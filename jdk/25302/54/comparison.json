{"files":[{"patch":"@@ -1508,0 +1508,8 @@\n+void* PosixSignals::get_signal_handler_for_signal(int sig) {\n+  struct sigaction oact;\n+  if (sigaction(sig, (struct sigaction*)nullptr, &oact) == -1) {\n+    return nullptr; \/\/ signal not installed\n+  }\n+  return get_signal_handler(&oact);\n+}\n+\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -55,0 +55,2 @@\n+  static void* get_signal_handler_for_signal(int sig);\n+\n","filename":"src\/hotspot\/os\/posix\/signals_posix.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-  return jt->jfr_thread_local()->has_sample_request();\n+  JfrThreadLocal* tl = jt->jfr_thread_local();\n+  return tl->has_sample_request() || tl->has_cpu_time_jfr_requests();\n","filename":"src\/hotspot\/share\/jfr\/jfr.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp\"\n@@ -172,0 +173,5 @@\n+JVM_ENTRY_NO_ENV(void, jfr_set_cpu_throttle(JNIEnv* env, jclass jvm, jdouble rate, jboolean auto_adapt))\n+  JfrEventSetting::set_enabled(JfrCPUTimeSampleEvent, rate > 0);\n+  JfrCPUTimeThreadSampling::set_rate(rate, auto_adapt == JNI_TRUE);\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -132,0 +132,2 @@\n+void JNICALL jfr_set_cpu_throttle(JNIEnv* env, jclass jvm, jdouble rate, jboolean auto_adapt);\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+      (char*)\"setCPUThrottle\", (char*)\"(DZ)V\", (void*)jfr_set_cpu_throttle,\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -965,0 +965,16 @@\n+  <Event name=\"CPUTimeSample\" category=\"Java Virtual Machine, Profiling\" label=\"CPU Time Method Sample\"\n+    description=\"Snapshot of a threads state from the CPU time sampler. The throttle can be either an upper bound for the event emission rate, e.g. 100\/s, or the cpu-time period, e.g. 10ms, with s, ms, us and ns supported as time units.\"\n+    throttle=\"true\" thread=\"false\" experimental=\"true\" startTime=\"false\">\n+    <Field type=\"StackTrace\" name=\"stackTrace\" label=\"Stack Trace\" \/>\n+    <Field type=\"Thread\" name=\"eventThread\" label=\"Thread\" \/>\n+    <Field type=\"boolean\" name=\"failed\" label=\"Failed\" description=\"Failed to obtain the stack trace\" \/>\n+    <Field type=\"Tickspan\" name=\"samplingPeriod\" label=\"CPU Time Sampling Period\"\/>\n+    <Field type=\"boolean\" name=\"biased\" label=\"Biased\" description=\"The sample is safepoint-biased\" \/>\n+  <\/Event>\n+\n+  <Event name=\"CPUTimeSamplesLost\" category=\"Java Virtual Machine, Profiling\" label=\"CPU Time Method Profiling Lost Samples\" description=\"Records that the CPU time sampler lost samples\"\n+    thread=\"false\" stackTrace=\"false\" startTime=\"false\" experimental=\"true\">\n+    <Field type=\"int\" name=\"lostSamples\" label=\"Lost Samples\" \/>\n+    <Field type=\"Thread\" name=\"eventThread\" label=\"Thread\" \/>\n+  <\/Event>\n+\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,768 @@\n+\/*\n+ * Copyright (c) 2025 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp\"\n+#include \"logging\/log.hpp\"\n+\n+\n+#if defined(LINUX)\n+#include \"jfr\/periodic\/sampling\/jfrThreadSampling.hpp\"\n+#include \"jfr\/support\/jfrThreadLocal.hpp\"\n+#include \"jfr\/utilities\/jfrTime.hpp\"\n+#include \"jfr\/utilities\/jfrThreadIterator.hpp\"\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n+#include \"jfrfiles\/jfrEventClasses.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/osThread.hpp\"\n+#include \"runtime\/safepointMechanism.inline.hpp\"\n+#include \"runtime\/threadSMR.hpp\"\n+#include \"runtime\/vmOperation.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+#include \"signals_posix.hpp\"\n+\n+static const int64_t AUTOADAPT_INTERVAL_MS = 100;\n+\n+static bool is_excluded(JavaThread* jt) {\n+  return jt->is_hidden_from_external_view() ||\n+         jt->jfr_thread_local()->is_excluded() ||\n+         jt->is_JfrRecorder_thread();\n+}\n+\n+static JavaThread* get_java_thread_if_valid() {\n+  Thread* raw_thread = Thread::current_or_null_safe();\n+  if (raw_thread == nullptr) {\n+    \/\/ probably while shutting down\n+    return nullptr;\n+  }\n+  assert(raw_thread->is_Java_thread(), \"invariant\");\n+  JavaThread* jt = JavaThread::cast(raw_thread);\n+  if (is_excluded(jt) || jt->is_exiting()) {\n+    return nullptr;\n+  }\n+  return jt;\n+}\n+\n+JfrCPUTimeTraceQueue::JfrCPUTimeTraceQueue(u4 capacity) :\n+  _capacity(capacity), _head(0), _lost_samples(0) {\n+  _data = JfrCHeapObj::new_array<JfrCPUTimeSampleRequest>(capacity);\n+}\n+\n+JfrCPUTimeTraceQueue::~JfrCPUTimeTraceQueue() {\n+  JfrCHeapObj::free(_data, _capacity * sizeof(JfrCPUTimeSampleRequest));\n+}\n+\n+bool JfrCPUTimeTraceQueue::enqueue(JfrCPUTimeSampleRequest& request) {\n+  assert(JavaThread::current()->jfr_thread_local()->is_cpu_time_jfr_enqueue_locked(), \"invariant\");\n+  assert(&JavaThread::current()->jfr_thread_local()->cpu_time_jfr_queue() == this, \"invariant\");\n+  u4 elementIndex;\n+  do {\n+    elementIndex = Atomic::load_acquire(&_head);\n+    if (elementIndex >= _capacity) {\n+      return false;\n+    }\n+  } while (Atomic::cmpxchg(&_head, elementIndex, elementIndex + 1) != elementIndex);\n+  _data[elementIndex] = request;\n+  return true;\n+}\n+\n+JfrCPUTimeSampleRequest& JfrCPUTimeTraceQueue::at(u4 index) {\n+  assert(index < _head, \"invariant\");\n+  return _data[index];\n+}\n+\n+static volatile u4 _lost_samples_sum = 0;\n+\n+u4 JfrCPUTimeTraceQueue::size() const {\n+  return Atomic::load_acquire(&_head);\n+}\n+\n+void JfrCPUTimeTraceQueue::set_size(u4 size) {\n+  Atomic::release_store(&_head, size);\n+}\n+\n+u4 JfrCPUTimeTraceQueue::capacity() const {\n+  return _capacity;\n+}\n+\n+void JfrCPUTimeTraceQueue::set_capacity(u4 capacity) {\n+  _head = 0;\n+  JfrCHeapObj::free(_data, _capacity * sizeof(JfrCPUTimeSampleRequest));\n+  _data = JfrCHeapObj::new_array<JfrCPUTimeSampleRequest>(capacity);\n+  _capacity = capacity;\n+}\n+\n+bool JfrCPUTimeTraceQueue::is_empty() const {\n+  return Atomic::load_acquire(&_head) == 0;\n+}\n+\n+u4 JfrCPUTimeTraceQueue::lost_samples() const {\n+  return Atomic::load(&_lost_samples);\n+}\n+\n+void JfrCPUTimeTraceQueue::increment_lost_samples() {\n+  Atomic::inc(&_lost_samples_sum);\n+  Atomic::inc(&_lost_samples);\n+}\n+\n+u4 JfrCPUTimeTraceQueue::get_and_reset_lost_samples() {\n+  return Atomic::xchg(&_lost_samples, (u4)0);\n+}\n+\n+void JfrCPUTimeTraceQueue::resize(u4 capacity) {\n+  if (capacity != _capacity) {\n+    set_capacity(capacity);\n+  }\n+}\n+\n+void JfrCPUTimeTraceQueue::resize_for_period(u4 period_millis) {\n+  u4 capacity = CPU_TIME_QUEUE_CAPACITY;\n+  if (period_millis > 0 && period_millis < 10) {\n+    capacity = (u4) ((double) capacity * 10 \/ period_millis);\n+  }\n+  resize(capacity);\n+}\n+\n+void JfrCPUTimeTraceQueue::clear() {\n+  Atomic::release_store(&_head, (u4)0);\n+}\n+\n+static int64_t compute_sampling_period(double rate) {\n+  if (rate == 0) {\n+    return 0;\n+  }\n+  return os::active_processor_count() * 1000000000.0 \/ rate;\n+}\n+\n+class JfrCPUSamplerThread : public NonJavaThread {\n+  friend class JfrCPUTimeThreadSampling;\n+ private:\n+  Semaphore _sample;\n+  NonJavaThread* _sampler_thread;\n+  double _rate;\n+  bool _auto_adapt;\n+  volatile int64_t _current_sampling_period_ns;\n+  volatile bool _disenrolled;\n+  \/\/ top bit is used to indicate that no signal handler should proceed\n+  volatile u4 _active_signal_handlers;\n+  volatile bool _is_async_processing_of_cpu_time_jfr_requests_triggered;\n+  volatile bool _warned_about_timer_creation_failure;\n+  volatile bool _signal_handler_installed;\n+\n+  static const u4 STOP_SIGNAL_BIT = 0x80000000;\n+\n+  JfrCPUSamplerThread(double rate, bool auto_adapt);\n+\n+  void start_thread();\n+\n+  void enroll();\n+  void disenroll();\n+  void update_all_thread_timers();\n+\n+  void auto_adapt_period_if_needed();\n+\n+  void set_rate(double rate, bool auto_adapt);\n+  int64_t get_sampling_period() const { return Atomic::load(&_current_sampling_period_ns); };\n+\n+  void sample_thread(JfrSampleRequest& request, void* ucontext, JavaThread* jt, JfrThreadLocal* tl);\n+\n+  \/\/ process the queues for all threads that are in native state (and requested to be processed)\n+  void stackwalk_threads_in_native();\n+  bool create_timer_for_thread(JavaThread* thread, timer_t &timerid);\n+\n+  void stop_signal_handlers();\n+\n+  \/\/ returns false if the stop signal bit was set, true otherwise\n+  bool increment_signal_handler_count();\n+\n+  void decrement_signal_handler_count();\n+\n+  void allow_signal_handlers();\n+\n+protected:\n+  virtual void post_run();\n+public:\n+  virtual const char* name() const { return \"JFR CPU Sampler Thread\"; }\n+  virtual const char* type_name() const { return \"JfrCPUTimeSampler\"; }\n+  void run();\n+  void on_javathread_create(JavaThread* thread);\n+  void on_javathread_terminate(JavaThread* thread);\n+\n+  void handle_timer_signal(siginfo_t* info, void* context);\n+  bool init_timers();\n+  void stop_timer();\n+\n+  void trigger_async_processing_of_cpu_time_jfr_requests();\n+};\n+\n+JfrCPUSamplerThread::JfrCPUSamplerThread(double rate, bool auto_adapt) :\n+  _sample(),\n+  _sampler_thread(nullptr),\n+  _rate(rate),\n+  _auto_adapt(auto_adapt),\n+  _current_sampling_period_ns(compute_sampling_period(rate)),\n+  _disenrolled(true),\n+  _active_signal_handlers(STOP_SIGNAL_BIT),\n+  _is_async_processing_of_cpu_time_jfr_requests_triggered(false),\n+  _warned_about_timer_creation_failure(false),\n+  _signal_handler_installed(false) {\n+  assert(rate >= 0, \"invariant\");\n+}\n+\n+void JfrCPUSamplerThread::trigger_async_processing_of_cpu_time_jfr_requests() {\n+  Atomic::release_store(&_is_async_processing_of_cpu_time_jfr_requests_triggered, true);\n+}\n+\n+void JfrCPUSamplerThread::on_javathread_create(JavaThread* thread) {\n+  if (thread->is_hidden_from_external_view() || thread->is_JfrRecorder_thread() ||\n+      !Atomic::load_acquire(&_signal_handler_installed)) {\n+    return;\n+  }\n+  JfrThreadLocal* tl = thread->jfr_thread_local();\n+  assert(tl != nullptr, \"invariant\");\n+  tl->cpu_time_jfr_queue().resize_for_period(_current_sampling_period_ns \/ 1000000);\n+  timer_t timerid;\n+  if (create_timer_for_thread(thread, timerid)) {\n+    tl->set_cpu_timer(&timerid);\n+  } else {\n+    if (!Atomic::or_then_fetch(&_warned_about_timer_creation_failure, true)) {\n+      log_warning(jfr)(\"Failed to create timer for a thread\");\n+    }\n+    tl->deallocate_cpu_time_jfr_queue();\n+  }\n+}\n+\n+void JfrCPUSamplerThread::on_javathread_terminate(JavaThread* thread) {\n+  JfrThreadLocal* tl = thread->jfr_thread_local();\n+  assert(tl != nullptr, \"invariant\");\n+  timer_t* timer = tl->cpu_timer();\n+  if (timer == nullptr) {\n+    return; \/\/ no timer was created for this thread\n+  }\n+  tl->unset_cpu_timer();\n+  tl->deallocate_cpu_time_jfr_queue();\n+  s4 lost_samples = tl->cpu_time_jfr_queue().lost_samples();\n+  if (lost_samples > 0) {\n+    JfrCPUTimeThreadSampling::send_lost_event(JfrTicks::now(), JfrThreadLocal::thread_id(thread), lost_samples);\n+  }\n+}\n+\n+void JfrCPUSamplerThread::start_thread() {\n+  if (os::create_thread(this, os::os_thread)) {\n+    os::start_thread(this);\n+  } else {\n+    log_error(jfr)(\"Failed to create thread for thread sampling\");\n+  }\n+}\n+\n+void JfrCPUSamplerThread::enroll() {\n+  if (Atomic::cmpxchg(&_disenrolled, true, false)) {\n+    Atomic::store(&_warned_about_timer_creation_failure, false);\n+    allow_signal_handlers();\n+    log_trace(jfr)(\"Enrolling CPU thread sampler\");\n+    _sample.signal();\n+    if (!init_timers()) {\n+      log_error(jfr)(\"Failed to initialize timers for CPU thread sampler\");\n+      disenroll();\n+      return;\n+    }\n+    log_trace(jfr)(\"Enrolled CPU thread sampler\");\n+  }\n+}\n+\n+void JfrCPUSamplerThread::disenroll() {\n+  if (!Atomic::cmpxchg(&_disenrolled, false, true)) {\n+    log_trace(jfr)(\"Disenrolling CPU thread sampler\");\n+    if (Atomic::fetch_then_and(&_signal_handler_installed, false)) {\n+      stop_timer();\n+      stop_signal_handlers();\n+    }\n+    _sample.wait();\n+    log_trace(jfr)(\"Disenrolled CPU thread sampler\");\n+  }\n+}\n+\n+void JfrCPUSamplerThread::run() {\n+  assert(_sampler_thread == nullptr, \"invariant\");\n+  _sampler_thread = this;\n+  int64_t last_auto_adapt_check = os::javaTimeNanos();\n+  while (true) {\n+    if (!_sample.trywait()) {\n+      \/\/ disenrolled\n+      _sample.wait();\n+    }\n+    _sample.signal();\n+\n+    if (os::javaTimeNanos() - last_auto_adapt_check > AUTOADAPT_INTERVAL_MS * 1000000) {\n+      auto_adapt_period_if_needed();\n+      last_auto_adapt_check = os::javaTimeNanos();\n+    }\n+\n+    if (Atomic::cmpxchg(&_is_async_processing_of_cpu_time_jfr_requests_triggered, true, false)) {\n+      stackwalk_threads_in_native();\n+    }\n+    os::naked_sleep(100);\n+  }\n+}\n+\n+void JfrCPUSamplerThread::stackwalk_threads_in_native() {\n+  ResourceMark rm;\n+  ThreadsListHandle tlh;\n+  Thread* current = Thread::current();\n+  for (size_t i = 0; i < tlh.list()->length(); i++) {\n+    JavaThread* jt = tlh.list()->thread_at(i);\n+    JfrThreadLocal* tl = jt->jfr_thread_local();\n+    if (tl->wants_async_processing_of_cpu_time_jfr_requests()) {\n+      if (jt->thread_state() != _thread_in_native || !tl->try_acquire_cpu_time_jfr_dequeue_lock()) {\n+        tl->set_do_async_processing_of_cpu_time_jfr_requests(false);\n+        continue;\n+      }\n+      if (jt->has_last_Java_frame()) {\n+        JfrThreadSampling::process_cpu_time_request(jt, tl, current, false);\n+      } else {\n+        tl->set_do_async_processing_of_cpu_time_jfr_requests(false);\n+      }\n+      tl->release_cpu_time_jfr_queue_lock();\n+    }\n+  }\n+}\n+\n+static volatile size_t count = 0;\n+\n+void JfrCPUTimeThreadSampling::send_empty_event(const JfrTicks &start_time, traceid tid, Tickspan cpu_time_period) {\n+  EventCPUTimeSample event(UNTIMED);\n+  event.set_failed(true);\n+  event.set_starttime(start_time);\n+  event.set_eventThread(tid);\n+  event.set_stackTrace(0);\n+  event.set_samplingPeriod(cpu_time_period);\n+  event.set_biased(false);\n+  event.commit();\n+}\n+\n+\n+static volatile size_t biased_count = 0;\n+\n+void JfrCPUTimeThreadSampling::send_event(const JfrTicks &start_time, traceid sid, traceid tid, Tickspan cpu_time_period, bool biased) {\n+  EventCPUTimeSample event(UNTIMED);\n+  event.set_failed(false);\n+  event.set_starttime(start_time);\n+  event.set_eventThread(tid);\n+  event.set_stackTrace(sid);\n+  event.set_samplingPeriod(cpu_time_period);\n+  event.set_biased(biased);\n+  event.commit();\n+  Atomic::inc(&count);\n+  if (biased) {\n+    Atomic::inc(&biased_count);\n+  }\n+  if (Atomic::load(&count) % 1000 == 0) {\n+    log_debug(jfr)(\"CPU thread sampler sent %zu events, lost %d, biased %zu\\n\", Atomic::load(&count), Atomic::load(&_lost_samples_sum), Atomic::load(&biased_count));\n+  }\n+}\n+\n+void JfrCPUTimeThreadSampling::send_lost_event(const JfrTicks &time, traceid tid, s4 lost_samples) {\n+  if (!EventCPUTimeSamplesLost::is_enabled()) {\n+    return;\n+  }\n+  EventCPUTimeSamplesLost event(UNTIMED);\n+  event.set_starttime(time);\n+  event.set_lostSamples(lost_samples);\n+  event.set_eventThread(tid);\n+  event.commit();\n+}\n+\n+void JfrCPUSamplerThread::post_run() {\n+  this->NonJavaThread::post_run();\n+  delete this;\n+}\n+\n+static JfrCPUTimeThreadSampling* _instance = nullptr;\n+\n+JfrCPUTimeThreadSampling& JfrCPUTimeThreadSampling::instance() {\n+  return *_instance;\n+}\n+\n+JfrCPUTimeThreadSampling* JfrCPUTimeThreadSampling::create() {\n+  assert(_instance == nullptr, \"invariant\");\n+  _instance = new JfrCPUTimeThreadSampling();\n+  return _instance;\n+}\n+\n+void JfrCPUTimeThreadSampling::destroy() {\n+  if (_instance != nullptr) {\n+    delete _instance;\n+    _instance = nullptr;\n+  }\n+}\n+\n+JfrCPUTimeThreadSampling::JfrCPUTimeThreadSampling() : _sampler(nullptr) {}\n+\n+JfrCPUTimeThreadSampling::~JfrCPUTimeThreadSampling() {\n+  if (_sampler != nullptr) {\n+    _sampler->disenroll();\n+  }\n+}\n+\n+void JfrCPUTimeThreadSampling::create_sampler(double rate, bool auto_adapt) {\n+  assert(_sampler == nullptr, \"invariant\");\n+  _sampler = new JfrCPUSamplerThread(rate, auto_adapt);\n+  _sampler->start_thread();\n+  _sampler->enroll();\n+}\n+\n+void JfrCPUTimeThreadSampling::update_run_state(double rate, bool auto_adapt) {\n+  if (rate != 0) {\n+    if (_sampler == nullptr) {\n+      create_sampler(rate, auto_adapt);\n+    } else {\n+      _sampler->set_rate(rate, auto_adapt);\n+      _sampler->enroll();\n+    }\n+    return;\n+  }\n+  if (_sampler != nullptr) {\n+    _sampler->set_rate(rate \/* 0 *\/, auto_adapt);\n+    _sampler->disenroll();\n+  }\n+}\n+\n+void JfrCPUTimeThreadSampling::set_rate(double rate, bool auto_adapt) {\n+  assert(rate >= 0, \"invariant\");\n+  if (_instance == nullptr) {\n+    return;\n+  }\n+  instance().set_rate_value(rate, auto_adapt);\n+}\n+\n+void JfrCPUTimeThreadSampling::set_rate_value(double rate, bool auto_adapt) {\n+  if (_sampler != nullptr) {\n+    _sampler->set_rate(rate, auto_adapt);\n+  }\n+  update_run_state(rate, auto_adapt);\n+}\n+\n+void JfrCPUTimeThreadSampling::on_javathread_create(JavaThread *thread) {\n+  if (_instance != nullptr && _instance->_sampler != nullptr) {\n+    _instance->_sampler->on_javathread_create(thread);\n+  }\n+}\n+\n+void JfrCPUTimeThreadSampling::on_javathread_terminate(JavaThread *thread) {\n+  if (_instance != nullptr && _instance->_sampler != nullptr) {\n+    _instance->_sampler->on_javathread_terminate(thread);\n+  }\n+}\n+\n+void JfrCPUTimeThreadSampling::trigger_async_processing_of_cpu_time_jfr_requests() {\n+  if (_instance != nullptr && _instance->_sampler != nullptr) {\n+    _instance->_sampler->trigger_async_processing_of_cpu_time_jfr_requests();\n+  }\n+}\n+\n+void handle_timer_signal(int signo, siginfo_t* info, void* context) {\n+  assert(_instance != nullptr, \"invariant\");\n+  _instance->handle_timer_signal(info, context);\n+}\n+\n+\n+void JfrCPUTimeThreadSampling::handle_timer_signal(siginfo_t* info, void* context) {\n+  if (info->si_code != SI_TIMER) {\n+    \/\/ not the signal we are interested in\n+    return;\n+  }\n+  assert(_sampler != nullptr, \"invariant\");\n+\n+  if (!_sampler->increment_signal_handler_count()) {\n+    return;\n+  }\n+  _sampler->handle_timer_signal(info, context);\n+  _sampler->decrement_signal_handler_count();\n+}\n+\n+void JfrCPUSamplerThread::sample_thread(JfrSampleRequest& request, void* ucontext, JavaThread* jt, JfrThreadLocal* tl) {\n+  JfrSampleRequestBuilder::build_cpu_time_sample_request(request, ucontext, jt, jt->jfr_thread_local());\n+}\n+\n+static bool check_state(JavaThread* thread) {\n+  switch (thread->thread_state()) {\n+    case _thread_in_Java:\n+    case _thread_in_native:\n+      return true;\n+    default:\n+      return false;\n+  }\n+}\n+\n+void JfrCPUSamplerThread::handle_timer_signal(siginfo_t* info, void* context) {\n+  JavaThread* jt = get_java_thread_if_valid();\n+  if (jt == nullptr) {\n+    return;\n+  }\n+  JfrThreadLocal* tl = jt->jfr_thread_local();\n+  JfrCPUTimeTraceQueue& queue = tl->cpu_time_jfr_queue();\n+  if (!check_state(jt)) {\n+    queue.increment_lost_samples();\n+    return;\n+  }\n+  if (!tl->try_acquire_cpu_time_jfr_enqueue_lock()) {\n+    queue.increment_lost_samples();\n+    return;\n+  }\n+\n+  JfrCPUTimeSampleRequest request;\n+  \/\/ the sampling period might be too low for the current Linux configuration\n+  \/\/ so samples might be skipped and we have to compute the actual period\n+  int64_t period = get_sampling_period() * (info->si_overrun + 1);\n+  request._cpu_time_period = Ticks(period \/ 1000000000.0 * JfrTime::frequency()) - Ticks(0);\n+  sample_thread(request._request, context, jt, tl);\n+\n+  if (queue.enqueue(request)) {\n+    if (queue.size() == 1) {\n+      tl->set_has_cpu_time_jfr_requests(true);\n+      SafepointMechanism::arm_local_poll_release(jt);\n+    }\n+  } else {\n+    queue.increment_lost_samples();\n+  }\n+\n+  if (jt->thread_state() == _thread_in_native) {\n+      if (!tl->wants_async_processing_of_cpu_time_jfr_requests()) {\n+        tl->set_do_async_processing_of_cpu_time_jfr_requests(true);\n+        JfrCPUTimeThreadSampling::trigger_async_processing_of_cpu_time_jfr_requests();\n+      }\n+  } else {\n+    tl->set_do_async_processing_of_cpu_time_jfr_requests(false);\n+  }\n+\n+  tl->release_cpu_time_jfr_queue_lock();\n+}\n+\n+static const int SIG = SIGPROF;\n+\n+static void set_timer_time(timer_t timerid, int64_t period_nanos) {\n+  struct itimerspec its;\n+  if (period_nanos == 0) {\n+    its.it_interval.tv_sec = 0;\n+    its.it_interval.tv_nsec = 0;\n+  } else {\n+    its.it_interval.tv_sec = period_nanos \/ NANOSECS_PER_SEC;\n+    its.it_interval.tv_nsec = period_nanos % NANOSECS_PER_SEC;\n+  }\n+  its.it_value = its.it_interval;\n+  if (timer_settime(timerid, 0, &its, nullptr) == -1) {\n+    warning(\"Failed to set timer for thread sampling: %s\", os::strerror(os::get_last_error()));\n+  }\n+}\n+\n+bool JfrCPUSamplerThread::create_timer_for_thread(JavaThread* thread, timer_t& timerid) {\n+  struct sigevent sev;\n+  sev.sigev_notify = SIGEV_THREAD_ID;\n+  sev.sigev_signo = SIG;\n+  sev.sigev_value.sival_ptr = nullptr;\n+  ((int*)&sev.sigev_notify)[1] = thread->osthread()->thread_id();\n+  clockid_t clock;\n+  int err = pthread_getcpuclockid(thread->osthread()->pthread_id(), &clock);\n+  if (err != 0) {\n+    log_error(jfr)(\"Failed to get clock for thread sampling: %s\", os::strerror(err));\n+    return false;\n+  }\n+  if (timer_create(clock, &sev, &timerid) < 0) {\n+    return false;\n+  }\n+  int64_t period = get_sampling_period();\n+  if (period != 0) {\n+    set_timer_time(timerid, period);\n+  }\n+  return true;\n+}\n+\n+\n+void JfrCPUSamplerThread::stop_signal_handlers() {\n+  \/\/ set the stop signal bit\n+  Atomic::or_then_fetch(&_active_signal_handlers, STOP_SIGNAL_BIT, memory_order_acq_rel);\n+  while (Atomic::load_acquire(&_active_signal_handlers) > STOP_SIGNAL_BIT) {\n+    \/\/ wait for all signal handlers to finish\n+    os::naked_short_nanosleep(1000);\n+  }\n+}\n+\n+\/\/ returns false if the stop signal bit was set, true otherwise\n+bool JfrCPUSamplerThread::increment_signal_handler_count() {\n+  \/\/ increment the count of active signal handlers\n+  u4 old_value = Atomic::fetch_then_add(&_active_signal_handlers, (u4)1, memory_order_acq_rel);\n+  if ((old_value & STOP_SIGNAL_BIT) != 0) {\n+    \/\/ if the stop signal bit was set, we are not allowed to increment\n+    Atomic::dec(&_active_signal_handlers, memory_order_acq_rel);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+void JfrCPUSamplerThread::decrement_signal_handler_count() {\n+  Atomic::dec(&_active_signal_handlers, memory_order_acq_rel);\n+}\n+\n+void JfrCPUSamplerThread::allow_signal_handlers() {\n+  Atomic::release_store(&_active_signal_handlers, (u4)0);\n+}\n+\n+class VM_CPUTimeSamplerThreadInitializer : public VM_Operation {\n+ private:\n+  JfrCPUSamplerThread *_sampler;\n+ public:\n+\n+  VM_CPUTimeSamplerThreadInitializer(JfrCPUSamplerThread* sampler) : _sampler(sampler) {\n+  }\n+\n+  VMOp_Type type() const { return VMOp_CPUTimeSamplerThreadInitializer; }\n+  void doit() {\n+    JfrJavaThreadIterator iter;\n+    while (iter.has_next()) {\n+      _sampler->on_javathread_create(iter.next());\n+    }\n+  };\n+};\n+\n+bool JfrCPUSamplerThread::init_timers() {\n+  \/\/ install sig handler for sig\n+  void* prev_handler = PosixSignals::get_signal_handler_for_signal(SIG);\n+  if ((prev_handler != SIG_DFL && prev_handler != SIG_IGN && prev_handler != (void*)::handle_timer_signal) ||\n+      PosixSignals::install_generic_signal_handler(SIG, (void*)::handle_timer_signal) == (void*)-1) {\n+    log_error(jfr)(\"CPUTimeSample events will not be recorded: %p\", prev_handler);\n+    return false;\n+  }\n+  Atomic::release_store(&_signal_handler_installed, true);\n+  VM_CPUTimeSamplerThreadInitializer op(this);\n+  VMThread::execute(&op);\n+  return true;\n+}\n+\n+class VM_CPUTimeSamplerThreadTerminator : public VM_Operation {\n+ private:\n+  JfrCPUSamplerThread *_sampler;\n+ public:\n+\n+  VM_CPUTimeSamplerThreadTerminator(JfrCPUSamplerThread* sampler) : _sampler(sampler) {\n+  }\n+\n+  VMOp_Type type() const { return VMOp_CPUTimeSamplerThreadTerminator; }\n+  void doit() {\n+    JfrJavaThreadIterator iter;\n+    while (iter.has_next()) {\n+      JavaThread *thread = iter.next();\n+      JfrThreadLocal* tl = thread->jfr_thread_local();\n+      timer_t* timer = tl->cpu_timer();\n+      if (timer == nullptr) {\n+        continue;\n+      }\n+      timer_delete(*timer);\n+      tl->deallocate_cpu_time_jfr_queue();\n+      tl->unset_cpu_timer();\n+    }\n+  };\n+};\n+\n+void JfrCPUSamplerThread::stop_timer() {\n+  VM_CPUTimeSamplerThreadTerminator op(this);\n+  VMThread::execute(&op);\n+}\n+\n+void JfrCPUSamplerThread::auto_adapt_period_if_needed() {\n+  int64_t current_period = get_sampling_period();\n+  if (_auto_adapt || current_period == -1) {\n+    int64_t period = compute_sampling_period(_rate);\n+    if (period != current_period) {\n+      Atomic::store(&_current_sampling_period_ns, period);\n+      update_all_thread_timers();\n+    }\n+  }\n+}\n+\n+void JfrCPUSamplerThread::set_rate(double rate, bool auto_adapt) {\n+  _rate = rate;\n+  _auto_adapt = auto_adapt;\n+  if (_rate > 0 && Atomic::load_acquire(&_disenrolled) == false) {\n+    auto_adapt_period_if_needed();\n+  } else {\n+    Atomic::store(&_current_sampling_period_ns, compute_sampling_period(rate));\n+  }\n+}\n+\n+void JfrCPUSamplerThread::update_all_thread_timers() {\n+  int64_t period_millis = get_sampling_period();\n+  ThreadsListHandle tlh;\n+  for (size_t i = 0; i < tlh.length(); i++) {\n+    JavaThread* thread = tlh.thread_at(i);\n+    JfrThreadLocal* tl = thread->jfr_thread_local();\n+    assert(tl != nullptr, \"invariant\");\n+    timer_t* timer = tl->cpu_timer();\n+    if (timer != nullptr) {\n+      set_timer_time(*timer, period_millis);\n+    }\n+  }\n+}\n+\n+#else\n+\n+static void warn() {\n+  static bool displayed_warning = false;\n+  if (!displayed_warning) {\n+    warning(\"CPU time method sampling not supported in JFR on your platform\");\n+    displayed_warning = true;\n+  }\n+}\n+\n+static JfrCPUTimeThreadSampling* _instance = nullptr;\n+\n+JfrCPUTimeThreadSampling& JfrCPUTimeThreadSampling::instance() {\n+  return *_instance;\n+}\n+\n+JfrCPUTimeThreadSampling* JfrCPUTimeThreadSampling::create() {\n+  _instance = new JfrCPUTimeThreadSampling();\n+  return _instance;\n+}\n+\n+void JfrCPUTimeThreadSampling::destroy() {\n+  delete _instance;\n+  _instance = nullptr;\n+}\n+\n+void JfrCPUTimeThreadSampling::set_rate(double rate, bool auto_adapt) {\n+  if (rate != 0) {\n+    warn();\n+  }\n+}\n+\n+void JfrCPUTimeThreadSampling::on_javathread_create(JavaThread* thread) {\n+}\n+\n+void JfrCPUTimeThreadSampling::on_javathread_terminate(JavaThread* thread) {\n+}\n+\n+#endif \/\/ defined(LINUX) && defined(INCLUDE_JFR)\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.cpp","additions":768,"deletions":0,"binary":false,"changes":768,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2025 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_PERIODIC_SAMPLING_JFRCPUTIMETHREADSAMPLER_HPP\n+#define SHARE_JFR_PERIODIC_SAMPLING_JFRCPUTIMETHREADSAMPLER_HPP\n+\n+#include \"jfr\/utilities\/jfrAllocation.hpp\"\n+\n+class JavaThread;\n+\n+#if defined(LINUX)\n+\n+#include \"jfr\/periodic\/sampling\/jfrSampleRequest.hpp\"\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n+\n+struct JfrCPUTimeSampleRequest {\n+  JfrSampleRequest _request;\n+  Tickspan _cpu_time_period;\n+\n+  JfrCPUTimeSampleRequest() {}\n+};\n+\n+\/\/ Fixed size async-signal-safe SPSC linear queue backed by an array.\n+\/\/ Designed to be only used under lock and read linearly\n+class JfrCPUTimeTraceQueue {\n+\n+  \/\/ the default queue capacity, scaled if the sampling period is smaller than 10ms\n+  \/\/ when the thread is started\n+  static const u4 CPU_TIME_QUEUE_CAPACITY = 500;\n+\n+  JfrCPUTimeSampleRequest* _data;\n+  u4 _capacity;\n+  \/\/ next unfilled index\n+  volatile u4 _head;\n+\n+  volatile u4 _lost_samples;\n+\n+public:\n+  JfrCPUTimeTraceQueue(u4 capacity);\n+\n+  ~JfrCPUTimeTraceQueue();\n+\n+  \/\/ signal safe, but can't be interleaved with dequeue\n+  bool enqueue(JfrCPUTimeSampleRequest& trace);\n+\n+  JfrCPUTimeSampleRequest& at(u4 index);\n+\n+  u4 size() const;\n+\n+  void set_size(u4 size);\n+\n+  u4 capacity() const;\n+\n+  \/\/ deletes all samples in the queue\n+  void set_capacity(u4 capacity);\n+\n+  bool is_empty() const;\n+\n+  u4 lost_samples() const;\n+\n+  void increment_lost_samples();\n+\n+  \/\/ returns the previous lost samples count\n+  u4 get_and_reset_lost_samples();\n+\n+  void resize(u4 capacity);\n+\n+  void resize_for_period(u4 period_millis);\n+\n+  void clear();\n+\n+};\n+\n+\n+class JfrCPUSamplerThread;\n+\n+class JfrCPUTimeThreadSampling : public JfrCHeapObj {\n+  friend class JfrRecorder;\n+ private:\n+\n+  JfrCPUSamplerThread* _sampler;\n+\n+  void create_sampler(double rate, bool auto_adapt);\n+  void set_rate_value(double rate, bool auto_adapt);\n+\n+  JfrCPUTimeThreadSampling();\n+  ~JfrCPUTimeThreadSampling();\n+\n+  static JfrCPUTimeThreadSampling& instance();\n+  static JfrCPUTimeThreadSampling* create();\n+  static void destroy();\n+\n+  void update_run_state(double rate, bool auto_adapt);\n+\n+ public:\n+  static void set_rate(double rate, bool auto_adapt);\n+\n+  static void on_javathread_create(JavaThread* thread);\n+  static void on_javathread_terminate(JavaThread* thread);\n+  void handle_timer_signal(siginfo_t* info, void* context);\n+\n+  static void send_empty_event(const JfrTicks& start_time, traceid tid, Tickspan cpu_time_period);\n+  static void send_event(const JfrTicks& start_time, traceid sid, traceid tid, Tickspan cpu_time_period, bool biased);\n+  static void send_lost_event(const JfrTicks& time, traceid tid, s4 lost_samples);\n+\n+  static void trigger_async_processing_of_cpu_time_jfr_requests();\n+};\n+\n+#else\n+\n+\/\/ a basic implementation on other platforms that\n+\/\/ emits warnings\n+\n+class JfrCPUTimeThreadSampling : public JfrCHeapObj {\n+  friend class JfrRecorder;\n+private:\n+  static JfrCPUTimeThreadSampling& instance();\n+  static JfrCPUTimeThreadSampling* create();\n+  static void destroy();\n+\n+ public:\n+  static void set_rate(double rate, bool auto_adapt);\n+\n+  static void on_javathread_create(JavaThread* thread);\n+  static void on_javathread_terminate(JavaThread* thread);\n+};\n+\n+#endif \/\/ defined(LINUX)\n+\n+\n+#endif \/\/ SHARE_JFR_PERIODIC_SAMPLING_JFRCPUTIMETHREADSAMPLER_HPP\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -174,1 +174,1 @@\n-  assert(jt->thread_state() == _thread_in_Java, \"invariant\");\n+  assert(jt->thread_state() == _thread_in_Java || jt->thread_state() == _thread_in_native, \"invariant\");\n@@ -306,0 +306,29 @@\n+\n+\n+\/\/ A biased sample request is denoted by an empty bcp and an empty pc.\n+static inline void set_cpu_time_biased_sample(JfrSampleRequest& request, JavaThread* jt) {\n+  if (request._sample_bcp != nullptr) {\n+    request._sample_bcp = nullptr;\n+  }\n+  assert(request._sample_bcp == nullptr, \"invariant\");\n+  request._sample_pc = nullptr;\n+}\n+\n+void JfrSampleRequestBuilder::build_cpu_time_sample_request(JfrSampleRequest& request,\n+                                                            void* ucontext,\n+                                                            JavaThread* jt,\n+                                                            JfrThreadLocal* tl) {\n+  assert(jt != nullptr, \"invariant\");\n+\n+  \/\/ Prioritize the ljf, if one exists.\n+  request._sample_sp = jt->last_Java_sp();\n+  if (request._sample_sp == nullptr || !build_from_ljf(request, tl, jt)) {\n+    intptr_t* fp;\n+    request._sample_pc = os::fetch_frame_from_context(ucontext, reinterpret_cast<intptr_t**>(&request._sample_sp), &fp);\n+    assert(sp_in_stack(request, jt), \"invariant\");\n+    if (!build(request, fp, jt)) {\n+      set_cpu_time_biased_sample(request, jt);\n+    }\n+  }\n+  request._sample_ticks = JfrTicks::now();\n+}\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrSampleRequest.cpp","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -84,0 +84,4 @@\n+  static void build_cpu_time_sample_request(JfrSampleRequest &request,\n+                                            void* ucontext,\n+                                            JavaThread* jt,\n+                                            JfrThreadLocal* tl);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrSampleRequest.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp\"\n@@ -164,1 +165,1 @@\n-static bool compute_top_frame(const JfrSampleRequest& request, frame& top_frame, bool& in_continuation, JavaThread* jt) {\n+static bool compute_top_frame(const JfrSampleRequest& request, frame& top_frame, bool& in_continuation, JavaThread* jt, bool& biased) {\n@@ -181,0 +182,1 @@\n+    biased = true;\n@@ -230,0 +232,2 @@\n+  biased = true;\n+\n@@ -253,0 +257,1 @@\n+          biased = false;\n@@ -273,0 +278,1 @@\n+  bool biased = false;\n@@ -274,1 +280,1 @@\n-  if (!compute_top_frame(request, top_frame, in_continuation, jt)) {\n+  if (!compute_top_frame(request, top_frame, in_continuation, jt, biased)) {\n@@ -296,0 +302,36 @@\n+#ifdef LINUX\n+static void record_cpu_time_thread(const JfrCPUTimeSampleRequest& request, const JfrTicks& now, const JfrThreadLocal* tl, JavaThread* jt, Thread* current) {\n+  assert(jt != nullptr, \"invariant\");\n+  assert(tl != nullptr, \"invariant\");\n+  assert(current != nullptr, \"invariant\");\n+  frame top_frame;\n+  bool biased = false;\n+  bool in_continuation = false;\n+  bool could_compute_top_frame = compute_top_frame(request._request, top_frame, in_continuation, jt, biased);\n+  const traceid tid = in_continuation ? tl->vthread_id_with_epoch_update(jt) : JfrThreadLocal::jvm_thread_id(jt);\n+\n+  if (!could_compute_top_frame) {\n+    JfrCPUTimeThreadSampling::send_empty_event(request._request._sample_ticks, tid, request._cpu_time_period);\n+    return;\n+  }\n+  traceid sid;\n+  {\n+    ResourceMark rm(current);\n+    JfrStackTrace stacktrace;\n+    if (!stacktrace.record(jt, top_frame, in_continuation, request._request)) {\n+      \/\/ Unable to record stacktrace. Fail.\n+      JfrCPUTimeThreadSampling::send_empty_event(request._request._sample_ticks, tid, request._cpu_time_period);\n+      return;\n+    }\n+    sid = JfrStackTraceRepository::add(stacktrace);\n+  }\n+  assert(sid != 0, \"invariant\");\n+\n+\n+  JfrCPUTimeThreadSampling::send_event(request._request._sample_ticks, sid, tid, request._cpu_time_period, biased);\n+  if (current == jt) {\n+    send_safepoint_latency_event(request._request, now, sid, jt);\n+  }\n+}\n+#endif\n+\n@@ -311,0 +353,61 @@\n+static void drain_enqueued_cpu_time_requests(const JfrTicks& now, JfrThreadLocal* tl, JavaThread* jt, Thread* current, bool lock) {\n+  assert(tl != nullptr, \"invariant\");\n+  assert(jt != nullptr, \"invariant\");\n+  assert(current != nullptr, \"invariant\");\n+#ifdef LINUX\n+  tl->set_do_async_processing_of_cpu_time_jfr_requests(false);\n+  if (lock) {\n+    tl->acquire_cpu_time_jfr_dequeue_lock();\n+  }\n+  JfrCPUTimeTraceQueue& queue = tl->cpu_time_jfr_queue();\n+  for (u4 i = 0; i < queue.size(); i++) {\n+    record_cpu_time_thread(queue.at(i), now, tl, jt, current);\n+  }\n+  queue.clear();\n+  assert(queue.is_empty(), \"invariant\");\n+  tl->set_has_cpu_time_jfr_requests(false);\n+  if (queue.lost_samples() > 0) {\n+    JfrCPUTimeThreadSampling::send_lost_event( now, JfrThreadLocal::thread_id(jt), queue.get_and_reset_lost_samples());\n+  }\n+  if (lock) {\n+    tl->release_cpu_time_jfr_queue_lock();\n+  }\n+#endif\n+}\n+\n+\/\/ Entry point for a thread that has been sampled in native code and has a pending JFR CPU time request.\n+void JfrThreadSampling::process_cpu_time_request(JavaThread* jt, JfrThreadLocal* tl, Thread* current, bool lock) {\n+  assert(jt != nullptr, \"invariant\");\n+\n+  const JfrTicks now = JfrTicks::now();\n+  drain_enqueued_cpu_time_requests(now, tl, jt, current, lock);\n+}\n+\n+static void drain_all_enqueued_requests(const JfrTicks& now, JfrThreadLocal* tl, JavaThread* jt, Thread* current) {\n+  assert(tl != nullptr, \"invariant\");\n+  assert(jt != nullptr, \"invariant\");\n+  assert(current != nullptr, \"invariant\");\n+  drain_enqueued_requests(now, tl, jt, current);\n+  if (tl->has_cpu_time_jfr_requests()) {\n+    drain_enqueued_cpu_time_requests(now, tl, jt, current, true);\n+  }\n+}\n+\n+class SampleMonitor : public StackObj {\n+ private:\n+  JfrThreadLocal* const _tl;\n+  Monitor* const _sample_monitor;\n+ public:\n+  SampleMonitor(JfrThreadLocal* tl) : _tl(tl), _sample_monitor(tl->sample_monitor()) {\n+    assert(tl != nullptr, \"invariant\");\n+    assert(_sample_monitor != nullptr, \"invariant\");\n+    _sample_monitor->lock_without_safepoint_check();\n+  }\n+  ~SampleMonitor() {\n+    assert_lock_strong(_sample_monitor);\n+    _tl->set_sample_state(NO_SAMPLE);\n+    _sample_monitor->notify_all();\n+    _sample_monitor->unlock();\n+  }\n+};\n+\n@@ -385,1 +488,1 @@\n-  drain_enqueued_requests(now, tl, jt, jt);\n+  drain_all_enqueued_requests(now, tl, jt, jt);\n@@ -387,0 +490,1 @@\n+\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampling.cpp","additions":107,"deletions":3,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+  friend class JfrCPUSamplerThread;\n@@ -38,0 +39,1 @@\n+  static void process_cpu_time_request(JavaThread* jt, JfrThreadLocal* tl, Thread* current, bool lock);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampling.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp\"\n@@ -307,0 +308,3 @@\n+  if (!create_cpu_time_thread_sampling()) {\n+    return false;\n+  }\n@@ -321,0 +325,1 @@\n+static JfrCPUTimeThreadSampling* _cpu_time_thread_sampling = nullptr;\n@@ -393,0 +398,6 @@\n+bool JfrRecorder::create_cpu_time_thread_sampling() {\n+  assert(_cpu_time_thread_sampling == nullptr, \"invariant\");\n+  _cpu_time_thread_sampling = JfrCPUTimeThreadSampling::create();\n+  return _cpu_time_thread_sampling != nullptr;\n+}\n+\n@@ -431,0 +442,4 @@\n+  if (_cpu_time_thread_sampling != nullptr) {\n+    JfrCPUTimeThreadSampling::destroy();\n+    _cpu_time_thread_sampling = nullptr;\n+  }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+  static bool create_cpu_time_thread_sampling();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+static JfrEventThrottler* _disabled_cpu_time_sample_throttler = nullptr;\n@@ -51,0 +52,3 @@\n+  assert(_disabled_cpu_time_sample_throttler == nullptr, \"invariant\");\n+  _disabled_cpu_time_sample_throttler = new JfrEventThrottler(JfrCPUTimeSampleEvent);\n+  _disabled_cpu_time_sample_throttler->_disabled = true;\n@@ -62,0 +66,2 @@\n+  delete _disabled_cpu_time_sample_throttler;\n+  _disabled_cpu_time_sample_throttler = nullptr;\n@@ -72,0 +78,1 @@\n+  assert(_disabled_cpu_time_sample_throttler != nullptr, \"Disabled CPU time throttler has not been properly initialized\");\n@@ -74,1 +81,1 @@\n-  assert(event_id == JfrObjectAllocationSampleEvent || event_id == JfrSafepointLatencyEvent, \"Event type has an unconfigured throttler\");\n+  assert(event_id == JfrObjectAllocationSampleEvent || event_id == JfrSafepointLatencyEvent || event_id == JfrCPUTimeSampleEvent, \"Event type has an unconfigured throttler\");\n@@ -81,0 +88,3 @@\n+  if (event_id == JfrCPUTimeSampleEvent) {\n+    return _disabled_cpu_time_sample_throttler;\n+  }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrEventThrottler.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp\"\n@@ -81,1 +82,9 @@\n-  _dead(false) {\n+  _dead(false)\n+#ifdef LINUX\n+  ,_cpu_timer(nullptr),\n+  _cpu_time_jfr_locked(UNLOCKED),\n+  _has_cpu_time_jfr_requests(false),\n+  _cpu_time_jfr_queue(0),\n+  _do_async_processing_of_cpu_time_jfr_requests(false)\n+#endif\n+  {\n@@ -132,1 +141,3 @@\n-      send_java_thread_start_event(JavaThread::cast(t));\n+      JavaThread *const jt = JavaThread::cast(t);\n+      JfrCPUTimeThreadSampling::on_javathread_create(jt);\n+      send_java_thread_start_event(jt);\n@@ -224,0 +235,1 @@\n+    JfrCPUTimeThreadSampling::on_javathread_terminate(jt);\n@@ -540,0 +552,82 @@\n+\n+\n+#ifdef LINUX\n+\n+void JfrThreadLocal::set_cpu_timer(timer_t* timer) {\n+  if (_cpu_timer == nullptr) {\n+    _cpu_timer = JfrCHeapObj::new_array<timer_t>(1);\n+  }\n+  *_cpu_timer = *timer;\n+}\n+\n+void JfrThreadLocal::unset_cpu_timer() {\n+  if (_cpu_timer != nullptr) {\n+    timer_delete(*_cpu_timer);\n+    JfrCHeapObj::free(_cpu_timer, sizeof(timer_t));\n+    _cpu_timer = nullptr;\n+  }\n+}\n+\n+timer_t* JfrThreadLocal::cpu_timer() const {\n+  return _cpu_timer;\n+}\n+\n+bool JfrThreadLocal::is_cpu_time_jfr_enqueue_locked() {\n+  return Atomic::load_acquire(&_cpu_time_jfr_locked) == ENQUEUE;\n+}\n+\n+bool JfrThreadLocal::is_cpu_time_jfr_dequeue_locked() {\n+  return Atomic::load_acquire(&_cpu_time_jfr_locked) == DEQUEUE;\n+}\n+\n+bool JfrThreadLocal::try_acquire_cpu_time_jfr_enqueue_lock() {\n+  return Atomic::cmpxchg(&_cpu_time_jfr_locked, UNLOCKED, ENQUEUE) == UNLOCKED;\n+}\n+\n+bool JfrThreadLocal::try_acquire_cpu_time_jfr_dequeue_lock() {\n+  CPUTimeLockState got;\n+  while (true)  {\n+    CPUTimeLockState got = Atomic::cmpxchg(&_cpu_time_jfr_locked, UNLOCKED, DEQUEUE);\n+    if (got == UNLOCKED) {\n+      return true; \/\/ successfully locked for dequeue\n+    }\n+    if (got == DEQUEUE) {\n+      return false; \/\/ already locked for dequeue\n+    }\n+    \/\/ else wait for the lock to be released from a signal handler\n+  }\n+}\n+\n+void JfrThreadLocal::acquire_cpu_time_jfr_dequeue_lock() {\n+  while (Atomic::cmpxchg(&_cpu_time_jfr_locked, UNLOCKED, DEQUEUE) != UNLOCKED);\n+}\n+\n+void JfrThreadLocal::release_cpu_time_jfr_queue_lock() {\n+  Atomic::release_store(&_cpu_time_jfr_locked, UNLOCKED);\n+}\n+\n+void JfrThreadLocal::set_has_cpu_time_jfr_requests(bool has_requests) {\n+  Atomic::release_store(&_has_cpu_time_jfr_requests, has_requests);\n+}\n+\n+bool JfrThreadLocal::has_cpu_time_jfr_requests() {\n+  return Atomic::load_acquire(&_has_cpu_time_jfr_requests);\n+}\n+\n+JfrCPUTimeTraceQueue& JfrThreadLocal::cpu_time_jfr_queue() {\n+  return _cpu_time_jfr_queue;\n+}\n+\n+void JfrThreadLocal::deallocate_cpu_time_jfr_queue() {\n+  cpu_time_jfr_queue().resize(0);\n+}\n+\n+void JfrThreadLocal::set_do_async_processing_of_cpu_time_jfr_requests(bool wants) {\n+  Atomic::release_store(&_do_async_processing_of_cpu_time_jfr_requests, wants);\n+}\n+\n+bool JfrThreadLocal::wants_async_processing_of_cpu_time_jfr_requests() {\n+  return Atomic::load_acquire(&_do_async_processing_of_cpu_time_jfr_requests);\n+}\n+\n+#endif\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.cpp","additions":96,"deletions":2,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -36,0 +36,4 @@\n+#ifdef LINUX\n+#include \"jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp\"\n+#endif\n+\n@@ -82,0 +86,16 @@\n+#ifdef LINUX\n+  timer_t* _cpu_timer;\n+\n+  enum CPUTimeLockState {\n+    UNLOCKED,\n+    \/\/ locked for enqueuing\n+    ENQUEUE,\n+    \/\/ locked for dequeuing\n+    DEQUEUE\n+  };\n+  volatile CPUTimeLockState _cpu_time_jfr_locked;\n+  volatile bool _has_cpu_time_jfr_requests;\n+  JfrCPUTimeTraceQueue _cpu_time_jfr_queue;\n+  volatile bool _do_async_processing_of_cpu_time_jfr_requests;\n+#endif\n+\n@@ -345,0 +365,33 @@\n+  \/\/ CPU time sampling\n+#ifdef LINUX\n+  void set_cpu_timer(timer_t* timer);\n+  void unset_cpu_timer();\n+  timer_t* cpu_timer() const;\n+\n+  \/\/ The CPU time JFR lock has three different states:\n+  \/\/ - ENQUEUE: lock for enqueuing CPU time requests\n+  \/\/ - DEQUEUE: lock for dequeuing CPU time requests\n+  \/\/ - UNLOCKED: no lock held\n+  \/\/ This ensures that we can safely enqueue and dequeue CPU time requests,\n+  \/\/ without interleaving\n+\n+  bool is_cpu_time_jfr_enqueue_locked();\n+  bool is_cpu_time_jfr_dequeue_locked();\n+\n+  bool try_acquire_cpu_time_jfr_enqueue_lock();\n+  bool try_acquire_cpu_time_jfr_dequeue_lock();\n+  void acquire_cpu_time_jfr_dequeue_lock();\n+  void release_cpu_time_jfr_queue_lock();\n+\n+  void set_has_cpu_time_jfr_requests(bool has_events);\n+  bool has_cpu_time_jfr_requests();\n+\n+  JfrCPUTimeTraceQueue& cpu_time_jfr_queue();\n+  void deallocate_cpu_time_jfr_queue();\n+\n+  void set_do_async_processing_of_cpu_time_jfr_requests(bool wants);\n+  bool wants_async_processing_of_cpu_time_jfr_requests();\n+#else\n+  bool has_cpu_time_jfr_requests() { return false; }\n+#endif\n+\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.hpp","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+\/\/     - JfrCPUSamplerThread\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -118,0 +118,2 @@\n+  template(CPUTimeSamplerThreadInitializer)       \\\n+  template(CPUTimeSamplerThreadTerminator)        \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -239,0 +239,1 @@\n+  friend class JfrCPUSamplerThread;\n","filename":"src\/hotspot\/share\/utilities\/ticks.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+import jdk.jfr.internal.settings.CPUThrottleSetting;\n@@ -329,0 +330,3 @@\n+        if (type.getName().equals(\"jdk.CPUTimeSample\")) {\n+            return new Control(new CPUThrottleSetting(type), def);\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventControl.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -273,0 +273,10 @@\n+    \/**\n+     * Set the maximum event emission rate for the CPU time sampler\n+     *\n+     * Setting rate to 0 turns off the CPU time sampler.\n+     *\n+     * @param rate the new rate in events per second\n+     * @param autoAdapt true if the rate should be adapted automatically\n+     *\/\n+    public static native void setCPUThrottle(double rate, boolean autoAdapt);\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.jfr.events.ActiveSettingEvent;\n@@ -35,0 +36,1 @@\n+import jdk.jfr.internal.util.TimespanRate;\n@@ -48,0 +50,1 @@\n+    private final boolean isCPUTimeMethodSampling;\n@@ -59,0 +62,1 @@\n+    private TimespanRate cpuRate;\n@@ -78,0 +82,1 @@\n+        this.isCPUTimeMethodSampling = isJVM && name.equals(Type.EVENT_NAME_PREFIX + \"CPUTimeSample\");\n@@ -194,0 +199,7 @@\n+    public void setCPUThrottle(TimespanRate rate) {\n+        if (isCPUTimeMethodSampling) {\n+            this.cpuRate = rate;\n+            JVM.setCPUThrottle(rate.rate(), rate.autoAdapt());\n+        }\n+    }\n+\n@@ -254,0 +266,3 @@\n+            } else if (isCPUTimeMethodSampling) {\n+                TimespanRate r = enabled ? cpuRate : new TimespanRate(0, false);\n+                JVM.setCPUThrottle(r.rate(), r.autoAdapt());\n@@ -391,0 +406,4 @@\n+    public boolean isCPUTimeMethodSampling() {\n+        return isCPUTimeMethodSampling;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformEventType.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -42,1 +42,2 @@\n-                missing:whitespace, missing:whitespace, missing:whitespace\n+                missing:whitespace, missing:whitespace, missing:whitespace,\n+                missing:whitespace\n@@ -403,0 +404,22 @@\n+[application.cpu-time-hot-methods]\n+label = \"Java Methods that Execute the Most from CPU Time Sampler\"\n+table = \"COLUMN 'Method', 'Samples', 'Percent'\n+         FORMAT none, none, normalized\n+         SELECT stackTrace.topFrame AS T, COUNT(*), COUNT(*)\n+         FROM CPUTimeSample GROUP BY T LIMIT 25\"\n+\n+[application.cpu-time-statistics]\n+label = \"CPU Time Sample Statistics\"\n+form = \"COLUMN 'Successful Samples', 'Failed Samples', 'Biased Samples', 'Total Samples', 'Lost Samples'\n+        SELECT COUNT(S.startTime), COUNT(F.startTime), COUNT(B.startTime), Count(A.startTime), SUM(L.lostSamples)\n+        FROM\n+          CPUTimeSample AS S,\n+          CPUTimeSample AS F,\n+          CPUTimeSample AS A,\n+          CPUTimeSample AS B,\n+          CPUTimeSamplesLost AS L\n+        WHERE\n+          S.failed = 'false' AND\n+          F.failed = 'true'  AND\n+          B.biased = 'true'\"\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/view.ini","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * Copyright (c) 2025 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal.settings;\n+\n+import static jdk.jfr.internal.util.TimespanUnit.SECONDS;\n+import static jdk.jfr.internal.util.TimespanUnit.MILLISECONDS;\n+\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import jdk.jfr.Description;\n+import jdk.jfr.SettingControl;\n+import jdk.jfr.Label;\n+import jdk.jfr.MetadataDefinition;\n+import jdk.jfr.Name;\n+import jdk.jfr.internal.PlatformEventType;\n+import jdk.jfr.internal.Type;\n+import jdk.jfr.internal.util.TimespanRate;\n+import jdk.jfr.internal.util.Utils;\n+\n+@MetadataDefinition\n+@Label(\"CPUThrottleSetting\")\n+@Description(\"Upper bounds the emission rate for CPU time samples\")\n+@Name(Type.SETTINGS_PREFIX + \"Rate\")\n+public final class CPUThrottleSetting extends SettingControl {\n+    public static final String DEFAULT_VALUE = \"0\/s\";\n+    private final PlatformEventType eventType;\n+    private String value = DEFAULT_VALUE;\n+\n+    public CPUThrottleSetting(PlatformEventType eventType) {\n+       this.eventType = Objects.requireNonNull(eventType);\n+    }\n+\n+    @Override\n+    public String combine(Set<String> values) {\n+        TimespanRate max = null;\n+        for (String value : values) {\n+            TimespanRate rate = TimespanRate.of(value);\n+            if (rate != null) {\n+                if (max == null || rate.isHigher(max)) {\n+                    max = rate;\n+                }\n+                max = new TimespanRate(max.rate(), max.autoAdapt() || rate.autoAdapt());\n+            }\n+        }\n+        \/\/ \"off\" is not supported\n+        return Objects.requireNonNullElse(max.toString(), DEFAULT_VALUE);\n+    }\n+\n+    @Override\n+    public void setValue(String value) {\n+        TimespanRate rate = TimespanRate.of(value);\n+        if (rate != null) {\n+            eventType.setCPUThrottle(rate);\n+            this.value = value;\n+        }\n+    }\n+\n+    @Override\n+    public String getValue() {\n+        return value;\n+    }\n+}\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/CPUThrottleSetting.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -58,0 +58,4 @@\n+\n+    public double perSecond() {\n+        return inNanos() * 1_000_000_000.0;\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Rate.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2025 SAP SE. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.util;\n+\n+import jdk.jfr.internal.settings.CPUThrottleSetting;\n+\n+\/**\n+ * A rate or fixed period, see {@link jdk.jfr.internal.Rate}\n+ *\/\n+public record TimespanRate(double rate, boolean autoAdapt) {\n+\n+    public static TimespanRate of(String text) {\n+        if (text.equals(\"off\")) {\n+            text = CPUThrottleSetting.DEFAULT_VALUE;\n+        }\n+        boolean isPeriod = !text.contains(\"\/\");\n+        if (isPeriod) {\n+            var period = ValueParser.parseTimespanWithInfinity(text, Long.MAX_VALUE);\n+            if (period == Long.MAX_VALUE) {\n+                return null;\n+            }\n+            if (period == 0) {\n+                return new TimespanRate(0, false);\n+            }\n+            return new TimespanRate(Runtime.getRuntime().availableProcessors() \/ (period \/ 1_000_000_000.0), false);\n+        }\n+        Rate r = Rate.of(text);\n+        if (r == null) {\n+            return null;\n+        }\n+        return new TimespanRate(r.perSecond(), true);\n+    }\n+\n+    public boolean isHigher(TimespanRate that) {\n+        return rate() > that.rate();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (autoAdapt) {\n+            return String.format(\"%d\/ns\", (long)(rate * 1_000_000_000L));\n+        }\n+        return String.format(\"%dns\", (long)(Runtime.getRuntime().availableProcessors() \/ rate * 1_000_000_000L));\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/TimespanRate.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -229,0 +229,10 @@\n+    <event name=\"jdk.CPUTimeSample\">\n+      <setting name=\"enabled\" control=\"method-sampling-enabled\">false<\/setting>\n+      <setting name=\"throttle\">500\/s<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.CPUTimeSamplesLost\">\n+      <setting name=\"enabled\" control=\"method-sampling-enabled\">true<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -209,0 +209,10 @@\n+    <event name=\"jdk.CPUTimeSample\">\n+      <setting name=\"enabled\">false<\/setting>\n+      <setting name=\"throttle\">10ms<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.CPUTimeSamplesLost\">\n+      <setting name=\"enabled\">true<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -92,1 +92,4 @@\n-        \"Flush\", \"SyncOnValueBasedClass\");\n+        \"Flush\", \"SyncOnValueBasedClass\", \"CPUTimeSample\", \"CPUTimeSamplesLost\");\n+\n+    \/\/ Subset of the experimental events that should have tests\n+    private static final Set<String> experimentalButTestedEvents = Set.of(\"CPUTimeSample\");\n@@ -113,1 +116,3 @@\n-        for (String event : jfrEventTypes) {\n+        Set<String> checkedEvents = new HashSet<>(jfrEventTypes);\n+        checkedEvents.addAll(experimentalButTestedEvents);\n+        for (String event : checkedEvents) {\n","filename":"test\/jdk\/jdk\/jfr\/event\/metadata\/TestLookForUntestedEvents.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.profiling;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedFrame;\n+import jdk.jfr.consumer.RecordedStackTrace;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.jfr.RecurseThread;\n+\n+public class BaseTestFullStackTrace {\n+    private final static int MAX_DEPTH = 64; \/\/ currently hardcoded in jvm\n+\n+    private final String eventName;\n+    private final String threadFieldName;\n+\n+    public BaseTestFullStackTrace(String eventName, String threadFieldName) {\n+        this.eventName = eventName;\n+        this.threadFieldName = threadFieldName;\n+    }\n+\n+    public void run() throws Throwable {\n+        RecurseThread[] threads = new RecurseThread[3];\n+        for (int i = 0; i < threads.length; ++i) {\n+            int depth = MAX_DEPTH - 1 + i;\n+            threads[i] = new RecurseThread(depth);\n+            threads[i].setName(\"recursethread-\" + depth);\n+            threads[i].start();\n+        }\n+\n+        for (RecurseThread thread : threads) {\n+            while (!thread.isInRunLoop()) {\n+                Thread.sleep(20);\n+            }\n+        }\n+\n+        assertStackTraces(threads);\n+\n+        for (RecurseThread thread : threads) {\n+            thread.quit();\n+            thread.join();\n+        }\n+    }\n+\n+    private void assertStackTraces(RecurseThread[] threads) throws Throwable {\n+        while (true) {\n+            try (Recording recording = new Recording()) {\n+                if (eventName.equals(EventNames.CPUTimeSample)) {\n+                    recording.enable(eventName).with(\"throttle\", \"50ms\");\n+                } else {\n+                    recording.enable(eventName).withPeriod(Duration.ofMillis(50));\n+                }\n+                recording.start();\n+                Thread.sleep(500);\n+                recording.stop();\n+                if (hasValidStackTraces(recording, threads)) {\n+                    break;\n+                }\n+            }\n+        };\n+    }\n+\n+    private boolean hasValidStackTraces(Recording recording, RecurseThread[] threads) throws Throwable {\n+        boolean[] isEventFound = new boolean[threads.length];\n+\n+        for (RecordedEvent event : Events.fromRecording(recording)) {\n+            System.out.println(\"Event: \" + event);\n+            String threadName = Events.assertField(event, threadFieldName + \".javaName\").getValue();\n+            long threadId = Events.assertField(event, threadFieldName + \".javaThreadId\").getValue();\n+\n+            for (int threadIndex = 0; threadIndex < threads.length; ++threadIndex) {\n+                RecurseThread currThread = threads[threadIndex];\n+                if (threadId == currThread.getId()) {\n+                    System.out.println(\"ThreadName=\" + currThread.getName() + \", depth=\" + currThread.totalDepth);\n+                    Asserts.assertEquals(threadName, currThread.getName(), \"Wrong thread name\");\n+                    if (\"recurseEnd\".equals(getTopMethodName(event))) {\n+                        isEventFound[threadIndex] = true;\n+                        checkEvent(event, currThread.totalDepth);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            String msg = \"threadIndex=%d, recurseDepth=%d, isEventFound=%b%n\";\n+            System.out.printf(msg, i, threads[i].totalDepth, isEventFound[i]);\n+        }\n+        for (int i = 0; i < threads.length; ++i) {\n+            if(!isEventFound[i]) {\n+               \/\/ no assertion, let's retry.\n+               \/\/ Could be race condition, i.e safe point during Thread.sleep\n+               System.out.println(\"Failed to validate all threads, will retry.\");\n+               return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public String getTopMethodName(RecordedEvent event) {\n+        List<RecordedFrame> frames = event.getStackTrace().getFrames();\n+        Asserts.assertFalse(frames.isEmpty(), \"JavaFrames was empty\");\n+        return frames.getFirst().getMethod().getName();\n+    }\n+\n+    private void checkEvent(RecordedEvent event, int expectedDepth) throws Throwable {\n+        RecordedStackTrace stacktrace = null;\n+        try {\n+            stacktrace = event.getStackTrace();\n+            List<RecordedFrame> frames = stacktrace.getFrames();\n+            Asserts.assertEquals(Math.min(MAX_DEPTH, expectedDepth), frames.size(), \"Wrong stacktrace depth. Expected:\" + expectedDepth);\n+            List<String> expectedMethods = getExpectedMethods(expectedDepth);\n+            Asserts.assertEquals(expectedMethods.size(), frames.size(), \"Wrong expectedMethods depth. Test error.\");\n+\n+            for (int i = 0; i < frames.size(); ++i) {\n+                String name = frames.get(i).getMethod().getName();\n+                String expectedName = expectedMethods.get(i);\n+                System.out.printf(\"method[%d]=%s, expected=%s%n\", i, name, expectedName);\n+                Asserts.assertEquals(name, expectedName, \"Wrong method name\");\n+            }\n+\n+            boolean isTruncated = stacktrace.isTruncated();\n+            boolean isTruncateExpected = expectedDepth > MAX_DEPTH;\n+            Asserts.assertEquals(isTruncated, isTruncateExpected, \"Wrong value for isTruncated. Expected:\" + isTruncateExpected);\n+\n+            String firstMethod = frames.getLast().getMethod().getName();\n+            boolean isFullTrace = \"run\".equals(firstMethod);\n+            String msg = String.format(\"Wrong values for isTruncated=%b, isFullTrace=%b\", isTruncated, isFullTrace);\n+            Asserts.assertTrue(isTruncated != isFullTrace, msg);\n+        } catch (Throwable t) {\n+            System.out.println(String.format(\"stacktrace:%n%s\", stacktrace));\n+            throw t;\n+        }\n+    }\n+\n+    private List<String> getExpectedMethods(int depth) {\n+        List<String> methods = new ArrayList<>();\n+        methods.add(\"recurseEnd\");\n+        for (int i = 0; i < depth - 2; ++i) {\n+            methods.add((i % 2) == 0 ? \"recurseA\" : \"recurseB\");\n+        }\n+        methods.add(\"run\");\n+        if (depth > MAX_DEPTH) {\n+            methods = methods.subList(0, MAX_DEPTH);\n+        }\n+        return methods;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/BaseTestFullStackTrace.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2025 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.profiling;\n+\n+import java.time.Duration;\n+\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.RecurseThread;\n+\n+\/*\n+ * @test\n+ * @requires vm.hasJFR & os.family == \"linux\"\n+ * @library \/test\/lib\n+ * @modules jdk.jfr\/jdk.jfr.internal\n+ * @run main\/timeout=30 jdk.jfr.event.profiling.TestCPUTimeAndExecutionSample\n+ *\/\n+public class TestCPUTimeAndExecutionSample {\n+\n+    static String sampleEvent = EventNames.CPUTimeSample;\n+\n+    \/\/ The period is set to 1100 ms to provoke the 1000 ms\n+    \/\/ threshold in the JVM for os::naked_short_sleep().\n+    public static void main(String[] args) throws Exception {\n+        run(EventNames.ExecutionSample);\n+        run(EventNames.CPUTimeSample);\n+        run(EventNames.ExecutionSample);\n+        run(EventNames.CPUTimeSample);\n+    }\n+\n+    private static void run(String eventType) {\n+        RecurseThread t = new RecurseThread(50);\n+        t.setDaemon(true);\n+        try (RecordingStream rs = new RecordingStream()) {\n+            rs.enable(sampleEvent).with(\"throttle\", \"1000\/s\");\n+            rs.onEvent(sampleEvent, e -> {\n+                t.quit();\n+                rs.close();\n+            });\n+            t.start();\n+            rs.start();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeAndExecutionSample.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.profiling;\n+\n+import jdk.test.lib.jfr.EventNames;\n+\n+\/**\n+ * @test\n+ * @requires vm.hasJFR & os.family == \"linux\"\n+ * @library \/test\/lib\n+ * @build jdk.jfr.event.profiling.BaseTestFullStackTrace\n+ * @run main\/othervm jdk.jfr.event.profiling.TestCPUTimeSampleFullStackTrace\n+ *\/\n+public class TestCPUTimeSampleFullStackTrace {\n+\n+    public static void main(String[] args) throws Throwable {\n+        new BaseTestFullStackTrace(EventNames.CPUTimeSample, \"eventThread\").run();\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeSampleFullStackTrace.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2025 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.profiling;\n+\n+import java.time.Duration;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.jfr.internal.JVM;\n+import jdk.test.lib.jfr.EventNames;\n+\n+\/*\n+ * Tests that creating multiple recordings after another is possible.\n+ * @test\n+ * @requires vm.hasJFR & os.family == \"linux\"\n+ * @library \/test\/lib\n+ * @modules jdk.jfr\/jdk.jfr.internal\n+ * @run main jdk.jfr.event.profiling.TestCPUTimeSampleMultipleRecordings\n+ *\/\n+public class TestCPUTimeSampleMultipleRecordings {\n+\n+    static String nativeEvent = EventNames.CPUTimeSample;\n+\n+    static volatile boolean alive = true;\n+\n+    public static void main(String[] args) throws Exception {\n+        Thread t = new Thread(TestCPUTimeSampleMultipleRecordings::nativeMethod);\n+        t.setDaemon(true);\n+        t.start();\n+        for (int i = 0; i < 2; i++) {\n+            try (RecordingStream rs = new RecordingStream()) {\n+                rs.enable(nativeEvent).with(\"throttle\", \"1ms\");\n+                rs.onEvent(nativeEvent, e -> {\n+                    alive = false;\n+                    rs.close();\n+                });\n+\n+                rs.start();\n+            }\n+        }\n+        alive = false;\n+    }\n+\n+    public static void nativeMethod() {\n+        while (alive) {\n+            JVM.getPid();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeSampleMultipleRecordings.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.profiling;\n+\n+import java.time.Duration;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.jfr.internal.JVM;\n+import jdk.test.lib.jfr.EventNames;\n+\n+\/*\n+ * @test\n+ * @requires vm.hasJFR & os.family == \"linux\"\n+ * @library \/test\/lib\n+ * @modules jdk.jfr\/jdk.jfr.internal\n+ * @run main jdk.jfr.event.profiling.TestCPUTimeSampleNative\n+ *\/\n+public class TestCPUTimeSampleNative {\n+\n+    static String nativeEvent = EventNames.CPUTimeSample;\n+\n+    static volatile boolean alive = true;\n+\n+    public static void main(String[] args) throws Exception {\n+        try (RecordingStream rs = new RecordingStream()) {\n+            rs.enable(nativeEvent).with(\"throttle\", \"1ms\");\n+            rs.onEvent(nativeEvent, e -> {\n+                alive = false;\n+                rs.close();\n+            });\n+            Thread t = new Thread(TestCPUTimeSampleNative::nativeMethod);\n+            t.setDaemon(true);\n+            t.start();\n+            rs.start();\n+        }\n+\n+    }\n+\n+    public static void nativeMethod() {\n+        while (alive) {\n+            JVM.getPid();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeSampleNative.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2025 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.profiling;\n+import java.lang.management.ManagementFactory;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Comparator;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @requires vm.hasJFR & os.family == \"linux\"\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.event.profiling.TestCPUTimeSampleThrottling\n+ *\/\n+public class TestCPUTimeSampleThrottling {\n+\n+    public static void main(String[] args) throws Exception {\n+        testZeroPerSecond();\n+        testThrottleSettings();\n+        testThrottleSettingsPeriod();\n+    }\n+\n+    private static void testZeroPerSecond() throws Exception {\n+        Asserts.assertTrue(0L == countEvents(1000, \"0\/s\").count());\n+    }\n+\n+    private static void testThrottleSettings() throws Exception {\n+        long count = countEvents(1000,\n+            Runtime.getRuntime().availableProcessors() * 2 + \"\/s\").count();\n+        Asserts.assertTrue(count > 0 && count < 3,\n+            \"Expected between 0 and 3 events, got \" + count);\n+    }\n+\n+    private static void testThrottleSettingsPeriod() throws Exception {\n+        float rate = countEvents(1000, \"10ms\").rate();\n+        Asserts.assertTrue(rate > 90 && rate < 110, \"Expected around 100 events per second, got \" + rate);\n+    }\n+\n+    private record EventCount(long count, float time) {\n+        float rate() {\n+            return count \/ time;\n+        }\n+    }\n+\n+    private static EventCount countEvents(int timeMs, String rate) throws Exception {\n+        try(Recording recording = new Recording()) {\n+            recording.enable(EventNames.CPUTimeSample)\n+                    .with(\"throttle\", rate);\n+\n+            var bean = ManagementFactory.getThreadMXBean();\n+\n+            recording.start();\n+\n+            long startThreadCpuTime = bean.getCurrentThreadCpuTime();\n+\n+            wasteCPU(timeMs);\n+\n+            long spendCPUTime = bean.getCurrentThreadCpuTime() - startThreadCpuTime;\n+\n+            recording.stop();\n+\n+            long eventCount = Events.fromRecording(recording).stream()\n+                    .filter(e -> e.getThread().getJavaName()\n+                                .equals(Thread.currentThread().getName()))\n+                    .count();\n+\n+            System.out.println(\"Event count: \" + eventCount + \", CPU time: \" + spendCPUTime \/ 1_000_000_000f + \"s\");\n+\n+            return new EventCount(eventCount, spendCPUTime \/ 1_000_000_000f);\n+        }\n+    }\n+\n+    private static void wasteCPU(int durationMs) {\n+        long start = System.currentTimeMillis();\n+        double i = 0;\n+        while (System.currentTimeMillis() - start < durationMs) {\n+            for (int j = 0; j < 100000; j++) {\n+                i = Math.sqrt(i * Math.pow(Math.sqrt(Math.random()), Math.random()));\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeSampleThrottling.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.profiling;\n+\n+import java.time.Duration;\n+\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.RecurseThread;\n+\n+\/*\n+ * @test\n+ * @requires vm.hasJFR & os.family == \"linux\"\n+ * @library \/test\/lib\n+ * @modules jdk.jfr\/jdk.jfr.internal\n+ * @run main jdk.jfr.event.profiling.TestCPUTimeSamplingLongPeriod\n+ *\/\n+public class TestCPUTimeSamplingLongPeriod {\n+\n+    static String sampleEvent = EventNames.CPUTimeSample;\n+\n+    \/\/ The period is set to 1100 ms to provoke the 1000 ms\n+    \/\/ threshold in the JVM for os::naked_short_sleep().\n+    public static void main(String[] args) throws Exception {\n+        RecurseThread t = new RecurseThread(50);\n+        t.setDaemon(true);\n+        try (RecordingStream rs = new RecordingStream()) {\n+            rs.enable(sampleEvent).with(\"throttle\", \"1100ms\");\n+            rs.onEvent(sampleEvent, e -> {\n+                t.quit();\n+                rs.close();\n+            });\n+            t.start();\n+            rs.start();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeSamplingLongPeriod.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -26,9 +26,0 @@\n-import java.time.Duration;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import jdk.jfr.Recording;\n-import jdk.jfr.consumer.RecordedEvent;\n-import jdk.jfr.consumer.RecordedFrame;\n-import jdk.jfr.consumer.RecordedStackTrace;\n-import jdk.test.lib.Asserts;\n@@ -36,2 +27,0 @@\n-import jdk.test.lib.jfr.Events;\n-import jdk.test.lib.jfr.RecurseThread;\n@@ -44,0 +33,1 @@\n+ * @build jdk.jfr.event.profiling.BaseTestFullStackTrace\n@@ -47,2 +37,0 @@\n-    private final static String EVENT_NAME = EventNames.ExecutionSample;\n-    private final static int MAX_DEPTH = 64; \/\/ currently hardcoded in jvm\n@@ -51,31 +39,1 @@\n-        RecurseThread[] threads = new RecurseThread[3];\n-        for (int i = 0; i < threads.length; ++i) {\n-            int depth = MAX_DEPTH - 1 + i;\n-            threads[i] = new RecurseThread(depth);\n-            threads[i].setName(\"recursethread-\" + depth);\n-            threads[i].start();\n-        }\n-\n-        for (RecurseThread thread : threads) {\n-            while (!thread.isInRunLoop()) {\n-                Thread.sleep(20);\n-            }\n-        }\n-\n-        assertStackTraces(threads);\n-\n-        for (RecurseThread thread : threads) {\n-            thread.quit();\n-            thread.join();\n-        }\n-    }\n-\n-    private static void assertStackTraces( RecurseThread[] threads) throws Throwable {\n-        Recording recording= null;\n-        do {\n-            recording = new Recording();\n-            recording.enable(EVENT_NAME).withPeriod(Duration.ofMillis(50));\n-            recording.start();\n-            Thread.sleep(500);\n-            recording.stop();\n-        } while (!hasValidStackTraces(recording, threads));\n+        new BaseTestFullStackTrace(EventNames.ExecutionSample, \"sampledThread\").run();\n@@ -84,85 +42,0 @@\n-    private static boolean hasValidStackTraces(Recording recording, RecurseThread[] threads) throws Throwable {\n-        boolean[] isEventFound = new boolean[threads.length];\n-\n-        for (RecordedEvent event : Events.fromRecording(recording)) {\n-            \/\/System.out.println(\"Event: \" + event);\n-            String threadName = Events.assertField(event, \"sampledThread.javaName\").getValue();\n-            long threadId = Events.assertField(event, \"sampledThread.javaThreadId\").getValue();\n-\n-            for (int threadIndex = 0; threadIndex < threads.length; ++threadIndex) {\n-                RecurseThread currThread = threads[threadIndex];\n-                if (threadId == currThread.getId()) {\n-                    System.out.println(\"ThreadName=\" + currThread.getName() + \", depth=\" + currThread.totalDepth);\n-                    Asserts.assertEquals(threadName, currThread.getName(), \"Wrong thread name\");\n-                    if (\"recurseEnd\".equals(getTopMethodName(event))) {\n-                        isEventFound[threadIndex] = true;\n-                        checkEvent(event, currThread.totalDepth);\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-\n-        for (int i = 0; i < threads.length; ++i) {\n-            String msg = \"threadIndex=%d, recurseDepth=%d, isEventFound=%b%n\";\n-            System.out.printf(msg, i, threads[i].totalDepth, isEventFound[i]);\n-        }\n-        for (int i = 0; i < threads.length; ++i) {\n-            if(!isEventFound[i]) {\n-               \/\/ no assertion, let's retry.\n-               \/\/ Could be race condition, i.e safe point during Thread.sleep\n-               System.out.println(\"Failed to validate all threads, will retry.\");\n-               return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    public static String getTopMethodName(RecordedEvent event) {\n-        List<RecordedFrame> frames = event.getStackTrace().getFrames();\n-        Asserts.assertFalse(frames.isEmpty(), \"JavaFrames was empty\");\n-        return frames.getFirst().getMethod().getName();\n-    }\n-\n-    private static void checkEvent(RecordedEvent event, int expectedDepth) throws Throwable {\n-        RecordedStackTrace stacktrace = null;\n-        try {\n-            stacktrace = event.getStackTrace();\n-            List<RecordedFrame> frames = stacktrace.getFrames();\n-            Asserts.assertEquals(Math.min(MAX_DEPTH, expectedDepth), frames.size(), \"Wrong stacktrace depth. Expected:\" + expectedDepth);\n-            List<String> expectedMethods = getExpectedMethods(expectedDepth);\n-            Asserts.assertEquals(expectedMethods.size(), frames.size(), \"Wrong expectedMethods depth. Test error.\");\n-\n-            for (int i = 0; i < frames.size(); ++i) {\n-                String name = frames.get(i).getMethod().getName();\n-                String expectedName = expectedMethods.get(i);\n-                System.out.printf(\"method[%d]=%s, expected=%s%n\", i, name, expectedName);\n-                Asserts.assertEquals(name, expectedName, \"Wrong method name\");\n-            }\n-\n-            boolean isTruncated = stacktrace.isTruncated();\n-            boolean isTruncateExpected = expectedDepth > MAX_DEPTH;\n-            Asserts.assertEquals(isTruncated, isTruncateExpected, \"Wrong value for isTruncated. Expected:\" + isTruncateExpected);\n-\n-            String firstMethod = frames.getLast().getMethod().getName();\n-            boolean isFullTrace = \"run\".equals(firstMethod);\n-            String msg = String.format(\"Wrong values for isTruncated=%b, isFullTrace=%b\", isTruncated, isFullTrace);\n-            Asserts.assertTrue(isTruncated != isFullTrace, msg);\n-        } catch (Throwable t) {\n-            System.out.println(String.format(\"stacktrace:%n%s\", stacktrace));\n-            throw t;\n-        }\n-    }\n-\n-    private static List<String> getExpectedMethods(int depth) {\n-        List<String> methods = new ArrayList<>();\n-        methods.add(\"recurseEnd\");\n-        for (int i = 0; i < depth - 2; ++i) {\n-            methods.add((i % 2) == 0 ? \"recurseA\" : \"recurseB\");\n-        }\n-        methods.add(\"run\");\n-        if (depth > MAX_DEPTH) {\n-            methods = methods.subList(0, MAX_DEPTH);\n-        }\n-        return methods;\n-    }\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestFullStackTrace.java","additions":2,"deletions":129,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2025 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ package test;\n+\n+ import java.time.Duration;\n+\n+ \/*\n+  * A class used to create a simple deep call stack for testing purposes\n+  *\/\n+ public class RecursiveMethods {\n+\n+    \/** Method that uses recursion to produce a call stack of at least {@code depth} depth *\/\n+    public static int entry(int depth) {\n+        return method2(--depth);\n+    }\n+\n+    private static int method2(int depth) {\n+        return method3(--depth);\n+    }\n+\n+    private static int method3(int depth) {\n+        return method4(--depth);\n+    }\n+\n+    private static int method4(int depth) {\n+        return method5(--depth);\n+    }\n+\n+    private static int method5(int depth) {\n+        return method6(--depth);\n+    }\n+\n+    private static int method6(int depth) {\n+        return method7(--depth);\n+    }\n+\n+    private static int method7(int depth) {\n+        return method8(--depth);\n+    }\n+\n+    private static int method8(int depth) {\n+        return method9(--depth);\n+    }\n+\n+    private static int method9(int depth) {\n+        return method10(--depth);\n+    }\n+\n+    private static int method10(int depth) {\n+        if (depth > 0) {\n+            return entry(--depth);\n+        }\n+        return depth;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/classes\/test\/RecursiveMethods.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -80,0 +80,2 @@\n+    public static final String CPUTimeSample = PREFIX + \"CPUTimeSample\";\n+    public static final String CPUTimeSamplesLost = PREFIX + \"CPUTimeSamplesLost\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}