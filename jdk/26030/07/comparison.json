{"files":[{"patch":"@@ -24,0 +24,1 @@\n+import java.io.ByteArrayOutputStream;\n@@ -38,0 +39,2 @@\n+import static java.util.Comparator.comparing;\n+\n@@ -45,1 +48,1 @@\n- * @run main\/othervm -Xmx900m AbsPathsInImage\n+ * @run main AbsPathsInImage\n@@ -54,0 +57,3 @@\n+    private static final int DEFAULT_BUFFER_SIZE = 8192;\n+    private static List<byte[]> searchPatterns = new ArrayList<>();\n+    private static List<int[]> prefixTables = new ArrayList<>();\n@@ -57,0 +63,2 @@\n+    record Match(int begin, int end) { }\n+\n@@ -110,3 +118,3 @@\n-        List<byte[]> searchPatterns = new ArrayList<>();\n-        expandPatterns(searchPatterns, buildWorkspaceRoot);\n-        expandPatterns(searchPatterns, buildOutputRoot);\n+        expandPatterns(buildWorkspaceRoot);\n+        expandPatterns(buildOutputRoot);\n+        createPrefixTables();\n@@ -121,1 +129,1 @@\n-        absPathsInImage.scanFiles(dirToScan, searchPatterns);\n+        absPathsInImage.scanFiles(dirToScan);\n@@ -132,1 +140,1 @@\n-    private static void expandPatterns(List<byte[]> searchPatterns, String pattern) {\n+    private static void expandPatterns(String pattern) {\n@@ -154,1 +162,36 @@\n-    private void scanFiles(Path root, List<byte[]> searchPatterns) throws IOException {\n+    \/**\n+     * The failure function for KMP. Returns the correct index in the pattern to jump\n+     * back to when encountering a mismatched character. Used in both\n+     * createPrefixTables (pre-processing) and scanBytes (matching).\n+     *\/\n+    private static int getPrefixIndex(int patternIdx, int state, byte match) {\n+        if (state == 0) {\n+            return 0;\n+        }\n+        byte[] searchPattern = searchPatterns.get(patternIdx);\n+        int[] prefixTable = prefixTables.get(patternIdx);\n+        int i = prefixTable[state - 1];\n+        while (i > 0 && searchPattern[i] != match) {\n+            i = prefixTable[i - 1];\n+        }\n+        return searchPattern[i] == match ? i + 1 : i;\n+    }\n+\n+    \/**\n+     * Pre-processing string patterns for Knuth–Morris–Pratt (KMP) search algorithm.\n+     * Lookup tables of longest prefixes at each given index are created for each\n+     * search pattern string. These tables are later used in scanBytes during matching\n+     * as lookups for failure state transitions.\n+     *\/\n+    private static void createPrefixTables() {\n+        for (int patternIdx = 0; patternIdx < searchPatterns.size(); patternIdx++) {\n+            int patternLen = searchPatterns.get(patternIdx).length;\n+            int[] prefixTable = new int[patternLen];\n+            prefixTables.add(prefixTable);\n+            for (int i = 1; i < patternLen; i++) {\n+                prefixTable[i] = getPrefixIndex(patternIdx, i, searchPatterns.get(patternIdx)[i]);\n+            }\n+        }\n+    }\n+\n+    private void scanFiles(Path root) throws IOException {\n@@ -173,1 +216,1 @@\n-                    scanZipFile(file, searchPatterns);\n+                    scanZipFile(file);\n@@ -175,1 +218,1 @@\n-                    scanFile(file, searchPatterns);\n+                    scanFile(file);\n@@ -182,9 +225,12 @@\n-    private void scanFile(Path file, List<byte[]> searchPatterns) throws IOException {\n-        List<String> matches = scanBytes(Files.readAllBytes(file), searchPatterns);\n-        if (matches.size() > 0) {\n-            matchFound = true;\n-            System.out.println(file + \":\");\n-            for (String match : matches) {\n-                System.out.println(match);\n-            }\n-            System.out.println();\n+    private void scanFile(Path file) throws IOException {\n+        List<Match> matches;\n+        try (InputStream inputStream = Files.newInputStream(file)) {\n+            matches = scanBytes(inputStream);\n+        }\n+        \/\/ test succeeds\n+        if (matches.size() == 0) {\n+            return;\n+        }\n+        \/\/ test fails; pay penalty and re-scan file for debug output\n+        try (InputStream inputStream = Files.newInputStream(file)) {\n+            printDebugOutput(inputStream, matches, file + \":\");\n@@ -194,1 +240,4 @@\n-    private void scanZipFile(Path zipFile, List<byte[]> searchPatterns) throws IOException {\n+    private void scanZipFile(Path zipFile) throws IOException {\n+        List<List<Match>> entryMatches = new ArrayList<>();\n+        boolean found = false;\n+        ZipEntry zipEntry;\n@@ -196,1 +245,0 @@\n-            ZipEntry zipEntry;\n@@ -198,1 +246,1 @@\n-                List<String> matches = scanBytes(zipInputStream.readAllBytes(), searchPatterns);\n+                List<Match> matches = scanBytes(zipInputStream);\n@@ -200,6 +248,19 @@\n-                    matchFound = true;\n-                    System.out.println(zipFile + \", \" + zipEntry.getName() + \":\");\n-                    for (String match : matches) {\n-                        System.out.println(match);\n-                    }\n-                    System.out.println();\n+                    entryMatches.add(matches);\n+                    found = true;\n+                } else {\n+                    entryMatches.add(null);\n+                }\n+            }\n+        }\n+        \/\/ test succeeds\n+        if (!found) {\n+            return;\n+        }\n+        \/\/ test fails\n+        try (ZipInputStream zipInputStream = new ZipInputStream(Files.newInputStream(zipFile))) {\n+            int i = 0;\n+            while ((zipEntry = zipInputStream.getNextEntry()) != null) {\n+                List<Match> matches = entryMatches.get(i);\n+                i++;\n+                if (matches != null) {\n+                    printDebugOutput(zipInputStream, matches, zipFile + \", \" + zipEntry.getName() + \":\");\n@@ -211,8 +272,24 @@\n-    private List<String> scanBytes(byte[] data, List<byte[]> searchPatterns) {\n-        List<String> matches = new ArrayList<>();\n-        for (int i = 0; i < data.length; i++) {\n-            for (byte[] searchPattern : searchPatterns) {\n-                boolean found = true;\n-                for (int j = 0; j < searchPattern.length; j++) {\n-                    if ((i + j >= data.length || data[i + j] != searchPattern[j])) {\n-                        found = false;\n+    \/**\n+     * Scans each byte until encounters a match with one of searchPatterns. Uses KMP to\n+     * perform matches. Keep track of current matched index (states) for each search\n+     * pattern. At each given byte, update states accordingly (increment if match or\n+     * failure function transition if mismatch). Returns a list of Match objects.\n+     *\/\n+    private List<Match> scanBytes(InputStream input) throws IOException {\n+        List<Match> matches = new ArrayList<>();\n+        byte[] buf = new byte[DEFAULT_BUFFER_SIZE];\n+        int[] states = new int[searchPatterns.size()];\n+        int fileIdx = 0;\n+        int bytesRead, patternLen;\n+        while ((bytesRead = input.read(buf)) != -1) {\n+            for (int bufIdx = 0; bufIdx < bytesRead; bufIdx++, fileIdx++) {\n+                byte datum = buf[bufIdx];\n+                for (int i = 0; i < searchPatterns.size(); i++) {\n+                    patternLen = searchPatterns.get(i).length;\n+                    if (datum != searchPatterns.get(i)[states[i]]) {\n+                        states[i] = getPrefixIndex(i, states[i], datum);\n+                    } else if (++states[i] == patternLen) {\n+                        \/\/ technically at last match, state should reset according to failure function\n+                        \/\/ but in original test, matching didn't search same string for multiple matches\n+                        states[i] = 0;\n+                        matches.add(new Match(fileIdx - patternLen + 1, fileIdx));\n@@ -222,5 +299,0 @@\n-                if (found) {\n-                    matches.add(new String(data, charsStart(data, i), charsOffset(data, i, searchPattern.length)));\n-                    \/\/ No need to search the same string for multiple patterns\n-                    break;\n-                }\n@@ -232,17 +304,32 @@\n-    private int charsStart(byte[] data, int startIndex) {\n-        int index = startIndex;\n-        while (--index > 0) {\n-            byte datum = data[index];\n-            if (datum < 32 || datum > 126) {\n-                break;\n-            }\n-        }\n-        return index + 1;\n-    }\n-\n-    private int charsOffset(byte[] data, int startIndex, int startOffset) {\n-        int offset = startOffset;\n-        while (startIndex + ++offset < data.length) {\n-            byte datum = data[startIndex + offset];\n-            if (datum < 32 || datum > 126) {\n-                break;\n+    \/**\n+     * In original test, failed test output would backtrack to last non-ascii byte on\n+     * matched pattern. This is incompatible with the new buffered approach (and a\n+     * proper solution requires a 2nd dynamic buffer). Instead, on failed test case,\n+     * files are scanned a 2nd time to print debug output. Failed runs will pay\n+     * additional performance\/space penalty, but passing runs are faster.\n+     *\/\n+    private void printDebugOutput(InputStream input, List<Match> matches, final String HEADER) throws IOException{\n+        matchFound = true;\n+        System.out.println(HEADER);\n+        matches.sort(comparing(Match::begin));\n+        ByteArrayOutputStream output = new ByteArrayOutputStream();\n+        byte[] buf = new byte[DEFAULT_BUFFER_SIZE];\n+        int matchIdx = 0;\n+        int fileIdx = 0;\n+        int bytesRead;\n+        while (matchIdx < matches.size() && (bytesRead = input.read(buf)) != -1) {\n+            for (int i = 0; matchIdx < matches.size() && i < bytesRead; i++, fileIdx++) {\n+                byte datum = buf[i];\n+                if (datum >= 32 && datum <= 126) {\n+                    output.write(datum);\n+                } else if (fileIdx < matches.get(matchIdx).begin()) {\n+                    output.reset();\n+                } else if (fileIdx > matches.get(matchIdx).end()) {\n+                    System.out.println(output.toString());\n+                    output.reset();\n+                    \/\/ This imperfect as incorrect in edge cases with patterns containing non-ascii?\n+                    \/\/ but high-accuracy not priority + output still legible and useful\n+                    for (; matchIdx < matches.size() && matches.get(matchIdx).end() < fileIdx; matchIdx++);\n+                } else {\n+                    output.write(datum);\n+                }\n@@ -251,1 +338,1 @@\n-        return offset;\n+        System.out.println();\n","filename":"test\/jdk\/build\/AbsPathsInImage.java","additions":145,"deletions":58,"binary":false,"changes":203,"status":"modified"}]}