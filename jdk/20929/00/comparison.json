{"files":[{"patch":"@@ -90,4 +90,0 @@\n- * The version specification (if any) is processed first by the\n- * platform independent routine SelectVersion.  This may result in\n- * the exec of the specified launcher version.\n- *\n","filename":"src\/java.base\/macosx\/native\/libjli\/java_md_macosx.m","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -101,1 +101,5 @@\n-                (!isPreview && !Modifier.isStatic(mods))) {\n+                (!isPreview &&\n+                        (!Modifier.isStatic(mods)\n+                                || !Modifier.isPublic(mods)\n+                                || mainMethod.getParameterCount() != 1)\n+                )) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/MethodFinder.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -75,1 +75,0 @@\n-import jdk.internal.misc.PreviewFeatures;\n@@ -126,1 +125,0 @@\n-    private static Class<?> appClass; \/\/ application class, for GUI\/reporting purposes\n@@ -597,7 +595,19 @@\n-    private static String getMainClassFromJar(JarFile jarFile) throws IOException {\n-        String jarname = jarFile.getName();\n-        Manifest manifest = jarFile.getManifest();\n-        if (manifest == null) {\n-            abort(null, \"java.launcher.jar.error2\", jarname);\n-        }\n-\n+    \/**\n+     * Expects the presence of a {@code Main-Class} attribute in the jar's manifest\n+     * and returns that value. If the attribute is absent then this method calls\n+     * {@link #abort(Throwable, String, Object...)}. After ascertaining the presence of\n+     * {@code Main-Class}, if {@code JavaFX-Application-Class} attribute is found, then\n+     * this method returns the value of {@code JavaFX-Application-Class} after appropriately\n+     * {@linkplain FXHelper#setFXLaunchParameters(String, int) configuring} Java FX runtime.\n+     *\n+     * <p>\n+     * Additionally, this method also checks for the presence of {@code Launcher-Agent-Class}\n+     * attribute in the manifest. If found, and if {@code java.instrument} module is available,\n+     * then the agent will loaded. If there's any exception when trying to load the agent, then\n+     * this method will call {@code abort()}.\n+     * <p>\n+     * {@code Add-Exports} and {@code Add-Opens} are also parsed and processed by this method.\n+     *\n+     * @return the values of the {@code Main-Class} attribute\n+     *\/\n+    private static String parseManifest(String jarname, Manifest manifest) throws IOException {\n@@ -605,4 +615,0 @@\n-        if (mainAttrs == null) {\n-            abort(null, \"java.launcher.jar.error3\", jarname);\n-        }\n-\n@@ -714,1 +720,1 @@\n-     * perform the launch.\n+     * configure the FX launch.\n@@ -722,1 +728,1 @@\n-     * @return the application's main class\n+     * @return the application's main entry point\n@@ -725,1 +731,1 @@\n-    public static Class<?> checkAndLoadMain(boolean printToStderr,\n+    public static MainEntry locateMainEntry(boolean printToStderr,\n@@ -730,1 +736,1 @@\n-        Class<?> mainClass = null;\n+        MainEntry.Builder mainEntryBuilder = new MainEntry.Builder();\n@@ -733,1 +739,1 @@\n-                mainClass = loadModuleMainClass(what);\n+                loadModuleMainClass(what, mainEntryBuilder);\n@@ -736,1 +742,1 @@\n-                mainClass = loadMainClass(mode, what);\n+                loadMainClass(mode, what, mainEntryBuilder);\n@@ -742,1 +748,2 @@\n-        appClass = mainClass;\n+        assert mainEntryBuilder.mainClass != null : \"missing main class\";\n+        mainEntryBuilder.appClass = mainEntryBuilder.mainClass;\n@@ -749,2 +756,2 @@\n-        if (JAVAFX_FXHELPER_CLASS_NAME_SUFFIX.equals(mainClass.getName()) ||\n-            doesExtendFXApplication(mainClass)) {\n+        if (JAVAFX_FXHELPER_CLASS_NAME_SUFFIX.equals(mainEntryBuilder.mainClass.getName()) ||\n+            doesExtendFXApplication(mainEntryBuilder.mainClass)) {\n@@ -753,1 +760,1 @@\n-            mainClass = FXHelper.class;\n+            mainEntryBuilder.mainClass = FXHelper.class;\n@@ -756,2 +763,1 @@\n-        validateMainMethod(mainClass);\n-        return mainClass;\n+        return requireValidMainMethod(mainEntryBuilder);\n@@ -765,1 +771,1 @@\n-    private static Class<?> loadModuleMainClass(String what) {\n+    private static void loadModuleMainClass(String what, MainEntry.Builder builder) {\n@@ -814,1 +820,1 @@\n-        return c;\n+        builder.mainClass = c;\n@@ -820,1 +826,1 @@\n-    private static Class<?> loadMainClass(int mode, String what) {\n+    private static void loadMainClass(int mode, String what, MainEntry.Builder builder) {\n@@ -822,1 +828,2 @@\n-        String cn = null;\n+        String mainClassName = null;\n+        Class<?> mainClass = null;\n@@ -828,21 +835,0 @@\n-        switch (mode) {\n-            case LM_CLASS:\n-                cn = what;\n-                break;\n-            case LM_JAR:\n-                try {\n-                    jarFile = new JarFile(what);\n-                    cn = getMainClassFromJar(jarFile);\n-                } catch (IOException ioe) {\n-                    abort(ioe, \"java.launcher.jar.error1\", what);\n-                }\n-                break;\n-            default:\n-                \/\/ should never happen\n-                throw new InternalError(\"\" + mode + \": Unknown launch mode\");\n-        }\n-\n-        \/\/ load the main class\n-        cn = cn.replace('\/', '.');\n-        Class<?> mainClass = null;\n-        ClassLoader scl = ClassLoader.getSystemClassLoader();\n@@ -850,0 +836,29 @@\n+            switch (mode) {\n+                case LM_CLASS:\n+                    mainClassName = what;\n+                    break;\n+                case LM_JAR:\n+                    try {\n+                        jarFile = new JarFile(what);\n+                        Manifest manifest = jarFile.getManifest();\n+                        if (manifest == null) {\n+                            abort(null, \"java.launcher.jar.error2\", jarFile.getName());\n+                        }\n+                        Attributes mainAttrs = manifest.getMainAttributes();\n+                        if (mainAttrs == null) {\n+                            abort(null, \"java.launcher.jar.error3\", jarFile.getName());\n+                        }\n+                        mainClassName = parseManifest(jarFile.getName(), manifest);\n+                        builder.splashScreenImage = mainAttrs.getValue(\"Splashscreen-Image\");\n+                    } catch (IOException ioe) {\n+                        abort(ioe, \"java.launcher.jar.error1\", what);\n+                    }\n+                    break;\n+                default:\n+                    \/\/ should never happen\n+                    throw new InternalError(mode + \": Unknown launch mode\");\n+            }\n+            assert mainClassName != null : \"missing main class name\";\n+            \/\/ load the main class\n+            mainClassName = mainClassName.replace('\/', '.');\n+            ClassLoader scl = ClassLoader.getSystemClassLoader();\n@@ -851,1 +866,1 @@\n-                mainClass = Class.forName(cn, false, scl);\n+                mainClass = Class.forName(mainClassName, false, scl);\n@@ -854,1 +869,1 @@\n-                        && Normalizer.isNormalized(cn, Normalizer.Form.NFD)) {\n+                        && Normalizer.isNormalized(mainClassName, Normalizer.Form.NFD)) {\n@@ -860,1 +875,1 @@\n-                        String ncn = Normalizer.normalize(cn, Normalizer.Form.NFC);\n+                        String ncn = Normalizer.normalize(mainClassName, Normalizer.Form.NFC);\n@@ -863,1 +878,1 @@\n-                        abort(cnfe1, \"java.launcher.cls.error1\", cn,\n+                        abort(cnfe1, \"java.launcher.cls.error1\", mainClassName,\n@@ -867,1 +882,1 @@\n-                    abort(cnfe, \"java.launcher.cls.error1\", cn,\n+                    abort(cnfe, \"java.launcher.cls.error1\", mainClassName,\n@@ -872,1 +887,1 @@\n-            abort(le, \"java.launcher.cls.error4\", cn,\n+            abort(le, \"java.launcher.cls.error4\", mainClassName,\n@@ -883,11 +898,2 @@\n-        return mainClass;\n-    }\n-\n-    \/*\n-     * Accessor method called by the launcher after getting the main class via\n-     * checkAndLoadMain(). The \"application class\" is the class that is finally\n-     * executed to start the application and in this case is used to report\n-     * the correct application name, typically for UI purposes.\n-     *\/\n-    public static Class<?> getApplicationClass() {\n-        return appClass;\n+        assert mainClass != null : \"missing main class\";\n+        builder.mainClass = mainClass;\n@@ -911,3 +917,0 @@\n-    private static boolean isStaticMain = false;\n-    private static boolean noArgMain = false;\n-\n@@ -915,1 +918,1 @@\n-    private static void validateMainMethod(Class<?> mainClass) {\n+    private static MainEntry requireValidMainMethod(MainEntry.Builder builder) {\n@@ -918,2 +921,1 @@\n-            mainMethod = MethodFinder.findMainMethod(mainClass);\n-\n+            mainMethod = MethodFinder.findMainMethod(builder.mainClass);\n@@ -922,1 +924,1 @@\n-                abort(null, \"java.launcher.cls.error2\", mainClass.getName(),\n+                abort(null, \"java.launcher.cls.error2\", builder.mainClass.getName(),\n@@ -926,1 +928,1 @@\n-            if (mainClass.getModule().isNamed()) {\n+            if (builder.mainClass.getModule().isNamed()) {\n@@ -928,1 +930,1 @@\n-                      mainClass.getName(), mainClass.getModule().getName(),\n+                      builder.mainClass.getName(), builder.mainClass.getModule().getName(),\n@@ -931,1 +933,1 @@\n-                abort(e, \"java.launcher.cls.error5\", mainClass.getName(),\n+                abort(e, \"java.launcher.cls.error5\", builder.mainClass.getName(),\n@@ -935,1 +937,2 @@\n-\n+        assert mainMethod != null : \"main method wasn't located\";\n+        builder.mainMethod = mainMethod;\n@@ -937,10 +940,2 @@\n-        isStaticMain = Modifier.isStatic(mods);\n-        boolean isPublic = Modifier.isPublic(mods);\n-        noArgMain = mainMethod.getParameterCount() == 0;\n-\n-        if (!PreviewFeatures.isEnabled()) {\n-            if (!isStaticMain || !isPublic || noArgMain) {\n-                  abort(null, \"java.launcher.cls.error2\", mainClass.getName(),\n-                       JAVAFX_APPLICATION_CLASS_NAME);\n-            }\n-            return;\n+        if (Modifier.isStatic(mods)) { \/\/ static main method\n+            return builder.build();\n@@ -948,12 +943,10 @@\n-\n-        if (!isStaticMain) {\n-            String className = mainMethod.getDeclaringClass().getName();\n-            if (mainClass.isMemberClass() && !Modifier.isStatic(mainClass.getModifiers())) {\n-                abort(null, \"java.launcher.cls.error7\", className);\n-            }\n-            try {\n-                Constructor<?> constructor = mainClass.getDeclaredConstructor();\n-                if (Modifier.isPrivate(constructor.getModifiers())) {\n-                    abort(null, \"java.launcher.cls.error6\", className);\n-                }\n-            } catch (Throwable ex) {\n+        \/\/ instance main method\n+        Constructor<?> noArgConstructor = null;\n+        String className = mainMethod.getDeclaringClass().getName();\n+        if (builder.mainClass.isMemberClass()\n+                && !Modifier.isStatic(builder.mainClass.getModifiers())) {\n+            abort(null, \"java.launcher.cls.error7\", className);\n+        }\n+        try {\n+            noArgConstructor = builder.mainClass.getDeclaredConstructor();\n+            if (Modifier.isPrivate(noArgConstructor.getModifiers())) {\n@@ -962,0 +955,2 @@\n+        } catch (Throwable ex) {\n+            abort(null, \"java.launcher.cls.error6\", className);\n@@ -963,0 +958,2 @@\n+        assert noArgConstructor != null : \"missing no-arg constructor for main class\";\n+        return builder.build();\n@@ -1047,0 +1044,36 @@\n+    \/\/ carries details about the application's main method and splash screen image path,\n+    \/\/ that will be used by the native code in the launcher.\n+    public record MainEntry (Class<?> mainClass, Method mainMethod,\n+                             int mainMethodFlag, Class<?> appClass,\n+                             String splashScreenImage) {\n+\n+        private static final int FLAG_STATIC_METHOD = 1;\n+        private static final int FLAG_NO_ARG_METHOD = 2;\n+\n+        public MainEntry {\n+            \/\/ other than these, the rest can be null\n+            assert mainClass != null : \"mainClass is null\";\n+            assert mainMethod != null : \"mainMethod is null\";\n+            assert appClass != null : \"appClass is null\";\n+        }\n+\n+        private static final class Builder {\n+            private Class<?> mainClass;\n+            private Class<?> appClass;\n+            private Method mainMethod;\n+            private String splashScreenImage;\n+\n+            MainEntry build() {\n+                int mainMethodFlag = 0;\n+                if (Modifier.isStatic(mainMethod.getModifiers())) {\n+                    mainMethodFlag |= FLAG_STATIC_METHOD;\n+                }\n+                if (mainMethod.getParameterCount() == 0) {\n+                    mainMethodFlag |= FLAG_NO_ARG_METHOD;\n+                }\n+                return new MainEntry(mainClass, mainMethod, mainMethodFlag,\n+                        appClass, splashScreenImage);\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":133,"deletions":100,"binary":false,"changes":233,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,2 +61,2 @@\n- * the program image remain relatively small until after SelectVersion\n- * CreateExecutionEnvironment have finished their possibly recursive\n+ * the program image remain relatively small until after\n+ * CreateExecutionEnvironment has finished its possibly recursive\n@@ -91,2 +91,3 @@\n- * Entries for splash screen environment variables.\n- * putenv is performed in SelectVersion. We need\n+ * Values that will be stored into splash screen environment variables.\n+ * putenv is performed to set _JAVA_SPLASH_FILE and _JAVA_SPLASH_JAR\n+ * with these values, before PostJVMInit is invoked. We need\n@@ -113,1 +114,0 @@\n-static void SelectVersion(int argc, char **argv, char **main_class);\n@@ -116,1 +116,1 @@\n-                               int *pret, const char *jrepath);\n+                               int *pret);\n@@ -120,3 +120,2 @@\n-static jclass LoadMainClass(JNIEnv *env, int mode, char *name);\n-static jclass GetApplicationClass(JNIEnv *env);\n-\n+static jobject LocateMainEntry(JNIEnv *env, int mode, char *name);\n+static void SetupSplashScreenEnvVars(JNIEnv *env, const char *jarName, const char *jarSplashScreenImage);\n@@ -125,1 +124,0 @@\n-static void SetApplicationClassPath(const char**);\n@@ -133,4 +131,0 @@\n-static jboolean ValidateModules(JNIEnv* env);\n-\n-static void SetPaths(int argc, char **argv);\n-\n@@ -180,0 +174,5 @@\n+typedef struct launcher_splash_info {\n+    int headless; \/\/ 1 if headless, 0 otherwise\n+    char *splash_file_name; \/\/ non-null if \"-splash:\" launcher option is used\n+} launcher_splash_info;\n+static launcher_splash_info *launcherSplashInfo = NULL;\n@@ -243,1 +242,0 @@\n-    char *main_class = NULL;\n@@ -260,0 +258,4 @@\n+        char *env_in;\n+        if ((env_in = getenv(MAIN_CLASS_ENV_ENTRY)) != NULL) {\n+            printf(\"Launched through Multiple JRE (mJRE) support\\n\");\n+        }\n@@ -272,12 +274,0 @@\n-    \/*\n-     * SelectVersion() has several responsibilities:\n-     *\n-     *  1) Disallow specification of another JRE.  With 1.9, another\n-     *     version of the JRE cannot be invoked.\n-     *  2) Allow for a JRE version to invoke JDK 1.9 or later.  Since\n-     *     all mJRE directives have been stripped from the request but\n-     *     the pre 1.9 JRE [ 1.6 thru 1.8 ], it is as if 1.9+ has been\n-     *     invoked from the command line.\n-     *\/\n-    SelectVersion(argc, argv, &main_class);\n-\n@@ -326,1 +316,1 @@\n-    if (!ParseArguments(&argc, &argv, &mode, &what, &ret, jrepath)) {\n+    if (!ParseArguments(&argc, &argv, &mode, &what, &ret)) {\n@@ -390,88 +380,0 @@\n-\/*\n- * Invokes static main(String[]) method if found.\n- * Returns 0 with a pending exception if not found. Returns 1 if invoked, maybe\n- * a pending exception if the method threw.\n- *\/\n-int\n-invokeStaticMainWithArgs(JNIEnv *env, jclass mainClass, jobjectArray mainArgs) {\n-    jmethodID mainID = (*env)->GetStaticMethodID(env, mainClass, \"main\",\n-                                  \"([Ljava\/lang\/String;)V\");\n-    if (mainID == NULL) {\n-        \/\/ static main(String[]) not found\n-        return 0;\n-    }\n-    (*env)->CallStaticVoidMethod(env, mainClass, mainID, mainArgs);\n-    return 1; \/\/ method was invoked\n-}\n-\n-\/*\n- * Invokes instance main(String[]) method if found.\n- * Returns 0 with a pending exception if not found. Returns 1 if invoked, maybe\n- * a pending exception if the method threw.\n- *\/\n-int\n-invokeInstanceMainWithArgs(JNIEnv *env, jclass mainClass, jobjectArray mainArgs) {\n-    jmethodID constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n-    if (constructor == NULL) {\n-        \/\/ main class' no-arg constructor not found\n-        return 0;\n-    }\n-    jobject mainObject = (*env)->NewObject(env, mainClass, constructor);\n-    if (mainObject == NULL) {\n-        \/\/ main class instance couldn't be constructed\n-        return 0;\n-    }\n-    jmethodID mainID =\n-        (*env)->GetMethodID(env, mainClass, \"main\", \"([Ljava\/lang\/String;)V\");\n-    if (mainID == NULL) {\n-        \/\/ instance method main(String[]) method not found\n-        return 0;\n-    }\n-    (*env)->CallVoidMethod(env, mainObject, mainID, mainArgs);\n-    return 1; \/\/ method was invoked\n-}\n-\n-\/*\n- * Invokes no-arg static main() method if found.\n- * Returns 0 with a pending exception if not found. Returns 1 if invoked, maybe\n- * a pending exception if the method threw.\n- *\/\n-int\n-invokeStaticMainWithoutArgs(JNIEnv *env, jclass mainClass) {\n-    jmethodID mainID = (*env)->GetStaticMethodID(env, mainClass, \"main\",\n-                                       \"()V\");\n-    if (mainID == NULL) {\n-        \/\/ static main() method couldn't be located\n-        return 0;\n-    }\n-    (*env)->CallStaticVoidMethod(env, mainClass, mainID);\n-    return 1; \/\/ method was invoked\n-}\n-\n-\/*\n- * Invokes no-arg instance main() method if found.\n- * Returns 0 with a pending exception if not found. Returns 1 if invoked, maybe\n- * a pending exception if the method threw.\n- *\/\n-int\n-invokeInstanceMainWithoutArgs(JNIEnv *env, jclass mainClass) {\n-    jmethodID constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n-    if (constructor == NULL) {\n-        \/\/ main class' no-arg constructor not found\n-        return 0;\n-    }\n-    jobject mainObject = (*env)->NewObject(env, mainClass, constructor);\n-    if (mainObject == NULL) {\n-        \/\/ couldn't create instance of main class\n-        return 0;\n-    }\n-    jmethodID mainID = (*env)->GetMethodID(env, mainClass, \"main\",\n-                                 \"()V\");\n-    if (mainID == NULL) {\n-        \/\/ instance method main() not found\n-        return 0;\n-    }\n-    (*env)->CallVoidMethod(env, mainObject, mainID);\n-    return 1; \/\/ method was invoked\n-}\n-\n@@ -490,3 +392,0 @@\n-    jclass mainClass = NULL;\n-    jclass appClass = NULL; \/\/ actual application class being launched\n-    jobjectArray mainArgs;\n@@ -495,5 +394,0 @@\n-    jclass helperClass;\n-    jfieldID isStaticMainField;\n-    jboolean isStaticMain;\n-    jfieldID noArgMainField;\n-    jboolean noArgMain;\n@@ -603,1 +497,7 @@\n-    mainClass = LoadMainClass(env, mode, what);\n+    const jobject mainEntry = LocateMainEntry(env, mode, what);\n+    CHECK_EXCEPTION_NULL_LEAVE(mainEntry);\n+\n+    const jclass mainEntryType = (*env)->GetObjectClass(env, mainEntry); \/\/ sun\/launcher\/LauncherHelper$MainEntry\n+    const jfieldID mainClassFieldId = (*env)->GetFieldID(env, mainEntryType, \"mainClass\", \"Ljava\/lang\/Class;\");\n+    CHECK_EXCEPTION_NULL_LEAVE(mainClassFieldId);\n+    const jclass mainClass = (jclass)(*env)->GetObjectField(env, mainEntry, mainClassFieldId);\n@@ -607,1 +507,1 @@\n-     * JavaFX application with no main method, the mainClass will not be the\n+     * JavaFX application with no main method, the main class will not be the\n@@ -611,1 +511,3 @@\n-    appClass = GetApplicationClass(env);\n+    const jfieldID appClassFieldId = (*env)->GetFieldID(env, mainEntryType, \"appClass\", \"Ljava\/lang\/Class;\");\n+    CHECK_EXCEPTION_NULL_LEAVE(appClassFieldId);\n+    const jclass appClass = (jclass)(*env)->GetObjectField(env, mainEntry, appClassFieldId);\n@@ -615,1 +517,1 @@\n-    mainArgs = CreateApplicationArgs(env, argv, argc);\n+    const jobjectArray mainArgs = CreateApplicationArgs(env, argv, argc);\n@@ -623,0 +525,18 @@\n+    const jfieldID splashScreenImageFieldID = (*env)->GetFieldID(env, mainEntryType, \"splashScreenImage\",\n+                                                                 \"Ljava\/lang\/String;\");\n+    CHECK_EXCEPTION_NULL_LEAVE(splashScreenImageFieldID);\n+    const jstring jarSplashScreenImage = (jstring)(*env)->GetObjectField(env, mainEntry, splashScreenImageFieldID);\n+    CHECK_EXCEPTION_LEAVE(1);\n+    const char *splash_file_name;\n+    if (jarSplashScreenImage) {\n+        splash_file_name = (*env)->GetStringUTFChars(env, jarSplashScreenImage, 0);\n+        CHECK_EXCEPTION_LEAVE(1);\n+    } else {\n+        splash_file_name = NULL;\n+    }\n+\n+    SetupSplashScreenEnvVars(env, what, splash_file_name);\n+\n+    if (jarSplashScreenImage) {\n+        (*env)->ReleaseStringUTFChars(env, jarSplashScreenImage, splash_file_name);\n+    }\n@@ -624,0 +544,5 @@\n+     * In some cases when launching an application that needs a helper, e.g., a\n+     * JavaFX application with no main method, the main class will not be the\n+     * application's own main class but rather a helper class. To keep things\n+     * consistent in the UI we need to track and report the application main class.\n+     *\n@@ -627,1 +552,1 @@\n-     * instead of mainClass as that may be a launcher or helper class instead\n+     * instead of main class as that may be a launcher or helper class instead\n@@ -638,9 +563,16 @@\n-    helperClass = GetLauncherHelperClass(env);\n-    isStaticMainField = (*env)->GetStaticFieldID(env, helperClass, \"isStaticMain\", \"Z\");\n-    CHECK_EXCEPTION_NULL_LEAVE(isStaticMainField);\n-    isStaticMain = (*env)->GetStaticBooleanField(env, helperClass, isStaticMainField);\n-\n-    noArgMainField = (*env)->GetStaticFieldID(env, helperClass, \"noArgMain\", \"Z\");\n-    CHECK_EXCEPTION_NULL_LEAVE(noArgMainField);\n-    noArgMain = (*env)->GetStaticBooleanField(env, helperClass, noArgMainField);\n-\n+    const jfieldID mainMethodFieldID = (*env)->GetFieldID(env, mainEntryType, \"mainMethod\",\n+                                                          \"Ljava\/lang\/reflect\/Method;\");\n+    CHECK_EXCEPTION_NULL_LEAVE(mainMethodFieldID);\n+    const jobject mainMethod = (*env)->GetObjectField(env, mainEntry, mainMethodFieldID);\n+    CHECK_EXCEPTION_NULL_LEAVE(mainMethod);\n+\n+    const jfieldID flagFieldID = (*env)->GetFieldID(env, mainEntryType, \"mainMethodFlag\", \"I\");\n+    CHECK_EXCEPTION_NULL_LEAVE(flagFieldID);\n+    const jint flag = (*env)->GetIntField(env, mainEntry, flagFieldID);\n+    const jboolean isStaticMain = flag & 1; \/\/ if set, then implies static method\n+    const jboolean isNoArgMain = flag & 2; \/\/ if set, then implies no-arg method\n+\n+    \/\/ FromReflectedMethod will internally initialize the class to which the mainMethod belongs\n+    const jmethodID mainMethodID = (*env)->FromReflectedMethod(env, mainMethod);\n+    CHECK_EXCEPTION_NULL_LEAVE(mainMethodID); \/\/ can happen if static initialization of the mainMethod's class failed\n+    jboolean mainInvoked = JNI_FALSE;\n@@ -648,5 +580,3 @@\n-        if (noArgMain) {\n-            ret = invokeStaticMainWithoutArgs(env, mainClass);\n-        } else {\n-            ret = invokeStaticMainWithArgs(env, mainClass, mainArgs);\n-        }\n+        isNoArgMain ? (*env)->CallStaticVoidMethod(env, mainClass, mainMethodID)\n+                    : (*env)->CallStaticVoidMethod(env, mainClass, mainMethodID, mainArgs);\n+        mainInvoked = JNI_TRUE;\n@@ -654,4 +584,8 @@\n-        if (noArgMain) {\n-            ret = invokeInstanceMainWithoutArgs(env, mainClass);\n-        } else {\n-            ret = invokeInstanceMainWithArgs(env, mainClass, mainArgs);\n+        const jmethodID constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n+        if (constructor != NULL) {\n+            const jobject inst = (*env)->NewObject(env, mainClass, constructor);\n+            if (inst != NULL) {\n+                isNoArgMain ? (*env)->CallVoidMethod(env, inst, mainMethodID)\n+                            : (*env)->CallVoidMethod(env, inst, mainMethodID, mainArgs);\n+                mainInvoked = JNI_TRUE;\n+            }\n@@ -660,2 +594,2 @@\n-    if (!ret) {\n-        \/\/ An appropriate main method couldn't be located, check and report\n+    if (!mainInvoked) {\n+        \/\/ An appropriate main method wasn't invoked, check and report\n@@ -670,1 +604,1 @@\n-    if (ret && (*env)->ExceptionOccurred(env) == NULL) {\n+    if (mainInvoked && (*env)->ExceptionOccurred(env) == NULL) {\n@@ -679,1 +613,44 @@\n-    LEAVE();\n+    LEAVE(); \/\/ exits with the correct \"ret\" code\n+}\n+\n+static void\n+SetupSplashScreenEnvVars(JNIEnv *env,\n+                         const char *jarName, \/\/ the jar file being launched\n+                         const char *jarSplashScreenImage \/\/ SplashScreen-Image value from the jar's manifest\n+) {\n+    if (launcherSplashInfo == NULL || launcherSplashInfo->headless) {\n+        \/\/ splash screen not applicable\n+        return;\n+    }\n+    \/\/ not in headless mode, either use the \"-splash:\" file (if any)\n+    \/\/ specified to the launcher or use the \"Splashscreen-Image\"\n+    \/\/ (if any) specified in the manifest of the jar being launched.\n+\n+    \/\/ command line specified \"-splash:\" takes priority over manifest one.\n+    if (launcherSplashInfo->splash_file_name) {\n+        \/\/ We set up the splash file name as a env variable which then gets\n+        \/\/ used when showing the splash screen in ShowSplashScreen()\n+\n+        \/\/ create the string of the form _JAVA_SPLASH_FILE=<val>\n+        splash_file_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_FILE_ENV_ENTRY \"=\")\n+                                         + JLI_StrLen(launcherSplashInfo->splash_file_name) + 1);\n+        JLI_StrCpy(splash_file_entry, SPLASH_FILE_ENV_ENTRY \"=\");\n+        JLI_StrCat(splash_file_entry, launcherSplashInfo->splash_file_name);\n+        putenv(splash_file_entry);\n+    } else if (jarSplashScreenImage) {\n+        \/\/ The jar's manifest had a \"Splashscreen-Image\" specified. We set up the jar entry name\n+        \/\/ and the jar file name as env variables which then get used when showing the splash screen\n+        \/\/ in ShowSplashScreen()\n+\n+        \/\/ create the string of the form _JAVA_SPLASH_FILE=<val>\n+        splash_file_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_FILE_ENV_ENTRY \"=\")\n+                                         + JLI_StrLen(jarSplashScreenImage) + 1);\n+        JLI_StrCpy(splash_file_entry, SPLASH_FILE_ENV_ENTRY \"=\");\n+        JLI_StrCat(splash_file_entry, jarSplashScreenImage);\n+        putenv(splash_file_entry);\n+        \/\/ create the string of the form _JAVA_SPLASH_JAR=<val>\n+        splash_jar_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_JAR_ENV_ENTRY \"=\") + JLI_StrLen(jarName) + 1);\n+        JLI_StrCpy(splash_jar_entry, SPLASH_JAR_ENV_ENTRY \"=\");\n+        JLI_StrCat(splash_jar_entry, jarName);\n+        putenv(splash_jar_entry);\n+    }\n@@ -1081,161 +1058,0 @@\n-\/*\n- * The SelectVersion() routine ensures that an appropriate version of\n- * the JRE is running.  The specification for the appropriate version\n- * is obtained from either the manifest of a jar file (preferred) or\n- * from command line options.\n- * The routine also parses splash screen command line options and\n- * passes on their values in private environment variables.\n- *\/\n-static void\n-SelectVersion(int argc, char **argv, char **main_class)\n-{\n-    char    *arg;\n-    char    *operand;\n-    int     jarflag = 0;\n-    int     headlessflag = 0;\n-    manifest_info info;\n-    char    *splash_file_name = NULL;\n-    char    *splash_jar_name = NULL;\n-    char    *env_in;\n-    int     res;\n-    jboolean has_arg;\n-\n-    \/*\n-     * If the version has already been selected, set *main_class\n-     * with the value passed through the environment (if any) and\n-     * simply return.\n-     *\/\n-\n-    \/*\n-     * This environmental variable can be set by mJRE capable JREs\n-     * [ 1.5 thru 1.8 ].  All other aspects of mJRE processing have been\n-     * stripped by those JREs.  This environmental variable allows 1.9+\n-     * JREs to be started by these mJRE capable JREs.\n-     * Note that mJRE directives in the jar manifest file would have been\n-     * ignored for a JRE started by another JRE...\n-     * .. skipped for JRE 1.5 and beyond.\n-     * .. not even checked for pre 1.5.\n-     *\/\n-    if ((env_in = getenv(ENV_ENTRY)) != NULL) {\n-        if (*env_in != '\\0')\n-            *main_class = JLI_StringDup(env_in);\n-        return;\n-    }\n-\n-    \/*\n-     * Scan through the arguments for options relevant to multiple JRE\n-     * support.  Multiple JRE support existed in JRE versions 1.5 thru 1.8.\n-     *\n-     * This capability is no longer available with JRE versions 1.9 and later.\n-     * These command line options are reported as errors.\n-     *\/\n-\n-    argc--;\n-    argv++;\n-    while (argc > 0 && *(arg = *argv) == '-') {\n-        has_arg = IsOptionWithArgument(argc, argv);\n-        if (JLI_StrCCmp(arg, \"-version:\") == 0) {\n-            JLI_ReportErrorMessage(SPC_ERROR1);\n-        } else if (JLI_StrCmp(arg, \"-jre-restrict-search\") == 0) {\n-            JLI_ReportErrorMessage(SPC_ERROR2);\n-        } else if (JLI_StrCmp(arg, \"-jre-no-restrict-search\") == 0) {\n-            JLI_ReportErrorMessage(SPC_ERROR2);\n-        } else {\n-            if (JLI_StrCmp(arg, \"-jar\") == 0)\n-                jarflag = 1;\n-            if (IsWhiteSpaceOption(arg)) {\n-                if (has_arg) {\n-                    argc--;\n-                    argv++;\n-                    arg = *argv;\n-                }\n-            }\n-\n-            \/*\n-             * Checking for headless toolkit option in the some way as AWT does:\n-             * \"true\" means true and any other value means false\n-             *\/\n-            if (JLI_StrCmp(arg, \"-Djava.awt.headless=true\") == 0) {\n-                headlessflag = 1;\n-            } else if (JLI_StrCCmp(arg, \"-Djava.awt.headless=\") == 0) {\n-                headlessflag = 0;\n-            } else if (JLI_StrCCmp(arg, \"-splash:\") == 0) {\n-                splash_file_name = arg+8;\n-            }\n-        }\n-        argc--;\n-        argv++;\n-    }\n-    if (argc <= 0) {    \/* No operand? Possibly legit with -[full]version *\/\n-        operand = NULL;\n-    } else {\n-        argc--;\n-        operand = *argv++;\n-    }\n-\n-    \/*\n-     * If there is a jar file, read the manifest. If the jarfile can't be\n-     * read, the manifest can't be read from the jar file, or the manifest\n-     * is corrupt, issue the appropriate error messages and exit.\n-     *\n-     * Even if there isn't a jar file, construct a manifest_info structure\n-     * containing the command line information.  It's a convenient way to carry\n-     * this data around.\n-     *\/\n-    if (jarflag && operand) {\n-        if ((res = JLI_ParseManifest(operand, &info)) != 0) {\n-            if (res == -1)\n-                JLI_ReportErrorMessage(JAR_ERROR2, operand);\n-            else\n-                JLI_ReportErrorMessage(JAR_ERROR3, operand);\n-            exit(1);\n-        }\n-\n-        \/*\n-         * Command line splash screen option should have precedence\n-         * over the manifest, so the manifest data is used only if\n-         * splash_file_name has not been initialized above during command\n-         * line parsing\n-         *\/\n-        if (!headlessflag && !splash_file_name && info.splashscreen_image_file_name) {\n-            splash_file_name = info.splashscreen_image_file_name;\n-            splash_jar_name = operand;\n-        }\n-    } else {\n-        info.manifest_version = NULL;\n-        info.main_class = NULL;\n-        info.jre_version = NULL;\n-        info.jre_restrict_search = 0;\n-    }\n-\n-    \/*\n-     * Passing on splash screen info in environment variables\n-     *\/\n-    if (splash_file_name && !headlessflag) {\n-        splash_file_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_FILE_ENV_ENTRY \"=\")+JLI_StrLen(splash_file_name)+1);\n-        JLI_StrCpy(splash_file_entry, SPLASH_FILE_ENV_ENTRY \"=\");\n-        JLI_StrCat(splash_file_entry, splash_file_name);\n-        putenv(splash_file_entry);\n-    }\n-    if (splash_jar_name && !headlessflag) {\n-        splash_jar_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_JAR_ENV_ENTRY \"=\")+JLI_StrLen(splash_jar_name)+1);\n-        JLI_StrCpy(splash_jar_entry, SPLASH_JAR_ENV_ENTRY \"=\");\n-        JLI_StrCat(splash_jar_entry, splash_jar_name);\n-        putenv(splash_jar_entry);\n-    }\n-\n-\n-    \/*\n-     * \"Valid\" returns (other than unrecoverable errors) follow.  Set\n-     * main_class as a side-effect of this routine.\n-     *\/\n-    if (info.main_class != NULL)\n-        *main_class = JLI_StringDup(info.main_class);\n-\n-    if (info.jre_version == NULL) {\n-        JLI_FreeManifest();\n-        return;\n-    }\n-\n-}\n-\n@@ -1328,1 +1144,1 @@\n-               int *pret, const char *jrepath)\n+               int *pret)\n@@ -1334,0 +1150,2 @@\n+    int headlessflag = 0;\n+    char *splash_file_name = NULL;\n@@ -1392,0 +1210,7 @@\n+        } else if (JLI_StrCCmp(arg, \"-version:\") == 0) {\n+            REPORT_ERROR(NULL, SPC_ERROR1, arg);\n+        } else if (JLI_StrCmp(arg, \"-jre-restrict-search\") == 0) {\n+            REPORT_ERROR(NULL, SPC_ERROR2, arg);\n+        } else if (JLI_StrCmp(arg, \"-jre-no-restrict-search\") == 0) {\n+            REPORT_ERROR(NULL, SPC_ERROR2, arg);\n+\n@@ -1502,1 +1327,1 @@\n-            ; \/* Ignore machine independent options already handled *\/\n+            splash_file_name = arg+8;\n@@ -1511,0 +1336,8 @@\n+            } else if (JLI_StrCmp(arg, \"-Djava.awt.headless=true\") == 0) {\n+                \/*\n+                 * Checking for headless toolkit option in the some way as AWT does:\n+                 * \"true\" means true and any other value means false\n+                 *\/\n+                headlessflag = 1;\n+            } else if (JLI_StrCCmp(arg, \"-Djava.awt.headless=\") == 0) {\n+                headlessflag = 0;\n@@ -1523,0 +1356,1 @@\n+\n@@ -1561,0 +1395,4 @@\n+    launcherSplashInfo = (struct launcher_splash_info*) JLI_MemAlloc(sizeof(struct launcher_splash_info));\n+    launcherSplashInfo->headless = headlessflag;\n+    launcherSplashInfo->splash_file_name = splash_file_name;\n+\n@@ -1666,1 +1504,1 @@\n- * Calls LauncherHelper::checkAndLoadMain to verify that the main class\n+ * Calls LauncherHelper::locateMainEntry to verify that the main class\n@@ -1670,2 +1508,2 @@\n-static jclass\n-LoadMainClass(JNIEnv *env, int mode, char *name)\n+static jobject\n+LocateMainEntry(JNIEnv *env, int mode, char *name)\n@@ -1677,2 +1515,2 @@\n-    jclass cls = GetLauncherHelperClass(env);\n-    NULL_CHECK0(cls);\n+    jclass launcherHelperClass = GetLauncherHelperClass(env);\n+    NULL_CHECK0(launcherHelperClass);\n@@ -1682,3 +1520,3 @@\n-    NULL_CHECK0(mid = (*env)->GetStaticMethodID(env, cls,\n-                \"checkAndLoadMain\",\n-                \"(ZILjava\/lang\/String;)Ljava\/lang\/Class;\"));\n+    NULL_CHECK0(mid = (*env)->GetStaticMethodID(env, launcherHelperClass,\n+                                                \"locateMainEntry\",\n+                                                \"(ZILjava\/lang\/String;)Lsun\/launcher\/LauncherHelper$MainEntry;\"));\n@@ -1687,1 +1525,1 @@\n-    NULL_CHECK0(result = (*env)->CallStaticObjectMethod(env, cls, mid,\n+    NULL_CHECK0(result = (*env)->CallStaticObjectMethod(env, launcherHelperClass, mid,\n@@ -1692,1 +1530,1 @@\n-        printf(\"%ld micro seconds to load main class\\n\", (long)(end-start));\n+        printf(\"%ld micro seconds to locate main method\\n\", (long)(end-start));\n@@ -1696,17 +1534,1 @@\n-    return (jclass)result;\n-}\n-\n-static jclass\n-GetApplicationClass(JNIEnv *env)\n-{\n-    jmethodID mid;\n-    jclass appClass;\n-    jclass cls = GetLauncherHelperClass(env);\n-    NULL_CHECK0(cls);\n-    NULL_CHECK0(mid = (*env)->GetStaticMethodID(env, cls,\n-                \"getApplicationClass\",\n-                \"()Ljava\/lang\/Class;\"));\n-\n-    appClass = (*env)->CallStaticObjectMethod(env, cls, mid);\n-    CHECK_EXCEPTION_RETURN_VALUE(0);\n-    return appClass;\n+    return (jobject) result;\n@@ -2350,1 +2172,1 @@\n-    (void)UnsetEnv(ENV_ENTRY);\n+    (void)UnsetEnv(MAIN_CLASS_ENV_ENTRY);\n@@ -2356,1 +2178,4 @@\n-\n+    if (launcherSplashInfo) {\n+        JLI_MemFree(launcherSplashInfo);\n+        launcherSplashInfo = NULL;\n+    }\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":169,"deletions":344,"binary":false,"changes":513,"status":"modified"},{"patch":"@@ -54,15 +54,12 @@\n- * The following environment variable is used to influence the behavior\n- * of the jre exec'd through the SelectVersion routine.  The command line\n- * options which specify the version are not passed to the exec'd version,\n- * because that jre may be an older version which wouldn't recognize them.\n- * This environment variable is known to this (and later) version and serves\n- * to suppress the version selection code.  This is not only for efficiency,\n- * but also for correctness, since any command line options have been\n- * removed which would cause any value found in the manifest to be used.\n- * This would be incorrect because the command line options are defined\n- * to take precedence.\n- *\n- * The value associated with this environment variable is the MainClass\n- * name from within the executable jar file (if any). This is strictly a\n- * performance enhancement to avoid re-reading the jar file manifest.\n- *\n+ * Older versions of java launcher used to support JRE version selection.\n+ * Specifically, the java launcher in JDK 1.8 can be used to launch a java\n+ * application using a different java runtime (older, newer or same version JRE\n+ * installed at a different location) than the one the launcher belongs to. That support\n+ * was discontinued starting Java 9.\n+ * However, java launcher in JDK 1.8 can still be launched with JRE version selection\n+ * options to launch higher versioned java runtimes, including the current\n+ * JDK version. When it does that, this environment variable is set by\n+ * the Java 1.8 launcher. The value of this environment variable is the Main-Class name from\n+ * within the executable jar file (if any).\n+ * The java launcher in the current version of the JDK doesn't use this environment variable\n+ * in any way other than merely using it for debug logging.\n@@ -70,1 +67,1 @@\n-#define ENV_ENTRY \"_JAVA_VERSION_SET\"\n+#define MAIN_CLASS_ENV_ENTRY \"_JAVA_VERSION_SET\"\n","filename":"src\/java.base\/share\/native\/libjli\/java.h","additions":13,"deletions":16,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,14 +163,0 @@\n-\/*\n- * Information returned from the Manifest file by the ParseManifest() routine.\n- * Certainly (much) more could be returned, but this is the information\n- * currently of interest to the C based Java utilities (particularly the\n- * Java launcher).\n- *\/\n-typedef struct manifest_info {  \/* Interesting fields from the Manifest *\/\n-    char        *manifest_version;      \/* Manifest-Version string *\/\n-    char        *main_class;            \/* Main-Class entry *\/\n-    char        *jre_version;           \/* Appropriate J2SE release spec *\/\n-    char        jre_restrict_search;    \/* Restricted JRE search *\/\n-    char        *splashscreen_image_file_name; \/* splashscreen image file *\/\n-} manifest_info;\n-\n@@ -183,4 +169,0 @@\n-\/*\n- * Function prototypes.\n- *\/\n-int     JLI_ParseManifest(char *jarfile, manifest_info *info);\n@@ -189,1 +171,0 @@\n-void    JLI_FreeManifest(void);\n","filename":"src\/java.base\/share\/native\/libjli\/manifest_info.h","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,0 @@\n-static char     *manifest;\n-\n@@ -567,67 +565,0 @@\n-\/*\n- * Read the manifest from the specified jar file and fill in the manifest_info\n- * structure with the information found within.\n- *\n- * Error returns are as follows:\n- *    0 Success\n- *   -1 Unable to open jarfile\n- *   -2 Error accessing the manifest from within the jarfile (most likely\n- *      a manifest is not present, or this isn't a valid zip\/jar file).\n- *\/\n-int\n-JLI_ParseManifest(char *jarfile, manifest_info *info)\n-{\n-    int     fd;\n-    zentry  entry;\n-    char    *lp;\n-    char    *name;\n-    char    *value;\n-    int     rc;\n-\n-    if ((fd = JLI_Open(jarfile, O_RDONLY\n-#ifdef O_LARGEFILE\n-        | O_LARGEFILE \/* large file mode *\/\n-#endif\n-#ifdef O_BINARY\n-        | O_BINARY \/* use binary mode on windows *\/\n-#endif\n-        )) == -1) {\n-        return (-1);\n-    }\n-    info->manifest_version = NULL;\n-    info->main_class = NULL;\n-    info->jre_version = NULL;\n-    info->jre_restrict_search = 0;\n-    info->splashscreen_image_file_name = NULL;\n-    if ((rc = find_file(fd, &entry, manifest_name)) != 0) {\n-        close(fd);\n-        return (-2);\n-    }\n-    manifest = inflate_file(fd, &entry, NULL);\n-    if (manifest == NULL) {\n-        close(fd);\n-        return (-2);\n-    }\n-    lp = manifest;\n-    while ((rc = parse_nv_pair(&lp, &name, &value)) > 0) {\n-        if (JLI_StrCaseCmp(name, \"Manifest-Version\") == 0) {\n-            info->manifest_version = value;\n-        } else if (JLI_StrCaseCmp(name, \"Main-Class\") == 0) {\n-            info->main_class = value;\n-        } else if (JLI_StrCaseCmp(name, \"JRE-Version\") == 0) {\n-            \/*\n-             * Manifest specification overridden by command line option\n-             * so we will silently override there with no specification.\n-             *\/\n-            info->jre_version = 0;\n-        } else if (JLI_StrCaseCmp(name, \"Splashscreen-Image\") == 0) {\n-            info->splashscreen_image_file_name = value;\n-        }\n-    }\n-    close(fd);\n-    if (rc == 0)\n-        return (0);\n-    else\n-        return (-2);\n-}\n-\n@@ -661,10 +592,0 @@\n-\/*\n- * Specialized \"free\" function.\n- *\/\n-void\n-JLI_FreeManifest()\n-{\n-    if (manifest)\n-        free(manifest);\n-}\n-\n","filename":"src\/java.base\/share\/native\/libjli\/parse_manifest.c","additions":1,"deletions":80,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -63,4 +63,0 @@\n- * The version specification (if any) is processed first by the\n- * platform independent routine SelectVersion.  This may result in\n- * the exec of the specified launcher version.\n- *\n@@ -720,1 +716,0 @@\n-    ShowSplashScreen();\n@@ -727,1 +722,1 @@\n-    \/\/ stubbed out for windows and *nixes.\n+    ShowSplashScreen();\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.c","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -921,1 +921,0 @@\n-    ShowSplashScreen();\n@@ -928,1 +927,1 @@\n-    \/\/ stubbed out for windows and *nixes.\n+    ShowSplashScreen();\n","filename":"src\/java.base\/windows\/native\/libjli\/java_md.c","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,2 +115,12 @@\n-        errorMessages.forEach(tr::contains);\n-\n+        boolean foundAnyExpectedErrMsgs = false;\n+        for (String errMsg : errorMessages) {\n+            if (tr.contains(errMsg)) {\n+                foundAnyExpectedErrMsgs = true;\n+                break;\n+            }\n+        }\n+        if (!foundAnyExpectedErrMsgs) {\n+            errorMessages.forEach((errMsg) -> {\n+                tr.appendError(\"string <\" + errMsg + \"> not found\");\n+            });\n+        }\n","filename":"test\/jdk\/tools\/launcher\/MultipleJRERemoved.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,197 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.FileOutputStream;\n+import java.io.FilterOutputStream;\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.jar.Attributes;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+import java.util.jar.Manifest;\n+import java.util.zip.CRC32;\n+\n+import jdk.test.lib.compiler.CompilerUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import org.junit.jupiter.api.Test;\n+import static java.util.zip.ZipEntry.STORED;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8328995\n+ * @summary verifies that java -jar can launch a zip64 jar file\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.process.ProcessTools jdk.test.lib.compiler.CompilerUtils\n+ * @run junit Zip64ExecutableJarTest\n+ *\/\n+public class Zip64ExecutableJarTest {\n+    \/\/ size in bytes to trigger representing ZIP entries as ZIP64 in the CEN\n+    private static final long ZIP64_SIZE_MAGICVAL = 0xFFFFFFFFL;\n+    private static final Path SCRATCH_DIR = Path.of(\".\");\n+    private static final String MAIN_CLASS = \"foo.Bar\";\n+    private static final String MAIN_CLASS_CONTENT = \"\"\"\n+            package foo;\n+            public class Bar {\n+                public static void main(final String[] args) throws Exception {\n+                    System.out.println(\"hello world from \" + Bar.class.getName());\n+                }\n+            }\n+            \"\"\";\n+\n+    \/*\n+     * Creates a ZIP64 executable JAR file and verifies that \"java -jar\" against\n+     * that file correctly launches the application class.\n+     *\/\n+    @Test\n+    public void testLaunchZip64() throws Exception {\n+        final Path mainClassFile = compileMainClass();\n+        final Path zip64JarFile = createZip64Jar(mainClassFile);\n+        System.out.println(\"created zip64 jar at \" + zip64JarFile);\n+        \/\/ java -jar <jar>\n+        final OutputAnalyzer oa = ProcessTools.executeTestJava(\"-jar\",\n+                zip64JarFile.toAbsolutePath().toString());\n+        oa.shouldHaveExitValue(0);\n+        oa.shouldContain(\"hello world from \" + MAIN_CLASS);\n+    }\n+\n+    \/*\n+     * Compile the application class that will be packaged into the JAR file.\n+     *\/\n+    private static Path compileMainClass() throws Exception {\n+        \/\/ create foo\/Bar.java\n+        final Path javaSrcDir = Files.createTempDirectory(SCRATCH_DIR, \"8328995-java-src-\");\n+        final Path javaSrcFile = javaSrcDir.resolve(\"foo\").resolve(\"Bar.java\");\n+        Files.createDirectories(javaSrcFile.getParent());\n+        Files.writeString(javaSrcFile, MAIN_CLASS_CONTENT);\n+        \/\/ compile foo\/Bar.java into a classes dir\n+        final Path classesDir = Files.createTempDirectory(SCRATCH_DIR, \"8328995-classes-\");\n+        final boolean compiled = CompilerUtils.compile(javaSrcFile, classesDir);\n+        assertTrue(compiled, \"failed to compile \" + javaSrcFile);\n+        final Path mainClassFile = classesDir.resolve(\"foo\").resolve(\"Bar.class\");\n+        assertTrue(Files.isRegularFile(mainClassFile), \"missing compiled class file at \"\n+                + mainClassFile);\n+        return mainClassFile;\n+    }\n+\n+    \/*\n+     * Create the ZIP64 JAR file\n+     *\/\n+    private static Path createZip64Jar(final Path mainClassFile) throws Exception {\n+        final Path jarFile = Files.createTempFile(SCRATCH_DIR, \"8328995-\", \".jar\");\n+        try (final SparseOutputStream sos =\n+                     new SparseOutputStream(new FileOutputStream(jarFile.toFile()));\n+             final JarOutputStream jaros = new JarOutputStream(sos)) {\n+            \/\/ aad an entry with a large size so that ZipOutputStream\n+            \/\/ creates ZIP64 data while writing the CEN\n+            forceCreateLargeZip64Entry(jaros);\n+            \/\/ now that the large entry has been written as sparse holes, we now\n+            \/\/ switch to writing the actual bytes for the rest of the entries\n+            sos.sparse = false;\n+            \/\/ add the main class\n+            final JarEntry mainClassEntry = new JarEntry(MAIN_CLASS.replace('.', '\/') + \".class\");\n+            jaros.putNextEntry(mainClassEntry);\n+            jaros.write(Files.readAllBytes(mainClassFile));\n+            jaros.closeEntry();\n+            \/\/ finally add the META-INF\/MANIFEST.MF\n+            final Manifest manifest = new Manifest();\n+            final Attributes mainAttributes = manifest.getMainAttributes();\n+            mainAttributes.putValue(\"Manifest-Version\", \"1.0\");\n+            mainAttributes.putValue(\"Main-Class\", MAIN_CLASS);\n+            final JarEntry manifestEntry = new JarEntry(\"META-INF\/MANIFEST.MF\");\n+            jaros.putNextEntry(manifestEntry);\n+            manifest.write(jaros);\n+            jaros.closeEntry();\n+        }\n+        return jarFile;\n+    }\n+\n+    private static void forceCreateLargeZip64Entry(final JarOutputStream jaros) throws IOException {\n+        final JarEntry entry = new JarEntry(\"entry-1\");\n+        entry.setMethod(STORED); \/\/ no need to deflate, we want the entry to be large sized\n+        entry.setSize(ZIP64_SIZE_MAGICVAL);\n+        \/\/ start with a dummy value, we will update it once the entry content is written\n+        entry.setCrc(0);\n+        jaros.putNextEntry(entry);\n+        long numWritten = 0;\n+        final byte[] entryContent = new byte[102400];\n+        final CRC32 crc = new CRC32();\n+        \/\/ keep writing the entry content till we reach the\n+        \/\/ desired size that represents a zip64 entry\n+        while (numWritten < ZIP64_SIZE_MAGICVAL) {\n+            final long remaining = ZIP64_SIZE_MAGICVAL - numWritten;\n+            final int len = remaining < entryContent.length\n+                    ? (int) remaining\n+                    : entryContent.length;\n+            jaros.write(entryContent, 0, len);\n+            numWritten += len;\n+            crc.update(entryContent, 0, len);\n+        }\n+        entry.setCrc(crc.getValue()); \/\/ update the CRC in the entry\n+        jaros.closeEntry();\n+    }\n+\n+    \/*\n+     * An OutputStream which writes holes through its write() methods, until it is\n+     * instructed to write the actual bytes. This implementation allows us to create large\n+     * ZIP files without actually consuming large disk space.\n+     * Instances of this class should be passed directly to the ZipOutputStream\/JarOutputStream\n+     * constructor, without any buffering, to allow for the implementation to correctly keep\n+     * track of when to and when not to write holes.\n+     *\/\n+    private static class SparseOutputStream extends FilterOutputStream {\n+        private final FileChannel channel;\n+        private boolean sparse = true; \/\/ if true then contents will be written as sparse holes\n+        private long position;\n+\n+        public SparseOutputStream(FileOutputStream fos) {\n+            super(fos);\n+            this.channel = fos.getChannel();\n+        }\n+\n+        @Override\n+        public void write(byte[] b, int off, int len) throws IOException {\n+            position += len;\n+            if (sparse) {\n+                channel.position(position);\n+            } else {\n+                \/\/ regular write\n+                out.write(b, off, len);\n+            }\n+        }\n+\n+        @Override\n+        public void write(int b) throws IOException {\n+            position++;\n+            if (sparse) {\n+                channel.position(position);\n+            } else {\n+                \/\/ regular write\n+                out.write(b);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/launcher\/Zip64ExecutableJarTest.java","additions":197,"deletions":0,"binary":false,"changes":197,"status":"added"}]}