{"files":[{"patch":"@@ -1,4164 +1,4567 @@\n-\/*\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.util;\n-\n-import java.util.concurrent.CountedCompleter;\n-import java.util.concurrent.RecursiveTask;\n-\n-\/**\n- * This class implements powerful and fully optimized versions, both\n- * sequential and parallel, of the Dual-Pivot Quicksort algorithm by\n- * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\n- * offers O(n log(n)) performance on all data sets, and is typically\n- * faster than traditional (one-pivot) Quicksort implementations.\n- *\n- * There are also additional algorithms, invoked from the Dual-Pivot\n- * Quicksort, such as mixed insertion sort, merging of runs and heap\n- * sort, counting sort and parallel merge sort.\n- *\n- * @author Vladimir Yaroslavskiy\n- * @author Jon Bentley\n- * @author Josh Bloch\n- * @author Doug Lea\n- *\n- * @version 2018.08.18\n- *\n- * @since 1.7 * 14\n- *\/\n-final class DualPivotQuicksort {\n-\n-    \/**\n-     * Prevents instantiation.\n-     *\/\n-    private DualPivotQuicksort() {}\n-\n-    \/**\n-     * Max array size to use mixed insertion sort.\n-     *\/\n-    private static final int MAX_MIXED_INSERTION_SORT_SIZE = 65;\n-\n-    \/**\n-     * Max array size to use insertion sort.\n-     *\/\n-    private static final int MAX_INSERTION_SORT_SIZE = 44;\n-\n-    \/**\n-     * Min array size to perform sorting in parallel.\n-     *\/\n-    private static final int MIN_PARALLEL_SORT_SIZE = 4 << 10;\n-\n-    \/**\n-     * Min array size to try merging of runs.\n-     *\/\n-    private static final int MIN_TRY_MERGE_SIZE = 4 << 10;\n-\n-    \/**\n-     * Min size of the first run to continue with scanning.\n-     *\/\n-    private static final int MIN_FIRST_RUN_SIZE = 16;\n-\n-    \/**\n-     * Min factor for the first runs to continue scanning.\n-     *\/\n-    private static final int MIN_FIRST_RUNS_FACTOR = 7;\n-\n-    \/**\n-     * Max capacity of the index array for tracking runs.\n-     *\/\n-    private static final int MAX_RUN_CAPACITY = 5 << 10;\n-\n-    \/**\n-     * Min number of runs, required by parallel merging.\n-     *\/\n-    private static final int MIN_RUN_COUNT = 4;\n-\n-    \/**\n-     * Min array size to use parallel merging of parts.\n-     *\/\n-    private static final int MIN_PARALLEL_MERGE_PARTS_SIZE = 4 << 10;\n-\n-    \/**\n-     * Min size of a byte array to use counting sort.\n-     *\/\n-    private static final int MIN_BYTE_COUNTING_SORT_SIZE = 64;\n-\n-    \/**\n-     * Min size of a short or char array to use counting sort.\n-     *\/\n-    private static final int MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE = 1750;\n-\n-    \/**\n-     * Threshold of mixed insertion sort is incremented by this value.\n-     *\/\n-    private static final int DELTA = 3 << 1;\n-\n-    \/**\n-     * Max recursive partitioning depth before using heap sort.\n-     *\/\n-    private static final int MAX_RECURSION_DEPTH = 64 * DELTA;\n-\n-    \/**\n-     * Calculates the double depth of parallel merging.\n-     * Depth is negative, if tasks split before sorting.\n-     *\n-     * @param parallelism the parallelism level\n-     * @param size the target size\n-     * @return the depth of parallel merging\n-     *\/\n-    private static int getDepth(int parallelism, int size) {\n-        int depth = 0;\n-\n-        while ((parallelism >>= 3) > 0 && (size >>= 2) > 0) {\n-            depth -= 2;\n-        }\n-        return depth;\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using parallel merge\n-     * sort and\/or Dual-Pivot Quicksort.\n-     *\n-     * To balance the faster splitting and parallelism of merge sort\n-     * with the faster element partitioning of Quicksort, ranges are\n-     * subdivided in tiers such that, if there is enough parallelism,\n-     * the four-way parallel merge is started, still ensuring enough\n-     * parallelism to process the partitions.\n-     *\n-     * @param a the array to be sorted\n-     * @param parallelism the parallelism level\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    static void sort(int[] a, int parallelism, int low, int high) {\n-        int size = high - low;\n-\n-        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n-            int depth = getDepth(parallelism, size >> 12);\n-            int[] b = depth == 0 ? null : new int[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n-        } else {\n-            sort(null, a, 0, low, high);\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n-     *\n-     * @param sorter parallel context\n-     * @param a the array to be sorted\n-     * @param bits the combination of recursion depth and bit flag, where\n-     *        the right bit \"0\" indicates that array is the leftmost part\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    static void sort(Sorter sorter, int[] a, int bits, int low, int high) {\n-        while (true) {\n-            int end = high - 1, size = high - low;\n-\n-            \/*\n-             * Run mixed insertion sort on small non-leftmost parts.\n-             *\/\n-            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n-                mixedInsertionSort(a, low, high - 3 * ((size >> 5) << 3), high);\n-                return;\n-            }\n-\n-            \/*\n-             * Invoke insertion sort on small leftmost part.\n-             *\/\n-            if (size < MAX_INSERTION_SORT_SIZE) {\n-                insertionSort(a, low, high);\n-                return;\n-            }\n-\n-            \/*\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n-             *\/\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n-                return;\n-            }\n-\n-            \/*\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n-             *\/\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n-                return;\n-            }\n-\n-            \/*\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n-             *\/\n-            int step = (size >> 3) * 3 + 3;\n-\n-            \/*\n-             * Five elements around (and including) the central element\n-             * will be used for pivot selection as described below. The\n-             * unequal choice of spacing these elements was empirically\n-             * determined to work well on a wide variety of inputs.\n-             *\/\n-            int e1 = low + step;\n-            int e5 = end - step;\n-            int e3 = (e1 + e5) >>> 1;\n-            int e2 = (e1 + e3) >>> 1;\n-            int e4 = (e3 + e5) >>> 1;\n-            int a3 = a[e3];\n-\n-            \/*\n-             * Sort these elements in place by the combination\n-             * of 4-element sorting network and insertion sort.\n-             *\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n-             *\/\n-            if (a[e5] < a[e2]) { int t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { int t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { int t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { int t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { int t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n-\n-            if (a3 < a[e2]) {\n-                if (a3 < a[e1]) {\n-                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\n-                } else {\n-                    a[e3] = a[e2]; a[e2] = a3;\n-                }\n-            } else if (a3 > a[e4]) {\n-                if (a3 > a[e5]) {\n-                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\n-                } else {\n-                    a[e3] = a[e4]; a[e4] = a3;\n-                }\n-            }\n-\n-            \/\/ Pointers\n-            int lower = low; \/\/ The index of the last element of the left part\n-            int upper = end; \/\/ The index of the first element of the right part\n-\n-            \/*\n-             * Partitioning with 2 pivots in case of different elements.\n-             *\/\n-            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n-\n-                \/*\n-                 * Use the first and fifth of the five sorted elements as\n-                 * the pivots. These values are inexpensive approximation\n-                 * of tertiles. Note, that pivot1 < pivot2.\n-                 *\/\n-                int pivot1 = a[e1];\n-                int pivot2 = a[e5];\n-\n-                \/*\n-                 * The first and the last elements to be sorted are moved\n-                 * to the locations formerly occupied by the pivots. When\n-                 * partitioning is completed, the pivots are swapped back\n-                 * into their final positions, and excluded from the next\n-                 * subsequent sorting.\n-                 *\/\n-                a[e1] = a[lower];\n-                a[e5] = a[upper];\n-\n-                \/*\n-                 * Skip elements, which are less or greater than the pivots.\n-                 *\/\n-                while (a[++lower] < pivot1);\n-                while (a[--upper] > pivot2);\n-\n-                \/*\n-                 * Backward 3-interval partitioning\n-                 *\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int unused = --lower, k = ++upper; --k > lower; ) {\n-                    int ak = a[k];\n-\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n-                                break;\n-                            }\n-                        }\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n-                        a[k] = a[--upper];\n-                        a[upper] = ak;\n-                    }\n-                }\n-\n-                \/*\n-                 * Swap the pivots into their final positions.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot1;\n-                a[end] = a[upper]; a[upper] = pivot2;\n-\n-                \/*\n-                 * Sort non-left parts recursively (possibly in parallel),\n-                 * excluding known pivots.\n-                 *\/\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n-                } else {\n-                    sort(sorter, a, bits | 1, lower + 1, upper);\n-                    sort(sorter, a, bits | 1, upper + 1, high);\n-                }\n-\n-            } else { \/\/ Use single pivot in case of many equal elements\n-\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                int pivot = a[e3];\n-\n-                \/*\n-                 * The first element to be sorted is moved to the\n-                 * location formerly occupied by the pivot. After\n-                 * completion of partitioning the pivot is swapped\n-                 * back into its final position, and excluded from\n-                 * the next subsequent sorting.\n-                 *\/\n-                a[e3] = a[lower];\n-\n-                \/*\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n-                 *\n-                 *   left part                 central part    right part\n-                 * +------------------------------------------------------+\n-                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-                 * +------------------------------------------------------+\n-                 *              ^           ^                ^\n-                 *              |           |                |\n-                 *            lower         k              upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int k = ++upper; --k > lower; ) {\n-                    int ak = a[k];\n-\n-                    if (ak != pivot) {\n-                        a[k] = pivot;\n-\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n-                            while (a[++lower] < pivot);\n-\n-                            if (a[lower] > pivot) {\n-                                a[--upper] = a[lower];\n-                            }\n-                            a[lower] = ak;\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n-                            a[--upper] = ak;\n-                        }\n-                    }\n-                }\n-\n-                \/*\n-                 * Swap the pivot into its final position.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot;\n-\n-                \/*\n-                 * Sort the right part (possibly in parallel), excluding\n-                 * known pivot. All elements from the central part are\n-                 * equal and therefore already sorted.\n-                 *\/\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.forkSorter(bits | 1, upper, high);\n-                } else {\n-                    sort(sorter, a, bits | 1, upper, high);\n-                }\n-            }\n-            high = lower; \/\/ Iterate along the left part\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using mixed insertion sort.\n-     *\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n-     *\n-     * In the context of Dual-Pivot Quicksort, the pivot element\n-     * from the left part plays the role of sentinel, because it\n-     * is less than any elements from the given part. Therefore,\n-     * expensive check of the left range can be skipped on each\n-     * iteration unless it is the leftmost call.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param end the index of the last element for simple insertion sort\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void mixedInsertionSort(int[] a, int low, int end, int high) {\n-        if (end == high) {\n-\n-            \/*\n-             * Invoke simple insertion sort on tiny array.\n-             *\/\n-            for (int i; ++low < end; ) {\n-                int ai = a[i = low];\n-\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        } else {\n-\n-            \/*\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n-             *\/\n-            int pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                int ai = a[i = low];\n-\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n-\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n-\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n-            }\n-\n-            \/*\n-             * Continue with pair insertion sort on remain part.\n-             *\/\n-            for (int i; low < high; ++low) {\n-                int a1 = a[i = low], a2 = a[++low];\n-\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n-\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n-\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n-\n-                } else if (a1 < a[i - 1]) {\n-\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n-\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using insertion sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void insertionSort(int[] a, int low, int high) {\n-        for (int i, k = low; ++k < high; ) {\n-            int ai = a[i = k];\n-\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using heap sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void heapSort(int[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            int max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n-\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(int[] a, int p, int value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n-\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n-            }\n-        }\n-        a[p] = value;\n-    }\n-\n-    \/**\n-     * Tries to sort the specified range of the array.\n-     *\n-     * @param sorter parallel context\n-     * @param a the array to be sorted\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n-     * @return true if finally sorted, false otherwise\n-     *\/\n-    private static boolean tryMergeRuns(Sorter sorter, int[] a, int low, int size) {\n-\n-        \/*\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n-         *\/\n-        int[] run = null;\n-        int high = low + size;\n-        int count = 1, last = low;\n-\n-        \/*\n-         * Identify all possible runs.\n-         *\/\n-        for (int k = low + 1; k < high; ) {\n-\n-            \/*\n-             * Find the end index of the current run.\n-             *\/\n-            if (a[k - 1] < a[k]) {\n-\n-                \/\/ Identify ascending sequence\n-                while (++k < high && a[k - 1] <= a[k]);\n-\n-            } else if (a[k - 1] > a[k]) {\n-\n-                \/\/ Identify descending sequence\n-                while (++k < high && a[k - 1] >= a[k]);\n-\n-                \/\/ Reverse into ascending order\n-                for (int i = last - 1, j = k; ++i < --j && a[i] > a[j]; ) {\n-                    int ai = a[i]; a[i] = a[j]; a[j] = ai;\n-                }\n-            } else { \/\/ Identify constant sequence\n-                for (int ak = a[k]; ++k < high && ak == a[k]; );\n-\n-                if (k < high) {\n-                    continue;\n-                }\n-            }\n-\n-            \/*\n-             * Check special cases.\n-             *\/\n-            if (run == null) {\n-                if (k == high) {\n-\n-                    \/*\n-                     * The array is monotonous sequence,\n-                     * and therefore already sorted.\n-                     *\/\n-                    return true;\n-                }\n-\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n-                run[0] = low;\n-\n-            } else if (a[last - 1] > a[last]) {\n-\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n-\n-                    \/*\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                if (++count == MAX_RUN_CAPACITY) {\n-\n-                    \/*\n-                     * Array is not highly structured.\n-                     *\/\n-                    return false;\n-                }\n-\n-                if (count == run.length) {\n-\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n-            }\n-            run[count] = (last = k);\n-        }\n-\n-        \/*\n-         * Merge runs of highly structured array.\n-         *\/\n-        if (count > 1) {\n-            int[] b; int offset = low;\n-\n-            if (sorter == null || (b = (int[]) sorter.b) == null) {\n-                b = new int[size];\n-            } else {\n-                offset = sorter.offset;\n-            }\n-            mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);\n-        }\n-        return true;\n-    }\n-\n-    \/**\n-     * Merges the specified runs.\n-     *\n-     * @param a the source array\n-     * @param b the temporary buffer used in merging\n-     * @param offset the start index in the source, inclusive\n-     * @param aim specifies merging: to source ( > 0), buffer ( < 0) or any ( == 0)\n-     * @param parallel indicates whether merging is performed in parallel\n-     * @param run the start indexes of the runs, inclusive\n-     * @param lo the start index of the first run, inclusive\n-     * @param hi the start index of the last run, inclusive\n-     * @return the destination where runs are merged\n-     *\/\n-    private static int[] mergeRuns(int[] a, int[] b, int offset,\n-            int aim, boolean parallel, int[] run, int lo, int hi) {\n-\n-        if (hi - lo == 1) {\n-            if (aim >= 0) {\n-                return a;\n-            }\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n-            return b;\n-        }\n-\n-        \/*\n-         * Split into approximately equal parts.\n-         *\/\n-        int mi = lo, rmi = (run[lo] + run[hi]) >>> 1;\n-        while (run[++mi + 1] <= rmi);\n-\n-        \/*\n-         * Merge the left and right parts.\n-         *\/\n-        int[] a1, a2;\n-\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (int[]) merger.getDestination();\n-        } else {\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n-        }\n-\n-        int[] dst = a1 == a ? b : a;\n-\n-        int k   = a1 == a ? run[lo] - offset : run[lo];\n-        int lo1 = a1 == b ? run[lo] - offset : run[lo];\n-        int hi1 = a1 == b ? run[mi] - offset : run[mi];\n-        int lo2 = a2 == b ? run[mi] - offset : run[mi];\n-        int hi2 = a2 == b ? run[hi] - offset : run[hi];\n-\n-        if (parallel) {\n-            new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\n-        } else {\n-            mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);\n-        }\n-        return dst;\n-    }\n-\n-    \/**\n-     * Merges the sorted parts.\n-     *\n-     * @param merger parallel context\n-     * @param dst the destination where parts are merged\n-     * @param k the start index of the destination, inclusive\n-     * @param a1 the first part\n-     * @param lo1 the start index of the first part, inclusive\n-     * @param hi1 the end index of the first part, exclusive\n-     * @param a2 the second part\n-     * @param lo2 the start index of the second part, inclusive\n-     * @param hi2 the end index of the second part, exclusive\n-     *\/\n-    private static void mergeParts(Merger merger, int[] dst, int k,\n-            int[] a1, int lo1, int hi1, int[] a2, int lo2, int hi2) {\n-\n-        if (merger != null && a1 == a2) {\n-\n-            while (true) {\n-\n-                \/*\n-                 * The first part must be larger.\n-                 *\/\n-                if (hi1 - lo1 < hi2 - lo2) {\n-                    int lo = lo1; lo1 = lo2; lo2 = lo;\n-                    int hi = hi1; hi1 = hi2; hi2 = hi;\n-                }\n-\n-                \/*\n-                 * Small parts will be merged sequentially.\n-                 *\/\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n-                    break;\n-                }\n-\n-                \/*\n-                 * Find the median of the larger part.\n-                 *\/\n-                int mi1 = (lo1 + hi1) >>> 1;\n-                int key = a1[mi1];\n-                int mi2 = hi2;\n-\n-                \/*\n-                 * Partition the smaller part.\n-                 *\/\n-                for (int loo = lo2; loo < mi2; ) {\n-                    int t = (loo + mi2) >>> 1;\n-\n-                    if (key > a2[t]) {\n-                        loo = t + 1;\n-                    } else {\n-                        mi2 = t;\n-                    }\n-                }\n-\n-                int d = mi2 - lo2 + mi1 - lo1;\n-\n-                \/*\n-                 * Merge the right sub-parts in parallel.\n-                 *\/\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n-\n-                \/*\n-                 * Process the sub-left parts.\n-                 *\/\n-                hi1 = mi1;\n-                hi2 = mi2;\n-            }\n-        }\n-\n-        \/*\n-         * Merge small parts sequentially.\n-         *\/\n-        while (lo1 < hi1 && lo2 < hi2) {\n-            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\n-        }\n-        if (dst != a1 || k < lo1) {\n-            while (lo1 < hi1) {\n-                dst[k++] = a1[lo1++];\n-            }\n-        }\n-        if (dst != a2 || k < lo2) {\n-            while (lo2 < hi2) {\n-                dst[k++] = a2[lo2++];\n-            }\n-        }\n-    }\n-\n-\/\/ [long]\n-\n-    \/**\n-     * Sorts the specified range of the array using parallel merge\n-     * sort and\/or Dual-Pivot Quicksort.\n-     *\n-     * To balance the faster splitting and parallelism of merge sort\n-     * with the faster element partitioning of Quicksort, ranges are\n-     * subdivided in tiers such that, if there is enough parallelism,\n-     * the four-way parallel merge is started, still ensuring enough\n-     * parallelism to process the partitions.\n-     *\n-     * @param a the array to be sorted\n-     * @param parallelism the parallelism level\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    static void sort(long[] a, int parallelism, int low, int high) {\n-        int size = high - low;\n-\n-        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n-            int depth = getDepth(parallelism, size >> 12);\n-            long[] b = depth == 0 ? null : new long[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n-        } else {\n-            sort(null, a, 0, low, high);\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n-     *\n-     * @param sorter parallel context\n-     * @param a the array to be sorted\n-     * @param bits the combination of recursion depth and bit flag, where\n-     *        the right bit \"0\" indicates that array is the leftmost part\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    static void sort(Sorter sorter, long[] a, int bits, int low, int high) {\n-        while (true) {\n-            int end = high - 1, size = high - low;\n-\n-            \/*\n-             * Run mixed insertion sort on small non-leftmost parts.\n-             *\/\n-            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n-                mixedInsertionSort(a, low, high - 3 * ((size >> 5) << 3), high);\n-                return;\n-            }\n-\n-            \/*\n-             * Invoke insertion sort on small leftmost part.\n-             *\/\n-            if (size < MAX_INSERTION_SORT_SIZE) {\n-                insertionSort(a, low, high);\n-                return;\n-            }\n-\n-            \/*\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n-             *\/\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n-                return;\n-            }\n-\n-            \/*\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n-             *\/\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n-                return;\n-            }\n-\n-            \/*\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n-             *\/\n-            int step = (size >> 3) * 3 + 3;\n-\n-            \/*\n-             * Five elements around (and including) the central element\n-             * will be used for pivot selection as described below. The\n-             * unequal choice of spacing these elements was empirically\n-             * determined to work well on a wide variety of inputs.\n-             *\/\n-            int e1 = low + step;\n-            int e5 = end - step;\n-            int e3 = (e1 + e5) >>> 1;\n-            int e2 = (e1 + e3) >>> 1;\n-            int e4 = (e3 + e5) >>> 1;\n-            long a3 = a[e3];\n-\n-            \/*\n-             * Sort these elements in place by the combination\n-             * of 4-element sorting network and insertion sort.\n-             *\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n-             *\/\n-            if (a[e5] < a[e2]) { long t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { long t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { long t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { long t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { long t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n-\n-            if (a3 < a[e2]) {\n-                if (a3 < a[e1]) {\n-                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\n-                } else {\n-                    a[e3] = a[e2]; a[e2] = a3;\n-                }\n-            } else if (a3 > a[e4]) {\n-                if (a3 > a[e5]) {\n-                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\n-                } else {\n-                    a[e3] = a[e4]; a[e4] = a3;\n-                }\n-            }\n-\n-            \/\/ Pointers\n-            int lower = low; \/\/ The index of the last element of the left part\n-            int upper = end; \/\/ The index of the first element of the right part\n-\n-            \/*\n-             * Partitioning with 2 pivots in case of different elements.\n-             *\/\n-            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n-\n-                \/*\n-                 * Use the first and fifth of the five sorted elements as\n-                 * the pivots. These values are inexpensive approximation\n-                 * of tertiles. Note, that pivot1 < pivot2.\n-                 *\/\n-                long pivot1 = a[e1];\n-                long pivot2 = a[e5];\n-\n-                \/*\n-                 * The first and the last elements to be sorted are moved\n-                 * to the locations formerly occupied by the pivots. When\n-                 * partitioning is completed, the pivots are swapped back\n-                 * into their final positions, and excluded from the next\n-                 * subsequent sorting.\n-                 *\/\n-                a[e1] = a[lower];\n-                a[e5] = a[upper];\n-\n-                \/*\n-                 * Skip elements, which are less or greater than the pivots.\n-                 *\/\n-                while (a[++lower] < pivot1);\n-                while (a[--upper] > pivot2);\n-\n-                \/*\n-                 * Backward 3-interval partitioning\n-                 *\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int unused = --lower, k = ++upper; --k > lower; ) {\n-                    long ak = a[k];\n-\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n-                                break;\n-                            }\n-                        }\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n-                        a[k] = a[--upper];\n-                        a[upper] = ak;\n-                    }\n-                }\n-\n-                \/*\n-                 * Swap the pivots into their final positions.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot1;\n-                a[end] = a[upper]; a[upper] = pivot2;\n-\n-                \/*\n-                 * Sort non-left parts recursively (possibly in parallel),\n-                 * excluding known pivots.\n-                 *\/\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n-                } else {\n-                    sort(sorter, a, bits | 1, lower + 1, upper);\n-                    sort(sorter, a, bits | 1, upper + 1, high);\n-                }\n-\n-            } else { \/\/ Use single pivot in case of many equal elements\n-\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                long pivot = a[e3];\n-\n-                \/*\n-                 * The first element to be sorted is moved to the\n-                 * location formerly occupied by the pivot. After\n-                 * completion of partitioning the pivot is swapped\n-                 * back into its final position, and excluded from\n-                 * the next subsequent sorting.\n-                 *\/\n-                a[e3] = a[lower];\n-\n-                \/*\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n-                 *\n-                 *   left part                 central part    right part\n-                 * +------------------------------------------------------+\n-                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-                 * +------------------------------------------------------+\n-                 *              ^           ^                ^\n-                 *              |           |                |\n-                 *            lower         k              upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int k = ++upper; --k > lower; ) {\n-                    long ak = a[k];\n-\n-                    if (ak != pivot) {\n-                        a[k] = pivot;\n-\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n-                            while (a[++lower] < pivot);\n-\n-                            if (a[lower] > pivot) {\n-                                a[--upper] = a[lower];\n-                            }\n-                            a[lower] = ak;\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n-                            a[--upper] = ak;\n-                        }\n-                    }\n-                }\n-\n-                \/*\n-                 * Swap the pivot into its final position.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot;\n-\n-                \/*\n-                 * Sort the right part (possibly in parallel), excluding\n-                 * known pivot. All elements from the central part are\n-                 * equal and therefore already sorted.\n-                 *\/\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.forkSorter(bits | 1, upper, high);\n-                } else {\n-                    sort(sorter, a, bits | 1, upper, high);\n-                }\n-            }\n-            high = lower; \/\/ Iterate along the left part\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using mixed insertion sort.\n-     *\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n-     *\n-     * In the context of Dual-Pivot Quicksort, the pivot element\n-     * from the left part plays the role of sentinel, because it\n-     * is less than any elements from the given part. Therefore,\n-     * expensive check of the left range can be skipped on each\n-     * iteration unless it is the leftmost call.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param end the index of the last element for simple insertion sort\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void mixedInsertionSort(long[] a, int low, int end, int high) {\n-        if (end == high) {\n-\n-            \/*\n-             * Invoke simple insertion sort on tiny array.\n-             *\/\n-            for (int i; ++low < end; ) {\n-                long ai = a[i = low];\n-\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        } else {\n-\n-            \/*\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n-             *\/\n-            long pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                long ai = a[i = low];\n-\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n-\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n-\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n-            }\n-\n-            \/*\n-             * Continue with pair insertion sort on remain part.\n-             *\/\n-            for (int i; low < high; ++low) {\n-                long a1 = a[i = low], a2 = a[++low];\n-\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n-\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n-\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n-\n-                } else if (a1 < a[i - 1]) {\n-\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n-\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using insertion sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void insertionSort(long[] a, int low, int high) {\n-        for (int i, k = low; ++k < high; ) {\n-            long ai = a[i = k];\n-\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using heap sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void heapSort(long[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            long max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n-\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(long[] a, int p, long value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n-\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n-            }\n-        }\n-        a[p] = value;\n-    }\n-\n-    \/**\n-     * Tries to sort the specified range of the array.\n-     *\n-     * @param sorter parallel context\n-     * @param a the array to be sorted\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n-     * @return true if finally sorted, false otherwise\n-     *\/\n-    private static boolean tryMergeRuns(Sorter sorter, long[] a, int low, int size) {\n-\n-        \/*\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n-         *\/\n-        int[] run = null;\n-        int high = low + size;\n-        int count = 1, last = low;\n-\n-        \/*\n-         * Identify all possible runs.\n-         *\/\n-        for (int k = low + 1; k < high; ) {\n-\n-            \/*\n-             * Find the end index of the current run.\n-             *\/\n-            if (a[k - 1] < a[k]) {\n-\n-                \/\/ Identify ascending sequence\n-                while (++k < high && a[k - 1] <= a[k]);\n-\n-            } else if (a[k - 1] > a[k]) {\n-\n-                \/\/ Identify descending sequence\n-                while (++k < high && a[k - 1] >= a[k]);\n-\n-                \/\/ Reverse into ascending order\n-                for (int i = last - 1, j = k; ++i < --j && a[i] > a[j]; ) {\n-                    long ai = a[i]; a[i] = a[j]; a[j] = ai;\n-                }\n-            } else { \/\/ Identify constant sequence\n-                for (long ak = a[k]; ++k < high && ak == a[k]; );\n-\n-                if (k < high) {\n-                    continue;\n-                }\n-            }\n-\n-            \/*\n-             * Check special cases.\n-             *\/\n-            if (run == null) {\n-                if (k == high) {\n-\n-                    \/*\n-                     * The array is monotonous sequence,\n-                     * and therefore already sorted.\n-                     *\/\n-                    return true;\n-                }\n-\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n-                run[0] = low;\n-\n-            } else if (a[last - 1] > a[last]) {\n-\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n-\n-                    \/*\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                if (++count == MAX_RUN_CAPACITY) {\n-\n-                    \/*\n-                     * Array is not highly structured.\n-                     *\/\n-                    return false;\n-                }\n-\n-                if (count == run.length) {\n-\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n-            }\n-            run[count] = (last = k);\n-        }\n-\n-        \/*\n-         * Merge runs of highly structured array.\n-         *\/\n-        if (count > 1) {\n-            long[] b; int offset = low;\n-\n-            if (sorter == null || (b = (long[]) sorter.b) == null) {\n-                b = new long[size];\n-            } else {\n-                offset = sorter.offset;\n-            }\n-            mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);\n-        }\n-        return true;\n-    }\n-\n-    \/**\n-     * Merges the specified runs.\n-     *\n-     * @param a the source array\n-     * @param b the temporary buffer used in merging\n-     * @param offset the start index in the source, inclusive\n-     * @param aim specifies merging: to source ( > 0), buffer ( < 0) or any ( == 0)\n-     * @param parallel indicates whether merging is performed in parallel\n-     * @param run the start indexes of the runs, inclusive\n-     * @param lo the start index of the first run, inclusive\n-     * @param hi the start index of the last run, inclusive\n-     * @return the destination where runs are merged\n-     *\/\n-    private static long[] mergeRuns(long[] a, long[] b, int offset,\n-            int aim, boolean parallel, int[] run, int lo, int hi) {\n-\n-        if (hi - lo == 1) {\n-            if (aim >= 0) {\n-                return a;\n-            }\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n-            return b;\n-        }\n-\n-        \/*\n-         * Split into approximately equal parts.\n-         *\/\n-        int mi = lo, rmi = (run[lo] + run[hi]) >>> 1;\n-        while (run[++mi + 1] <= rmi);\n-\n-        \/*\n-         * Merge the left and right parts.\n-         *\/\n-        long[] a1, a2;\n-\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (long[]) merger.getDestination();\n-        } else {\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n-        }\n-\n-        long[] dst = a1 == a ? b : a;\n-\n-        int k   = a1 == a ? run[lo] - offset : run[lo];\n-        int lo1 = a1 == b ? run[lo] - offset : run[lo];\n-        int hi1 = a1 == b ? run[mi] - offset : run[mi];\n-        int lo2 = a2 == b ? run[mi] - offset : run[mi];\n-        int hi2 = a2 == b ? run[hi] - offset : run[hi];\n-\n-        if (parallel) {\n-            new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\n-        } else {\n-            mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);\n-        }\n-        return dst;\n-    }\n-\n-    \/**\n-     * Merges the sorted parts.\n-     *\n-     * @param merger parallel context\n-     * @param dst the destination where parts are merged\n-     * @param k the start index of the destination, inclusive\n-     * @param a1 the first part\n-     * @param lo1 the start index of the first part, inclusive\n-     * @param hi1 the end index of the first part, exclusive\n-     * @param a2 the second part\n-     * @param lo2 the start index of the second part, inclusive\n-     * @param hi2 the end index of the second part, exclusive\n-     *\/\n-    private static void mergeParts(Merger merger, long[] dst, int k,\n-            long[] a1, int lo1, int hi1, long[] a2, int lo2, int hi2) {\n-\n-        if (merger != null && a1 == a2) {\n-\n-            while (true) {\n-\n-                \/*\n-                 * The first part must be larger.\n-                 *\/\n-                if (hi1 - lo1 < hi2 - lo2) {\n-                    int lo = lo1; lo1 = lo2; lo2 = lo;\n-                    int hi = hi1; hi1 = hi2; hi2 = hi;\n-                }\n-\n-                \/*\n-                 * Small parts will be merged sequentially.\n-                 *\/\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n-                    break;\n-                }\n-\n-                \/*\n-                 * Find the median of the larger part.\n-                 *\/\n-                int mi1 = (lo1 + hi1) >>> 1;\n-                long key = a1[mi1];\n-                int mi2 = hi2;\n-\n-                \/*\n-                 * Partition the smaller part.\n-                 *\/\n-                for (int loo = lo2; loo < mi2; ) {\n-                    int t = (loo + mi2) >>> 1;\n-\n-                    if (key > a2[t]) {\n-                        loo = t + 1;\n-                    } else {\n-                        mi2 = t;\n-                    }\n-                }\n-\n-                int d = mi2 - lo2 + mi1 - lo1;\n-\n-                \/*\n-                 * Merge the right sub-parts in parallel.\n-                 *\/\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n-\n-                \/*\n-                 * Process the sub-left parts.\n-                 *\/\n-                hi1 = mi1;\n-                hi2 = mi2;\n-            }\n-        }\n-\n-        \/*\n-         * Merge small parts sequentially.\n-         *\/\n-        while (lo1 < hi1 && lo2 < hi2) {\n-            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\n-        }\n-        if (dst != a1 || k < lo1) {\n-            while (lo1 < hi1) {\n-                dst[k++] = a1[lo1++];\n-            }\n-        }\n-        if (dst != a2 || k < lo2) {\n-            while (lo2 < hi2) {\n-                dst[k++] = a2[lo2++];\n-            }\n-        }\n-    }\n-\n-\/\/ [byte]\n-\n-    \/**\n-     * Sorts the specified range of the array using\n-     * counting sort or insertion sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    static void sort(byte[] a, int low, int high) {\n-        if (high - low > MIN_BYTE_COUNTING_SORT_SIZE) {\n-            countingSort(a, low, high);\n-        } else {\n-            insertionSort(a, low, high);\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using insertion sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void insertionSort(byte[] a, int low, int high) {\n-        for (int i, k = low; ++k < high; ) {\n-            byte ai = a[i = k];\n-\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * The number of distinct byte values.\n-     *\/\n-    private static final int NUM_BYTE_VALUES = 1 << 8;\n-\n-    \/**\n-     * Max index of byte counter.\n-     *\/\n-    private static final int MAX_BYTE_INDEX = Byte.MAX_VALUE + NUM_BYTE_VALUES + 1;\n-\n-    \/**\n-     * Sorts the specified range of the array using counting sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void countingSort(byte[] a, int low, int high) {\n-        int[] count = new int[NUM_BYTE_VALUES];\n-\n-        \/*\n-         * Compute a histogram with the number of each values.\n-         *\/\n-        for (int i = high; i > low; ++count[a[--i] & 0xFF]);\n-\n-        \/*\n-         * Place values on their final positions.\n-         *\/\n-        if (high - low > NUM_BYTE_VALUES) {\n-            for (int i = MAX_BYTE_INDEX; --i > Byte.MAX_VALUE; ) {\n-                int value = i & 0xFF;\n-\n-                for (low = high - count[value]; high > low;\n-                    a[--high] = (byte) value\n-                );\n-            }\n-        } else {\n-            for (int i = MAX_BYTE_INDEX; high > low; ) {\n-                while (count[--i & 0xFF] == 0);\n-\n-                int value = i & 0xFF;\n-                int c = count[value];\n-\n-                do {\n-                    a[--high] = (byte) value;\n-                } while (--c > 0);\n-            }\n-        }\n-    }\n-\n-\/\/ [char]\n-\n-    \/**\n-     * Sorts the specified range of the array using\n-     * counting sort or Dual-Pivot Quicksort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    static void sort(char[] a, int low, int high) {\n-        if (high - low > MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE) {\n-            countingSort(a, low, high);\n-        } else {\n-            sort(a, 0, low, high);\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n-     *\n-     * @param a the array to be sorted\n-     * @param bits the combination of recursion depth and bit flag, where\n-     *        the right bit \"0\" indicates that array is the leftmost part\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    static void sort(char[] a, int bits, int low, int high) {\n-        while (true) {\n-            int end = high - 1, size = high - low;\n-\n-            \/*\n-             * Invoke insertion sort on small leftmost part.\n-             *\/\n-            if (size < MAX_INSERTION_SORT_SIZE) {\n-                insertionSort(a, low, high);\n-                return;\n-            }\n-\n-            \/*\n-             * Switch to counting sort if execution\n-             * time is becoming quadratic.\n-             *\/\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                countingSort(a, low, high);\n-                return;\n-            }\n-\n-            \/*\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n-             *\/\n-            int step = (size >> 3) * 3 + 3;\n-\n-            \/*\n-             * Five elements around (and including) the central element\n-             * will be used for pivot selection as described below. The\n-             * unequal choice of spacing these elements was empirically\n-             * determined to work well on a wide variety of inputs.\n-             *\/\n-            int e1 = low + step;\n-            int e5 = end - step;\n-            int e3 = (e1 + e5) >>> 1;\n-            int e2 = (e1 + e3) >>> 1;\n-            int e4 = (e3 + e5) >>> 1;\n-            char a3 = a[e3];\n-\n-            \/*\n-             * Sort these elements in place by the combination\n-             * of 4-element sorting network and insertion sort.\n-             *\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n-             *\/\n-            if (a[e5] < a[e2]) { char t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { char t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { char t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { char t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { char t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n-\n-            if (a3 < a[e2]) {\n-                if (a3 < a[e1]) {\n-                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\n-                } else {\n-                    a[e3] = a[e2]; a[e2] = a3;\n-                }\n-            } else if (a3 > a[e4]) {\n-                if (a3 > a[e5]) {\n-                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\n-                } else {\n-                    a[e3] = a[e4]; a[e4] = a3;\n-                }\n-            }\n-\n-            \/\/ Pointers\n-            int lower = low; \/\/ The index of the last element of the left part\n-            int upper = end; \/\/ The index of the first element of the right part\n-\n-            \/*\n-             * Partitioning with 2 pivots in case of different elements.\n-             *\/\n-            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n-\n-                \/*\n-                 * Use the first and fifth of the five sorted elements as\n-                 * the pivots. These values are inexpensive approximation\n-                 * of tertiles. Note, that pivot1 < pivot2.\n-                 *\/\n-                char pivot1 = a[e1];\n-                char pivot2 = a[e5];\n-\n-                \/*\n-                 * The first and the last elements to be sorted are moved\n-                 * to the locations formerly occupied by the pivots. When\n-                 * partitioning is completed, the pivots are swapped back\n-                 * into their final positions, and excluded from the next\n-                 * subsequent sorting.\n-                 *\/\n-                a[e1] = a[lower];\n-                a[e5] = a[upper];\n-\n-                \/*\n-                 * Skip elements, which are less or greater than the pivots.\n-                 *\/\n-                while (a[++lower] < pivot1);\n-                while (a[--upper] > pivot2);\n-\n-                \/*\n-                 * Backward 3-interval partitioning\n-                 *\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int unused = --lower, k = ++upper; --k > lower; ) {\n-                    char ak = a[k];\n-\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n-                                break;\n-                            }\n-                        }\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n-                        a[k] = a[--upper];\n-                        a[upper] = ak;\n-                    }\n-                }\n-\n-                \/*\n-                 * Swap the pivots into their final positions.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot1;\n-                a[end] = a[upper]; a[upper] = pivot2;\n-\n-                \/*\n-                 * Sort non-left parts recursively,\n-                 * excluding known pivots.\n-                 *\/\n-                sort(a, bits | 1, lower + 1, upper);\n-                sort(a, bits | 1, upper + 1, high);\n-\n-            } else { \/\/ Use single pivot in case of many equal elements\n-\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                char pivot = a[e3];\n-\n-                \/*\n-                 * The first element to be sorted is moved to the\n-                 * location formerly occupied by the pivot. After\n-                 * completion of partitioning the pivot is swapped\n-                 * back into its final position, and excluded from\n-                 * the next subsequent sorting.\n-                 *\/\n-                a[e3] = a[lower];\n-\n-                \/*\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n-                 *\n-                 *   left part                 central part    right part\n-                 * +------------------------------------------------------+\n-                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-                 * +------------------------------------------------------+\n-                 *              ^           ^                ^\n-                 *              |           |                |\n-                 *            lower         k              upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int k = ++upper; --k > lower; ) {\n-                    char ak = a[k];\n-\n-                    if (ak != pivot) {\n-                        a[k] = pivot;\n-\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n-                            while (a[++lower] < pivot);\n-\n-                            if (a[lower] > pivot) {\n-                                a[--upper] = a[lower];\n-                            }\n-                            a[lower] = ak;\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n-                            a[--upper] = ak;\n-                        }\n-                    }\n-                }\n-\n-                \/*\n-                 * Swap the pivot into its final position.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot;\n-\n-                \/*\n-                 * Sort the right part, excluding known pivot.\n-                 * All elements from the central part are\n-                 * equal and therefore already sorted.\n-                 *\/\n-                sort(a, bits | 1, upper, high);\n-            }\n-            high = lower; \/\/ Iterate along the left part\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using insertion sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void insertionSort(char[] a, int low, int high) {\n-        for (int i, k = low; ++k < high; ) {\n-            char ai = a[i = k];\n-\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * The number of distinct char values.\n-     *\/\n-    private static final int NUM_CHAR_VALUES = 1 << 16;\n-\n-    \/**\n-     * Sorts the specified range of the array using counting sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void countingSort(char[] a, int low, int high) {\n-        int[] count = new int[NUM_CHAR_VALUES];\n-\n-        \/*\n-         * Compute a histogram with the number of each values.\n-         *\/\n-        for (int i = high; i > low; ++count[a[--i]]);\n-\n-        \/*\n-         * Place values on their final positions.\n-         *\/\n-        if (high - low > NUM_CHAR_VALUES) {\n-            for (int i = NUM_CHAR_VALUES; i > 0; ) {\n-                for (low = high - count[--i]; high > low;\n-                    a[--high] = (char) i\n-                );\n-            }\n-        } else {\n-            for (int i = NUM_CHAR_VALUES; high > low; ) {\n-                while (count[--i] == 0);\n-                int c = count[i];\n-\n-                do {\n-                    a[--high] = (char) i;\n-                } while (--c > 0);\n-            }\n-        }\n-    }\n-\n-\/\/ [short]\n-\n-    \/**\n-     * Sorts the specified range of the array using\n-     * counting sort or Dual-Pivot Quicksort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    static void sort(short[] a, int low, int high) {\n-        if (high - low > MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE) {\n-            countingSort(a, low, high);\n-        } else {\n-            sort(a, 0, low, high);\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n-     *\n-     * @param a the array to be sorted\n-     * @param bits the combination of recursion depth and bit flag, where\n-     *        the right bit \"0\" indicates that array is the leftmost part\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    static void sort(short[] a, int bits, int low, int high) {\n-        while (true) {\n-            int end = high - 1, size = high - low;\n-\n-            \/*\n-             * Invoke insertion sort on small leftmost part.\n-             *\/\n-            if (size < MAX_INSERTION_SORT_SIZE) {\n-                insertionSort(a, low, high);\n-                return;\n-            }\n-\n-            \/*\n-             * Switch to counting sort if execution\n-             * time is becoming quadratic.\n-             *\/\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                countingSort(a, low, high);\n-                return;\n-            }\n-\n-            \/*\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n-             *\/\n-            int step = (size >> 3) * 3 + 3;\n-\n-            \/*\n-             * Five elements around (and including) the central element\n-             * will be used for pivot selection as described below. The\n-             * unequal choice of spacing these elements was empirically\n-             * determined to work well on a wide variety of inputs.\n-             *\/\n-            int e1 = low + step;\n-            int e5 = end - step;\n-            int e3 = (e1 + e5) >>> 1;\n-            int e2 = (e1 + e3) >>> 1;\n-            int e4 = (e3 + e5) >>> 1;\n-            short a3 = a[e3];\n-\n-            \/*\n-             * Sort these elements in place by the combination\n-             * of 4-element sorting network and insertion sort.\n-             *\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n-             *\/\n-            if (a[e5] < a[e2]) { short t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { short t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { short t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { short t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { short t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n-\n-            if (a3 < a[e2]) {\n-                if (a3 < a[e1]) {\n-                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\n-                } else {\n-                    a[e3] = a[e2]; a[e2] = a3;\n-                }\n-            } else if (a3 > a[e4]) {\n-                if (a3 > a[e5]) {\n-                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\n-                } else {\n-                    a[e3] = a[e4]; a[e4] = a3;\n-                }\n-            }\n-\n-            \/\/ Pointers\n-            int lower = low; \/\/ The index of the last element of the left part\n-            int upper = end; \/\/ The index of the first element of the right part\n-\n-            \/*\n-             * Partitioning with 2 pivots in case of different elements.\n-             *\/\n-            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n-\n-                \/*\n-                 * Use the first and fifth of the five sorted elements as\n-                 * the pivots. These values are inexpensive approximation\n-                 * of tertiles. Note, that pivot1 < pivot2.\n-                 *\/\n-                short pivot1 = a[e1];\n-                short pivot2 = a[e5];\n-\n-                \/*\n-                 * The first and the last elements to be sorted are moved\n-                 * to the locations formerly occupied by the pivots. When\n-                 * partitioning is completed, the pivots are swapped back\n-                 * into their final positions, and excluded from the next\n-                 * subsequent sorting.\n-                 *\/\n-                a[e1] = a[lower];\n-                a[e5] = a[upper];\n-\n-                \/*\n-                 * Skip elements, which are less or greater than the pivots.\n-                 *\/\n-                while (a[++lower] < pivot1);\n-                while (a[--upper] > pivot2);\n-\n-                \/*\n-                 * Backward 3-interval partitioning\n-                 *\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int unused = --lower, k = ++upper; --k > lower; ) {\n-                    short ak = a[k];\n-\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n-                                break;\n-                            }\n-                        }\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n-                        a[k] = a[--upper];\n-                        a[upper] = ak;\n-                    }\n-                }\n-\n-                \/*\n-                 * Swap the pivots into their final positions.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot1;\n-                a[end] = a[upper]; a[upper] = pivot2;\n-\n-                \/*\n-                 * Sort non-left parts recursively,\n-                 * excluding known pivots.\n-                 *\/\n-                sort(a, bits | 1, lower + 1, upper);\n-                sort(a, bits | 1, upper + 1, high);\n-\n-            } else { \/\/ Use single pivot in case of many equal elements\n-\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                short pivot = a[e3];\n-\n-                \/*\n-                 * The first element to be sorted is moved to the\n-                 * location formerly occupied by the pivot. After\n-                 * completion of partitioning the pivot is swapped\n-                 * back into its final position, and excluded from\n-                 * the next subsequent sorting.\n-                 *\/\n-                a[e3] = a[lower];\n-\n-                \/*\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n-                 *\n-                 *   left part                 central part    right part\n-                 * +------------------------------------------------------+\n-                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-                 * +------------------------------------------------------+\n-                 *              ^           ^                ^\n-                 *              |           |                |\n-                 *            lower         k              upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int k = ++upper; --k > lower; ) {\n-                    short ak = a[k];\n-\n-                    if (ak != pivot) {\n-                        a[k] = pivot;\n-\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n-                            while (a[++lower] < pivot);\n-\n-                            if (a[lower] > pivot) {\n-                                a[--upper] = a[lower];\n-                            }\n-                            a[lower] = ak;\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n-                            a[--upper] = ak;\n-                        }\n-                    }\n-                }\n-\n-                \/*\n-                 * Swap the pivot into its final position.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot;\n-\n-                \/*\n-                 * Sort the right part, excluding known pivot.\n-                 * All elements from the central part are\n-                 * equal and therefore already sorted.\n-                 *\/\n-                sort(a, bits | 1, upper, high);\n-            }\n-            high = lower; \/\/ Iterate along the left part\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using insertion sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void insertionSort(short[] a, int low, int high) {\n-        for (int i, k = low; ++k < high; ) {\n-            short ai = a[i = k];\n-\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * The number of distinct short values.\n-     *\/\n-    private static final int NUM_SHORT_VALUES = 1 << 16;\n-\n-    \/**\n-     * Max index of short counter.\n-     *\/\n-    private static final int MAX_SHORT_INDEX = Short.MAX_VALUE + NUM_SHORT_VALUES + 1;\n-\n-    \/**\n-     * Sorts the specified range of the array using counting sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void countingSort(short[] a, int low, int high) {\n-        int[] count = new int[NUM_SHORT_VALUES];\n-\n-        \/*\n-         * Compute a histogram with the number of each values.\n-         *\/\n-        for (int i = high; i > low; ++count[a[--i] & 0xFFFF]);\n-\n-        \/*\n-         * Place values on their final positions.\n-         *\/\n-        if (high - low > NUM_SHORT_VALUES) {\n-            for (int i = MAX_SHORT_INDEX; --i > Short.MAX_VALUE; ) {\n-                int value = i & 0xFFFF;\n-\n-                for (low = high - count[value]; high > low;\n-                    a[--high] = (short) value\n-                );\n-            }\n-        } else {\n-            for (int i = MAX_SHORT_INDEX; high > low; ) {\n-                while (count[--i & 0xFFFF] == 0);\n-\n-                int value = i & 0xFFFF;\n-                int c = count[value];\n-\n-                do {\n-                    a[--high] = (short) value;\n-                } while (--c > 0);\n-            }\n-        }\n-    }\n-\n-\/\/ [float]\n-\n-    \/**\n-     * Sorts the specified range of the array using parallel merge\n-     * sort and\/or Dual-Pivot Quicksort.\n-     *\n-     * To balance the faster splitting and parallelism of merge sort\n-     * with the faster element partitioning of Quicksort, ranges are\n-     * subdivided in tiers such that, if there is enough parallelism,\n-     * the four-way parallel merge is started, still ensuring enough\n-     * parallelism to process the partitions.\n-     *\n-     * @param a the array to be sorted\n-     * @param parallelism the parallelism level\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    static void sort(float[] a, int parallelism, int low, int high) {\n-        \/*\n-         * Phase 1. Count the number of negative zero -0.0f,\n-         * turn them into positive zero, and move all NaNs\n-         * to the end of the array.\n-         *\/\n-        int numNegativeZero = 0;\n-\n-        for (int k = high; k > low; ) {\n-            float ak = a[--k];\n-\n-            if (ak == 0.0f && Float.floatToRawIntBits(ak) < 0) { \/\/ ak is -0.0f\n-                numNegativeZero += 1;\n-                a[k] = 0.0f;\n-            } else if (ak != ak) { \/\/ ak is NaN\n-                a[k] = a[--high];\n-                a[high] = ak;\n-            }\n-        }\n-\n-        \/*\n-         * Phase 2. Sort everything except NaNs,\n-         * which are already in place.\n-         *\/\n-        int size = high - low;\n-\n-        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n-            int depth = getDepth(parallelism, size >> 12);\n-            float[] b = depth == 0 ? null : new float[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n-        } else {\n-            sort(null, a, 0, low, high);\n-        }\n-\n-        \/*\n-         * Phase 3. Turn positive zero 0.0f\n-         * back into negative zero -0.0f.\n-         *\/\n-        if (++numNegativeZero == 1) {\n-            return;\n-        }\n-\n-        \/*\n-         * Find the position one less than\n-         * the index of the first zero.\n-         *\/\n-        while (low <= high) {\n-            int middle = (low + high) >>> 1;\n-\n-            if (a[middle] < 0) {\n-                low = middle + 1;\n-            } else {\n-                high = middle - 1;\n-            }\n-        }\n-\n-        \/*\n-         * Replace the required number of 0.0f by -0.0f.\n-         *\/\n-        while (--numNegativeZero > 0) {\n-            a[++high] = -0.0f;\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n-     *\n-     * @param sorter parallel context\n-     * @param a the array to be sorted\n-     * @param bits the combination of recursion depth and bit flag, where\n-     *        the right bit \"0\" indicates that array is the leftmost part\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    static void sort(Sorter sorter, float[] a, int bits, int low, int high) {\n-        while (true) {\n-            int end = high - 1, size = high - low;\n-\n-            \/*\n-             * Run mixed insertion sort on small non-leftmost parts.\n-             *\/\n-            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n-                mixedInsertionSort(a, low, high - 3 * ((size >> 5) << 3), high);\n-                return;\n-            }\n-\n-            \/*\n-             * Invoke insertion sort on small leftmost part.\n-             *\/\n-            if (size < MAX_INSERTION_SORT_SIZE) {\n-                insertionSort(a, low, high);\n-                return;\n-            }\n-\n-            \/*\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n-             *\/\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n-                return;\n-            }\n-\n-            \/*\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n-             *\/\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n-                return;\n-            }\n-\n-            \/*\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n-             *\/\n-            int step = (size >> 3) * 3 + 3;\n-\n-            \/*\n-             * Five elements around (and including) the central element\n-             * will be used for pivot selection as described below. The\n-             * unequal choice of spacing these elements was empirically\n-             * determined to work well on a wide variety of inputs.\n-             *\/\n-            int e1 = low + step;\n-            int e5 = end - step;\n-            int e3 = (e1 + e5) >>> 1;\n-            int e2 = (e1 + e3) >>> 1;\n-            int e4 = (e3 + e5) >>> 1;\n-            float a3 = a[e3];\n-\n-            \/*\n-             * Sort these elements in place by the combination\n-             * of 4-element sorting network and insertion sort.\n-             *\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n-             *\/\n-            if (a[e5] < a[e2]) { float t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { float t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { float t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { float t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { float t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n-\n-            if (a3 < a[e2]) {\n-                if (a3 < a[e1]) {\n-                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\n-                } else {\n-                    a[e3] = a[e2]; a[e2] = a3;\n-                }\n-            } else if (a3 > a[e4]) {\n-                if (a3 > a[e5]) {\n-                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\n-                } else {\n-                    a[e3] = a[e4]; a[e4] = a3;\n-                }\n-            }\n-\n-            \/\/ Pointers\n-            int lower = low; \/\/ The index of the last element of the left part\n-            int upper = end; \/\/ The index of the first element of the right part\n-\n-            \/*\n-             * Partitioning with 2 pivots in case of different elements.\n-             *\/\n-            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n-\n-                \/*\n-                 * Use the first and fifth of the five sorted elements as\n-                 * the pivots. These values are inexpensive approximation\n-                 * of tertiles. Note, that pivot1 < pivot2.\n-                 *\/\n-                float pivot1 = a[e1];\n-                float pivot2 = a[e5];\n-\n-                \/*\n-                 * The first and the last elements to be sorted are moved\n-                 * to the locations formerly occupied by the pivots. When\n-                 * partitioning is completed, the pivots are swapped back\n-                 * into their final positions, and excluded from the next\n-                 * subsequent sorting.\n-                 *\/\n-                a[e1] = a[lower];\n-                a[e5] = a[upper];\n-\n-                \/*\n-                 * Skip elements, which are less or greater than the pivots.\n-                 *\/\n-                while (a[++lower] < pivot1);\n-                while (a[--upper] > pivot2);\n-\n-                \/*\n-                 * Backward 3-interval partitioning\n-                 *\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int unused = --lower, k = ++upper; --k > lower; ) {\n-                    float ak = a[k];\n-\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n-                                break;\n-                            }\n-                        }\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n-                        a[k] = a[--upper];\n-                        a[upper] = ak;\n-                    }\n-                }\n-\n-                \/*\n-                 * Swap the pivots into their final positions.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot1;\n-                a[end] = a[upper]; a[upper] = pivot2;\n-\n-                \/*\n-                 * Sort non-left parts recursively (possibly in parallel),\n-                 * excluding known pivots.\n-                 *\/\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n-                } else {\n-                    sort(sorter, a, bits | 1, lower + 1, upper);\n-                    sort(sorter, a, bits | 1, upper + 1, high);\n-                }\n-\n-            } else { \/\/ Use single pivot in case of many equal elements\n-\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                float pivot = a[e3];\n-\n-                \/*\n-                 * The first element to be sorted is moved to the\n-                 * location formerly occupied by the pivot. After\n-                 * completion of partitioning the pivot is swapped\n-                 * back into its final position, and excluded from\n-                 * the next subsequent sorting.\n-                 *\/\n-                a[e3] = a[lower];\n-\n-                \/*\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n-                 *\n-                 *   left part                 central part    right part\n-                 * +------------------------------------------------------+\n-                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-                 * +------------------------------------------------------+\n-                 *              ^           ^                ^\n-                 *              |           |                |\n-                 *            lower         k              upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int k = ++upper; --k > lower; ) {\n-                    float ak = a[k];\n-\n-                    if (ak != pivot) {\n-                        a[k] = pivot;\n-\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n-                            while (a[++lower] < pivot);\n-\n-                            if (a[lower] > pivot) {\n-                                a[--upper] = a[lower];\n-                            }\n-                            a[lower] = ak;\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n-                            a[--upper] = ak;\n-                        }\n-                    }\n-                }\n-\n-                \/*\n-                 * Swap the pivot into its final position.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot;\n-\n-                \/*\n-                 * Sort the right part (possibly in parallel), excluding\n-                 * known pivot. All elements from the central part are\n-                 * equal and therefore already sorted.\n-                 *\/\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.forkSorter(bits | 1, upper, high);\n-                } else {\n-                    sort(sorter, a, bits | 1, upper, high);\n-                }\n-            }\n-            high = lower; \/\/ Iterate along the left part\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using mixed insertion sort.\n-     *\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n-     *\n-     * In the context of Dual-Pivot Quicksort, the pivot element\n-     * from the left part plays the role of sentinel, because it\n-     * is less than any elements from the given part. Therefore,\n-     * expensive check of the left range can be skipped on each\n-     * iteration unless it is the leftmost call.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param end the index of the last element for simple insertion sort\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void mixedInsertionSort(float[] a, int low, int end, int high) {\n-        if (end == high) {\n-\n-            \/*\n-             * Invoke simple insertion sort on tiny array.\n-             *\/\n-            for (int i; ++low < end; ) {\n-                float ai = a[i = low];\n-\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        } else {\n-\n-            \/*\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n-             *\/\n-            float pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                float ai = a[i = low];\n-\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n-\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n-\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n-            }\n-\n-            \/*\n-             * Continue with pair insertion sort on remain part.\n-             *\/\n-            for (int i; low < high; ++low) {\n-                float a1 = a[i = low], a2 = a[++low];\n-\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n-\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n-\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n-\n-                } else if (a1 < a[i - 1]) {\n-\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n-\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using insertion sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void insertionSort(float[] a, int low, int high) {\n-        for (int i, k = low; ++k < high; ) {\n-            float ai = a[i = k];\n-\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using heap sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void heapSort(float[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            float max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n-\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(float[] a, int p, float value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n-\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n-            }\n-        }\n-        a[p] = value;\n-    }\n-\n-    \/**\n-     * Tries to sort the specified range of the array.\n-     *\n-     * @param sorter parallel context\n-     * @param a the array to be sorted\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n-     * @return true if finally sorted, false otherwise\n-     *\/\n-    private static boolean tryMergeRuns(Sorter sorter, float[] a, int low, int size) {\n-\n-        \/*\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n-         *\/\n-        int[] run = null;\n-        int high = low + size;\n-        int count = 1, last = low;\n-\n-        \/*\n-         * Identify all possible runs.\n-         *\/\n-        for (int k = low + 1; k < high; ) {\n-\n-            \/*\n-             * Find the end index of the current run.\n-             *\/\n-            if (a[k - 1] < a[k]) {\n-\n-                \/\/ Identify ascending sequence\n-                while (++k < high && a[k - 1] <= a[k]);\n-\n-            } else if (a[k - 1] > a[k]) {\n-\n-                \/\/ Identify descending sequence\n-                while (++k < high && a[k - 1] >= a[k]);\n-\n-                \/\/ Reverse into ascending order\n-                for (int i = last - 1, j = k; ++i < --j && a[i] > a[j]; ) {\n-                    float ai = a[i]; a[i] = a[j]; a[j] = ai;\n-                }\n-            } else { \/\/ Identify constant sequence\n-                for (float ak = a[k]; ++k < high && ak == a[k]; );\n-\n-                if (k < high) {\n-                    continue;\n-                }\n-            }\n-\n-            \/*\n-             * Check special cases.\n-             *\/\n-            if (run == null) {\n-                if (k == high) {\n-\n-                    \/*\n-                     * The array is monotonous sequence,\n-                     * and therefore already sorted.\n-                     *\/\n-                    return true;\n-                }\n-\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n-                run[0] = low;\n-\n-            } else if (a[last - 1] > a[last]) {\n-\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n-\n-                    \/*\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                if (++count == MAX_RUN_CAPACITY) {\n-\n-                    \/*\n-                     * Array is not highly structured.\n-                     *\/\n-                    return false;\n-                }\n-\n-                if (count == run.length) {\n-\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n-            }\n-            run[count] = (last = k);\n-        }\n-\n-        \/*\n-         * Merge runs of highly structured array.\n-         *\/\n-        if (count > 1) {\n-            float[] b; int offset = low;\n-\n-            if (sorter == null || (b = (float[]) sorter.b) == null) {\n-                b = new float[size];\n-            } else {\n-                offset = sorter.offset;\n-            }\n-            mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);\n-        }\n-        return true;\n-    }\n-\n-    \/**\n-     * Merges the specified runs.\n-     *\n-     * @param a the source array\n-     * @param b the temporary buffer used in merging\n-     * @param offset the start index in the source, inclusive\n-     * @param aim specifies merging: to source ( > 0), buffer ( < 0) or any ( == 0)\n-     * @param parallel indicates whether merging is performed in parallel\n-     * @param run the start indexes of the runs, inclusive\n-     * @param lo the start index of the first run, inclusive\n-     * @param hi the start index of the last run, inclusive\n-     * @return the destination where runs are merged\n-     *\/\n-    private static float[] mergeRuns(float[] a, float[] b, int offset,\n-            int aim, boolean parallel, int[] run, int lo, int hi) {\n-\n-        if (hi - lo == 1) {\n-            if (aim >= 0) {\n-                return a;\n-            }\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n-            return b;\n-        }\n-\n-        \/*\n-         * Split into approximately equal parts.\n-         *\/\n-        int mi = lo, rmi = (run[lo] + run[hi]) >>> 1;\n-        while (run[++mi + 1] <= rmi);\n-\n-        \/*\n-         * Merge the left and right parts.\n-         *\/\n-        float[] a1, a2;\n-\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (float[]) merger.getDestination();\n-        } else {\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n-        }\n-\n-        float[] dst = a1 == a ? b : a;\n-\n-        int k   = a1 == a ? run[lo] - offset : run[lo];\n-        int lo1 = a1 == b ? run[lo] - offset : run[lo];\n-        int hi1 = a1 == b ? run[mi] - offset : run[mi];\n-        int lo2 = a2 == b ? run[mi] - offset : run[mi];\n-        int hi2 = a2 == b ? run[hi] - offset : run[hi];\n-\n-        if (parallel) {\n-            new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\n-        } else {\n-            mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);\n-        }\n-        return dst;\n-    }\n-\n-    \/**\n-     * Merges the sorted parts.\n-     *\n-     * @param merger parallel context\n-     * @param dst the destination where parts are merged\n-     * @param k the start index of the destination, inclusive\n-     * @param a1 the first part\n-     * @param lo1 the start index of the first part, inclusive\n-     * @param hi1 the end index of the first part, exclusive\n-     * @param a2 the second part\n-     * @param lo2 the start index of the second part, inclusive\n-     * @param hi2 the end index of the second part, exclusive\n-     *\/\n-    private static void mergeParts(Merger merger, float[] dst, int k,\n-            float[] a1, int lo1, int hi1, float[] a2, int lo2, int hi2) {\n-\n-        if (merger != null && a1 == a2) {\n-\n-            while (true) {\n-\n-                \/*\n-                 * The first part must be larger.\n-                 *\/\n-                if (hi1 - lo1 < hi2 - lo2) {\n-                    int lo = lo1; lo1 = lo2; lo2 = lo;\n-                    int hi = hi1; hi1 = hi2; hi2 = hi;\n-                }\n-\n-                \/*\n-                 * Small parts will be merged sequentially.\n-                 *\/\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n-                    break;\n-                }\n-\n-                \/*\n-                 * Find the median of the larger part.\n-                 *\/\n-                int mi1 = (lo1 + hi1) >>> 1;\n-                float key = a1[mi1];\n-                int mi2 = hi2;\n-\n-                \/*\n-                 * Partition the smaller part.\n-                 *\/\n-                for (int loo = lo2; loo < mi2; ) {\n-                    int t = (loo + mi2) >>> 1;\n-\n-                    if (key > a2[t]) {\n-                        loo = t + 1;\n-                    } else {\n-                        mi2 = t;\n-                    }\n-                }\n-\n-                int d = mi2 - lo2 + mi1 - lo1;\n-\n-                \/*\n-                 * Merge the right sub-parts in parallel.\n-                 *\/\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n-\n-                \/*\n-                 * Process the sub-left parts.\n-                 *\/\n-                hi1 = mi1;\n-                hi2 = mi2;\n-            }\n-        }\n-\n-        \/*\n-         * Merge small parts sequentially.\n-         *\/\n-        while (lo1 < hi1 && lo2 < hi2) {\n-            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\n-        }\n-        if (dst != a1 || k < lo1) {\n-            while (lo1 < hi1) {\n-                dst[k++] = a1[lo1++];\n-            }\n-        }\n-        if (dst != a2 || k < lo2) {\n-            while (lo2 < hi2) {\n-                dst[k++] = a2[lo2++];\n-            }\n-        }\n-    }\n-\n-\/\/ [double]\n-\n-    \/**\n-     * Sorts the specified range of the array using parallel merge\n-     * sort and\/or Dual-Pivot Quicksort.\n-     *\n-     * To balance the faster splitting and parallelism of merge sort\n-     * with the faster element partitioning of Quicksort, ranges are\n-     * subdivided in tiers such that, if there is enough parallelism,\n-     * the four-way parallel merge is started, still ensuring enough\n-     * parallelism to process the partitions.\n-     *\n-     * @param a the array to be sorted\n-     * @param parallelism the parallelism level\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    static void sort(double[] a, int parallelism, int low, int high) {\n-        \/*\n-         * Phase 1. Count the number of negative zero -0.0d,\n-         * turn them into positive zero, and move all NaNs\n-         * to the end of the array.\n-         *\/\n-        int numNegativeZero = 0;\n-\n-        for (int k = high; k > low; ) {\n-            double ak = a[--k];\n-\n-            if (ak == 0.0d && Double.doubleToRawLongBits(ak) < 0) { \/\/ ak is -0.0d\n-                numNegativeZero += 1;\n-                a[k] = 0.0d;\n-            } else if (ak != ak) { \/\/ ak is NaN\n-                a[k] = a[--high];\n-                a[high] = ak;\n-            }\n-        }\n-\n-        \/*\n-         * Phase 2. Sort everything except NaNs,\n-         * which are already in place.\n-         *\/\n-        int size = high - low;\n-\n-        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n-            int depth = getDepth(parallelism, size >> 12);\n-            double[] b = depth == 0 ? null : new double[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n-        } else {\n-            sort(null, a, 0, low, high);\n-        }\n-\n-        \/*\n-         * Phase 3. Turn positive zero 0.0d\n-         * back into negative zero -0.0d.\n-         *\/\n-        if (++numNegativeZero == 1) {\n-            return;\n-        }\n-\n-        \/*\n-         * Find the position one less than\n-         * the index of the first zero.\n-         *\/\n-        while (low <= high) {\n-            int middle = (low + high) >>> 1;\n-\n-            if (a[middle] < 0) {\n-                low = middle + 1;\n-            } else {\n-                high = middle - 1;\n-            }\n-        }\n-\n-        \/*\n-         * Replace the required number of 0.0d by -0.0d.\n-         *\/\n-        while (--numNegativeZero > 0) {\n-            a[++high] = -0.0d;\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n-     *\n-     * @param sorter parallel context\n-     * @param a the array to be sorted\n-     * @param bits the combination of recursion depth and bit flag, where\n-     *        the right bit \"0\" indicates that array is the leftmost part\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    static void sort(Sorter sorter, double[] a, int bits, int low, int high) {\n-        while (true) {\n-            int end = high - 1, size = high - low;\n-\n-            \/*\n-             * Run mixed insertion sort on small non-leftmost parts.\n-             *\/\n-            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n-                mixedInsertionSort(a, low, high - 3 * ((size >> 5) << 3), high);\n-                return;\n-            }\n-\n-            \/*\n-             * Invoke insertion sort on small leftmost part.\n-             *\/\n-            if (size < MAX_INSERTION_SORT_SIZE) {\n-                insertionSort(a, low, high);\n-                return;\n-            }\n-\n-            \/*\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n-             *\/\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n-                return;\n-            }\n-\n-            \/*\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n-             *\/\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n-                return;\n-            }\n-\n-            \/*\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n-             *\/\n-            int step = (size >> 3) * 3 + 3;\n-\n-            \/*\n-             * Five elements around (and including) the central element\n-             * will be used for pivot selection as described below. The\n-             * unequal choice of spacing these elements was empirically\n-             * determined to work well on a wide variety of inputs.\n-             *\/\n-            int e1 = low + step;\n-            int e5 = end - step;\n-            int e3 = (e1 + e5) >>> 1;\n-            int e2 = (e1 + e3) >>> 1;\n-            int e4 = (e3 + e5) >>> 1;\n-            double a3 = a[e3];\n-\n-            \/*\n-             * Sort these elements in place by the combination\n-             * of 4-element sorting network and insertion sort.\n-             *\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n-             *\/\n-            if (a[e5] < a[e2]) { double t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { double t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { double t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { double t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { double t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n-\n-            if (a3 < a[e2]) {\n-                if (a3 < a[e1]) {\n-                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\n-                } else {\n-                    a[e3] = a[e2]; a[e2] = a3;\n-                }\n-            } else if (a3 > a[e4]) {\n-                if (a3 > a[e5]) {\n-                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\n-                } else {\n-                    a[e3] = a[e4]; a[e4] = a3;\n-                }\n-            }\n-\n-            \/\/ Pointers\n-            int lower = low; \/\/ The index of the last element of the left part\n-            int upper = end; \/\/ The index of the first element of the right part\n-\n-            \/*\n-             * Partitioning with 2 pivots in case of different elements.\n-             *\/\n-            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n-\n-                \/*\n-                 * Use the first and fifth of the five sorted elements as\n-                 * the pivots. These values are inexpensive approximation\n-                 * of tertiles. Note, that pivot1 < pivot2.\n-                 *\/\n-                double pivot1 = a[e1];\n-                double pivot2 = a[e5];\n-\n-                \/*\n-                 * The first and the last elements to be sorted are moved\n-                 * to the locations formerly occupied by the pivots. When\n-                 * partitioning is completed, the pivots are swapped back\n-                 * into their final positions, and excluded from the next\n-                 * subsequent sorting.\n-                 *\/\n-                a[e1] = a[lower];\n-                a[e5] = a[upper];\n-\n-                \/*\n-                 * Skip elements, which are less or greater than the pivots.\n-                 *\/\n-                while (a[++lower] < pivot1);\n-                while (a[--upper] > pivot2);\n-\n-                \/*\n-                 * Backward 3-interval partitioning\n-                 *\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int unused = --lower, k = ++upper; --k > lower; ) {\n-                    double ak = a[k];\n-\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n-                                break;\n-                            }\n-                        }\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n-                        a[k] = a[--upper];\n-                        a[upper] = ak;\n-                    }\n-                }\n-\n-                \/*\n-                 * Swap the pivots into their final positions.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot1;\n-                a[end] = a[upper]; a[upper] = pivot2;\n-\n-                \/*\n-                 * Sort non-left parts recursively (possibly in parallel),\n-                 * excluding known pivots.\n-                 *\/\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n-                } else {\n-                    sort(sorter, a, bits | 1, lower + 1, upper);\n-                    sort(sorter, a, bits | 1, upper + 1, high);\n-                }\n-\n-            } else { \/\/ Use single pivot in case of many equal elements\n-\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                double pivot = a[e3];\n-\n-                \/*\n-                 * The first element to be sorted is moved to the\n-                 * location formerly occupied by the pivot. After\n-                 * completion of partitioning the pivot is swapped\n-                 * back into its final position, and excluded from\n-                 * the next subsequent sorting.\n-                 *\/\n-                a[e3] = a[lower];\n-\n-                \/*\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n-                 *\n-                 *   left part                 central part    right part\n-                 * +------------------------------------------------------+\n-                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-                 * +------------------------------------------------------+\n-                 *              ^           ^                ^\n-                 *              |           |                |\n-                 *            lower         k              upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int k = ++upper; --k > lower; ) {\n-                    double ak = a[k];\n-\n-                    if (ak != pivot) {\n-                        a[k] = pivot;\n-\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n-                            while (a[++lower] < pivot);\n-\n-                            if (a[lower] > pivot) {\n-                                a[--upper] = a[lower];\n-                            }\n-                            a[lower] = ak;\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n-                            a[--upper] = ak;\n-                        }\n-                    }\n-                }\n-\n-                \/*\n-                 * Swap the pivot into its final position.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot;\n-\n-                \/*\n-                 * Sort the right part (possibly in parallel), excluding\n-                 * known pivot. All elements from the central part are\n-                 * equal and therefore already sorted.\n-                 *\/\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.forkSorter(bits | 1, upper, high);\n-                } else {\n-                    sort(sorter, a, bits | 1, upper, high);\n-                }\n-            }\n-            high = lower; \/\/ Iterate along the left part\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using mixed insertion sort.\n-     *\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n-     *\n-     * In the context of Dual-Pivot Quicksort, the pivot element\n-     * from the left part plays the role of sentinel, because it\n-     * is less than any elements from the given part. Therefore,\n-     * expensive check of the left range can be skipped on each\n-     * iteration unless it is the leftmost call.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param end the index of the last element for simple insertion sort\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void mixedInsertionSort(double[] a, int low, int end, int high) {\n-        if (end == high) {\n-\n-            \/*\n-             * Invoke simple insertion sort on tiny array.\n-             *\/\n-            for (int i; ++low < end; ) {\n-                double ai = a[i = low];\n-\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        } else {\n-\n-            \/*\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n-             *\/\n-            double pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                double ai = a[i = low];\n-\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n-\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n-\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n-            }\n-\n-            \/*\n-             * Continue with pair insertion sort on remain part.\n-             *\/\n-            for (int i; low < high; ++low) {\n-                double a1 = a[i = low], a2 = a[++low];\n-\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n-\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n-\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n-\n-                } else if (a1 < a[i - 1]) {\n-\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n-\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using insertion sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void insertionSort(double[] a, int low, int high) {\n-        for (int i, k = low; ++k < high; ) {\n-            double ai = a[i = k];\n-\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using heap sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void heapSort(double[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            double max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n-\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(double[] a, int p, double value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n-\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n-            }\n-        }\n-        a[p] = value;\n-    }\n-\n-    \/**\n-     * Tries to sort the specified range of the array.\n-     *\n-     * @param sorter parallel context\n-     * @param a the array to be sorted\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n-     * @return true if finally sorted, false otherwise\n-     *\/\n-    private static boolean tryMergeRuns(Sorter sorter, double[] a, int low, int size) {\n-\n-        \/*\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n-         *\/\n-        int[] run = null;\n-        int high = low + size;\n-        int count = 1, last = low;\n-\n-        \/*\n-         * Identify all possible runs.\n-         *\/\n-        for (int k = low + 1; k < high; ) {\n-\n-            \/*\n-             * Find the end index of the current run.\n-             *\/\n-            if (a[k - 1] < a[k]) {\n-\n-                \/\/ Identify ascending sequence\n-                while (++k < high && a[k - 1] <= a[k]);\n-\n-            } else if (a[k - 1] > a[k]) {\n-\n-                \/\/ Identify descending sequence\n-                while (++k < high && a[k - 1] >= a[k]);\n-\n-                \/\/ Reverse into ascending order\n-                for (int i = last - 1, j = k; ++i < --j && a[i] > a[j]; ) {\n-                    double ai = a[i]; a[i] = a[j]; a[j] = ai;\n-                }\n-            } else { \/\/ Identify constant sequence\n-                for (double ak = a[k]; ++k < high && ak == a[k]; );\n-\n-                if (k < high) {\n-                    continue;\n-                }\n-            }\n-\n-            \/*\n-             * Check special cases.\n-             *\/\n-            if (run == null) {\n-                if (k == high) {\n-\n-                    \/*\n-                     * The array is monotonous sequence,\n-                     * and therefore already sorted.\n-                     *\/\n-                    return true;\n-                }\n-\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n-                run[0] = low;\n-\n-            } else if (a[last - 1] > a[last]) {\n-\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n-\n-                    \/*\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                if (++count == MAX_RUN_CAPACITY) {\n-\n-                    \/*\n-                     * Array is not highly structured.\n-                     *\/\n-                    return false;\n-                }\n-\n-                if (count == run.length) {\n-\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n-            }\n-            run[count] = (last = k);\n-        }\n-\n-        \/*\n-         * Merge runs of highly structured array.\n-         *\/\n-        if (count > 1) {\n-            double[] b; int offset = low;\n-\n-            if (sorter == null || (b = (double[]) sorter.b) == null) {\n-                b = new double[size];\n-            } else {\n-                offset = sorter.offset;\n-            }\n-            mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);\n-        }\n-        return true;\n-    }\n-\n-    \/**\n-     * Merges the specified runs.\n-     *\n-     * @param a the source array\n-     * @param b the temporary buffer used in merging\n-     * @param offset the start index in the source, inclusive\n-     * @param aim specifies merging: to source ( > 0), buffer ( < 0) or any ( == 0)\n-     * @param parallel indicates whether merging is performed in parallel\n-     * @param run the start indexes of the runs, inclusive\n-     * @param lo the start index of the first run, inclusive\n-     * @param hi the start index of the last run, inclusive\n-     * @return the destination where runs are merged\n-     *\/\n-    private static double[] mergeRuns(double[] a, double[] b, int offset,\n-            int aim, boolean parallel, int[] run, int lo, int hi) {\n-\n-        if (hi - lo == 1) {\n-            if (aim >= 0) {\n-                return a;\n-            }\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n-            return b;\n-        }\n-\n-        \/*\n-         * Split into approximately equal parts.\n-         *\/\n-        int mi = lo, rmi = (run[lo] + run[hi]) >>> 1;\n-        while (run[++mi + 1] <= rmi);\n-\n-        \/*\n-         * Merge the left and right parts.\n-         *\/\n-        double[] a1, a2;\n-\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (double[]) merger.getDestination();\n-        } else {\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n-        }\n-\n-        double[] dst = a1 == a ? b : a;\n-\n-        int k   = a1 == a ? run[lo] - offset : run[lo];\n-        int lo1 = a1 == b ? run[lo] - offset : run[lo];\n-        int hi1 = a1 == b ? run[mi] - offset : run[mi];\n-        int lo2 = a2 == b ? run[mi] - offset : run[mi];\n-        int hi2 = a2 == b ? run[hi] - offset : run[hi];\n-\n-        if (parallel) {\n-            new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\n-        } else {\n-            mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);\n-        }\n-        return dst;\n-    }\n-\n-    \/**\n-     * Merges the sorted parts.\n-     *\n-     * @param merger parallel context\n-     * @param dst the destination where parts are merged\n-     * @param k the start index of the destination, inclusive\n-     * @param a1 the first part\n-     * @param lo1 the start index of the first part, inclusive\n-     * @param hi1 the end index of the first part, exclusive\n-     * @param a2 the second part\n-     * @param lo2 the start index of the second part, inclusive\n-     * @param hi2 the end index of the second part, exclusive\n-     *\/\n-    private static void mergeParts(Merger merger, double[] dst, int k,\n-            double[] a1, int lo1, int hi1, double[] a2, int lo2, int hi2) {\n-\n-        if (merger != null && a1 == a2) {\n-\n-            while (true) {\n-\n-                \/*\n-                 * The first part must be larger.\n-                 *\/\n-                if (hi1 - lo1 < hi2 - lo2) {\n-                    int lo = lo1; lo1 = lo2; lo2 = lo;\n-                    int hi = hi1; hi1 = hi2; hi2 = hi;\n-                }\n-\n-                \/*\n-                 * Small parts will be merged sequentially.\n-                 *\/\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n-                    break;\n-                }\n-\n-                \/*\n-                 * Find the median of the larger part.\n-                 *\/\n-                int mi1 = (lo1 + hi1) >>> 1;\n-                double key = a1[mi1];\n-                int mi2 = hi2;\n-\n-                \/*\n-                 * Partition the smaller part.\n-                 *\/\n-                for (int loo = lo2; loo < mi2; ) {\n-                    int t = (loo + mi2) >>> 1;\n-\n-                    if (key > a2[t]) {\n-                        loo = t + 1;\n-                    } else {\n-                        mi2 = t;\n-                    }\n-                }\n-\n-                int d = mi2 - lo2 + mi1 - lo1;\n-\n-                \/*\n-                 * Merge the right sub-parts in parallel.\n-                 *\/\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n-\n-                \/*\n-                 * Process the sub-left parts.\n-                 *\/\n-                hi1 = mi1;\n-                hi2 = mi2;\n-            }\n-        }\n-\n-        \/*\n-         * Merge small parts sequentially.\n-         *\/\n-        while (lo1 < hi1 && lo2 < hi2) {\n-            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\n-        }\n-        if (dst != a1 || k < lo1) {\n-            while (lo1 < hi1) {\n-                dst[k++] = a1[lo1++];\n-            }\n-        }\n-        if (dst != a2 || k < lo2) {\n-            while (lo2 < hi2) {\n-                dst[k++] = a2[lo2++];\n-            }\n-        }\n-    }\n-\n-\/\/ [class]\n-\n-    \/**\n-     * This class implements parallel sorting.\n-     *\/\n-    private static final class Sorter extends CountedCompleter<Void> {\n-        private static final long serialVersionUID = 20180818L;\n-        @SuppressWarnings(\"serial\")\n-        private final Object a, b;\n-        private final int low, size, offset, depth;\n-\n-        private Sorter(CountedCompleter<?> parent,\n-                Object a, Object b, int low, int size, int offset, int depth) {\n-            super(parent);\n-            this.a = a;\n-            this.b = b;\n-            this.low = low;\n-            this.size = size;\n-            this.offset = offset;\n-            this.depth = depth;\n-        }\n-\n-        @Override\n-        public final void compute() {\n-            if (depth < 0) {\n-                setPendingCount(2);\n-                int half = size >> 1;\n-                new Sorter(this, b, a, low, half, offset, depth + 1).fork();\n-                new Sorter(this, b, a, low + half, size - half, offset, depth + 1).compute();\n-            } else {\n-                if (a instanceof int[]) {\n-                    sort(this, (int[]) a, depth, low, low + size);\n-                } else if (a instanceof long[]) {\n-                    sort(this, (long[]) a, depth, low, low + size);\n-                } else if (a instanceof float[]) {\n-                    sort(this, (float[]) a, depth, low, low + size);\n-                } else if (a instanceof double[]) {\n-                    sort(this, (double[]) a, depth, low, low + size);\n-                } else {\n-                    throw new IllegalArgumentException(\n-                        \"Unknown type of array: \" + a.getClass().getName());\n-                }\n-            }\n-            tryComplete();\n-        }\n-\n-        @Override\n-        public final void onCompletion(CountedCompleter<?> caller) {\n-            if (depth < 0) {\n-                int mi = low + (size >> 1);\n-                boolean src = (depth & 1) == 0;\n-\n-                new Merger(null,\n-                    a,\n-                    src ? low : low - offset,\n-                    b,\n-                    src ? low - offset : low,\n-                    src ? mi - offset : mi,\n-                    b,\n-                    src ? mi - offset : mi,\n-                    src ? low + size - offset : low + size\n-                ).invoke();\n-            }\n-        }\n-\n-        private void forkSorter(int depth, int low, int high) {\n-            addToPendingCount(1);\n-            Object a = this.a; \/\/ Use local variable for performance\n-            new Sorter(this, a, b, low, high - low, offset, depth).fork();\n-        }\n-    }\n-\n-    \/**\n-     * This class implements parallel merging.\n-     *\/\n-    private static final class Merger extends CountedCompleter<Void> {\n-        private static final long serialVersionUID = 20180818L;\n-        @SuppressWarnings(\"serial\")\n-        private final Object dst, a1, a2;\n-        private final int k, lo1, hi1, lo2, hi2;\n-\n-        private Merger(CountedCompleter<?> parent, Object dst, int k,\n-                Object a1, int lo1, int hi1, Object a2, int lo2, int hi2) {\n-            super(parent);\n-            this.dst = dst;\n-            this.k = k;\n-            this.a1 = a1;\n-            this.lo1 = lo1;\n-            this.hi1 = hi1;\n-            this.a2 = a2;\n-            this.lo2 = lo2;\n-            this.hi2 = hi2;\n-        }\n-\n-        @Override\n-        public final void compute() {\n-            if (dst instanceof int[]) {\n-                mergeParts(this, (int[]) dst, k,\n-                    (int[]) a1, lo1, hi1, (int[]) a2, lo2, hi2);\n-            } else if (dst instanceof long[]) {\n-                mergeParts(this, (long[]) dst, k,\n-                    (long[]) a1, lo1, hi1, (long[]) a2, lo2, hi2);\n-            } else if (dst instanceof float[]) {\n-                mergeParts(this, (float[]) dst, k,\n-                    (float[]) a1, lo1, hi1, (float[]) a2, lo2, hi2);\n-            } else if (dst instanceof double[]) {\n-                mergeParts(this, (double[]) dst, k,\n-                    (double[]) a1, lo1, hi1, (double[]) a2, lo2, hi2);\n-            } else {\n-                throw new IllegalArgumentException(\n-                    \"Unknown type of array: \" + dst.getClass().getName());\n-            }\n-            propagateCompletion();\n-        }\n-\n-        private void forkMerger(Object dst, int k,\n-                Object a1, int lo1, int hi1, Object a2, int lo2, int hi2) {\n-            addToPendingCount(1);\n-            new Merger(this, dst, k, a1, lo1, hi1, a2, lo2, hi2).fork();\n-        }\n-    }\n-\n-    \/**\n-     * This class implements parallel merging of runs.\n-     *\/\n-    private static final class RunMerger extends RecursiveTask<Object> {\n-        private static final long serialVersionUID = 20180818L;\n-        @SuppressWarnings(\"serial\")\n-        private final Object a, b;\n-        private final int[] run;\n-        private final int offset, aim, lo, hi;\n-\n-        private RunMerger(Object a, Object b, int offset,\n-                int aim, int[] run, int lo, int hi) {\n-            this.a = a;\n-            this.b = b;\n-            this.offset = offset;\n-            this.aim = aim;\n-            this.run = run;\n-            this.lo = lo;\n-            this.hi = hi;\n-        }\n-\n-        @Override\n-        protected final Object compute() {\n-            if (a instanceof int[]) {\n-                return mergeRuns((int[]) a, (int[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            if (a instanceof long[]) {\n-                return mergeRuns((long[]) a, (long[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            if (a instanceof float[]) {\n-                return mergeRuns((float[]) a, (float[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            if (a instanceof double[]) {\n-                return mergeRuns((double[]) a, (double[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            throw new IllegalArgumentException(\n-                \"Unknown type of array: \" + a.getClass().getName());\n-        }\n-\n-        private RunMerger forkMe() {\n-            fork();\n-            return this;\n-        }\n-\n-        private Object getDestination() {\n-            join();\n-            return getRawResult();\n-        }\n-    }\n-}\n+\/*\r\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\r\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+ *\r\n+ * This code is free software; you can redistribute it and\/or modify it\r\n+ * under the terms of the GNU General Public License version 2 only, as\r\n+ * published by the Free Software Foundation.  Oracle designates this\r\n+ * particular file as subject to the \"Classpath\" exception as provided\r\n+ * by Oracle in the LICENSE file that accompanied this code.\r\n+ *\r\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+ * version 2 for more details (a copy is included in the LICENSE file that\r\n+ * accompanied this code).\r\n+ *\r\n+ * You should have received a copy of the GNU General Public License version\r\n+ * 2 along with this work; if not, write to the Free Software Foundation,\r\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+ *\r\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+ * or visit www.oracle.com if you need additional information or have any\r\n+ * questions.\r\n+ *\/\r\n+\r\n+package java.util;\r\n+\r\n+import java.util.concurrent.CountedCompleter;\r\n+import jdk.internal.misc.Unsafe;\r\n+\r\n+\/**\r\n+ * This class implements powerful and fully optimized versions, both\r\n+ * sequential and parallel, of the Dual-Pivot Quicksort algorithm by\r\n+ * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\r\n+ * offers O(n log(n)) performance on all data sets, and is typically\r\n+ * faster than traditional (one-pivot) Quicksort implementations.\r\n+ *\r\n+ * There are also additional algorithms, invoked from the Dual-Pivot\r\n+ * Quicksort such as merging sort, sorting network, Radix sort, heap\r\n+ * sort, mixed (simple, pin, pair) insertion sort, counting sort and\r\n+ * parallel merge sort.\r\n+ *\r\n+ * @author Vladimir Yaroslavskiy\r\n+ * @author Jon Bentley\r\n+ * @author Josh Bloch\r\n+ * @author Doug Lea\r\n+ *\r\n+ * @version 2022.06.14\r\n+ *\r\n+ * @since 1.7 * 14 ^ 22\r\n+ *\/\r\n+final class DualPivotQuicksort {\r\n+\r\n+    \/**\r\n+     * Prevents instantiation.\r\n+     *\/\r\n+    private DualPivotQuicksort() {}\r\n+\r\n+    \/* ---------------- Insertion sort section ---------------- *\/\r\n+\r\n+    \/**\r\n+     * Max array size to use mixed insertion sort.\r\n+     *\/\r\n+    private static final int MAX_MIXED_INSERTION_SORT_SIZE = 124;\r\n+\r\n+    \/**\r\n+     * Max array size to use insertion sort.\r\n+     *\/\r\n+    private static final int MAX_INSERTION_SORT_SIZE = 44;\r\n+\r\n+    \/* ----------------- Merging sort section ----------------- *\/\r\n+\r\n+    \/**\r\n+     * Min array size to use merging sort.\r\n+     *\/\r\n+    private static final int MIN_MERGING_SORT_SIZE = 512;\r\n+\r\n+    \/**\r\n+     * Min size of run to continue scanning.\r\n+     *\/\r\n+    private static final int MIN_RUN_SIZE = 128;\r\n+\r\n+    \/* ------------------ Radix sort section ------------------ *\/\r\n+\r\n+    \/**\r\n+     * Min array size to use Radix sort.\r\n+     *\/\r\n+    private static final int MIN_RADIX_SORT_SIZE = 800;\r\n+\r\n+    \/* ------------------ Counting sort section --------------- *\/\r\n+\r\n+    \/**\r\n+     * Min size of a byte array to use counting sort.\r\n+     *\/\r\n+    private static final int MIN_BYTE_COUNTING_SORT_SIZE = 36;\r\n+\r\n+    \/**\r\n+     * Min size of a char array to use counting sort.\r\n+     *\/\r\n+    private static final int MIN_CHAR_COUNTING_SORT_SIZE = 1700;\r\n+\r\n+    \/**\r\n+     * Min size of a short array to use counting sort.\r\n+     *\/\r\n+    private static final int MIN_SHORT_COUNTING_SORT_SIZE = 2100;\r\n+\r\n+    \/* -------------------- Common section -------------------- *\/\r\n+\r\n+    \/**\r\n+     * Min array size to perform sorting in parallel.\r\n+     *\/\r\n+    private static final int MIN_PARALLEL_SORT_SIZE = 1024;\r\n+\r\n+    \/**\r\n+     * Max recursive depth before switching to heap sort.\r\n+     *\/\r\n+    private static final int MAX_RECURSION_DEPTH = 64 << 1;\r\n+\r\n+    \/**\r\n+     * Max size of additional buffer,\r\n+     *      limited by max_heap \/ 64 or 2 GB max.\r\n+     *\/\r\n+    private static final int MAX_BUFFER_SIZE =\r\n+            (int) Math.min(Runtime.getRuntime().maxMemory() >> 6, Integer.MAX_VALUE);\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using parallel merge\r\n+     * sort and\/or Dual-Pivot Quicksort.\r\n+     *\r\n+     * To balance the faster splitting and parallelism of merge sort\r\n+     * with the faster element partitioning of Quicksort, ranges are\r\n+     * subdivided in tiers such that, if there is enough parallelism,\r\n+     * the four-way parallel merge is started, still ensuring enough\r\n+     * parallelism to process the partitions.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param parallelism the parallelism level\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void sort(int[] a, int parallelism, int low, int high) {\r\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\r\n+            new Sorter<>(a, parallelism, low, high - low, 0).invoke();\r\n+        } else {\r\n+            sort(null, a, 0, low, high);\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\r\n+     *\r\n+     * @param sorter parallel context\r\n+     * @param a the array to be sorted\r\n+     * @param bits the combination of recursion depth and bit flag, where\r\n+     *        the right bit \"0\" indicates that range is the leftmost part\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void sort(Sorter<int[]> sorter, int[] a, int bits, int low, int high) {\r\n+        while (true) {\r\n+            int size = high - low;\r\n+\r\n+            \/*\r\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\r\n+             *\/\r\n+            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\r\n+                mixedInsertionSort(a, low, high);\r\n+                return;\r\n+            }\r\n+\r\n+            \/*\r\n+             * Invoke insertion sort on small leftmost part.\r\n+             *\/\r\n+            if (size < MAX_INSERTION_SORT_SIZE) {\r\n+                insertionSort(a, low, high);\r\n+                return;\r\n+            }\r\n+\r\n+            \/*\r\n+             * Try merging sort on large part.\r\n+             *\/\r\n+            if (size > MIN_MERGING_SORT_SIZE * bits\r\n+                    && tryMergingSort(sorter, a, low, high)) {\r\n+                return;\r\n+            }\r\n+\r\n+            \/*\r\n+             * Use an inexpensive approximation of the golden ratio\r\n+             * to select five sample elements and determine pivots.\r\n+             *\/\r\n+            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;\r\n+\r\n+            \/*\r\n+             * Five elements around (and including) the central element\r\n+             * will be used for pivot selection as described below. The\r\n+             * unequal choice of spacing these elements was empirically\r\n+             * determined to work well on a wide variety of inputs.\r\n+             *\/\r\n+            int end = high - 1;\r\n+            int e1 = low + step;\r\n+            int e5 = end - step;\r\n+            int e3 = (e1 + e5) >>> 1;\r\n+            int e2 = (e1 + e3) >>> 1;\r\n+            int e4 = (e3 + e5) >>> 1;\r\n+            int a3 = a[e3];\r\n+\r\n+            boolean isRandom =\r\n+                a[e1] > a[e2] || a[e2] > a3 || a3 > a[e4] || a[e4] > a[e5];\r\n+\r\n+            \/*\r\n+             * Sort these elements in place by the combination\r\n+             * of 4-element sorting network and insertion sort.\r\n+             *\r\n+             *    1  ------------o-----o------------\r\n+             *                   |     |\r\n+             *    2  ------o-----|-----o-----o------\r\n+             *             |     |           |\r\n+             *    4  ------|-----o-----o-----o------\r\n+             *             |           |\r\n+             *    5  ------o-----------o------------\r\n+             *\/\r\n+            if (a[e2] > a[e5]) { int t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\r\n+            if (a[e1] > a[e4]) { int t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\r\n+            if (a[e1] > a[e2]) { int t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\r\n+            if (a[e4] > a[e5]) { int t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\r\n+            if (a[e2] > a[e4]) { int t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\r\n+\r\n+            \/*\r\n+             * Insert the third element.\r\n+             *\/\r\n+            if (a3 < a[e2]) {\r\n+                if (a3 < a[e1]) {\r\n+                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\r\n+                } else {\r\n+                    a[e3] = a[e2]; a[e2] = a3;\r\n+                }\r\n+            } else if (a3 > a[e4]) {\r\n+                if (a3 > a[e5]) {\r\n+                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\r\n+                } else {\r\n+                    a[e3] = a[e4]; a[e4] = a3;\r\n+                }\r\n+            }\r\n+\r\n+            \/*\r\n+             * Try Radix sort on large fully random data,\r\n+             * taking into account parallel context.\r\n+             *\/\r\n+            isRandom &= a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5];\r\n+\r\n+            if (size > MIN_RADIX_SORT_SIZE && isRandom && (sorter == null || bits > 0)\r\n+                    && tryRadixSort(sorter, a, low, high)) {\r\n+                return;\r\n+            }\r\n+\r\n+            \/*\r\n+             * Switch to heap sort, if execution time is quadratic.\r\n+             *\/\r\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\r\n+                heapSort(a, low, high);\r\n+                return;\r\n+            }\r\n+\r\n+            \/\/ Pointers\r\n+            int lower = low; \/\/ The index of the last element of the left part\r\n+            int upper = end; \/\/ The index of the first element of the right part\r\n+\r\n+            \/*\r\n+             * Partitioning with two pivots on array of fully random elements.\r\n+             *\/\r\n+            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\r\n+\r\n+                \/*\r\n+                 * Use the first and fifth of the five sorted elements as\r\n+                 * the pivots. These values are inexpensive approximation\r\n+                 * of tertiles. Note, that pivot1 < pivot2.\r\n+                 *\/\r\n+                int pivot1 = a[e1];\r\n+                int pivot2 = a[e5];\r\n+\r\n+                \/*\r\n+                 * The first and the last elements to be sorted are moved\r\n+                 * to the locations formerly occupied by the pivots. When\r\n+                 * partitioning is completed, the pivots are swapped back\r\n+                 * into their final positions, and excluded from the next\r\n+                 * subsequent sorting.\r\n+                 *\/\r\n+                a[e1] = a[lower];\r\n+                a[e5] = a[upper];\r\n+\r\n+                \/*\r\n+                 * Skip elements, which are less or greater than the pivots.\r\n+                 *\/\r\n+                while (a[++lower] < pivot1);\r\n+                while (a[--upper] > pivot2);\r\n+\r\n+                \/*\r\n+                 * Backward 3-interval partitioning\r\n+                 *\r\n+                 *     left part                    central part          right part\r\n+                 * +------------------------------------------------------------------+\r\n+                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |\r\n+                 * +------------------------------------------------------------------+\r\n+                 *               ^         ^                            ^\r\n+                 *               |         |                            |\r\n+                 *             lower       k                          upper\r\n+                 *\r\n+                 * Pointer k is the last index of ?-part\r\n+                 * Pointer lower is the last index of left part\r\n+                 * Pointer upper is the first index of right part\r\n+                 *\r\n+                 * Invariants:\r\n+                 *\r\n+                 *     all in (low, lower]  <  pivot1\r\n+                 *     all in (k, upper)   in [pivot1, pivot2]\r\n+                 *     all in [upper, end)  >  pivot2\r\n+                 *\/\r\n+                for (int unused = --lower, k = ++upper; --k > lower; ) {\r\n+                    int ak = a[k];\r\n+\r\n+                    if (ak < pivot1) { \/\/ Move a[k] to the left side\r\n+                        while (a[++lower] < pivot1) {\r\n+                            if (lower == k) {\r\n+                                break;\r\n+                            }\r\n+                        }\r\n+                        if (a[lower] > pivot2) {\r\n+                            a[k] = a[--upper];\r\n+                            a[upper] = a[lower];\r\n+                        } else {\r\n+                            a[k] = a[lower];\r\n+                        }\r\n+                        a[lower] = ak;\r\n+                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\r\n+                        a[k] = a[--upper];\r\n+                        a[upper] = ak;\r\n+                    }\r\n+                }\r\n+\r\n+                \/*\r\n+                 * Swap the pivots into their final positions.\r\n+                 *\/\r\n+                a[low] = a[lower]; a[lower] = pivot1;\r\n+                a[end] = a[upper]; a[upper] = pivot2;\r\n+\r\n+                \/*\r\n+                 * Sort non-left parts recursively (possibly in parallel),\r\n+                 * excluding known pivots.\r\n+                 *\/\r\n+                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\r\n+                    sorter.fork(bits | 1, lower + 1, upper);\r\n+                    sorter.fork(bits | 1, upper + 1, high);\r\n+                } else {\r\n+                    sort(sorter, a, bits | 1, lower + 1, upper);\r\n+                    sort(sorter, a, bits | 1, upper + 1, high);\r\n+                }\r\n+\r\n+            } else { \/\/ Partitioning with one pivot\r\n+\r\n+                \/*\r\n+                 * Use the third of the five sorted elements as the pivot.\r\n+                 * This value is inexpensive approximation of the median.\r\n+                 *\/\r\n+                int pivot = a[e3];\r\n+\r\n+                \/*\r\n+                 * The first element to be sorted is moved to the\r\n+                 * location formerly occupied by the pivot. After\r\n+                 * completion of partitioning the pivot is swapped\r\n+                 * back into its final position, and excluded from\r\n+                 * the next subsequent sorting.\r\n+                 *\/\r\n+                a[e3] = a[lower];\r\n+\r\n+                \/*\r\n+                 * Dutch National Flag partitioning\r\n+                 *\r\n+                 *    left part                central part    right part\r\n+                 * +------------------------------------------------------+\r\n+                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\r\n+                 * +------------------------------------------------------+\r\n+                 *              ^           ^                ^\r\n+                 *              |           |                |\r\n+                 *            lower         k              upper\r\n+                 *\r\n+                 * Pointer k is the last index of ?-part\r\n+                 * Pointer lower is the last index of left part\r\n+                 * Pointer upper is the first index of right part\r\n+                 *\r\n+                 * Invariants:\r\n+                 *\r\n+                 *     all in (low, lower]  <  pivot\r\n+                 *     all in (k, upper)   ==  pivot\r\n+                 *     all in [upper, end]  >  pivot\r\n+                 *\/\r\n+                for (int k = ++upper; --k > lower; ) {\r\n+                    int ak = a[k];\r\n+\r\n+                    if (ak != pivot) {\r\n+                        a[k] = pivot;\r\n+\r\n+                        if (ak < pivot) { \/\/ Move a[k] to the left side\r\n+                            while (a[++lower] < pivot);\r\n+\r\n+                            if (a[lower] > pivot) {\r\n+                                a[--upper] = a[lower];\r\n+                            }\r\n+                            a[lower] = ak;\r\n+                        } else { \/\/ ak > pivot - Move a[k] to the right side\r\n+                            a[--upper] = ak;\r\n+                        }\r\n+                    }\r\n+                }\r\n+\r\n+                \/*\r\n+                 * Swap the pivot into its final position.\r\n+                 *\/\r\n+                a[low] = a[lower]; a[lower] = pivot;\r\n+\r\n+                \/*\r\n+                 * Sort the right part (possibly in parallel), excluding\r\n+                 * known pivot. All elements from the central part are\r\n+                 * equal and therefore already sorted.\r\n+                 *\/\r\n+                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\r\n+                    sorter.fork(bits | 1, upper, high);\r\n+                } else {\r\n+                    sort(sorter, a, bits | 1, upper, high);\r\n+                }\r\n+            }\r\n+            high = lower; \/\/ Iterate along the left part\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using mixed insertion sort.\r\n+     *\r\n+     * Mixed insertion sort is combination of pin insertion sort,\r\n+     * simple insertion sort and pair insertion sort.\r\n+     *\r\n+     * In the context of Dual-Pivot Quicksort, the pivot element\r\n+     * from the left part plays the role of sentinel, because it\r\n+     * is less than any elements from the given part. Therefore,\r\n+     * expensive check of the left range can be skipped on each\r\n+     * iteration unless it is the leftmost call.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void mixedInsertionSort(int[] a, int low, int high) {\r\n+\r\n+        \/*\r\n+         * Split part for pin and pair insertion sorts.\r\n+         *\/\r\n+        int end = high - 3 * ((high - low) >> 3 << 1);\r\n+\r\n+        \/*\r\n+         * Invoke simple insertion sort on small part.\r\n+         *\/\r\n+        if (end == high) {\r\n+            for (int i; ++low < high; ) {\r\n+                int ai = a[i = low];\r\n+\r\n+                while (ai < a[i - 1]) {\r\n+                    a[i] = a[--i];\r\n+                }\r\n+                a[i] = ai;\r\n+            }\r\n+            return;\r\n+        }\r\n+\r\n+        \/*\r\n+         * Start with pin insertion sort.\r\n+         *\/\r\n+        for (int i, p = high; ++low < end; ) {\r\n+            int ai = a[i = low], pin = a[--p];\r\n+\r\n+            \/*\r\n+             * Swap larger element with pin.\r\n+             *\/\r\n+            if (ai > pin) {\r\n+                ai = pin;\r\n+                a[p] = a[i];\r\n+            }\r\n+\r\n+            \/*\r\n+             * Insert element into sorted part.\r\n+             *\/\r\n+            while (ai < a[i - 1]) {\r\n+                a[i] = a[--i];\r\n+            }\r\n+            a[i] = ai;\r\n+        }\r\n+\r\n+        \/*\r\n+         * Finish with pair insertion sort.\r\n+         *\/\r\n+        for (int i; low < high; ++low) {\r\n+            int a1 = a[i = low], a2 = a[++low];\r\n+\r\n+            \/*\r\n+             * Insert two elements per iteration: at first, insert the\r\n+             * larger element and then insert the smaller element, but\r\n+             * from the position where the larger element was inserted.\r\n+             *\/\r\n+            if (a1 > a2) {\r\n+\r\n+                while (a1 < a[--i]) {\r\n+                    a[i + 2] = a[i];\r\n+                }\r\n+                a[++i + 1] = a1;\r\n+\r\n+                while (a2 < a[--i]) {\r\n+                    a[i + 1] = a[i];\r\n+                }\r\n+                a[i + 1] = a2;\r\n+\r\n+            } else if (a1 < a[i - 1]) {\r\n+\r\n+                while (a2 < a[--i]) {\r\n+                    a[i + 2] = a[i];\r\n+                }\r\n+                a[++i + 1] = a2;\r\n+\r\n+                while (a1 < a[--i]) {\r\n+                    a[i + 1] = a[i];\r\n+                }\r\n+                a[i + 1] = a1;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using insertion sort.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void insertionSort(int[] a, int low, int high) {\r\n+        for (int i, k = low; ++k < high; ) {\r\n+            int ai = a[i = k];\r\n+\r\n+            if (ai < a[i - 1]) {\r\n+                do {\r\n+                    a[i] = a[--i];\r\n+                } while (i > low && ai < a[i - 1]);\r\n+\r\n+                a[i ] = ai;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Tries to sort the specified range of the array using merging sort.\r\n+     *\r\n+     * @param sorter parallel context\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\r\n+     *\/\r\n+    static boolean tryMergingSort(Sorter<int[]> sorter, int[] a, int low, int high) {\r\n+\r\n+        \/*\r\n+         * The element run[i] holds the start index\r\n+         * of i-th sequence in non-descending order.\r\n+         *\/\r\n+        int count = 1;\r\n+        int[] run = null;\r\n+\r\n+        \/*\r\n+         * Identify all possible runs.\r\n+         *\/\r\n+        for (int k = low + 1, last = low; k < high; ) {\r\n+\r\n+            \/*\r\n+             * Find the next run.\r\n+             *\/\r\n+            if (a[k - 1] < a[k]) {\r\n+\r\n+                \/\/ Identify ascending sequence\r\n+                while (++k < high && a[k - 1] <= a[k]);\r\n+\r\n+            } else if (a[k - 1] > a[k]) {\r\n+\r\n+                \/\/ Identify descending sequence\r\n+                while (++k < high && a[k - 1] >= a[k]);\r\n+\r\n+                \/\/ Reverse into ascending order\r\n+                for (int i = last - 1, j = k; ++i < --j && a[i] > a[j]; ) {\r\n+                    int ai = a[i]; a[i] = a[j]; a[j] = ai;\r\n+                }\r\n+            } else { \/\/ Identify constant sequence\r\n+                for (int ak = a[k]; ++k < high && ak == a[k]; );\r\n+\r\n+                if (k < high) {\r\n+                    continue;\r\n+                }\r\n+            }\r\n+\r\n+            \/*\r\n+             * Check if the runs are too\r\n+             * long to continue scanning.\r\n+             *\/\r\n+            if (count > 6 && k - low < count * MIN_RUN_SIZE) {\r\n+                return false;\r\n+            }\r\n+\r\n+            \/*\r\n+             * Process the run.\r\n+             *\/\r\n+            if (run == null) {\r\n+\r\n+                if (k == high) {\r\n+                    \/*\r\n+                     * Array is monotonous sequence\r\n+                     * and therefore already sorted.\r\n+                     *\/\r\n+                    return true;\r\n+                }\r\n+\r\n+                run = new int[((high - low) >> 9) & 0x1FF | 0x3F];\r\n+                run[0] = low;\r\n+\r\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\r\n+\r\n+                if (++count == run.length) {\r\n+                    \/*\r\n+                     * Array is not highly structured.\r\n+                     *\/\r\n+                    return false;\r\n+                }\r\n+            }\r\n+\r\n+            \/*\r\n+             * Save the current run.\r\n+             *\/\r\n+            run[count] = (last = k);\r\n+\r\n+            \/*\r\n+             * Check single-element run at the end.\r\n+             *\/\r\n+            if (++k == high) {\r\n+                --k;\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Merge all runs.\r\n+         *\/\r\n+        if (count > 1) {\r\n+            int[] b; int offset = low;\r\n+\r\n+            if (sorter != null && (b = sorter.b) != null) {\r\n+                offset = sorter.offset;\r\n+            } else if ((b = tryAllocate(int[].class, high - low)) == null) {\r\n+                return false;\r\n+            }\r\n+            mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);\r\n+        }\r\n+        return true;\r\n+    }\r\n+\r\n+    \/**\r\n+     * Merges the specified runs.\r\n+     *\r\n+     * @param a the source array\r\n+     * @param b the temporary buffer used in merging\r\n+     * @param offset the start index in the source, inclusive\r\n+     * @param aim specifies merging: to source ( > 0), buffer ( < 0) or any ( == 0)\r\n+     * @param parallel indicates whether merging is performed in parallel\r\n+     * @param run the start indexes of the runs, inclusive\r\n+     * @param lo the start index of the first run, inclusive\r\n+     * @param hi the start index of the last run, inclusive\r\n+     * @return the destination where runs are merged\r\n+     *\/\r\n+    private static int[] mergeRuns(int[] a, int[] b, int offset,\r\n+            int aim, boolean parallel, int[] run, int lo, int hi) {\r\n+\r\n+        if (hi - lo == 1) {\r\n+            if (aim >= 0) {\r\n+                return a;\r\n+            }\r\n+            System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\r\n+            return b;\r\n+        }\r\n+\r\n+        \/*\r\n+         * Split into approximately equal parts.\r\n+         *\/\r\n+        int mi = lo, rmi = (run[lo] + run[hi]) >>> 1;\r\n+        while (run[++mi + 1] <= rmi);\r\n+\r\n+        \/*\r\n+         * Merge runs of each part.\r\n+         *\/\r\n+        int[] a1 = mergeRuns(a, b, offset, -aim, parallel, run, lo, mi);\r\n+        int[] a2 = mergeRuns(a, b, offset,    0, parallel, run, mi, hi);\r\n+        int[] dst = a1 == a ? b : a;\r\n+\r\n+        int k   = a1 == a ? run[lo] - offset : run[lo];\r\n+        int lo1 = a1 == b ? run[lo] - offset : run[lo];\r\n+        int hi1 = a1 == b ? run[mi] - offset : run[mi];\r\n+        int lo2 = a2 == b ? run[mi] - offset : run[mi];\r\n+        int hi2 = a2 == b ? run[hi] - offset : run[hi];\r\n+\r\n+        \/*\r\n+         * Merge the left and right parts.\r\n+         *\/\r\n+        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && parallel) {\r\n+            new Merger<>(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\r\n+        } else {\r\n+            mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);\r\n+        }\r\n+        return dst;\r\n+    }\r\n+\r\n+    \/**\r\n+     * Merges the sorted parts.\r\n+     *\r\n+     * @param merger parallel context\r\n+     * @param dst the destination where parts are merged\r\n+     * @param k the start index of the destination, inclusive\r\n+     * @param a1 the first part\r\n+     * @param lo1 the start index of the first part, inclusive\r\n+     * @param hi1 the end index of the first part, exclusive\r\n+     * @param a2 the second part\r\n+     * @param lo2 the start index of the second part, inclusive\r\n+     * @param hi2 the end index of the second part, exclusive\r\n+     *\/\r\n+    private static void mergeParts(Merger<int[]> merger, int[] dst, int k,\r\n+            int[] a1, int lo1, int hi1, int[] a2, int lo2, int hi2) {\r\n+\r\n+        if (merger != null && a1 == a2) {\r\n+\r\n+            while (true) {\r\n+\r\n+                \/*\r\n+                 * The first part must be larger.\r\n+                 *\/\r\n+                if (hi1 - lo1 < hi2 - lo2) {\r\n+                    int lo = lo1; lo1 = lo2; lo2 = lo;\r\n+                    int hi = hi1; hi1 = hi2; hi2 = hi;\r\n+                }\r\n+\r\n+                \/*\r\n+                 * Small parts will be merged sequentially.\r\n+                 *\/\r\n+                if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\r\n+                    break;\r\n+                }\r\n+\r\n+                \/*\r\n+                 * Find the median of the larger part.\r\n+                 *\/\r\n+                int mi1 = (lo1 + hi1) >>> 1;\r\n+                int key = a1[mi1];\r\n+                int mi2 = hi2;\r\n+\r\n+                \/*\r\n+                 * Divide the smaller part.\r\n+                 *\/\r\n+                for (int loo = lo2; loo < mi2; ) {\r\n+                    int t = (loo + mi2) >>> 1;\r\n+\r\n+                    if (key > a2[t]) {\r\n+                        loo = t + 1;\r\n+                    } else {\r\n+                        mi2 = t;\r\n+                    }\r\n+                }\r\n+\r\n+                \/*\r\n+                 * Reserve space for the left part.\r\n+                 *\/\r\n+                int d = mi2 - lo2 + mi1 - lo1;\r\n+\r\n+                \/*\r\n+                 * Merge the right part in parallel.\r\n+                 *\/\r\n+                merger.fork(k + d, mi1, hi1, mi2, hi2);\r\n+\r\n+                \/*\r\n+                 * Iterate along the left part.\r\n+                 *\/\r\n+                hi1 = mi1;\r\n+                hi2 = mi2;\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Merge small parts sequentially.\r\n+         *\/\r\n+        while (lo1 < hi1 && lo2 < hi2) {\r\n+            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\r\n+        }\r\n+        if (dst != a1 || k < lo1) {\r\n+            while (lo1 < hi1) {\r\n+                dst[k++] = a1[lo1++];\r\n+            }\r\n+        }\r\n+        if (dst != a2 || k < lo2) {\r\n+            while (lo2 < hi2) {\r\n+                dst[k++] = a2[lo2++];\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Tries to sort the specified range of the array\r\n+     * using LSD (The Least Significant Digit) Radix sort.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\r\n+     *\/\r\n+    static boolean tryRadixSort(Sorter<int[]> sorter, int[] a, int low, int high) {\r\n+        int[] b; int offset = low, size = high - low;\r\n+\r\n+        \/*\r\n+         * Allocate additional buffer.\r\n+         *\/\r\n+        if (sorter != null && (b = sorter.b) != null) {\r\n+            offset = sorter.offset;\r\n+        } else if ((b = tryAllocate(int[].class, size)) == null) {\r\n+            return false;\r\n+        }\r\n+\r\n+        int start = low - offset;\r\n+        int last = high - offset;\r\n+\r\n+        \/*\r\n+         * Count the number of all digits.\r\n+         *\/\r\n+        int[] count1 = new int[1024];\r\n+        int[] count2 = new int[2048];\r\n+        int[] count3 = new int[2048];\r\n+\r\n+        for (int i = low; i < high; ++i) {\r\n+            ++count1[ a[i]         & 0x3FF];\r\n+            ++count2[(a[i] >>> 10) & 0x7FF];\r\n+            ++count3[(a[i] >>> 21) ^ 0x400]; \/\/ Reverse the sign bit\r\n+        }\r\n+\r\n+        \/*\r\n+         * Detect digits to be processed.\r\n+         *\/\r\n+        boolean processDigit1 = processDigit(count1, size, low);\r\n+        boolean processDigit2 = processDigit(count2, size, low);\r\n+        boolean processDigit3 = processDigit(count3, size, low);\r\n+\r\n+        \/*\r\n+         * Process the 1-st digit.\r\n+         *\/\r\n+        if (processDigit1) {\r\n+            for (int i = high; i > low; ) {\r\n+                b[--count1[a[--i] & 0x3FF] - offset] = a[i];\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Process the 2-nd digit.\r\n+         *\/\r\n+        if (processDigit2) {\r\n+            if (processDigit1) {\r\n+                for (int i = last; i > start; ) {\r\n+                    a[--count2[(b[--i] >>> 10) & 0x7FF]] = b[i];\r\n+                }\r\n+            } else {\r\n+                for (int i = high; i > low; ) {\r\n+                    b[--count2[(a[--i] >>> 10) & 0x7FF] - offset] = a[i];\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Process the 3-rd digit.\r\n+         *\/\r\n+        if (processDigit3) {\r\n+            if (processDigit1 ^ processDigit2) {\r\n+                for (int i = last; i > start; ) {\r\n+                    a[--count3[(b[--i] >>> 21) ^ 0x400]] = b[i];\r\n+                }\r\n+            } else {\r\n+                for (int i = high; i > low; ) {\r\n+                    b[--count3[(a[--i] >>> 21) ^ 0x400] - offset] = a[i];\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Copy the buffer to original array, if we process ood number of digits.\r\n+         *\/\r\n+        if (processDigit1 ^ processDigit2 ^ processDigit3) {\r\n+            System.arraycopy(b, low - offset, a, low, size);\r\n+        }\r\n+        return true;\r\n+    }\r\n+\r\n+    \/**\r\n+     * Checks the count array and then computes the histogram.\r\n+     *\r\n+     * @param count the count array\r\n+     * @param total the total number of elements\r\n+     * @param low the index of the first element, inclusive\r\n+     * @return {@code true} if the digit must be processed, otherwise {@code false}\r\n+     *\/\r\n+    private static boolean processDigit(int[] count, int total, int low) {\r\n+\r\n+        \/*\r\n+         * Check if we can skip given digit.\r\n+         *\/\r\n+        for (int c : count) {\r\n+            if (c == total) {\r\n+                return false;\r\n+            }\r\n+            if (c > 0) {\r\n+                break;\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Compute the histogram.\r\n+         *\/\r\n+        count[0] += low;\r\n+\r\n+        for (int i = 0; ++i < count.length; ) {\r\n+            count[i] += count[i - 1];\r\n+        }\r\n+        return true;\r\n+    }\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using heap sort.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void heapSort(int[] a, int low, int high) {\r\n+        for (int k = (low + high) >>> 1; k > low; ) {\r\n+            pushDown(a, --k, a[k], low, high);\r\n+        }\r\n+        while (--high > low) {\r\n+            int max = a[low];\r\n+            pushDown(a, low, a[high], low, high);\r\n+            a[high] = max;\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Pushes specified element down during heap sort.\r\n+     *\r\n+     * @param a the given array\r\n+     * @param p the start index\r\n+     * @param value the given element\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    private static void pushDown(int[] a, int p, int value, int low, int high) {\r\n+        for (int k ;; a[p] = a[p = k]) {\r\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\r\n+\r\n+            if (k > high) {\r\n+                break;\r\n+            }\r\n+            if (k == high || a[k] < a[k - 1]) {\r\n+                --k;\r\n+            }\r\n+            if (a[k] <= value) {\r\n+                break;\r\n+            }\r\n+        }\r\n+        a[p] = value;\r\n+    }\r\n+\r\n+\/\/ #[long]\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using parallel merge\r\n+     * sort and\/or Dual-Pivot Quicksort.\r\n+     *\r\n+     * To balance the faster splitting and parallelism of merge sort\r\n+     * with the faster element partitioning of Quicksort, ranges are\r\n+     * subdivided in tiers such that, if there is enough parallelism,\r\n+     * the four-way parallel merge is started, still ensuring enough\r\n+     * parallelism to process the partitions.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param parallelism the parallelism level\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void sort(long[] a, int parallelism, int low, int high) {\r\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\r\n+            new Sorter<>(a, parallelism, low, high - low, 0).invoke();\r\n+        } else {\r\n+            sort(null, a, 0, low, high);\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\r\n+     *\r\n+     * @param sorter parallel context\r\n+     * @param a the array to be sorted\r\n+     * @param bits the combination of recursion depth and bit flag, where\r\n+     *        the right bit \"0\" indicates that range is the leftmost part\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void sort(Sorter<long[]> sorter, long[] a, int bits, int low, int high) {\r\n+        while (true) {\r\n+            int size = high - low;\r\n+\r\n+            \/*\r\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\r\n+             *\/\r\n+            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\r\n+                mixedInsertionSort(a, low, high);\r\n+                return;\r\n+            }\r\n+\r\n+            \/*\r\n+             * Invoke insertion sort on small leftmost part.\r\n+             *\/\r\n+            if (size < MAX_INSERTION_SORT_SIZE) {\r\n+                insertionSort(a, low, high);\r\n+                return;\r\n+            }\r\n+\r\n+            \/*\r\n+             * Try merging sort on large part.\r\n+             *\/\r\n+            if (size > MIN_MERGING_SORT_SIZE * bits\r\n+                    && tryMergingSort(sorter, a, low, high)) {\r\n+                return;\r\n+            }\r\n+\r\n+            \/*\r\n+             * Use an inexpensive approximation of the golden ratio\r\n+             * to select five sample elements and determine pivots.\r\n+             *\/\r\n+            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;\r\n+\r\n+            \/*\r\n+             * Five elements around (and including) the central element\r\n+             * will be used for pivot selection as described below. The\r\n+             * unequal choice of spacing these elements was empirically\r\n+             * determined to work well on a wide variety of inputs.\r\n+             *\/\r\n+            int end = high - 1;\r\n+            int e1 = low + step;\r\n+            int e5 = end - step;\r\n+            int e3 = (e1 + e5) >>> 1;\r\n+            int e2 = (e1 + e3) >>> 1;\r\n+            int e4 = (e3 + e5) >>> 1;\r\n+            long a3 = a[e3];\r\n+\r\n+            boolean isRandom =\r\n+                a[e1] > a[e2] || a[e2] > a3 || a3 > a[e4] || a[e4] > a[e5];\r\n+\r\n+            \/*\r\n+             * Sort these elements in place by the combination\r\n+             * of 4-element sorting network and insertion sort.\r\n+             *\r\n+             *    1  ------------o-----o------------\r\n+             *                   |     |\r\n+             *    2  ------o-----|-----o-----o------\r\n+             *             |     |           |\r\n+             *    4  ------|-----o-----o-----o------\r\n+             *             |           |\r\n+             *    5  ------o-----------o------------\r\n+             *\/\r\n+            if (a[e2] > a[e5]) { long t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\r\n+            if (a[e1] > a[e4]) { long t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\r\n+            if (a[e1] > a[e2]) { long t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\r\n+            if (a[e4] > a[e5]) { long t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\r\n+            if (a[e2] > a[e4]) { long t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\r\n+\r\n+            \/*\r\n+             * Insert the third element.\r\n+             *\/\r\n+            if (a3 < a[e2]) {\r\n+                if (a3 < a[e1]) {\r\n+                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\r\n+                } else {\r\n+                    a[e3] = a[e2]; a[e2] = a3;\r\n+                }\r\n+            } else if (a3 > a[e4]) {\r\n+                if (a3 > a[e5]) {\r\n+                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\r\n+                } else {\r\n+                    a[e3] = a[e4]; a[e4] = a3;\r\n+                }\r\n+            }\r\n+\r\n+            \/*\r\n+             * Try Radix sort on large fully random data,\r\n+             * taking into account parallel context.\r\n+             *\/\r\n+            isRandom &= a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5];\r\n+\r\n+            if (size > MIN_RADIX_SORT_SIZE && isRandom && (sorter == null || bits > 0)\r\n+                    && tryRadixSort(sorter, a, low, high)) {\r\n+                return;\r\n+            }\r\n+\r\n+            \/*\r\n+             * Switch to heap sort, if execution time is quadratic.\r\n+             *\/\r\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\r\n+                heapSort(a, low, high);\r\n+                return;\r\n+            }\r\n+\r\n+            \/\/ Pointers\r\n+            int lower = low; \/\/ The index of the last element of the left part\r\n+            int upper = end; \/\/ The index of the first element of the right part\r\n+\r\n+            \/*\r\n+             * Partitioning with two pivots on array of fully random elements.\r\n+             *\/\r\n+            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\r\n+\r\n+                \/*\r\n+                 * Use the first and fifth of the five sorted elements as\r\n+                 * the pivots. These values are inexpensive approximation\r\n+                 * of tertiles. Note, that pivot1 < pivot2.\r\n+                 *\/\r\n+                long pivot1 = a[e1];\r\n+                long pivot2 = a[e5];\r\n+\r\n+                \/*\r\n+                 * The first and the last elements to be sorted are moved\r\n+                 * to the locations formerly occupied by the pivots. When\r\n+                 * partitioning is completed, the pivots are swapped back\r\n+                 * into their final positions, and excluded from the next\r\n+                 * subsequent sorting.\r\n+                 *\/\r\n+                a[e1] = a[lower];\r\n+                a[e5] = a[upper];\r\n+\r\n+                \/*\r\n+                 * Skip elements, which are less or greater than the pivots.\r\n+                 *\/\r\n+                while (a[++lower] < pivot1);\r\n+                while (a[--upper] > pivot2);\r\n+\r\n+                \/*\r\n+                 * Backward 3-interval partitioning\r\n+                 *\r\n+                 *     left part                    central part          right part\r\n+                 * +------------------------------------------------------------------+\r\n+                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |\r\n+                 * +------------------------------------------------------------------+\r\n+                 *               ^         ^                            ^\r\n+                 *               |         |                            |\r\n+                 *             lower       k                          upper\r\n+                 *\r\n+                 * Pointer k is the last index of ?-part\r\n+                 * Pointer lower is the last index of left part\r\n+                 * Pointer upper is the first index of right part\r\n+                 *\r\n+                 * Invariants:\r\n+                 *\r\n+                 *     all in (low, lower]  <  pivot1\r\n+                 *     all in (k, upper)   in [pivot1, pivot2]\r\n+                 *     all in [upper, end)  >  pivot2\r\n+                 *\/\r\n+                for (int unused = --lower, k = ++upper; --k > lower; ) {\r\n+                    long ak = a[k];\r\n+\r\n+                    if (ak < pivot1) { \/\/ Move a[k] to the left side\r\n+                        while (a[++lower] < pivot1) {\r\n+                            if (lower == k) {\r\n+                                break;\r\n+                            }\r\n+                        }\r\n+                        if (a[lower] > pivot2) {\r\n+                            a[k] = a[--upper];\r\n+                            a[upper] = a[lower];\r\n+                        } else {\r\n+                            a[k] = a[lower];\r\n+                        }\r\n+                        a[lower] = ak;\r\n+                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\r\n+                        a[k] = a[--upper];\r\n+                        a[upper] = ak;\r\n+                    }\r\n+                }\r\n+\r\n+                \/*\r\n+                 * Swap the pivots into their final positions.\r\n+                 *\/\r\n+                a[low] = a[lower]; a[lower] = pivot1;\r\n+                a[end] = a[upper]; a[upper] = pivot2;\r\n+\r\n+                \/*\r\n+                 * Sort non-left parts recursively (possibly in parallel),\r\n+                 * excluding known pivots.\r\n+                 *\/\r\n+                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\r\n+                    sorter.fork(bits | 1, lower + 1, upper);\r\n+                    sorter.fork(bits | 1, upper + 1, high);\r\n+                } else {\r\n+                    sort(sorter, a, bits | 1, lower + 1, upper);\r\n+                    sort(sorter, a, bits | 1, upper + 1, high);\r\n+                }\r\n+\r\n+            } else { \/\/ Partitioning with one pivot\r\n+\r\n+                \/*\r\n+                 * Use the third of the five sorted elements as the pivot.\r\n+                 * This value is inexpensive approximation of the median.\r\n+                 *\/\r\n+                long pivot = a[e3];\r\n+\r\n+                \/*\r\n+                 * The first element to be sorted is moved to the\r\n+                 * location formerly occupied by the pivot. After\r\n+                 * completion of partitioning the pivot is swapped\r\n+                 * back into its final position, and excluded from\r\n+                 * the next subsequent sorting.\r\n+                 *\/\r\n+                a[e3] = a[lower];\r\n+\r\n+                \/*\r\n+                 * Dutch National Flag partitioning\r\n+                 *\r\n+                 *    left part                central part    right part\r\n+                 * +------------------------------------------------------+\r\n+                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\r\n+                 * +------------------------------------------------------+\r\n+                 *              ^           ^                ^\r\n+                 *              |           |                |\r\n+                 *            lower         k              upper\r\n+                 *\r\n+                 * Pointer k is the last index of ?-part\r\n+                 * Pointer lower is the last index of left part\r\n+                 * Pointer upper is the first index of right part\r\n+                 *\r\n+                 * Invariants:\r\n+                 *\r\n+                 *     all in (low, lower]  <  pivot\r\n+                 *     all in (k, upper)   ==  pivot\r\n+                 *     all in [upper, end]  >  pivot\r\n+                 *\/\r\n+                for (int k = ++upper; --k > lower; ) {\r\n+                    long ak = a[k];\r\n+\r\n+                    if (ak != pivot) {\r\n+                        a[k] = pivot;\r\n+\r\n+                        if (ak < pivot) { \/\/ Move a[k] to the left side\r\n+                            while (a[++lower] < pivot);\r\n+\r\n+                            if (a[lower] > pivot) {\r\n+                                a[--upper] = a[lower];\r\n+                            }\r\n+                            a[lower] = ak;\r\n+                        } else { \/\/ ak > pivot - Move a[k] to the right side\r\n+                            a[--upper] = ak;\r\n+                        }\r\n+                    }\r\n+                }\r\n+\r\n+                \/*\r\n+                 * Swap the pivot into its final position.\r\n+                 *\/\r\n+                a[low] = a[lower]; a[lower] = pivot;\r\n+\r\n+                \/*\r\n+                 * Sort the right part (possibly in parallel), excluding\r\n+                 * known pivot. All elements from the central part are\r\n+                 * equal and therefore already sorted.\r\n+                 *\/\r\n+                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\r\n+                    sorter.fork(bits | 1, upper, high);\r\n+                } else {\r\n+                    sort(sorter, a, bits | 1, upper, high);\r\n+                }\r\n+            }\r\n+            high = lower; \/\/ Iterate along the left part\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using mixed insertion sort.\r\n+     *\r\n+     * Mixed insertion sort is combination of pin insertion sort,\r\n+     * simple insertion sort and pair insertion sort.\r\n+     *\r\n+     * In the context of Dual-Pivot Quicksort, the pivot element\r\n+     * from the left part plays the role of sentinel, because it\r\n+     * is less than any elements from the given part. Therefore,\r\n+     * expensive check of the left range can be skipped on each\r\n+     * iteration unless it is the leftmost call.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void mixedInsertionSort(long[] a, int low, int high) {\r\n+\r\n+        \/*\r\n+         * Split part for pin and pair insertion sorts.\r\n+         *\/\r\n+        int end = high - 3 * ((high - low) >> 3 << 1);\r\n+\r\n+        \/*\r\n+         * Invoke simple insertion sort on small part.\r\n+         *\/\r\n+        if (end == high) {\r\n+            for (int i; ++low < high; ) {\r\n+                long ai = a[i = low];\r\n+\r\n+                while (ai < a[i - 1]) {\r\n+                    a[i] = a[--i];\r\n+                }\r\n+                a[i] = ai;\r\n+            }\r\n+            return;\r\n+        }\r\n+\r\n+        \/*\r\n+         * Start with pin insertion sort.\r\n+         *\/\r\n+        for (int i, p = high; ++low < end; ) {\r\n+            long ai = a[i = low], pin = a[--p];\r\n+\r\n+            \/*\r\n+             * Swap larger element with pin.\r\n+             *\/\r\n+            if (ai > pin) {\r\n+                ai = pin;\r\n+                a[p] = a[i];\r\n+            }\r\n+\r\n+            \/*\r\n+             * Insert element into sorted part.\r\n+             *\/\r\n+            while (ai < a[i - 1]) {\r\n+                a[i] = a[--i];\r\n+            }\r\n+            a[i] = ai;\r\n+        }\r\n+\r\n+        \/*\r\n+         * Finish with pair insertion sort.\r\n+         *\/\r\n+        for (int i; low < high; ++low) {\r\n+            long a1 = a[i = low], a2 = a[++low];\r\n+\r\n+            \/*\r\n+             * Insert two elements per iteration: at first, insert the\r\n+             * larger element and then insert the smaller element, but\r\n+             * from the position where the larger element was inserted.\r\n+             *\/\r\n+            if (a1 > a2) {\r\n+\r\n+                while (a1 < a[--i]) {\r\n+                    a[i + 2] = a[i];\r\n+                }\r\n+                a[++i + 1] = a1;\r\n+\r\n+                while (a2 < a[--i]) {\r\n+                    a[i + 1] = a[i];\r\n+                }\r\n+                a[i + 1] = a2;\r\n+\r\n+            } else if (a1 < a[i - 1]) {\r\n+\r\n+                while (a2 < a[--i]) {\r\n+                    a[i + 2] = a[i];\r\n+                }\r\n+                a[++i + 1] = a2;\r\n+\r\n+                while (a1 < a[--i]) {\r\n+                    a[i + 1] = a[i];\r\n+                }\r\n+                a[i + 1] = a1;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using insertion sort.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void insertionSort(long[] a, int low, int high) {\r\n+        for (int i, k = low; ++k < high; ) {\r\n+            long ai = a[i = k];\r\n+\r\n+            if (ai < a[i - 1]) {\r\n+                do {\r\n+                    a[i] = a[--i];\r\n+                } while (i > low && ai < a[i - 1]);\r\n+\r\n+                a[i ] = ai;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Tries to sort the specified range of the array using merging sort.\r\n+     *\r\n+     * @param sorter parallel context\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\r\n+     *\/\r\n+    static boolean tryMergingSort(Sorter<long[]> sorter, long[] a, int low, int high) {\r\n+\r\n+        \/*\r\n+         * The element run[i] holds the start index\r\n+         * of i-th sequence in non-descending order.\r\n+         *\/\r\n+        int count = 1;\r\n+        int[] run = null;\r\n+\r\n+        \/*\r\n+         * Identify all possible runs.\r\n+         *\/\r\n+        for (int k = low + 1, last = low; k < high; ) {\r\n+\r\n+            \/*\r\n+             * Find the next run.\r\n+             *\/\r\n+            if (a[k - 1] < a[k]) {\r\n+\r\n+                \/\/ Identify ascending sequence\r\n+                while (++k < high && a[k - 1] <= a[k]);\r\n+\r\n+            } else if (a[k - 1] > a[k]) {\r\n+\r\n+                \/\/ Identify descending sequence\r\n+                while (++k < high && a[k - 1] >= a[k]);\r\n+\r\n+                \/\/ Reverse into ascending order\r\n+                for (int i = last - 1, j = k; ++i < --j && a[i] > a[j]; ) {\r\n+                    long ai = a[i]; a[i] = a[j]; a[j] = ai;\r\n+                }\r\n+            } else { \/\/ Identify constant sequence\r\n+                for (long ak = a[k]; ++k < high && ak == a[k]; );\r\n+\r\n+                if (k < high) {\r\n+                    continue;\r\n+                }\r\n+            }\r\n+\r\n+            \/*\r\n+             * Check if the runs are too\r\n+             * long to continue scanning.\r\n+             *\/\r\n+            if (count > 6 && k - low < count * MIN_RUN_SIZE) {\r\n+                return false;\r\n+            }\r\n+\r\n+            \/*\r\n+             * Process the run.\r\n+             *\/\r\n+            if (run == null) {\r\n+\r\n+                if (k == high) {\r\n+                    \/*\r\n+                     * Array is monotonous sequence\r\n+                     * and therefore already sorted.\r\n+                     *\/\r\n+                    return true;\r\n+                }\r\n+\r\n+                run = new int[((high - low) >> 9) & 0x1FF | 0x3F];\r\n+                run[0] = low;\r\n+\r\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\r\n+\r\n+                if (++count == run.length) {\r\n+                    \/*\r\n+                     * Array is not highly structured.\r\n+                     *\/\r\n+                    return false;\r\n+                }\r\n+            }\r\n+\r\n+            \/*\r\n+             * Save the current run.\r\n+             *\/\r\n+            run[count] = (last = k);\r\n+\r\n+            \/*\r\n+             * Check single-element run at the end.\r\n+             *\/\r\n+            if (++k == high) {\r\n+                --k;\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Merge all runs.\r\n+         *\/\r\n+        if (count > 1) {\r\n+            long[] b; int offset = low;\r\n+\r\n+            if (sorter != null && (b = sorter.b) != null) {\r\n+                offset = sorter.offset;\r\n+            } else if ((b = tryAllocate(long[].class, high - low)) == null) {\r\n+                return false;\r\n+            }\r\n+            mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);\r\n+        }\r\n+        return true;\r\n+    }\r\n+\r\n+    \/**\r\n+     * Merges the specified runs.\r\n+     *\r\n+     * @param a the source array\r\n+     * @param b the temporary buffer used in merging\r\n+     * @param offset the start index in the source, inclusive\r\n+     * @param aim specifies merging: to source ( > 0), buffer ( < 0) or any ( == 0)\r\n+     * @param parallel indicates whether merging is performed in parallel\r\n+     * @param run the start indexes of the runs, inclusive\r\n+     * @param lo the start index of the first run, inclusive\r\n+     * @param hi the start index of the last run, inclusive\r\n+     * @return the destination where runs are merged\r\n+     *\/\r\n+    private static long[] mergeRuns(long[] a, long[] b, int offset,\r\n+            int aim, boolean parallel, int[] run, int lo, int hi) {\r\n+\r\n+        if (hi - lo == 1) {\r\n+            if (aim >= 0) {\r\n+                return a;\r\n+            }\r\n+            System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\r\n+            return b;\r\n+        }\r\n+\r\n+        \/*\r\n+         * Split into approximately equal parts.\r\n+         *\/\r\n+        int mi = lo, rmi = (run[lo] + run[hi]) >>> 1;\r\n+        while (run[++mi + 1] <= rmi);\r\n+\r\n+        \/*\r\n+         * Merge runs of each part.\r\n+         *\/\r\n+        long[] a1 = mergeRuns(a, b, offset, -aim, parallel, run, lo, mi);\r\n+        long[] a2 = mergeRuns(a, b, offset,    0, parallel, run, mi, hi);\r\n+        long[] dst = a1 == a ? b : a;\r\n+\r\n+        int k   = a1 == a ? run[lo] - offset : run[lo];\r\n+        int lo1 = a1 == b ? run[lo] - offset : run[lo];\r\n+        int hi1 = a1 == b ? run[mi] - offset : run[mi];\r\n+        int lo2 = a2 == b ? run[mi] - offset : run[mi];\r\n+        int hi2 = a2 == b ? run[hi] - offset : run[hi];\r\n+\r\n+        \/*\r\n+         * Merge the left and right parts.\r\n+         *\/\r\n+        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && parallel) {\r\n+            new Merger<>(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\r\n+        } else {\r\n+            mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);\r\n+        }\r\n+        return dst;\r\n+    }\r\n+\r\n+    \/**\r\n+     * Merges the sorted parts.\r\n+     *\r\n+     * @param merger parallel context\r\n+     * @param dst the destination where parts are merged\r\n+     * @param k the start index of the destination, inclusive\r\n+     * @param a1 the first part\r\n+     * @param lo1 the start index of the first part, inclusive\r\n+     * @param hi1 the end index of the first part, exclusive\r\n+     * @param a2 the second part\r\n+     * @param lo2 the start index of the second part, inclusive\r\n+     * @param hi2 the end index of the second part, exclusive\r\n+     *\/\r\n+    private static void mergeParts(Merger<long[]> merger, long[] dst, int k,\r\n+            long[] a1, int lo1, int hi1, long[] a2, int lo2, int hi2) {\r\n+\r\n+        if (merger != null && a1 == a2) {\r\n+\r\n+            while (true) {\r\n+\r\n+                \/*\r\n+                 * The first part must be larger.\r\n+                 *\/\r\n+                if (hi1 - lo1 < hi2 - lo2) {\r\n+                    int lo = lo1; lo1 = lo2; lo2 = lo;\r\n+                    int hi = hi1; hi1 = hi2; hi2 = hi;\r\n+                }\r\n+\r\n+                \/*\r\n+                 * Small parts will be merged sequentially.\r\n+                 *\/\r\n+                if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\r\n+                    break;\r\n+                }\r\n+\r\n+                \/*\r\n+                 * Find the median of the larger part.\r\n+                 *\/\r\n+                int mi1 = (lo1 + hi1) >>> 1;\r\n+                long key = a1[mi1];\r\n+                int mi2 = hi2;\r\n+\r\n+                \/*\r\n+                 * Divide the smaller part.\r\n+                 *\/\r\n+                for (int loo = lo2; loo < mi2; ) {\r\n+                    int t = (loo + mi2) >>> 1;\r\n+\r\n+                    if (key > a2[t]) {\r\n+                        loo = t + 1;\r\n+                    } else {\r\n+                        mi2 = t;\r\n+                    }\r\n+                }\r\n+\r\n+                \/*\r\n+                 * Reserve space for the left part.\r\n+                 *\/\r\n+                int d = mi2 - lo2 + mi1 - lo1;\r\n+\r\n+                \/*\r\n+                 * Merge the right part in parallel.\r\n+                 *\/\r\n+                merger.fork(k + d, mi1, hi1, mi2, hi2);\r\n+\r\n+                \/*\r\n+                 * Iterate along the left part.\r\n+                 *\/\r\n+                hi1 = mi1;\r\n+                hi2 = mi2;\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Merge small parts sequentially.\r\n+         *\/\r\n+        while (lo1 < hi1 && lo2 < hi2) {\r\n+            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\r\n+        }\r\n+        if (dst != a1 || k < lo1) {\r\n+            while (lo1 < hi1) {\r\n+                dst[k++] = a1[lo1++];\r\n+            }\r\n+        }\r\n+        if (dst != a2 || k < lo2) {\r\n+            while (lo2 < hi2) {\r\n+                dst[k++] = a2[lo2++];\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Tries to sort the specified range of the array\r\n+     * using LSD (The Least Significant Digit) Radix sort.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\r\n+     *\/\r\n+    static boolean tryRadixSort(Sorter<long[]> sorter, long[] a, int low, int high) {\r\n+        long[] b; int offset = low, size = high - low;\r\n+\r\n+        \/*\r\n+         * Allocate additional buffer.\r\n+         *\/\r\n+        if (sorter != null && (b = sorter.b) != null) {\r\n+            offset = sorter.offset;\r\n+        } else if ((b = tryAllocate(long[].class, size)) == null) {\r\n+            return false;\r\n+        }\r\n+\r\n+        int start = low - offset;\r\n+        int last = high - offset;\r\n+\r\n+        \/*\r\n+         * Count the number of all digits.\r\n+         *\/\r\n+        int[] count1 = new int[1024];\r\n+        int[] count2 = new int[2048];\r\n+        int[] count3 = new int[2048];\r\n+        int[] count4 = new int[2048];\r\n+        int[] count5 = new int[2048];\r\n+        int[] count6 = new int[1024];\r\n+\r\n+        for (int i = low; i < high; ++i) {\r\n+            ++count1[(int)  (a[i]         & 0x3FF)];\r\n+            ++count2[(int) ((a[i] >>> 10) & 0x7FF)];\r\n+            ++count3[(int) ((a[i] >>> 21) & 0x7FF)];\r\n+            ++count4[(int) ((a[i] >>> 32) & 0x7FF)];\r\n+            ++count5[(int) ((a[i] >>> 43) & 0x7FF)];\r\n+            ++count6[(int) ((a[i] >>> 54) ^ 0x200)]; \/\/ Reverse the sign bit\r\n+        }\r\n+\r\n+        \/*\r\n+         * Detect digits to be processed.\r\n+         *\/\r\n+        boolean processDigit1 = processDigit(count1, size, low);\r\n+        boolean processDigit2 = processDigit(count2, size, low);\r\n+        boolean processDigit3 = processDigit(count3, size, low);\r\n+        boolean processDigit4 = processDigit(count4, size, low);\r\n+        boolean processDigit5 = processDigit(count5, size, low);\r\n+        boolean processDigit6 = processDigit(count6, size, low);\r\n+\r\n+        \/*\r\n+         * Process the 1-st digit.\r\n+         *\/\r\n+        if (processDigit1) {\r\n+            for (int i = high; i > low; ) {\r\n+                b[--count1[(int) (a[--i] & 0x3FF)] - offset] = a[i];\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Process the 2-nd digit.\r\n+         *\/\r\n+        if (processDigit2) {\r\n+            if (processDigit1) {\r\n+                for (int i = last; i > start; ) {\r\n+                    a[--count2[(int) ((b[--i] >>> 10) & 0x7FF)]] = b[i];\r\n+                }\r\n+            } else {\r\n+                for (int i = high; i > low; ) {\r\n+                    b[--count2[(int) ((a[--i] >>> 10) & 0x7FF)] - offset] = a[i];\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Process the 3-rd digit.\r\n+         *\/\r\n+        if (processDigit3) {\r\n+            if (processDigit1 ^ processDigit2) {\r\n+                for (int i = last; i > start; ) {\r\n+                    a[--count3[(int) ((b[--i] >>> 21) & 0x7FF)]] = b[i];\r\n+                }\r\n+            } else {\r\n+                for (int i = high; i > low; ) {\r\n+                    b[--count3[(int) ((a[--i] >>> 21) & 0x7FF)] - offset] = a[i];\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Process the 4-th digit.\r\n+         *\/\r\n+        if (processDigit4) {\r\n+            if (processDigit1 ^ processDigit2 ^ processDigit3) {\r\n+                for (int i = last; i > start; ) {\r\n+                    a[--count4[(int) ((b[--i] >>> 32) & 0x7FF)]] = b[i];\r\n+                }\r\n+            } else {\r\n+                for (int i = high; i > low; ) {\r\n+                    b[--count4[(int) ((a[--i] >>> 32) & 0x7FF)] - offset] = a[i];\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Process the 5-th digit.\r\n+         *\/\r\n+        if (processDigit5) {\r\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4) {\r\n+                for (int i = last; i > start; ) {\r\n+                    a[--count5[(int) ((b[--i] >>> 43) & 0x7FF)]] = b[i];\r\n+                }\r\n+            } else {\r\n+                for (int i = high; i > low; ) {\r\n+                    b[--count5[(int) ((a[--i] >>> 43) & 0x7FF)] - offset] = a[i];\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Process the 6-th digit.\r\n+         *\/\r\n+        if (processDigit6) {\r\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5) {\r\n+                for (int i = last; i > start; ) {\r\n+                    a[--count6[(int) ((b[--i] >>> 54) ^ 0x200)]] = b[i];\r\n+                }\r\n+            } else {\r\n+                for (int i = high; i > low; ) {\r\n+                    b[--count6[(int) ((a[--i] >>> 54) ^ 0x200)] - offset] = a[i];\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Copy the buffer to original array, if we process ood number of digits.\r\n+         *\/\r\n+        if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5 ^ processDigit6) {\r\n+            System.arraycopy(b, low - offset, a, low, size);\r\n+        }\r\n+        return true;\r\n+    }\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using heap sort.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void heapSort(long[] a, int low, int high) {\r\n+        for (int k = (low + high) >>> 1; k > low; ) {\r\n+            pushDown(a, --k, a[k], low, high);\r\n+        }\r\n+        while (--high > low) {\r\n+            long max = a[low];\r\n+            pushDown(a, low, a[high], low, high);\r\n+            a[high] = max;\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Pushes specified element down during heap sort.\r\n+     *\r\n+     * @param a the given array\r\n+     * @param p the start index\r\n+     * @param value the given element\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    private static void pushDown(long[] a, int p, long value, int low, int high) {\r\n+        for (int k ;; a[p] = a[p = k]) {\r\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\r\n+\r\n+            if (k > high) {\r\n+                break;\r\n+            }\r\n+            if (k == high || a[k] < a[k - 1]) {\r\n+                --k;\r\n+            }\r\n+            if (a[k] <= value) {\r\n+                break;\r\n+            }\r\n+        }\r\n+        a[p] = value;\r\n+    }\r\n+\r\n+\/\/ #[byte]\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using\r\n+     * counting sort or insertion sort.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void sort(byte[] a, int low, int high) {\r\n+        if (high - low > MIN_BYTE_COUNTING_SORT_SIZE) {\r\n+            countingSort(a, low, high);\r\n+        } else {\r\n+            insertionSort(a, low, high);\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * The number of distinct byte values.\r\n+     *\/\r\n+    private static final int NUM_BYTE_VALUES = 1 << 8;\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using counting sort.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    private static void countingSort(byte[] a, int low, int high) {\r\n+        int[] count = new int[NUM_BYTE_VALUES];\r\n+\r\n+        \/*\r\n+         * Compute the histogram.\r\n+         *\/\r\n+        for (int i = high; i > low; ++count[a[--i] & 0xFF]);\r\n+\r\n+        \/*\r\n+         * Put values on their final positions.\r\n+         *\/\r\n+        for (int i = Byte.MAX_VALUE + 1; high > low; ) {\r\n+            while (count[--i & 0xFF] == 0);\r\n+\r\n+            int num = count[i & 0xFF];\r\n+\r\n+            do {\r\n+                a[--high] = (byte) i;\r\n+            } while (--num > 0);\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using insertion sort.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void insertionSort(byte[] a, int low, int high) {\r\n+        for (int i, k = low; ++k < high; ) {\r\n+            byte ai = a[i = k];\r\n+\r\n+            if (ai < a[i - 1]) {\r\n+                do {\r\n+                    a[i] = a[--i];\r\n+                } while (i > low && ai < a[i - 1]);\r\n+\r\n+                a[i ] = ai;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+\/\/ #[char]\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using\r\n+     * counting sort or Dual-Pivot Quicksort.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void sort(char[] a, int low, int high) {\r\n+        if (high - low > MIN_CHAR_COUNTING_SORT_SIZE) {\r\n+            countingSort(a, low, high);\r\n+        } else {\r\n+            sort(a, 0, low, high);\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * The number of distinct char values.\r\n+     *\/\r\n+    private static final int NUM_CHAR_VALUES = 1 << 16;\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using counting sort.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    private static void countingSort(char[] a, int low, int high) {\r\n+        int[] count = new int[NUM_CHAR_VALUES];\r\n+\r\n+        \/*\r\n+         * Compute the histogram.\r\n+         *\/\r\n+        for (int i = high; i > low; ++count[a[--i]]);\r\n+\r\n+        \/*\r\n+         * Put values on their final positions.\r\n+         *\/\r\n+        if (high - low > NUM_CHAR_VALUES) {\r\n+            for (int i = NUM_CHAR_VALUES; i > 0; ) {\r\n+                for (low = high - count[--i]; high > low; ) {\r\n+                    a[--high] = (char) i;\r\n+                }\r\n+            }\r\n+        } else {\r\n+            for (int i = NUM_CHAR_VALUES; high > low; ) {\r\n+                while (count[--i] == 0);\r\n+\r\n+                int num = count[i];\r\n+\r\n+                do {\r\n+                    a[--high] = (char) i;\r\n+                } while (--num > 0);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param bits the combination of recursion depth and bit flag, where\r\n+     *        the right bit \"0\" indicates that range is the leftmost part\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void sort(char[] a, int bits, int low, int high) {\r\n+        while (true) {\r\n+            int size = high - low;\r\n+\r\n+            \/*\r\n+             * Invoke insertion sort on small part.\r\n+             *\/\r\n+            if (size < MAX_INSERTION_SORT_SIZE) {\r\n+                insertionSort(a, low, high);\r\n+                return;\r\n+            }\r\n+\r\n+            \/*\r\n+             * Switch to counting sort, if execution time is quadratic.\r\n+             *\/\r\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\r\n+                countingSort(a, low, high);\r\n+                return;\r\n+            }\r\n+\r\n+            \/*\r\n+             * Use an inexpensive approximation of the golden ratio\r\n+             * to select five sample elements and determine pivots.\r\n+             *\/\r\n+            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;\r\n+\r\n+            \/*\r\n+             * Five elements around (and including) the central element\r\n+             * will be used for pivot selection as described below. The\r\n+             * unequal choice of spacing these elements was empirically\r\n+             * determined to work well on a wide variety of inputs.\r\n+             *\/\r\n+            int end = high - 1;\r\n+            int e1 = low + step;\r\n+            int e5 = end - step;\r\n+            int e3 = (e1 + e5) >>> 1;\r\n+            int e2 = (e1 + e3) >>> 1;\r\n+            int e4 = (e3 + e5) >>> 1;\r\n+            char a3 = a[e3];\r\n+\r\n+            \/*\r\n+             * Sort these elements in place by the combination\r\n+             * of 4-element sorting network and insertion sort.\r\n+             *\r\n+             *    1  ------------o-----o------------\r\n+             *                   |     |\r\n+             *    2  ------o-----|-----o-----o------\r\n+             *             |     |           |\r\n+             *    4  ------|-----o-----o-----o------\r\n+             *             |           |\r\n+             *    5  ------o-----------o------------\r\n+             *\/\r\n+            if (a[e2] > a[e5]) { char t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\r\n+            if (a[e1] > a[e4]) { char t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\r\n+            if (a[e1] > a[e2]) { char t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\r\n+            if (a[e4] > a[e5]) { char t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\r\n+            if (a[e2] > a[e4]) { char t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\r\n+\r\n+            \/*\r\n+             * Insert the third element.\r\n+             *\/\r\n+            if (a3 < a[e2]) {\r\n+                if (a3 < a[e1]) {\r\n+                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\r\n+                } else {\r\n+                    a[e3] = a[e2]; a[e2] = a3;\r\n+                }\r\n+            } else if (a3 > a[e4]) {\r\n+                if (a3 > a[e5]) {\r\n+                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\r\n+                } else {\r\n+                    a[e3] = a[e4]; a[e4] = a3;\r\n+                }\r\n+            }\r\n+\r\n+            \/\/ Pointers\r\n+            int lower = low; \/\/ The index of the last element of the left part\r\n+            int upper = end; \/\/ The index of the first element of the right part\r\n+\r\n+            \/*\r\n+             * Partitioning with two pivots on array of fully random elements.\r\n+             *\/\r\n+            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\r\n+\r\n+                \/*\r\n+                 * Use the first and fifth of the five sorted elements as\r\n+                 * the pivots. These values are inexpensive approximation\r\n+                 * of tertiles. Note, that pivot1 < pivot2.\r\n+                 *\/\r\n+                char pivot1 = a[e1];\r\n+                char pivot2 = a[e5];\r\n+\r\n+                \/*\r\n+                 * The first and the last elements to be sorted are moved\r\n+                 * to the locations formerly occupied by the pivots. When\r\n+                 * partitioning is completed, the pivots are swapped back\r\n+                 * into their final positions, and excluded from the next\r\n+                 * subsequent sorting.\r\n+                 *\/\r\n+                a[e1] = a[lower];\r\n+                a[e5] = a[upper];\r\n+\r\n+                \/*\r\n+                 * Skip elements, which are less or greater than the pivots.\r\n+                 *\/\r\n+                while (a[++lower] < pivot1);\r\n+                while (a[--upper] > pivot2);\r\n+\r\n+                \/*\r\n+                 * Backward 3-interval partitioning\r\n+                 *\r\n+                 *     left part                    central part          right part\r\n+                 * +------------------------------------------------------------------+\r\n+                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |\r\n+                 * +------------------------------------------------------------------+\r\n+                 *               ^         ^                            ^\r\n+                 *               |         |                            |\r\n+                 *             lower       k                          upper\r\n+                 *\r\n+                 * Pointer k is the last index of ?-part\r\n+                 * Pointer lower is the last index of left part\r\n+                 * Pointer upper is the first index of right part\r\n+                 *\r\n+                 * Invariants:\r\n+                 *\r\n+                 *     all in (low, lower]  <  pivot1\r\n+                 *     all in (k, upper)   in [pivot1, pivot2]\r\n+                 *     all in [upper, end)  >  pivot2\r\n+                 *\/\r\n+                for (int unused = --lower, k = ++upper; --k > lower; ) {\r\n+                    char ak = a[k];\r\n+\r\n+                    if (ak < pivot1) { \/\/ Move a[k] to the left side\r\n+                        while (a[++lower] < pivot1) {\r\n+                            if (lower == k) {\r\n+                                break;\r\n+                            }\r\n+                        }\r\n+                        if (a[lower] > pivot2) {\r\n+                            a[k] = a[--upper];\r\n+                            a[upper] = a[lower];\r\n+                        } else {\r\n+                            a[k] = a[lower];\r\n+                        }\r\n+                        a[lower] = ak;\r\n+                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\r\n+                        a[k] = a[--upper];\r\n+                        a[upper] = ak;\r\n+                    }\r\n+                }\r\n+\r\n+                \/*\r\n+                 * Swap the pivots into their final positions.\r\n+                 *\/\r\n+                a[low] = a[lower]; a[lower] = pivot1;\r\n+                a[end] = a[upper]; a[upper] = pivot2;\r\n+\r\n+                \/*\r\n+                 * Sort non-left parts recursively,\r\n+                 * excluding known pivots.\r\n+                 *\/\r\n+                sort(a, bits | 1, lower + 1, upper);\r\n+                sort(a, bits | 1, upper + 1, high);\r\n+\r\n+            } else { \/\/ Partitioning with one pivot\r\n+\r\n+                \/*\r\n+                 * Use the third of the five sorted elements as the pivot.\r\n+                 * This value is inexpensive approximation of the median.\r\n+                 *\/\r\n+                char pivot = a[e3];\r\n+\r\n+                \/*\r\n+                 * The first element to be sorted is moved to the\r\n+                 * location formerly occupied by the pivot. After\r\n+                 * completion of partitioning the pivot is swapped\r\n+                 * back into its final position, and excluded from\r\n+                 * the next subsequent sorting.\r\n+                 *\/\r\n+                a[e3] = a[lower];\r\n+\r\n+                \/*\r\n+                 * Dutch National Flag partitioning\r\n+                 *\r\n+                 *    left part                central part    right part\r\n+                 * +------------------------------------------------------+\r\n+                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\r\n+                 * +------------------------------------------------------+\r\n+                 *              ^           ^                ^\r\n+                 *              |           |                |\r\n+                 *            lower         k              upper\r\n+                 *\r\n+                 * Pointer k is the last index of ?-part\r\n+                 * Pointer lower is the last index of left part\r\n+                 * Pointer upper is the first index of right part\r\n+                 *\r\n+                 * Invariants:\r\n+                 *\r\n+                 *     all in (low, lower]  <  pivot\r\n+                 *     all in (k, upper)   ==  pivot\r\n+                 *     all in [upper, end]  >  pivot\r\n+                 *\/\r\n+                for (int k = ++upper; --k > lower; ) {\r\n+                    char ak = a[k];\r\n+\r\n+                    if (ak != pivot) {\r\n+                        a[k] = pivot;\r\n+\r\n+                        if (ak < pivot) { \/\/ Move a[k] to the left side\r\n+                            while (a[++lower] < pivot);\r\n+\r\n+                            if (a[lower] > pivot) {\r\n+                                a[--upper] = a[lower];\r\n+                            }\r\n+                            a[lower] = ak;\r\n+                        } else { \/\/ ak > pivot - Move a[k] to the right side\r\n+                            a[--upper] = ak;\r\n+                        }\r\n+                    }\r\n+                }\r\n+\r\n+                \/*\r\n+                 * Swap the pivot into its final position.\r\n+                 *\/\r\n+                a[low] = a[lower]; a[lower] = pivot;\r\n+\r\n+                \/*\r\n+                 * Sort the right part, excluding known pivot.\r\n+                 * All elements from the central part are\r\n+                 * equal and therefore already sorted.\r\n+                 *\/\r\n+                sort(a, bits | 1, upper, high);\r\n+            }\r\n+            high = lower; \/\/ Iterate along the left part\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using insertion sort.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void insertionSort(char[] a, int low, int high) {\r\n+        for (int i, k = low; ++k < high; ) {\r\n+            char ai = a[i = k];\r\n+\r\n+            if (ai < a[i - 1]) {\r\n+                do {\r\n+                    a[i] = a[--i];\r\n+                } while (i > low && ai < a[i - 1]);\r\n+\r\n+                a[i ] = ai;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+\/\/ #[short]\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using\r\n+     * counting sort or Dual-Pivot Quicksort.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void sort(short[] a, int low, int high) {\r\n+        if (high - low > MIN_SHORT_COUNTING_SORT_SIZE) {\r\n+            countingSort(a, low, high);\r\n+        } else {\r\n+            sort(a, 0, low, high);\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * The number of distinct short values.\r\n+     *\/\r\n+    private static final int NUM_SHORT_VALUES = 1 << 16;\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using counting sort.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    private static void countingSort(short[] a, int low, int high) {\r\n+        int[] count = new int[NUM_SHORT_VALUES];\r\n+\r\n+        \/*\r\n+         * Compute the histogram.\r\n+         *\/\r\n+        for (int i = high; i > low; ++count[a[--i] & 0xFFFF]);\r\n+\r\n+        \/*\r\n+         * Place values on their final positions.\r\n+         *\/\r\n+        if (high - low > NUM_SHORT_VALUES) {\r\n+            for (int i = Short.MAX_VALUE; i >= Short.MIN_VALUE; --i) {\r\n+                for (low = high - count[i & 0xFFFF]; high > low;\r\n+                    a[--high] = (short) i\r\n+                );\r\n+            }\r\n+        } else {\r\n+            for (int i = Short.MAX_VALUE + 1; high > low; ) {\r\n+                while (count[--i & 0xFFFF] == 0);\r\n+\r\n+                int num = count[i & 0xFFFF];\r\n+\r\n+                do {\r\n+                    a[--high] = (short) i;\r\n+                } while (--num > 0);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param bits the combination of recursion depth and bit flag, where\r\n+     *        the right bit \"0\" indicates that range is the leftmost part\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void sort(short[] a, int bits, int low, int high) {\r\n+        while (true) {\r\n+            int size = high - low;\r\n+\r\n+            \/*\r\n+             * Invoke insertion sort on small part.\r\n+             *\/\r\n+            if (size < MAX_INSERTION_SORT_SIZE) {\r\n+                insertionSort(a, low, high);\r\n+                return;\r\n+            }\r\n+\r\n+            \/*\r\n+             * Switch to counting sort, if execution time is quadratic.\r\n+             *\/\r\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\r\n+                countingSort(a, low, high);\r\n+                return;\r\n+            }\r\n+\r\n+            \/*\r\n+             * Use an inexpensive approximation of the golden ratio\r\n+             * to select five sample elements and determine pivots.\r\n+             *\/\r\n+            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;\r\n+\r\n+            \/*\r\n+             * Five elements around (and including) the central element\r\n+             * will be used for pivot selection as described below. The\r\n+             * unequal choice of spacing these elements was empirically\r\n+             * determined to work well on a wide variety of inputs.\r\n+             *\/\r\n+            int end = high - 1;\r\n+            int e1 = low + step;\r\n+            int e5 = end - step;\r\n+            int e3 = (e1 + e5) >>> 1;\r\n+            int e2 = (e1 + e3) >>> 1;\r\n+            int e4 = (e3 + e5) >>> 1;\r\n+            short a3 = a[e3];\r\n+\r\n+            \/*\r\n+             * Sort these elements in place by the combination\r\n+             * of 4-element sorting network and insertion sort.\r\n+             *\r\n+             *    1  ------------o-----o------------\r\n+             *                   |     |\r\n+             *    2  ------o-----|-----o-----o------\r\n+             *             |     |           |\r\n+             *    4  ------|-----o-----o-----o------\r\n+             *             |           |\r\n+             *    5  ------o-----------o------------\r\n+             *\/\r\n+            if (a[e2] > a[e5]) { short t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\r\n+            if (a[e1] > a[e4]) { short t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\r\n+            if (a[e1] > a[e2]) { short t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\r\n+            if (a[e4] > a[e5]) { short t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\r\n+            if (a[e2] > a[e4]) { short t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\r\n+\r\n+            \/*\r\n+             * Insert the third element.\r\n+             *\/\r\n+            if (a3 < a[e2]) {\r\n+                if (a3 < a[e1]) {\r\n+                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\r\n+                } else {\r\n+                    a[e3] = a[e2]; a[e2] = a3;\r\n+                }\r\n+            } else if (a3 > a[e4]) {\r\n+                if (a3 > a[e5]) {\r\n+                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\r\n+                } else {\r\n+                    a[e3] = a[e4]; a[e4] = a3;\r\n+                }\r\n+            }\r\n+\r\n+            \/\/ Pointers\r\n+            int lower = low; \/\/ The index of the last element of the left part\r\n+            int upper = end; \/\/ The index of the first element of the right part\r\n+\r\n+            \/*\r\n+             * Partitioning with two pivots on array of fully random elements.\r\n+             *\/\r\n+            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\r\n+\r\n+                \/*\r\n+                 * Use the first and fifth of the five sorted elements as\r\n+                 * the pivots. These values are inexpensive approximation\r\n+                 * of tertiles. Note, that pivot1 < pivot2.\r\n+                 *\/\r\n+                short pivot1 = a[e1];\r\n+                short pivot2 = a[e5];\r\n+\r\n+                \/*\r\n+                 * The first and the last elements to be sorted are moved\r\n+                 * to the locations formerly occupied by the pivots. When\r\n+                 * partitioning is completed, the pivots are swapped back\r\n+                 * into their final positions, and excluded from the next\r\n+                 * subsequent sorting.\r\n+                 *\/\r\n+                a[e1] = a[lower];\r\n+                a[e5] = a[upper];\r\n+\r\n+                \/*\r\n+                 * Skip elements, which are less or greater than the pivots.\r\n+                 *\/\r\n+                while (a[++lower] < pivot1);\r\n+                while (a[--upper] > pivot2);\r\n+\r\n+                \/*\r\n+                 * Backward 3-interval partitioning\r\n+                 *\r\n+                 *     left part                    central part          right part\r\n+                 * +------------------------------------------------------------------+\r\n+                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |\r\n+                 * +------------------------------------------------------------------+\r\n+                 *               ^         ^                            ^\r\n+                 *               |         |                            |\r\n+                 *             lower       k                          upper\r\n+                 *\r\n+                 * Pointer k is the last index of ?-part\r\n+                 * Pointer lower is the last index of left part\r\n+                 * Pointer upper is the first index of right part\r\n+                 *\r\n+                 * Invariants:\r\n+                 *\r\n+                 *     all in (low, lower]  <  pivot1\r\n+                 *     all in (k, upper)   in [pivot1, pivot2]\r\n+                 *     all in [upper, end)  >  pivot2\r\n+                 *\/\r\n+                for (int unused = --lower, k = ++upper; --k > lower; ) {\r\n+                    short ak = a[k];\r\n+\r\n+                    if (ak < pivot1) { \/\/ Move a[k] to the left side\r\n+                        while (a[++lower] < pivot1) {\r\n+                            if (lower == k) {\r\n+                                break;\r\n+                            }\r\n+                        }\r\n+                        if (a[lower] > pivot2) {\r\n+                            a[k] = a[--upper];\r\n+                            a[upper] = a[lower];\r\n+                        } else {\r\n+                            a[k] = a[lower];\r\n+                        }\r\n+                        a[lower] = ak;\r\n+                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\r\n+                        a[k] = a[--upper];\r\n+                        a[upper] = ak;\r\n+                    }\r\n+                }\r\n+\r\n+                \/*\r\n+                 * Swap the pivots into their final positions.\r\n+                 *\/\r\n+                a[low] = a[lower]; a[lower] = pivot1;\r\n+                a[end] = a[upper]; a[upper] = pivot2;\r\n+\r\n+                \/*\r\n+                 * Sort non-left parts recursively,\r\n+                 * excluding known pivots.\r\n+                 *\/\r\n+                sort(a, bits | 1, lower + 1, upper);\r\n+                sort(a, bits | 1, upper + 1, high);\r\n+\r\n+            } else { \/\/ Partitioning with one pivot\r\n+\r\n+                \/*\r\n+                 * Use the third of the five sorted elements as the pivot.\r\n+                 * This value is inexpensive approximation of the median.\r\n+                 *\/\r\n+                short pivot = a[e3];\r\n+\r\n+                \/*\r\n+                 * The first element to be sorted is moved to the\r\n+                 * location formerly occupied by the pivot. After\r\n+                 * completion of partitioning the pivot is swapped\r\n+                 * back into its final position, and excluded from\r\n+                 * the next subsequent sorting.\r\n+                 *\/\r\n+                a[e3] = a[lower];\r\n+\r\n+                \/*\r\n+                 * Dutch National Flag partitioning\r\n+                 *\r\n+                 *    left part                central part    right part\r\n+                 * +------------------------------------------------------+\r\n+                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\r\n+                 * +------------------------------------------------------+\r\n+                 *              ^           ^                ^\r\n+                 *              |           |                |\r\n+                 *            lower         k              upper\r\n+                 *\r\n+                 * Pointer k is the last index of ?-part\r\n+                 * Pointer lower is the last index of left part\r\n+                 * Pointer upper is the first index of right part\r\n+                 *\r\n+                 * Invariants:\r\n+                 *\r\n+                 *     all in (low, lower]  <  pivot\r\n+                 *     all in (k, upper)   ==  pivot\r\n+                 *     all in [upper, end]  >  pivot\r\n+                 *\/\r\n+                for (int k = ++upper; --k > lower; ) {\r\n+                    short ak = a[k];\r\n+\r\n+                    if (ak != pivot) {\r\n+                        a[k] = pivot;\r\n+\r\n+                        if (ak < pivot) { \/\/ Move a[k] to the left side\r\n+                            while (a[++lower] < pivot);\r\n+\r\n+                            if (a[lower] > pivot) {\r\n+                                a[--upper] = a[lower];\r\n+                            }\r\n+                            a[lower] = ak;\r\n+                        } else { \/\/ ak > pivot - Move a[k] to the right side\r\n+                            a[--upper] = ak;\r\n+                        }\r\n+                    }\r\n+                }\r\n+\r\n+                \/*\r\n+                 * Swap the pivot into its final position.\r\n+                 *\/\r\n+                a[low] = a[lower]; a[lower] = pivot;\r\n+\r\n+                \/*\r\n+                 * Sort the right part, excluding known pivot.\r\n+                 * All elements from the central part are\r\n+                 * equal and therefore already sorted.\r\n+                 *\/\r\n+                sort(a, bits | 1, upper, high);\r\n+            }\r\n+            high = lower; \/\/ Iterate along the left part\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using insertion sort.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void insertionSort(short[] a, int low, int high) {\r\n+        for (int i, k = low; ++k < high; ) {\r\n+            short ai = a[i = k];\r\n+\r\n+            if (ai < a[i - 1]) {\r\n+                do {\r\n+                    a[i] = a[--i];\r\n+                } while (i > low && ai < a[i - 1]);\r\n+\r\n+                a[i ] = ai;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+\/\/ #[float]\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using parallel merge\r\n+     * sort and\/or Dual-Pivot Quicksort.\r\n+     *\r\n+     * To balance the faster splitting and parallelism of merge sort\r\n+     * with the faster element partitioning of Quicksort, ranges are\r\n+     * subdivided in tiers such that, if there is enough parallelism,\r\n+     * the four-way parallel merge is started, still ensuring enough\r\n+     * parallelism to process the partitions.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param parallelism the parallelism level\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void sort(float[] a, int parallelism, int low, int high) {\r\n+        \/*\r\n+         * Phase 1. Count the number of negative zero -0.0f,\r\n+         * turn them into positive zero, and move all NaNs\r\n+         * to the end of the array.\r\n+         *\/\r\n+        int numNegativeZero = 0;\r\n+\r\n+        for (int k = high; k > low; ) {\r\n+            float ak = a[--k];\r\n+\r\n+            if (ak == 0.0f && Float.floatToRawIntBits(ak) < 0) { \/\/ ak is -0.0f\r\n+                numNegativeZero += 1;\r\n+                a[k] = 0.0f;\r\n+            } else if (ak != ak) { \/\/ ak is NaN\r\n+                a[k] = a[--high];\r\n+                a[high] = ak;\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Phase 2. Sort everything except NaNs,\r\n+         * which are already in place.\r\n+         *\/\r\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\r\n+            new Sorter<>(a, parallelism, low, high - low, 0).invoke();\r\n+        } else {\r\n+            sort(null, a, 0, low, high);\r\n+        }\r\n+\r\n+        \/*\r\n+         * Phase 3. Turn positive zero 0.0f\r\n+         * back into negative zero -0.0f.\r\n+         *\/\r\n+        if (++numNegativeZero == 1) {\r\n+            return;\r\n+        }\r\n+\r\n+        \/*\r\n+         * Find the position one less than\r\n+         * the index of the first zero.\r\n+         *\/\r\n+        while (low <= high) {\r\n+            int middle = (low + high) >>> 1;\r\n+\r\n+            if (a[middle] < 0) {\r\n+                low = middle + 1;\r\n+            } else {\r\n+                high = middle - 1;\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Replace the required number of 0.0f by -0.0f.\r\n+         *\/\r\n+        while (--numNegativeZero > 0) {\r\n+            a[++high] = -0.0f;\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\r\n+     *\r\n+     * @param sorter parallel context\r\n+     * @param a the array to be sorted\r\n+     * @param bits the combination of recursion depth and bit flag, where\r\n+     *        the right bit \"0\" indicates that range is the leftmost part\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void sort(Sorter<float[]> sorter, float[] a, int bits, int low, int high) {\r\n+        while (true) {\r\n+            int size = high - low;\r\n+\r\n+            \/*\r\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\r\n+             *\/\r\n+            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\r\n+                mixedInsertionSort(a, low, high);\r\n+                return;\r\n+            }\r\n+\r\n+            \/*\r\n+             * Invoke insertion sort on small leftmost part.\r\n+             *\/\r\n+            if (size < MAX_INSERTION_SORT_SIZE) {\r\n+                insertionSort(a, low, high);\r\n+                return;\r\n+            }\r\n+\r\n+            \/*\r\n+             * Try merging sort on large part.\r\n+             *\/\r\n+            if (size > MIN_MERGING_SORT_SIZE * bits\r\n+                    && tryMergingSort(sorter, a, low, high)) {\r\n+                return;\r\n+            }\r\n+\r\n+            \/*\r\n+             * Use an inexpensive approximation of the golden ratio\r\n+             * to select five sample elements and determine pivots.\r\n+             *\/\r\n+            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;\r\n+\r\n+            \/*\r\n+             * Five elements around (and including) the central element\r\n+             * will be used for pivot selection as described below. The\r\n+             * unequal choice of spacing these elements was empirically\r\n+             * determined to work well on a wide variety of inputs.\r\n+             *\/\r\n+            int end = high - 1;\r\n+            int e1 = low + step;\r\n+            int e5 = end - step;\r\n+            int e3 = (e1 + e5) >>> 1;\r\n+            int e2 = (e1 + e3) >>> 1;\r\n+            int e4 = (e3 + e5) >>> 1;\r\n+            float a3 = a[e3];\r\n+\r\n+            boolean isRandom =\r\n+                a[e1] > a[e2] || a[e2] > a3 || a3 > a[e4] || a[e4] > a[e5];\r\n+\r\n+            \/*\r\n+             * Sort these elements in place by the combination\r\n+             * of 4-element sorting network and insertion sort.\r\n+             *\r\n+             *    1  ------------o-----o------------\r\n+             *                   |     |\r\n+             *    2  ------o-----|-----o-----o------\r\n+             *             |     |           |\r\n+             *    4  ------|-----o-----o-----o------\r\n+             *             |           |\r\n+             *    5  ------o-----------o------------\r\n+             *\/\r\n+            if (a[e2] > a[e5]) { float t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\r\n+            if (a[e1] > a[e4]) { float t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\r\n+            if (a[e1] > a[e2]) { float t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\r\n+            if (a[e4] > a[e5]) { float t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\r\n+            if (a[e2] > a[e4]) { float t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\r\n+\r\n+            \/*\r\n+             * Insert the third element.\r\n+             *\/\r\n+            if (a3 < a[e2]) {\r\n+                if (a3 < a[e1]) {\r\n+                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\r\n+                } else {\r\n+                    a[e3] = a[e2]; a[e2] = a3;\r\n+                }\r\n+            } else if (a3 > a[e4]) {\r\n+                if (a3 > a[e5]) {\r\n+                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\r\n+                } else {\r\n+                    a[e3] = a[e4]; a[e4] = a3;\r\n+                }\r\n+            }\r\n+\r\n+            \/*\r\n+             * Try Radix sort on large fully random data,\r\n+             * taking into account parallel context.\r\n+             *\/\r\n+            isRandom &= a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5];\r\n+\r\n+            if (size > MIN_RADIX_SORT_SIZE && isRandom && (sorter == null || bits > 0)\r\n+                    && tryRadixSort(sorter, a, low, high)) {\r\n+                return;\r\n+            }\r\n+\r\n+            \/*\r\n+             * Switch to heap sort, if execution time is quadratic.\r\n+             *\/\r\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\r\n+                heapSort(a, low, high);\r\n+                return;\r\n+            }\r\n+\r\n+            \/\/ Pointers\r\n+            int lower = low; \/\/ The index of the last element of the left part\r\n+            int upper = end; \/\/ The index of the first element of the right part\r\n+\r\n+            \/*\r\n+             * Partitioning with two pivots on array of fully random elements.\r\n+             *\/\r\n+            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\r\n+\r\n+                \/*\r\n+                 * Use the first and fifth of the five sorted elements as\r\n+                 * the pivots. These values are inexpensive approximation\r\n+                 * of tertiles. Note, that pivot1 < pivot2.\r\n+                 *\/\r\n+                float pivot1 = a[e1];\r\n+                float pivot2 = a[e5];\r\n+\r\n+                \/*\r\n+                 * The first and the last elements to be sorted are moved\r\n+                 * to the locations formerly occupied by the pivots. When\r\n+                 * partitioning is completed, the pivots are swapped back\r\n+                 * into their final positions, and excluded from the next\r\n+                 * subsequent sorting.\r\n+                 *\/\r\n+                a[e1] = a[lower];\r\n+                a[e5] = a[upper];\r\n+\r\n+                \/*\r\n+                 * Skip elements, which are less or greater than the pivots.\r\n+                 *\/\r\n+                while (a[++lower] < pivot1);\r\n+                while (a[--upper] > pivot2);\r\n+\r\n+                \/*\r\n+                 * Backward 3-interval partitioning\r\n+                 *\r\n+                 *     left part                    central part          right part\r\n+                 * +------------------------------------------------------------------+\r\n+                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |\r\n+                 * +------------------------------------------------------------------+\r\n+                 *               ^         ^                            ^\r\n+                 *               |         |                            |\r\n+                 *             lower       k                          upper\r\n+                 *\r\n+                 * Pointer k is the last index of ?-part\r\n+                 * Pointer lower is the last index of left part\r\n+                 * Pointer upper is the first index of right part\r\n+                 *\r\n+                 * Invariants:\r\n+                 *\r\n+                 *     all in (low, lower]  <  pivot1\r\n+                 *     all in (k, upper)   in [pivot1, pivot2]\r\n+                 *     all in [upper, end)  >  pivot2\r\n+                 *\/\r\n+                for (int unused = --lower, k = ++upper; --k > lower; ) {\r\n+                    float ak = a[k];\r\n+\r\n+                    if (ak < pivot1) { \/\/ Move a[k] to the left side\r\n+                        while (a[++lower] < pivot1) {\r\n+                            if (lower == k) {\r\n+                                break;\r\n+                            }\r\n+                        }\r\n+                        if (a[lower] > pivot2) {\r\n+                            a[k] = a[--upper];\r\n+                            a[upper] = a[lower];\r\n+                        } else {\r\n+                            a[k] = a[lower];\r\n+                        }\r\n+                        a[lower] = ak;\r\n+                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\r\n+                        a[k] = a[--upper];\r\n+                        a[upper] = ak;\r\n+                    }\r\n+                }\r\n+\r\n+                \/*\r\n+                 * Swap the pivots into their final positions.\r\n+                 *\/\r\n+                a[low] = a[lower]; a[lower] = pivot1;\r\n+                a[end] = a[upper]; a[upper] = pivot2;\r\n+\r\n+                \/*\r\n+                 * Sort non-left parts recursively (possibly in parallel),\r\n+                 * excluding known pivots.\r\n+                 *\/\r\n+                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\r\n+                    sorter.fork(bits | 1, lower + 1, upper);\r\n+                    sorter.fork(bits | 1, upper + 1, high);\r\n+                } else {\r\n+                    sort(sorter, a, bits | 1, lower + 1, upper);\r\n+                    sort(sorter, a, bits | 1, upper + 1, high);\r\n+                }\r\n+\r\n+            } else { \/\/ Partitioning with one pivot\r\n+\r\n+                \/*\r\n+                 * Use the third of the five sorted elements as the pivot.\r\n+                 * This value is inexpensive approximation of the median.\r\n+                 *\/\r\n+                float pivot = a[e3];\r\n+\r\n+                \/*\r\n+                 * The first element to be sorted is moved to the\r\n+                 * location formerly occupied by the pivot. After\r\n+                 * completion of partitioning the pivot is swapped\r\n+                 * back into its final position, and excluded from\r\n+                 * the next subsequent sorting.\r\n+                 *\/\r\n+                a[e3] = a[lower];\r\n+\r\n+                \/*\r\n+                 * Dutch National Flag partitioning\r\n+                 *\r\n+                 *    left part                central part    right part\r\n+                 * +------------------------------------------------------+\r\n+                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\r\n+                 * +------------------------------------------------------+\r\n+                 *              ^           ^                ^\r\n+                 *              |           |                |\r\n+                 *            lower         k              upper\r\n+                 *\r\n+                 * Pointer k is the last index of ?-part\r\n+                 * Pointer lower is the last index of left part\r\n+                 * Pointer upper is the first index of right part\r\n+                 *\r\n+                 * Invariants:\r\n+                 *\r\n+                 *     all in (low, lower]  <  pivot\r\n+                 *     all in (k, upper)   ==  pivot\r\n+                 *     all in [upper, end]  >  pivot\r\n+                 *\/\r\n+                for (int k = ++upper; --k > lower; ) {\r\n+                    float ak = a[k];\r\n+\r\n+                    if (ak != pivot) {\r\n+                        a[k] = pivot;\r\n+\r\n+                        if (ak < pivot) { \/\/ Move a[k] to the left side\r\n+                            while (a[++lower] < pivot);\r\n+\r\n+                            if (a[lower] > pivot) {\r\n+                                a[--upper] = a[lower];\r\n+                            }\r\n+                            a[lower] = ak;\r\n+                        } else { \/\/ ak > pivot - Move a[k] to the right side\r\n+                            a[--upper] = ak;\r\n+                        }\r\n+                    }\r\n+                }\r\n+\r\n+                \/*\r\n+                 * Swap the pivot into its final position.\r\n+                 *\/\r\n+                a[low] = a[lower]; a[lower] = pivot;\r\n+\r\n+                \/*\r\n+                 * Sort the right part (possibly in parallel), excluding\r\n+                 * known pivot. All elements from the central part are\r\n+                 * equal and therefore already sorted.\r\n+                 *\/\r\n+                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\r\n+                    sorter.fork(bits | 1, upper, high);\r\n+                } else {\r\n+                    sort(sorter, a, bits | 1, upper, high);\r\n+                }\r\n+            }\r\n+            high = lower; \/\/ Iterate along the left part\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using mixed insertion sort.\r\n+     *\r\n+     * Mixed insertion sort is combination of pin insertion sort,\r\n+     * simple insertion sort and pair insertion sort.\r\n+     *\r\n+     * In the context of Dual-Pivot Quicksort, the pivot element\r\n+     * from the left part plays the role of sentinel, because it\r\n+     * is less than any elements from the given part. Therefore,\r\n+     * expensive check of the left range can be skipped on each\r\n+     * iteration unless it is the leftmost call.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void mixedInsertionSort(float[] a, int low, int high) {\r\n+\r\n+        \/*\r\n+         * Split part for pin and pair insertion sorts.\r\n+         *\/\r\n+        int end = high - 3 * ((high - low) >> 3 << 1);\r\n+\r\n+        \/*\r\n+         * Invoke simple insertion sort on small part.\r\n+         *\/\r\n+        if (end == high) {\r\n+            for (int i; ++low < high; ) {\r\n+                float ai = a[i = low];\r\n+\r\n+                while (ai < a[i - 1]) {\r\n+                    a[i] = a[--i];\r\n+                }\r\n+                a[i] = ai;\r\n+            }\r\n+            return;\r\n+        }\r\n+\r\n+        \/*\r\n+         * Start with pin insertion sort.\r\n+         *\/\r\n+        for (int i, p = high; ++low < end; ) {\r\n+            float ai = a[i = low], pin = a[--p];\r\n+\r\n+            \/*\r\n+             * Swap larger element with pin.\r\n+             *\/\r\n+            if (ai > pin) {\r\n+                ai = pin;\r\n+                a[p] = a[i];\r\n+            }\r\n+\r\n+            \/*\r\n+             * Insert element into sorted part.\r\n+             *\/\r\n+            while (ai < a[i - 1]) {\r\n+                a[i] = a[--i];\r\n+            }\r\n+            a[i] = ai;\r\n+        }\r\n+\r\n+        \/*\r\n+         * Finish with pair insertion sort.\r\n+         *\/\r\n+        for (int i; low < high; ++low) {\r\n+            float a1 = a[i = low], a2 = a[++low];\r\n+\r\n+            \/*\r\n+             * Insert two elements per iteration: at first, insert the\r\n+             * larger element and then insert the smaller element, but\r\n+             * from the position where the larger element was inserted.\r\n+             *\/\r\n+            if (a1 > a2) {\r\n+\r\n+                while (a1 < a[--i]) {\r\n+                    a[i + 2] = a[i];\r\n+                }\r\n+                a[++i + 1] = a1;\r\n+\r\n+                while (a2 < a[--i]) {\r\n+                    a[i + 1] = a[i];\r\n+                }\r\n+                a[i + 1] = a2;\r\n+\r\n+            } else if (a1 < a[i - 1]) {\r\n+\r\n+                while (a2 < a[--i]) {\r\n+                    a[i + 2] = a[i];\r\n+                }\r\n+                a[++i + 1] = a2;\r\n+\r\n+                while (a1 < a[--i]) {\r\n+                    a[i + 1] = a[i];\r\n+                }\r\n+                a[i + 1] = a1;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using insertion sort.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void insertionSort(float[] a, int low, int high) {\r\n+        for (int i, k = low; ++k < high; ) {\r\n+            float ai = a[i = k];\r\n+\r\n+            if (ai < a[i - 1]) {\r\n+                do {\r\n+                    a[i] = a[--i];\r\n+                } while (i > low && ai < a[i - 1]);\r\n+\r\n+                a[i ] = ai;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Tries to sort the specified range of the array using merging sort.\r\n+     *\r\n+     * @param sorter parallel context\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\r\n+     *\/\r\n+    static boolean tryMergingSort(Sorter<float[]> sorter, float[] a, int low, int high) {\r\n+\r\n+        \/*\r\n+         * The element run[i] holds the start index\r\n+         * of i-th sequence in non-descending order.\r\n+         *\/\r\n+        int count = 1;\r\n+        int[] run = null;\r\n+\r\n+        \/*\r\n+         * Identify all possible runs.\r\n+         *\/\r\n+        for (int k = low + 1, last = low; k < high; ) {\r\n+\r\n+            \/*\r\n+             * Find the next run.\r\n+             *\/\r\n+            if (a[k - 1] < a[k]) {\r\n+\r\n+                \/\/ Identify ascending sequence\r\n+                while (++k < high && a[k - 1] <= a[k]);\r\n+\r\n+            } else if (a[k - 1] > a[k]) {\r\n+\r\n+                \/\/ Identify descending sequence\r\n+                while (++k < high && a[k - 1] >= a[k]);\r\n+\r\n+                \/\/ Reverse into ascending order\r\n+                for (int i = last - 1, j = k; ++i < --j && a[i] > a[j]; ) {\r\n+                    float ai = a[i]; a[i] = a[j]; a[j] = ai;\r\n+                }\r\n+            } else { \/\/ Identify constant sequence\r\n+                for (float ak = a[k]; ++k < high && ak == a[k]; );\r\n+\r\n+                if (k < high) {\r\n+                    continue;\r\n+                }\r\n+            }\r\n+\r\n+            \/*\r\n+             * Check if the runs are too\r\n+             * long to continue scanning.\r\n+             *\/\r\n+            if (count > 6 && k - low < count * MIN_RUN_SIZE) {\r\n+                return false;\r\n+            }\r\n+\r\n+            \/*\r\n+             * Process the run.\r\n+             *\/\r\n+            if (run == null) {\r\n+\r\n+                if (k == high) {\r\n+                    \/*\r\n+                     * Array is monotonous sequence\r\n+                     * and therefore already sorted.\r\n+                     *\/\r\n+                    return true;\r\n+                }\r\n+\r\n+                run = new int[((high - low) >> 9) & 0x1FF | 0x3F];\r\n+                run[0] = low;\r\n+\r\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\r\n+\r\n+                if (++count == run.length) {\r\n+                    \/*\r\n+                     * Array is not highly structured.\r\n+                     *\/\r\n+                    return false;\r\n+                }\r\n+            }\r\n+\r\n+            \/*\r\n+             * Save the current run.\r\n+             *\/\r\n+            run[count] = (last = k);\r\n+\r\n+            \/*\r\n+             * Check single-element run at the end.\r\n+             *\/\r\n+            if (++k == high) {\r\n+                --k;\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Merge all runs.\r\n+         *\/\r\n+        if (count > 1) {\r\n+            float[] b; int offset = low;\r\n+\r\n+            if (sorter != null && (b = sorter.b) != null) {\r\n+                offset = sorter.offset;\r\n+            } else if ((b = tryAllocate(float[].class, high - low)) == null) {\r\n+                return false;\r\n+            }\r\n+            mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);\r\n+        }\r\n+        return true;\r\n+    }\r\n+\r\n+    \/**\r\n+     * Merges the specified runs.\r\n+     *\r\n+     * @param a the source array\r\n+     * @param b the temporary buffer used in merging\r\n+     * @param offset the start index in the source, inclusive\r\n+     * @param aim specifies merging: to source ( > 0), buffer ( < 0) or any ( == 0)\r\n+     * @param parallel indicates whether merging is performed in parallel\r\n+     * @param run the start indexes of the runs, inclusive\r\n+     * @param lo the start index of the first run, inclusive\r\n+     * @param hi the start index of the last run, inclusive\r\n+     * @return the destination where runs are merged\r\n+     *\/\r\n+    private static float[] mergeRuns(float[] a, float[] b, int offset,\r\n+            int aim, boolean parallel, int[] run, int lo, int hi) {\r\n+\r\n+        if (hi - lo == 1) {\r\n+            if (aim >= 0) {\r\n+                return a;\r\n+            }\r\n+            System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\r\n+            return b;\r\n+        }\r\n+\r\n+        \/*\r\n+         * Split into approximately equal parts.\r\n+         *\/\r\n+        int mi = lo, rmi = (run[lo] + run[hi]) >>> 1;\r\n+        while (run[++mi + 1] <= rmi);\r\n+\r\n+        \/*\r\n+         * Merge runs of each part.\r\n+         *\/\r\n+        float[] a1 = mergeRuns(a, b, offset, -aim, parallel, run, lo, mi);\r\n+        float[] a2 = mergeRuns(a, b, offset,    0, parallel, run, mi, hi);\r\n+        float[] dst = a1 == a ? b : a;\r\n+\r\n+        int k   = a1 == a ? run[lo] - offset : run[lo];\r\n+        int lo1 = a1 == b ? run[lo] - offset : run[lo];\r\n+        int hi1 = a1 == b ? run[mi] - offset : run[mi];\r\n+        int lo2 = a2 == b ? run[mi] - offset : run[mi];\r\n+        int hi2 = a2 == b ? run[hi] - offset : run[hi];\r\n+\r\n+        \/*\r\n+         * Merge the left and right parts.\r\n+         *\/\r\n+        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && parallel) {\r\n+            new Merger<>(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\r\n+        } else {\r\n+            mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);\r\n+        }\r\n+        return dst;\r\n+    }\r\n+\r\n+    \/**\r\n+     * Merges the sorted parts.\r\n+     *\r\n+     * @param merger parallel context\r\n+     * @param dst the destination where parts are merged\r\n+     * @param k the start index of the destination, inclusive\r\n+     * @param a1 the first part\r\n+     * @param lo1 the start index of the first part, inclusive\r\n+     * @param hi1 the end index of the first part, exclusive\r\n+     * @param a2 the second part\r\n+     * @param lo2 the start index of the second part, inclusive\r\n+     * @param hi2 the end index of the second part, exclusive\r\n+     *\/\r\n+    private static void mergeParts(Merger<float[]> merger, float[] dst, int k,\r\n+            float[] a1, int lo1, int hi1, float[] a2, int lo2, int hi2) {\r\n+\r\n+        if (merger != null && a1 == a2) {\r\n+\r\n+            while (true) {\r\n+\r\n+                \/*\r\n+                 * The first part must be larger.\r\n+                 *\/\r\n+                if (hi1 - lo1 < hi2 - lo2) {\r\n+                    int lo = lo1; lo1 = lo2; lo2 = lo;\r\n+                    int hi = hi1; hi1 = hi2; hi2 = hi;\r\n+                }\r\n+\r\n+                \/*\r\n+                 * Small parts will be merged sequentially.\r\n+                 *\/\r\n+                if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\r\n+                    break;\r\n+                }\r\n+\r\n+                \/*\r\n+                 * Find the median of the larger part.\r\n+                 *\/\r\n+                int mi1 = (lo1 + hi1) >>> 1;\r\n+                float key = a1[mi1];\r\n+                int mi2 = hi2;\r\n+\r\n+                \/*\r\n+                 * Divide the smaller part.\r\n+                 *\/\r\n+                for (int loo = lo2; loo < mi2; ) {\r\n+                    int t = (loo + mi2) >>> 1;\r\n+\r\n+                    if (key > a2[t]) {\r\n+                        loo = t + 1;\r\n+                    } else {\r\n+                        mi2 = t;\r\n+                    }\r\n+                }\r\n+\r\n+                \/*\r\n+                 * Reserve space for the left part.\r\n+                 *\/\r\n+                int d = mi2 - lo2 + mi1 - lo1;\r\n+\r\n+                \/*\r\n+                 * Merge the right part in parallel.\r\n+                 *\/\r\n+                merger.fork(k + d, mi1, hi1, mi2, hi2);\r\n+\r\n+                \/*\r\n+                 * Iterate along the left part.\r\n+                 *\/\r\n+                hi1 = mi1;\r\n+                hi2 = mi2;\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Merge small parts sequentially.\r\n+         *\/\r\n+        while (lo1 < hi1 && lo2 < hi2) {\r\n+            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\r\n+        }\r\n+        if (dst != a1 || k < lo1) {\r\n+            while (lo1 < hi1) {\r\n+                dst[k++] = a1[lo1++];\r\n+            }\r\n+        }\r\n+        if (dst != a2 || k < lo2) {\r\n+            while (lo2 < hi2) {\r\n+                dst[k++] = a2[lo2++];\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Tries to sort the specified range of the array\r\n+     * using LSD (The Least Significant Digit) Radix sort.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\r\n+     *\/\r\n+    static boolean tryRadixSort(Sorter<float[]> sorter, float[] a, int low, int high) {\r\n+        float[] b; int offset = low, size = high - low;\r\n+\r\n+        \/*\r\n+         * Allocate additional buffer.\r\n+         *\/\r\n+        if (sorter != null && (b = sorter.b) != null) {\r\n+            offset = sorter.offset;\r\n+        } else if ((b = tryAllocate(float[].class, size)) == null) {\r\n+            return false;\r\n+        }\r\n+\r\n+        int start = low - offset;\r\n+        int last = high - offset;\r\n+\r\n+        \/*\r\n+         * Count the number of all digits.\r\n+         *\/\r\n+        int[] count1 = new int[1024];\r\n+        int[] count2 = new int[2048];\r\n+        int[] count3 = new int[2048];\r\n+\r\n+        for (int i = low; i < high; ++i) {\r\n+            ++count1[ fti(a[i])         & 0x3FF];\r\n+            ++count2[(fti(a[i]) >>> 10) & 0x7FF];\r\n+            ++count3[(fti(a[i]) >>> 21) & 0x7FF];\r\n+        }\r\n+\r\n+        \/*\r\n+         * Detect digits to be processed.\r\n+         *\/\r\n+        boolean processDigit1 = processDigit(count1, size, low);\r\n+        boolean processDigit2 = processDigit(count2, size, low);\r\n+        boolean processDigit3 = processDigit(count3, size, low);\r\n+\r\n+        \/*\r\n+         * Process the 1-st digit.\r\n+         *\/\r\n+        if (processDigit1) {\r\n+            for (int i = high; i > low; ) {\r\n+                b[--count1[fti(a[--i]) & 0x3FF] - offset] = a[i];\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Process the 2-nd digit.\r\n+         *\/\r\n+        if (processDigit2) {\r\n+            if (processDigit1) {\r\n+                for (int i = last; i > start; ) {\r\n+                    a[--count2[(fti(b[--i]) >>> 10) & 0x7FF]] = b[i];\r\n+                }\r\n+            } else {\r\n+                for (int i = high; i > low; ) {\r\n+                    b[--count2[(fti(a[--i]) >>> 10) & 0x7FF] - offset] = a[i];\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Process the 3-rd digit.\r\n+         *\/\r\n+        if (processDigit3) {\r\n+            if (processDigit1 ^ processDigit2) {\r\n+                for (int i = last; i > start; ) {\r\n+                    a[--count3[(fti(b[--i]) >>> 21) & 0x7FF]] = b[i];\r\n+                }\r\n+            } else {\r\n+                for (int i = high; i > low; ) {\r\n+                    b[--count3[(fti(a[--i]) >>> 21) & 0x7FF] - offset] = a[i];\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Copy the buffer to original array, if we process ood number of digits.\r\n+         *\/\r\n+        if (processDigit1 ^ processDigit2 ^ processDigit3) {\r\n+            System.arraycopy(b, low - offset, a, low, size);\r\n+        }\r\n+        return true;\r\n+    }\r\n+\r\n+    \/**\r\n+     * Returns masked bits that represent the float value.\r\n+     *\r\n+     * @param f the given value\r\n+     * @return masked bits\r\n+     *\/\r\n+    private static int fti(float f) {\r\n+        int x = Float.floatToRawIntBits(f);\r\n+        return x ^ ((x >> 31) | 0x80000000);\r\n+    }\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using heap sort.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void heapSort(float[] a, int low, int high) {\r\n+        for (int k = (low + high) >>> 1; k > low; ) {\r\n+            pushDown(a, --k, a[k], low, high);\r\n+        }\r\n+        while (--high > low) {\r\n+            float max = a[low];\r\n+            pushDown(a, low, a[high], low, high);\r\n+            a[high] = max;\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Pushes specified element down during heap sort.\r\n+     *\r\n+     * @param a the given array\r\n+     * @param p the start index\r\n+     * @param value the given element\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    private static void pushDown(float[] a, int p, float value, int low, int high) {\r\n+        for (int k ;; a[p] = a[p = k]) {\r\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\r\n+\r\n+            if (k > high) {\r\n+                break;\r\n+            }\r\n+            if (k == high || a[k] < a[k - 1]) {\r\n+                --k;\r\n+            }\r\n+            if (a[k] <= value) {\r\n+                break;\r\n+            }\r\n+        }\r\n+        a[p] = value;\r\n+    }\r\n+\r\n+\/\/ #[double]\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using parallel merge\r\n+     * sort and\/or Dual-Pivot Quicksort.\r\n+     *\r\n+     * To balance the faster splitting and parallelism of merge sort\r\n+     * with the faster element partitioning of Quicksort, ranges are\r\n+     * subdivided in tiers such that, if there is enough parallelism,\r\n+     * the four-way parallel merge is started, still ensuring enough\r\n+     * parallelism to process the partitions.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param parallelism the parallelism level\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void sort(double[] a, int parallelism, int low, int high) {\r\n+        \/*\r\n+         * Phase 1. Count the number of negative zero -0.0d,\r\n+         * turn them into positive zero, and move all NaNs\r\n+         * to the end of the array.\r\n+         *\/\r\n+        int numNegativeZero = 0;\r\n+\r\n+        for (int k = high; k > low; ) {\r\n+            double ak = a[--k];\r\n+\r\n+            if (ak == 0.0d && Double.doubleToRawLongBits(ak) < 0) { \/\/ ak is -0.0d\r\n+                numNegativeZero += 1;\r\n+                a[k] = 0.0d;\r\n+            } else if (ak != ak) { \/\/ ak is NaN\r\n+                a[k] = a[--high];\r\n+                a[high] = ak;\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Phase 2. Sort everything except NaNs,\r\n+         * which are already in place.\r\n+         *\/\r\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\r\n+            new Sorter<>(a, parallelism, low, high - low, 0).invoke();\r\n+        } else {\r\n+            sort(null, a, 0, low, high);\r\n+        }\r\n+\r\n+        \/*\r\n+         * Phase 3. Turn positive zero 0.0d\r\n+         * back into negative zero -0.0d.\r\n+         *\/\r\n+        if (++numNegativeZero == 1) {\r\n+            return;\r\n+        }\r\n+\r\n+        \/*\r\n+         * Find the position one less than\r\n+         * the index of the first zero.\r\n+         *\/\r\n+        while (low <= high) {\r\n+            int middle = (low + high) >>> 1;\r\n+\r\n+            if (a[middle] < 0) {\r\n+                low = middle + 1;\r\n+            } else {\r\n+                high = middle - 1;\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Replace the required number of 0.0d by -0.0d.\r\n+         *\/\r\n+        while (--numNegativeZero > 0) {\r\n+            a[++high] = -0.0d;\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\r\n+     *\r\n+     * @param sorter parallel context\r\n+     * @param a the array to be sorted\r\n+     * @param bits the combination of recursion depth and bit flag, where\r\n+     *        the right bit \"0\" indicates that range is the leftmost part\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void sort(Sorter<double[]> sorter, double[] a, int bits, int low, int high) {\r\n+        while (true) {\r\n+            int size = high - low;\r\n+\r\n+            \/*\r\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\r\n+             *\/\r\n+            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\r\n+                mixedInsertionSort(a, low, high);\r\n+                return;\r\n+            }\r\n+\r\n+            \/*\r\n+             * Invoke insertion sort on small leftmost part.\r\n+             *\/\r\n+            if (size < MAX_INSERTION_SORT_SIZE) {\r\n+                insertionSort(a, low, high);\r\n+                return;\r\n+            }\r\n+\r\n+            \/*\r\n+             * Try merging sort on large part.\r\n+             *\/\r\n+            if (size > MIN_MERGING_SORT_SIZE * bits\r\n+                    && tryMergingSort(sorter, a, low, high)) {\r\n+                return;\r\n+            }\r\n+\r\n+            \/*\r\n+             * Use an inexpensive approximation of the golden ratio\r\n+             * to select five sample elements and determine pivots.\r\n+             *\/\r\n+            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;\r\n+\r\n+            \/*\r\n+             * Five elements around (and including) the central element\r\n+             * will be used for pivot selection as described below. The\r\n+             * unequal choice of spacing these elements was empirically\r\n+             * determined to work well on a wide variety of inputs.\r\n+             *\/\r\n+            int end = high - 1;\r\n+            int e1 = low + step;\r\n+            int e5 = end - step;\r\n+            int e3 = (e1 + e5) >>> 1;\r\n+            int e2 = (e1 + e3) >>> 1;\r\n+            int e4 = (e3 + e5) >>> 1;\r\n+            double a3 = a[e3];\r\n+\r\n+            boolean isRandom =\r\n+                a[e1] > a[e2] || a[e2] > a3 || a3 > a[e4] || a[e4] > a[e5];\r\n+\r\n+            \/*\r\n+             * Sort these elements in place by the combination\r\n+             * of 4-element sorting network and insertion sort.\r\n+             *\r\n+             *    1  ------------o-----o------------\r\n+             *                   |     |\r\n+             *    2  ------o-----|-----o-----o------\r\n+             *             |     |           |\r\n+             *    4  ------|-----o-----o-----o------\r\n+             *             |           |\r\n+             *    5  ------o-----------o------------\r\n+             *\/\r\n+            if (a[e2] > a[e5]) { double t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\r\n+            if (a[e1] > a[e4]) { double t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\r\n+            if (a[e1] > a[e2]) { double t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\r\n+            if (a[e4] > a[e5]) { double t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\r\n+            if (a[e2] > a[e4]) { double t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\r\n+\r\n+            \/*\r\n+             * Insert the third element.\r\n+             *\/\r\n+            if (a3 < a[e2]) {\r\n+                if (a3 < a[e1]) {\r\n+                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\r\n+                } else {\r\n+                    a[e3] = a[e2]; a[e2] = a3;\r\n+                }\r\n+            } else if (a3 > a[e4]) {\r\n+                if (a3 > a[e5]) {\r\n+                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\r\n+                } else {\r\n+                    a[e3] = a[e4]; a[e4] = a3;\r\n+                }\r\n+            }\r\n+\r\n+            \/*\r\n+             * Try Radix sort on large fully random data,\r\n+             * taking into account parallel context.\r\n+             *\/\r\n+            isRandom &= a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5];\r\n+\r\n+            if (size > MIN_RADIX_SORT_SIZE && isRandom && (sorter == null || bits > 0)\r\n+                    && tryRadixSort(sorter, a, low, high)) {\r\n+                return;\r\n+            }\r\n+\r\n+            \/*\r\n+             * Switch to heap sort, if execution time is quadratic.\r\n+             *\/\r\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\r\n+                heapSort(a, low, high);\r\n+                return;\r\n+            }\r\n+\r\n+            \/\/ Pointers\r\n+            int lower = low; \/\/ The index of the last element of the left part\r\n+            int upper = end; \/\/ The index of the first element of the right part\r\n+\r\n+            \/*\r\n+             * Partitioning with two pivots on array of fully random elements.\r\n+             *\/\r\n+            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\r\n+\r\n+                \/*\r\n+                 * Use the first and fifth of the five sorted elements as\r\n+                 * the pivots. These values are inexpensive approximation\r\n+                 * of tertiles. Note, that pivot1 < pivot2.\r\n+                 *\/\r\n+                double pivot1 = a[e1];\r\n+                double pivot2 = a[e5];\r\n+\r\n+                \/*\r\n+                 * The first and the last elements to be sorted are moved\r\n+                 * to the locations formerly occupied by the pivots. When\r\n+                 * partitioning is completed, the pivots are swapped back\r\n+                 * into their final positions, and excluded from the next\r\n+                 * subsequent sorting.\r\n+                 *\/\r\n+                a[e1] = a[lower];\r\n+                a[e5] = a[upper];\r\n+\r\n+                \/*\r\n+                 * Skip elements, which are less or greater than the pivots.\r\n+                 *\/\r\n+                while (a[++lower] < pivot1);\r\n+                while (a[--upper] > pivot2);\r\n+\r\n+                \/*\r\n+                 * Backward 3-interval partitioning\r\n+                 *\r\n+                 *     left part                    central part          right part\r\n+                 * +------------------------------------------------------------------+\r\n+                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |\r\n+                 * +------------------------------------------------------------------+\r\n+                 *               ^         ^                            ^\r\n+                 *               |         |                            |\r\n+                 *             lower       k                          upper\r\n+                 *\r\n+                 * Pointer k is the last index of ?-part\r\n+                 * Pointer lower is the last index of left part\r\n+                 * Pointer upper is the first index of right part\r\n+                 *\r\n+                 * Invariants:\r\n+                 *\r\n+                 *     all in (low, lower]  <  pivot1\r\n+                 *     all in (k, upper)   in [pivot1, pivot2]\r\n+                 *     all in [upper, end)  >  pivot2\r\n+                 *\/\r\n+                for (int unused = --lower, k = ++upper; --k > lower; ) {\r\n+                    double ak = a[k];\r\n+\r\n+                    if (ak < pivot1) { \/\/ Move a[k] to the left side\r\n+                        while (a[++lower] < pivot1) {\r\n+                            if (lower == k) {\r\n+                                break;\r\n+                            }\r\n+                        }\r\n+                        if (a[lower] > pivot2) {\r\n+                            a[k] = a[--upper];\r\n+                            a[upper] = a[lower];\r\n+                        } else {\r\n+                            a[k] = a[lower];\r\n+                        }\r\n+                        a[lower] = ak;\r\n+                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\r\n+                        a[k] = a[--upper];\r\n+                        a[upper] = ak;\r\n+                    }\r\n+                }\r\n+\r\n+                \/*\r\n+                 * Swap the pivots into their final positions.\r\n+                 *\/\r\n+                a[low] = a[lower]; a[lower] = pivot1;\r\n+                a[end] = a[upper]; a[upper] = pivot2;\r\n+\r\n+                \/*\r\n+                 * Sort non-left parts recursively (possibly in parallel),\r\n+                 * excluding known pivots.\r\n+                 *\/\r\n+                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\r\n+                    sorter.fork(bits | 1, lower + 1, upper);\r\n+                    sorter.fork(bits | 1, upper + 1, high);\r\n+                } else {\r\n+                    sort(sorter, a, bits | 1, lower + 1, upper);\r\n+                    sort(sorter, a, bits | 1, upper + 1, high);\r\n+                }\r\n+\r\n+            } else { \/\/ Partitioning with one pivot\r\n+\r\n+                \/*\r\n+                 * Use the third of the five sorted elements as the pivot.\r\n+                 * This value is inexpensive approximation of the median.\r\n+                 *\/\r\n+                double pivot = a[e3];\r\n+\r\n+                \/*\r\n+                 * The first element to be sorted is moved to the\r\n+                 * location formerly occupied by the pivot. After\r\n+                 * completion of partitioning the pivot is swapped\r\n+                 * back into its final position, and excluded from\r\n+                 * the next subsequent sorting.\r\n+                 *\/\r\n+                a[e3] = a[lower];\r\n+\r\n+                \/*\r\n+                 * Dutch National Flag partitioning\r\n+                 *\r\n+                 *    left part                central part    right part\r\n+                 * +------------------------------------------------------+\r\n+                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\r\n+                 * +------------------------------------------------------+\r\n+                 *              ^           ^                ^\r\n+                 *              |           |                |\r\n+                 *            lower         k              upper\r\n+                 *\r\n+                 * Pointer k is the last index of ?-part\r\n+                 * Pointer lower is the last index of left part\r\n+                 * Pointer upper is the first index of right part\r\n+                 *\r\n+                 * Invariants:\r\n+                 *\r\n+                 *     all in (low, lower]  <  pivot\r\n+                 *     all in (k, upper)   ==  pivot\r\n+                 *     all in [upper, end]  >  pivot\r\n+                 *\/\r\n+                for (int k = ++upper; --k > lower; ) {\r\n+                    double ak = a[k];\r\n+\r\n+                    if (ak != pivot) {\r\n+                        a[k] = pivot;\r\n+\r\n+                        if (ak < pivot) { \/\/ Move a[k] to the left side\r\n+                            while (a[++lower] < pivot);\r\n+\r\n+                            if (a[lower] > pivot) {\r\n+                                a[--upper] = a[lower];\r\n+                            }\r\n+                            a[lower] = ak;\r\n+                        } else { \/\/ ak > pivot - Move a[k] to the right side\r\n+                            a[--upper] = ak;\r\n+                        }\r\n+                    }\r\n+                }\r\n+\r\n+                \/*\r\n+                 * Swap the pivot into its final position.\r\n+                 *\/\r\n+                a[low] = a[lower]; a[lower] = pivot;\r\n+\r\n+                \/*\r\n+                 * Sort the right part (possibly in parallel), excluding\r\n+                 * known pivot. All elements from the central part are\r\n+                 * equal and therefore already sorted.\r\n+                 *\/\r\n+                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\r\n+                    sorter.fork(bits | 1, upper, high);\r\n+                } else {\r\n+                    sort(sorter, a, bits | 1, upper, high);\r\n+                }\r\n+            }\r\n+            high = lower; \/\/ Iterate along the left part\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using mixed insertion sort.\r\n+     *\r\n+     * Mixed insertion sort is combination of pin insertion sort,\r\n+     * simple insertion sort and pair insertion sort.\r\n+     *\r\n+     * In the context of Dual-Pivot Quicksort, the pivot element\r\n+     * from the left part plays the role of sentinel, because it\r\n+     * is less than any elements from the given part. Therefore,\r\n+     * expensive check of the left range can be skipped on each\r\n+     * iteration unless it is the leftmost call.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void mixedInsertionSort(double[] a, int low, int high) {\r\n+\r\n+        \/*\r\n+         * Split part for pin and pair insertion sorts.\r\n+         *\/\r\n+        int end = high - 3 * ((high - low) >> 3 << 1);\r\n+\r\n+        \/*\r\n+         * Invoke simple insertion sort on small part.\r\n+         *\/\r\n+        if (end == high) {\r\n+            for (int i; ++low < high; ) {\r\n+                double ai = a[i = low];\r\n+\r\n+                while (ai < a[i - 1]) {\r\n+                    a[i] = a[--i];\r\n+                }\r\n+                a[i] = ai;\r\n+            }\r\n+            return;\r\n+        }\r\n+\r\n+        \/*\r\n+         * Start with pin insertion sort.\r\n+         *\/\r\n+        for (int i, p = high; ++low < end; ) {\r\n+            double ai = a[i = low], pin = a[--p];\r\n+\r\n+            \/*\r\n+             * Swap larger element with pin.\r\n+             *\/\r\n+            if (ai > pin) {\r\n+                ai = pin;\r\n+                a[p] = a[i];\r\n+            }\r\n+\r\n+            \/*\r\n+             * Insert element into sorted part.\r\n+             *\/\r\n+            while (ai < a[i - 1]) {\r\n+                a[i] = a[--i];\r\n+            }\r\n+            a[i] = ai;\r\n+        }\r\n+\r\n+        \/*\r\n+         * Finish with pair insertion sort.\r\n+         *\/\r\n+        for (int i; low < high; ++low) {\r\n+            double a1 = a[i = low], a2 = a[++low];\r\n+\r\n+            \/*\r\n+             * Insert two elements per iteration: at first, insert the\r\n+             * larger element and then insert the smaller element, but\r\n+             * from the position where the larger element was inserted.\r\n+             *\/\r\n+            if (a1 > a2) {\r\n+\r\n+                while (a1 < a[--i]) {\r\n+                    a[i + 2] = a[i];\r\n+                }\r\n+                a[++i + 1] = a1;\r\n+\r\n+                while (a2 < a[--i]) {\r\n+                    a[i + 1] = a[i];\r\n+                }\r\n+                a[i + 1] = a2;\r\n+\r\n+            } else if (a1 < a[i - 1]) {\r\n+\r\n+                while (a2 < a[--i]) {\r\n+                    a[i + 2] = a[i];\r\n+                }\r\n+                a[++i + 1] = a2;\r\n+\r\n+                while (a1 < a[--i]) {\r\n+                    a[i + 1] = a[i];\r\n+                }\r\n+                a[i + 1] = a1;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using insertion sort.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void insertionSort(double[] a, int low, int high) {\r\n+        for (int i, k = low; ++k < high; ) {\r\n+            double ai = a[i = k];\r\n+\r\n+            if (ai < a[i - 1]) {\r\n+                do {\r\n+                    a[i] = a[--i];\r\n+                } while (i > low && ai < a[i - 1]);\r\n+\r\n+                a[i ] = ai;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Tries to sort the specified range of the array using merging sort.\r\n+     *\r\n+     * @param sorter parallel context\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\r\n+     *\/\r\n+    static boolean tryMergingSort(Sorter<double[]> sorter, double[] a, int low, int high) {\r\n+\r\n+        \/*\r\n+         * The element run[i] holds the start index\r\n+         * of i-th sequence in non-descending order.\r\n+         *\/\r\n+        int count = 1;\r\n+        int[] run = null;\r\n+\r\n+        \/*\r\n+         * Identify all possible runs.\r\n+         *\/\r\n+        for (int k = low + 1, last = low; k < high; ) {\r\n+\r\n+            \/*\r\n+             * Find the next run.\r\n+             *\/\r\n+            if (a[k - 1] < a[k]) {\r\n+\r\n+                \/\/ Identify ascending sequence\r\n+                while (++k < high && a[k - 1] <= a[k]);\r\n+\r\n+            } else if (a[k - 1] > a[k]) {\r\n+\r\n+                \/\/ Identify descending sequence\r\n+                while (++k < high && a[k - 1] >= a[k]);\r\n+\r\n+                \/\/ Reverse into ascending order\r\n+                for (int i = last - 1, j = k; ++i < --j && a[i] > a[j]; ) {\r\n+                    double ai = a[i]; a[i] = a[j]; a[j] = ai;\r\n+                }\r\n+            } else { \/\/ Identify constant sequence\r\n+                for (double ak = a[k]; ++k < high && ak == a[k]; );\r\n+\r\n+                if (k < high) {\r\n+                    continue;\r\n+                }\r\n+            }\r\n+\r\n+            \/*\r\n+             * Check if the runs are too\r\n+             * long to continue scanning.\r\n+             *\/\r\n+            if (count > 6 && k - low < count * MIN_RUN_SIZE) {\r\n+                return false;\r\n+            }\r\n+\r\n+            \/*\r\n+             * Process the run.\r\n+             *\/\r\n+            if (run == null) {\r\n+\r\n+                if (k == high) {\r\n+                    \/*\r\n+                     * Array is monotonous sequence\r\n+                     * and therefore already sorted.\r\n+                     *\/\r\n+                    return true;\r\n+                }\r\n+\r\n+                run = new int[((high - low) >> 9) & 0x1FF | 0x3F];\r\n+                run[0] = low;\r\n+\r\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\r\n+\r\n+                if (++count == run.length) {\r\n+                    \/*\r\n+                     * Array is not highly structured.\r\n+                     *\/\r\n+                    return false;\r\n+                }\r\n+            }\r\n+\r\n+            \/*\r\n+             * Save the current run.\r\n+             *\/\r\n+            run[count] = (last = k);\r\n+\r\n+            \/*\r\n+             * Check single-element run at the end.\r\n+             *\/\r\n+            if (++k == high) {\r\n+                --k;\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Merge all runs.\r\n+         *\/\r\n+        if (count > 1) {\r\n+            double[] b; int offset = low;\r\n+\r\n+            if (sorter != null && (b = sorter.b) != null) {\r\n+                offset = sorter.offset;\r\n+            } else if ((b = tryAllocate(double[].class, high - low)) == null) {\r\n+                return false;\r\n+            }\r\n+            mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);\r\n+        }\r\n+        return true;\r\n+    }\r\n+\r\n+    \/**\r\n+     * Merges the specified runs.\r\n+     *\r\n+     * @param a the source array\r\n+     * @param b the temporary buffer used in merging\r\n+     * @param offset the start index in the source, inclusive\r\n+     * @param aim specifies merging: to source ( > 0), buffer ( < 0) or any ( == 0)\r\n+     * @param parallel indicates whether merging is performed in parallel\r\n+     * @param run the start indexes of the runs, inclusive\r\n+     * @param lo the start index of the first run, inclusive\r\n+     * @param hi the start index of the last run, inclusive\r\n+     * @return the destination where runs are merged\r\n+     *\/\r\n+    private static double[] mergeRuns(double[] a, double[] b, int offset,\r\n+            int aim, boolean parallel, int[] run, int lo, int hi) {\r\n+\r\n+        if (hi - lo == 1) {\r\n+            if (aim >= 0) {\r\n+                return a;\r\n+            }\r\n+            System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\r\n+            return b;\r\n+        }\r\n+\r\n+        \/*\r\n+         * Split into approximately equal parts.\r\n+         *\/\r\n+        int mi = lo, rmi = (run[lo] + run[hi]) >>> 1;\r\n+        while (run[++mi + 1] <= rmi);\r\n+\r\n+        \/*\r\n+         * Merge runs of each part.\r\n+         *\/\r\n+        double[] a1 = mergeRuns(a, b, offset, -aim, parallel, run, lo, mi);\r\n+        double[] a2 = mergeRuns(a, b, offset,    0, parallel, run, mi, hi);\r\n+        double[] dst = a1 == a ? b : a;\r\n+\r\n+        int k   = a1 == a ? run[lo] - offset : run[lo];\r\n+        int lo1 = a1 == b ? run[lo] - offset : run[lo];\r\n+        int hi1 = a1 == b ? run[mi] - offset : run[mi];\r\n+        int lo2 = a2 == b ? run[mi] - offset : run[mi];\r\n+        int hi2 = a2 == b ? run[hi] - offset : run[hi];\r\n+\r\n+        \/*\r\n+         * Merge the left and right parts.\r\n+         *\/\r\n+        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && parallel) {\r\n+            new Merger<>(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\r\n+        } else {\r\n+            mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);\r\n+        }\r\n+        return dst;\r\n+    }\r\n+\r\n+    \/**\r\n+     * Merges the sorted parts.\r\n+     *\r\n+     * @param merger parallel context\r\n+     * @param dst the destination where parts are merged\r\n+     * @param k the start index of the destination, inclusive\r\n+     * @param a1 the first part\r\n+     * @param lo1 the start index of the first part, inclusive\r\n+     * @param hi1 the end index of the first part, exclusive\r\n+     * @param a2 the second part\r\n+     * @param lo2 the start index of the second part, inclusive\r\n+     * @param hi2 the end index of the second part, exclusive\r\n+     *\/\r\n+    private static void mergeParts(Merger<double[]> merger, double[] dst, int k,\r\n+            double[] a1, int lo1, int hi1, double[] a2, int lo2, int hi2) {\r\n+\r\n+        if (merger != null && a1 == a2) {\r\n+\r\n+            while (true) {\r\n+\r\n+                \/*\r\n+                 * The first part must be larger.\r\n+                 *\/\r\n+                if (hi1 - lo1 < hi2 - lo2) {\r\n+                    int lo = lo1; lo1 = lo2; lo2 = lo;\r\n+                    int hi = hi1; hi1 = hi2; hi2 = hi;\r\n+                }\r\n+\r\n+                \/*\r\n+                 * Small parts will be merged sequentially.\r\n+                 *\/\r\n+                if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\r\n+                    break;\r\n+                }\r\n+\r\n+                \/*\r\n+                 * Find the median of the larger part.\r\n+                 *\/\r\n+                int mi1 = (lo1 + hi1) >>> 1;\r\n+                double key = a1[mi1];\r\n+                int mi2 = hi2;\r\n+\r\n+                \/*\r\n+                 * Divide the smaller part.\r\n+                 *\/\r\n+                for (int loo = lo2; loo < mi2; ) {\r\n+                    int t = (loo + mi2) >>> 1;\r\n+\r\n+                    if (key > a2[t]) {\r\n+                        loo = t + 1;\r\n+                    } else {\r\n+                        mi2 = t;\r\n+                    }\r\n+                }\r\n+\r\n+                \/*\r\n+                 * Reserve space for the left part.\r\n+                 *\/\r\n+                int d = mi2 - lo2 + mi1 - lo1;\r\n+\r\n+                \/*\r\n+                 * Merge the right part in parallel.\r\n+                 *\/\r\n+                merger.fork(k + d, mi1, hi1, mi2, hi2);\r\n+\r\n+                \/*\r\n+                 * Iterate along the left part.\r\n+                 *\/\r\n+                hi1 = mi1;\r\n+                hi2 = mi2;\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Merge small parts sequentially.\r\n+         *\/\r\n+        while (lo1 < hi1 && lo2 < hi2) {\r\n+            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\r\n+        }\r\n+        if (dst != a1 || k < lo1) {\r\n+            while (lo1 < hi1) {\r\n+                dst[k++] = a1[lo1++];\r\n+            }\r\n+        }\r\n+        if (dst != a2 || k < lo2) {\r\n+            while (lo2 < hi2) {\r\n+                dst[k++] = a2[lo2++];\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Tries to sort the specified range of the array\r\n+     * using LSD (The Least Significant Digit) Radix sort.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\r\n+     *\/\r\n+    static boolean tryRadixSort(Sorter<double[]> sorter, double[] a, int low, int high) {\r\n+        double[] b; int offset = low, size = high - low;\r\n+\r\n+        \/*\r\n+         * Allocate additional buffer.\r\n+         *\/\r\n+        if (sorter != null && (b = sorter.b) != null) {\r\n+            offset = sorter.offset;\r\n+        } else if ((b = tryAllocate(double[].class, size)) == null) {\r\n+            return false;\r\n+        }\r\n+\r\n+        int start = low - offset;\r\n+        int last = high - offset;\r\n+\r\n+        \/*\r\n+         * Count the number of all digits.\r\n+         *\/\r\n+        int[] count1 = new int[1024];\r\n+        int[] count2 = new int[2048];\r\n+        int[] count3 = new int[2048];\r\n+        int[] count4 = new int[2048];\r\n+        int[] count5 = new int[2048];\r\n+        int[] count6 = new int[1024];\r\n+\r\n+        for (int i = low; i < high; ++i) {\r\n+            ++count1[(int)  (dtl(a[i])         & 0x3FF)];\r\n+            ++count2[(int) ((dtl(a[i]) >>> 10) & 0x7FF)];\r\n+            ++count3[(int) ((dtl(a[i]) >>> 21) & 0x7FF)];\r\n+            ++count4[(int) ((dtl(a[i]) >>> 32) & 0x7FF)];\r\n+            ++count5[(int) ((dtl(a[i]) >>> 43) & 0x7FF)];\r\n+            ++count6[(int) ((dtl(a[i]) >>> 54) & 0x3FF)];\r\n+        }\r\n+\r\n+        \/*\r\n+         * Detect digits to be processed.\r\n+         *\/\r\n+        boolean processDigit1 = processDigit(count1, size, low);\r\n+        boolean processDigit2 = processDigit(count2, size, low);\r\n+        boolean processDigit3 = processDigit(count3, size, low);\r\n+        boolean processDigit4 = processDigit(count4, size, low);\r\n+        boolean processDigit5 = processDigit(count5, size, low);\r\n+        boolean processDigit6 = processDigit(count6, size, low);\r\n+\r\n+        \/*\r\n+         * Process the 1-st digit.\r\n+         *\/\r\n+        if (processDigit1) {\r\n+            for (int i = high; i > low; ) {\r\n+                b[--count1[(int) (dtl(a[--i]) & 0x3FF)] - offset] = a[i];\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Process the 2-nd digit.\r\n+         *\/\r\n+        if (processDigit2) {\r\n+            if (processDigit1) {\r\n+                for (int i = last; i > start; ) {\r\n+                    a[--count2[(int) ((dtl(b[--i]) >>> 10) & 0x7FF)]] = b[i];\r\n+                }\r\n+            } else {\r\n+                for (int i = high; i > low; ) {\r\n+                    b[--count2[(int) ((dtl(a[--i]) >>> 10) & 0x7FF)] - offset] = a[i];\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Process the 3-rd digit.\r\n+         *\/\r\n+        if (processDigit3) {\r\n+            if (processDigit1 ^ processDigit2) {\r\n+                for (int i = last; i > start; ) {\r\n+                    a[--count3[(int) ((dtl(b[--i]) >>> 21) & 0x7FF)]] = b[i];\r\n+                }\r\n+            } else {\r\n+                for (int i = high; i > low; ) {\r\n+                    b[--count3[(int) ((dtl(a[--i]) >>> 21) & 0x7FF)] - offset] = a[i];\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Process the 4-th digit.\r\n+         *\/\r\n+        if (processDigit4) {\r\n+            if (processDigit1 ^ processDigit2 ^ processDigit3) {\r\n+                for (int i = last; i > start; ) {\r\n+                    a[--count4[(int) ((dtl(b[--i]) >>> 32) & 0x7FF)]] = b[i];\r\n+                }\r\n+            } else {\r\n+                for (int i = high; i > low; ) {\r\n+                    b[--count4[(int) ((dtl(a[--i]) >>> 32) & 0x7FF)] - offset] = a[i];\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Process the 5-th digit.\r\n+         *\/\r\n+        if (processDigit5) {\r\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4) {\r\n+                for (int i = last; i > start; ) {\r\n+                    a[--count5[(int) ((dtl(b[--i]) >>> 43) & 0x7FF)]] = b[i];\r\n+                }\r\n+            } else {\r\n+                for (int i = high; i > low; ) {\r\n+                    b[--count5[(int) ((dtl(a[--i]) >>> 43) & 0x7FF)] - offset] = a[i];\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Process the 6-th digit.\r\n+         *\/\r\n+        if (processDigit6) {\r\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5) {\r\n+                for (int i = last; i > start; ) {\r\n+                    a[--count6[(int) ((dtl(b[--i]) >>> 54) & 0x3FF)]] = b[i];\r\n+                }\r\n+            } else {\r\n+                for (int i = high; i > low; ) {\r\n+                    b[--count6[(int) ((dtl(a[--i]) >>> 54) & 0x3FF)] - offset] = a[i];\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        \/*\r\n+         * Copy the buffer to original array, if we process ood number of digits.\r\n+         *\/\r\n+        if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5 ^ processDigit6) {\r\n+            System.arraycopy(b, low - offset, a, low, size);\r\n+        }\r\n+        return true;\r\n+    }\r\n+\r\n+    \/**\r\n+     * Returns masked bits that represent the double value.\r\n+     *\r\n+     * @param d the given value\r\n+     * @return masked bits\r\n+     *\/\r\n+    private static long dtl(double d) {\r\n+        long x = Double.doubleToRawLongBits(d);\r\n+        return x ^ ((x >> 63) | 0x8000000000000000L);\r\n+    }\r\n+\r\n+    \/**\r\n+     * Sorts the specified range of the array using heap sort.\r\n+     *\r\n+     * @param a the array to be sorted\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    static void heapSort(double[] a, int low, int high) {\r\n+        for (int k = (low + high) >>> 1; k > low; ) {\r\n+            pushDown(a, --k, a[k], low, high);\r\n+        }\r\n+        while (--high > low) {\r\n+            double max = a[low];\r\n+            pushDown(a, low, a[high], low, high);\r\n+            a[high] = max;\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Pushes specified element down during heap sort.\r\n+     *\r\n+     * @param a the given array\r\n+     * @param p the start index\r\n+     * @param value the given element\r\n+     * @param low the index of the first element, inclusive, to be sorted\r\n+     * @param high the index of the last element, exclusive, to be sorted\r\n+     *\/\r\n+    private static void pushDown(double[] a, int p, double value, int low, int high) {\r\n+        for (int k ;; a[p] = a[p = k]) {\r\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\r\n+\r\n+            if (k > high) {\r\n+                break;\r\n+            }\r\n+            if (k == high || a[k] < a[k - 1]) {\r\n+                --k;\r\n+            }\r\n+            if (a[k] <= value) {\r\n+                break;\r\n+            }\r\n+        }\r\n+        a[p] = value;\r\n+    }\r\n+\r\n+\/\/ #[class]\r\n+\r\n+    \/**\r\n+     * This class implements parallel sorting.\r\n+     *\/\r\n+    private static final class Sorter<T> extends CountedCompleter<Void> {\r\n+\r\n+        private static final long serialVersionUID = 123456789L;\r\n+\r\n+        @SuppressWarnings(\"serial\")\r\n+        private final T a, b;\r\n+        private final int low, size, offset, depth;\r\n+\r\n+        @SuppressWarnings(\"unchecked\")\r\n+        private Sorter(T a, int parallelism, int low, int size, int depth) {\r\n+            this.a = a;\r\n+            this.low = low;\r\n+            this.size = size;\r\n+            this.offset = low;\r\n+\r\n+            while ((parallelism >>= 2) > 0 && (size >>= 2) > 0) {\r\n+                depth -= 2;\r\n+            }\r\n+            this.b = (T) tryAllocate(a.getClass(), this.size);\r\n+            this.depth = b == null ? 0 : depth;\r\n+        }\r\n+\r\n+        private Sorter(CountedCompleter<?> parent,\r\n+                T a, T b, int low, int size, int offset, int depth) {\r\n+            super(parent);\r\n+            this.a = a;\r\n+            this.b = b;\r\n+            this.low = low;\r\n+            this.size = size;\r\n+            this.offset = offset;\r\n+            this.depth = depth;\r\n+        }\r\n+\r\n+        @Override\r\n+        @SuppressWarnings(\"unchecked\")\r\n+        public void compute() {\r\n+            if (depth < 0) {\r\n+                setPendingCount(2);\r\n+                int half = size >> 1;\r\n+                new Sorter<>(this, b, a, low, half, offset, depth + 1).fork();\r\n+                new Sorter<>(this, b, a, low + half, size - half, offset, depth + 1).compute();\r\n+            } else {\r\n+                if (a instanceof int[]) {\r\n+                    sort((Sorter<int[]>) this, (int[]) a, depth, low, low + size);\r\n+                } else if (a instanceof long[]) {\r\n+                    sort((Sorter<long[]>) this, (long[]) a, depth, low, low + size);\r\n+                } else if (a instanceof float[]) {\r\n+                    sort((Sorter<float[]>) this, (float[]) a, depth, low, low + size);\r\n+                } else if (a instanceof double[]) {\r\n+                    sort((Sorter<double[]>) this, (double[]) a, depth, low, low + size);\r\n+                } else {\r\n+                    throw new IllegalArgumentException(\"Unknown array: \" + a.getClass().getName());\r\n+                }\r\n+            }\r\n+            tryComplete();\r\n+        }\r\n+\r\n+        @Override\r\n+        public void onCompletion(CountedCompleter<?> caller) {\r\n+            if (depth < 0) {\r\n+                int mi = low + (size >> 1);\r\n+                boolean src = (depth & 1) == 0;\r\n+\r\n+                new Merger<>(null,\r\n+                    a,\r\n+                    src ? low : low - offset,\r\n+                    b,\r\n+                    src ? low - offset : low,\r\n+                    src ? mi - offset : mi,\r\n+                    b,\r\n+                    src ? mi - offset : mi,\r\n+                    src ? low + size - offset : low + size\r\n+                ).invoke();\r\n+            }\r\n+        }\r\n+\r\n+        private void fork(int depth, int low, int high) {\r\n+            addToPendingCount(1);\r\n+            new Sorter<>(this, a, b, low, high - low, offset, depth).fork();\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * This class implements parallel merging.\r\n+     *\/\r\n+    private static final class Merger<T> extends CountedCompleter<Void> {\r\n+\r\n+        private static final long serialVersionUID = 123456789L;\r\n+\r\n+        @SuppressWarnings(\"serial\")\r\n+        private final T dst, a1, a2;\r\n+        private final int k, lo1, hi1, lo2, hi2;\r\n+\r\n+        private Merger(CountedCompleter<?> parent, T dst, int k,\r\n+                T a1, int lo1, int hi1, T a2, int lo2, int hi2) {\r\n+            super(parent);\r\n+            this.dst = dst;\r\n+            this.k = k;\r\n+            this.a1 = a1;\r\n+            this.lo1 = lo1;\r\n+            this.hi1 = hi1;\r\n+            this.a2 = a2;\r\n+            this.lo2 = lo2;\r\n+            this.hi2 = hi2;\r\n+        }\r\n+\r\n+        @Override\r\n+        @SuppressWarnings(\"unchecked\")\r\n+        public void compute() {\r\n+            if (dst instanceof int[]) {\r\n+                mergeParts((Merger<int[]>) this, (int[]) dst, k,\r\n+                    (int[]) a1, lo1, hi1, (int[]) a2, lo2, hi2);\r\n+            } else if (dst instanceof long[]) {\r\n+                mergeParts((Merger<long[]>) this, (long[]) dst, k,\r\n+                    (long[]) a1, lo1, hi1, (long[]) a2, lo2, hi2);\r\n+            } else if (dst instanceof float[]) {\r\n+                mergeParts((Merger<float[]>) this, (float[]) dst, k,\r\n+                    (float[]) a1, lo1, hi1, (float[]) a2, lo2, hi2);\r\n+            } else if (dst instanceof double[]) {\r\n+                mergeParts((Merger<double[]>) this, (double[]) dst, k,\r\n+                    (double[]) a1, lo1, hi1, (double[]) a2, lo2, hi2);\r\n+            } else {\r\n+                throw new IllegalArgumentException(\"Unknown array: \" + dst.getClass().getName());\r\n+            }\r\n+            propagateCompletion();\r\n+        }\r\n+\r\n+        private void fork(int k, int lo1, int hi1, int lo2, int hi2) {\r\n+            addToPendingCount(1);\r\n+            new Merger<>(this, dst, k, a1, lo1, hi1, a2, lo2, hi2).fork();\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Tries to allocate additional buffer.\r\n+     *\r\n+     * @param clazz the given array class\r\n+     * @param size the size of additional buffer\r\n+     * @return {@code null} if requested size is too large or there is not enough memory,\r\n+     *         otherwise created buffer\r\n+    *\/\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    private static <T> T tryAllocate(Class<T> clazz, int size) {\r\n+        try {\r\n+            return size > MAX_BUFFER_SIZE ? null :\r\n+                (T) U.allocateUninitializedArray(clazz.componentType(), size);\r\n+        } catch (OutOfMemoryError e) {\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    private static final Unsafe U = Unsafe.getUnsafe();\r\n+}\r\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":4567,"deletions":4164,"binary":false,"changes":8731,"status":"modified"},{"patch":"@@ -1,2016 +1,1798 @@\n-\/*\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @compile\/module=java.base java\/util\/SortingHelper.java\n- * @bug 6880672 6896573 6899694 6976036 7013585 7018258 8003981 8226297\n- * @build Sorting\n- * @run main Sorting -shortrun\n- * @summary Exercise Arrays.sort, Arrays.parallelSort\n- *\n- * @author Vladimir Yaroslavskiy\n- * @author Jon Bentley\n- * @author Josh Bloch\n- *\/\n-\n-import java.io.PrintStream;\n-import java.util.Comparator;\n-import java.util.Random;\n-import java.util.SortingHelper;\n-\n-public class Sorting {\n-\n-    private static final PrintStream out = System.out;\n-    private static final PrintStream err = System.err;\n-\n-    \/\/ Array lengths used in a long run (default)\n-    private static final int[] LONG_RUN_LENGTHS = {\n-        1, 3, 8, 21, 55, 100, 1_000, 10_000, 100_000 };\n-\n-    \/\/ Array lengths used in a short run\n-    private static final int[] SHORT_RUN_LENGTHS = {\n-        1, 8, 55, 100, 10_000 };\n-\n-    \/\/ Random initial values used in a long run (default)\n-    private static final TestRandom[] LONG_RUN_RANDOMS = {\n-        TestRandom.BABA, TestRandom.DEDA, TestRandom.C0FFEE };\n-\n-    \/\/ Random initial values used in a short run\n-    private static final TestRandom[] SHORT_RUN_RANDOMS = {\n-        TestRandom.C0FFEE };\n-\n-    \/\/ Constants used in subarray sorting\n-    private static final int A380 = 0xA380;\n-    private static final int B747 = 0xB747;\n-\n-    private final SortingHelper sortingHelper;\n-    private final TestRandom[] randoms;\n-    private final int[] lengths;\n-    private Object[] gold;\n-    private Object[] test;\n-\n-    public static void main(String[] args) {\n-        long start = System.currentTimeMillis();\n-        boolean shortRun = args.length > 0 && args[0].equals(\"-shortrun\");\n-\n-        int[] lengths = shortRun ? SHORT_RUN_LENGTHS : LONG_RUN_LENGTHS;\n-        TestRandom[] randoms = shortRun ? SHORT_RUN_RANDOMS : LONG_RUN_RANDOMS;\n-\n-        new Sorting(SortingHelper.DUAL_PIVOT_QUICKSORT, randoms, lengths).testCore();\n-        new Sorting(SortingHelper.PARALLEL_SORT, randoms, lengths).testCore();\n-        new Sorting(SortingHelper.HEAP_SORT, randoms, lengths).testBasic();\n-        new Sorting(SortingHelper.ARRAYS_SORT, randoms, lengths).testAll();\n-        new Sorting(SortingHelper.ARRAYS_PARALLEL_SORT, randoms, lengths).testAll();\n-\n-        long end = System.currentTimeMillis();\n-        out.format(\"PASSED in %d sec.\\n\", (end - start) \/ 1000);\n-    }\n-\n-    private Sorting(SortingHelper sortingHelper, TestRandom[] randoms, int[] lengths) {\n-        this.sortingHelper = sortingHelper;\n-        this.randoms = randoms;\n-        this.lengths = lengths;\n-    }\n-\n-    private void testBasic() {\n-        testEmptyArray();\n-\n-        for (int length : lengths) {\n-            createData(length);\n-            testBasic(length);\n-        }\n-    }\n-\n-    private void testBasic(int length) {\n-        for (TestRandom random : randoms) {\n-            testWithInsertionSort(length, random);\n-            testWithCheckSum(length, random);\n-            testWithScrambling(length, random);\n-        }\n-    }\n-\n-    private void testCore() {\n-        for (int length : lengths) {\n-            createData(length);\n-            testCore(length);\n-        }\n-    }\n-\n-    private void testCore(int length) {\n-        testBasic(length);\n-\n-        for (TestRandom random : randoms) {\n-            testMergingSort(length, random);\n-            testSubArray(length, random);\n-            testNegativeZero(length, random);\n-            testFloatingPointSorting(length, random);\n-        }\n-    }\n-\n-    private void testAll() {\n-        for (int length : lengths) {\n-            createData(length);\n-            testAll(length);\n-        }\n-    }\n-\n-    private void testAll(int length) {\n-        testCore(length);\n-\n-        for (TestRandom random : randoms) {\n-            testRange(length, random);\n-            testStability(length, random);\n-        }\n-    }\n-\n-    private void testEmptyArray() {\n-        testEmptyAndNullIntArray();\n-        testEmptyAndNullLongArray();\n-        testEmptyAndNullByteArray();\n-        testEmptyAndNullCharArray();\n-        testEmptyAndNullShortArray();\n-        testEmptyAndNullFloatArray();\n-        testEmptyAndNullDoubleArray();\n-    }\n-\n-    private void testStability(int length, TestRandom random) {\n-        printTestName(\"Test stability\", random, length);\n-\n-        Pair[] a = build(length, random);\n-        sortingHelper.sort(a);\n-        checkSorted(a);\n-        checkStable(a);\n-\n-        a = build(length, random);\n-        sortingHelper.sort(a, pairComparator);\n-        checkSorted(a);\n-        checkStable(a);\n-\n-        out.println();\n-    }\n-\n-    private void testEmptyAndNullIntArray() {\n-        sortingHelper.sort(new int[] {});\n-        sortingHelper.sort(new int[] {}, 0, 0);\n-\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(int[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(int[]) shouldn't catch null array\");\n-    }\n-\n-    private void testEmptyAndNullLongArray() {\n-        sortingHelper.sort(new long[] {});\n-        sortingHelper.sort(new long[] {}, 0, 0);\n-\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(long[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(long[]) shouldn't catch null array\");\n-    }\n-\n-    private void testEmptyAndNullByteArray() {\n-        sortingHelper.sort(new byte[] {});\n-        sortingHelper.sort(new byte[] {}, 0, 0);\n-\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(byte[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(byte[]) shouldn't catch null array\");\n-    }\n-\n-    private void testEmptyAndNullCharArray() {\n-        sortingHelper.sort(new char[] {});\n-        sortingHelper.sort(new char[] {}, 0, 0);\n-\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(char[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(char[]) shouldn't catch null array\");\n-    }\n-\n-    private void testEmptyAndNullShortArray() {\n-        sortingHelper.sort(new short[] {});\n-        sortingHelper.sort(new short[] {}, 0, 0);\n-\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(short[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(short[]) shouldn't catch null array\");\n-    }\n-\n-    private void testEmptyAndNullFloatArray() {\n-        sortingHelper.sort(new float[] {});\n-        sortingHelper.sort(new float[] {}, 0, 0);\n-\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(float[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(float[]) shouldn't catch null array\");\n-    }\n-\n-    private void testEmptyAndNullDoubleArray() {\n-        sortingHelper.sort(new double[] {});\n-        sortingHelper.sort(new double[] {}, 0, 0);\n-\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(double[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(double[]) shouldn't catch null array\");\n-    }\n-\n-    private void testSubArray(int length, TestRandom random) {\n-        if (length < 4) {\n-            return;\n-        }\n-        for (int m = 1; m < length \/ 2; m <<= 1) {\n-            int fromIndex = m;\n-            int toIndex = length - m;\n-\n-            prepareSubArray((int[]) gold[0], fromIndex, toIndex);\n-            convertData(length);\n-\n-            for (int i = 0; i < test.length; i++) {\n-                printTestName(\"Test subarray\", random, length,\n-                    \", m = \" + m + \", \" + getType(i));\n-                sortingHelper.sort(test[i], fromIndex, toIndex);\n-                checkSubArray(test[i], fromIndex, toIndex);\n-            }\n-        }\n-        out.println();\n-    }\n-\n-    private void testRange(int length, TestRandom random) {\n-        if (length < 2) {\n-            return;\n-        }\n-        for (int m = 1; m < length; m <<= 1) {\n-            for (int i = 1; i <= length; i++) {\n-                ((int[]) gold[0]) [i - 1] = i % m + m % i;\n-            }\n-            convertData(length);\n-\n-            for (int i = 0; i < test.length; i++) {\n-                printTestName(\"Test range check\", random, length,\n-                    \", m = \" + m + \", \" + getType(i));\n-                checkRange(test[i], m);\n-            }\n-        }\n-        out.println();\n-    }\n-\n-    private void checkSorted(Pair[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n-            if (a[i].getKey() > a[i + 1].getKey()) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" +\n-                    a[i].getKey() + \" and \" + a[i + 1].getKey());\n-            }\n-        }\n-    }\n-\n-    private void checkStable(Pair[] a) {\n-        for (int i = 0; i < a.length \/ 4; ) {\n-            int key1 = a[i].getKey();\n-            int value1 = a[i++].getValue();\n-            int key2 = a[i].getKey();\n-            int value2 = a[i++].getValue();\n-            int key3 = a[i].getKey();\n-            int value3 = a[i++].getValue();\n-            int key4 = a[i].getKey();\n-            int value4 = a[i++].getValue();\n-\n-            if (!(key1 == key2 && key2 == key3 && key3 == key4)) {\n-                fail(\"Keys are different \" + key1 + \", \" + key2 + \", \" +\n-                    key3 + \", \" + key4 + \" at position \" + i);\n-            }\n-            if (!(value1 < value2 && value2 < value3 && value3 < value4)) {\n-                fail(\"Sorting is not stable at position \" + i +\n-                    \". Second values have been changed: \" + value1 + \", \" +\n-                    value2 + \", \" + value3 + \", \" + value4);\n-            }\n-        }\n-    }\n-\n-    private Pair[] build(int length, Random random) {\n-        Pair[] a = new Pair[length * 4];\n-\n-        for (int i = 0; i < a.length; ) {\n-            int key = random.nextInt();\n-            a[i++] = new Pair(key, 1);\n-            a[i++] = new Pair(key, 2);\n-            a[i++] = new Pair(key, 3);\n-            a[i++] = new Pair(key, 4);\n-        }\n-        return a;\n-    }\n-\n-    private void testWithInsertionSort(int length, TestRandom random) {\n-        if (length > 1000) {\n-            return;\n-        }\n-        for (int m = 1; m <= length; m <<= 1) {\n-            for (UnsortedBuilder builder : UnsortedBuilder.values()) {\n-                builder.build((int[]) gold[0], m, random);\n-                convertData(length);\n-\n-                for (int i = 0; i < test.length; i++) {\n-                    printTestName(\"Test with insertion sort\", random, length,\n-                        \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n-                    sortingHelper.sort(test[i]);\n-                    sortByInsertionSort(gold[i]);\n-                    compare(test[i], gold[i]);\n-                }\n-            }\n-        }\n-        out.println();\n-    }\n-\n-    private void testMergingSort(int length, TestRandom random) {\n-        if (length < (4 << 10)) { \/\/ DualPivotQuicksort.MIN_TRY_MERGE_SIZE\n-            return;\n-        }\n-        final int PERIOD = 50;\n-\n-        for (int m = PERIOD - 2; m <= PERIOD + 2; m++) {\n-            for (MergingBuilder builder : MergingBuilder.values()) {\n-                builder.build((int[]) gold[0], m);\n-                convertData(length);\n-\n-                for (int i = 0; i < test.length; i++) {\n-                    printTestName(\"Test merging sort\", random, length,\n-                        \", m = \" + m + \", \" +  getType(i) + \" \" + builder);\n-                    sortingHelper.sort(test[i]);\n-                    checkSorted(test[i]);\n-                }\n-            }\n-        }\n-        out.println();\n-    }\n-\n-    private void testWithCheckSum(int length, TestRandom random) {\n-        for (int m = 1; m <= length; m <<= 1) {\n-            for (UnsortedBuilder builder : UnsortedBuilder.values()) {\n-                builder.build((int[]) gold[0], m, random);\n-                convertData(length);\n-\n-                for (int i = 0; i < test.length; i++) {\n-                    printTestName(\"Test with check sum\", random, length,\n-                        \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n-                    sortingHelper.sort(test[i]);\n-                    checkWithCheckSum(test[i], gold[i]);\n-                }\n-            }\n-        }\n-        out.println();\n-    }\n-\n-    private void testWithScrambling(int length, TestRandom random) {\n-        for (int m = 1; m <= length; m <<= 1) {\n-            for (SortedBuilder builder : SortedBuilder.values()) {\n-                builder.build((int[]) gold[0], m);\n-                convertData(length);\n-\n-                for (int i = 0; i < test.length; i++) {\n-                    printTestName(\"Test with scrambling\", random, length,\n-                        \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n-                    scramble(test[i], random);\n-                    sortingHelper.sort(test[i]);\n-                    compare(test[i], gold[i]);\n-                }\n-            }\n-        }\n-        out.println();\n-    }\n-\n-    private void testNegativeZero(int length, TestRandom random) {\n-        for (int i = 5; i < test.length; i++) {\n-            printTestName(\"Test negative zero -0.0\", random, length, \" \" + getType(i));\n-\n-            NegativeZeroBuilder builder = NegativeZeroBuilder.values() [i - 5];\n-            builder.build(test[i], random);\n-\n-            sortingHelper.sort(test[i]);\n-            checkNegativeZero(test[i]);\n-        }\n-        out.println();\n-    }\n-\n-    private void testFloatingPointSorting(int length, TestRandom random) {\n-        if (length < 2) {\n-            return;\n-        }\n-        final int MAX = 13;\n-\n-        for (int a = 0; a < MAX; a++) {\n-            for (int g = 0; g < MAX; g++) {\n-                for (int z = 0; z < MAX; z++) {\n-                    for (int n = 0; n < MAX; n++) {\n-                        for (int p = 0; p < MAX; p++) {\n-                            if (a + g + z + n + p != length) {\n-                                continue;\n-                            }\n-                            for (int i = 5; i < test.length; i++) {\n-                                printTestName(\"Test float-pointing sorting\", random, length,\n-                                    \", a = \" + a + \", g = \" + g + \", z = \" + z +\n-                                    \", n = \" + n + \", p = \" + p + \", \" + getType(i));\n-                                FloatingPointBuilder builder = FloatingPointBuilder.values()[i - 5];\n-                                builder.build(gold[i], a, g, z, n, p, random);\n-                                copy(test[i], gold[i]);\n-                                scramble(test[i], random);\n-                                sortingHelper.sort(test[i]);\n-                                compare(test[i], gold[i], a, n, g);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        for (int m = 13; m > 4; m--) {\n-            int t = length \/ m;\n-            int g = t, z = t, n = t, p = t;\n-            int a = length - g - z - n - p;\n-\n-            for (int i = 5; i < test.length; i++) {\n-                printTestName(\"Test float-pointing sorting\", random, length,\n-                    \", a = \" + a + \", g = \" + g + \", z = \" + z +\n-                    \", n = \" + n + \", p = \" + p + \", \" + getType(i));\n-                FloatingPointBuilder builder = FloatingPointBuilder.values() [i - 5];\n-                builder.build(gold[i], a, g, z, n, p, random);\n-                copy(test[i], gold[i]);\n-                scramble(test[i], random);\n-                sortingHelper.sort(test[i]);\n-                compare(test[i], gold[i], a, n, g);\n-            }\n-        }\n-        out.println();\n-    }\n-\n-    private void prepareSubArray(int[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            a[i] = A380;\n-        }\n-        int middle = (fromIndex + toIndex) >>> 1;\n-        int k = 0;\n-\n-        for (int i = fromIndex; i < middle; i++) {\n-            a[i] = k++;\n-        }\n-\n-        for (int i = middle; i < toIndex; i++) {\n-            a[i] = k--;\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            a[i] = B747;\n-        }\n-    }\n-\n-    private void scramble(Object a, Random random) {\n-        if (a instanceof int[]) {\n-            scramble((int[]) a, random);\n-        } else if (a instanceof long[]) {\n-            scramble((long[]) a, random);\n-        } else if (a instanceof byte[]) {\n-            scramble((byte[]) a, random);\n-        } else if (a instanceof char[]) {\n-            scramble((char[]) a, random);\n-        } else if (a instanceof short[]) {\n-            scramble((short[]) a, random);\n-        } else if (a instanceof float[]) {\n-            scramble((float[]) a, random);\n-        } else if (a instanceof double[]) {\n-            scramble((double[]) a, random);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n-        }\n-    }\n-\n-    private void scramble(int[] a, Random random) {\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n-        }\n-    }\n-\n-    private void scramble(long[] a, Random random) {\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n-        }\n-    }\n-\n-    private void scramble(byte[] a, Random random) {\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n-        }\n-    }\n-\n-    private void scramble(char[] a, Random random) {\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n-        }\n-    }\n-\n-    private void scramble(short[] a, Random random) {\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n-        }\n-    }\n-\n-    private void scramble(float[] a, Random random) {\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n-        }\n-    }\n-\n-    private void scramble(double[] a, Random random) {\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n-        }\n-    }\n-\n-    private void swap(int[] a, int i, int j) {\n-        int t = a[i]; a[i] = a[j]; a[j] = t;\n-    }\n-\n-    private void swap(long[] a, int i, int j) {\n-        long t = a[i]; a[i] = a[j]; a[j] = t;\n-    }\n-\n-    private void swap(byte[] a, int i, int j) {\n-        byte t = a[i]; a[i] = a[j]; a[j] = t;\n-    }\n-\n-    private void swap(char[] a, int i, int j) {\n-        char t = a[i]; a[i] = a[j]; a[j] = t;\n-    }\n-\n-    private void swap(short[] a, int i, int j) {\n-        short t = a[i]; a[i] = a[j]; a[j] = t;\n-    }\n-\n-    private void swap(float[] a, int i, int j) {\n-        float t = a[i]; a[i] = a[j]; a[j] = t;\n-    }\n-\n-    private void swap(double[] a, int i, int j) {\n-        double t = a[i]; a[i] = a[j]; a[j] = t;\n-    }\n-\n-    private void checkWithCheckSum(Object test, Object gold) {\n-        checkSorted(test);\n-        checkCheckSum(test, gold);\n-    }\n-\n-    private void fail(String message) {\n-        err.format(\"\\n*** TEST FAILED ***\\n\\n%s\\n\\n\", message);\n-        throw new RuntimeException(\"Test failed\");\n-    }\n-\n-    private void checkNegativeZero(Object a) {\n-        if (a instanceof float[]) {\n-            checkNegativeZero((float[]) a);\n-        } else if (a instanceof double[]) {\n-            checkNegativeZero((double[]) a);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n-        }\n-    }\n-\n-    private void checkNegativeZero(float[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n-            if (Float.floatToRawIntBits(a[i]) == 0 && Float.floatToRawIntBits(a[i + 1]) < 0) {\n-                fail(a[i] + \" before \" + a[i + 1] + \" at position \" + i);\n-            }\n-        }\n-    }\n-\n-    private void checkNegativeZero(double[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n-            if (Double.doubleToRawLongBits(a[i]) == 0 && Double.doubleToRawLongBits(a[i + 1]) < 0) {\n-                fail(a[i] + \" before \" + a[i + 1] + \" at position \" + i);\n-            }\n-        }\n-    }\n-\n-    private void compare(Object a, Object b, int numNaN, int numNeg, int numNegZero) {\n-        if (a instanceof float[]) {\n-            compare((float[]) a, (float[]) b, numNaN, numNeg, numNegZero);\n-        } else if (a instanceof double[]) {\n-            compare((double[]) a, (double[]) b, numNaN, numNeg, numNegZero);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n-        }\n-    }\n-\n-    private void compare(float[] a, float[] b, int numNaN, int numNeg, int numNegZero) {\n-        for (int i = a.length - numNaN; i < a.length; i++) {\n-            if (a[i] == a[i]) {\n-                fail(\"There must be NaN instead of \" + a[i] + \" at position \" + i);\n-            }\n-        }\n-        final int NEGATIVE_ZERO = Float.floatToIntBits(-0.0f);\n-\n-        for (int i = numNeg; i < numNeg + numNegZero; i++) {\n-            if (NEGATIVE_ZERO != Float.floatToIntBits(a[i])) {\n-                fail(\"There must be -0.0 instead of \" + a[i] + \" at position \" + i);\n-            }\n-        }\n-\n-        for (int i = 0; i < a.length - numNaN; i++) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n-            }\n-        }\n-    }\n-\n-    private void compare(double[] a, double[] b, int numNaN, int numNeg, int numNegZero) {\n-        for (int i = a.length - numNaN; i < a.length; i++) {\n-            if (a[i] == a[i]) {\n-                fail(\"There must be NaN instead of \" + a[i] + \" at position \" + i);\n-            }\n-        }\n-        final long NEGATIVE_ZERO = Double.doubleToLongBits(-0.0d);\n-\n-        for (int i = numNeg; i < numNeg + numNegZero; i++) {\n-            if (NEGATIVE_ZERO != Double.doubleToLongBits(a[i])) {\n-                fail(\"There must be -0.0 instead of \" + a[i] + \" at position \" + i);\n-            }\n-        }\n-\n-        for (int i = 0; i < a.length - numNaN; i++) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n-            }\n-        }\n-    }\n-\n-    private void compare(Object a, Object b) {\n-        if (a instanceof int[]) {\n-            compare((int[]) a, (int[]) b);\n-        } else if (a instanceof long[]) {\n-            compare((long[]) a, (long[]) b);\n-        } else if (a instanceof byte[]) {\n-            compare((byte[]) a, (byte[]) b);\n-        } else if (a instanceof char[]) {\n-            compare((char[]) a, (char[]) b);\n-        } else if (a instanceof short[]) {\n-            compare((short[]) a, (short[]) b);\n-        } else if (a instanceof float[]) {\n-            compare((float[]) a, (float[]) b);\n-        } else if (a instanceof double[]) {\n-            compare((double[]) a, (double[]) b);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n-        }\n-    }\n-\n-    private void compare(int[] a, int[] b) {\n-        for (int i = 0; i < a.length; i++) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n-            }\n-        }\n-    }\n-\n-    private void compare(long[] a, long[] b) {\n-        for (int i = 0; i < a.length; i++) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n-            }\n-        }\n-    }\n-\n-    private void compare(byte[] a, byte[] b) {\n-        for (int i = 0; i < a.length; i++) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n-            }\n-        }\n-    }\n-\n-    private void compare(char[] a, char[] b) {\n-        for (int i = 0; i < a.length; i++) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n-            }\n-        }\n-    }\n-\n-    private void compare(short[] a, short[] b) {\n-        for (int i = 0; i < a.length; i++) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n-            }\n-        }\n-    }\n-\n-    private void compare(float[] a, float[] b) {\n-        for (int i = 0; i < a.length; i++) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n-            }\n-        }\n-    }\n-\n-    private void compare(double[] a, double[] b) {\n-        for (int i = 0; i < a.length; i++) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n-            }\n-        }\n-    }\n-\n-    private String getType(int i) {\n-        Object a = test[i];\n-\n-        if (a instanceof int[]) {\n-            return \"INT   \";\n-        }\n-        if (a instanceof long[]) {\n-            return \"LONG  \";\n-        }\n-        if (a instanceof byte[]) {\n-            return \"BYTE  \";\n-        }\n-        if (a instanceof char[]) {\n-            return \"CHAR  \";\n-        }\n-        if (a instanceof short[]) {\n-            return \"SHORT \";\n-        }\n-        if (a instanceof float[]) {\n-            return \"FLOAT \";\n-        }\n-        if (a instanceof double[]) {\n-            return \"DOUBLE\";\n-        }\n-        fail(\"Unknown type of array: \" + a.getClass().getName());\n-        return null;\n-    }\n-\n-    private void checkSorted(Object a) {\n-        if (a instanceof int[]) {\n-            checkSorted((int[]) a);\n-        } else if (a instanceof long[]) {\n-            checkSorted((long[]) a);\n-        } else if (a instanceof byte[]) {\n-            checkSorted((byte[]) a);\n-        } else if (a instanceof char[]) {\n-            checkSorted((char[]) a);\n-        } else if (a instanceof short[]) {\n-            checkSorted((short[]) a);\n-        } else if (a instanceof float[]) {\n-            checkSorted((float[]) a);\n-        } else if (a instanceof double[]) {\n-            checkSorted((double[]) a);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n-        }\n-    }\n-\n-    private void checkSorted(int[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-    }\n-\n-    private void checkSorted(long[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-    }\n-\n-    private void checkSorted(byte[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-    }\n-\n-    private void checkSorted(char[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-    }\n-\n-    private void checkSorted(short[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-    }\n-\n-    private void checkSorted(float[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-    }\n-\n-    private void checkSorted(double[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-    }\n-\n-    private void checkCheckSum(Object test, Object gold) {\n-        if (checkSumXor(test) != checkSumXor(gold)) {\n-            fail(\"Original and sorted arrays are not identical [^]\");\n-        }\n-        if (checkSumPlus(test) != checkSumPlus(gold)) {\n-            fail(\"Original and sorted arrays are not identical [+]\");\n-        }\n-    }\n-\n-    private int checkSumXor(Object a) {\n-        if (a instanceof int[]) {\n-            return checkSumXor((int[]) a);\n-        }\n-        if (a instanceof long[]) {\n-            return checkSumXor((long[]) a);\n-        }\n-        if (a instanceof byte[]) {\n-            return checkSumXor((byte[]) a);\n-        }\n-        if (a instanceof char[]) {\n-            return checkSumXor((char[]) a);\n-        }\n-        if (a instanceof short[]) {\n-            return checkSumXor((short[]) a);\n-        }\n-        if (a instanceof float[]) {\n-            return checkSumXor((float[]) a);\n-        }\n-        if (a instanceof double[]) {\n-            return checkSumXor((double[]) a);\n-        }\n-        fail(\"Unknown type of array: \" + a.getClass().getName());\n-        return -1;\n-    }\n-\n-    private int checkSumXor(int[] a) {\n-        int checkSum = 0;\n-\n-        for (int e : a) {\n-            checkSum ^= e;\n-        }\n-        return checkSum;\n-    }\n-\n-    private int checkSumXor(long[] a) {\n-        long checkSum = 0;\n-\n-        for (long e : a) {\n-            checkSum ^= e;\n-        }\n-        return (int) checkSum;\n-    }\n-\n-    private int checkSumXor(byte[] a) {\n-        byte checkSum = 0;\n-\n-        for (byte e : a) {\n-            checkSum ^= e;\n-        }\n-        return (int) checkSum;\n-    }\n-\n-    private int checkSumXor(char[] a) {\n-        char checkSum = 0;\n-\n-        for (char e : a) {\n-            checkSum ^= e;\n-        }\n-        return (int) checkSum;\n-    }\n-\n-    private int checkSumXor(short[] a) {\n-        short checkSum = 0;\n-\n-        for (short e : a) {\n-            checkSum ^= e;\n-        }\n-        return (int) checkSum;\n-    }\n-\n-    private int checkSumXor(float[] a) {\n-        int checkSum = 0;\n-\n-        for (float e : a) {\n-            checkSum ^= (int) e;\n-        }\n-        return checkSum;\n-    }\n-\n-    private int checkSumXor(double[] a) {\n-        int checkSum = 0;\n-\n-        for (double e : a) {\n-            checkSum ^= (int) e;\n-        }\n-        return checkSum;\n-    }\n-\n-    private int checkSumPlus(Object a) {\n-        if (a instanceof int[]) {\n-            return checkSumPlus((int[]) a);\n-        }\n-        if (a instanceof long[]) {\n-            return checkSumPlus((long[]) a);\n-        }\n-        if (a instanceof byte[]) {\n-            return checkSumPlus((byte[]) a);\n-        }\n-        if (a instanceof char[]) {\n-            return checkSumPlus((char[]) a);\n-        }\n-        if (a instanceof short[]) {\n-            return checkSumPlus((short[]) a);\n-        }\n-        if (a instanceof float[]) {\n-            return checkSumPlus((float[]) a);\n-        }\n-        if (a instanceof double[]) {\n-            return checkSumPlus((double[]) a);\n-        }\n-        fail(\"Unknown type of array: \" + a.getClass().getName());\n-        return -1;\n-    }\n-\n-    private int checkSumPlus(int[] a) {\n-        int checkSum = 0;\n-\n-        for (int e : a) {\n-            checkSum += e;\n-        }\n-        return checkSum;\n-    }\n-\n-    private int checkSumPlus(long[] a) {\n-        long checkSum = 0;\n-\n-        for (long e : a) {\n-            checkSum += e;\n-        }\n-        return (int) checkSum;\n-    }\n-\n-    private int checkSumPlus(byte[] a) {\n-        byte checkSum = 0;\n-\n-        for (byte e : a) {\n-            checkSum += e;\n-        }\n-        return (int) checkSum;\n-    }\n-\n-    private int checkSumPlus(char[] a) {\n-        char checkSum = 0;\n-\n-        for (char e : a) {\n-            checkSum += e;\n-        }\n-        return (int) checkSum;\n-    }\n-\n-    private int checkSumPlus(short[] a) {\n-        short checkSum = 0;\n-\n-        for (short e : a) {\n-            checkSum += e;\n-        }\n-        return (int) checkSum;\n-    }\n-\n-    private int checkSumPlus(float[] a) {\n-        int checkSum = 0;\n-\n-        for (float e : a) {\n-            checkSum += (int) e;\n-        }\n-        return checkSum;\n-    }\n-\n-    private int checkSumPlus(double[] a) {\n-        int checkSum = 0;\n-\n-        for (double e : a) {\n-            checkSum += (int) e;\n-        }\n-        return checkSum;\n-    }\n-\n-    private void sortByInsertionSort(Object a) {\n-        if (a instanceof int[]) {\n-            sortByInsertionSort((int[]) a);\n-        } else if (a instanceof long[]) {\n-            sortByInsertionSort((long[]) a);\n-        } else if (a instanceof byte[]) {\n-            sortByInsertionSort((byte[]) a);\n-        } else if (a instanceof char[]) {\n-            sortByInsertionSort((char[]) a);\n-        } else if (a instanceof short[]) {\n-            sortByInsertionSort((short[]) a);\n-        } else if (a instanceof float[]) {\n-            sortByInsertionSort((float[]) a);\n-        } else if (a instanceof double[]) {\n-            sortByInsertionSort((double[]) a);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n-        }\n-    }\n-\n-    private void sortByInsertionSort(int[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            int ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(long[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            long ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(byte[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            byte ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(char[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            char ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(short[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            short ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(float[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            float ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(double[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            double ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void checkSubArray(Object a, int fromIndex, int toIndex) {\n-        if (a instanceof int[]) {\n-            checkSubArray((int[]) a, fromIndex, toIndex);\n-        } else if (a instanceof long[]) {\n-            checkSubArray((long[]) a, fromIndex, toIndex);\n-        } else if (a instanceof byte[]) {\n-            checkSubArray((byte[]) a, fromIndex, toIndex);\n-        } else if (a instanceof char[]) {\n-            checkSubArray((char[]) a, fromIndex, toIndex);\n-        } else if (a instanceof short[]) {\n-            checkSubArray((short[]) a, fromIndex, toIndex);\n-        } else if (a instanceof float[]) {\n-            checkSubArray((float[]) a, fromIndex, toIndex);\n-        } else if (a instanceof double[]) {\n-            checkSubArray((double[]) a, fromIndex, toIndex);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n-        }\n-    }\n-\n-    private void checkSubArray(int[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex(a[i], A380));\n-            }\n-        }\n-\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex(a[i], B747));\n-            }\n-        }\n-    }\n-\n-    private void checkSubArray(long[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != (long) A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex(a[i], A380));\n-            }\n-        }\n-\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != (long) B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex(a[i], B747));\n-            }\n-        }\n-    }\n-\n-    private void checkSubArray(byte[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != (byte) A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex(a[i], A380));\n-            }\n-        }\n-\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != (byte) B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex(a[i], B747));\n-            }\n-        }\n-    }\n-\n-    private void checkSubArray(char[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != (char) A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex(a[i], A380));\n-            }\n-        }\n-\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != (char) B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex(a[i], B747));\n-            }\n-        }\n-    }\n-\n-    private void checkSubArray(short[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != (short) A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex(a[i], A380));\n-            }\n-        }\n-\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != (short) B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex(a[i], B747));\n-            }\n-        }\n-    }\n-\n-    private void checkSubArray(float[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != (float) A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex((long) a[i], A380));\n-            }\n-        }\n-\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != (float) B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex((long) a[i], B747));\n-            }\n-        }\n-    }\n-\n-    private void checkSubArray(double[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != (double) A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex((long) a[i], A380));\n-            }\n-        }\n-\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != (double) B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex((long) a[i], B747));\n-            }\n-        }\n-    }\n-\n-    private void checkRange(Object a, int m) {\n-        if (a instanceof int[]) {\n-            checkRange((int[]) a, m);\n-        } else if (a instanceof long[]) {\n-            checkRange((long[]) a, m);\n-        } else if (a instanceof byte[]) {\n-            checkRange((byte[]) a, m);\n-        } else if (a instanceof char[]) {\n-            checkRange((char[]) a, m);\n-        } else if (a instanceof short[]) {\n-            checkRange((short[]) a, m);\n-        } else if (a instanceof float[]) {\n-            checkRange((float[]) a, m);\n-        } else if (a instanceof double[]) {\n-            checkRange((double[]) a, m);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n-        }\n-    }\n-\n-    private void checkRange(int[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n-            try {\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n-                try {\n-                    sortingHelper.sort(a, 0, a.length + m);\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n-            }\n-        }\n-    }\n-\n-    private void checkRange(long[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n-            try {\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n-                try {\n-                    sortingHelper.sort(a, 0, a.length + m);\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n-            }\n-        }\n-    }\n-\n-    private void checkRange(byte[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n-            try {\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n-                try {\n-                    sortingHelper.sort(a, 0, a.length + m);\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n-            }\n-        }\n-    }\n-\n-    private void checkRange(char[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n-            try {\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n-                try {\n-                    sortingHelper.sort(a, 0, a.length + m);\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n-            }\n-        }\n-    }\n-\n-    private void checkRange(short[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n-            try {\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n-                try {\n-                    sortingHelper.sort(a, 0, a.length + m);\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n-            }\n-        }\n-    }\n-\n-    private void checkRange(float[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n-            try {\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n-                try {\n-                    sortingHelper.sort(a, 0, a.length + m);\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n-            }\n-        }\n-    }\n-\n-    private void checkRange(double[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n-            try {\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n-                try {\n-                    sortingHelper.sort(a, 0, a.length + m);\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n-            }\n-        }\n-    }\n-\n-    private void copy(Object dst, Object src) {\n-        if (src instanceof float[]) {\n-            copy((float[]) dst, (float[]) src);\n-        } else if (src instanceof double[]) {\n-            copy((double[]) dst, (double[]) src);\n-        } else {\n-            fail(\"Unknown type of array: \" + src.getClass().getName());\n-        }\n-    }\n-\n-    private void copy(float[] dst, float[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n-    }\n-\n-    private void copy(double[] dst, double[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n-    }\n-\n-    private void printTestName(String test, TestRandom random, int length) {\n-        printTestName(test, random, length, \"\");\n-    }\n-\n-    private void createData(int length) {\n-        gold = new Object[] {\n-            new int[length], new long[length],\n-            new byte[length], new char[length], new short[length],\n-            new float[length], new double[length]\n-        };\n-\n-        test = new Object[] {\n-            new int[length], new long[length],\n-            new byte[length], new char[length], new short[length],\n-            new float[length], new double[length]\n-        };\n-    }\n-\n-    private void convertData(int length) {\n-        for (int i = 1; i < gold.length; i++) {\n-            TypeConverter converter = TypeConverter.values()[i - 1];\n-            converter.convert((int[])gold[0], gold[i]);\n-        }\n-\n-        for (int i = 0; i < gold.length; i++) {\n-            System.arraycopy(gold[i], 0, test[i], 0, length);\n-        }\n-    }\n-\n-    private String hex(long a, int b) {\n-        return \": \" + Long.toHexString(a) + \", must be \" + Integer.toHexString(b);\n-    }\n-\n-    private void printTestName(String test, TestRandom random, int length, String message) {\n-        out.println( \"[\" + sortingHelper + \"] '\" + test +\n-            \"' length = \" + length + \", random = \" + random + message);\n-    }\n-\n-    private static enum TypeConverter {\n-        LONG {\n-            void convert(int[] src, Object dst) {\n-                long[] b = (long[]) dst;\n-\n-                for (int i = 0; i < src.length; i++) {\n-                    b[i] = (long) src[i];\n-                }\n-            }\n-        },\n-\n-        BYTE {\n-            void convert(int[] src, Object dst) {\n-                byte[] b = (byte[]) dst;\n-\n-                for (int i = 0; i < src.length; i++) {\n-                    b[i] = (byte) src[i];\n-                }\n-            }\n-        },\n-\n-        CHAR {\n-            void convert(int[] src, Object dst) {\n-                char[] b = (char[]) dst;\n-\n-                for (int i = 0; i < src.length; i++) {\n-                    b[i] = (char) src[i];\n-                }\n-            }\n-        },\n-\n-        SHORT {\n-            void convert(int[] src, Object dst) {\n-                short[] b = (short[]) dst;\n-\n-                for (int i = 0; i < src.length; i++) {\n-                    b[i] = (short) src[i];\n-                }\n-            }\n-        },\n-\n-        FLOAT {\n-            void convert(int[] src, Object dst) {\n-                float[] b = (float[]) dst;\n-\n-                for (int i = 0; i < src.length; i++) {\n-                    b[i] = (float) src[i];\n-                }\n-            }\n-        },\n-\n-        DOUBLE {\n-            void convert(int[] src, Object dst) {\n-                double[] b = (double[]) dst;\n-\n-                for (int i = 0; i < src.length; i++) {\n-                    b[i] = (double) src[i];\n-                }\n-            }\n-        };\n-\n-        abstract void convert(int[] src, Object dst);\n-    }\n-\n-    private static enum SortedBuilder {\n-        STEPS {\n-            void build(int[] a, int m) {\n-                for (int i = 0; i < m; i++) {\n-                    a[i] = 0;\n-                }\n-\n-                for (int i = m; i < a.length; i++) {\n-                    a[i] = 1;\n-                }\n-            }\n-        };\n-\n-        abstract void build(int[] a, int m);\n-    }\n-\n-    private static enum UnsortedBuilder {\n-        RANDOM {\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = random.nextInt();\n-                }\n-            }\n-        },\n-\n-        ASCENDING {\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = m + i;\n-                }\n-            }\n-        },\n-\n-        DESCENDING {\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = a.length - m - i;\n-                }\n-            }\n-        },\n-\n-        EQUAL {\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = m;\n-                }\n-            }\n-        },\n-\n-        SAW {\n-            void build(int[] a, int m, Random random) {\n-                int incCount = 1;\n-                int decCount = a.length;\n-                int i = 0;\n-                int period = m--;\n-\n-                while (true) {\n-                    for (int k = 1; k <= period; k++) {\n-                        if (i >= a.length) {\n-                            return;\n-                        }\n-                        a[i++] = incCount++;\n-                    }\n-                    period += m;\n-\n-                    for (int k = 1; k <= period; k++) {\n-                        if (i >= a.length) {\n-                            return;\n-                        }\n-                        a[i++] = decCount--;\n-                    }\n-                    period += m;\n-                }\n-            }\n-        },\n-\n-        REPEATED {\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = i % m;\n-                }\n-            }\n-        },\n-\n-        DUPLICATED {\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = random.nextInt(m);\n-                }\n-            }\n-        },\n-\n-        ORGAN_PIPES {\n-            void build(int[] a, int m, Random random) {\n-                int middle = a.length \/ (m + 1);\n-\n-                for (int i = 0; i < middle; i++) {\n-                    a[i] = i;\n-                }\n-\n-                for (int i = middle; i < a.length; i++) {\n-                    a[i] = a.length - i - 1;\n-                }\n-            }\n-        },\n-\n-        STAGGER {\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = (i * m + i) % a.length;\n-                }\n-            }\n-        },\n-\n-        PLATEAU {\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = Math.min(i, m);\n-                }\n-            }\n-        },\n-\n-        SHUFFLE {\n-            void build(int[] a, int m, Random random) {\n-                int x = 0, y = 0;\n-\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = random.nextBoolean() ? (x += 2) : (y += 2);\n-                }\n-            }\n-        },\n-\n-        LATCH {\n-            void build(int[] a, int m, Random random) {\n-                int max = a.length \/ m;\n-                max = max < 2 ? 2 : max;\n-\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = i % max;\n-                }\n-            }\n-        };\n-\n-        abstract void build(int[] a, int m, Random random);\n-    }\n-\n-    private static enum MergingBuilder {\n-        ASCENDING {\n-            void build(int[] a, int m) {\n-                int period = a.length \/ m;\n-                int v = 1, i = 0;\n-\n-                for (int k = 0; k < m; k++) {\n-                    v = 1;\n-\n-                    for (int p = 0; p < period; p++) {\n-                        a[i++] = v++;\n-                    }\n-                }\n-\n-                for (int j = i; j < a.length - 1; j++) {\n-                    a[j] = v++;\n-                }\n-\n-                a[a.length - 1] = 0;\n-            }\n-        },\n-\n-        DESCENDING {\n-            void build(int[] a, int m) {\n-                int period = a.length \/ m;\n-                int v = -1, i = 0;\n-\n-                for (int k = 0; k < m; k++) {\n-                    v = -1;\n-\n-                    for (int p = 0; p < period; p++) {\n-                        a[i++] = v--;\n-                    }\n-                }\n-\n-                for (int j = i; j < a.length - 1; j++) {\n-                    a[j] = v--;\n-                }\n-\n-                a[a.length - 1] = 0;\n-            }\n-        },\n-\n-        POINT {\n-            void build(int[] a, int m) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = 0;\n-                }\n-                a[a.length \/ 2] = m;\n-            }\n-        },\n-\n-        LINE {\n-            void build(int[] a, int m) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = i;\n-                }\n-                reverse(a, 0, a.length - 1);\n-            }\n-        },\n-\n-        PEARL {\n-            void build(int[] a, int m) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = i;\n-                }\n-                reverse(a, 0, 2);\n-            }\n-        },\n-\n-        RING {\n-            void build(int[] a, int m) {\n-                int k1 = a.length \/ 3;\n-                int k2 = a.length \/ 3 * 2;\n-                int level = a.length \/ 3;\n-\n-                for (int i = 0, k = level; i < k1; i++) {\n-                    a[i] = k--;\n-                }\n-\n-                for (int i = k1; i < k2; i++) {\n-                    a[i] = 0;\n-                }\n-\n-                for (int i = k2, k = level; i < a.length; i++) {\n-                    a[i] = k--;\n-                }\n-            }\n-        };\n-\n-        abstract void build(int[] a, int m);\n-\n-        private static void reverse(int[] a, int lo, int hi) {\n-            for (--hi; lo < hi; ) {\n-                int tmp = a[lo];\n-                a[lo++] = a[hi];\n-                a[hi--] = tmp;\n-            }\n-        }\n-    }\n-\n-    private static enum NegativeZeroBuilder {\n-        FLOAT {\n-            void build(Object o, Random random) {\n-                float[] a = (float[]) o;\n-\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = random.nextBoolean() ? -0.0f : 0.0f;\n-                }\n-            }\n-        },\n-\n-        DOUBLE {\n-            void build(Object o, Random random) {\n-                double[] a = (double[]) o;\n-\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = random.nextBoolean() ? -0.0d : 0.0d;\n-                }\n-            }\n-        };\n-\n-        abstract void build(Object o, Random random);\n-    }\n-\n-    private static enum FloatingPointBuilder {\n-        FLOAT {\n-            void build(Object o, int a, int g, int z, int n, int p, Random random) {\n-                float negativeValue = -random.nextFloat();\n-                float positiveValue =  random.nextFloat();\n-                float[] x = (float[]) o;\n-                int fromIndex = 0;\n-\n-                writeValue(x, negativeValue, fromIndex, n);\n-                fromIndex += n;\n-\n-                writeValue(x, -0.0f, fromIndex, g);\n-                fromIndex += g;\n-\n-                writeValue(x, 0.0f, fromIndex, z);\n-                fromIndex += z;\n-\n-                writeValue(x, positiveValue, fromIndex, p);\n-                fromIndex += p;\n-\n-                writeValue(x, Float.NaN, fromIndex, a);\n-            }\n-        },\n-\n-        DOUBLE {\n-            void build(Object o, int a, int g, int z, int n, int p, Random random) {\n-                double negativeValue = -random.nextFloat();\n-                double positiveValue =  random.nextFloat();\n-                double[] x = (double[]) o;\n-                int fromIndex = 0;\n-\n-                writeValue(x, negativeValue, fromIndex, n);\n-                fromIndex += n;\n-\n-                writeValue(x, -0.0d, fromIndex, g);\n-                fromIndex += g;\n-\n-                writeValue(x, 0.0d, fromIndex, z);\n-                fromIndex += z;\n-\n-                writeValue(x, positiveValue, fromIndex, p);\n-                fromIndex += p;\n-\n-                writeValue(x, Double.NaN, fromIndex, a);\n-            }\n-        };\n-\n-        abstract void build(Object o, int a, int g, int z, int n, int p, Random random);\n-\n-        private static void writeValue(float[] a, float value, int fromIndex, int count) {\n-            for (int i = fromIndex; i < fromIndex + count; i++) {\n-                a[i] = value;\n-            }\n-        }\n-\n-        private static void writeValue(double[] a, double value, int fromIndex, int count) {\n-            for (int i = fromIndex; i < fromIndex + count; i++) {\n-                a[i] = value;\n-            }\n-        }\n-    }\n-\n-    private static Comparator<Pair> pairComparator = new Comparator<Pair>() {\n-\n-        @Override\n-        public int compare(Pair p1, Pair p2) {\n-            return p1.compareTo(p2);\n-        }\n-    };\n-\n-    private static class Pair implements Comparable<Pair> {\n-\n-        private Pair(int key, int value) {\n-            this.key = key;\n-            this.value = value;\n-        }\n-\n-        int getKey() {\n-            return key;\n-        }\n-\n-        int getValue() {\n-            return value;\n-        }\n-\n-        @Override\n-        public int compareTo(Pair pair) {\n-            return Integer.compare(key, pair.key);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"(\" + key + \", \" + value + \")\";\n-        }\n-\n-        private int key;\n-        private int value;\n-    }\n-\n-    private static class TestRandom extends Random {\n-\n-        private static final TestRandom BABA = new TestRandom(0xBABA);\n-        private static final TestRandom DEDA = new TestRandom(0xDEDA);\n-        private static final TestRandom C0FFEE = new TestRandom(0xC0FFEE);\n-\n-        private TestRandom(long seed) {\n-            super(seed);\n-            this.seed = Long.toHexString(seed).toUpperCase();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return seed;\n-        }\n-\n-        private String seed;\n-    }\n-}\n+\/*\r\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\r\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+ *\r\n+ * This code is free software; you can redistribute it and\/or modify it\r\n+ * under the terms of the GNU General Public License version 2 only, as\r\n+ * published by the Free Software Foundation.\r\n+ *\r\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+ * version 2 for more details (a copy is included in the LICENSE file that\r\n+ * accompanied this code).\r\n+ *\r\n+ * You should have received a copy of the GNU General Public License version\r\n+ * 2 along with this work; if not, write to the Free Software Foundation,\r\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+ *\r\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+ * or visit www.oracle.com if you need additional information or have any\r\n+ * questions.\r\n+ *\/\r\n+\r\n+\/*\r\n+ * @test\r\n+ * @compile\/module=java.base java\/util\/SortingHelper.java\r\n+ * @bug 6880672 6896573 6899694 6976036 7013585 7018258 8003981 8226297 8266431\r\n+ * @build Sorting\r\n+ * @run main Sorting -shortrun\r\n+ * @summary Exercise Arrays.sort, Arrays.parallelSort\r\n+ *\r\n+ * @author Vladimir Yaroslavskiy\r\n+ * @author Jon Bentley\r\n+ * @author Josh Bloch\r\n+ *\/\r\n+\r\n+import java.io.PrintStream;\r\n+import java.util.Arrays;\r\n+import java.util.Random;\r\n+import java.util.SortingHelper;\r\n+\r\n+public class Sorting {\r\n+\r\n+    private static final PrintStream out = System.out;\r\n+    private static final PrintStream err = System.err;\r\n+\r\n+    \/\/ Lengths of arrays for short run\r\n+    private static final int[] SHORT_RUN_LENGTHS =\r\n+        { 1, 2, 14, 100, 500, 1_000, 10_000 };\r\n+\r\n+    \/\/ Lengths of arrays for long run (default)\r\n+    private static final int[] LONG_RUN_LENGTHS =\r\n+        { 1, 2, 14, 100, 500, 1_000, 10_000, 50_000 };\r\n+\r\n+    \/\/ Initial random values for short run\r\n+    private static final TestRandom[] SHORT_RUN_RANDOMS =\r\n+        { TestRandom.C0FFEE };\r\n+\r\n+    \/\/ Initial random values for long run (default)\r\n+    private static final TestRandom[] LONG_RUN_RANDOMS =\r\n+        { TestRandom.DEDA, TestRandom.BABA, TestRandom.C0FFEE };\r\n+\r\n+    \/\/ Constant to fill the left part of array\r\n+    private static final int A380 = 0xA380;\r\n+\r\n+    \/\/ Constant to fill the right part of array\r\n+    private static final int B747 = 0xB747;\r\n+\r\n+    private final SortingHelper sortingHelper;\r\n+    private final TestRandom[] randoms;\r\n+    private final int[] lengths;\r\n+    private final boolean fix;\r\n+    private Object[] gold;\r\n+    private Object[] test;\r\n+\r\n+    public static void main(String[] args) {\r\n+        long start = System.currentTimeMillis();\r\n+        boolean shortRun = args.length > 0 && args[0].equals(\"-shortrun\");\r\n+\r\n+        int[] lengths = shortRun ? SHORT_RUN_LENGTHS : LONG_RUN_LENGTHS;\r\n+        TestRandom[] randoms = shortRun ? SHORT_RUN_RANDOMS : LONG_RUN_RANDOMS;\r\n+\r\n+        new Sorting(SortingHelper.MIXED_INSERTION_SORT, randoms).testBase();\r\n+        new Sorting(SortingHelper.MERGING_SORT, randoms, lengths).testStructured(512);\r\n+        new Sorting(SortingHelper.HEAP_SORT, randoms, lengths).testBase();\r\n+        new Sorting(SortingHelper.RADIX_SORT, randoms, lengths).testCore();\r\n+        new Sorting(SortingHelper.DUAL_PIVOT_QUICKSORT, randoms, lengths).testCore();\r\n+        new Sorting(SortingHelper.PARALLEL_SORT, randoms, lengths).testCore();\r\n+        new Sorting(SortingHelper.ARRAYS_SORT, randoms, lengths).testAll();\r\n+        new Sorting(SortingHelper.ARRAYS_PARALLEL_SORT, randoms, lengths).testAll();\r\n+\r\n+        long end = System.currentTimeMillis();\r\n+        out.format(\"PASSED in %d sec.\\n\", (end - start) \/ 1_000);\r\n+    }\r\n+\r\n+    private Sorting(SortingHelper sortingHelper, TestRandom[] randoms) {\r\n+        this(sortingHelper, randoms, SHORT_RUN_LENGTHS, true);\r\n+    }\r\n+\r\n+    private Sorting(SortingHelper sortingHelper, TestRandom[] randoms, int[] lengths) {\r\n+        this(sortingHelper, randoms, lengths, false);\r\n+    }\r\n+\r\n+    private Sorting(SortingHelper sortingHelper, TestRandom[] randoms, int[] lengths, boolean fix) {\r\n+        this.sortingHelper = sortingHelper;\r\n+        this.randoms = randoms;\r\n+        this.lengths = lengths;\r\n+        this.fix = fix;\r\n+    }\r\n+\r\n+    private void testBase() {\r\n+        testStructured(0);\r\n+        testEmptyArray();\r\n+\r\n+        for (int length : lengths) {\r\n+            createData(length);\r\n+            testSubArray(length);\r\n+\r\n+            for (TestRandom random : randoms) {\r\n+                testWithCheckSum(length, random);\r\n+                testWithScrambling(length, random);\r\n+                testWithInsertionSort(length, random);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void testCore() {\r\n+        testBase();\r\n+\r\n+        for (int length : lengths) {\r\n+            createData(length);\r\n+\r\n+            for (TestRandom random : randoms) {\r\n+                testNegativeZero(length, random);\r\n+                testFloatingPointSorting(length, random);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void testAll() {\r\n+        testCore();\r\n+\r\n+        for (int length : lengths) {\r\n+            createData(length);\r\n+            testRange(length);\r\n+        }\r\n+    }\r\n+\r\n+    private void testStructured(int min) {\r\n+        for (int length : lengths) {\r\n+            createData(length);\r\n+            testStructured(length, min);\r\n+        }\r\n+    }\r\n+\r\n+    private void testEmptyArray() {\r\n+        sortingHelper.sort(new int[] {});\r\n+        sortingHelper.sort(new int[] {}, 0, 0);\r\n+\r\n+        sortingHelper.sort(new long[] {});\r\n+        sortingHelper.sort(new long[] {}, 0, 0);\r\n+\r\n+        sortingHelper.sort(new byte[] {});\r\n+        sortingHelper.sort(new byte[] {}, 0, 0);\r\n+\r\n+        sortingHelper.sort(new char[] {});\r\n+        sortingHelper.sort(new char[] {}, 0, 0);\r\n+\r\n+        sortingHelper.sort(new short[] {});\r\n+        sortingHelper.sort(new short[] {}, 0, 0);\r\n+\r\n+        sortingHelper.sort(new float[] {});\r\n+        sortingHelper.sort(new float[] {}, 0, 0);\r\n+\r\n+        sortingHelper.sort(new double[] {});\r\n+        sortingHelper.sort(new double[] {}, 0, 0);\r\n+    }\r\n+\r\n+    private void testSubArray(int length) {\r\n+        if (fix || length < 4) {\r\n+            return;\r\n+        }\r\n+        for (int m = 1; m < length \/ 2; m <<= 1) {\r\n+            int toIndex = length - m;\r\n+\r\n+            prepareSubArray((int[]) gold[0], m, toIndex);\r\n+            convertData(length);\r\n+\r\n+            for (int i = 0; i < test.length; ++i) {\r\n+                printTestName(\"Test subarray\", length,\r\n+                    \", m = \" + m + \", \" + getType(i));\r\n+                sortingHelper.sort(test[i], m, toIndex);\r\n+                checkSubArray(test[i], m, toIndex);\r\n+            }\r\n+        }\r\n+        out.println();\r\n+    }\r\n+\r\n+    private void testRange(int length) {\r\n+        for (int m = 1; m < length; m <<= 1) {\r\n+            for (int i = 1; i <= length; ++i) {\r\n+                ((int[]) gold[0])[i - 1] = i % m + m % i;\r\n+            }\r\n+            convertData(length);\r\n+\r\n+            for (int i = 0; i < test.length; ++i) {\r\n+                printTestName(\"Test range check\", length,\r\n+                    \", m = \" + m + \", \" + getType(i));\r\n+                checkRange(test[i], m);\r\n+            }\r\n+        }\r\n+        out.println();\r\n+    }\r\n+\r\n+    private void testWithInsertionSort(int length, TestRandom random) {\r\n+        if (length > 1_000) {\r\n+            return;\r\n+        }\r\n+        for (int m = 1; m <= length; m <<= 1) {\r\n+            for (UnsortedBuilder builder : UnsortedBuilder.values()) {\r\n+                builder.build((int[]) gold[0], m, random);\r\n+                convertData(length);\r\n+\r\n+                for (int i = 0; i < test.length; ++i) {\r\n+                    printTestName(\"Test with insertion sort\", random, length,\r\n+                        \", m = \" + m + \", \" + getType(i) + \" \" + builder);\r\n+                    sortingHelper.sort(test[i]);\r\n+                    sortByInsertionSort(gold[i]);\r\n+                    checkSorted(gold[i]);\r\n+                    compare(test[i], gold[i]);\r\n+                }\r\n+            }\r\n+        }\r\n+        out.println();\r\n+    }\r\n+\r\n+    private void testStructured(int length, int min) {\r\n+        if (length < min) {\r\n+            return;\r\n+        }\r\n+        for (int m = 1; m < 8; ++m) {\r\n+            for (StructuredBuilder builder : StructuredBuilder.values()) {\r\n+                builder.build((int[]) gold[0], m);\r\n+                convertData(length);\r\n+\r\n+                for (int i = 0; i < test.length; ++i) {\r\n+                    printTestName(\"Test structured\", length,\r\n+                        \", m = \" + m + \", \" +  getType(i) + \" \" + builder);\r\n+                    sortingHelper.sort(test[i]);\r\n+                    checkSorted(test[i]);\r\n+                }\r\n+            }\r\n+        }\r\n+        out.println();\r\n+    }\r\n+\r\n+    private void testWithCheckSum(int length, TestRandom random) {\r\n+        if (length > 1_000) {\r\n+            return;\r\n+        }\r\n+        for (int m = 1; m <= length; m <<= 1) {\r\n+            for (UnsortedBuilder builder : UnsortedBuilder.values()) {\r\n+                builder.build((int[]) gold[0], m, random);\r\n+                convertData(length);\r\n+\r\n+                for (int i = 0; i < test.length; ++i) {\r\n+                    printTestName(\"Test with check sum\", random, length,\r\n+                        \", m = \" + m + \", \" + getType(i) + \" \" + builder);\r\n+                    sortingHelper.sort(test[i]);\r\n+                    checkWithCheckSum(test[i], gold[i]);\r\n+                }\r\n+            }\r\n+        }\r\n+        out.println();\r\n+    }\r\n+\r\n+    private void testWithScrambling(int length, TestRandom random) {\r\n+        if (fix) {\r\n+            return;\r\n+        }\r\n+        for (int m = 1; m <= length; m <<= 1) {\r\n+            for (SortedBuilder builder : SortedBuilder.values()) {\r\n+                builder.build((int[]) gold[0], m);\r\n+                convertData(length);\r\n+\r\n+                for (int i = 0; i < test.length; ++i) {\r\n+                    printTestName(\"Test with scrambling\", random, length,\r\n+                        \", m = \" + m + \", \" + getType(i) + \" \" + builder);\r\n+                    scramble(test[i], random);\r\n+                    sortingHelper.sort(test[i]);\r\n+                    compare(test[i], gold[i]);\r\n+                }\r\n+            }\r\n+        }\r\n+        out.println();\r\n+    }\r\n+\r\n+    private void testNegativeZero(int length, TestRandom random) {\r\n+        for (int i = 5; i < test.length; ++i) {\r\n+            printTestName(\"Test negative zero -0.0\", random, length, \" \" + getType(i));\r\n+\r\n+            NegativeZeroBuilder builder = NegativeZeroBuilder.values()[i - 5];\r\n+            builder.build(test[i], random);\r\n+\r\n+            sortingHelper.sort(test[i]);\r\n+            checkNegativeZero(test[i]);\r\n+        }\r\n+        out.println();\r\n+    }\r\n+\r\n+    private void testFloatingPointSorting(int length, TestRandom random) {\r\n+        if (length < 6) {\r\n+            return;\r\n+        }\r\n+        final int MAX = 14;\r\n+        int s = 4;\r\n+\r\n+        for (int a = 0; a < MAX; ++a) {\r\n+            for (int g = 0; g < MAX; ++g) {\r\n+                for (int z = 0; z < MAX; ++z) {\r\n+                    for (int n = 0; n < MAX; ++n) {\r\n+                        for (int p = 0; p < MAX; ++p) {\r\n+                            if (a + g + z + n + p + s != length) {\r\n+                                continue;\r\n+                            }\r\n+                            for (int i = 5; i < test.length; ++i) {\r\n+                                printTestName(\"Test float-pointing sorting\", random, length,\r\n+                                    \", a = \" + a + \", g = \" + g + \", z = \" + z +\r\n+                                    \", n = \" + n + \", p = \" + p + \", \" + getType(i));\r\n+                                FloatingPointBuilder builder = FloatingPointBuilder.values()[i - 5];\r\n+                                builder.build(gold[i], a, g, z, n, p, random);\r\n+                                copy(test[i], gold[i]);\r\n+                                scramble(test[i], random);\r\n+                                sortingHelper.sort(test[i]);\r\n+                                compare(test[i], gold[i], a, n + 2, g);\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                }\r\n+            }\r\n+        }\r\n+        for (int m = MAX; m > 4; --m) {\r\n+            int g = length \/ m;\r\n+            int a = length - g - g - g - g - s;\r\n+\r\n+            for (int i = 5; i < test.length; ++i) {\r\n+                printTestName(\"Test float-pointing sorting\", random, length,\r\n+                    \", a = \" + a + \", g = \" + g + \", z = \" + g +\r\n+                    \", n = \" + g + \", p = \" + g + \", \" + getType(i));\r\n+                FloatingPointBuilder builder = FloatingPointBuilder.values()[i - 5];\r\n+                builder.build(gold[i], a, g, g, g, g, random);\r\n+                copy(test[i], gold[i]);\r\n+                scramble(test[i], random);\r\n+                sortingHelper.sort(test[i]);\r\n+                compare(test[i], gold[i], a, g + 2, g);\r\n+            }\r\n+        }\r\n+        out.println();\r\n+    }\r\n+\r\n+    private void prepareSubArray(int[] a, int fromIndex, int toIndex) {\r\n+        for (int i = 0; i < fromIndex; ++i) {\r\n+            a[i] = A380;\r\n+        }\r\n+        int middle = (fromIndex + toIndex) >>> 1;\r\n+        int k = 0;\r\n+\r\n+        for (int i = fromIndex; i < middle; ++i) {\r\n+            a[i] = k++;\r\n+        }\r\n+\r\n+        for (int i = middle; i < toIndex; ++i) {\r\n+            a[i] = k--;\r\n+        }\r\n+\r\n+        for (int i = toIndex; i < a.length; ++i) {\r\n+            a[i] = B747;\r\n+        }\r\n+    }\r\n+\r\n+    private void scramble(Object a, Random random) {\r\n+        if (a instanceof int[]) {\r\n+            scramble((int[]) a, random);\r\n+        } else if (a instanceof long[]) {\r\n+            scramble((long[]) a, random);\r\n+        } else if (a instanceof byte[]) {\r\n+            scramble((byte[]) a, random);\r\n+        } else if (a instanceof char[]) {\r\n+            scramble((char[]) a, random);\r\n+        } else if (a instanceof short[]) {\r\n+            scramble((short[]) a, random);\r\n+        } else if (a instanceof float[]) {\r\n+            scramble((float[]) a, random);\r\n+        } else if (a instanceof double[]) {\r\n+            scramble((double[]) a, random);\r\n+        } else {\r\n+            fail(a);\r\n+        }\r\n+    }\r\n+\r\n+    private void scramble(int[] a, Random random) {\r\n+        for (int i = 0; i < a.length * 7; ++i) {\r\n+            swap(a, random.nextInt(a.length), random.nextInt(a.length));\r\n+        }\r\n+    }\r\n+\r\n+    private void scramble(long[] a, Random random) {\r\n+        for (int i = 0; i < a.length * 7; ++i) {\r\n+            swap(a, random.nextInt(a.length), random.nextInt(a.length));\r\n+        }\r\n+    }\r\n+\r\n+    private void scramble(byte[] a, Random random) {\r\n+        for (int i = 0; i < a.length * 7; ++i) {\r\n+            swap(a, random.nextInt(a.length), random.nextInt(a.length));\r\n+        }\r\n+    }\r\n+\r\n+    private void scramble(char[] a, Random random) {\r\n+        for (int i = 0; i < a.length * 7; ++i) {\r\n+            swap(a, random.nextInt(a.length), random.nextInt(a.length));\r\n+        }\r\n+    }\r\n+\r\n+    private void scramble(short[] a, Random random) {\r\n+        for (int i = 0; i < a.length * 7; ++i) {\r\n+            swap(a, random.nextInt(a.length), random.nextInt(a.length));\r\n+        }\r\n+    }\r\n+\r\n+    private void scramble(float[] a, Random random) {\r\n+        for (int i = 0; i < a.length * 7; ++i) {\r\n+            swap(a, random.nextInt(a.length), random.nextInt(a.length));\r\n+        }\r\n+    }\r\n+\r\n+    private void scramble(double[] a, Random random) {\r\n+        for (int i = 0; i < a.length * 7; ++i) {\r\n+            swap(a, random.nextInt(a.length), random.nextInt(a.length));\r\n+        }\r\n+    }\r\n+\r\n+    private void swap(int[] a, int i, int j) {\r\n+        int t = a[i]; a[i] = a[j]; a[j] = t;\r\n+    }\r\n+\r\n+    private void swap(long[] a, int i, int j) {\r\n+        long t = a[i]; a[i] = a[j]; a[j] = t;\r\n+    }\r\n+\r\n+    private void swap(byte[] a, int i, int j) {\r\n+        byte t = a[i]; a[i] = a[j]; a[j] = t;\r\n+    }\r\n+\r\n+    private void swap(char[] a, int i, int j) {\r\n+        char t = a[i]; a[i] = a[j]; a[j] = t;\r\n+    }\r\n+\r\n+    private void swap(short[] a, int i, int j) {\r\n+        short t = a[i]; a[i] = a[j]; a[j] = t;\r\n+    }\r\n+\r\n+    private void swap(float[] a, int i, int j) {\r\n+        float t = a[i]; a[i] = a[j]; a[j] = t;\r\n+    }\r\n+\r\n+    private void swap(double[] a, int i, int j) {\r\n+        double t = a[i]; a[i] = a[j]; a[j] = t;\r\n+    }\r\n+\r\n+    private void checkWithCheckSum(Object test, Object gold) {\r\n+        checkSorted(test);\r\n+        checkCheckSum(test, gold);\r\n+    }\r\n+\r\n+    private void fail(Object object) {\r\n+        fail(\"Unknown type of array: \" + object.getClass().getName());\r\n+    }\r\n+\r\n+    private void fail(String message) {\r\n+        err.format(\"\\n*** TEST FAILED ***\\n\\n%s\\n\\n\", message);\r\n+        throw new RuntimeException(\"Test failed\");\r\n+    }\r\n+\r\n+    private void checkNegativeZero(Object a) {\r\n+        if (a instanceof float[]) {\r\n+            checkNegativeZero((float[]) a);\r\n+        } else if (a instanceof double[]) {\r\n+            checkNegativeZero((double[]) a);\r\n+        } else {\r\n+            fail(a);\r\n+        }\r\n+    }\r\n+\r\n+    private void checkNegativeZero(float[] a) {\r\n+        for (int i = 0; i < a.length - 1; ++i) {\r\n+            if (Float.floatToRawIntBits(a[i]) == 0 && Float.floatToRawIntBits(a[i + 1]) < 0) {\r\n+                fail(a[i] + \" before \" + a[i + 1] + \" at position \" + i);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void checkNegativeZero(double[] a) {\r\n+        for (int i = 0; i < a.length - 1; ++i) {\r\n+            if (Double.doubleToRawLongBits(a[i]) == 0 && Double.doubleToRawLongBits(a[i + 1]) < 0) {\r\n+                fail(a[i] + \" before \" + a[i + 1] + \" at position \" + i);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void compare(Object a, Object b, int numNaN, int numNeg, int numNegZero) {\r\n+        if (a instanceof float[]) {\r\n+            compare((float[]) a, (float[]) b, numNaN, numNeg, numNegZero);\r\n+        } else if (a instanceof double[]) {\r\n+            compare((double[]) a, (double[]) b, numNaN, numNeg, numNegZero);\r\n+        } else {\r\n+            fail(a);\r\n+        }\r\n+    }\r\n+\r\n+    private void compare(float[] a, float[] b, int numNaN, int numNeg, int numNegZero) {\r\n+        for (int i = a.length - numNaN; i < a.length; ++i) {\r\n+            if (a[i] == a[i]) {\r\n+                fail(\"There must be NaN instead of \" + a[i] + \" at position \" + i);\r\n+            }\r\n+        }\r\n+        final int NEGATIVE_ZERO = Float.floatToIntBits(-0.0f);\r\n+\r\n+        for (int i = numNeg; i < numNeg + numNegZero; ++i) {\r\n+            if (NEGATIVE_ZERO != Float.floatToIntBits(a[i])) {\r\n+                fail(\"There must be -0.0 instead of \" + a[i] + \" at position \" + i);\r\n+            }\r\n+        }\r\n+\r\n+        for (int i = 0; i < a.length - numNaN; ++i) {\r\n+            if (a[i] != b[i]) {\r\n+                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void compare(double[] a, double[] b, int numNaN, int numNeg, int numNegZero) {\r\n+        for (int i = a.length - numNaN; i < a.length; ++i) {\r\n+            if (a[i] == a[i]) {\r\n+                fail(\"There must be NaN instead of \" + a[i] + \" at position \" + i);\r\n+            }\r\n+        }\r\n+        final long NEGATIVE_ZERO = Double.doubleToLongBits(-0.0d);\r\n+\r\n+        for (int i = numNeg; i < numNeg + numNegZero; ++i) {\r\n+            if (NEGATIVE_ZERO != Double.doubleToLongBits(a[i])) {\r\n+                fail(\"There must be -0.0 instead of \" + a[i] + \" at position \" + i);\r\n+            }\r\n+        }\r\n+\r\n+        for (int i = 0; i < a.length - numNaN; ++i) {\r\n+            if (a[i] != b[i]) {\r\n+                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void compare(Object a, Object b) {\r\n+        if (a instanceof int[]) {\r\n+            compare((int[]) a, (int[]) b);\r\n+        } else if (a instanceof long[]) {\r\n+            compare((long[]) a, (long[]) b);\r\n+        } else if (a instanceof byte[]) {\r\n+            compare((byte[]) a, (byte[]) b);\r\n+        } else if (a instanceof char[]) {\r\n+            compare((char[]) a, (char[]) b);\r\n+        } else if (a instanceof short[]) {\r\n+            compare((short[]) a, (short[]) b);\r\n+        } else if (a instanceof float[]) {\r\n+            compare((float[]) a, (float[]) b);\r\n+        } else if (a instanceof double[]) {\r\n+            compare((double[]) a, (double[]) b);\r\n+        } else {\r\n+            fail(a);\r\n+        }\r\n+    }\r\n+\r\n+    private void compare(int[] a, int[] b) {\r\n+        for (int i = 0; i < a.length; ++i) {\r\n+            if (a[i] != b[i]) {\r\n+                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void compare(long[] a, long[] b) {\r\n+        for (int i = 0; i < a.length; ++i) {\r\n+            if (a[i] != b[i]) {\r\n+                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void compare(byte[] a, byte[] b) {\r\n+        for (int i = 0; i < a.length; ++i) {\r\n+            if (a[i] != b[i]) {\r\n+                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void compare(char[] a, char[] b) {\r\n+        for (int i = 0; i < a.length; ++i) {\r\n+            if (a[i] != b[i]) {\r\n+                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void compare(short[] a, short[] b) {\r\n+        for (int i = 0; i < a.length; ++i) {\r\n+            if (a[i] != b[i]) {\r\n+                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void compare(float[] a, float[] b) {\r\n+        for (int i = 0; i < a.length; ++i) {\r\n+            if (a[i] != b[i]) {\r\n+                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void compare(double[] a, double[] b) {\r\n+        for (int i = 0; i < a.length; ++i) {\r\n+            if (a[i] != b[i]) {\r\n+                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private String getType(int i) {\r\n+        Object a = test[i];\r\n+\r\n+        if (a instanceof int[]) {\r\n+            return \"INT   \";\r\n+        }\r\n+        if (a instanceof long[]) {\r\n+            return \"LONG  \";\r\n+        }\r\n+        if (a instanceof byte[]) {\r\n+            return \"BYTE  \";\r\n+        }\r\n+        if (a instanceof char[]) {\r\n+            return \"CHAR  \";\r\n+        }\r\n+        if (a instanceof short[]) {\r\n+            return \"SHORT \";\r\n+        }\r\n+        if (a instanceof float[]) {\r\n+            return \"FLOAT \";\r\n+        }\r\n+        if (a instanceof double[]) {\r\n+            return \"DOUBLE\";\r\n+        }\r\n+        fail(a);\r\n+        return null;\r\n+    }\r\n+\r\n+    private void checkSorted(Object a) {\r\n+        if (a instanceof int[]) {\r\n+            checkSorted((int[]) a);\r\n+        } else if (a instanceof long[]) {\r\n+            checkSorted((long[]) a);\r\n+        } else if (a instanceof byte[]) {\r\n+            checkSorted((byte[]) a);\r\n+        } else if (a instanceof char[]) {\r\n+            checkSorted((char[]) a);\r\n+        } else if (a instanceof short[]) {\r\n+            checkSorted((short[]) a);\r\n+        } else if (a instanceof float[]) {\r\n+            checkSorted((float[]) a);\r\n+        } else if (a instanceof double[]) {\r\n+            checkSorted((double[]) a);\r\n+        } else {\r\n+            fail(a);\r\n+        }\r\n+    }\r\n+\r\n+    private void checkSorted(int[] a) {\r\n+        for (int i = 0; i < a.length - 1; ++i) {\r\n+            if (a[i] > a[i + 1]) {\r\n+                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void checkSorted(long[] a) {\r\n+        for (int i = 0; i < a.length - 1; ++i) {\r\n+            if (a[i] > a[i + 1]) {\r\n+                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void checkSorted(byte[] a) {\r\n+        for (int i = 0; i < a.length - 1; ++i) {\r\n+            if (a[i] > a[i + 1]) {\r\n+                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void checkSorted(char[] a) {\r\n+        for (int i = 0; i < a.length - 1; ++i) {\r\n+            if (a[i] > a[i + 1]) {\r\n+                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void checkSorted(short[] a) {\r\n+        for (int i = 0; i < a.length - 1; ++i) {\r\n+            if (a[i] > a[i + 1]) {\r\n+                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void checkSorted(float[] a) {\r\n+        for (int i = 0; i < a.length - 1; ++i) {\r\n+            if (a[i] > a[i + 1]) {\r\n+                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void checkSorted(double[] a) {\r\n+        for (int i = 0; i < a.length - 1; ++i) {\r\n+            if (a[i] > a[i + 1]) {\r\n+                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void checkCheckSum(Object test, Object gold) {\r\n+        if (checkSumXor(test) != checkSumXor(gold)) {\r\n+            fail(\"Original and sorted arrays are not identical [^]\");\r\n+        }\r\n+        if (checkSumPlus(test) != checkSumPlus(gold)) {\r\n+            fail(\"Original and sorted arrays are not identical [+]\");\r\n+        }\r\n+    }\r\n+\r\n+    private int checkSumXor(Object a) {\r\n+        if (a instanceof int[]) {\r\n+            return checkSumXor((int[]) a);\r\n+        }\r\n+        if (a instanceof long[]) {\r\n+            return checkSumXor((long[]) a);\r\n+        }\r\n+        if (a instanceof byte[]) {\r\n+            return checkSumXor((byte[]) a);\r\n+        }\r\n+        if (a instanceof char[]) {\r\n+            return checkSumXor((char[]) a);\r\n+        }\r\n+        if (a instanceof short[]) {\r\n+            return checkSumXor((short[]) a);\r\n+        }\r\n+        if (a instanceof float[]) {\r\n+            return checkSumXor((float[]) a);\r\n+        }\r\n+        if (a instanceof double[]) {\r\n+            return checkSumXor((double[]) a);\r\n+        }\r\n+        fail(a);\r\n+        return -1;\r\n+    }\r\n+\r\n+    private int checkSumXor(int[] a) {\r\n+        int checkSum = 0;\r\n+\r\n+        for (int e : a) {\r\n+            checkSum ^= e;\r\n+        }\r\n+        return checkSum;\r\n+    }\r\n+\r\n+    private int checkSumXor(long[] a) {\r\n+        long checkSum = 0;\r\n+\r\n+        for (long e : a) {\r\n+            checkSum ^= e;\r\n+        }\r\n+        return (int) checkSum;\r\n+    }\r\n+\r\n+    private int checkSumXor(byte[] a) {\r\n+        byte checkSum = 0;\r\n+\r\n+        for (byte e : a) {\r\n+            checkSum ^= e;\r\n+        }\r\n+        return checkSum;\r\n+    }\r\n+\r\n+    private int checkSumXor(char[] a) {\r\n+        char checkSum = 0;\r\n+\r\n+        for (char e : a) {\r\n+            checkSum ^= e;\r\n+        }\r\n+        return checkSum;\r\n+    }\r\n+\r\n+    private int checkSumXor(short[] a) {\r\n+        short checkSum = 0;\r\n+\r\n+        for (short e : a) {\r\n+            checkSum ^= e;\r\n+        }\r\n+        return checkSum;\r\n+    }\r\n+\r\n+    private int checkSumXor(float[] a) {\r\n+        int checkSum = 0;\r\n+\r\n+        for (float e : a) {\r\n+            checkSum ^= (int) e;\r\n+        }\r\n+        return checkSum;\r\n+    }\r\n+\r\n+    private int checkSumXor(double[] a) {\r\n+        int checkSum = 0;\r\n+\r\n+        for (double e : a) {\r\n+            checkSum ^= (int) e;\r\n+        }\r\n+        return checkSum;\r\n+    }\r\n+\r\n+    private int checkSumPlus(Object a) {\r\n+        if (a instanceof int[]) {\r\n+            return checkSumPlus((int[]) a);\r\n+        }\r\n+        if (a instanceof long[]) {\r\n+            return checkSumPlus((long[]) a);\r\n+        }\r\n+        if (a instanceof byte[]) {\r\n+            return checkSumPlus((byte[]) a);\r\n+        }\r\n+        if (a instanceof char[]) {\r\n+            return checkSumPlus((char[]) a);\r\n+        }\r\n+        if (a instanceof short[]) {\r\n+            return checkSumPlus((short[]) a);\r\n+        }\r\n+        if (a instanceof float[]) {\r\n+            return checkSumPlus((float[]) a);\r\n+        }\r\n+        if (a instanceof double[]) {\r\n+            return checkSumPlus((double[]) a);\r\n+        }\r\n+        fail(a);\r\n+        return -1;\r\n+    }\r\n+\r\n+    private int checkSumPlus(int[] a) {\r\n+        int checkSum = 0;\r\n+\r\n+        for (int e : a) {\r\n+            checkSum += e;\r\n+        }\r\n+        return checkSum;\r\n+    }\r\n+\r\n+    private int checkSumPlus(long[] a) {\r\n+        long checkSum = 0;\r\n+\r\n+        for (long e : a) {\r\n+            checkSum += e;\r\n+        }\r\n+        return (int) checkSum;\r\n+    }\r\n+\r\n+    private int checkSumPlus(byte[] a) {\r\n+        byte checkSum = 0;\r\n+\r\n+        for (byte e : a) {\r\n+            checkSum += e;\r\n+        }\r\n+        return checkSum;\r\n+    }\r\n+\r\n+    private int checkSumPlus(char[] a) {\r\n+        char checkSum = 0;\r\n+\r\n+        for (char e : a) {\r\n+            checkSum += e;\r\n+        }\r\n+        return checkSum;\r\n+    }\r\n+\r\n+    private int checkSumPlus(short[] a) {\r\n+        short checkSum = 0;\r\n+\r\n+        for (short e : a) {\r\n+            checkSum += e;\r\n+        }\r\n+        return checkSum;\r\n+    }\r\n+\r\n+    private int checkSumPlus(float[] a) {\r\n+        int checkSum = 0;\r\n+\r\n+        for (float e : a) {\r\n+            checkSum += (int) e;\r\n+        }\r\n+        return checkSum;\r\n+    }\r\n+\r\n+    private int checkSumPlus(double[] a) {\r\n+        int checkSum = 0;\r\n+\r\n+        for (double e : a) {\r\n+            checkSum += (int) e;\r\n+        }\r\n+        return checkSum;\r\n+    }\r\n+\r\n+    private void sortByInsertionSort(Object a) {\r\n+        SortingHelper.INSERTION_SORT.sort(a);\r\n+    }\r\n+\r\n+    private void checkSubArray(Object a, int fromIndex, int toIndex) {\r\n+        if (a instanceof int[]) {\r\n+            checkSubArray((int[]) a, fromIndex, toIndex);\r\n+        } else if (a instanceof long[]) {\r\n+            checkSubArray((long[]) a, fromIndex, toIndex);\r\n+        } else if (a instanceof byte[]) {\r\n+            checkSubArray((byte[]) a, fromIndex, toIndex);\r\n+        } else if (a instanceof char[]) {\r\n+            checkSubArray((char[]) a, fromIndex, toIndex);\r\n+        } else if (a instanceof short[]) {\r\n+            checkSubArray((short[]) a, fromIndex, toIndex);\r\n+        } else if (a instanceof float[]) {\r\n+            checkSubArray((float[]) a, fromIndex, toIndex);\r\n+        } else if (a instanceof double[]) {\r\n+            checkSubArray((double[]) a, fromIndex, toIndex);\r\n+        } else {\r\n+            fail(a);\r\n+        }\r\n+    }\r\n+\r\n+    private void checkSubArray(int[] a, int fromIndex, int toIndex) {\r\n+        for (int i = 0; i < fromIndex; ++i) {\r\n+            if (a[i] != A380) {\r\n+                fail(\"Range sort changes left element at position \" + i + hex(a[i], A380));\r\n+            }\r\n+        }\r\n+\r\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\r\n+            if (a[i] > a[i + 1]) {\r\n+                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\r\n+            }\r\n+        }\r\n+\r\n+        for (int i = toIndex; i < a.length; ++i) {\r\n+            if (a[i] != B747) {\r\n+                fail(\"Range sort changes right element at position \" + i + hex(a[i], B747));\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void checkSubArray(long[] a, int fromIndex, int toIndex) {\r\n+        for (int i = 0; i < fromIndex; ++i) {\r\n+            if (a[i] != (long) A380) {\r\n+                fail(\"Range sort changes left element at position \" + i + hex(a[i], A380));\r\n+            }\r\n+        }\r\n+\r\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\r\n+            if (a[i] > a[i + 1]) {\r\n+                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\r\n+            }\r\n+        }\r\n+\r\n+        for (int i = toIndex; i < a.length; ++i) {\r\n+            if (a[i] != (long) B747) {\r\n+                fail(\"Range sort changes right element at position \" + i + hex(a[i], B747));\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void checkSubArray(byte[] a, int fromIndex, int toIndex) {\r\n+        for (int i = 0; i < fromIndex; ++i) {\r\n+            if (a[i] != (byte) A380) {\r\n+                fail(\"Range sort changes left element at position \" + i + hex(a[i], A380));\r\n+            }\r\n+        }\r\n+\r\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\r\n+            if (a[i] > a[i + 1]) {\r\n+                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\r\n+            }\r\n+        }\r\n+\r\n+        for (int i = toIndex; i < a.length; ++i) {\r\n+            if (a[i] != (byte) B747) {\r\n+                fail(\"Range sort changes right element at position \" + i + hex(a[i], B747));\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void checkSubArray(char[] a, int fromIndex, int toIndex) {\r\n+        for (int i = 0; i < fromIndex; ++i) {\r\n+            if (a[i] != (char) A380) {\r\n+                fail(\"Range sort changes left element at position \" + i + hex(a[i], A380));\r\n+            }\r\n+        }\r\n+\r\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\r\n+            if (a[i] > a[i + 1]) {\r\n+                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\r\n+            }\r\n+        }\r\n+\r\n+        for (int i = toIndex; i < a.length; ++i) {\r\n+            if (a[i] != (char) B747) {\r\n+                fail(\"Range sort changes right element at position \" + i + hex(a[i], B747));\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void checkSubArray(short[] a, int fromIndex, int toIndex) {\r\n+        for (int i = 0; i < fromIndex; ++i) {\r\n+            if (a[i] != (short) A380) {\r\n+                fail(\"Range sort changes left element at position \" + i + hex(a[i], A380));\r\n+            }\r\n+        }\r\n+\r\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\r\n+            if (a[i] > a[i + 1]) {\r\n+                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\r\n+            }\r\n+        }\r\n+\r\n+        for (int i = toIndex; i < a.length; ++i) {\r\n+            if (a[i] != (short) B747) {\r\n+                fail(\"Range sort changes right element at position \" + i + hex(a[i], B747));\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void checkSubArray(float[] a, int fromIndex, int toIndex) {\r\n+        for (int i = 0; i < fromIndex; ++i) {\r\n+            if (a[i] != (float) A380) {\r\n+                fail(\"Range sort changes left element at position \" + i + hex((long) a[i], A380));\r\n+            }\r\n+        }\r\n+\r\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\r\n+            if (a[i] > a[i + 1]) {\r\n+                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\r\n+            }\r\n+        }\r\n+\r\n+        for (int i = toIndex; i < a.length; ++i) {\r\n+            if (a[i] != (float) B747) {\r\n+                fail(\"Range sort changes right element at position \" + i + hex((long) a[i], B747));\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void checkSubArray(double[] a, int fromIndex, int toIndex) {\r\n+        for (int i = 0; i < fromIndex; ++i) {\r\n+            if (a[i] != (double) A380) {\r\n+                fail(\"Range sort changes left element at position \" + i + hex((long) a[i], A380));\r\n+            }\r\n+        }\r\n+\r\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\r\n+            if (a[i] > a[i + 1]) {\r\n+                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\r\n+            }\r\n+        }\r\n+\r\n+        for (int i = toIndex; i < a.length; ++i) {\r\n+            if (a[i] != (double) B747) {\r\n+                fail(\"Range sort changes right element at position \" + i + hex((long) a[i], B747));\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void checkRange(Object a, int m) {\r\n+        if (a instanceof int[]) {\r\n+            checkRange((int[]) a, m);\r\n+        } else if (a instanceof long[]) {\r\n+            checkRange((long[]) a, m);\r\n+        } else if (a instanceof byte[]) {\r\n+            checkRange((byte[]) a, m);\r\n+        } else if (a instanceof char[]) {\r\n+            checkRange((char[]) a, m);\r\n+        } else if (a instanceof short[]) {\r\n+            checkRange((short[]) a, m);\r\n+        } else if (a instanceof float[]) {\r\n+            checkRange((float[]) a, m);\r\n+        } else if (a instanceof double[]) {\r\n+            checkRange((double[]) a, m);\r\n+        } else {\r\n+            fail(a);\r\n+        }\r\n+    }\r\n+\r\n+    private void checkRange(int[] a, int m) {\r\n+        try {\r\n+            sortingHelper.sort(a, m + 1, m);\r\n+            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\r\n+                \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\r\n+        } catch (IllegalArgumentException iae) {\r\n+            try {\r\n+                sortingHelper.sort(a, -m, a.length);\r\n+                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\r\n+                    \"as expected: fromIndex = \" + (-m));\r\n+            } catch (ArrayIndexOutOfBoundsException aoe) {\r\n+                try {\r\n+                    sortingHelper.sort(a, 0, a.length + m);\r\n+                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\r\n+                        \"as expected: toIndex = \" + (a.length + m));\r\n+                } catch (ArrayIndexOutOfBoundsException expected) {}\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void checkRange(long[] a, int m) {\r\n+        try {\r\n+            sortingHelper.sort(a, m + 1, m);\r\n+            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\r\n+                \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\r\n+        } catch (IllegalArgumentException iae) {\r\n+            try {\r\n+                sortingHelper.sort(a, -m, a.length);\r\n+                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\r\n+                    \"as expected: fromIndex = \" + (-m));\r\n+            } catch (ArrayIndexOutOfBoundsException aoe) {\r\n+                try {\r\n+                    sortingHelper.sort(a, 0, a.length + m);\r\n+                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\r\n+                        \"as expected: toIndex = \" + (a.length + m));\r\n+                } catch (ArrayIndexOutOfBoundsException expected) {}\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void checkRange(byte[] a, int m) {\r\n+        try {\r\n+            sortingHelper.sort(a, m + 1, m);\r\n+            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\r\n+                \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\r\n+        } catch (IllegalArgumentException iae) {\r\n+            try {\r\n+                sortingHelper.sort(a, -m, a.length);\r\n+                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\r\n+                    \"as expected: fromIndex = \" + (-m));\r\n+            } catch (ArrayIndexOutOfBoundsException aoe) {\r\n+                try {\r\n+                    sortingHelper.sort(a, 0, a.length + m);\r\n+                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\r\n+                        \"as expected: toIndex = \" + (a.length + m));\r\n+                } catch (ArrayIndexOutOfBoundsException expected) {}\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void checkRange(char[] a, int m) {\r\n+        try {\r\n+            sortingHelper.sort(a, m + 1, m);\r\n+            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\r\n+                \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\r\n+        } catch (IllegalArgumentException iae) {\r\n+            try {\r\n+                sortingHelper.sort(a, -m, a.length);\r\n+                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\r\n+                    \"as expected: fromIndex = \" + (-m));\r\n+            } catch (ArrayIndexOutOfBoundsException aoe) {\r\n+                try {\r\n+                    sortingHelper.sort(a, 0, a.length + m);\r\n+                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\r\n+                        \"as expected: toIndex = \" + (a.length + m));\r\n+                } catch (ArrayIndexOutOfBoundsException expected) {}\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void checkRange(short[] a, int m) {\r\n+        try {\r\n+            sortingHelper.sort(a, m + 1, m);\r\n+            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\r\n+                \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\r\n+        } catch (IllegalArgumentException iae) {\r\n+            try {\r\n+                sortingHelper.sort(a, -m, a.length);\r\n+                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\r\n+                    \"as expected: fromIndex = \" + (-m));\r\n+            } catch (ArrayIndexOutOfBoundsException aoe) {\r\n+                try {\r\n+                    sortingHelper.sort(a, 0, a.length + m);\r\n+                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\r\n+                        \"as expected: toIndex = \" + (a.length + m));\r\n+                } catch (ArrayIndexOutOfBoundsException expected) {}\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void checkRange(float[] a, int m) {\r\n+        try {\r\n+            sortingHelper.sort(a, m + 1, m);\r\n+            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\r\n+                \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\r\n+        } catch (IllegalArgumentException iae) {\r\n+            try {\r\n+                sortingHelper.sort(a, -m, a.length);\r\n+                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\r\n+                    \"as expected: fromIndex = \" + (-m));\r\n+            } catch (ArrayIndexOutOfBoundsException aoe) {\r\n+                try {\r\n+                    sortingHelper.sort(a, 0, a.length + m);\r\n+                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\r\n+                        \"as expected: toIndex = \" + (a.length + m));\r\n+                } catch (ArrayIndexOutOfBoundsException expected) {}\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void checkRange(double[] a, int m) {\r\n+        try {\r\n+            sortingHelper.sort(a, m + 1, m);\r\n+            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\r\n+                \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\r\n+        } catch (IllegalArgumentException iae) {\r\n+            try {\r\n+                sortingHelper.sort(a, -m, a.length);\r\n+                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\r\n+                    \"as expected: fromIndex = \" + (-m));\r\n+            } catch (ArrayIndexOutOfBoundsException aoe) {\r\n+                try {\r\n+                    sortingHelper.sort(a, 0, a.length + m);\r\n+                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\r\n+                        \"as expected: toIndex = \" + (a.length + m));\r\n+                } catch (ArrayIndexOutOfBoundsException expected) {}\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void copy(Object dst, Object src) {\r\n+        if (src instanceof float[]) {\r\n+            copy((float[]) dst, (float[]) src);\r\n+        } else if (src instanceof double[]) {\r\n+            copy((double[]) dst, (double[]) src);\r\n+        } else {\r\n+            fail(src);\r\n+        }\r\n+    }\r\n+\r\n+    private void copy(float[] dst, float[] src) {\r\n+        System.arraycopy(src, 0, dst, 0, src.length);\r\n+    }\r\n+\r\n+    private void copy(double[] dst, double[] src) {\r\n+        System.arraycopy(src, 0, dst, 0, src.length);\r\n+    }\r\n+\r\n+    private void createData(int length) {\r\n+        gold = new Object[] {\r\n+            new int[length], new long[length],\r\n+            new byte[length], new char[length], new short[length],\r\n+            new float[length], new double[length]\r\n+        };\r\n+\r\n+        test = new Object[] {\r\n+            new int[length], new long[length],\r\n+            new byte[length], new char[length], new short[length],\r\n+            new float[length], new double[length]\r\n+        };\r\n+    }\r\n+\r\n+    private void convertData(int length) {\r\n+        for (int i = 0; i < gold.length; ++i) {\r\n+            TypeConverter converter = TypeConverter.values()[i];\r\n+            converter.convert((int[]) gold[0], gold[i], fix);\r\n+        }\r\n+\r\n+        for (int i = 0; i < gold.length; ++i) {\r\n+            System.arraycopy(gold[i], 0, test[i], 0, length);\r\n+        }\r\n+    }\r\n+\r\n+    private String hex(long a, int b) {\r\n+        return \": \" + Long.toHexString(a) + \", must be \" + Integer.toHexString(b);\r\n+    }\r\n+\r\n+    private void printTestName(String test, int length, String message) {\r\n+        out.println(\"[\" + sortingHelper + \"] '\" + test + \"' length = \" + length + message);\r\n+    }\r\n+\r\n+    private void printTestName(String test, TestRandom random, int length, String message) {\r\n+        out.println(\"[\" + sortingHelper + \"] '\" + test +\r\n+            \"' length = \" + length + \", random = \" + random + message);\r\n+    }\r\n+\r\n+    private enum TypeConverter {\r\n+\r\n+        INT {\r\n+            @Override\r\n+            void convert(int[] src, Object dst, boolean fix) {\r\n+                if (fix) {\r\n+                    src[0] = Integer.MIN_VALUE;\r\n+                }\r\n+            }\r\n+        },\r\n+\r\n+        LONG {\r\n+            @Override\r\n+            void convert(int[] src, Object dst, boolean fix) {\r\n+                long[] b = (long[]) dst;\r\n+\r\n+                for (int i = 0; i < src.length; ++i) {\r\n+                    b[i] = src[i];\r\n+                }\r\n+                if (fix) {\r\n+                    b[0] = Long.MIN_VALUE;\r\n+                }\r\n+            }\r\n+        },\r\n+\r\n+        BYTE {\r\n+            @Override\r\n+            void convert(int[] src, Object dst, boolean fix) {\r\n+                byte[] b = (byte[]) dst;\r\n+\r\n+                for (int i = 0; i < src.length; ++i) {\r\n+                    b[i] = (byte) src[i];\r\n+                }\r\n+                if (fix) {\r\n+                    b[0] = Byte.MIN_VALUE;\r\n+                }\r\n+            }\r\n+        },\r\n+\r\n+        CHAR {\r\n+            @Override\r\n+            void convert(int[] src, Object dst, boolean fix) {\r\n+                char[] b = (char[]) dst;\r\n+\r\n+                for (int i = 0; i < src.length; ++i) {\r\n+                    b[i] = (char) src[i];\r\n+                }\r\n+                if (fix) {\r\n+                    b[0] = Character.MIN_VALUE;\r\n+                }\r\n+            }\r\n+        },\r\n+\r\n+        SHORT {\r\n+            @Override\r\n+            void convert(int[] src, Object dst, boolean fix) {\r\n+                short[] b = (short[]) dst;\r\n+\r\n+                for (int i = 0; i < src.length; ++i) {\r\n+                    b[i] = (short) src[i];\r\n+                }\r\n+                if (fix) {\r\n+                    b[0] = Short.MIN_VALUE;\r\n+                }\r\n+            }\r\n+        },\r\n+\r\n+        FLOAT {\r\n+            @Override\r\n+            void convert(int[] src, Object dst, boolean fix) {\r\n+                float[] b = (float[]) dst;\r\n+\r\n+                for (int i = 0; i < src.length; ++i) {\r\n+                    b[i] = (float) src[i];\r\n+                }\r\n+                if (fix) {\r\n+                    b[0] = Float.NEGATIVE_INFINITY;\r\n+                }\r\n+            }\r\n+        },\r\n+\r\n+        DOUBLE {\r\n+            @Override\r\n+            void convert(int[] src, Object dst, boolean fix) {\r\n+                double[] b = (double[]) dst;\r\n+\r\n+                for (int i = 0; i < src.length; ++i) {\r\n+                    b[i] = src[i];\r\n+                }\r\n+                if (fix) {\r\n+                    b[0] = Double.NEGATIVE_INFINITY;\r\n+                }\r\n+            }\r\n+        };\r\n+\r\n+        abstract void convert(int[] src, Object dst, boolean fix);\r\n+    }\r\n+\r\n+    private enum SortedBuilder {\r\n+\r\n+        STEPS {\r\n+            @Override\r\n+            void build(int[] a, int m) {\r\n+                for (int i = 0; i < m; ++i) {\r\n+                    a[i] = 0;\r\n+                }\r\n+\r\n+                for (int i = m; i < a.length; ++i) {\r\n+                    a[i] = 1;\r\n+                }\r\n+            }\r\n+        };\r\n+\r\n+        abstract void build(int[] a, int m);\r\n+    }\r\n+\r\n+    private enum UnsortedBuilder {\r\n+\r\n+        RANDOM {\r\n+            @Override\r\n+            void build(int[] a, int m, Random random) {\r\n+                for (int i = 0; i < a.length; ++i) {\r\n+                    a[i] = random.nextInt();\r\n+                }\r\n+            }\r\n+        },\r\n+\r\n+        PERMUTATION {\r\n+            @Override\r\n+            void build(int[] a, int m, Random random) {\r\n+                int mask = ~(0x000000FF << (random.nextInt(4) * 2));\r\n+\r\n+                for (int i = 0; i < a.length; ++i) {\r\n+                    a[i] = i & mask;\r\n+                }\r\n+                for (int i = a.length; i > 1; --i) {\r\n+                    int k = random.nextInt(i);\r\n+                    int t = a[i - 1]; a[i - 1] = a[k]; a[k] = t;\r\n+                }\r\n+            }\r\n+        },\r\n+\r\n+        UNIFORM {\r\n+            @Override\r\n+            void build(int[] a, int m, Random random) {\r\n+                int mask = (m << 15) - 1;\r\n+\r\n+                for (int i = 0; i < a.length; ++i) {\r\n+                    a[i] = random.nextInt() & mask;\r\n+                }\r\n+            }\r\n+        },\r\n+\r\n+        REPEATED {\r\n+            @Override\r\n+            void build(int[] a, int m, Random random) {\r\n+                for (int i = 0; i < a.length; ++i) {\r\n+                    a[i] = i % m;\r\n+                }\r\n+            }\r\n+        },\r\n+\r\n+        DUPLICATED {\r\n+            @Override\r\n+            void build(int[] a, int m, Random random) {\r\n+                for (int i = 0; i < a.length; ++i) {\r\n+                    a[i] = random.nextInt(m);\r\n+                }\r\n+            }\r\n+        },\r\n+\r\n+        SAWTOOTH {\r\n+            @Override\r\n+            void build(int[] a, int m, Random random) {\r\n+                int incCount = 1;\r\n+                int decCount = a.length;\r\n+                int i = 0;\r\n+                int period = m--;\r\n+\r\n+                while (true) {\r\n+                    for (int k = 1; k <= period; ++k) {\r\n+                        if (i >= a.length) {\r\n+                            return;\r\n+                        }\r\n+                        a[i++] = incCount++;\r\n+                    }\r\n+                    period += m;\r\n+\r\n+                    for (int k = 1; k <= period; ++k) {\r\n+                        if (i >= a.length) {\r\n+                            return;\r\n+                        }\r\n+                        a[i++] = decCount--;\r\n+                    }\r\n+                    period += m;\r\n+                }\r\n+            }\r\n+        },\r\n+\r\n+        SHUFFLE {\r\n+            @Override\r\n+            void build(int[] a, int m, Random random) {\r\n+                for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\r\n+                    a[i] = random.nextInt(m) > 0 ? (j += 2) : (k += 2);\r\n+                }\r\n+            }\r\n+        };\r\n+\r\n+        abstract void build(int[] a, int m, Random random);\r\n+    }\r\n+\r\n+    private enum StructuredBuilder {\r\n+\r\n+        ASCENDING {\r\n+            @Override\r\n+            void build(int[] a, int m) {\r\n+                for (int i = 0; i < a.length; ++i) {\r\n+                    a[i] = m + i;\r\n+                }\r\n+            }\r\n+        },\r\n+\r\n+        DESCENDING {\r\n+            @Override\r\n+            void build(int[] a, int m) {\r\n+                for (int i = 0; i < a.length; ++i) {\r\n+                    a[i] = a.length - m - i;\r\n+                }\r\n+            }\r\n+        },\r\n+\r\n+        EQUAL {\r\n+            @Override\r\n+            void build(int[] a, int m) {\r\n+                Arrays.fill(a, m);\r\n+            }\r\n+        },\r\n+\r\n+        MASKED {\r\n+            @Override\r\n+            void build(int[] a, int m) {\r\n+                int mask = (m << 15) - 1;\r\n+\r\n+                for (int i = 0; i < a.length; ++i) {\r\n+                    a[i] = (i ^ 0xFF) & mask;\r\n+                }\r\n+            }\r\n+        },\r\n+\r\n+        ORGAN_PIPES {\r\n+            @Override\r\n+            void build(int[] a, int m) {\r\n+                int middle = a.length \/ (m + 1);\r\n+\r\n+                for (int i = 0; i < middle; ++i) {\r\n+                    a[i] = i;\r\n+                }\r\n+\r\n+                for (int i = middle; i < a.length; ++i) {\r\n+                    a[i] = a.length - i - 1;\r\n+                }\r\n+            }\r\n+        },\r\n+\r\n+        STAGGER {\r\n+            @Override\r\n+            void build(int[] a, int m) {\r\n+                for (int i = 0; i < a.length; ++i) {\r\n+                    a[i] = (i * m + i) % a.length;\r\n+                }\r\n+            }\r\n+        },\r\n+\r\n+        PLATEAU {\r\n+            @Override\r\n+            void build(int[] a, int m) {\r\n+                for (int i = 0; i < a.length; ++i) {\r\n+                    a[i] = Math.min(i, m);\r\n+                }\r\n+            }\r\n+        },\r\n+\r\n+        LATCH {\r\n+            @Override\r\n+            void build(int[] a, int m) {\r\n+                int max = a.length \/ m;\r\n+                max = Math.max(max, 2);\r\n+\r\n+                for (int i = 0; i < a.length; ++i) {\r\n+                    a[i] = i % max;\r\n+                }\r\n+            }\r\n+        },\r\n+\r\n+        POINT {\r\n+            @Override\r\n+            void build(int[] a, int m) {\r\n+                Arrays.fill(a, 0);\r\n+                a[a.length \/ 2] = m;\r\n+            }\r\n+        },\r\n+\r\n+        LINE {\r\n+            @Override\r\n+            void build(int[] a, int m) {\r\n+                for (int i = 0; i < a.length; ++i) {\r\n+                    a[i] = i;\r\n+                }\r\n+                reverse(a, m, a.length - 1);\r\n+            }\r\n+        },\r\n+\r\n+        PEARL {\r\n+            @Override\r\n+            void build(int[] a, int m) {\r\n+                for (int i = 0; i < a.length; ++i) {\r\n+                    a[i] = i;\r\n+                }\r\n+                reverse(a, 0, Math.min(m, a.length));\r\n+            }\r\n+        },\r\n+\r\n+        RING {\r\n+            @Override\r\n+            void build(int[] a, int m) {\r\n+                int k1 = a.length \/ 3;\r\n+                int k2 = a.length \/ 3 * 2;\r\n+                int level = a.length \/ 3;\r\n+\r\n+                for (int i = 0, k = level; i < k1; ++i) {\r\n+                    a[i] = k--;\r\n+                }\r\n+\r\n+                for (int i = k1; i < k2; ++i) {\r\n+                    a[i] = 0;\r\n+                }\r\n+\r\n+                for (int i = k2, k = level; i < a.length; ++i) {\r\n+                    a[i] = k--;\r\n+                }\r\n+            }\r\n+        };\r\n+\r\n+        abstract void build(int[] a, int m);\r\n+\r\n+        private static void reverse(int[] a, int lo, int hi) {\r\n+            for (--hi; lo < hi; ) {\r\n+                int tmp = a[lo];\r\n+                a[lo++] = a[hi];\r\n+                a[hi--] = tmp;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private enum NegativeZeroBuilder {\r\n+\r\n+        FLOAT {\r\n+            @Override\r\n+            void build(Object o, Random random) {\r\n+                float[] a = (float[]) o;\r\n+\r\n+                for (int i = 0; i < a.length; ++i) {\r\n+                    a[i] = random.nextBoolean() ? -0.0f : 0.0f;\r\n+                }\r\n+            }\r\n+        },\r\n+\r\n+        DOUBLE {\r\n+            @Override\r\n+            void build(Object o, Random random) {\r\n+                double[] a = (double[]) o;\r\n+\r\n+                for (int i = 0; i < a.length; ++i) {\r\n+                    a[i] = random.nextBoolean() ? -0.0d : 0.0d;\r\n+                }\r\n+            }\r\n+        };\r\n+\r\n+        abstract void build(Object o, Random random);\r\n+    }\r\n+\r\n+    private enum FloatingPointBuilder {\r\n+\r\n+        FLOAT {\r\n+            @Override\r\n+            void build(Object o, int a, int g, int z, int n, int p, Random random) {\r\n+                float negativeValue = -random.nextFloat();\r\n+                float positiveValue =  random.nextFloat();\r\n+                float[] data = (float[]) o;\r\n+                int fromIndex = 0;\r\n+\r\n+                fillWithValue(data, Float.NEGATIVE_INFINITY, fromIndex, 1);\r\n+                fromIndex += 1;\r\n+\r\n+                fillWithValue(data, -Float.MAX_VALUE, fromIndex, 1);\r\n+                fromIndex += 1;\r\n+\r\n+                fillWithValue(data, negativeValue, fromIndex, n);\r\n+                fromIndex += n;\r\n+\r\n+                fillWithValue(data, -0.0f, fromIndex, g);\r\n+                fromIndex += g;\r\n+\r\n+                fillWithValue(data, 0.0f, fromIndex, z);\r\n+                fromIndex += z;\r\n+\r\n+                fillWithValue(data, positiveValue, fromIndex, p);\r\n+                fromIndex += p;\r\n+\r\n+                fillWithValue(data, Float.MAX_VALUE, fromIndex, 1);\r\n+                fromIndex += 1;\r\n+\r\n+                fillWithValue(data, Float.POSITIVE_INFINITY, fromIndex, 1);\r\n+                fromIndex += 1;\r\n+\r\n+                fillWithValue(data, Float.NaN, fromIndex, a);\r\n+            }\r\n+        },\r\n+\r\n+        DOUBLE {\r\n+            @Override\r\n+            void build(Object o, int a, int g, int z, int n, int p, Random random) {\r\n+                double negativeValue = -random.nextFloat();\r\n+                double positiveValue =  random.nextFloat();\r\n+                double[] data = (double[]) o;\r\n+                int fromIndex = 0;\r\n+\r\n+                fillWithValue(data, Double.NEGATIVE_INFINITY, fromIndex, 1);\r\n+                fromIndex++;\r\n+\r\n+                fillWithValue(data, -Double.MAX_VALUE, fromIndex, 1);\r\n+                fromIndex++;\r\n+\r\n+                fillWithValue(data, negativeValue, fromIndex, n);\r\n+                fromIndex += n;\r\n+\r\n+                fillWithValue(data, -0.0d, fromIndex, g);\r\n+                fromIndex += g;\r\n+\r\n+                fillWithValue(data, 0.0d, fromIndex, z);\r\n+                fromIndex += z;\r\n+\r\n+                fillWithValue(data, positiveValue, fromIndex, p);\r\n+                fromIndex += p;\r\n+\r\n+                fillWithValue(data, Double.MAX_VALUE, fromIndex, 1);\r\n+                fromIndex += 1;\r\n+\r\n+                fillWithValue(data, Double.POSITIVE_INFINITY, fromIndex, 1);\r\n+                fromIndex += 1;\r\n+\r\n+                fillWithValue(data, Double.NaN, fromIndex, a);\r\n+            }\r\n+        };\r\n+\r\n+        abstract void build(Object o, int a, int g, int z, int n, int p, Random random);\r\n+\r\n+        private static void fillWithValue(float[] a, float value, int fromIndex, int count) {\r\n+            for (int i = fromIndex; i < fromIndex + count; ++i) {\r\n+                a[i] = value;\r\n+            }\r\n+        }\r\n+\r\n+        private static void fillWithValue(double[] a, double value, int fromIndex, int count) {\r\n+            for (int i = fromIndex; i < fromIndex + count; ++i) {\r\n+                a[i] = value;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private static class TestRandom extends Random {\r\n+\r\n+        private static final TestRandom DEDA = new TestRandom(0xDEDA);\r\n+        private static final TestRandom BABA = new TestRandom(0xBABA);\r\n+        private static final TestRandom C0FFEE = new TestRandom(0xC0FFEE);\r\n+\r\n+        private TestRandom(long seed) {\r\n+            super(seed);\r\n+            this.seed = Long.toHexString(seed).toUpperCase();\r\n+        }\r\n+\r\n+        @Override\r\n+        public String toString() {\r\n+            return seed;\r\n+        }\r\n+\r\n+        private final String seed;\r\n+    }\r\n+}\r\n","filename":"test\/jdk\/java\/util\/Arrays\/Sorting.java","additions":1798,"deletions":2016,"binary":false,"changes":3814,"status":"modified"},{"patch":"@@ -1,352 +1,331 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.util;\n-\n-\/**\n- * This class provides access to package-private\n- * methods of DualPivotQuicksort class.\n- *\n- * @author Vladimir Yaroslavskiy\n- *\n- * @version 2019.09.19\n- *\n- * @since 14\n- *\/\n-public enum SortingHelper {\n-\n-    DUAL_PIVOT_QUICKSORT(\"Dual-Pivot Quicksort\") {\n-\n-        @Override\n-        public void sort(Object a) {\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort((int[]) a, SEQUENTIAL, 0, ((int[]) a).length);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort((long[]) a, SEQUENTIAL, 0, ((long[]) a).length);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, 0, ((byte[]) a).length);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, SEQUENTIAL, 0, ((char[]) a).length);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, SEQUENTIAL, 0, ((short[]) a).length);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort((float[]) a, SEQUENTIAL, 0, ((float[]) a).length);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort((double[]) a, SEQUENTIAL, 0, ((double[]) a).length);\n-            } else {\n-                fail(a);\n-            }\n-        }\n-\n-        @Override\n-        public void sort(Object a, int low, int high) {\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort((int[]) a, SEQUENTIAL, low, high);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort((long[]) a, SEQUENTIAL, low, high);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, low, high);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, SEQUENTIAL, low, high);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, SEQUENTIAL, low, high);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort((float[]) a, SEQUENTIAL, low, high);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort((double[]) a, SEQUENTIAL, low, high);\n-            } else {\n-                fail(a);\n-            }\n-        }\n-\n-        @Override\n-        public void sort(Object[] a) {\n-            fail(a);\n-        }\n-\n-        @Override\n-        public void sort(Object[] a, Comparator comparator) {\n-            fail(a);\n-        }\n-    },\n-\n-    PARALLEL_SORT(\"Parallel sort\") {\n-\n-        @Override\n-        public void sort(Object a) {\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort((int[]) a, PARALLEL, 0, ((int[]) a).length);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort((long[]) a, PARALLEL, 0, ((long[]) a).length);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, 0, ((byte[]) a).length);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, PARALLEL, 0, ((char[]) a).length);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, PARALLEL, 0, ((short[]) a).length);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort((float[]) a, PARALLEL, 0, ((float[]) a).length);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort((double[]) a, PARALLEL, 0, ((double[]) a).length);\n-            } else {\n-                fail(a);\n-            }\n-        }\n-\n-        @Override\n-        public void sort(Object a, int low, int high) {\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort((int[]) a, PARALLEL, low, high);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort((long[]) a, PARALLEL, low, high);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, low, high);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, PARALLEL, low, high);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, PARALLEL, low, high);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort((float[]) a, PARALLEL, low, high);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort((double[]) a, PARALLEL, low, high);\n-            } else {\n-                fail(a);\n-            }\n-        }\n-\n-        @Override\n-        public void sort(Object[] a) {\n-            fail(a);\n-        }\n-\n-        @Override\n-        public void sort(Object[] a, Comparator comparator) {\n-            fail(a);\n-        }\n-    },\n-\n-    HEAP_SORT(\"Heap sort\") {\n-\n-        @Override\n-        public void sort(Object a) {\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort(null, (int[]) a, BIG_DEPTH, 0, ((int[]) a).length);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort(null, (long[]) a, BIG_DEPTH, 0, ((long[]) a).length);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, 0, ((byte[]) a).length);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, BIG_DEPTH, 0, ((char[]) a).length);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, BIG_DEPTH, 0, ((short[]) a).length);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort(null, (float[]) a, BIG_DEPTH, 0, ((float[]) a).length);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort(null, (double[]) a, BIG_DEPTH, 0, ((double[]) a).length);\n-            } else {\n-                fail(a);\n-            }\n-        }\n-\n-        @Override\n-        public void sort(Object a, int low, int high) {\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort(null, (int[]) a, BIG_DEPTH, low, high);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort(null, (long[]) a, BIG_DEPTH, low, high);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, low, high);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, BIG_DEPTH, low, high);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, BIG_DEPTH, low, high);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort(null, (float[]) a, BIG_DEPTH, low, high);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort(null, (double[]) a, BIG_DEPTH, low, high);\n-            } else {\n-                fail(a);\n-            }\n-        }\n-\n-        @Override\n-        public void sort(Object[] a) {\n-            fail(a);\n-        }\n-\n-        @Override\n-        public void sort(Object[] a, Comparator comparator) {\n-            fail(a);\n-        }\n-    },\n-\n-    ARRAYS_SORT(\"Arrays.sort\") {\n-\n-        @Override\n-        public void sort(Object a) {\n-            if (a instanceof int[]) {\n-                Arrays.sort((int[]) a);\n-            } else if (a instanceof long[]) {\n-                Arrays.sort((long[]) a);\n-            } else if (a instanceof byte[]) {\n-                Arrays.sort((byte[]) a);\n-            } else if (a instanceof char[]) {\n-                Arrays.sort((char[]) a);\n-            } else if (a instanceof short[]) {\n-                Arrays.sort((short[]) a);\n-            } else if (a instanceof float[]) {\n-                Arrays.sort((float[]) a);\n-            } else if (a instanceof double[]) {\n-                Arrays.sort((double[]) a);\n-            } else {\n-                fail(a);\n-            }\n-        }\n-\n-        @Override\n-        public void sort(Object a, int low, int high) {\n-            if (a instanceof int[]) {\n-                Arrays.sort((int[]) a, low, high);\n-            } else if (a instanceof long[]) {\n-                Arrays.sort((long[]) a, low, high);\n-            } else if (a instanceof byte[]) {\n-                Arrays.sort((byte[]) a, low, high);\n-            } else if (a instanceof char[]) {\n-                Arrays.sort((char[]) a, low, high);\n-            } else if (a instanceof short[]) {\n-                Arrays.sort((short[]) a, low, high);\n-            } else if (a instanceof float[]) {\n-                Arrays.sort((float[]) a, low, high);\n-            } else if (a instanceof double[]) {\n-                Arrays.sort((double[]) a, low, high);\n-            } else {\n-                fail(a);\n-            }\n-        }\n-\n-        @Override\n-        public void sort(Object[] a) {\n-            Arrays.sort(a);\n-        }\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public void sort(Object[] a, Comparator comparator) {\n-            Arrays.sort(a, comparator);\n-        }\n-    },\n-\n-    ARRAYS_PARALLEL_SORT(\"Arrays.parallelSort\") {\n-\n-        @Override\n-        public void sort(Object a) {\n-            if (a instanceof int[]) {\n-                Arrays.parallelSort((int[]) a);\n-            } else if (a instanceof long[]) {\n-                Arrays.parallelSort((long[]) a);\n-            } else if (a instanceof byte[]) {\n-                Arrays.parallelSort((byte[]) a);\n-            } else if (a instanceof char[]) {\n-                Arrays.parallelSort((char[]) a);\n-            } else if (a instanceof short[]) {\n-                Arrays.parallelSort((short[]) a);\n-            } else if (a instanceof float[]) {\n-                Arrays.parallelSort((float[]) a);\n-            } else if (a instanceof double[]) {\n-                Arrays.parallelSort((double[]) a);\n-            } else {\n-                fail(a);\n-            }\n-        }\n-\n-        @Override\n-        public void sort(Object a, int low, int high) {\n-            if (a instanceof int[]) {\n-                Arrays.parallelSort((int[]) a, low, high);\n-            } else if (a instanceof long[]) {\n-                Arrays.parallelSort((long[]) a, low, high);\n-            } else if (a instanceof byte[]) {\n-                Arrays.parallelSort((byte[]) a, low, high);\n-            } else if (a instanceof char[]) {\n-                Arrays.parallelSort((char[]) a, low, high);\n-            } else if (a instanceof short[]) {\n-                Arrays.parallelSort((short[]) a, low, high);\n-            } else if (a instanceof float[]) {\n-                Arrays.parallelSort((float[]) a, low, high);\n-            } else if (a instanceof double[]) {\n-                Arrays.parallelSort((double[]) a, low, high);\n-            } else {\n-                fail(a);\n-            }\n-        }\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public void sort(Object[] a) {\n-            Arrays.parallelSort((Comparable[]) a);\n-        }\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public void sort(Object[] a, Comparator comparator) {\n-            Arrays.parallelSort(a, comparator);\n-        }\n-    };\n-\n-    abstract public void sort(Object a);\n-\n-    abstract public void sort(Object a, int low, int high);\n-\n-    abstract public void sort(Object[] a);\n-\n-    abstract public void sort(Object[] a, Comparator comparator);\n-\n-    private SortingHelper(String name) {\n-        this.name = name;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return name;\n-    }\n-\n-    private static void fail(Object a) {\n-        throw new RuntimeException(\"Unexpected type of array: \" + a.getClass().getName());\n-    }\n-\n-    private String name;\n-\n-    \/**\n-     * Parallelism level for sequential and parallel sorting.\n-     *\/\n-    private static final int SEQUENTIAL = 0;\n-    private static final int PARALLEL = 87;\n-\n-    \/**\n-     * Heap sort will be invoked, if recursion depth is too big.\n-     * Value is taken from DualPivotQuicksort.MAX_RECURSION_DEPTH.\n-     *\/\n-    private static final int BIG_DEPTH = 64 * (3 << 1);\n-}\n+\/*\r\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\r\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+ *\r\n+ * This code is free software; you can redistribute it and\/or modify it\r\n+ * under the terms of the GNU General Public License version 2 only, as\r\n+ * published by the Free Software Foundation.\r\n+ *\r\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+ * version 2 for more details (a copy is included in the LICENSE file that\r\n+ * accompanied this code).\r\n+ *\r\n+ * You should have received a copy of the GNU General Public License version\r\n+ * 2 along with this work; if not, write to the Free Software Foundation,\r\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+ *\r\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+ * or visit www.oracle.com if you need additional information or have any\r\n+ * questions.\r\n+ *\/\r\n+\r\n+package java.util;\r\n+\r\n+\/**\r\n+ * This class provides access to package-private\r\n+ * methods of DualPivotQuicksort class.\r\n+ *\r\n+ * @author Vladimir Yaroslavskiy\r\n+ *\r\n+ * @version 2022.06.14\r\n+ *\r\n+ * @since 14 ^ 22\r\n+ *\/\r\n+public enum SortingHelper {\r\n+\r\n+    DUAL_PIVOT_QUICKSORT(\"Dual-Pivot Quicksort\") {\r\n+        @Override\r\n+        public void sort(Object a, int low, int high) {\r\n+            sort(a, SEQUENTIAL, low, high);\r\n+        }\r\n+    },\r\n+\r\n+    PARALLEL_SORT(\"Parallel sort\") {\r\n+        @Override\r\n+        public void sort(Object a, int low, int high) {\r\n+            sort(a, PARALLEL, low, high);\r\n+        }\r\n+    },\r\n+\r\n+    MIXED_INSERTION_SORT(\"Mixed insertion sort\") {\r\n+        @Override\r\n+        public void sort(Object a, int low, int high) {\r\n+            if (a instanceof int[]) {\r\n+                DualPivotQuicksort.mixedInsertionSort((int[]) a, low, high);\r\n+            } else if (a instanceof long[]) {\r\n+                DualPivotQuicksort.mixedInsertionSort((long[]) a, low, high);\r\n+            } else if (a instanceof byte[]) {\r\n+                DualPivotQuicksort.sort((byte[]) a, low, high);\r\n+            } else if (a instanceof char[]) {\r\n+                DualPivotQuicksort.sort((char[]) a, low, high);\r\n+            } else if (a instanceof short[]) {\r\n+                DualPivotQuicksort.sort((short[]) a, low, high);\r\n+            } else if (a instanceof float[]) {\r\n+                DualPivotQuicksort.mixedInsertionSort((float[]) a, low, high);\r\n+            } else if (a instanceof double[]) {\r\n+                DualPivotQuicksort.mixedInsertionSort((double[]) a, low, high);\r\n+            } else {\r\n+                fail(a);\r\n+            }\r\n+        }\r\n+    },\r\n+\r\n+    INSERTION_SORT(\"Insertion sort\") {\r\n+        @Override\r\n+        public void sort(Object a, int low, int high) {\r\n+            if (a instanceof int[]) {\r\n+                DualPivotQuicksort.insertionSort((int[]) a, low, high);\r\n+            } else if (a instanceof long[]) {\r\n+                DualPivotQuicksort.insertionSort((long[]) a, low, high);\r\n+            } else if (a instanceof byte[]) {\r\n+                DualPivotQuicksort.insertionSort((byte[]) a, low, high);\r\n+            } else if (a instanceof char[]) {\r\n+                DualPivotQuicksort.insertionSort((char[]) a, low, high);\r\n+            } else if (a instanceof short[]) {\r\n+                DualPivotQuicksort.insertionSort((short[]) a, low, high);\r\n+            } else if (a instanceof float[]) {\r\n+                DualPivotQuicksort.insertionSort((float[]) a, low, high);\r\n+            } else if (a instanceof double[]) {\r\n+                DualPivotQuicksort.insertionSort((double[]) a, low, high);\r\n+            } else {\r\n+                fail(a);\r\n+            }\r\n+        }\r\n+    },\r\n+\r\n+    MERGING_SORT(\"Merging sort\") {\r\n+        @Override\r\n+        public void sort(Object a, int low, int high) {\r\n+            if (a instanceof int[]) {\r\n+                check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, (int[]) a, low, high - low));\r\n+            } else if (a instanceof long[]) {\r\n+                check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, (long[]) a, low, high - low));\r\n+            } else if (a instanceof byte[]) {\r\n+                DualPivotQuicksort.sort((byte[]) a, low, high);\r\n+            } else if (a instanceof char[]) {\r\n+                DualPivotQuicksort.sort((char[]) a, low, high);\r\n+            } else if (a instanceof short[]) {\r\n+                DualPivotQuicksort.sort((short[]) a, low, high);\r\n+            } else if (a instanceof float[]) {\r\n+                check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, (float[]) a, low, high - low));\r\n+            } else if (a instanceof double[]) {\r\n+                check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, (double[]) a, low, high - low));\r\n+            } else {\r\n+                fail(a);\r\n+            }\r\n+        }\r\n+    },\r\n+\r\n+    RADIX_SORT(\"Radix sort\") {\r\n+        @Override\r\n+        public void sort(Object a, int low, int high) {\r\n+            if (a instanceof int[]) {\r\n+                check(\"Radix\", DualPivotQuicksort.tryRadixSort(null, (int[]) a, low, high));\r\n+            } else if (a instanceof long[]) {\r\n+                check(\"Radix\", DualPivotQuicksort.tryRadixSort(null, (long[]) a, low, high));\r\n+            } else if (a instanceof byte[]) {\r\n+                DualPivotQuicksort.sort((byte[]) a, low, high);\r\n+            } else if (a instanceof char[]) {\r\n+                DualPivotQuicksort.sort((char[]) a, low, high);\r\n+            } else if (a instanceof short[]) {\r\n+                DualPivotQuicksort.sort((short[]) a, low, high);\r\n+            } else if (a instanceof float[]) {\r\n+                check(\"Radix\", DualPivotQuicksort.tryRadixSort(null, (float[]) a, low, high));\r\n+            } else if (a instanceof double[]) {\r\n+                check(\"Radix\", DualPivotQuicksort.tryRadixSort(null, (double[]) a, low, high));\r\n+            } else {\r\n+                fail(a);\r\n+            }\r\n+        }\r\n+    },\r\n+\r\n+    HEAP_SORT(\"Heap sort\") {\r\n+        @Override\r\n+        public void sort(Object a, int low, int high) {\r\n+            if (a instanceof int[]) {\r\n+                DualPivotQuicksort.heapSort((int[]) a, low, high);\r\n+            } else if (a instanceof long[]) {\r\n+                DualPivotQuicksort.heapSort((long[]) a, low, high);\r\n+            } else if (a instanceof byte[]) {\r\n+                DualPivotQuicksort.sort((byte[]) a, low, high);\r\n+            } else if (a instanceof char[]) {\r\n+                DualPivotQuicksort.sort((char[]) a, low, high);\r\n+            } else if (a instanceof short[]) {\r\n+                DualPivotQuicksort.sort((short[]) a, low, high);\r\n+            } else if (a instanceof float[]) {\r\n+                DualPivotQuicksort.heapSort((float[]) a, low, high);\r\n+            } else if (a instanceof double[]) {\r\n+                DualPivotQuicksort.heapSort((double[]) a, low, high);\r\n+            } else {\r\n+                fail(a);\r\n+            }\r\n+        }\r\n+    },\r\n+\r\n+    ARRAYS_SORT(\"Arrays.sort\") {\r\n+        @Override\r\n+        public void sort(Object a) {\r\n+            if (a instanceof int[]) {\r\n+                Arrays.sort((int[]) a);\r\n+            } else if (a instanceof long[]) {\r\n+                Arrays.sort((long[]) a);\r\n+            } else if (a instanceof byte[]) {\r\n+                Arrays.sort((byte[]) a);\r\n+            } else if (a instanceof char[]) {\r\n+                Arrays.sort((char[]) a);\r\n+            } else if (a instanceof short[]) {\r\n+                Arrays.sort((short[]) a);\r\n+            } else if (a instanceof float[]) {\r\n+                Arrays.sort((float[]) a);\r\n+            } else if (a instanceof double[]) {\r\n+                Arrays.sort((double[]) a);\r\n+            } else {\r\n+                fail(a);\r\n+            }\r\n+        }\r\n+\r\n+        @Override\r\n+        public void sort(Object a, int low, int high) {\r\n+            if (a instanceof int[]) {\r\n+                Arrays.sort((int[]) a, low, high);\r\n+            } else if (a instanceof long[]) {\r\n+                Arrays.sort((long[]) a, low, high);\r\n+            } else if (a instanceof byte[]) {\r\n+                Arrays.sort((byte[]) a, low, high);\r\n+            } else if (a instanceof char[]) {\r\n+                Arrays.sort((char[]) a, low, high);\r\n+            } else if (a instanceof short[]) {\r\n+                Arrays.sort((short[]) a, low, high);\r\n+            } else if (a instanceof float[]) {\r\n+                Arrays.sort((float[]) a, low, high);\r\n+            } else if (a instanceof double[]) {\r\n+                Arrays.sort((double[]) a, low, high);\r\n+            } else {\r\n+                fail(a);\r\n+            }\r\n+        }\r\n+    },\r\n+\r\n+    ARRAYS_PARALLEL_SORT(\"Arrays.parallelSort\") {\r\n+        @Override\r\n+        public void sort(Object a) {\r\n+            if (a instanceof int[]) {\r\n+                Arrays.parallelSort((int[]) a);\r\n+            } else if (a instanceof long[]) {\r\n+                Arrays.parallelSort((long[]) a);\r\n+            } else if (a instanceof byte[]) {\r\n+                Arrays.parallelSort((byte[]) a);\r\n+            } else if (a instanceof char[]) {\r\n+                Arrays.parallelSort((char[]) a);\r\n+            } else if (a instanceof short[]) {\r\n+                Arrays.parallelSort((short[]) a);\r\n+            } else if (a instanceof float[]) {\r\n+                Arrays.parallelSort((float[]) a);\r\n+            } else if (a instanceof double[]) {\r\n+                Arrays.parallelSort((double[]) a);\r\n+            } else {\r\n+                fail(a);\r\n+            }\r\n+        }\r\n+\r\n+        @Override\r\n+        public void sort(Object a, int low, int high) {\r\n+            if (a instanceof int[]) {\r\n+                Arrays.parallelSort((int[]) a, low, high);\r\n+            } else if (a instanceof long[]) {\r\n+                Arrays.parallelSort((long[]) a, low, high);\r\n+            } else if (a instanceof byte[]) {\r\n+                Arrays.parallelSort((byte[]) a, low, high);\r\n+            } else if (a instanceof char[]) {\r\n+                Arrays.parallelSort((char[]) a, low, high);\r\n+            } else if (a instanceof short[]) {\r\n+                Arrays.parallelSort((short[]) a, low, high);\r\n+            } else if (a instanceof float[]) {\r\n+                Arrays.parallelSort((float[]) a, low, high);\r\n+            } else if (a instanceof double[]) {\r\n+                Arrays.parallelSort((double[]) a, low, high);\r\n+            } else {\r\n+                fail(a);\r\n+            }\r\n+        }\r\n+    };\r\n+\r\n+    abstract public void sort(Object a, int low, int high);\r\n+\r\n+    public void sort(Object a) {\r\n+        if (a instanceof int[]) {\r\n+            sort(a, 0, ((int[]) a).length);\r\n+        } else if (a instanceof long[]) {\r\n+            sort(a, 0, ((long[]) a).length);\r\n+        } else if (a instanceof byte[]) {\r\n+            sort(a, 0, ((byte[]) a).length);\r\n+        } else if (a instanceof char[]) {\r\n+            sort(a, 0, ((char[]) a).length);\r\n+        } else if (a instanceof short[]) {\r\n+            sort(a, 0, ((short[]) a).length);\r\n+        } else if (a instanceof float[]) {\r\n+            sort(a, 0, ((float[]) a).length);\r\n+        } else if (a instanceof double[]) {\r\n+            sort(a, 0, ((double[]) a).length);\r\n+        } else {\r\n+            fail(a);\r\n+        }\r\n+    }\r\n+\r\n+    SortingHelper(String name) {\r\n+        this.name = name;\r\n+    }\r\n+\r\n+    @Override\r\n+    public String toString() {\r\n+        return name;\r\n+    }\r\n+\r\n+    static void sort(Object a, int parallelism, int low, int high) {\r\n+        if (a instanceof int[]) {\r\n+            DualPivotQuicksort.sort((int[]) a, parallelism, low, high);\r\n+        } else if (a instanceof long[]) {\r\n+            DualPivotQuicksort.sort((long[]) a, parallelism, low, high);\r\n+        } else if (a instanceof byte[]) {\r\n+            DualPivotQuicksort.sort((byte[]) a, low, high);\r\n+        } else if (a instanceof char[]) {\r\n+            DualPivotQuicksort.sort((char[]) a, low, high);\r\n+        } else if (a instanceof short[]) {\r\n+            DualPivotQuicksort.sort((short[]) a, low, high);\r\n+        } else if (a instanceof float[]) {\r\n+            DualPivotQuicksort.sort((float[]) a, parallelism, low, high);\r\n+        } else if (a instanceof double[]) {\r\n+            DualPivotQuicksort.sort((double[]) a, parallelism, low, high);\r\n+        } else {\r\n+            fail(a);\r\n+        }\r\n+    }\r\n+\r\n+    private static void check(String name, boolean result) {\r\n+        if (!result) {\r\n+            fail(name + \" sort must return true\");\r\n+        }\r\n+    }\r\n+\r\n+    private static void fail(Object a) {\r\n+        fail(\"Unknown array: \" + a.getClass().getName());\r\n+    }\r\n+\r\n+    private static void fail(String message) {\r\n+        throw new RuntimeException(message);\r\n+    }\r\n+\r\n+    private final String name;\r\n+\r\n+    \/**\r\n+     * Parallelism level for sequential sorting.\r\n+     *\/\r\n+    private static final int SEQUENTIAL = 0;\r\n+\r\n+    \/**\r\n+     * Parallelism level for parallel sorting.\r\n+     *\/\r\n+    private static final int PARALLEL = 88;\r\n+}\r\n","filename":"test\/jdk\/java\/util\/Arrays\/java.base\/java\/util\/SortingHelper.java","additions":331,"deletions":352,"binary":false,"changes":683,"status":"modified"},{"patch":"@@ -0,0 +1,311 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.util;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+\/**\n+ * Microbenchmark for Arrays.sort() and Arrays.parallelSort().\n+ *\n+ * @author Vladimir Yaroslavskiy\n+ *\n+ * @version 2022.06.14\n+ *\n+ * @since 22\n+ *\/\n+@Fork(1)\n+@State(Scope.Benchmark)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@Warmup(iterations = 1, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 3, timeUnit = TimeUnit.SECONDS)\n+public class ArraysSort {\n+\n+    @Param({ \"800\", \"7000\", \"50000\", \"300000\", \"2000000\" })\n+    int size;\n+\n+    @Param\n+    Builder builder;\n+\n+    int[] b;\n+\n+    @Setup\n+    public void init() {\n+        b = new int[size];\n+    }\n+\n+    public enum Builder {\n+\n+        RANDOM {\n+            @Override\n+            void build(int[] b) {\n+                Random random = new Random(0x777);\n+\n+                for (int i = 0; i < b.length; ++i) {\n+                    b[i] = random.nextInt();\n+                }\n+            }\n+        },\n+\n+        REPEATED {\n+            @Override\n+            void build(int[] b) {\n+                Random random = new Random(0x777);\n+\n+                for (int i = 0; i < b.length; ++i) {\n+                    b[i] = random.nextInt(4);\n+                }\n+            }\n+        },\n+\n+        STAGGER {\n+            @Override\n+            void build(int[] b) {\n+                for (int i = 0; i < b.length; ++i) {\n+                    b[i] = (i * 3) % b.length;\n+                }\n+            }\n+        },\n+\n+        SHUFFLE {\n+            @Override\n+            void build(int[] b) {\n+                Random random = new Random(0x777);\n+\n+                for (int i = 0, j = 0, k = 1; i < b.length; ++i) {\n+                    b[i] = random.nextInt(6) > 0 ? (j += 2) : (k += 2);\n+                }\n+            }\n+        };\n+\n+        abstract void build(int[] b);\n+    }\n+\n+    public static class Int extends ArraysSort {\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(b);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(b);\n+        }\n+    }\n+\n+    public static class Long extends ArraysSort {\n+\n+        long[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new long[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(a);\n+        }\n+    }\n+\n+    public static class Byte extends ArraysSort {\n+\n+        byte[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new byte[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = (byte) b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(a);\n+        }\n+    }\n+\n+    public static class Char extends ArraysSort {\n+\n+        char[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new char[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = (char) b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(a);\n+        }\n+    }\n+\n+    public static class Short extends ArraysSort {\n+\n+        short[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new short[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = (short) b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(a);\n+        }\n+    }\n+\n+    public static class Float extends ArraysSort {\n+\n+        float[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new float[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(a);\n+        }\n+    }\n+\n+    public static class Double extends ArraysSort {\n+\n+        double[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new double[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(a);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/ArraysSort.java","additions":311,"deletions":0,"binary":false,"changes":311,"status":"added"}]}