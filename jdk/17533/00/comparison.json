{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,11 +78,0 @@\n-\/\/ Convert OopHandle to oop*\n-\n-template<>\n-struct PrimitiveConversions::Translate<OopHandle> : public std::true_type {\n-  typedef OopHandle Value;\n-  typedef oop* Decayed;\n-\n-  static Decayed decay(Value x) { return x.ptr_raw(); }\n-  static Value recover(Decayed x) { return OopHandle(x); }\n-};\n-\n","filename":"src\/hotspot\/share\/oops\/oopHandle.hpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,7 @@\n-MemoryManager::MemoryManager(const char* name) :\n-  _num_pools(0), _name(name) {}\n+MemoryManager::MemoryManager(const char* name)\n+  : _pools(),\n+    _num_pools(0),\n+    _name(name),\n+    _memory_mgr_obj(),\n+    _memory_mgr_obj_initialized(false)\n+{}\n@@ -59,1 +64,5 @@\n-  return mh() == Atomic::load(&_memory_mgr_obj).resolve();\n+  if (Atomic::load_acquire(&_memory_mgr_obj_initialized)) {\n+    return mh() == _memory_mgr_obj.resolve();\n+  } else {\n+    return false;\n+  }\n@@ -71,0 +80,1 @@\n+  \/\/ Lazily create the manager object.\n@@ -73,2 +83,1 @@\n-  oop mgr_obj = Atomic::load_acquire(&_memory_mgr_obj).resolve();\n-  if (mgr_obj == nullptr) {\n+  if (!Atomic::load_acquire(&_memory_mgr_obj_initialized)) {\n@@ -117,24 +126,25 @@\n-    instanceOop m = (instanceOop) result.get_oop();\n-    instanceHandle mgr(THREAD, m);\n-\n-    {\n-      \/\/ Get lock before setting _memory_mgr_obj\n-      \/\/ since another thread may have created the instance\n-      MutexLocker ml(THREAD, Management_lock);\n-\n-      \/\/ Check if another thread has created the management object.  We reload\n-      \/\/ _memory_mgr_obj here because some other thread may have initialized\n-      \/\/ it while we were executing the code before the lock.\n-      mgr_obj = Atomic::load(&_memory_mgr_obj).resolve();\n-      if (mgr_obj != nullptr) {\n-         return (instanceOop)mgr_obj;\n-      }\n-\n-      \/\/ Get the address of the object we created via call_special.\n-      mgr_obj = mgr();\n-\n-      \/\/ Use store barrier to make sure the memory accesses associated\n-      \/\/ with creating the management object are visible before publishing\n-      \/\/ its address.  The unlock will publish the store to _memory_mgr_obj\n-      \/\/ because it does a release first.\n-      Atomic::release_store(&_memory_mgr_obj, OopHandle(Universe::vm_global(), mgr_obj));\n+    \/\/ Verify we didn't get a null manager.  If that could happen then we'd\n+    \/\/ need to return immediately rather than continuing on and recording the\n+    \/\/ manager has been created.\n+    oop m = result.get_oop();\n+    guarantee(m != nullptr, \"Manager creation returned null\");\n+    instanceHandle mgr(THREAD, (instanceOop)m);\n+\n+    \/\/ Allocate global handle outside lock, to avoid any lock nesting issues\n+    \/\/ with the Management_lock.\n+    OopHandle mgr_handle(Universe::vm_global(), mgr());\n+\n+    \/\/ Get lock since another thread may have created and installed the instance.\n+    MutexLocker ml(THREAD, Management_lock);\n+\n+    if (Atomic::load(&_memory_mgr_obj_initialized)) {\n+      \/\/ Some other thread won the race.  Release the handle we allocated and\n+      \/\/ use the other one.  Relaxed load is sufficient because flag update is\n+      \/\/ under the lock.\n+      mgr_handle.release(Universe::vm_global());\n+    } else {\n+      \/\/ Record the object we created via call_special.\n+      _memory_mgr_obj = mgr_handle;\n+      \/\/ Record manager has been created.  Release matching unlocked acquire,\n+      \/\/ to safely publish the manager object.\n+      Atomic::release_store(&_memory_mgr_obj_initialized, true);\n@@ -144,1 +154,1 @@\n-  return (instanceOop)mgr_obj;\n+  return (instanceOop)_memory_mgr_obj.resolve();\n","filename":"src\/hotspot\/share\/services\/memoryManager.cpp","additions":41,"deletions":31,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,2 @@\n-  volatile OopHandle _memory_mgr_obj;\n+  OopHandle _memory_mgr_obj;\n+  volatile bool _memory_mgr_obj_initialized;\n@@ -62,1 +63,0 @@\n-public:\n@@ -65,0 +65,3 @@\n+public:\n+  virtual ~MemoryManager() = default; \/\/ FIXME\n+\n","filename":"src\/hotspot\/share\/services\/memoryManager.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,2 @@\n-  _memory_pool_obj()\n+  _memory_pool_obj(),\n+  _memory_pool_obj_initialized(false)\n@@ -70,1 +71,5 @@\n-  return pool() == Atomic::load(&_memory_pool_obj).resolve();\n+  if (Atomic::load_acquire(&_memory_pool_obj_initialized)) {\n+    return pool() == _memory_pool_obj.resolve();\n+  } else {\n+    return false;\n+  }\n@@ -86,0 +91,1 @@\n+  \/\/ Lazily create the pool object.\n@@ -88,2 +94,1 @@\n-  oop pool_obj = Atomic::load_acquire(&_memory_pool_obj).resolve();\n-  if (pool_obj == nullptr) {\n+  if (!Atomic::load_acquire(&_memory_pool_obj_initialized)) {\n@@ -116,23 +121,25 @@\n-    instanceOop p = (instanceOop) result.get_oop();\n-    instanceHandle pool(THREAD, p);\n-\n-    {\n-      \/\/ Get lock since another thread may have create the instance\n-      MutexLocker ml(THREAD, Management_lock);\n-\n-      \/\/ Check if another thread has created the pool.  We reload\n-      \/\/ _memory_pool_obj here because some other thread may have\n-      \/\/ initialized it while we were executing the code before the lock.\n-      pool_obj = Atomic::load(&_memory_pool_obj).resolve();\n-      if (pool_obj != nullptr) {\n-         return (instanceOop)pool_obj;\n-      }\n-\n-      \/\/ Get the address of the object we created via call_special.\n-      pool_obj = pool();\n-\n-      \/\/ Use store barrier to make sure the memory accesses associated\n-      \/\/ with creating the pool are visible before publishing its address.\n-      \/\/ The unlock will publish the store to _memory_pool_obj because\n-      \/\/ it does a release first.\n-      Atomic::release_store(&_memory_pool_obj, OopHandle(Universe::vm_global(), pool_obj));\n+    \/\/ Verify we didn't get a null pool.  If that could happen then we'd\n+    \/\/ need to return immediately rather than continuing on and recording the\n+    \/\/ pool has been created.\n+    oop p = result.get_oop();\n+    guarantee(p != nullptr, \"Pool creation returns null\");\n+    instanceHandle pool(THREAD, (instanceOop)p);\n+\n+    \/\/ Allocate global handle outside lock, to avoid any lock nesting issues\n+    \/\/ with the Management_lock.\n+    OopHandle pool_handle(Universe::vm_global(), pool());\n+\n+    \/\/ Get lock since another thread may have created and installed the instance.\n+    MutexLocker ml(THREAD, Management_lock);\n+\n+    if (Atomic::load(&_memory_pool_obj_initialized)) {\n+      \/\/ Some other thread won the race.  Release the handle we allocated and\n+      \/\/ use the other one.  Relaxed load is sufficient because flag update is\n+      \/\/ under the lock.\n+      pool_handle.release(Universe::vm_global());\n+    } else {\n+      \/\/ Record the object we created via call_special.\n+      _memory_pool_obj = pool_handle;\n+      \/\/ Record pool has been created.  Release matching unlocked acquire, to\n+      \/\/ safely publish the pool object.\n+      Atomic::release_store(&_memory_pool_obj_initialized, true);\n@@ -142,1 +149,1 @@\n-  return (instanceOop)pool_obj;\n+  return (instanceOop)_memory_pool_obj.resolve();\n","filename":"src\/hotspot\/share\/services\/memoryPool.cpp","additions":36,"deletions":29,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,2 @@\n-  volatile OopHandle _memory_pool_obj;\n+  OopHandle _memory_pool_obj;\n+  volatile bool _memory_pool_obj_initialized;\n","filename":"src\/hotspot\/share\/services\/memoryPool.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}