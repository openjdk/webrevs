{"files":[{"patch":"@@ -119,0 +119,10 @@\n+  <Event name=\"JavaMonitorDeflate\" category=\"Java Application\" label=\"Java Monitor Deflated\">\n+    <Field type=\"Class\" name=\"monitorClass\" label=\"Monitor Class\" \/>\n+    <Field type=\"ulong\" contentType=\"address\" name=\"address\" label=\"Monitor Address\" relation=\"JavaMonitorAddress\" \/>\n+  <\/Event>\n+\n+  <Event name=\"JavaMonitorStatistics\" category=\"Java Application, Statistics\" label=\"Java Monitor Statistics\" period=\"everyChunk\">\n+    <Field type=\"ulong\" name=\"count\" label=\"Monitors in Use\" description=\"Current number of in-use monitors\" \/>\n+    <Field type=\"ulong\" name=\"maxCount\" label=\"Maximum Monitors in Use\" description=\"Maximum number of in-use monitors over the entire JVM lifetime\" \/>\n+  <\/Event>\n+\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -742,0 +742,7 @@\n+\n+TRACE_REQUEST_FUNC(JavaMonitorStatistics) {\n+  EventJavaMonitorStatistics event;\n+  event.set_count(ObjectSynchronizer::in_use_list_count());\n+  event.set_maxCount(ObjectSynchronizer::in_use_list_max());\n+  event.commit();\n+}\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -372,1 +372,5 @@\n-  event->set_monitorClass(obj->klass());\n+  const Klass* monitor_klass = obj->klass();\n+  if (ObjectMonitor::is_jfr_excluded(monitor_klass)) {\n+    return;\n+  }\n+  event->set_monitorClass(monitor_klass);\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -737,0 +737,12 @@\n+static void post_monitor_deflate_event(EventJavaMonitorDeflate* event,\n+                                       const oop obj) {\n+  assert(event != nullptr, \"invariant\");\n+  const Klass* monitor_klass = obj->klass();\n+  if (ObjectMonitor::is_jfr_excluded(monitor_klass)) {\n+    return;\n+  }\n+  event->set_monitorClass(monitor_klass);\n+  event->set_address((uintptr_t)(void*)obj);\n+  event->commit();\n+}\n+\n@@ -756,0 +768,2 @@\n+  EventJavaMonitorDeflate event;\n+\n@@ -829,0 +843,4 @@\n+  if (event.should_commit()) {\n+    post_monitor_deflate_event(&event, obj);\n+  }\n+\n@@ -1631,6 +1649,0 @@\n-static inline bool is_excluded(const Klass* monitor_klass) {\n-  assert(monitor_klass != nullptr, \"invariant\");\n-  NOT_JFR_RETURN_(false);\n-  JFR_ONLY(return vmSymbols::jdk_jfr_internal_management_HiddenWait() == monitor_klass->name();)\n-}\n-\n@@ -1645,1 +1657,1 @@\n-  if (is_excluded(monitor_klass)) {\n+  if (ObjectMonitor::is_jfr_excluded(monitor_klass)) {\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -466,0 +466,4 @@\n+\n+  \/\/ JFR support\n+public:\n+  static bool is_jfr_excluded(const Klass* monitor_klass);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -289,0 +290,6 @@\n+inline bool ObjectMonitor::is_jfr_excluded(const Klass* monitor_klass) {\n+  assert(monitor_klass != nullptr, \"invariant\");\n+  NOT_JFR_RETURN_(false);\n+  JFR_ONLY(return vmSymbols::jdk_jfr_internal_management_HiddenWait() == monitor_klass->name();)\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1315,0 +1315,8 @@\n+size_t ObjectSynchronizer::in_use_list_count() {\n+  return _in_use_list.count();\n+}\n+\n+size_t ObjectSynchronizer::in_use_list_max() {\n+  return _in_use_list.max();\n+}\n+\n@@ -1422,1 +1430,5 @@\n-  event->set_monitorClass(obj->klass());\n+  const Klass* monitor_klass = obj->klass();\n+  if (ObjectMonitor::is_jfr_excluded(monitor_klass)) {\n+    return;\n+  }\n+  event->set_monitorClass(monitor_klass);\n@@ -1713,2 +1725,2 @@\n-  size_t count() const   { return ObjectSynchronizer::_in_use_list.count(); }\n-  size_t max() const     { return ObjectSynchronizer::_in_use_list.max(); }\n+  size_t count() const   { return ObjectSynchronizer::in_use_list_count(); }\n+  size_t max() const     { return ObjectSynchronizer::in_use_list_max(); }\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -190,0 +190,2 @@\n+  static size_t in_use_list_count();\n+  static size_t in_use_list_max();\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,0 +104,10 @@\n+    <event name=\"jdk.JavaMonitorDeflate\">\n+      <setting name=\"enabled\">false<\/setting>\n+      <setting name=\"threshold\">0 ms<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.JavaMonitorStatistics\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"period\">everyChunk<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -104,0 +104,10 @@\n+    <event name=\"jdk.JavaMonitorDeflate\">\n+      <setting name=\"enabled\">false<\/setting>\n+      <setting name=\"threshold\">0 ms<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.JavaMonitorStatistics\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"period\">everyChunk<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.runtime;\n+\n+import static jdk.test.lib.Asserts.assertFalse;\n+\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.jfr.consumer.RecordedClass;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.thread.TestThread;\n+import jdk.test.lib.thread.XRun;\n+\n+\/**\n+ * @test TestJavaMonitorDeflateEvent\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:GuaranteedAsyncDeflationInterval=100 jdk.jfr.event.runtime.TestJavaMonitorDeflateEvent\n+ *\/\n+public class TestJavaMonitorDeflateEvent {\n+\n+    private static final String FIELD_KLASS_NAME = \"monitorClass.name\";\n+    private static final String FIELD_ADDRESS    = \"address\";\n+\n+    private static final String EVENT_NAME = EventNames.JavaMonitorDeflate;\n+\n+    static class Lock {\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        final Lock lock = new Lock();\n+        final String lockClassName = lock.getClass().getName().replace('.', '\/');\n+\n+        List<RecordedEvent> events = new CopyOnWriteArrayList<>();\n+        try (RecordingStream rs = new RecordingStream()) {\n+            rs.enable(EVENT_NAME).withoutThreshold();\n+            rs.onEvent(EVENT_NAME, e -> {\n+                Object clazz = e.getValue(FIELD_KLASS_NAME);\n+                if (clazz.equals(lockClassName)) {\n+                    events.add(e);\n+                    rs.close();\n+                }\n+            });\n+            rs.startAsync();\n+\n+            synchronized (lock) {\n+                \/\/ Causes lock inflation.\n+                lock.wait(1);\n+            }\n+\n+            \/\/ Wait for deflater thread to act.\n+            rs.awaitTermination();\n+\n+            System.out.println(events);\n+            assertFalse(events.isEmpty());\n+            for (RecordedEvent ev : events) {\n+                Events.assertField(ev, FIELD_ADDRESS).notEqual(0L);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestJavaMonitorDeflateEvent.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.runtime;\n+\n+import static jdk.test.lib.Asserts.assertFalse;\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.jfr.consumer.RecordedClass;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.thread.TestThread;\n+import jdk.test.lib.thread.XRun;\n+\n+\/**\n+ * @test TestJavaMonitorStatisticsEvent\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.event.runtime.TestJavaMonitorStatisticsEvent\n+ *\/\n+public class TestJavaMonitorStatisticsEvent {\n+\n+    private static final String FIELD_COUNT = \"count\";\n+    private static final String FIELD_MAX_COUNT = \"maxCount\";\n+\n+    private static final String EVENT_NAME = EventNames.JavaMonitorStatistics;\n+    private static final int NUM_LOCKS = 512;\n+\n+    static class Lock {\n+    }\n+\n+    static final Lock[] LOCKS = new Lock[NUM_LOCKS];\n+\n+    static void lockNext(int idx, Runnable action) throws InterruptedException {\n+        if (idx >= NUM_LOCKS) {\n+            action.run();\n+            return;\n+        }\n+        synchronized (LOCKS[idx]) {\n+            LOCKS[idx].wait(1);\n+            lockNext(idx + 1, action);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        List<RecordedEvent> events = new CopyOnWriteArrayList<>();\n+        try (RecordingStream rs = new RecordingStream()) {\n+            rs.enable(EVENT_NAME).with(\"period\", \"everyChunk\");\n+            rs.onEvent(EVENT_NAME, e -> events.add(e));\n+            rs.startAsync();\n+\n+            \/\/ Recursively lock all, causing NUM_LOCKS monitors to exist.\n+            \/\/ Stop the recording when holding all the locks, so that we\n+            \/\/ get at least one event with NUM_LOCKS max.\n+            for (int c = 0; c < NUM_LOCKS; c++) {\n+                LOCKS[c] = new Lock();\n+            }\n+            lockNext(0, () -> rs.stop());\n+\n+            System.out.println(events);\n+            assertFalse(events.isEmpty());\n+\n+            long globalMax = Long.MIN_VALUE;\n+            long globalCount = Long.MIN_VALUE;\n+            for (RecordedEvent ev : events) {\n+                long evMaxCount = Events.assertField(ev, FIELD_MAX_COUNT).getValue();\n+                long evCount = Events.assertField(ev, FIELD_COUNT).getValue();\n+                assertTrue(evCount <= evMaxCount, \"Count should be below max: \" + evCount + \" <= \" + evMaxCount);\n+                assertTrue(evMaxCount >= 0, \"Max should be non-negative: \" + evMaxCount);\n+                assertTrue(evCount >= 0, \"Count should be non-negative: \" + evCount);\n+                globalMax = Math.max(globalMax, evMaxCount);\n+                globalCount = Math.max(globalCount, evCount);\n+            }\n+\n+            assertTrue(globalMax >= NUM_LOCKS, \"Global max should be at least \" + NUM_LOCKS + \": \" + globalMax);\n+            assertTrue(globalCount >= NUM_LOCKS, \"Global count should be at least \" + NUM_LOCKS + \": \" + globalCount);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestJavaMonitorStatisticsEvent.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -62,0 +62,2 @@\n+    public static final String JavaMonitorDeflate = PREFIX + \"JavaMonitorDeflate\";\n+    public static final String JavaMonitorStatistics = PREFIX + \"JavaMonitorStatistics\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}