{"files":[{"patch":"@@ -124,3 +124,3 @@\n-  <Event name=\"JavaMonitorStatistics\" category=\"Java Application\" label=\"Java Monitor Statistics\" startTime=\"false\">\n-    <Field type=\"ulong\" name=\"totalCount\" label=\"Monitors In Use\" description=\"Number of in-use monitors\"\/>\n-    <Field type=\"ulong\" name=\"deflatedCount\" label=\"Deflated Monitors\" description=\"Number of deflated monitors\"\/>\n+  <Event name=\"JavaMonitorStatistics\" category=\"Java Application, Statistics\" label=\"Java Monitor Statistics\" period=\"everyChunk\">\n+    <Field type=\"ulong\" name=\"count\" label=\"Monitors in Use\" description=\"Current number of in-use monitors\"\/>\n+    <Field type=\"ulong\" name=\"maxCount\" label=\"Max Monitors in Use\" description=\"Max number of in-use monitors over the entire JVM lifetime\"\/>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -742,0 +742,7 @@\n+\n+TRACE_REQUEST_FUNC(JavaMonitorStatistics) {\n+  EventJavaMonitorStatistics event;\n+  event.set_count(ObjectSynchronizer::in_use_list_count());\n+  event.set_maxCount(ObjectSynchronizer::in_use_list_max());\n+  event.commit();\n+}\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -372,1 +372,5 @@\n-  event->set_monitorClass(obj->klass());\n+  const Klass* monitor_klass = obj->klass();\n+  if (ObjectMonitor::is_jfr_excluded(monitor_klass)) {\n+    return;\n+  }\n+  event->set_monitorClass(monitor_klass);\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -663,1 +663,5 @@\n-  event->set_monitorClass(obj->klass());\n+  const Klass* monitor_klass = obj->klass();\n+  if (ObjectMonitor::is_jfr_excluded(monitor_klass)) {\n+    return;\n+  }\n+  event->set_monitorClass(monitor_klass);\n@@ -1612,6 +1616,0 @@\n-static inline bool is_excluded(const Klass* monitor_klass) {\n-  assert(monitor_klass != nullptr, \"invariant\");\n-  NOT_JFR_RETURN_(false);\n-  JFR_ONLY(return vmSymbols::jdk_jfr_internal_management_HiddenWait() == monitor_klass->name();)\n-}\n-\n@@ -1626,1 +1624,1 @@\n-  if (is_excluded(monitor_klass)) {\n+  if (ObjectMonitor::is_jfr_excluded(monitor_klass)) {\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -448,0 +448,4 @@\n+\n+  \/\/ JFR support\n+public:\n+  static bool is_jfr_excluded(const Klass* monitor_klass);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -289,0 +290,6 @@\n+inline bool ObjectMonitor::is_jfr_excluded(const Klass* monitor_klass) {\n+  assert(monitor_klass != nullptr, \"invariant\");\n+  NOT_JFR_RETURN_(false);\n+  JFR_ONLY(return vmSymbols::jdk_jfr_internal_management_HiddenWait() == monitor_klass->name();)\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1315,0 +1315,8 @@\n+size_t ObjectSynchronizer::in_use_list_count() {\n+  return _in_use_list.count();\n+}\n+\n+size_t ObjectSynchronizer::in_use_list_max() {\n+  return _in_use_list.max();\n+}\n+\n@@ -1422,1 +1430,5 @@\n-  event->set_monitorClass(obj->klass());\n+  const Klass* monitor_klass = obj->klass();\n+  if (ObjectMonitor::is_jfr_excluded(monitor_klass)) {\n+    return;\n+  }\n+  event->set_monitorClass(monitor_klass);\n@@ -1713,2 +1725,2 @@\n-  size_t count() const   { return ObjectSynchronizer::_in_use_list.count(); }\n-  size_t max() const     { return ObjectSynchronizer::_in_use_list.max(); }\n+  size_t count() const   { return ObjectSynchronizer::in_use_list_count(); }\n+  size_t max() const     { return ObjectSynchronizer::in_use_list_max(); }\n@@ -1810,2 +1822,0 @@\n-  EventJavaMonitorStatistics event;\n-\n@@ -1873,6 +1883,0 @@\n-  if (event.should_commit()) {\n-    event.set_totalCount(_in_use_list.count());\n-    event.set_deflatedCount(deflated_count);\n-    event.commit();\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -190,0 +190,2 @@\n+  static size_t in_use_list_count();\n+  static size_t in_use_list_max();\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+      <setting name=\"period\">everyChunk<\/setting>\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+      <setting name=\"period\">everyChunk<\/setting>\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.Asserts.assertFalse;\n@@ -30,1 +30,2 @@\n-import java.util.concurrent.CountDownLatch;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n@@ -33,0 +34,2 @@\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.jfr.consumer.RecordedClass;\n@@ -52,1 +55,0 @@\n-    private static final long WAIT_TIME = 123456;\n@@ -58,2 +60,0 @@\n-        Recording recording = new Recording();\n-        recording.enable(EVENT_NAME).withThreshold(Duration.ofMillis(0));\n@@ -61,8 +61,10 @@\n-        final CountDownLatch latch = new CountDownLatch(1);\n-        \/\/ create a thread that waits\n-        TestThread waitThread = new TestThread(new XRun() {\n-            @Override\n-            public void xrun() throws Throwable {\n-                synchronized (lock) {\n-                    latch.countDown();\n-                    lock.wait(WAIT_TIME);\n+        final String lockClassName = lock.getClass().getName().replace('.', '\/');\n+\n+        List<RecordedEvent> events = new CopyOnWriteArrayList<>();\n+        try (RecordingStream rs = new RecordingStream()) {\n+            rs.enable(EVENT_NAME).withoutThreshold();\n+            rs.onEvent(EVENT_NAME, e -> {\n+                Object clazz = e.getValue(FIELD_KLASS_NAME);\n+                if (clazz.equals(lockClassName)) {\n+                    events.add(e);\n+                    rs.close();\n@@ -70,6 +72,3 @@\n-            }\n-        });\n-        try {\n-            recording.start();\n-            waitThread.start();\n-            latch.await();\n+            });\n+            rs.startAsync();\n+\n@@ -77,1 +76,2 @@\n-                lock.notifyAll();\n+                \/\/ Causes lock inflation.\n+                lock.wait(1);\n@@ -79,21 +79,8 @@\n-        } finally {\n-            waitThread.join();\n-            \/\/ Let deflater thread run.\n-            Thread.sleep(3000);\n-            recording.stop();\n-        }\n-        final String lockClassName = lock.getClass().getName().replace('.', '\/');\n-        boolean isAnyFound = false;\n-        try {\n-            \/\/ Find at least one event with the correct monitor class and check the other fields\n-            for (RecordedEvent event : Events.fromRecording(recording)) {\n-                assertTrue(EVENT_NAME.equals(event.getEventType().getName()), \"mismatched event types?\");\n-                \/\/ Check recorded inflation event is associated with the Lock class used in the test\n-                final String recordedMonitorClassName = Events.assertField(event, FIELD_KLASS_NAME).getValue();\n-                if (!lockClassName.equals(recordedMonitorClassName)) {\n-                    continue;\n-                }\n-                \/\/ Check recorded thread matches one of the threads in the test\n-                Events.assertField(event, FIELD_ADDRESS).notEqual(0L);\n-                isAnyFound = true;\n-                break;\n+\n+            \/\/ Wait for deflater thread to act.\n+            rs.awaitTermination();\n+\n+            System.out.println(events);\n+            assertFalse(events.isEmpty());\n+            for (RecordedEvent ev : events) {\n+                Events.assertField(ev, FIELD_ADDRESS).notEqual(0L);\n@@ -101,6 +88,0 @@\n-            assertTrue(isAnyFound, \"Expected an deflation event from test\");\n-        } catch (Throwable e) {\n-            recording.dump(Paths.get(\"failed.jfr\"));\n-            throw e;\n-        } finally {\n-            recording.close();\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestJavaMonitorDeflateEvent.java","additions":28,"deletions":47,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import static jdk.test.lib.Asserts.assertFalse;\n@@ -30,1 +31,2 @@\n-import java.util.concurrent.CountDownLatch;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n@@ -33,0 +35,2 @@\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.jfr.consumer.RecordedClass;\n@@ -44,1 +48,1 @@\n- * @run main\/othervm -XX:GuaranteedAsyncDeflationInterval=100 jdk.jfr.event.runtime.TestJavaMonitorStatisticsEvent\n+ * @run main\/othervm jdk.jfr.event.runtime.TestJavaMonitorStatisticsEvent\n@@ -48,2 +52,2 @@\n-    private static final String FIELD_TOTAL_COUNT = \"totalCount\";\n-    private static final String FIELD_DEFLATED_COUNT = \"deflatedCount\";\n+    private static final String FIELD_COUNT = \"count\";\n+    private static final String FIELD_MAX_COUNT = \"maxCount\";\n@@ -52,1 +56,1 @@\n-    private static final long WAIT_TIME = 123456;\n+    private static final int NUM_LOCKS = 512;\n@@ -57,0 +61,13 @@\n+    static final Lock[] LOCKS = new Lock[NUM_LOCKS];\n+\n+    static void lockNext(int idx, Runnable action) throws InterruptedException {\n+        if (idx >= NUM_LOCKS) {\n+            action.run();\n+            return;\n+        }\n+        synchronized (LOCKS[idx]) {\n+            LOCKS[idx].wait(1);\n+            lockNext(idx + 1, action);\n+        }\n+    }\n+\n@@ -58,20 +75,11 @@\n-        Recording recording = new Recording();\n-        recording.enable(EVENT_NAME).withThreshold(Duration.ofMillis(0));\n-        final Lock lock = new Lock();\n-        final CountDownLatch latch = new CountDownLatch(1);\n-        \/\/ create a thread that waits\n-        TestThread waitThread = new TestThread(new XRun() {\n-            @Override\n-            public void xrun() throws Throwable {\n-                synchronized (lock) {\n-                    latch.countDown();\n-                    lock.wait(WAIT_TIME);\n-                }\n-            }\n-        });\n-        try {\n-            recording.start();\n-            waitThread.start();\n-            latch.await();\n-            synchronized (lock) {\n-                lock.notifyAll();\n+        List<RecordedEvent> events = new CopyOnWriteArrayList<>();\n+        try (RecordingStream rs = new RecordingStream()) {\n+            rs.enable(EVENT_NAME).with(\"period\", \"everyChunk\");\n+            rs.onEvent(EVENT_NAME, e -> events.add(e));\n+            rs.startAsync();\n+\n+            \/\/ Recursively lock all, causing NUM_LOCKS monitors to exist.\n+            \/\/ Stop the recording when holding all the locks, so that we\n+            \/\/ get at least one event with NUM_LOCKS max.\n+            for (int c = 0; c < NUM_LOCKS; c++) {\n+                LOCKS[c] = new Lock();\n@@ -79,18 +87,15 @@\n-        } finally {\n-            waitThread.join();\n-            \/\/ Let deflater thread run.\n-            Thread.sleep(3000);\n-            recording.stop();\n-        }\n-        boolean isAnyFound = false;\n-        try {\n-            \/\/ Find at least one event with the correct monitor class and check the other fields\n-            for (RecordedEvent event : Events.fromRecording(recording)) {\n-                assertTrue(EVENT_NAME.equals(event.getEventType().getName()), \"mismatched event types?\");\n-                long totalCount = Events.assertField(event, FIELD_TOTAL_COUNT).getValue();\n-                long deflatedCount = Events.assertField(event, FIELD_DEFLATED_COUNT).getValue();\n-                assertTrue(totalCount >= 0, \"Should be positive\");\n-                assertTrue(deflatedCount >= 0, \"Should be positive\");\n-                assertTrue(totalCount + deflatedCount > 0, \"Should be non-zero\");\n-                isAnyFound = true;\n-                break;\n+            lockNext(0, () -> rs.stop());\n+\n+            System.out.println(events);\n+            assertFalse(events.isEmpty());\n+\n+            long globalMax = Long.MIN_VALUE;\n+            long globalCount = Long.MIN_VALUE;\n+            for (RecordedEvent ev : events) {\n+                long evMaxCount = Events.assertField(ev, FIELD_MAX_COUNT).getValue();\n+                long evCount = Events.assertField(ev, FIELD_COUNT).getValue();\n+                assertTrue(evCount <= evMaxCount, \"Count should be below max: \" + evCount + \" <= \" + evMaxCount);\n+                assertTrue(evMaxCount >= 0, \"Max should be non-negative: \" + evMaxCount);\n+                assertTrue(evCount >= 0, \"Count should be non-negative: \" + evCount);\n+                globalMax = Math.max(globalMax, evMaxCount);\n+                globalCount = Math.max(globalCount, evCount);\n@@ -98,6 +103,3 @@\n-            assertTrue(isAnyFound, \"Expected a statistics event from test\");\n-        } catch (Throwable e) {\n-            recording.dump(Paths.get(\"failed.jfr\"));\n-            throw e;\n-        } finally {\n-            recording.close();\n+\n+            assertTrue(globalMax >= NUM_LOCKS, \"Global max should be at least \" + NUM_LOCKS + \": \" + globalMax);\n+            assertTrue(globalCount >= NUM_LOCKS, \"Global count should be at least \" + NUM_LOCKS + \": \" + globalCount);\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestJavaMonitorStatisticsEvent.java","additions":51,"deletions":49,"binary":false,"changes":100,"status":"modified"}]}