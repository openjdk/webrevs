{"files":[{"patch":"@@ -737,1 +737,1 @@\n-JRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* current, BasicObjectLock* elem))\n+JRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* current, void* elem))\n@@ -739,2 +739,8 @@\n-    \/\/ This is a hack to get around the limitation of registers in x86_32. We really\n-    \/\/ send an oopDesc* instead of a BasicObjectLock*.\n+    \/\/ TODO: We accept elem as void* to workaround a limitation of registers in x86_32. Interpreter\n+    \/\/ code is really sending an oopDesc* here.\n+    \/\/ The problem is that we would need to preserve the register that holds the BasicObjectLock,\n+    \/\/ but we are using that register to hold the thread. We don't have enough registers to\n+    \/\/ also keep the BasicObjectLock, but we don't really need it anyway, we only need\n+    \/\/ the object. See also InterpreterMacroAssembler::lock_object().\n+    \/\/ As soon as traditional stack-locking goes away we can change elem to be oopDesc*\n+    \/\/ (also in monitorexit below).\n@@ -747,0 +753,1 @@\n+  BasicObjectLock* lock = reinterpret_cast<BasicObjectLock*>(elem);\n@@ -748,1 +755,1 @@\n-  current->last_frame().interpreter_frame_verify_monitor(elem);\n+  current->last_frame().interpreter_frame_verify_monitor(lock);\n@@ -750,1 +757,1 @@\n-  Handle h_obj(current, elem->obj());\n+  Handle h_obj(current, lock->obj());\n@@ -753,2 +760,2 @@\n-  ObjectSynchronizer::enter(h_obj, elem->lock(), current);\n-  assert(Universe::heap()->is_in_or_null(elem->obj()),\n+  ObjectSynchronizer::enter(h_obj, lock->lock(), current);\n+  assert(Universe::heap()->is_in_or_null(lock->obj()),\n@@ -757,1 +764,1 @@\n-  current->last_frame().interpreter_frame_verify_monitor(elem);\n+  current->last_frame().interpreter_frame_verify_monitor(lock);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-  static void    monitorenter(JavaThread* current, BasicObjectLock* elem);\n+  static void    monitorenter(JavaThread* current, void* elem);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-  if (ignore_mark_word || UseFastLocking) {\n+  if (ignore_mark_word) {\n@@ -132,1 +132,1 @@\n-  return !SafepointSynchronize::is_at_safepoint();\n+  return  UseFastLocking || !SafepointSynchronize::is_at_safepoint();\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1996,3 +1996,0 @@\n-  if (UseHeavyMonitors) {\n-    FLAG_SET_DEFAULT(UseFastLocking, false);\n-  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -494,1 +494,1 @@\n-        markWord header = obj()->mark_acquire();\n+        markWord mark = obj()->mark_acquire();\n@@ -496,1 +496,1 @@\n-          if (header.is_neutral()) {\n+          if (mark.is_neutral()) {\n@@ -499,3 +499,3 @@\n-            markWord locked_header = header.set_fast_locked();\n-            markWord witness = obj()->cas_set_mark(locked_header, header);\n-            if (witness == header) {\n+            markWord locked_mark = mark.set_fast_locked();\n+            markWord old_mark = obj()->cas_set_mark(locked_mark, mark);\n+            if (old_mark == mark) {\n@@ -507,1 +507,1 @@\n-            header = witness;\n+            mark = old_mark;\n@@ -562,3 +562,3 @@\n-        markWord unlocked_header = mark.set_unlocked();\n-        markWord witness = object->cas_set_mark(unlocked_header, mark);\n-        if (witness != mark) {\n+        markWord unlocked_mark = mark.set_unlocked();\n+        markWord old_mark = object->cas_set_mark(unlocked_mark, mark);\n+        if (old_mark != mark) {\n@@ -569,2 +569,2 @@\n-          assert(witness.has_monitor(), \"must have monitor\");\n-          ObjectMonitor* monitor = witness.monitor();\n+          assert(old_mark.has_monitor(), \"must have monitor\");\n+          ObjectMonitor* monitor = old_mark.monitor();\n@@ -760,4 +760,10 @@\n-  if ((mark.is_fast_locked() && current->lock_stack().contains(obj())) ||\n-      (mark.has_locker() && current->is_lock_owned((address)mark.locker()))) {\n-    \/\/ Not inflated so there can't be any waiters to notify.\n-    return;\n+  if (UseFastLocking) {\n+    if ((mark.is_fast_locked() && current->lock_stack().contains(obj()))) {\n+      \/\/ Not inflated so there can't be any waiters to notify.\n+      return;\n+    }\n+  } else {\n+    if (mark.has_locker() && current->is_lock_owned((address)mark.locker())) {\n+      \/\/ Not inflated so there can't be any waiters to notify.\n+      return;\n+    }\n@@ -776,4 +782,10 @@\n-  if ((mark.is_fast_locked() && current->lock_stack().contains(obj())) ||\n-      (mark.has_locker() && current->is_lock_owned((address)mark.locker()))) {\n-    \/\/ Not inflated so there can't be any waiters to notify.\n-    return;\n+  if (UseFastLocking) {\n+    if ((mark.is_fast_locked() && current->lock_stack().contains(obj()))) {\n+      \/\/ Not inflated so there can't be any waiters to notify.\n+      return;\n+    }\n+  } else {\n+    if (mark.has_locker() && current->is_lock_owned((address)mark.locker())) {\n+      \/\/ Not inflated so there can't be any waiters to notify.\n+      return;\n+    }\n@@ -1350,2 +1362,2 @@\n-      markWord witness = object->cas_set_mark(monitor_mark, mark);\n-      if (witness == mark) {\n+      markWord old_mark = object->cas_set_mark(monitor_mark, mark);\n+      if (old_mark == mark) {\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":33,"deletions":21,"binary":false,"changes":54,"status":"modified"}]}