{"files":[{"patch":"@@ -288,1 +288,1 @@\n-  __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes(), compilation()->max_monitors());\n+  __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    fast_lock_impl(obj, hdr, thread, tmp, slow_case, LP64_ONLY(false) NOT_LP64(true));\n+    fast_lock_impl(obj, hdr, thread, tmp, slow_case);\n@@ -321,1 +321,1 @@\n-void C1_MacroAssembler::build_frame(int frame_size_in_bytes, int bang_size_in_bytes, int max_monitors) {\n+void C1_MacroAssembler::build_frame(int frame_size_in_bytes, int bang_size_in_bytes) {\n@@ -342,13 +342,0 @@\n-#ifdef _LP64\n-  if (UseFastLocking && max_monitors > 0) {\n-    Label ok;\n-    movptr(rax, Address(r15_thread, JavaThread::lock_stack_current_offset()));\n-    addptr(rax, max_monitors * wordSize);\n-    cmpptr(rax, Address(r15_thread, JavaThread::lock_stack_limit_offset()));\n-    jcc(Assembler::less, ok);\n-    assert(StubRoutines::x86::check_lock_stack() != nullptr, \"need runtime call stub\");\n-    call(RuntimeAddress(StubRoutines::x86::check_lock_stack()));\n-    bind(ok);\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -76,14 +76,0 @@\n-int C2CheckLockStackStub::max_size() const {\n-  \/\/ Max size of stub has been determined by testing with 0, in which case\n-  \/\/ C2CodeStubList::emit() will throw an assertion and report the actual size that\n-  \/\/ is needed.\n-  return 10;\n-}\n-\n-void C2CheckLockStackStub::emit(C2_MacroAssembler& masm) {\n-  __ bind(entry());\n-  assert(StubRoutines::x86::check_lock_stack() != nullptr, \"need runtime call stub\");\n-  __ call(RuntimeAddress(StubRoutines::x86::check_lock_stack()));\n-  __ jmp(continuation(), false \/* maybe_short *\/);\n-}\n-\n@@ -102,1 +88,1 @@\n-  __ subptr(Address(r15_thread, JavaThread::lock_stack_current_offset()), oopSize);\n+  __ subptr(Address(r15_thread, JavaThread::lock_stack_offset_offset()), oopSize);\n","filename":"src\/hotspot\/cpu\/x86\/c2_CodeStubs_x86.cpp","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-void C2_MacroAssembler::verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub, int max_monitors) {\n+void C2_MacroAssembler::verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub) {\n@@ -130,14 +130,0 @@\n-#ifdef _LP64\n-  if (UseFastLocking && max_monitors > 0) {\n-    C2CheckLockStackStub* stub = new (Compile::current()->comp_arena()) C2CheckLockStackStub();\n-    Compile::current()->output()->add_stub(stub);\n-    assert(!is_stub, \"only methods have monitors\");\n-    Register thread = r15_thread;\n-    movptr(rax, Address(thread, JavaThread::lock_stack_current_offset()));\n-    addptr(rax, max_monitors * oopSize);\n-    cmpptr(rax, Address(thread, JavaThread::lock_stack_limit_offset()));\n-    jcc(Assembler::greaterEqual, stub->entry());\n-    bind(stub->continuation());\n-  }\n-#endif\n-\n@@ -620,8 +606,0 @@\n-#ifdef _LP64\n-      fast_lock_impl(objReg, tmpReg, thread, scrReg, NO_COUNT, false);\n-      jmp(COUNT);\n-#else\n-      \/\/ We cannot emit the lock-stack-check in verified_entry() because we don't have enough\n-      \/\/ registers (for thread ptr). Therefore we have to emit the lock-stack-check in\n-      \/\/ fast_lock_impl(). However, that check can take a slow-path with ZF=1, therefore\n-      \/\/ we need to handle it specially and force ZF=0 before taking the actual slow-path.\n@@ -634,1 +612,0 @@\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-  void verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub, int max_monitors);\n+  void verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1354,2 +1354,2 @@\n-      movptr(tmp, Address(thread, JavaThread::lock_stack_current_offset()));\n-      cmpptr(obj_reg, Address(tmp, -oopSize));\n+      movl(tmp, Address(thread, JavaThread::lock_stack_offset_offset()));\n+      cmpptr(obj_reg, Address(thread, tmp, Address::times_1,  -oopSize));\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -9680,1 +9680,1 @@\n-void MacroAssembler::fast_lock_impl(Register obj, Register hdr, Register thread, Register tmp, Label& slow, bool rt_check_stack) {\n+void MacroAssembler::fast_lock_impl(Register obj, Register hdr, Register thread, Register tmp, Label& slow) {\n@@ -9685,15 +9685,2 @@\n-  if (rt_check_stack) {\n-    movptr(tmp, Address(thread, JavaThread::lock_stack_current_offset()));\n-    cmpptr(tmp, Address(thread, JavaThread::lock_stack_limit_offset()));\n-    jcc(Assembler::greaterEqual, slow);\n-  }\n-#ifdef ASSERT\n-  else {\n-    Label ok;\n-    movptr(tmp, Address(thread, JavaThread::lock_stack_current_offset()));\n-    cmpptr(tmp, Address(thread, JavaThread::lock_stack_limit_offset()));\n-    jcc(Assembler::less, ok);\n-    stop(\"Not enough room in lock stack; should have been checked in the method prologue\");\n-    bind(ok);\n-  }\n-#endif\n+  cmpl(Address(thread, JavaThread::lock_stack_offset_offset()), LockStack::end_offset());\n+  jcc(Assembler::greaterEqual, slow);\n@@ -9712,4 +9699,4 @@\n-  movptr(tmp, Address(thread, JavaThread::lock_stack_current_offset()));\n-  movptr(Address(tmp, 0), obj);\n-  increment(tmp, oopSize);\n-  movptr(Address(thread, JavaThread::lock_stack_current_offset()), tmp);\n+  movl(tmp, Address(thread, JavaThread::lock_stack_offset_offset()));\n+  movptr(Address(thread, tmp, Address::times_1), obj);\n+  incrementl(tmp, oopSize);\n+  movl(Address(thread, JavaThread::lock_stack_offset_offset()), tmp);\n@@ -9735,1 +9722,1 @@\n-  subptr(Address(thread, JavaThread::lock_stack_current_offset()), oopSize);\n+  subl(Address(thread, JavaThread::lock_stack_offset_offset()), oopSize);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":8,"deletions":21,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2011,1 +2011,1 @@\n-  void fast_lock_impl(Register obj, Register hdr, Register thread, Register tmp, Label& slow, bool rt_check_stack = true);\n+  void fast_lock_impl(Register obj, Register hdr, Register thread, Register tmp, Label& slow);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3195,49 +3195,0 @@\n-\/\/ Call runtime to ensure lock-stack size.\n-\/\/ Arguments:\n-\/\/ - c_rarg0: the required _limit pointer\n-address StubGenerator::generate_check_lock_stack() {\n-  __ align(CodeEntryAlignment);\n-  StubCodeMark mark(this, \"StubRoutines\", \"check_lock_stack\");\n-  address start = __ pc();\n-\n-  BLOCK_COMMENT(\"Entry:\");\n-  __ enter(); \/\/ save rbp\n-\n-  __ pusha();\n-\n-  \/\/ The method may have floats as arguments, and we must spill them before calling\n-  \/\/ the VM runtime.\n-  assert(Argument::n_float_register_parameters_j == 8, \"Assumption\");\n-  const int xmm_size = wordSize * 2;\n-  const int xmm_spill_size = xmm_size * Argument::n_float_register_parameters_j;\n-  __ subptr(rsp, xmm_spill_size);\n-  __ movdqu(Address(rsp, xmm_size * 7), xmm7);\n-  __ movdqu(Address(rsp, xmm_size * 6), xmm6);\n-  __ movdqu(Address(rsp, xmm_size * 5), xmm5);\n-  __ movdqu(Address(rsp, xmm_size * 4), xmm4);\n-  __ movdqu(Address(rsp, xmm_size * 3), xmm3);\n-  __ movdqu(Address(rsp, xmm_size * 2), xmm2);\n-  __ movdqu(Address(rsp, xmm_size * 1), xmm1);\n-  __ movdqu(Address(rsp, xmm_size * 0), xmm0);\n-\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, static_cast<void (*)(oop*)>(LockStack::ensure_lock_stack_size)), rax);\n-\n-  __ movdqu(xmm0, Address(rsp, xmm_size * 0));\n-  __ movdqu(xmm1, Address(rsp, xmm_size * 1));\n-  __ movdqu(xmm2, Address(rsp, xmm_size * 2));\n-  __ movdqu(xmm3, Address(rsp, xmm_size * 3));\n-  __ movdqu(xmm4, Address(rsp, xmm_size * 4));\n-  __ movdqu(xmm5, Address(rsp, xmm_size * 5));\n-  __ movdqu(xmm6, Address(rsp, xmm_size * 6));\n-  __ movdqu(xmm7, Address(rsp, xmm_size * 7));\n-  __ addptr(rsp, xmm_spill_size);\n-\n-  __ popa();\n-\n-  __ leave();\n-\n-  __ ret(0);\n-\n-  return start;\n-}\n-\n@@ -4140,3 +4091,0 @@\n-  if (UseFastLocking) {\n-    StubRoutines::x86::_check_lock_stack = generate_check_lock_stack();\n-  }\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":0,"deletions":52,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -472,2 +472,0 @@\n-  address generate_check_lock_stack();\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,1 +87,0 @@\n-address StubRoutines::x86::_check_lock_stack = nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -129,2 +129,0 @@\n-  static address _check_lock_stack;\n-\n@@ -220,2 +218,0 @@\n-  static address check_lock_stack() { return _check_lock_stack; }\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -617,2 +617,1 @@\n-  int max_monitors = C->method() != nullptr ? C->max_monitors() : 0;\n-  __ verified_entry(framesize, C->output()->need_stack_bang(bangsize)?bangsize:0, C->in_24_bit_fp_mode(), C->stub_function() != nullptr, max_monitors);\n+  __ verified_entry(framesize, C->output()->need_stack_bang(bangsize)?bangsize:0, C->in_24_bit_fp_mode(), C->stub_function() != nullptr);\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -925,2 +925,1 @@\n-  int max_monitors = C->method() != nullptr ? C->max_monitors() : 0;\n-  __ verified_entry(framesize, C->output()->need_stack_bang(bangsize)?bangsize:0, false, C->stub_function() != nullptr, max_monitors);\n+  __ verified_entry(framesize, C->output()->need_stack_bang(bangsize)?bangsize:0, false, C->stub_function() != nullptr);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}