{"files":[{"patch":"@@ -6262,3 +6262,3 @@\n-  ldr(t1, Address(rthread, JavaThread::lock_stack_offset_offset()));\n-  sub(t1, t1, oopSize);\n-  str(t1, Address(rthread, JavaThread::lock_stack_offset_offset()));\n+  ldrw(t1, Address(rthread, JavaThread::lock_stack_offset_offset()));\n+  subw(t1, t1, oopSize);\n+  strw(t1, Address(rthread, JavaThread::lock_stack_offset_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,2 +55,1 @@\n-  assert(hdr != obj && hdr != disp_hdr && obj != disp_hdr, \"registers must be different\");\n-  Label done;\n+  assert_different_registers(hdr, obj, disp_hdr);\n@@ -70,1 +69,1 @@\n-    bnez(t0, slow_case, true \/* is_far *\/);\n+    bnez(t0, slow_case, \/* is_far *\/ true);\n@@ -79,0 +78,1 @@\n+    Label done;\n@@ -110,0 +110,2 @@\n+    \/\/ done\n+    bind(done);\n@@ -111,2 +113,0 @@\n-  \/\/ done\n-  bind(done);\n@@ -123,7 +123,1 @@\n-  if (UseFastLocking) {\n-    \/\/ load object\n-    ld(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-    verify_oop(obj);\n-    ld(hdr, Address(obj, oopDesc::mark_offset_in_bytes()));\n-    fast_unlock(obj, hdr, t0, t1, slow_case);\n-  } else {\n+  if (!UseFastLocking) {\n@@ -135,3 +129,10 @@\n-    \/\/ load object\n-    ld(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-    verify_oop(obj);\n+  }\n+\n+  \/\/ load object\n+  ld(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n+  verify_oop(obj);\n+\n+  if (UseFastLocking) {\n+    ld(hdr, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    fast_unlock(obj, hdr, t0, t1, slow_case);\n+  } else {\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":16,"deletions":15,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/objectMonitor.hpp\"\n@@ -75,0 +76,24 @@\n+int C2HandleAnonOMOwnerStub::max_size() const {\n+  \/\/ Max size of stub has been determined by testing with 0 without using RISC-V compressed\n+  \/\/ instruction-set extension, in which case C2CodeStubList::emit() will throw an assertion\n+  \/\/ and report the actual size that is needed.\n+  return 20;\n+}\n+\n+void C2HandleAnonOMOwnerStub::emit(C2_MacroAssembler& masm) {\n+  __ bind(entry());\n+  Register mon = monitor();\n+  Register t = tmp();\n+  assert(t != noreg, \"need tmp register\");\n+\n+  \/\/ Fix owner to be the current thread.\n+  __ sd(xthread, Address(mon, ObjectMonitor::owner_offset_in_bytes()));\n+\n+  \/\/ Pop owner object from lock-stack.\n+  __ lwu(t, Address(xthread, JavaThread::lock_stack_offset_offset()));\n+  __ subw(t, t, oopSize);\n+  __ sw(t, Address(xthread, JavaThread::lock_stack_offset_offset()));\n+\n+  __ j(continuation());\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_CodeStubs_riscv.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -890,0 +890,12 @@\n+    if (!UseFastLocking) {\n+      \/\/ Convert from BasicObjectLock structure to object and BasicLock\n+      \/\/ structure Store the BasicLock address into x10\n+      la(swap_reg, Address(lock_reg, BasicObjectLock::lock_offset_in_bytes()));\n+    }\n+\n+    \/\/ Load oop into obj_reg(c_rarg3)\n+    ld(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()));\n+\n+    \/\/ Free entry\n+    sd(zr, Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()));\n+\n@@ -892,5 +904,0 @@\n-      \/\/ Load oop into obj_reg(c_rarg3)\n-      ld(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()));\n-\n-      \/\/ Free entry\n-      sd(zr, Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()));\n@@ -901,2 +908,4 @@\n-      ld(tmp, Address(xthread, JavaThread::lock_stack_current_offset()));\n-      ld(tmp, Address(tmp, -oopSize));\n+      lwu(tmp, Address(xthread, JavaThread::lock_stack_offset_offset()));\n+      subw(tmp, tmp, oopSize);\n+      add(tmp, xthread, tmp);\n+      ld(tmp, Address(tmp, 0));\n@@ -911,10 +920,0 @@\n-      \/\/ Convert from BasicObjectLock structure to object and BasicLock\n-      \/\/ structure Store the BasicLock address into x10\n-      la(swap_reg, Address(lock_reg, BasicObjectLock::lock_offset_in_bytes()));\n-\n-      \/\/ Load oop into obj_reg(c_rarg3)\n-      ld(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()));\n-\n-      \/\/ Free entry\n-      sd(zr, Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()));\n-\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2423,1 +2423,1 @@\n-    bgtu(in_nmethod ? sp : fp, t0, slow_path, true \/* is_far *\/);\n+    bgtu(in_nmethod ? sp : fp, t0, slow_path, \/* is_far *\/ true);\n@@ -2426,1 +2426,1 @@\n-    bnez(t0, slow_path, true \/* is_far *\/);\n+    bnez(t0, slow_path, \/* is_far *\/ true);\n@@ -4497,3 +4497,3 @@\n-  ld(tmp1, Address(xthread, JavaThread::lock_stack_current_offset()));\n-  ld(tmp2, Address(xthread, JavaThread::lock_stack_limit_offset()));\n-  bge(tmp1, tmp2, slow, true);\n+  lwu(tmp1, Address(xthread, JavaThread::lock_stack_offset_offset()));\n+  mv(tmp2, (unsigned)LockStack::end_offset());\n+  bge(tmp1, tmp2, slow, \/* is_far *\/ true);\n@@ -4505,0 +4505,1 @@\n+\n@@ -4511,6 +4512,5 @@\n-  \/\/ TODO: Can we avoid re-loading the current offset? The CAS above clobbers it.\n-  \/\/ Maybe we could ensure that we have enough space on the lock stack more cleverly.\n-  ld(tmp1, Address(xthread, JavaThread::lock_stack_current_offset()));\n-  sd(obj, Address(tmp1, 0));\n-  add(tmp1, tmp1, oopSize);\n-  sd(tmp1, Address(xthread, JavaThread::lock_stack_current_offset()));\n+  lwu(tmp1, Address(xthread, JavaThread::lock_stack_offset_offset()));\n+  add(tmp2, xthread, tmp1);\n+  sd(obj, Address(tmp2, 0));\n+  addw(tmp1, tmp1, oopSize);\n+  sw(tmp1, Address(xthread, JavaThread::lock_stack_offset_offset()));\n@@ -4536,3 +4536,3 @@\n-  ld(tmp1, Address(xthread, JavaThread::lock_stack_current_offset()));\n-  sub(tmp1, tmp1, oopSize);\n-  sd(tmp1, Address(xthread, JavaThread::lock_stack_current_offset()));\n+  lwu(tmp1, Address(xthread, JavaThread::lock_stack_offset_offset()));\n+  subw(tmp1, tmp1, oopSize);\n+  sw(tmp1, Address(xthread, JavaThread::lock_stack_offset_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2387,1 +2387,1 @@\n-  \/\/ using the cr register as the bool result: 0 for success; others failed.\n+  \/\/ Use cr register to indicate the fast_lock result: zero for success; non-zero for failure.\n@@ -2397,1 +2397,1 @@\n-    Label no_count;\n+    Label count, no_count;\n@@ -2405,4 +2405,4 @@\n-      __ load_klass(flag, oop);\n-      __ lwu(flag, Address(flag, Klass::access_flags_offset()));\n-      __ andi(flag, flag, JVM_ACC_IS_VALUE_BASED_CLASS, tmp \/* tmp *\/);\n-      __ bnez(flag, cont, true \/* is_far *\/);\n+      __ load_klass(tmp, oop);\n+      __ lwu(tmp, Address(tmp, Klass::access_flags_offset()));\n+      __ andi(flag, tmp, JVM_ACC_IS_VALUE_BASED_CLASS);\n+      __ bnez(flag, cont, \/* is_far *\/ true);\n@@ -2419,1 +2419,2 @@\n-        \/\/ Indicate success at cont.\n+\n+        \/\/ Indicate success on completion.\n@@ -2421,1 +2422,1 @@\n-        __ j(cont);\n+        __ j(count);\n@@ -2424,0 +2425,1 @@\n+        __ j(no_count);\n@@ -2456,0 +2458,1 @@\n+      __ j(cont);\n@@ -2458,0 +2461,1 @@\n+      __ j(cont);\n@@ -2460,2 +2464,0 @@\n-    __ j(cont);\n-\n@@ -2490,1 +2492,2 @@\n-\n+    \/\/ zero flag indicates success\n+    \/\/ non-zero flag indicates failure\n@@ -2493,0 +2496,1 @@\n+    __ bind(count);\n@@ -2498,1 +2502,1 @@\n-  \/\/ using cr flag to indicate the fast_unlock result: 0 for success; others failed.\n+  \/\/ Use cr register to indicate the fast_unlock result: zero for success; non-zero for failure.\n@@ -2508,1 +2512,1 @@\n-    Label no_count;\n+    Label count, no_count;\n@@ -2531,1 +2535,1 @@\n-        \/\/ Indicate success at cont.\n+        \/\/ Indicate success on completion.\n@@ -2533,1 +2537,1 @@\n-        __ j(cont);\n+        __ j(count);\n@@ -2536,0 +2540,1 @@\n+        __ j(no_count);\n@@ -2544,0 +2549,1 @@\n+        __ j(cont);\n@@ -2547,0 +2553,1 @@\n+      __ j(cont);\n@@ -2548,1 +2555,0 @@\n-    __ j(cont);\n@@ -2558,7 +2564,8 @@\n-      Label L;\n-      __ ld(disp_hdr, Address(tmp, ObjectMonitor::owner_offset_in_bytes()));\n-      __ mv(t0, (unsigned char)(intptr_t)ANONYMOUS_OWNER);\n-      __ bne(disp_hdr, t0, L);\n-      __ mv(flag, 1); \/\/ Indicate failure at cont -- dive into slow-path.\n-      __ j(cont);\n-      __ bind(L);\n+      \/\/ If the owner is anonymous, we need to fix it -- in an outline stub.\n+      Register tmp2 = disp_hdr;\n+      __ ld(tmp2, Address(tmp, ObjectMonitor::owner_offset_in_bytes()));\n+      __ andi(t0, tmp2, (int64_t)(intptr_t)ANONYMOUS_OWNER);\n+      C2HandleAnonOMOwnerStub* stub = new (Compile::current()->comp_arena()) C2HandleAnonOMOwnerStub(tmp, tmp2);\n+      Compile::current()->output()->add_stub(stub);\n+      __ bnez(t0, stub->entry(), \/* is_far *\/ true);\n+      __ bind(stub->continuation());\n@@ -2589,1 +2596,2 @@\n-\n+    \/\/ zero flag indicates success\n+    \/\/ non-zero flag indicates failure\n@@ -2592,0 +2600,1 @@\n+    __ bind(count);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":33,"deletions":24,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  return 17;\n+  return 18;\n","filename":"src\/hotspot\/cpu\/x86\/c2_CodeStubs_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}