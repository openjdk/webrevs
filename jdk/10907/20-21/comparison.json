{"files":[{"patch":"@@ -1791,12 +1791,0 @@\n-  int max_monitors = C->method() != nullptr ? C->max_monitors() : 0;\n-  if (UseFastLocking && max_monitors > 0) {\n-    C2CheckLockStackStub* stub = new (C->comp_arena()) C2CheckLockStackStub();\n-    C->output()->add_stub(stub);\n-    __ ldr(r9, Address(rthread, JavaThread::lock_stack_current_offset()));\n-    __ ldr(r10, Address(rthread, JavaThread::lock_stack_limit_offset()));\n-    __ add(r9, r9, max_monitors * oopSize);\n-    __ cmp(r9, r10);\n-    __ br(Assembler::GE, stub->entry());\n-    __ bind(stub->continuation());\n-  }\n-\n@@ -3852,1 +3840,2 @@\n-        __ fast_lock(oop, disp_hdr, tmp, rscratch1, no_count, false);\n+        Label slow;\n+        __ fast_lock(oop, disp_hdr, tmp, rscratch1, slow);\n@@ -3857,0 +3846,2 @@\n+        __ bind(slow);\n+        __ b(no_count);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -245,1 +245,1 @@\n-  __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes(), compilation()->max_monitors());\n+  __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-    fast_lock(obj, hdr, rscratch1, rscratch2, slow_case, false);\n+    fast_lock(obj, hdr, rscratch1, rscratch2, slow_case);\n@@ -318,1 +318,1 @@\n-void C1_MacroAssembler::build_frame(int framesize, int bang_size_in_bytes, int max_monitors) {\n+void C1_MacroAssembler::build_frame(int framesize, int bang_size_in_bytes) {\n@@ -325,12 +325,0 @@\n-  if (UseFastLocking && max_monitors > 0) {\n-    Label ok;\n-    ldr(r9, Address(rthread, JavaThread::lock_stack_current_offset()));\n-    ldr(r10, Address(rthread, JavaThread::lock_stack_limit_offset()));\n-    add(r9, r9, max_monitors * oopSize);\n-    cmp(r9, r10);\n-    br(Assembler::LT, ok);\n-    assert(StubRoutines::aarch64::check_lock_stack() != nullptr, \"need runtime call stub\");\n-    far_call(StubRoutines::aarch64::check_lock_stack());\n-    bind(ok);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -67,14 +67,0 @@\n-int C2CheckLockStackStub::max_size() const {\n-  \/\/ Max size of stub has been determined by testing with 0, in which case\n-  \/\/ C2CodeStubList::emit() will throw an assertion and report the actual size that\n-  \/\/ is needed.\n-  return 20;\n-}\n-\n-void C2CheckLockStackStub::emit(C2_MacroAssembler& masm) {\n-  __ bind(entry());\n-  assert(StubRoutines::aarch64::check_lock_stack() != nullptr, \"need runtime call stub\");\n-  __ far_call(StubRoutines::aarch64::check_lock_stack());\n-  __ b(continuation());\n-}\n-\n@@ -98,1 +84,1 @@\n-  __ ldr(t, Address(rthread, JavaThread::lock_stack_current_offset()));\n+  __ ldr(t, Address(rthread, JavaThread::lock_stack_offset_offset()));\n@@ -100,1 +86,1 @@\n-  __ str(t, Address(rthread, JavaThread::lock_stack_current_offset()));\n+  __ str(t, Address(rthread, JavaThread::lock_stack_offset_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_CodeStubs_aarch64.cpp","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -876,2 +876,3 @@\n-      ldr(tmp, Address(rthread, JavaThread::lock_stack_current_offset()));\n-      ldr(tmp, Address(tmp, -oopSize));\n+      ldrw(tmp, Address(rthread, JavaThread::lock_stack_offset_offset()));\n+      subw(tmp, tmp, oopSize);\n+      ldr(tmp, Address(rthread, tmp));\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -6221,1 +6221,1 @@\n-void MacroAssembler::fast_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow, bool rt_check_stack) {\n+void MacroAssembler::fast_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow) {\n@@ -6225,7 +6225,4 @@\n-  if (rt_check_stack) {\n-    \/\/ Check if we would have space on lock-stack for the object.\n-    ldr(t1, Address(rthread, JavaThread::lock_stack_current_offset()));\n-    ldr(t2, Address(rthread, JavaThread::lock_stack_limit_offset()));\n-    cmp(t1, t2);\n-    br(Assembler::GE, slow);\n-  }\n+  \/\/ Check if we would have space on lock-stack for the object.\n+  ldrw(t1, Address(rthread, JavaThread::lock_stack_offset_offset()));\n+  cmpw(t1, (unsigned)LockStack::end_offset());\n+  br(Assembler::GE, slow);\n@@ -6243,4 +6240,4 @@\n-  ldr(t1, Address(rthread, JavaThread::lock_stack_current_offset()));\n-  str(obj, Address(t1, 0));\n-  add(t1, t1, oopSize);\n-  str(t1, Address(rthread, JavaThread::lock_stack_current_offset()));\n+  ldrw(t1, Address(rthread, JavaThread::lock_stack_offset_offset()));\n+  str(obj, Address(rthread, t1));\n+  addw(t1, t1, oopSize);\n+  strw(t1, Address(rthread, JavaThread::lock_stack_offset_offset()));\n@@ -6265,1 +6262,1 @@\n-  ldr(t1, Address(rthread, JavaThread::lock_stack_current_offset()));\n+  ldr(t1, Address(rthread, JavaThread::lock_stack_offset_offset()));\n@@ -6267,1 +6264,1 @@\n-  str(t1, Address(rthread, JavaThread::lock_stack_current_offset()));\n+  str(t1, Address(rthread, JavaThread::lock_stack_offset_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1584,1 +1584,1 @@\n-  void fast_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow, bool rt_check_stack = true);\n+  void fast_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5477,22 +5477,0 @@\n-  address generate_check_lock_stack() {\n-    __ align(CodeEntryAlignment);\n-    StubCodeMark mark(this, \"StubRoutines\", \"check_lock_stack\");\n-\n-    address start = __ pc();\n-\n-    __ set_last_Java_frame(sp, rfp, lr, rscratch1);\n-    __ enter();\n-    __ push_call_clobbered_registers();\n-\n-    __ mov(c_rarg0, r9);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, LockStack::ensure_lock_stack_size), 1);\n-\n-    __ pop_call_clobbered_registers();\n-    __ leave();\n-    __ reset_last_Java_frame(true);\n-\n-    __ ret(lr);\n-\n-    return start;\n-  }\n-\n@@ -8131,3 +8109,0 @@\n-    if (UseFastLocking) {\n-      StubRoutines::aarch64::_check_lock_stack = generate_check_lock_stack();\n-    }\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-address StubRoutines::aarch64::_check_lock_stack = nullptr;\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -73,2 +73,0 @@\n-  static address _check_lock_stack;\n-\n@@ -185,4 +183,0 @@\n-  static address check_lock_stack() {\n-    return _check_lock_stack;\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-  __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes(), compilation()->max_monitors());\n+  __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-void C1_MacroAssembler::build_frame(int frame_size_in_bytes, int bang_size_in_bytes, int max_monitors) {\n+void C1_MacroAssembler::build_frame(int frame_size_in_bytes, int bang_size_in_bytes) {\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-  __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes(), compilation()->max_monitors());\n+  __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-void C1_MacroAssembler::build_frame(int frame_size_in_bytes, int bang_size_in_bytes, int max_monitors) {\n+void C1_MacroAssembler::build_frame(int frame_size_in_bytes, int bang_size_in_bytes) {\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-  __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes(), compilation()->max_monitors());\n+  __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -321,1 +321,1 @@\n-void C1_MacroAssembler::build_frame(int framesize, int bang_size_in_bytes, int max_monitors) {\n+void C1_MacroAssembler::build_frame(int framesize, int bang_size_in_bytes) {\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-  __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes(), compilation()->max_monitors());\n+  __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-void C1_MacroAssembler::build_frame(int frame_size_in_bytes, int bang_size_in_bytes, int max_monitors) {\n+void C1_MacroAssembler::build_frame(int frame_size_in_bytes, int bang_size_in_bytes) {\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -387,1 +387,0 @@\n-    push_monitor();\n@@ -575,1 +574,0 @@\n-, _max_monitors(0)\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,1 +86,0 @@\n-  int                _max_monitors; \/\/ Max number of active monitors, for fast-locking\n@@ -144,1 +143,0 @@\n-  int max_monitors() const                       { return _max_monitors; }\n@@ -177,2 +175,0 @@\n-  void push_monitor()                            { _max_monitors++; }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2318,1 +2318,0 @@\n-  compilation()->push_monitor();\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -776,1 +776,1 @@\n-  _masm->build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes(), compilation()->max_monitors());\n+  _masm->build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  void build_frame(int frame_size_in_bytes, int bang_size_in_bytes, int max_monitors);\n+  void build_frame(int frame_size_in_bytes, int bang_size_in_bytes);\n","filename":"src\/hotspot\/share\/c1\/c1_MacroAssembler.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,8 +89,0 @@\n-class C2CheckLockStackStub : public C2CodeStub {\n-public:\n-  C2CheckLockStackStub() : C2CodeStub() {}\n-\n-  int max_size() const;\n-  void emit(C2_MacroAssembler& masm);\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/c2_CodeStubs.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1024,1 +1024,0 @@\n-  reset_max_monitors();\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -340,1 +340,0 @@\n-  uint                  _max_monitors;          \/\/ Keep track of maximum number of active monitors in this compilation\n@@ -635,4 +634,0 @@\n-  void          push_monitor() { _max_monitors++; }\n-  void          reset_max_monitors() { _max_monitors = 0; }\n-  uint          max_monitors() { return _max_monitors; }\n-\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -183,1 +183,0 @@\n-  C->push_monitor();\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -426,1 +426,0 @@\n-    C->push_monitor();\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1150,2 +1150,2 @@\n-  static ByteSize lock_stack_current_offset()    { return byte_offset_of(JavaThread, _lock_stack) + LockStack::current_offset(); }\n-  static ByteSize lock_stack_limit_offset()    { return byte_offset_of(JavaThread, _lock_stack) + LockStack::limit_offset(); }\n+  static ByteSize lock_stack_offset_offset()    { return byte_offset_of(JavaThread, _lock_stack) + LockStack::offset_offset(); }\n+  static ByteSize lock_stack_base_offset()      { return byte_offset_of(JavaThread, _lock_stack) + LockStack::base_offset(); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/lockStack.hpp\"\n+#include \"runtime\/lockStack.inline.hpp\"\n@@ -33,4 +33,2 @@\n-LockStack::LockStack() :\n-  _base(UseFastLocking && !UseHeavyMonitors ? _initial : nullptr),\n-  _limit(_base + INITIAL_CAPACITY),\n-  _current(_base) {\n+int LockStack::end_offset() {\n+  return in_bytes(JavaThread::lock_stack_base_offset()) + CAPACITY * oopSize;\n@@ -39,6 +37,2 @@\n-LockStack::~LockStack() {\n-  if (UseFastLocking && !UseHeavyMonitors) {\n-    if (_base != _initial) {\n-      FREE_C_HEAP_ARRAY(oop, _base);\n-    }\n-  }\n+LockStack::LockStack() :\n+  _offset(in_bytes(JavaThread::lock_stack_base_offset())) {\n@@ -50,3 +44,4 @@\n-  for (oop* loc1 = _base; loc1 < _current - 1; loc1++) {\n-    for (oop* loc2 = loc1 + 1; loc2 < _current; loc2++) {\n-      assert(*loc1 != *loc2, \"entries must be unique: %s\", msg);\n+  int end = to_index(_offset);\n+  for (int i = 0; i < end; i++) {\n+    for (int j = i + 1; j < end; j++) {\n+      assert(_base[i] != _base[j], \"entries must be unique: %s\", msg);\n@@ -57,27 +52,0 @@\n-\n-void LockStack::grow(size_t min_capacity) {\n-  \/\/ Grow stack.\n-  assert(_limit > _base, \"invariant\");\n-  size_t capacity = _limit - _base;\n-  size_t index = _current - _base;\n-  size_t new_capacity = MAX2(min_capacity, capacity * 2);\n-  if (_base == _initial) {\n-    oop* new_stack = NEW_C_HEAP_ARRAY(oop, new_capacity, mtSynchronizer);\n-    for (size_t i = 0; i < index; i++) {\n-      *(new_stack + i) = *(_base + i);\n-    }\n-    _base = new_stack;\n-  } else {\n-    _base = REALLOC_C_HEAP_ARRAY(oop, _base, new_capacity, mtSynchronizer);\n-  }\n-  _limit = _base + new_capacity;\n-  _current = _base + index;\n-  assert(_current < _limit, \"must fit after growing\");\n-  assert((_limit - _base) >= (ptrdiff_t) min_capacity, \"must grow enough\");\n-}\n-\n-void LockStack::ensure_lock_stack_size(oop* required_limit) {\n-  JavaThread* jt = JavaThread::current();\n-  LockStack& lock_stack = jt->lock_stack();\n-  lock_stack.grow(required_limit - lock_stack._base);\n-}\n","filename":"src\/hotspot\/share\/runtime\/lockStack.cpp","additions":9,"deletions":41,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -38,7 +38,6 @@\n-  static const size_t INITIAL_CAPACITY = 4;\n-  oop* _base;\n-  oop* _limit;\n-  oop* _current;\n-  oop _initial[INITIAL_CAPACITY];\n-\n-  void grow(size_t min_capacity);\n+  static const int CAPACITY = 8;\n+  \/\/ The offset of the next element, in bytes, relative to the JavaThread structure.\n+  \/\/ We do this instead of a simple index into the array because this allows for\n+  \/\/ efficient addressing in generated code.\n+  int _offset;\n+  oop _base[CAPACITY];\n@@ -47,4 +46,0 @@\n-public:\n-  static ByteSize current_offset()    { return byte_offset_of(LockStack, _current); }\n-  static ByteSize base_offset()       { return byte_offset_of(LockStack, _base); }\n-  static ByteSize limit_offset()      { return byte_offset_of(LockStack, _limit); }\n@@ -52,1 +47,5 @@\n-  static void ensure_lock_stack_size(oop* _required_limit);\n+  static inline int to_index(int offset);\n+\n+public:\n+  static ByteSize offset_offset()    { return byte_offset_of(LockStack, _offset); }\n+  static ByteSize base_offset()    { return byte_offset_of(LockStack, _base); }\n@@ -55,1 +54,0 @@\n-  ~LockStack();\n@@ -57,0 +55,2 @@\n+  static int end_offset();\n+  inline bool can_push() const;\n","filename":"src\/hotspot\/share\/runtime\/lockStack.hpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -31,0 +32,8 @@\n+inline int LockStack::to_index(int offset) {\n+  return (offset - in_bytes(JavaThread::lock_stack_base_offset())) \/ oopSize;\n+}\n+\n+inline bool LockStack::can_push() const {\n+  return to_index(_offset) < CAPACITY;\n+}\n+\n@@ -35,5 +44,3 @@\n-  if (_current >= _limit) {\n-    grow((_limit - _base) + 1);\n-  }\n-  *_current = o;\n-  _current++;\n+  assert(can_push(), \"must have room\");\n+  _base[to_index(_offset)] = o;\n+  _offset += oopSize;\n@@ -45,4 +52,3 @@\n-  oop* new_loc = _current - 1;\n-  assert(new_loc < _current, \"underflow, probably unbalanced push\/pop\");\n-  _current = new_loc;\n-  oop o = *_current;\n+  assert(to_index(_offset) > 0, \"underflow, probably unbalanced push\/pop\");\n+  _offset -= oopSize;\n+  oop o = _base[to_index(_offset)];\n@@ -57,5 +63,6 @@\n-  for (oop* loc = _base; loc < _current; loc++) {\n-    if (*loc == o) {\n-      oop* last = _current - 1;\n-      for (; loc < last; loc++) {\n-        *loc = *(loc + 1);\n+  int end = to_index(_offset);\n+  for (int i = 0; i < end; i++) {\n+    if (_base[i] == o) {\n+      int last = end - 1;\n+      for (; i < last; i++) {\n+        _base[i] = _base[i + 1];\n@@ -63,1 +70,1 @@\n-      _current--;\n+      _offset -= oopSize;\n@@ -73,5 +80,4 @@\n-  bool found = false;\n-  size_t i = 0;\n-  size_t found_i = 0;\n-  for (oop* loc = _current - 1; loc >= _base; loc--) {\n-    if (*loc == o) {\n+  int end = to_index(_offset);\n+  for (int i = end - 1; i >= 0; i--) {\n+    if (_base[i] == o) {\n+      validate(\"post-contains\");\n@@ -88,2 +94,3 @@\n-  for (oop* loc = _base; loc < _current; loc++) {\n-    cl->do_oop(loc);\n+  int end = to_index(_offset);\n+  for (int i = 0; i < end; i++) {\n+    cl->do_oop(&_base[i]);\n","filename":"src\/hotspot\/share\/runtime\/lockStack.inline.hpp","additions":29,"deletions":22,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -493,12 +493,18 @@\n-\n-      markWord header = obj()->mark_acquire();\n-      while (true) {\n-        if (header.is_neutral()) {\n-          assert(!lock_stack.contains(obj()), \"thread must not already hold the lock\");\n-          \/\/ Try to swing into 'fast-locked' state without inflating.\n-          markWord locked_header = header.set_fast_locked();\n-          markWord witness = obj()->cas_set_mark(locked_header, header);\n-          if (witness == header) {\n-            \/\/ Successfully fast-locked, push object to lock-stack and return.\n-            lock_stack.push(obj());\n-            return;\n+      if (lock_stack.can_push()) {\n+        markWord header = obj()->mark_acquire();\n+        while (true) {\n+          if (header.is_neutral()) {\n+            assert(!lock_stack.contains(obj()), \"thread must not already hold the lock\");\n+            \/\/ Try to swing into 'fast-locked' state without inflating.\n+            markWord locked_header = header.set_fast_locked();\n+            markWord witness = obj()->cas_set_mark(locked_header, header);\n+            if (witness == header) {\n+              \/\/ Successfully fast-locked, push object to lock-stack and return.\n+              lock_stack.push(obj());\n+              return;\n+            }\n+            \/\/ Otherwise retry.\n+            header = witness;\n+          } else {\n+            \/\/ Fall-through to inflate-enter.\n+            break;\n@@ -506,5 +512,0 @@\n-          \/\/ Otherwise retry.\n-          header = witness;\n-        } else {\n-          \/\/ Fall-through to inflate-enter.\n-          break;\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -703,2 +703,2 @@\n-  nonstatic_field(LockStack,                   _current,                                      oop*)                                  \\\n-  nonstatic_field(LockStack,                   _base,                                         oop*)                                  \\\n+  nonstatic_field(LockStack,                   _offset,                                       int)                                   \\\n+  nonstatic_field(LockStack,                   _base[0],                                      oop)                                 \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}