{"files":[{"patch":"@@ -148,9 +148,0 @@\n-ifeq ($(call isTargetOs, linux), true)\n-  $(eval $(call SetupCopyFiles, COPY_SDP_CONF, \\\n-      FILES := $(TOPDIR)\/src\/java.base\/$(OPENJDK_TARGET_OS_TYPE)\/conf\/sdp\/sdp.conf.template, \\\n-      DEST := $(CONF_DST_DIR)\/sdp, \\\n-  ))\n-\n-  TARGETS += $(COPY_SDP_CONF)\n-endif\n-\n","filename":"make\/modules\/java.base\/Copy.gmk","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.net.sdp;\n-\n-import java.io.IOException;\n-import java.io.FileDescriptor;\n-\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.access.JavaIOFileDescriptorAccess;\n-import jdk.internal.util.OperatingSystem;\n-\n-\n-\/**\n- * This class defines methods for creating SDP sockets or \"converting\" existing\n- * file descriptors, referencing (unbound) TCP sockets, to SDP.\n- *\/\n-\n-public final class SdpSupport {\n-    private static final boolean isSupported = OperatingSystem.isLinux();\n-    private static final JavaIOFileDescriptorAccess fdAccess =\n-        SharedSecrets.getJavaIOFileDescriptorAccess();\n-\n-    private SdpSupport() { }\n-\n-    \/**\n-     * Creates a SDP socket, returning file descriptor referencing the socket.\n-     *\/\n-    public static FileDescriptor createSocket() throws IOException {\n-        if (!isSupported)\n-            throw new UnsupportedOperationException(\"SDP not supported on this platform\");\n-        int fdVal = create0();\n-        FileDescriptor fd = new FileDescriptor();\n-        fdAccess.set(fd, fdVal);\n-        return fd;\n-    }\n-\n-    \/**\n-     * Converts an existing file descriptor, that references an unbound TCP socket,\n-     * to SDP.\n-     *\/\n-    public static void convertSocket(FileDescriptor fd) throws IOException {\n-        if (!isSupported)\n-            throw new UnsupportedOperationException(\"SDP not supported on this platform\");\n-        int fdVal = fdAccess.get(fd);\n-        convert0(fdVal);\n-    }\n-\n-    private static native int create0() throws IOException;\n-\n-    private static native void convert0(int fd) throws IOException;\n-\n-    static {\n-        jdk.internal.loader.BootLoader.loadLibrary(\"net\");\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/net\/sdp\/SdpSupport.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -41,1 +41,0 @@\n-import sun.net.NetHooks;\n@@ -159,1 +158,0 @@\n-                NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousServerSocketChannelImpl.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import sun.net.NetHooks;\n@@ -450,1 +449,0 @@\n-                NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousSocketChannelImpl.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-import sun.net.NetHooks;\n@@ -504,5 +503,0 @@\n-            \/\/ invoke beforeTcpConnect hook if not already bound\n-            if (localport == 0) {\n-                NetHooks.beforeTcpConnect(fd, address, port);\n-            }\n-\n@@ -640,1 +634,0 @@\n-            NetHooks.beforeTcpBind(fd, host, port);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-import sun.net.NetHooks;\n@@ -334,1 +333,0 @@\n-        NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketChannelImpl.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-import sun.net.NetHooks;\n@@ -831,1 +830,0 @@\n-        NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());\n@@ -874,1 +872,0 @@\n-                NetHooks.beforeTcpConnect(fd, isa.getAddress(), isa.getPort());\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2009, 2010, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.net;\n-\n-import java.net.InetAddress;\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-\n-\/**\n- * Defines static methods to be invoked prior to binding or connecting TCP sockets.\n- *\/\n-\n-public final class NetHooks {\n-\n-    \/**\n-     * A provider with hooks to allow sockets be converted prior to binding or\n-     * connecting a TCP socket.\n-     *\n-     * <p> Concrete implementations of this class should define a zero-argument\n-     * constructor and implement the abstract methods specified below.\n-     *\/\n-    public abstract static class Provider {\n-        \/**\n-         * Initializes a new instance of this class.\n-         *\/\n-        protected Provider() {}\n-\n-        \/**\n-         * Invoked prior to binding a TCP socket.\n-         *\/\n-        public abstract void implBeforeTcpBind(FileDescriptor fdObj,\n-                                               InetAddress address,\n-                                               int port)\n-            throws IOException;\n-\n-        \/**\n-         * Invoked prior to connecting an unbound TCP socket.\n-         *\/\n-        public abstract void implBeforeTcpConnect(FileDescriptor fdObj,\n-                                                 InetAddress address,\n-                                                 int port)\n-            throws IOException;\n-    }\n-\n-    \/**\n-     * For now, we load the SDP provider on Solaris. In the future this may\n-     * be changed to use the ServiceLoader facility to allow the deployment of\n-     * other providers.\n-     *\/\n-    private static final Provider provider = new sun.net.sdp.SdpProvider();\n-\n-    \/**\n-     * Invoke prior to binding a TCP socket.\n-     *\/\n-    public static void beforeTcpBind(FileDescriptor fdObj,\n-                                     InetAddress address,\n-                                     int port)\n-        throws IOException\n-    {\n-        provider.implBeforeTcpBind(fdObj, address, port);\n-    }\n-\n-    \/**\n-     * Invoke prior to connecting an unbound TCP socket.\n-     *\/\n-    public static void beforeTcpConnect(FileDescriptor fdObj,\n-                                        InetAddress address,\n-                                        int port)\n-        throws IOException\n-    {\n-        provider.implBeforeTcpConnect(fdObj, address, port);\n-    }\n-}\n","filename":"src\/java.base\/unix\/classes\/sun\/net\/NetHooks.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -1,326 +0,0 @@\n-\/*\n- * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.net.sdp;\n-\n-import sun.net.NetHooks;\n-import java.net.InetAddress;\n-import java.net.Inet4Address;\n-import java.net.UnknownHostException;\n-import java.util.*;\n-import java.io.File;\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-import java.io.PrintStream;\n-\n-\/**\n- * A NetHooks provider that converts sockets from the TCP to SDP protocol prior\n- * to binding or connecting.\n- *\/\n-\n-public class SdpProvider extends NetHooks.Provider {\n-    \/\/ maximum port\n-    private static final int MAX_PORT = 65535;\n-\n-    \/\/ indicates if SDP is enabled and the rules for when the protocol is used\n-    private final boolean enabled;\n-    private final List<Rule> rules;\n-\n-    \/\/ logging for debug purposes\n-    private PrintStream log;\n-\n-    public SdpProvider() {\n-        Properties props = System.getProperties();\n-        \/\/ if this property is not defined then there is nothing to do.\n-        String file = props.getProperty(\"com.sun.sdp.conf\");\n-        if (file == null) {\n-            this.enabled = false;\n-            this.rules = null;\n-            return;\n-        }\n-\n-        \/\/ load configuration file\n-        List<Rule> list = null;\n-        try {\n-            list = loadRulesFromFile(file);\n-        } catch (IOException e) {\n-            fail(\"Error reading %s: %s\", file, e.getMessage());\n-        }\n-\n-        \/\/ check if debugging is enabled\n-        PrintStream out = null;\n-        String logfile = props.getProperty(\"com.sun.sdp.debug\");\n-        if (logfile != null) {\n-            out = System.out;\n-            if (!logfile.isEmpty()) {\n-                try {\n-                    out = new PrintStream(logfile);\n-                } catch (IOException ignore) { }\n-            }\n-        }\n-\n-        this.enabled = !list.isEmpty();\n-        this.rules = list;\n-        this.log = out;\n-    }\n-\n-    \/\/ supported actions\n-    private static enum Action {\n-        BIND,\n-        CONNECT;\n-    }\n-\n-    \/\/ a rule for matching a bind or connect request\n-    private static interface Rule {\n-        boolean match(Action action, InetAddress address, int port);\n-    }\n-\n-    \/\/ rule to match port[-end]\n-    private static class PortRangeRule implements Rule {\n-        private final Action action;\n-        private final int portStart;\n-        private final int portEnd;\n-        PortRangeRule(Action action, int portStart, int portEnd) {\n-            this.action = action;\n-            this.portStart = portStart;\n-            this.portEnd = portEnd;\n-        }\n-        Action action() {\n-            return action;\n-        }\n-        @Override\n-        public boolean match(Action action, InetAddress address, int port) {\n-            return (action == this.action &&\n-                    port >= this.portStart &&\n-                    port <= this.portEnd);\n-        }\n-    }\n-\n-    \/\/ rule to match address[\/prefix] port[-end]\n-    private static class AddressPortRangeRule extends PortRangeRule {\n-        private final byte[] addressAsBytes;\n-        private final int prefixByteCount;\n-        private final byte mask;\n-        AddressPortRangeRule(Action action, InetAddress address,\n-                             int prefix, int port, int end)\n-        {\n-            super(action, port, end);\n-            this.addressAsBytes = address.getAddress();\n-            this.prefixByteCount = prefix >> 3;\n-            this.mask = (byte)(0xff << (8 - (prefix % 8)));\n-        }\n-        @Override\n-        public boolean match(Action action, InetAddress address, int port) {\n-            if (action != action())\n-                return false;\n-            byte[] candidate = address.getAddress();\n-            \/\/ same address type?\n-            if (candidate.length != addressAsBytes.length)\n-                return false;\n-            \/\/ check bytes\n-            for (int i=0; i<prefixByteCount; i++) {\n-                if (candidate[i] != addressAsBytes[i])\n-                    return false;\n-            }\n-            \/\/ check remaining bits\n-            if ((prefixByteCount < addressAsBytes.length) &&\n-                ((candidate[prefixByteCount] & mask) !=\n-                 (addressAsBytes[prefixByteCount] & mask)))\n-                    return false;\n-            return super.match(action, address, port);\n-        }\n-    }\n-\n-    \/\/ parses port:[-end]\n-    private static int[] parsePortRange(String s) {\n-        int pos = s.indexOf('-');\n-        try {\n-            int[] result = new int[2];\n-            if (pos < 0) {\n-                boolean all = s.equals(\"*\");\n-                result[0] = all ? 0 : Integer.parseInt(s);\n-                result[1] = all ? MAX_PORT : result[0];\n-            } else {\n-                String low = s.substring(0, pos);\n-                if (low.isEmpty()) low = \"*\";\n-                String high = s.substring(pos+1);\n-                if (high.isEmpty()) high = \"*\";\n-                result[0] = low.equals(\"*\") ? 0 : Integer.parseInt(low);\n-                result[1] = high.equals(\"*\") ? MAX_PORT : Integer.parseInt(high);\n-            }\n-            return result;\n-        } catch (NumberFormatException e) {\n-            return new int[0];\n-        }\n-    }\n-\n-    private static void fail(String msg, Object... args) {\n-        Formatter f = new Formatter();\n-        f.format(msg, args);\n-        throw new RuntimeException(f.out().toString());\n-    }\n-\n-    \/\/ loads rules from the given file\n-    \/\/ Each non-blank\/non-comment line must have the format:\n-    \/\/ (\"bind\" | \"connect\") 1*LWSP-char (hostname | ipaddress[\"\/\" prefix])\n-    \/\/     1*LWSP-char (\"*\" | port) [ \"-\" (\"*\" | port) ]\n-    private static List<Rule> loadRulesFromFile(String file)\n-        throws IOException\n-    {\n-        try (Scanner scanner = new Scanner(new File(file))) {\n-            List<Rule> result = new ArrayList<>();\n-            while (scanner.hasNextLine()) {\n-                String line = scanner.nextLine().trim();\n-\n-                \/\/ skip blank lines and comments\n-                if (line.isEmpty() || line.charAt(0) == '#')\n-                    continue;\n-\n-                \/\/ must have 3 fields\n-                String[] s = line.split(\"\\\\s+\");\n-                if (s.length != 3) {\n-                    fail(\"Malformed line '%s'\", line);\n-                    continue;\n-                }\n-\n-                \/\/ first field is the action (\"bind\" or \"connect\")\n-                Action action = null;\n-                for (Action a: Action.values()) {\n-                    if (s[0].equalsIgnoreCase(a.name())) {\n-                        action = a;\n-                        break;\n-                    }\n-                }\n-                if (action == null) {\n-                    fail(\"Action '%s' not recognized\", s[0]);\n-                    continue;\n-                }\n-\n-                \/\/ * port[-end]\n-                int[] ports = parsePortRange(s[2]);\n-                if (ports.length == 0) {\n-                    fail(\"Malformed port range '%s'\", s[2]);\n-                    continue;\n-                }\n-\n-                \/\/ match all addresses\n-                if (s[1].equals(\"*\")) {\n-                    result.add(new PortRangeRule(action, ports[0], ports[1]));\n-                    continue;\n-                }\n-\n-                \/\/ hostname | ipaddress[\/prefix]\n-                int pos = s[1].indexOf('\/');\n-                try {\n-                    if (pos < 0) {\n-                        \/\/ hostname or ipaddress (no prefix)\n-                        InetAddress[] addresses = InetAddress.getAllByName(s[1]);\n-                        for (InetAddress address: addresses) {\n-                            int prefix =\n-                                (address instanceof Inet4Address) ? 32 : 128;\n-                            result.add(new AddressPortRangeRule(action, address,\n-                                prefix, ports[0], ports[1]));\n-                        }\n-                    } else {\n-                        \/\/ ipaddress\/prefix\n-                        InetAddress address = InetAddress\n-                            .getByName(s[1].substring(0, pos));\n-                        int prefix = -1;\n-                        try {\n-                            prefix = Integer.parseInt(s[1], pos + 1,\n-                                s[1].length(), 10);\n-                            if (address instanceof Inet4Address) {\n-                                \/\/ must be 1-31\n-                                if (prefix < 0 || prefix > 32) prefix = -1;\n-                            } else {\n-                                \/\/ must be 1-128\n-                                if (prefix < 0 || prefix > 128) prefix = -1;\n-                            }\n-                        } catch (NumberFormatException e) {\n-                        }\n-\n-                        if (prefix > 0) {\n-                            result.add(new AddressPortRangeRule(action,\n-                                        address, prefix, ports[0], ports[1]));\n-                        } else {\n-                            fail(\"Malformed prefix '%s'\", s[1]);\n-                            continue;\n-                        }\n-                    }\n-                } catch (UnknownHostException uhe) {\n-                    fail(\"Unknown host or malformed IP address '%s'\", s[1]);\n-                    continue;\n-                }\n-            }\n-            return result;\n-        }\n-    }\n-\n-    \/\/ converts unbound TCP socket to a SDP socket if it matches the rules\n-    private void convertTcpToSdpIfMatch(FileDescriptor fdObj,\n-                                               Action action,\n-                                               InetAddress address,\n-                                               int port)\n-        throws IOException\n-    {\n-        boolean matched = false;\n-        for (Rule rule: rules) {\n-            if (rule.match(action, address, port)) {\n-                SdpSupport.convertSocket(fdObj);\n-                matched = true;\n-                break;\n-            }\n-        }\n-        if (log != null) {\n-            String addr = (address instanceof Inet4Address) ?\n-                address.getHostAddress() : \"[\" + address.getHostAddress() + \"]\";\n-            if (matched) {\n-                log.format(\"%s to %s:%d (socket converted to SDP protocol)\\n\", action, addr, port);\n-            } else {\n-                log.format(\"%s to %s:%d (no match)\\n\", action, addr, port);\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void implBeforeTcpBind(FileDescriptor fdObj,\n-                              InetAddress address,\n-                              int port)\n-        throws IOException\n-    {\n-        if (enabled)\n-            convertTcpToSdpIfMatch(fdObj, Action.BIND, address, port);\n-    }\n-\n-    @Override\n-    public void implBeforeTcpConnect(FileDescriptor fdObj,\n-                                InetAddress address,\n-                                int port)\n-        throws IOException\n-    {\n-        if (enabled)\n-            convertTcpToSdpIfMatch(fdObj, Action.CONNECT, address, port);\n-    }\n-}\n","filename":"src\/java.base\/unix\/classes\/sun\/net\/sdp\/SdpProvider.java","additions":0,"deletions":326,"binary":false,"changes":326,"status":"deleted"},{"patch":"@@ -38,1 +38,0 @@\n-import sun.net.NetHooks;\n@@ -313,1 +312,0 @@\n-        boolean notifyBeforeTcpConnect;\n@@ -321,1 +319,0 @@\n-            notifyBeforeTcpConnect = (localAddress == null);\n@@ -327,3 +324,0 @@\n-            \/\/ notify hook if unbound\n-            if (notifyBeforeTcpConnect)\n-                NetHooks.beforeTcpConnect(fd, isa.getAddress(), isa.getPort());\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/UnixAsynchronousSocketChannelImpl.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,30 +0,0 @@\n-#\n-# Configuration file to enable InfiniBand Sockets Direct Protocol.\n-#\n-# Each line that does not start with a comment (#) is a rule to indicate when\n-# the SDP transport protocol should be used. The format of a rule is as follows:\n-#   (\"bind\"|\"connect\") 1*LWSP-char (hostname|ipaddress[\"\/\"prefix]) 1*LWSP-char (\"*\"|port)[\"-\"(\"*\"|port)]\n-#\n-# A \"bind\" rule indicates that the SDP protocol transport should be used when\n-# a TCP socket binds to an address\/port that matches the rule. A \"connect\" rule\n-# indicates that the SDP protocol transport should be used when an unbound\n-# TCP socket attempts to connect to an address\/port that matches the rule.\n-# Addresses may be specified as hostnames or literal Internet Protocol (IP)\n-# addresses. When a literal IP address is used then a prefix length may be used\n-# to indicate the number of bits for matching (useful when a block of addresses\n-# or subnet is allocated to the InfiniBand fabric). \n-\n-# Use SDP for all sockets that bind to specific local addresses\n-#bind    192.168.1.1    *\n-#bind    fe80::21b:24ff:fe3d:7896    *\n-\n-# Use SDP for all sockets that bind to the wildcard address in a port range\n-#bind    0.0.0.0    5000-5999\n-#bind    ::0        5000-5999\n-\n-# Use SDP when connecting to all application services on 192.168.1.*\n-#connect 192.168.1.0\/24       1024-*\n-\n-# Use SDP when connecting to the http server or MySQL database on hpccluster.\n-#connect hpccluster.foo.com   80\n-#connect hpccluster.foo.com   3306\n","filename":"src\/java.base\/unix\/conf\/sdp\/sdp.conf.template","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,112 +0,0 @@\n-\/*\n- * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <sys\/types.h>\n-#include <sys\/socket.h>\n-#include <errno.h>\n-\n-#if defined(__linux__)\n-  #if !defined(AF_INET_SDP)\n-    #define AF_INET_SDP     27\n-  #endif\n-#endif\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"net_util.h\"\n-\n-\/**\n- * Creates a SDP socket.\n- *\/\n-static int create(JNIEnv* env)\n-{\n-    int s;\n-\n-#if defined(__linux__)\n-    \/**\n-     * IPv6 not supported by SDP on Linux\n-     *\/\n-    if (ipv6_available()) {\n-        JNU_ThrowIOException(env, \"IPv6 not supported\");\n-        return -1;\n-    }\n-    s = socket(AF_INET_SDP, SOCK_STREAM, 0);\n-#else\n-    \/* not supported on other platforms at this time *\/\n-    s = -1;\n-    errno = EPROTONOSUPPORT;\n-#endif\n-\n-    if (s < 0)\n-        JNU_ThrowIOExceptionWithLastError(env, \"socket\");\n-    return s;\n-}\n-\n-\/**\n- * Creates a SDP socket, returning file descriptor referencing the socket.\n- *\/\n-JNIEXPORT jint JNICALL\n-Java_sun_net_sdp_SdpSupport_create0(JNIEnv *env, jclass cls)\n-{\n-    return create(env);\n-}\n-\n-\/**\n- * Converts an existing file descriptor, that references an unbound TCP socket,\n- * to SDP.\n- *\/\n-JNIEXPORT void JNICALL\n-Java_sun_net_sdp_SdpSupport_convert0(JNIEnv *env, jclass cls, int fd)\n-{\n-    int s = create(env);\n-    if (s >= 0) {\n-        socklen_t len;\n-        int arg, res;\n-        struct linger linger;\n-\n-        \/* copy socket options that are relevant to SDP *\/\n-        len = sizeof(arg);\n-        if (getsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char*)&arg, &len) == 0)\n-            setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char*)&arg, len);\n-#ifdef SO_REUSEPORT\n-        len = sizeof(arg);\n-        if (getsockopt(fd, SOL_SOCKET, SO_REUSEPORT, (char*)&arg, &len) == 0)\n-            setsockopt(s, SOL_SOCKET, SO_REUSEPORT, (char*)&arg, len);\n-#endif\n-        len = sizeof(arg);\n-        if (getsockopt(fd, SOL_SOCKET, SO_OOBINLINE, (char*)&arg, &len) == 0)\n-            setsockopt(s, SOL_SOCKET, SO_OOBINLINE, (char*)&arg, len);\n-        len = sizeof(linger);\n-        if (getsockopt(fd, SOL_SOCKET, SO_LINGER, (void*)&linger, &len) == 0)\n-            setsockopt(s, SOL_SOCKET, SO_LINGER, (char*)&linger, len);\n-\n-        RESTARTABLE(dup2(s, fd), res);\n-        if (res < 0)\n-            JNU_ThrowIOExceptionWithLastError(env, \"dup2\");\n-        res = close(s);\n-        if (res < 0 && !(*env)->ExceptionCheck(env))\n-            JNU_ThrowIOExceptionWithLastError(env, \"close\");\n-    }\n-}\n","filename":"src\/java.base\/unix\/native\/libnet\/SdpSupport.c","additions":0,"deletions":112,"binary":false,"changes":112,"status":"deleted"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package sun.net;\n-\n-import java.net.InetAddress;\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-\n-\/**\n- * Defines static methods to ensure that any installed net hooks are invoked\n- * prior to binding or connecting TCP sockets.\n- *\/\n-\n-public final class NetHooks {\n-\n-    \/**\n-     * Invoke prior to binding a TCP socket.\n-     *\/\n-    public static void beforeTcpBind(FileDescriptor fdObj,\n-                                     InetAddress address,\n-                                     int port)\n-        throws IOException\n-    {\n-        \/\/ nothing to do\n-    }\n-\n-    \/**\n-     * Invoke prior to connecting an unbound TCP socket.\n-     *\/\n-    public static void beforeTcpConnect(FileDescriptor fdObj,\n-                                        InetAddress address,\n-                                        int port)\n-        throws IOException\n-    {\n-        \/\/ nothing to do\n-    }\n-}\n","filename":"src\/java.base\/windows\/classes\/sun\/net\/NetHooks.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"}]}