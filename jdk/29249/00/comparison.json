{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,3 @@\n+#include \"gc\/shared\/partialArraySplitter.inline.hpp\"\n+#include \"gc\/shared\/partialArrayState.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStats.hpp\"\n@@ -79,0 +82,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -102,1 +106,1 @@\n-  _task->scan_task_entry(G1TaskQueueEntry::from_oop(cast_to_oop(addr)));\n+  _task->scan_task_entry(G1TaskQueueEntry(cast_to_oop(addr)), false \/* stolen *\/);\n@@ -493,0 +497,1 @@\n+  _partial_array_state_manager(new PartialArrayStateManager(_max_num_tasks)),\n@@ -559,0 +564,4 @@\n+PartialArrayStateManager* G1ConcurrentMark::partial_array_state_manager() const {\n+  return _partial_array_state_manager;\n+}\n+\n@@ -653,0 +662,19 @@\n+#if TASKQUEUE_STATS\n+void G1ConcurrentMark::print_and_reset_taskqueue_stats() {\n+\n+  _task_queues->print_and_reset_taskqueue_stats(\"G1ConcurrentMark Oop Queue\");\n+\n+  auto get_pa_stats = [&](uint i) {\n+    return _tasks[i]->partial_array_task_stats();\n+  };\n+\n+  PartialArrayTaskStats::log_set(_max_num_tasks, get_pa_stats,\n+                                 \"G1ConcurrentMark Partial Array Task Stats\");\n+\n+  for (uint i = 0; i < _max_num_tasks; ++i) {\n+    get_pa_stats(i)->reset();\n+  }\n+}\n+#endif\n+\n+\n@@ -654,0 +682,1 @@\n+  TASKQUEUE_STATS_ONLY(print_and_reset_taskqueue_stats());\n@@ -807,0 +836,2 @@\n+  reset_partial_array_state_manager();\n+\n@@ -812,0 +843,12 @@\n+void G1ConcurrentMark::reset_partial_array_state_manager() {\n+  for (uint i = 0; i < _max_num_tasks; ++i) {\n+    _tasks[i]->unregister_partial_array_splitter();\n+  }\n+\n+  partial_array_state_manager()->reset();\n+\n+  for (uint i = 0; i < _max_num_tasks; ++i) {\n+    _tasks[i]->register_partial_array_splitter();\n+  }\n+}\n+\n@@ -1792,2 +1835,3 @@\n-    if (task_entry.is_array_slice()) {\n-      guarantee(_g1h->is_in_reserved(task_entry.slice()), \"Slice \" PTR_FORMAT \" must be in heap.\", p2i(task_entry.slice()));\n+    if (task_entry.is_partial_array_state()) {\n+      oop obj = task_entry.to_partial_array_state()->source();\n+      guarantee(_g1h->is_in_reserved(obj), \"Partial Array \" PTR_FORMAT \" must be in heap.\", p2i(obj));\n@@ -1796,1 +1840,1 @@\n-    guarantee(oopDesc::is_oop(task_entry.obj()),\n+    guarantee(oopDesc::is_oop(task_entry.to_oop()),\n@@ -1798,2 +1842,2 @@\n-              p2i(task_entry.obj()), _phase, _info);\n-    G1HeapRegion* r = _g1h->heap_region_containing(task_entry.obj());\n+              p2i(task_entry.to_oop()), _phase, _info);\n+    G1HeapRegion* r = _g1h->heap_region_containing(task_entry.to_oop());\n@@ -1802,1 +1846,1 @@\n-              p2i(task_entry.obj()), _phase, _info, r->hrm_index());\n+              p2i(task_entry.to_oop()), _phase, _info, r->hrm_index());\n@@ -2058,0 +2102,11 @@\n+void G1CMTask::register_partial_array_splitter() {\n+\n+  ::new (&_partial_array_splitter) PartialArraySplitter(_cm->partial_array_state_manager(),\n+                                                        _cm->max_num_tasks(),\n+                                                        ObjArrayMarkingStride);\n+}\n+\n+void G1CMTask::unregister_partial_array_splitter() {\n+  _partial_array_splitter.~PartialArraySplitter();\n+}\n+\n@@ -2188,1 +2243,1 @@\n-    assert(task_entry.is_array_slice() || oopDesc::is_oop(task_entry.obj()), \"Element \" PTR_FORMAT \" must be an array slice or oop\", p2i(task_entry.obj()));\n+    assert(task_entry.is_partial_array_state() || oopDesc::is_oop(task_entry.to_oop()), \"Element \" PTR_FORMAT \" must be an array slice or oop\", p2i(task_entry.to_oop()));\n@@ -2219,1 +2274,1 @@\n-      scan_task_entry(entry);\n+      scan_task_entry(entry, false \/* stolen *\/);\n@@ -2229,0 +2284,31 @@\n+size_t G1CMTask::start_partial_objArray(oop obj) {\n+  assert(should_be_sliced(obj), \"Must be an array object %d and large %zu\", obj->is_objArray(), obj->size());\n+\n+  objArrayOop obj_array = objArrayOop(obj);\n+  size_t array_length = obj_array->length();\n+\n+  size_t initial_chunk_size = _partial_array_splitter.start(_task_queue, obj_array, nullptr, array_length);\n+\n+  \/\/ Mark objArray klass metadata\n+  if (_cm_oop_closure->do_metadata()) {\n+    _cm_oop_closure->do_klass(obj_array->klass());\n+  }\n+\n+  scan_objArray(obj_array, 0, initial_chunk_size);\n+\n+  \/\/ Include object header size\n+  return objArrayOopDesc::object_size(checked_cast<int>(initial_chunk_size));\n+}\n+\n+size_t G1CMTask::do_partial_objArray(const G1TaskQueueEntry& task, bool stolen) {\n+  PartialArrayState* state = task.to_partial_array_state();\n+  \/\/ Access state before release by claim().\n+  objArrayOop obj = objArrayOop(state->source());\n+\n+  PartialArraySplitter::Claim claim =\n+    _partial_array_splitter.claim(state, _task_queue, stolen);\n+\n+  scan_objArray(obj, claim._start, claim._end);\n+  return heap_word_size((claim._end - claim._start) * heapOopSize);\n+}\n+\n@@ -2433,1 +2519,1 @@\n-      scan_task_entry(entry);\n+      scan_task_entry(entry, true \/* stolen *\/);\n@@ -2762,1 +2848,0 @@\n-  _objArray_processor(this),\n@@ -2768,0 +2853,1 @@\n+  _partial_array_splitter(_cm->partial_array_state_manager(), _cm->max_num_tasks(), ObjArrayMarkingStride),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":98,"deletions":12,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-#include \"gc\/g1\/g1ConcurrentMarkObjArrayProcessor.hpp\"\n@@ -34,0 +33,3 @@\n+#include \"gc\/shared\/partialArraySplitter.hpp\"\n+#include \"gc\/shared\/partialArrayState.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStats.hpp\"\n@@ -56,35 +58,1 @@\n-\/\/ This is a container class for either an oop or a continuation address for\n-\/\/ mark stack entries. Both are pushed onto the mark stack.\n-class G1TaskQueueEntry {\n-private:\n-  void* _holder;\n-\n-  static const uintptr_t ArraySliceBit = 1;\n-\n-  G1TaskQueueEntry(oop obj) : _holder(obj) {\n-    assert(_holder != nullptr, \"Not allowed to set null task queue element\");\n-  }\n-  G1TaskQueueEntry(HeapWord* addr) : _holder((void*)((uintptr_t)addr | ArraySliceBit)) { }\n-public:\n-\n-  G1TaskQueueEntry() : _holder(nullptr) { }\n-  \/\/ Trivially copyable, for use in GenericTaskQueue.\n-\n-  static G1TaskQueueEntry from_slice(HeapWord* what) { return G1TaskQueueEntry(what); }\n-  static G1TaskQueueEntry from_oop(oop obj) { return G1TaskQueueEntry(obj); }\n-\n-  oop obj() const {\n-    assert(!is_array_slice(), \"Trying to read array slice \" PTR_FORMAT \" as oop\", p2i(_holder));\n-    return cast_to_oop(_holder);\n-  }\n-\n-  HeapWord* slice() const {\n-    assert(is_array_slice(), \"Trying to read oop \" PTR_FORMAT \" as array slice\", p2i(_holder));\n-    return (HeapWord*)((uintptr_t)_holder & ~ArraySliceBit);\n-  }\n-\n-  bool is_oop() const { return !is_array_slice(); }\n-  bool is_array_slice() const { return ((uintptr_t)_holder & ArraySliceBit) != 0; }\n-  bool is_null() const { return _holder == nullptr; }\n-};\n-\n+typedef ScannerTask G1TaskQueueEntry;\n@@ -414,0 +382,2 @@\n+  PartialArrayStateManager* _partial_array_state_manager;\n+\n@@ -491,0 +461,2 @@\n+  void print_and_reset_taskqueue_stats();\n+\n@@ -585,0 +557,2 @@\n+  uint max_num_tasks() const {return _max_num_tasks; }\n+\n@@ -634,0 +608,2 @@\n+  PartialArrayStateManager* partial_array_state_manager() const;\n+\n@@ -645,0 +621,4 @@\n+  \/\/ Recycle the memory that has been requested by allocators associated with\n+  \/\/ this manager.\n+  void reset_partial_array_state_manager();\n+\n@@ -735,2 +715,0 @@\n-  G1CMObjArrayProcessor       _objArray_processor;\n-\n@@ -743,0 +721,1 @@\n+  PartialArraySplitter        _partial_array_splitter;\n@@ -853,1 +832,10 @@\n-  template<bool scan> void process_grey_task_entry(G1TaskQueueEntry task_entry);\n+  template<bool scan> void process_grey_task_entry(G1TaskQueueEntry task_entry, bool stolen);\n+\n+  static bool should_be_sliced(oop obj);\n+  \/\/ Start processing the given objArrayOop by first pushing its continuations and\n+  \/\/ then scanning the first chunk including the header.\n+  size_t start_partial_objArray(oop obj);\n+  \/\/ Process the given continuation. Returns the number of words scanned.\n+  size_t do_partial_objArray(const G1TaskQueueEntry& task, bool stolen);\n+  \/\/ Apply the closure to the given range of elements in the objArray.\n+  inline void scan_objArray(objArrayOop obj, size_t start, size_t end);\n@@ -855,3 +843,0 @@\n-  \/\/ Apply the closure on the given area of the objArray. Return the number of words\n-  \/\/ scanned.\n-  inline size_t scan_objArray(objArrayOop obj, MemRegion mr);\n@@ -860,0 +845,5 @@\n+  \/\/ Register\/unregister Partial Array Splitter Allocator with the PartialArrayStateManager.\n+  \/\/ This allows us to discard memory arenas used for partial object array states at the end\n+  \/\/ of a concurrent mark cycle.\n+  void register_partial_array_splitter();\n+  void unregister_partial_array_splitter();\n@@ -915,1 +905,1 @@\n-  inline void scan_task_entry(G1TaskQueueEntry task_entry);\n+  inline void scan_task_entry(G1TaskQueueEntry task_entry, bool stolen);\n@@ -960,0 +950,5 @@\n+#if TASKQUEUE_STATS\n+  PartialArrayTaskStats* partial_array_task_stats() {\n+    return _partial_array_splitter.stats();\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":39,"deletions":44,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-#include \"gc\/g1\/g1ConcurrentMarkObjArrayProcessor.inline.hpp\"\n@@ -42,0 +41,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -110,1 +110,1 @@\n-inline void G1CMTask::scan_task_entry(G1TaskQueueEntry task_entry) { process_grey_task_entry<true>(task_entry); }\n+inline void G1CMTask::scan_task_entry(G1TaskQueueEntry task_entry, bool stolen) { process_grey_task_entry<true>(task_entry, stolen); }\n@@ -113,4 +113,4 @@\n-  assert(task_entry.is_array_slice() || _g1h->is_in_reserved(task_entry.obj()), \"invariant\");\n-  assert(task_entry.is_array_slice() || !_g1h->is_on_master_free_list(\n-              _g1h->heap_region_containing(task_entry.obj())), \"invariant\");\n-  assert(task_entry.is_array_slice() || _mark_bitmap->is_marked(cast_from_oop<HeapWord*>(task_entry.obj())), \"invariant\");\n+  assert(task_entry.is_partial_array_state() || _g1h->is_in_reserved(task_entry.to_oop()), \"invariant\");\n+  assert(task_entry.is_partial_array_state() || !_g1h->is_on_master_free_list(\n+              _g1h->heap_region_containing(task_entry.to_oop())), \"invariant\");\n+  assert(task_entry.is_partial_array_state() || _mark_bitmap->is_marked(cast_from_oop<HeapWord*>(task_entry.to_oop())), \"invariant\");\n@@ -162,3 +162,3 @@\n-inline void G1CMTask::process_grey_task_entry(G1TaskQueueEntry task_entry) {\n-  assert(scan || (task_entry.is_oop() && task_entry.obj()->is_typeArray()), \"Skipping scan of grey non-typeArray\");\n-  assert(task_entry.is_array_slice() || _mark_bitmap->is_marked(cast_from_oop<HeapWord*>(task_entry.obj())),\n+inline void G1CMTask::process_grey_task_entry(G1TaskQueueEntry task_entry, bool stolen) {\n+  assert(scan || (!task_entry.is_partial_array_state() && task_entry.to_oop()->is_typeArray()), \"Skipping scan of grey non-typeArray\");\n+  assert(task_entry.is_partial_array_state() || _mark_bitmap->is_marked(cast_from_oop<HeapWord*>(task_entry.to_oop())),\n@@ -168,2 +168,2 @@\n-    if (task_entry.is_array_slice()) {\n-      _words_scanned += _objArray_processor.process_slice(task_entry.slice());\n+    if (task_entry.is_partial_array_state()) {\n+      _words_scanned += do_partial_objArray(task_entry, stolen);\n@@ -171,3 +171,3 @@\n-      oop obj = task_entry.obj();\n-      if (G1CMObjArrayProcessor::should_be_sliced(obj)) {\n-        _words_scanned += _objArray_processor.process_obj(obj);\n+      oop obj = task_entry.to_oop();\n+      if (should_be_sliced(obj)) {\n+        _words_scanned += start_partial_objArray(obj);\n@@ -175,1 +175,1 @@\n-        _words_scanned += obj->oop_iterate_size(_cm_oop_closure);;\n+        _words_scanned += obj->oop_iterate_size(_cm_oop_closure);\n@@ -182,3 +182,8 @@\n-inline size_t G1CMTask::scan_objArray(objArrayOop obj, MemRegion mr) {\n-  obj->oop_iterate(_cm_oop_closure, mr);\n-  return mr.word_size();\n+inline bool G1CMTask::should_be_sliced(oop obj) {\n+  return obj->is_objArray() && ((objArrayOop)obj)->length() >= (int)ObjArrayMarkingStride;\n+}\n+\n+inline void G1CMTask::scan_objArray(objArrayOop obj, size_t start, size_t end) {\n+  obj->oop_iterate_elements_range(_cm_oop_closure,\n+                                  checked_cast<int>(start),\n+                                  checked_cast<int>(end));\n@@ -268,1 +273,1 @@\n-    G1TaskQueueEntry entry = G1TaskQueueEntry::from_oop(obj);\n+    G1TaskQueueEntry entry(obj);\n@@ -280,1 +285,1 @@\n-      process_grey_task_entry<false>(entry);\n+      process_grey_task_entry<false>(entry, false \/* stolen *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.inline.hpp","additions":26,"deletions":21,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n-#include \"gc\/g1\/g1ConcurrentMark.inline.hpp\"\n-#include \"gc\/g1\/g1ConcurrentMarkObjArrayProcessor.inline.hpp\"\n-#include \"gc\/g1\/g1HeapRegion.inline.hpp\"\n-#include \"gc\/shared\/gc_globals.hpp\"\n-#include \"memory\/memRegion.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-void G1CMObjArrayProcessor::push_array_slice(HeapWord* what) {\n-  _task->push(G1TaskQueueEntry::from_slice(what));\n-}\n-\n-size_t G1CMObjArrayProcessor::process_array_slice(objArrayOop obj, HeapWord* start_from, size_t remaining) {\n-  size_t words_to_scan = MIN2(remaining, (size_t)ObjArrayMarkingStride);\n-\n-  if (remaining > ObjArrayMarkingStride) {\n-    push_array_slice(start_from + ObjArrayMarkingStride);\n-  }\n-\n-  \/\/ Then process current area.\n-  MemRegion mr(start_from, words_to_scan);\n-  return _task->scan_objArray(obj, mr);\n-}\n-\n-size_t G1CMObjArrayProcessor::process_obj(oop obj) {\n-  assert(should_be_sliced(obj), \"Must be an array object %d and large %zu\", obj->is_objArray(), obj->size());\n-\n-  return process_array_slice(objArrayOop(obj), cast_from_oop<HeapWord*>(obj), objArrayOop(obj)->size());\n-}\n-\n-size_t G1CMObjArrayProcessor::process_slice(HeapWord* slice) {\n-\n-  \/\/ Find the start address of the objArrayOop.\n-  \/\/ Shortcut the BOT access if the given address is from a humongous object. The BOT\n-  \/\/ slide is fast enough for \"smaller\" objects in non-humongous regions, but is slower\n-  \/\/ than directly using heap region table.\n-  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-  G1HeapRegion* r = g1h->heap_region_containing(slice);\n-\n-  HeapWord* const start_address = r->is_humongous() ?\n-                                  r->humongous_start_region()->bottom() :\n-                                  r->block_start(slice);\n-\n-  assert(cast_to_oop(start_address)->is_objArray(), \"Address \" PTR_FORMAT \" does not refer to an object array \", p2i(start_address));\n-  assert(start_address < slice,\n-         \"Object start address \" PTR_FORMAT \" must be smaller than decoded address \" PTR_FORMAT,\n-         p2i(start_address),\n-         p2i(slice));\n-\n-  objArrayOop objArray = objArrayOop(cast_to_oop(start_address));\n-\n-  size_t already_scanned = pointer_delta(slice, start_address);\n-  size_t remaining = objArray->size() - already_scanned;\n-\n-  return process_array_slice(objArray, slice, remaining);\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkObjArrayProcessor.cpp","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1CONCURRENTMARKOBJARRAYPROCESSOR_HPP\n-#define SHARE_GC_G1_G1CONCURRENTMARKOBJARRAYPROCESSOR_HPP\n-\n-#include \"oops\/oopsHierarchy.hpp\"\n-\n-class G1CMTask;\n-\n-\/\/ Helper class to mark through large objArrays during marking in an efficient way.\n-\/\/ Instead of pushing large object arrays, we push continuations onto the\n-\/\/ mark stack. These continuations are identified by having their LSB set.\n-\/\/ This allows incremental processing of large objects.\n-class G1CMObjArrayProcessor {\n-private:\n-  \/\/ Reference to the task for doing the actual work.\n-  G1CMTask* _task;\n-\n-  \/\/ Push the continuation at the given address onto the mark stack.\n-  void push_array_slice(HeapWord* addr);\n-\n-  \/\/ Process (apply the closure) on the given continuation of the given objArray.\n-  size_t process_array_slice(objArrayOop const obj, HeapWord* start_from, size_t remaining);\n-public:\n-  static bool should_be_sliced(oop obj);\n-\n-  G1CMObjArrayProcessor(G1CMTask* task) : _task(task) {\n-  }\n-\n-  \/\/ Process the given continuation. Returns the number of words scanned.\n-  size_t process_slice(HeapWord* slice);\n-  \/\/ Start processing the given objArrayOop by scanning the header and pushing its\n-  \/\/ continuation.\n-  size_t process_obj(oop obj);\n-};\n-\n-#endif \/\/ SHARE_GC_G1_G1CONCURRENTMARKOBJARRAYPROCESSOR_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkObjArrayProcessor.hpp","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1CONCURRENTMARKOBJARRAYPROCESSOR_INLINE_HPP\n-#define SHARE_GC_G1_G1CONCURRENTMARKOBJARRAYPROCESSOR_INLINE_HPP\n-\n-#include \"gc\/g1\/g1ConcurrentMarkObjArrayProcessor.hpp\"\n-\n-#include \"gc\/shared\/gc_globals.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"oops\/oopsHierarchy.hpp\"\n-\n-inline bool G1CMObjArrayProcessor::should_be_sliced(oop obj) {\n-  return obj->is_objArray() && ((objArrayOop)obj)->size() >= 2 * ObjArrayMarkingStride;\n-}\n-\n-#endif \/\/ SHARE_GC_G1_G1CONCURRENTMARKOBJARRAYPROCESSOR_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkObjArrayProcessor.inline.hpp","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -644,0 +644,4 @@\n+  bool is_null() const {\n+    return _p == nullptr;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}