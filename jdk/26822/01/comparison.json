{"files":[{"patch":"@@ -693,5 +693,2 @@\n-     *\n-     * @param  noShare\n-     *         {@code true} if the resulting string MUST NOT share the byte array,\n-     *         {@code false} if the byte array can be exclusively used to construct\n-     *         the string and is not modified or used for any other purpose.\n+     * The byte array can be exclusively used to construct\n+     * the string and is not modified or used for any other purpose.\n@@ -699,1 +696,1 @@\n-    static String newStringUTF8NoRepl(byte[] bytes, int offset, int length, boolean noShare) {\n+    static String newStringUTF8NoRepl(byte[] bytes, int offset, int length) {\n@@ -710,1 +707,1 @@\n-                if (noShare || length != bytes.length) {\n+                if (length != bytes.length) {\n@@ -762,0 +759,13 @@\n+    \/**\n+     * {@return a new {@code String} created using the given byte array that is\n+     * encoded in specified charset}\n+     * <p>\n+     * <b>WARNING: The caller of this method is assumed to have relinquished\n+     * and transferred the ownership of the byte array<\/b>. It can thus be\n+     * exclusively used to construct the {@code String}.\n+     *\n+     * @param src byte array containing encoded characters\n+     * @param cs charset the byte array encoded in\n+     *\n+     * @throws CharacterCodingException for malformed input or unmappable characters\n+     *\/\n@@ -781,1 +791,1 @@\n-            return newStringUTF8NoRepl(src, 0, src.length, false);\n+            return newStringUTF8NoRepl(src, 0, src.length);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2143,4 +2143,0 @@\n-            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n-                return String.newStringUTF8NoRepl(bytes, off, len, true);\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -255,1 +256,7 @@\n-            return JLA.newStringUTF8NoRepl(ba, off, length);\n+            try {\n+                \/\/ Copy subrange for exclusive use by the string being created\n+                byte[] bytes = Arrays.copyOfRange(ba, off, off + length);\n+                return JLA.uncheckedNewStringNoRepl(bytes, StandardCharsets.UTF_8);\n+            } catch (CharacterCodingException cce) {\n+                throw new IllegalArgumentException(cce);\n+            }\n@@ -276,1 +283,1 @@\n-                return hash(JLA.newStringUTF8NoRepl(a, off, len));\n+                return hash(toString(a, off, len));\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipCoder.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -353,10 +353,0 @@\n-    \/**\n-     * Returns a new string by decoding from the given UTF-8 bytes array.\n-     *\n-     * @param off the index of the first byte to decode\n-     * @param len the number of bytes to decode\n-     * @return the newly created string\n-     * @throws IllegalArgumentException for malformed or unmappable bytes.\n-     *\/\n-    String newStringUTF8NoRepl(byte[] bytes, int off, int len);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"}]}