{"files":[{"patch":"@@ -2738,17 +2738,5 @@\n-Handle java_lang_Throwable::get_cause_with_stack_trace(Handle throwable, TRAPS) {\n-  \/\/ Call to JVM to fill in the stack trace and clear declaringClassObject to\n-  \/\/ not keep classes alive in the stack trace.\n-  \/\/ call this:  public StackTraceElement[] getStackTrace()\n-  assert(throwable.not_null(), \"shouldn't be\");\n-\n-  JavaValue result(T_ARRAY);\n-  JavaCalls::call_virtual(&result, throwable,\n-                          vmClasses::Throwable_klass(),\n-                          vmSymbols::getStackTrace_name(),\n-                          vmSymbols::getStackTrace_signature(),\n-                          CHECK_NH);\n-  Handle stack_trace(THREAD, result.get_oop());\n-  assert(stack_trace->is_objArray(), \"Should be an array\");\n-\n-  \/\/ Throw ExceptionInInitializerError as the cause with this exception in\n-  \/\/ the message and stack trace.\n+Handle java_lang_Throwable::create_initialization_error(JavaThread* current, Handle throwable) {\n+  \/\/ Creates an ExceptionInInitializerError to be recorded as the initialization error when class initialization\n+  \/\/ failed due to the passed in 'throwable'. We cannot save 'throwable' directly due to issues with keeping alive\n+  \/\/ all objects referenced via its stacktrace. So instead we save a new EIIE instance, with the same message and\n+  \/\/ symbolic stacktrace of 'throwable'.\n@@ -2758,1 +2746,1 @@\n-  ResourceMark rm(THREAD);\n+  ResourceMark rm(current);\n@@ -2763,1 +2751,1 @@\n-    st.print(\"[in thread \\\"%s\\\"]\", THREAD->name());\n+    st.print(\"[in thread \\\"%s\\\"]\", current->name());\n@@ -2765,1 +2753,1 @@\n-    st.print(\"%s [in thread \\\"%s\\\"]\", message->as_C_string(), THREAD->name());\n+    st.print(\"%s [in thread \\\"%s\\\"]\", message->as_C_string(), current->name());\n@@ -2769,4 +2757,4 @@\n-  Handle h_cause = Exceptions::new_exception(THREAD, exception_name, st.as_string());\n-\n-  \/\/ If new_exception returns a different exception while creating the exception, return null.\n-  if (h_cause->klass()->name() != exception_name) {\n+  Handle h_eiie = Exceptions::new_exception(current, exception_name, st.as_string());\n+  \/\/ If new_exception returns a different exception while creating the exception,\n+  \/\/ abandon the attempts to save the initialization error and return null.\n+  if (h_eiie->klass()->name() != exception_name) {\n@@ -2774,1 +2762,1 @@\n-                          h_cause->klass()->external_name());\n+                        h_eiie->klass()->external_name());\n@@ -2777,4 +2765,24 @@\n-  java_lang_Throwable::set_stacktrace(h_cause(), stack_trace());\n-  \/\/ Clear backtrace because the stacktrace should be used instead.\n-  set_backtrace(h_cause(), nullptr);\n-  return h_cause;\n+\n+  \/\/ Call to java to fill in the stack trace and clear declaringClassObject to\n+  \/\/ not keep classes alive in the stack trace.\n+  \/\/ call this:  public StackTraceElement[] getStackTrace()\n+  assert(throwable.not_null(), \"shouldn't be\");\n+  JavaValue result(T_ARRAY);\n+  JavaCalls::call_virtual(&result, throwable,\n+                          vmClasses::Throwable_klass(),\n+                          vmSymbols::getStackTrace_name(),\n+                          vmSymbols::getStackTrace_signature(),\n+                          current);\n+  if (!current->has_pending_exception()){\n+    Handle stack_trace(current, result.get_oop());\n+    assert(stack_trace->is_objArray(), \"Should be an array\");\n+    java_lang_Throwable::set_stacktrace(h_eiie(), stack_trace());\n+    \/\/ Clear backtrace because the stacktrace should be used instead.\n+    set_backtrace(h_eiie(), nullptr);\n+  } else {\n+    log_info(class, init)(\"Exception thrown while getting stack trace for initialization exception %s\",\n+                        h_eiie->klass()->external_name());\n+    current->clear_pending_exception();\n+  }\n+\n+  return h_eiie;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":37,"deletions":29,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -618,1 +618,1 @@\n-  static Handle get_cause_with_stack_trace(Handle throwable, TRAPS);\n+  static Handle create_initialization_error(JavaThread* current, Handle throwable);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -983,3 +983,4 @@\n-  Handle cause = java_lang_Throwable::get_cause_with_stack_trace(exception, THREAD);\n-  if (HAS_PENDING_EXCEPTION || cause.is_null()) {\n-    CLEAR_PENDING_EXCEPTION;\n+  Handle init_error = java_lang_Throwable::create_initialization_error(current, exception);\n+\n+  if ( init_error.is_null()) {\n+    log_trace(class, init)(\"Initialization error is null for class %s\", external_name());\n@@ -990,2 +991,2 @@\n-  OopHandle elem = OopHandle(Universe::vm_global(), cause());\n-  bool created = false;\n+  OopHandle elem = OopHandle(Universe::vm_global(), init_error());\n+  bool created;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"}]}