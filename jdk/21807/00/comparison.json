{"files":[{"patch":"@@ -52,1 +52,0 @@\n-MICROBENCHMARK_INDIFY_DONE := $(MICROBENCHMARK_CLASSES)\/_indify.marker\n@@ -74,11 +73,0 @@\n-#### Compile Indify tool\n-\n-$(eval $(call SetupJavaCompilation, BUILD_INDIFY, \\\n-    TARGET_RELEASE := $(TARGET_RELEASE_BOOTJDK), \\\n-    SRC := $(TOPDIR)\/test\/jdk\/java\/lang\/invoke, \\\n-    INCLUDE_FILES := indify\/Indify.java, \\\n-    DISABLED_WARNINGS := this-escape rawtypes serial options, \\\n-    BIN := $(MICROBENCHMARK_TOOLS_CLASSES), \\\n-    JAVAC_FLAGS := -XDstringConcat=inline -Xprefer:newer, \\\n-))\n-\n@@ -127,8 +115,0 @@\n-# Run Indify\n-$(MICROBENCHMARK_INDIFY_DONE): $(BUILD_INDIFY) $(BUILD_JDK_MICROBENCHMARK)\n-\t$(call LogWarn, Running Indify on microbenchmark classes)\n-\t$(JAVA_SMALL) -cp $(MICROBENCHMARK_TOOLS_CLASSES) \\\n-\t    indify.Indify --overwrite $(MICROBENCHMARK_CLASSES) \\\n-\t    $(LOG_DEBUG) 2>&1\n-\t$(TOUCH) $@\n-\n@@ -147,2 +127,1 @@\n-    DEPENDENCIES := $(BUILD_JDK_MICROBENCHMARK) $(JMH_UNPACKED_JARS_DONE) \\\n-        $(MICROBENCHMARK_INDIFY_DONE), \\\n+    DEPENDENCIES := $(BUILD_JDK_MICROBENCHMARK) $(JMH_UNPACKED_JARS_DONE), \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":22,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1,214 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.java.lang.invoke;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.TearDown;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.invoke.CallSite;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.invoke.MutableCallSite;\n-import java.lang.invoke.VolatileCallSite;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-\/**\n- * This benchmark evaluates INDY performance under dynamic target updates.\n- *\/\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@State(Scope.Thread)\n-@Warmup(iterations = 10, time = 2, timeUnit = TimeUnit.SECONDS)\n-@Measurement(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)\n-@Fork(3)\n-public class CallSiteSetTarget {\n-\n-    \/*\n-     * Implementation notes:\n-     *   - This test makes sense for mutable and volatile call sites only\n-     *   - Multiple threads are calling the same callsite, and invalidator thread tries to swap target on the fly.\n-     *   - Additional baseline includes \"raw\" test, calling callsite's MH directly\n-     *\/\n-\n-    private static volatile CallSite cs;\n-\n-    private static MethodHandle doCall1;\n-    private static MethodHandle doCall2;\n-\n-    static {\n-        try {\n-            doCall1 = MethodHandles.lookup().findVirtual(CallSiteSetTarget.class, \"call1\", MethodType.methodType(int.class));\n-            doCall2 = MethodHandles.lookup().findVirtual(CallSiteSetTarget.class, \"call2\", MethodType.methodType(int.class));\n-            cs = new MutableCallSite(doCall1);\n-        } catch (NoSuchMethodException | IllegalAccessException e) {\n-            throw new IllegalStateException(e);\n-        }\n-    }\n-\n-    private int i1;\n-    private int i2;\n-\n-    public int call1() {\n-        return i1++;\n-    }\n-\n-    public int call2() {\n-        return i2++;\n-    }\n-\n-    @Benchmark\n-    public int baselineRaw() throws Throwable {\n-        return (int) cs.getTarget().invokeExact(this);\n-    }\n-\n-    @Benchmark\n-    public int testMutable() throws Throwable {\n-        return (int) INDY_Mutable().invokeExact(this);\n-    }\n-\n-    @Benchmark\n-    public int testVolatile() throws Throwable {\n-        return (int) INDY_Volatile().invokeExact(this);\n-    }\n-\n-    \/* =========================== INDY TRAMPOLINES ============================== *\/\n-\n-    private static MethodType MT_bsm() {\n-        shouldNotCallThis();\n-        return MethodType.methodType(CallSite.class, MethodHandles.Lookup.class, String.class, MethodType.class);\n-    }\n-\n-    private static MethodHandle MH_bsm_Mutable() throws ReflectiveOperationException {\n-        shouldNotCallThis();\n-        return MethodHandles.lookup().findStatic(MethodHandles.lookup().lookupClass(), \"bsm_Mutable\", MT_bsm());\n-    }\n-\n-    private static MethodHandle MH_bsm_Volatile() throws ReflectiveOperationException {\n-        shouldNotCallThis();\n-        return MethodHandles.lookup().findStatic(MethodHandles.lookup().lookupClass(), \"bsm_Volatile\", MT_bsm());\n-    }\n-\n-    private static MethodHandle INDY_Mutable() throws Throwable {\n-        shouldNotCallThis();\n-        return ((CallSite) MH_bsm_Mutable().invoke(MethodHandles.lookup(), \"doCall1\", MethodType.methodType(int.class, CallSiteSetTarget.class))).dynamicInvoker();\n-    }\n-\n-    private static MethodHandle INDY_Volatile() throws Throwable {\n-        shouldNotCallThis();\n-        return ((CallSite) MH_bsm_Volatile().invoke(MethodHandles.lookup(), \"doCall1\", MethodType.methodType(int.class, CallSiteSetTarget.class))).dynamicInvoker();\n-    }\n-\n-    public static CallSite bsm_Mutable(MethodHandles.Lookup lookup, String name, MethodType type) {\n-        synchronized (CallSiteSetTarget.class) {\n-            if (cs == null)\n-                cs = new MutableCallSite(doCall1);\n-            return cs;\n-        }\n-    }\n-\n-    public static CallSite bsm_Volatile(MethodHandles.Lookup lookup, String name, MethodType type) {\n-        synchronized (CallSiteSetTarget.class) {\n-            if (cs == null)\n-                cs = new VolatileCallSite(doCall1);\n-            return cs;\n-        }\n-    }\n-\n-    private static void shouldNotCallThis() {\n-        \/\/ if this gets called, the transformation has not taken place\n-        throw new AssertionError(\"this code should be statically transformed away by Indify\");\n-    }\n-\n-    \/* =========================== INVALIDATE LOGIC ============================== *\/\n-\n-    private final static Invalidator invalidator = new Invalidator();\n-\n-    @Setup\n-    public void setup() {\n-        invalidator.start();\n-    }\n-\n-    @TearDown\n-    public void tearDown() throws InterruptedException {\n-        invalidator.stop();\n-    }\n-\n-    public static class Invalidator implements Runnable {\n-\n-        private final long period = Integer.getInteger(\"period\", 1000);\n-\n-        private final AtomicBoolean started = new AtomicBoolean();\n-        private volatile Thread thread;\n-\n-        @Override\n-        public void run() {\n-            try {\n-                while(!Thread.interrupted()) {\n-                    if (cs != null) {\n-                        cs.setTarget(doCall1);\n-                    }\n-                    TimeUnit.MICROSECONDS.sleep(period);\n-\n-                    if (cs != null) {\n-                        cs.setTarget(doCall2);\n-                    }\n-                    TimeUnit.MICROSECONDS.sleep(period);\n-                }\n-            } catch (InterruptedException e) {\n-                \/\/ do nothing\n-            }\n-        }\n-\n-        public void start() {\n-            if (started.compareAndSet(false, true)) {\n-                thread = new Thread(this);\n-                thread.setPriority(Thread.MAX_PRIORITY);\n-                thread.start();\n-            }\n-        }\n-\n-        public void stop() {\n-            if (thread != null) {\n-                thread.interrupt();\n-                try {\n-                    thread.join();\n-                } catch (InterruptedException e) {\n-                    Thread.currentThread().interrupt();\n-                }\n-                started.set(false);\n-            }\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/CallSiteSetTarget.java","additions":0,"deletions":214,"binary":false,"changes":214,"status":"deleted"},{"patch":"@@ -1,155 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.java.lang.invoke;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.invoke.CallSite;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.invoke.MutableCallSite;\n-import java.lang.invoke.VolatileCallSite;\n-import java.util.concurrent.TimeUnit;\n-\n-\/**\n- * This benchmark evaluates INDY performance under dynamic target updates.\n- *\/\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@State(Scope.Thread)\n-@Warmup(iterations = 10, time = 2, timeUnit = TimeUnit.SECONDS)\n-@Measurement(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)\n-@Fork(3)\n-public class CallSiteSetTargetSelf {\n-\n-    \/*\n-     * Implementation notes:\n-     *   - This test makes sense for mutable and volatile call sites only\n-     *   - Multiple threads are calling the same callsite, and each call is swapping the target.\n-     *   - Additional baseline includes \"raw\" test, calling callsite's MH directly\n-     *\n-     *   - NOTE: invalidating shared target callsite is very bad with multiple threads.\n-     *     I.e. this test is inherently non-scalable.\n-     *\/\n-\n-    private static CallSite cs;\n-\n-    private static MethodHandle doCall1;\n-    private static MethodHandle doCall2;\n-\n-    static {\n-        try {\n-            doCall1 = MethodHandles.lookup().findVirtual(CallSiteSetTargetSelf.class, \"call1\", MethodType.methodType(int.class));\n-            doCall2 = MethodHandles.lookup().findVirtual(CallSiteSetTargetSelf.class, \"call2\", MethodType.methodType(int.class));\n-            cs = new MutableCallSite(doCall1);\n-        } catch (NoSuchMethodException | IllegalAccessException e) {\n-            throw new IllegalStateException(e);\n-        }\n-    }\n-\n-    private int i1;\n-    private int i2;\n-\n-    public int call1() {\n-        cs.setTarget(doCall2);\n-        return i1++;\n-    }\n-\n-    public int call2() {\n-        cs.setTarget(doCall1);\n-        return i2++;\n-    }\n-\n-    @Benchmark\n-    public int baselineRaw() throws Throwable {\n-        return (int) cs.getTarget().invokeExact(this);\n-    }\n-\n-    @Benchmark\n-    public int testMutable() throws Throwable {\n-        return (int) INDY_Mutable().invokeExact(this);\n-    }\n-\n-    @Benchmark\n-    public int testVolatile() throws Throwable {\n-        return (int) INDY_Volatile().invokeExact(this);\n-    }\n-\n-    \/* =========================== INDY TRAMPOLINES ============================== *\/\n-\n-    private static MethodType MT_bsm() {\n-        shouldNotCallThis();\n-        return MethodType.methodType(CallSite.class, MethodHandles.Lookup.class, String.class, MethodType.class);\n-    }\n-\n-    private static MethodHandle MH_bsm_Mutable() throws ReflectiveOperationException {\n-        shouldNotCallThis();\n-        return MethodHandles.lookup().findStatic(MethodHandles.lookup().lookupClass(), \"bsm_Mutable\", MT_bsm());\n-    }\n-\n-    private static MethodHandle MH_bsm_Volatile() throws ReflectiveOperationException {\n-        shouldNotCallThis();\n-        return MethodHandles.lookup().findStatic(MethodHandles.lookup().lookupClass(), \"bsm_Volatile\", MT_bsm());\n-    }\n-\n-    private static MethodHandle INDY_Mutable() throws Throwable {\n-        shouldNotCallThis();\n-        return ((CallSite) MH_bsm_Mutable().invoke(MethodHandles.lookup(), \"doCall1\", MethodType.methodType(int.class, CallSiteSetTargetSelf.class))).dynamicInvoker();\n-    }\n-\n-    private static MethodHandle INDY_Volatile() throws Throwable {\n-        shouldNotCallThis();\n-        return ((CallSite) MH_bsm_Volatile().invoke(MethodHandles.lookup(), \"doCall1\", MethodType.methodType(int.class, CallSiteSetTargetSelf.class))).dynamicInvoker();\n-    }\n-\n-    public static CallSite bsm_Mutable(MethodHandles.Lookup lookup, String name, MethodType type) {\n-        synchronized (CallSiteSetTarget.class) {\n-            if (cs == null)\n-                cs = new MutableCallSite(doCall1);\n-            return cs;\n-        }\n-    }\n-\n-    public static CallSite bsm_Volatile(MethodHandles.Lookup lookup, String name, MethodType type) {\n-        synchronized (CallSiteSetTarget.class) {\n-            if (cs == null)\n-                cs = new VolatileCallSite(doCall1);\n-            return cs;\n-        }\n-    }\n-\n-    private static void shouldNotCallThis() {\n-        \/\/ if this gets called, the transformation has not taken place\n-        throw new AssertionError(\"this code should be statically transformed away by Indify\");\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/CallSiteSetTargetSelf.java","additions":0,"deletions":155,"binary":false,"changes":155,"status":"deleted"},{"patch":"@@ -1,171 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.java.lang.invoke;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.invoke.ConstantCallSite;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.invoke.MutableCallSite;\n-import java.lang.invoke.VolatileCallSite;\n-import java.util.concurrent.TimeUnit;\n-\n-\/**\n- * This benchmark evaluates INDY performance when call sites are not changed.\n- *\/\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@State(Scope.Thread)\n-@Warmup(iterations = 10, time = 1, timeUnit = TimeUnit.SECONDS)\n-@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n-@Fork(3)\n-public class CallSiteStable {\n-\n-    \/*\n-     * Implementation notes:\n-     *   - Test is calling simple method via INDY\n-     *   - Additional baseline includes \"raw\" test, calling target method directly in virtual and static modes\n-     *\/\n-\n-    private static java.lang.invoke.CallSite cs;\n-\n-    private static MethodHandle doCallMH;\n-\n-    static {\n-        try {\n-            doCallMH = MethodHandles.lookup().findVirtual(CallSiteStable.class, \"doCall\", MethodType.methodType(int.class, int.class));\n-        } catch (NoSuchMethodException | IllegalAccessException e) {\n-            throw new IllegalStateException(e);\n-        }\n-    }\n-\n-    private int i;\n-\n-    public int doCall(int value) {\n-        return value + 1;\n-    }\n-\n-    public static int doCallStatic(int value) {\n-        return value + 1;\n-    }\n-\n-    @Benchmark\n-    public void baselineVirtual() {\n-        i = doCall(i);\n-    }\n-\n-    @Benchmark\n-    public void baselineStatic() {\n-        i = doCallStatic(i);\n-    }\n-\n-    @Benchmark\n-    public void testConstant() throws Throwable {\n-        i = (int) INDY_Constant().invokeExact(this, i);\n-    }\n-\n-    @Benchmark\n-    public void testMutable() throws Throwable {\n-        i = (int) INDY_Mutable().invokeExact(this, i);\n-    }\n-\n-    @Benchmark\n-    public void testVolatile() throws Throwable {\n-        i = (int) INDY_Volatile().invokeExact(this, i);\n-    }\n-\n-    \/* =========================== INDY TRAMPOLINES ============================== *\/\n-\n-    private static MethodType MT_bsm() {\n-        shouldNotCallThis();\n-        return MethodType.methodType(java.lang.invoke.CallSite.class, MethodHandles.Lookup.class, String.class, MethodType.class);\n-    }\n-\n-    private static MethodHandle MH_bsm_Constant() throws ReflectiveOperationException {\n-        shouldNotCallThis();\n-        return MethodHandles.lookup().findStatic(MethodHandles.lookup().lookupClass(), \"bsm_Constant\", MT_bsm());\n-    }\n-\n-    private static MethodHandle MH_bsm_Mutable() throws ReflectiveOperationException {\n-        shouldNotCallThis();\n-        return MethodHandles.lookup().findStatic(MethodHandles.lookup().lookupClass(), \"bsm_Mutable\", MT_bsm());\n-    }\n-\n-    private static MethodHandle MH_bsm_Volatile() throws ReflectiveOperationException {\n-        shouldNotCallThis();\n-        return MethodHandles.lookup().findStatic(MethodHandles.lookup().lookupClass(), \"bsm_Volatile\", MT_bsm());\n-    }\n-\n-    private static MethodHandle INDY_Constant() throws Throwable {\n-        shouldNotCallThis();\n-        return ((java.lang.invoke.CallSite) MH_bsm_Constant().invoke(MethodHandles.lookup(), \"doCall\", MethodType.methodType(int.class, CallSiteStable.class, int.class))).dynamicInvoker();\n-    }\n-    private static MethodHandle INDY_Mutable() throws Throwable {\n-        shouldNotCallThis();\n-        return ((java.lang.invoke.CallSite) MH_bsm_Mutable().invoke(MethodHandles.lookup(), \"doCall\", MethodType.methodType(int.class, CallSiteStable.class, int.class))).dynamicInvoker();\n-    }\n-    private static MethodHandle INDY_Volatile() throws Throwable {\n-        shouldNotCallThis();\n-        return ((java.lang.invoke.CallSite) MH_bsm_Volatile().invoke(MethodHandles.lookup(), \"doCall\", MethodType.methodType(int.class, CallSiteStable.class, int.class))).dynamicInvoker();\n-    }\n-\n-    public static java.lang.invoke.CallSite bsm_Constant(MethodHandles.Lookup lookup, String name, MethodType type) {\n-        synchronized (CallSiteStable.class) {\n-            if (cs == null)\n-                cs = new ConstantCallSite(doCallMH);\n-            return cs;\n-        }\n-    }\n-\n-    public static java.lang.invoke.CallSite bsm_Mutable(MethodHandles.Lookup lookup, String name, MethodType type) {\n-        synchronized (CallSiteStable.class) {\n-            if (cs == null)\n-                cs = new MutableCallSite(doCallMH);\n-            return cs;\n-        }\n-    }\n-\n-    public static java.lang.invoke.CallSite bsm_Volatile(MethodHandles.Lookup lookup, String name, MethodType type) {\n-        synchronized (CallSiteStable.class) {\n-            if (cs == null)\n-                cs = new VolatileCallSite(doCallMH);\n-            return cs;\n-        }\n-    }\n-\n-    private static void shouldNotCallThis() {\n-        \/\/ if this gets called, the transformation has not taken place\n-        throw new AssertionError(\"this code should be statically transformed away by Indify\");\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/CallSiteStable.java","additions":0,"deletions":171,"binary":false,"changes":171,"status":"deleted"}]}