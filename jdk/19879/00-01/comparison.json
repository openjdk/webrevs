{"files":[{"patch":"@@ -24,1 +24,0 @@\n-import java.io.FileDescriptor;\n@@ -27,1 +26,1 @@\n-import java.lang.foreign.MemorySegment;\n+import java.lang.reflect.Field;\n@@ -31,1 +30,0 @@\n-import java.nio.Buffer;\n@@ -52,5 +50,0 @@\n-import jdk.internal.access.JavaNioAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.access.foreign.UnmapperProxy;\n-import jdk.internal.misc.VM;\n-import org.junit.jupiter.api.AfterAll;\n@@ -71,4 +64,4 @@\n- * @modules java.base\/jdk.internal.access\n- *          java.base\/jdk.internal.access.foreign\n- *          java.base\/jdk.internal.misc\n- *\n+ * @comment we use a patched java.net.InetSocketAddress to allow the test to intentionally\n+ *          craft some delays at specific locations in the implementation of InetSocketAddress\n+ *          to trigger race conditions\n+ * @compile\/module=java.base java\/net\/InetSocketAddress.java\n@@ -81,27 +74,0 @@\n-    private static final JavaNioAccess originalJavaNioAccess;\n-\n-    \/*\n-     * Sets up a JavaNioAccess implementation which introduces an artificial\n-     * delay in the implementation of certain method calls. JavaNioAccess itself plays no other role\n-     * other than it being used in the implementation of APIs of several of the SelectableChannel\n-     * classes. We override it in this test to introduce delays in some method calls. It thus\n-     * allows us to introduce a race between the Selector and the SelectableChannel operations,\n-     * effectively increasing the efficacy of this test.\n-     *\n-     * We use a static block, instead of @BeforeAll, to set our custom test specific\n-     * JavaNioAccess very early and thus reduce the chances of JavaNioAccess already\n-     * being looked up and cached by SelectableChannel implementations.\n-     *\/\n-    static {\n-        originalJavaNioAccess = SharedSecrets.getJavaNioAccess();\n-        SharedSecrets.setJavaNioAccess(new DelayInjectingNIOAccess());\n-    }\n-\n-    @AfterAll\n-    public static void afterAll() {\n-        \/\/ reset back to the original\n-        if (originalJavaNioAccess != null) {\n-            SharedSecrets.setJavaNioAccess(originalJavaNioAccess);\n-        }\n-    }\n-\n@@ -120,3 +86,12 @@\n-                                while (true) {\n-                                    bb.clear();\n-                                    dc.send(bb, target);\n+                                \/\/ configure our patched java.net.InetSocketAddress implementation\n+                                \/\/ to introduce delay in certain methods which get invoked\n+                                \/\/ internally from the DC.send() implementation\n+                                introduceDelayInInetSocketAddressMethod();\n+                                try {\n+                                    while (true) {\n+                                        bb.clear();\n+                                        dc.send(bb, target);\n+                                    }\n+                                } finally {\n+                                    \/\/ delays in patched InetSocketAddress are no longer needed\n+                                    undoDelayInInetSocketAddressMethod();\n@@ -125,2 +100,2 @@\n-                            } catch (IOException ioe) {\n-                                throw new UncheckedIOException(ioe);\n+                            } catch (Exception e) {\n+                                throw new RuntimeException(e);\n@@ -135,0 +110,1 @@\n+                            ByteBuffer sendBB = ByteBuffer.allocate(100);\n@@ -136,0 +112,1 @@\n+                                SocketAddress target = dc.getLocalAddress();\n@@ -137,3 +114,17 @@\n-                                while (true) {\n-                                    rcvBB.clear();\n-                                    dc.receive(rcvBB);\n+                                \/\/ configure our patched java.net.InetSocketAddress implementation\n+                                \/\/ to introduce delay in certain methods which get invoked\n+                                \/\/ internally from the DC.receive() implementation\n+                                introduceDelayInInetSocketAddressMethod();\n+                                try {\n+                                    while (true) {\n+                                        \/\/ first send() a few datagrams so that subsequent\n+                                        \/\/ receive() does receive them and thus triggers\n+                                        \/\/ the potential race with the deferred close\n+                                        sendBB.clear();\n+                                        dc.send(sendBB, target);\n+                                        rcvBB.clear();\n+                                        dc.receive(rcvBB);\n+                                    }\n+                                } finally {\n+                                    \/\/ delays in patched InetSocketAddress are no longer needed\n+                                    undoDelayInInetSocketAddressMethod();\n@@ -142,2 +133,2 @@\n-                            } catch (IOException ioe) {\n-                                throw new UncheckedIOException(ioe);\n+                            } catch (Exception e) {\n+                                throw new RuntimeException(e);\n@@ -464,0 +455,9 @@\n+    \/**\n+     * Configures our patched java.net.InetSocketAddress to introduce delays in\n+     * certain places within the implementation of that class\n+     *\/\n+    private static void introduceDelayInInetSocketAddressMethod() throws Exception {\n+        Field f = InetSocketAddress.class.getField(\"INTRODUCE_DELAY\");\n+        ThreadLocal<Boolean> introduceDelay = (ThreadLocal<Boolean>) f.get(null);\n+        introduceDelay.set(true);\n+    }\n@@ -465,107 +465,7 @@\n-    private static final class DelayInjectingNIOAccess implements JavaNioAccess {\n-        private final JavaNioAccess realJavaNioAccess = SharedSecrets.getJavaNioAccess();\n-\n-        @Override\n-        public VM.BufferPool getDirectBufferPool() {\n-            return realJavaNioAccess.getDirectBufferPool();\n-        }\n-\n-        @Override\n-        public ByteBuffer newDirectByteBuffer(long addr, int cap, Object obj,\n-                                              MemorySegment segment) {\n-            return realJavaNioAccess.newDirectByteBuffer(addr, cap, obj, segment);\n-        }\n-\n-        @Override\n-        public ByteBuffer newMappedByteBuffer(UnmapperProxy unmapperProxy, long addr,\n-                                              int cap, Object obj, MemorySegment segment) {\n-            return realJavaNioAccess.newMappedByteBuffer(unmapperProxy, addr, cap, obj, segment);\n-        }\n-\n-        @Override\n-        public ByteBuffer newHeapByteBuffer(byte[] hb, int offset, int capacity,\n-                                            MemorySegment segment) {\n-            return realJavaNioAccess.newHeapByteBuffer(hb, offset, capacity, segment);\n-        }\n-\n-        @Override\n-        public Object getBufferBase(Buffer bb) {\n-            return realJavaNioAccess.getBufferBase(bb);\n-        }\n-\n-        @Override\n-        public long getBufferAddress(Buffer buffer) {\n-            return realJavaNioAccess.getBufferAddress(buffer);\n-        }\n-\n-        @Override\n-        public UnmapperProxy unmapper(Buffer buffer) {\n-            return realJavaNioAccess.unmapper(buffer);\n-        }\n-\n-        @Override\n-        public MemorySegment bufferSegment(Buffer buffer) {\n-            return realJavaNioAccess.bufferSegment(buffer);\n-        }\n-\n-        @Override\n-        public void acquireSession(Buffer buffer) {\n-            \/\/ intentionally introduce an artificial delay\n-            try {\n-                Thread.sleep(100);\n-            } catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n-            }\n-            realJavaNioAccess.acquireSession(buffer);\n-        }\n-\n-        @Override\n-        public void releaseSession(Buffer buffer) {\n-            realJavaNioAccess.releaseSession(buffer);\n-        }\n-\n-        @Override\n-        public boolean isThreadConfined(Buffer buffer) {\n-            return realJavaNioAccess.isThreadConfined(buffer);\n-        }\n-\n-        @Override\n-        public boolean hasSession(Buffer buffer) {\n-            return realJavaNioAccess.hasSession(buffer);\n-        }\n-\n-        @Override\n-        public void force(FileDescriptor fd, long address, boolean isSync,\n-                          long offset, long size) {\n-            realJavaNioAccess.force(fd, address, isSync, offset, size);\n-        }\n-\n-        @Override\n-        public void load(long address, boolean isSync, long size) {\n-            realJavaNioAccess.load(address, isSync, size);\n-        }\n-\n-        @Override\n-        public void unload(long address, boolean isSync, long size) {\n-            realJavaNioAccess.unload(address, isSync, size);\n-        }\n-\n-        @Override\n-        public boolean isLoaded(long address, boolean isSync, long size) {\n-            return realJavaNioAccess.isLoaded(address, isSync, size);\n-        }\n-\n-        @Override\n-        public void reserveMemory(long size, long cap) {\n-            realJavaNioAccess.reserveMemory(size, cap);\n-        }\n-\n-        @Override\n-        public void unreserveMemory(long size, long cap) {\n-            realJavaNioAccess.unreserveMemory(size, cap);\n-        }\n-\n-        @Override\n-        public int pageSize() {\n-            return realJavaNioAccess.pageSize();\n-        }\n+    \/**\n+     * Reverts the delays introduced in our patched java.net.InetSocketAddress class\n+     *\/\n+    private static void undoDelayInInetSocketAddressMethod() throws Exception {\n+        Field f = InetSocketAddress.class.getField(\"INTRODUCE_DELAY\");\n+        ThreadLocal<Boolean> introduceDelay = (ThreadLocal<Boolean>) f.get(null);\n+        introduceDelay.remove();\n","filename":"test\/jdk\/java\/nio\/channels\/Selector\/DeferredCloseTest.java","additions":56,"deletions":156,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.net;\n+\n+\n+import java.util.Locale;\n+\n+\/\/ Patched implementation only meant to be used in certain tests\n+public class InetSocketAddress extends SocketAddress {\n+\n+    @java.io.Serial\n+    private static final long serialVersionUID = 5076001401234631237L;\n+\n+    public static final ThreadLocal<Boolean> INTRODUCE_DELAY = new ThreadLocal<>() {\n+        @Override\n+        protected Boolean initialValue() {\n+            return false;\n+        }\n+    };\n+\n+    static {\n+        System.out.println(\"patched InetSocketAddress class in use\");\n+    }\n+\n+    private final String hostname;\n+    private final InetAddress addr;\n+    private final int port;\n+\n+    public InetSocketAddress(int port) {\n+        this(InetAddress.anyLocalAddress(), port);\n+    }\n+\n+    public InetSocketAddress(InetAddress addr, int port) {\n+        this(null,\n+                addr == null ? InetAddress.anyLocalAddress() : addr,\n+                checkPort(port));\n+    }\n+\n+    public InetSocketAddress(String hostname, int port) {\n+        checkHost(hostname);\n+        InetAddress addr = null;\n+        String host = null;\n+        try {\n+            addr = InetAddress.getByName(hostname);\n+        } catch (UnknownHostException e) {\n+            host = hostname;\n+        }\n+        this.hostname = host;\n+        this.addr = addr;\n+        this.port = checkPort(port);\n+        if (INTRODUCE_DELAY.get()) {\n+            doDelay();\n+        }\n+    }\n+\n+    public static InetSocketAddress createUnresolved(String host, int port) {\n+        return new InetSocketAddress(checkHost(host), null, checkPort(port));\n+    }\n+\n+    private InetSocketAddress(String hostname, InetAddress addr, int port) {\n+        this.hostname = hostname;\n+        this.addr = addr;\n+        this.port = port;\n+        if (INTRODUCE_DELAY.get()) {\n+            doDelay();\n+        }\n+    }\n+\n+    \/**\n+     * Gets the port number.\n+     *\n+     * @return the port number.\n+     *\/\n+    public final int getPort() {\n+        if (!INTRODUCE_DELAY.get()) {\n+            return port;\n+        }\n+        doDelay();\n+        return this.port;\n+    }\n+\n+    \/**\n+     * Gets the {@code InetAddress}.\n+     *\n+     * @return the InetAddress or {@code null} if it is unresolved.\n+     *\/\n+    public final InetAddress getAddress() {\n+        return this.addr;\n+    }\n+\n+    public final String getHostName() {\n+        if (hostname != null) {\n+            return hostname;\n+        }\n+        if (addr != null) {\n+            return addr.getHostName();\n+        }\n+        return null;\n+    }\n+\n+    public final String getHostString() {\n+        if (hostname != null) {\n+            return hostname;\n+        }\n+        if (addr != null) {\n+            if (addr.holder().getHostName() != null) {\n+                return addr.holder().getHostName();\n+            } else {\n+                return addr.getHostAddress();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public final boolean isUnresolved() {\n+        return addr == null;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String formatted;\n+        if (isUnresolved()) {\n+            formatted = hostname + \"\/<unresolved>\";\n+        } else {\n+            formatted = addr.toString();\n+            if (addr instanceof Inet6Address) {\n+                int i = formatted.lastIndexOf(\"\/\");\n+                formatted = formatted.substring(0, i + 1)\n+                        + \"[\" + formatted.substring(i + 1) + \"]\";\n+            }\n+        }\n+        return formatted + \":\" + port;\n+    }\n+\n+    @Override\n+    public final boolean equals(Object other) {\n+        if (!(other instanceof InetSocketAddress that)) {\n+            return false;\n+        }\n+        boolean sameIP;\n+        if (addr != null) {\n+            sameIP = addr.equals(that.addr);\n+        } else if (hostname != null) {\n+            sameIP = (that.addr == null) &&\n+                    hostname.equalsIgnoreCase(that.hostname);\n+        } else {\n+            sameIP = (that.addr == null) && (that.hostname == null);\n+        }\n+        return sameIP && (port == that.port);\n+    }\n+\n+    @Override\n+    public final int hashCode() {\n+        if (addr != null) {\n+            return addr.hashCode() + port;\n+        }\n+        if (hostname != null) {\n+            return hostname.toLowerCase(Locale.ROOT).hashCode() + port;\n+        }\n+        return port;\n+    }\n+\n+    private static int checkPort(int port) {\n+        if (port < 0 || port > 0xFFFF)\n+            throw new IllegalArgumentException(\"port out of range:\" + port);\n+        return port;\n+    }\n+\n+    private static String checkHost(String hostname) {\n+        if (hostname == null)\n+            throw new IllegalArgumentException(\"hostname can't be null\");\n+        return hostname;\n+    }\n+\n+    private static void doDelay() {\n+        System.out.println(\"intentional delay injected in InetSocketAddress\");\n+        try {\n+            Thread.sleep(100);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Selector\/java.base\/java\/net\/InetSocketAddress.java","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"}]}