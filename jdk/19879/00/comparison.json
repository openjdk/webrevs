{"files":[{"patch":"@@ -1948,0 +1948,5 @@\n+        \/\/ wait for any read\/write operations to complete before trying to close\n+        readLock.lock();\n+        readLock.unlock();\n+        writeLock.lock();\n+        writeLock.unlock();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -657,0 +657,3 @@\n+        \/\/ wait for any accept operation to complete before trying to close\n+        acceptLock.lock();\n+        acceptLock.unlock();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketChannelImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1219,0 +1219,5 @@\n+        \/\/ wait for any read\/write operations to complete before trying to close\n+        readLock.lock();\n+        readLock.unlock();\n+        writeLock.lock();\n+        writeLock.unlock();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -204,0 +204,3 @@\n+        \/\/ wait for any write operation to complete before trying to close\n+        writeLock.lock();\n+        writeLock.unlock();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/SinkChannelImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -203,0 +203,3 @@\n+        \/\/ wait for any read operation to complete before trying to close\n+        readLock.lock();\n+        readLock.unlock();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/SourceChannelImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,573 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.lang.foreign.MemorySegment;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.nio.Buffer;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.ClosedSelectorException;\n+import java.nio.channels.DatagramChannel;\n+import java.nio.channels.Pipe;\n+import java.nio.channels.SelectableChannel;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.time.Instant;\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.access.foreign.UnmapperProxy;\n+import jdk.internal.misc.VM;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8334719\n+ * @summary verifies that if a registered channel has in-progress operations, then\n+ *          the Selector during its deferred close implementation won't prematurely release\n+ *          the channel's resources\n+ *\n+ * @modules java.base\/jdk.internal.access\n+ *          java.base\/jdk.internal.access.foreign\n+ *          java.base\/jdk.internal.misc\n+ *\n+ * @run junit\/othervm\/timeout=240 DeferredCloseTest\n+ *\/\n+public class DeferredCloseTest {\n+\n+    private static final int NUM_ITERATIONS = 50;\n+\n+    private static final JavaNioAccess originalJavaNioAccess;\n+\n+    \/*\n+     * Sets up a JavaNioAccess implementation which introduces an artificial\n+     * delay in the implementation of certain method calls. JavaNioAccess itself plays no other role\n+     * other than it being used in the implementation of APIs of several of the SelectableChannel\n+     * classes. We override it in this test to introduce delays in some method calls. It thus\n+     * allows us to introduce a race between the Selector and the SelectableChannel operations,\n+     * effectively increasing the efficacy of this test.\n+     *\n+     * We use a static block, instead of @BeforeAll, to set our custom test specific\n+     * JavaNioAccess very early and thus reduce the chances of JavaNioAccess already\n+     * being looked up and cached by SelectableChannel implementations.\n+     *\/\n+    static {\n+        originalJavaNioAccess = SharedSecrets.getJavaNioAccess();\n+        SharedSecrets.setJavaNioAccess(new DelayInjectingNIOAccess());\n+    }\n+\n+    @AfterAll\n+    public static void afterAll() {\n+        \/\/ reset back to the original\n+        if (originalJavaNioAccess != null) {\n+            SharedSecrets.setJavaNioAccess(originalJavaNioAccess);\n+        }\n+    }\n+\n+    private static Stream<Arguments> dcOperations() {\n+        return Stream.of(\n+                Arguments.of(\n+                        \/\/ repeatedly do DC.send() till there's a ClosedChannelException\n+                        \"DC.send()\", (Function<DatagramChannel, Void>) (dc) -> {\n+                            ByteBuffer bb = ByteBuffer.allocate(100);\n+                            try {\n+                                \/\/ We send to ourselves. Target, content and\n+                                \/\/ receipt of the Datagram isn't of importance\n+                                \/\/ in this test.\n+                                SocketAddress target = dc.getLocalAddress();\n+                                System.out.println(\"DC: \" + dc + \" sending to \" + target);\n+                                while (true) {\n+                                    bb.clear();\n+                                    dc.send(bb, target);\n+                                }\n+                            } catch (ClosedChannelException _) {\n+                            } catch (IOException ioe) {\n+                                throw new UncheckedIOException(ioe);\n+                            }\n+                            return null;\n+                        }\n+                ),\n+                Arguments.of(\n+                        \/\/ repeatedly do DC.receive() till there's a ClosedChannelException\n+                        \"DC.receive()\", (Function<DatagramChannel, Void>) (dc) -> {\n+                            ByteBuffer rcvBB = ByteBuffer.allocate(100);\n+                            try {\n+                                System.out.println(\"DC: \" + dc + \" receiving datagrams\");\n+                                while (true) {\n+                                    rcvBB.clear();\n+                                    dc.receive(rcvBB);\n+                                }\n+                            } catch (ClosedChannelException _) {\n+                            } catch (IOException ioe) {\n+                                throw new UncheckedIOException(ioe);\n+                            }\n+                            return null;\n+                        }\n+                )\n+        );\n+    }\n+\n+    \/**\n+     * Runs the test for DatagramChannel.\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable)\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"dcOperations\")\n+    public void testDatagramChannel(String opName, Function<DatagramChannel, Void> dcOperation)\n+            throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s DatagramChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                try (Selector sel = Selector.open();\n+                     DatagramChannel dc = DatagramChannel.open()) {\n+                    \/\/ create a non-blocking bound DatagramChannel\n+                    dc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+                    dc.configureBlocking(false);\n+                    \/\/ register the DatagramChannel with a selector\n+                    \/\/ (doesn't matter the interestOps)\n+                    final var key = dc.register(sel, SelectionKey.OP_READ);\n+                    runTest(executor, key, () -> dcOperation.apply(dc));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    private static Stream<Arguments> scOperations() {\n+        return Stream.of(\n+                Arguments.of(\n+                        \/\/ repeatedly do SC.write() till there's a ClosedChannelException\n+                        \"SC.write()\", (Function<SocketChannel, Void>) (sc) -> {\n+                            ByteBuffer bb = ByteBuffer.allocate(100);\n+                            try {\n+                                System.out.println(\"SC: \" + sc + \" writing\");\n+                                while (true) {\n+                                    bb.clear();\n+                                    sc.write(bb);\n+                                }\n+                            } catch (ClosedChannelException _) {\n+                            } catch (IOException ioe) {\n+                                throw new UncheckedIOException(ioe);\n+                            }\n+                            return null;\n+                        }\n+                ),\n+                Arguments.of(\n+                        \/\/ repeatedly do SC.read() till there's a ClosedChannelException\n+                        \"SC.read()\", (Function<SocketChannel, Void>) (sc) -> {\n+                            ByteBuffer bb = ByteBuffer.allocate(100);\n+                            try {\n+                                System.out.println(\"SC: \" + sc + \" reading\");\n+                                while (true) {\n+                                    bb.clear();\n+                                    sc.read(bb);\n+                                }\n+                            } catch (ClosedChannelException _) {\n+                            } catch (IOException ioe) {\n+                                throw new UncheckedIOException(ioe);\n+                            }\n+                            return null;\n+                        }\n+                )\n+        );\n+    }\n+\n+    \/**\n+     * Runs the test for SocketChannel\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable)\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"scOperations\")\n+    public void testSocketChannel(String opName, Function<SocketChannel, Void> scOperation)\n+            throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(3)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s SocketChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                try (Selector sel = Selector.open();\n+                     SocketChannel sc = SocketChannel.open()) {\n+                    \/\/ create and bind a SocketChannel\n+                    sc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+                    \/\/ stay in blocking mode till the SocketChannel is connected\n+                    sc.configureBlocking(true);\n+                    Future<SocketChannel> acceptedChannel;\n+                    SocketChannel conn;\n+                    \/\/ create a remote server and connect to it\n+                    try (ServerSocketChannel server = ServerSocketChannel.open()) {\n+                        server.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+                        SocketAddress remoteAddr = server.getLocalAddress();\n+                        acceptedChannel = executor.submit(new ConnAcceptor(server));\n+                        System.out.println(\"connecting to \" + remoteAddr);\n+                        sc.connect(remoteAddr);\n+                        conn = acceptedChannel.get();\n+                    }\n+                    try (conn) {\n+                        \/\/ switch to non-blocking\n+                        sc.configureBlocking(false);\n+                        System.out.println(\"switched to non-blocking: \" + sc);\n+                        \/\/ register the SocketChannel with a selector\n+                        \/\/ (doesn't matter the interestOps)\n+                        final var key = sc.register(sel, SelectionKey.OP_READ);\n+                        runTest(executor, key, () -> scOperation.apply(sc));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Runs the test for ServerSocketChannel\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable)\n+     *\/\n+    @Test\n+    public void testServerSocketChannel() throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s ServerSocketChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                try (Selector sel = Selector.open();\n+                     ServerSocketChannel ssc = ServerSocketChannel.open()) {\n+                    \/\/ create and bind a ServerSocketChannel\n+                    ssc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+                    ssc.configureBlocking(false);\n+                    \/\/ register the ServerSocketChannel with a selector\n+                    final var key = ssc.register(sel, SelectionKey.OP_ACCEPT);\n+                    runTest(executor, key, () -> {\n+                        \/\/ repeatedly do SSC.accept() till there's a ClosedChannelException\n+                        try {\n+                            while (true) {\n+                                ssc.accept();\n+                            }\n+                        } catch (ClosedChannelException _) {\n+                        }\n+                        return null;\n+                    });\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Runs the test for SinkChannel\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable)\n+     *\/\n+    @Test\n+    public void testSinkChannel() throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s SinkChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                Pipe pipe = Pipe.open();\n+                try (Selector sel = Selector.open();\n+                     Pipe.SinkChannel sink = pipe.sink()) {\n+                    sink.configureBlocking(false);\n+                    final var key = sink.register(sel, SelectionKey.OP_WRITE);\n+                    runTest(executor, key, () -> {\n+                        \/\/ repeatedly do SC.write() till there's a ClosedChannelException\n+                        ByteBuffer bb = ByteBuffer.allocate(100);\n+                        try {\n+                            while (true) {\n+                                bb.clear();\n+                                sink.write(bb);\n+                            }\n+                        } catch (ClosedChannelException _) {\n+                        }\n+                        return null;\n+                    });\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Runs the test for SourceChannel\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable)\n+     *\/\n+    @Test\n+    public void testSourceChannel() throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s SourceChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                Pipe pipe = Pipe.open();\n+                try (Selector sel = Selector.open();\n+                     Pipe.SourceChannel source = pipe.source()) {\n+                    source.configureBlocking(false);\n+                    final var key = source.register(sel, SelectionKey.OP_READ);\n+                    runTest(executor, key, () -> {\n+                        \/\/ repeatedly do SC.read() till there's a ClosedChannelException\n+                        ByteBuffer bb = ByteBuffer.allocate(100);\n+                        try {\n+                            while (true) {\n+                                bb.clear();\n+                                source.read(bb);\n+                            }\n+                        } catch (ClosedChannelException _) {\n+                        }\n+                        return null;\n+                    });\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * SelectableChannel implementations internally have a deferred close implementation. When a\n+     * channel is registered with a Selector and close() is invoked on the channel from a certain\n+     * thread, then the implementation of close() defers the actual close if the channel has\n+     * in-progress operations (for example, read\/write\/send\/receive and such) in some other thread.\n+     * A subsequent operation through the Selector (like Selector.select()) then completes the\n+     * deferred close (waiting for any in-progress operations to complete). This test method\n+     * verifies that the deferred close implementation doesn't prematurely close and release\n+     * the resources used by the channel, while there are in-progress operations.\n+     * <p>\n+     * Launches 2 threads, T1 and T2. When T1 and T2 are in progress, this method closes the\n+     * channel that is registered with the Selector.\n+     * T1 is running the channelOperation (which keeps running operations on the channel).\n+     * T2 is running a task which keeps invoking Selector.select(), until the channel is closed.\n+     * When T2 notices that the channel is closed, it cancels the selectionKey and then\n+     * invokes one last Selector.select() operation to finish the deferred close of the channel.\n+     *\/\n+    private static void runTest(ExecutorService executor, SelectionKey selectionKey,\n+                                Callable<Void> channelOperation) throws Exception {\n+\n+        SelectableChannel channel = selectionKey.channel();\n+        assertFalse(channel.isBlocking(), \"channel isn't non-blocking: \" + channel);\n+        selectionKey.selector().selectNow();\n+        CountDownLatch tasksStartedLatch = new CountDownLatch(2);\n+        \/\/ run the channel operations\n+        Future<?> channelOpResult = executor.submit(() -> {\n+            \/\/ notify that the task has started\n+            tasksStartedLatch.countDown();\n+            return channelOperation.call();\n+        });\n+        \/\/ run the Selector.select() task\n+        Future<?> selectorTaskResult = executor.submit(\n+                new SelectorTask(selectionKey, tasksStartedLatch));\n+        \/\/ await for the 2 tasks to start\n+        tasksStartedLatch.await();\n+        \/\/ just a few more milliseconds before we initiate the channel close\n+        Thread.sleep(100);\n+        \/\/ close the channel while it's still registered with the Selector,\n+        \/\/ so that the close is deferred by the channel implementations.\n+        System.out.println(\"closing channel: \" + channel);\n+        assertTrue(channel.isRegistered(), \"channel isn't registered: \" + channel);\n+        channel.close();\n+        \/\/ wait for the operation on the channel and the selector task to complete\n+        channelOpResult.get();\n+        selectorTaskResult.get();\n+    }\n+\n+    \/*\n+     * Keeps invoking Selector.select() until the channel is closed, after which\n+     * it cancels the SelectionKey and does one last Selector.select() to finish\n+     * the deferred close.\n+     *\/\n+    private static final class SelectorTask implements Callable<Void> {\n+        private final SelectionKey selectionKey;\n+        private final CountDownLatch startedLatch;\n+\n+        private SelectorTask(SelectionKey selectionKey, CountDownLatch startedLatch) {\n+            this.selectionKey = Objects.requireNonNull(selectionKey);\n+            this.startedLatch = startedLatch;\n+        }\n+\n+        @Override\n+        public Void call() throws Exception {\n+            try {\n+                \/\/ notify that the task has started\n+                startedLatch.countDown();\n+                Selector selector = selectionKey.selector();\n+                SelectableChannel channel = selectionKey.channel();\n+                while (true) {\n+                    selector.select(10);\n+                    if (!channel.isOpen()) {\n+                        \/\/ the channel is (defer) closed, cancel the registration and then\n+                        \/\/ issue a select() so that the Selector finishes the deferred\n+                        \/\/ close of the channel.\n+                        System.out.println(\"channel: \" + channel + \" isn't open,\" +\n+                                \" now cancelling key: \" + selectionKey);\n+                        selectionKey.cancel();\n+                        System.out.println(\"initiating select after key cancelled: \" + selectionKey);\n+                        selector.select(5);\n+                        break;\n+                    }\n+                }\n+            } catch (ClosedSelectorException _) {\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private static final class ConnAcceptor implements Callable<SocketChannel> {\n+        private final ServerSocketChannel serverSocketChannel;\n+\n+        private ConnAcceptor(ServerSocketChannel serverSocketChannel) {\n+            this.serverSocketChannel = serverSocketChannel;\n+        }\n+\n+        @Override\n+        public SocketChannel call() throws Exception {\n+            SocketChannel accepted = serverSocketChannel.accept();\n+            System.out.println(\"Accepted connection: \" + accepted);\n+            return accepted;\n+        }\n+    }\n+\n+\n+    private static final class DelayInjectingNIOAccess implements JavaNioAccess {\n+        private final JavaNioAccess realJavaNioAccess = SharedSecrets.getJavaNioAccess();\n+\n+        @Override\n+        public VM.BufferPool getDirectBufferPool() {\n+            return realJavaNioAccess.getDirectBufferPool();\n+        }\n+\n+        @Override\n+        public ByteBuffer newDirectByteBuffer(long addr, int cap, Object obj,\n+                                              MemorySegment segment) {\n+            return realJavaNioAccess.newDirectByteBuffer(addr, cap, obj, segment);\n+        }\n+\n+        @Override\n+        public ByteBuffer newMappedByteBuffer(UnmapperProxy unmapperProxy, long addr,\n+                                              int cap, Object obj, MemorySegment segment) {\n+            return realJavaNioAccess.newMappedByteBuffer(unmapperProxy, addr, cap, obj, segment);\n+        }\n+\n+        @Override\n+        public ByteBuffer newHeapByteBuffer(byte[] hb, int offset, int capacity,\n+                                            MemorySegment segment) {\n+            return realJavaNioAccess.newHeapByteBuffer(hb, offset, capacity, segment);\n+        }\n+\n+        @Override\n+        public Object getBufferBase(Buffer bb) {\n+            return realJavaNioAccess.getBufferBase(bb);\n+        }\n+\n+        @Override\n+        public long getBufferAddress(Buffer buffer) {\n+            return realJavaNioAccess.getBufferAddress(buffer);\n+        }\n+\n+        @Override\n+        public UnmapperProxy unmapper(Buffer buffer) {\n+            return realJavaNioAccess.unmapper(buffer);\n+        }\n+\n+        @Override\n+        public MemorySegment bufferSegment(Buffer buffer) {\n+            return realJavaNioAccess.bufferSegment(buffer);\n+        }\n+\n+        @Override\n+        public void acquireSession(Buffer buffer) {\n+            \/\/ intentionally introduce an artificial delay\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+            }\n+            realJavaNioAccess.acquireSession(buffer);\n+        }\n+\n+        @Override\n+        public void releaseSession(Buffer buffer) {\n+            realJavaNioAccess.releaseSession(buffer);\n+        }\n+\n+        @Override\n+        public boolean isThreadConfined(Buffer buffer) {\n+            return realJavaNioAccess.isThreadConfined(buffer);\n+        }\n+\n+        @Override\n+        public boolean hasSession(Buffer buffer) {\n+            return realJavaNioAccess.hasSession(buffer);\n+        }\n+\n+        @Override\n+        public void force(FileDescriptor fd, long address, boolean isSync,\n+                          long offset, long size) {\n+            realJavaNioAccess.force(fd, address, isSync, offset, size);\n+        }\n+\n+        @Override\n+        public void load(long address, boolean isSync, long size) {\n+            realJavaNioAccess.load(address, isSync, size);\n+        }\n+\n+        @Override\n+        public void unload(long address, boolean isSync, long size) {\n+            realJavaNioAccess.unload(address, isSync, size);\n+        }\n+\n+        @Override\n+        public boolean isLoaded(long address, boolean isSync, long size) {\n+            return realJavaNioAccess.isLoaded(address, isSync, size);\n+        }\n+\n+        @Override\n+        public void reserveMemory(long size, long cap) {\n+            realJavaNioAccess.reserveMemory(size, cap);\n+        }\n+\n+        @Override\n+        public void unreserveMemory(long size, long cap) {\n+            realJavaNioAccess.unreserveMemory(size, cap);\n+        }\n+\n+        @Override\n+        public int pageSize() {\n+            return realJavaNioAccess.pageSize();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Selector\/DeferredCloseTest.java","additions":573,"deletions":0,"binary":false,"changes":573,"status":"added"}]}