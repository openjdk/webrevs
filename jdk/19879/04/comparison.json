{"files":[{"patch":"@@ -1948,0 +1948,5 @@\n+        \/\/ wait for any read\/write operations to complete before trying to close\n+        readLock.lock();\n+        readLock.unlock();\n+        writeLock.lock();\n+        writeLock.unlock();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -657,0 +657,3 @@\n+        \/\/ wait for any accept operation to complete before trying to close\n+        acceptLock.lock();\n+        acceptLock.unlock();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketChannelImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1219,0 +1219,5 @@\n+        \/\/ wait for any read\/write operations to complete before trying to close\n+        readLock.lock();\n+        readLock.unlock();\n+        writeLock.lock();\n+        writeLock.unlock();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -204,0 +204,3 @@\n+        \/\/ wait for any write operation to complete before trying to close\n+        writeLock.lock();\n+        writeLock.unlock();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/SinkChannelImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -203,0 +203,3 @@\n+        \/\/ wait for any read operation to complete before trying to close\n+        readLock.lock();\n+        readLock.unlock();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/SourceChannelImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,484 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.ClosedSelectorException;\n+import java.nio.channels.DatagramChannel;\n+import java.nio.channels.Pipe;\n+import java.nio.channels.SelectableChannel;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.time.Instant;\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8334719\n+ * @summary verifies that if a registered channel has in-progress operations, then\n+ *          the Selector during its deferred close implementation won't prematurely release\n+ *          the channel's resources\n+ *\n+ * @comment we use a patched java.net.InetSocketAddress to allow the test to intentionally\n+ *          craft some delays at specific locations in the implementation of InetSocketAddress\n+ *          to trigger race conditions\n+ * @compile\/module=java.base java\/net\/InetSocketAddress.java\n+ * @run junit\/othervm DeferredCloseTest\n+ *\/\n+public class DeferredCloseTest {\n+\n+    private static final int NUM_ITERATIONS = 10;\n+    private static final InetSocketAddress BIND_ADDR = new InetSocketAddress(\n+            InetAddress.getLoopbackAddress(), 0);\n+\n+    @BeforeAll\n+    public static void beforeAll() throws Exception {\n+        \/\/ configure our patched java.net.InetSocketAddress implementation\n+        \/\/ to introduce delay in certain methods which get invoked\n+        \/\/ internally from the DC.send() implementation\n+        InetSocketAddress.enableDelay();\n+    }\n+\n+    @AfterAll\n+    public static void afterAll() throws Exception {\n+        \/\/ delays in patched InetSocketAddress are no longer needed\n+        InetSocketAddress.disableDelay();\n+    }\n+\n+    private static Stream<Arguments> dcOperations() {\n+        return Stream.of(\n+                Arguments.of(\n+                        \/\/ repeatedly do DC.send() till there's a ClosedChannelException\n+                        \"DC.send()\",\n+                        null,\n+                        (Function<DatagramChannel, Void>) (dc) -> {\n+                            ByteBuffer bb = ByteBuffer.allocate(100);\n+                            try {\n+                                \/\/ We send to ourselves. Target, content and\n+                                \/\/ receipt of the Datagram isn't of importance\n+                                \/\/ in this test.\n+                                SocketAddress target = dc.getLocalAddress();\n+                                System.out.println(\"DC: \" + dc + \" sending to \" + target);\n+                                while (true) {\n+                                    bb.clear();\n+                                    dc.send(bb, target);\n+                                }\n+                            } catch (ClosedChannelException _) {\n+                            } catch (Exception e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                            return null;\n+                        }\n+                ),\n+                Arguments.of(\n+                        \/\/ repeatedly do DC.receive() till there's a ClosedChannelException\n+                        \"DC.receive()\",\n+                        (Function<DatagramChannel, Void>) (dc) -> {\n+                            try {\n+                                SocketAddress target = dc.getLocalAddress();\n+                                ByteBuffer sendBB = ByteBuffer.allocate(100);\n+                                \/\/ first send() a few datagrams so that subsequent\n+                                \/\/ receive() does receive them and thus triggers\n+                                \/\/ the potential race with the deferred close\n+                                for (int i = 0; i < 5; i++) {\n+                                    sendBB.clear();\n+                                    dc.send(sendBB, target);\n+                                }\n+                            } catch (Exception e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                            return null;\n+                        },\n+                        (Function<DatagramChannel, Void>) (dc) -> {\n+                            try {\n+                                ByteBuffer rcvBB = ByteBuffer.allocate(10);\n+                                while (true) {\n+                                    rcvBB.clear();\n+                                    dc.receive(rcvBB);\n+                                }\n+                            } catch (ClosedChannelException _) {\n+                            } catch (Exception e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                            return null;\n+                        }\n+                )\n+        );\n+    }\n+\n+    \/**\n+     * Runs the test for DatagramChannel.\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable, CountDownLatch)\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"dcOperations\")\n+    public void testDatagramChannel(String opName, Function<DatagramChannel, Void> preOp,\n+                                    Function<DatagramChannel, Void> dcOperation)\n+            throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s DatagramChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                try (Selector sel = Selector.open();\n+                     DatagramChannel dc = DatagramChannel.open()) {\n+                    \/\/ create a non-blocking bound DatagramChannel\n+                    dc.bind(BIND_ADDR);\n+                    dc.configureBlocking(false);\n+                    \/\/ register the DatagramChannel with a selector\n+                    \/\/ (doesn't matter the interestOps)\n+                    SelectionKey key = dc.register(sel, SelectionKey.OP_READ);\n+                    if (preOp != null) {\n+                        preOp.apply(dc);\n+                    }\n+                    CountDownLatch opStartLatch = new CountDownLatch(1);\n+                    runTest(executor, key, () -> {\n+                        \/\/ notify that we will now start operation on the DC\n+                        opStartLatch.countDown();\n+                        return dcOperation.apply(dc);\n+                    }, opStartLatch);\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    private static Stream<Arguments> scOperations() {\n+        return Stream.of(\n+                Arguments.of(\n+                        \/\/ repeatedly do SC.write() till there's a ClosedChannelException\n+                        \"SC.write()\", (Function<SocketChannel, Void>) (sc) -> {\n+                            ByteBuffer bb = ByteBuffer.allocate(100);\n+                            try {\n+                                System.out.println(\"SC: \" + sc + \" writing\");\n+                                while (true) {\n+                                    bb.clear();\n+                                    sc.write(bb);\n+                                }\n+                            } catch (ClosedChannelException _) {\n+                            } catch (IOException ioe) {\n+                                throw new UncheckedIOException(ioe);\n+                            }\n+                            return null;\n+                        }\n+                ),\n+                Arguments.of(\n+                        \/\/ repeatedly do SC.read() till there's a ClosedChannelException\n+                        \"SC.read()\", (Function<SocketChannel, Void>) (sc) -> {\n+                            ByteBuffer bb = ByteBuffer.allocate(100);\n+                            try {\n+                                System.out.println(\"SC: \" + sc + \" reading\");\n+                                while (true) {\n+                                    bb.clear();\n+                                    sc.read(bb);\n+                                }\n+                            } catch (ClosedChannelException _) {\n+                            } catch (IOException ioe) {\n+                                throw new UncheckedIOException(ioe);\n+                            }\n+                            return null;\n+                        }\n+                )\n+        );\n+    }\n+\n+    \/**\n+     * Runs the test for SocketChannel\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable, CountDownLatch)\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"scOperations\")\n+    public void testSocketChannel(String opName, Function<SocketChannel, Void> scOperation)\n+            throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(3)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s SocketChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                try (Selector sel = Selector.open();\n+                     SocketChannel sc = SocketChannel.open()) {\n+                    \/\/ create and bind a SocketChannel\n+                    sc.bind(BIND_ADDR);\n+                    \/\/ stay in blocking mode till the SocketChannel is connected\n+                    sc.configureBlocking(true);\n+                    Future<SocketChannel> acceptedChannel;\n+                    SocketChannel conn;\n+                    \/\/ create a remote server and connect to it\n+                    try (ServerSocketChannel server = ServerSocketChannel.open()) {\n+                        server.bind(BIND_ADDR);\n+                        SocketAddress remoteAddr = server.getLocalAddress();\n+                        acceptedChannel = executor.submit(new ConnAcceptor(server));\n+                        System.out.println(\"connecting to \" + remoteAddr);\n+                        sc.connect(remoteAddr);\n+                        conn = acceptedChannel.get();\n+                    }\n+                    try (conn) {\n+                        \/\/ switch to non-blocking\n+                        sc.configureBlocking(false);\n+                        System.out.println(\"switched to non-blocking: \" + sc);\n+                        \/\/ register the SocketChannel with a selector\n+                        \/\/ (doesn't matter the interestOps)\n+                        SelectionKey key = sc.register(sel, SelectionKey.OP_READ);\n+                        CountDownLatch opStartLatch = new CountDownLatch(1);\n+                        runTest(executor, key, () -> {\n+                            \/\/ notify that we will now start operation on the SC\n+                            opStartLatch.countDown();\n+                            return scOperation.apply(sc);\n+                        }, opStartLatch);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Runs the test for ServerSocketChannel\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable, CountDownLatch)\n+     *\/\n+    @Test\n+    public void testServerSocketChannel() throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s ServerSocketChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                try (Selector sel = Selector.open();\n+                     ServerSocketChannel ssc = ServerSocketChannel.open()) {\n+                    \/\/ create and bind a ServerSocketChannel\n+                    ssc.bind(BIND_ADDR);\n+                    ssc.configureBlocking(false);\n+                    \/\/ register the ServerSocketChannel with a selector\n+                    SelectionKey key = ssc.register(sel, SelectionKey.OP_ACCEPT);\n+                    CountDownLatch opStartLatch = new CountDownLatch(1);\n+                    runTest(executor, key, () -> {\n+                        \/\/ notify that we will now start accept()ing\n+                        opStartLatch.countDown();\n+                        \/\/ repeatedly do SSC.accept() till there's a ClosedChannelException\n+                        try {\n+                            while (true) {\n+                                ssc.accept();\n+                            }\n+                        } catch (ClosedChannelException _) {\n+                        }\n+                        return null;\n+                    }, opStartLatch);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Runs the test for SinkChannel\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable, CountDownLatch)\n+     *\/\n+    @Test\n+    public void testSinkChannel() throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s SinkChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                Pipe pipe = Pipe.open();\n+                try (Selector sel = Selector.open();\n+                     Pipe.SinkChannel sink = pipe.sink()) {\n+                    sink.configureBlocking(false);\n+                    SelectionKey key = sink.register(sel, SelectionKey.OP_WRITE);\n+                    CountDownLatch opStartLatch = new CountDownLatch(1);\n+                    runTest(executor, key, () -> {\n+                        \/\/ notify that we will now start write()ing\n+                        opStartLatch.countDown();\n+                        \/\/ repeatedly do SC.write() till there's a ClosedChannelException\n+                        ByteBuffer bb = ByteBuffer.allocate(100);\n+                        try {\n+                            while (true) {\n+                                bb.clear();\n+                                sink.write(bb);\n+                            }\n+                        } catch (ClosedChannelException _) {\n+                        }\n+                        return null;\n+                    }, opStartLatch);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Runs the test for SourceChannel\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable, CountDownLatch)\n+     *\/\n+    @Test\n+    public void testSourceChannel() throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s SourceChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                Pipe pipe = Pipe.open();\n+                try (Selector sel = Selector.open();\n+                     Pipe.SourceChannel source = pipe.source()) {\n+                    source.configureBlocking(false);\n+                    SelectionKey key = source.register(sel, SelectionKey.OP_READ);\n+                    CountDownLatch opStartLatch = new CountDownLatch(1);\n+                    runTest(executor, key, () -> {\n+                        \/\/ notify that we will now start read()ing\n+                        opStartLatch.countDown();\n+                        \/\/ repeatedly do SC.read() till there's a ClosedChannelException\n+                        ByteBuffer bb = ByteBuffer.allocate(100);\n+                        try {\n+                            while (true) {\n+                                bb.clear();\n+                                source.read(bb);\n+                            }\n+                        } catch (ClosedChannelException _) {\n+                        }\n+                        return null;\n+                    }, opStartLatch);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * SelectableChannel implementations internally have a deferred close implementation. When a\n+     * channel is registered with a Selector and close() is invoked on the channel from a certain\n+     * thread, then the implementation of close() defers the actual close if the channel has\n+     * in-progress operations (for example, read\/write\/send\/receive and such) in some other thread.\n+     * A subsequent operation through the Selector (like Selector.select()) then completes the\n+     * deferred close (waiting for any in-progress operations to complete). This test method\n+     * verifies that the deferred close implementation doesn't prematurely close and release\n+     * the resources used by the channel, while there are in-progress operations.\n+     * <p>\n+     * Launches 2 threads, T1 and T2. When T1 and T2 are in progress, this method closes the\n+     * channel that is registered with the Selector.\n+     * T1 is running the channelOperation (which keeps running operations on the channel).\n+     * T2 is running a task which keeps invoking Selector.select(), until the channel is closed.\n+     * When T2 notices that the channel is closed, it cancels the selectionKey and then\n+     * invokes one last Selector.select() operation to finish the deferred close of the channel.\n+     *\/\n+    private static void runTest(ExecutorService executor, SelectionKey selectionKey,\n+                                Callable<Void> channelOperation, CountDownLatch chanOpStartLatch)\n+            throws Exception {\n+\n+        SelectableChannel channel = selectionKey.channel();\n+        assertFalse(channel.isBlocking(), \"channel isn't non-blocking: \" + channel);\n+        selectionKey.selector().selectNow();\n+        \/\/ run the channel operations\n+        Future<?> channelOpResult = executor.submit(channelOperation);\n+        CountDownLatch selectorTaskStartLatch = new CountDownLatch(1);\n+        \/\/ run the Selector.select() task\n+        Future<?> selectorTaskResult = executor.submit(\n+                new SelectorTask(selectionKey, selectorTaskStartLatch));\n+        \/\/ await for the channel operation task and the selector task to start\n+        chanOpStartLatch.await();\n+        selectorTaskStartLatch.await();\n+        \/\/ close the channel while it's still registered with the Selector,\n+        \/\/ so that the close is deferred by the channel implementations.\n+        System.out.println(\"closing channel: \" + channel);\n+        assertTrue(channel.isOpen(), \"channel already closed: \" + channel);\n+        assertTrue(channel.isRegistered(), \"channel isn't registered: \" + channel);\n+        channel.close();\n+        \/\/ wait for the operation on the channel and the selector task to complete\n+        channelOpResult.get();\n+        selectorTaskResult.get();\n+    }\n+\n+    \/*\n+     * Keeps invoking Selector.select() until the channel is closed, after which\n+     * it cancels the SelectionKey and does one last Selector.select() to finish\n+     * the deferred close.\n+     *\/\n+    private static final class SelectorTask implements Callable<Void> {\n+        private final SelectionKey selectionKey;\n+        private final CountDownLatch startedLatch;\n+\n+        private SelectorTask(SelectionKey selectionKey, CountDownLatch startedLatch) {\n+            this.selectionKey = Objects.requireNonNull(selectionKey);\n+            this.startedLatch = startedLatch;\n+        }\n+\n+        @Override\n+        public Void call() throws Exception {\n+            try {\n+                Selector selector = selectionKey.selector();\n+                SelectableChannel channel = selectionKey.channel();\n+                \/\/ notify that the task has started\n+                startedLatch.countDown();\n+                while (true) {\n+                    selector.select(10);\n+                    if (!channel.isOpen()) {\n+                        \/\/ the channel is (defer) closed, cancel the registration and then\n+                        \/\/ issue a select() so that the Selector finishes the deferred\n+                        \/\/ close of the channel.\n+                        System.out.println(\"channel: \" + channel + \" isn't open,\" +\n+                                \" now cancelling key: \" + selectionKey);\n+                        selectionKey.cancel();\n+                        System.out.println(\"initiating select after key cancelled: \" + selectionKey);\n+                        selector.select(5);\n+                        break;\n+                    }\n+                }\n+            } catch (ClosedSelectorException _) {\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private static final class ConnAcceptor implements Callable<SocketChannel> {\n+        private final ServerSocketChannel serverSocketChannel;\n+\n+        private ConnAcceptor(ServerSocketChannel serverSocketChannel) {\n+            this.serverSocketChannel = serverSocketChannel;\n+        }\n+\n+        @Override\n+        public SocketChannel call() throws Exception {\n+            SocketChannel accepted = serverSocketChannel.accept();\n+            System.out.println(\"Accepted connection: \" + accepted);\n+            return accepted;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Selector\/DeferredClose\/DeferredCloseTest.java","additions":484,"deletions":0,"binary":false,"changes":484,"status":"added"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.net;\n+\n+\n+import java.util.Locale;\n+\n+\/\/ Patched implementation only meant to be used in certain tests\n+public class InetSocketAddress extends SocketAddress {\n+\n+    @java.io.Serial\n+    private static final long serialVersionUID = 5076001401234631237L;\n+\n+    public static boolean enableDelay;\n+\n+    static {\n+        System.out.println(\"patched InetSocketAddress class in use\");\n+    }\n+\n+    private final String hostname;\n+    private final InetAddress addr;\n+    private final int port;\n+\n+    public InetSocketAddress(int port) {\n+        this(InetAddress.anyLocalAddress(), port);\n+    }\n+\n+    public InetSocketAddress(InetAddress addr, int port) {\n+        this(null,\n+                addr == null ? InetAddress.anyLocalAddress() : addr,\n+                checkPort(port));\n+    }\n+\n+    public InetSocketAddress(String hostname, int port) {\n+        checkHost(hostname);\n+        InetAddress addr = null;\n+        String host = null;\n+        try {\n+            addr = InetAddress.getByName(hostname);\n+        } catch (UnknownHostException e) {\n+            host = hostname;\n+        }\n+        this.hostname = host;\n+        this.addr = addr;\n+        this.port = checkPort(port);\n+    }\n+\n+    public static InetSocketAddress createUnresolved(String host, int port) {\n+        return new InetSocketAddress(checkHost(host), null, checkPort(port));\n+    }\n+\n+    public static void enableDelay() {\n+        enableDelay = true;\n+    }\n+\n+    public static void disableDelay() {\n+        enableDelay = false;\n+    }\n+\n+    private InetSocketAddress(String hostname, InetAddress addr, int port) {\n+        this.hostname = hostname;\n+        this.addr = addr;\n+        this.port = port;\n+        if (enableDelay) {\n+            doDelay();\n+        }\n+    }\n+\n+    \/**\n+     * Gets the port number.\n+     *\n+     * @return the port number.\n+     *\/\n+    public final int getPort() {\n+        if (enableDelay) {\n+            doDelay();\n+        }\n+        return this.port;\n+    }\n+\n+    \/**\n+     * Gets the {@code InetAddress}.\n+     *\n+     * @return the InetAddress or {@code null} if it is unresolved.\n+     *\/\n+    public final InetAddress getAddress() {\n+        return this.addr;\n+    }\n+\n+    public final String getHostName() {\n+        if (hostname != null) {\n+            return hostname;\n+        }\n+        if (addr != null) {\n+            return addr.getHostName();\n+        }\n+        return null;\n+    }\n+\n+    public final String getHostString() {\n+        if (hostname != null) {\n+            return hostname;\n+        }\n+        if (addr != null) {\n+            if (addr.holder().getHostName() != null) {\n+                return addr.holder().getHostName();\n+            } else {\n+                return addr.getHostAddress();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public final boolean isUnresolved() {\n+        return addr == null;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String formatted;\n+        if (isUnresolved()) {\n+            formatted = hostname + \"\/<unresolved>\";\n+        } else {\n+            formatted = addr.toString();\n+            if (addr instanceof Inet6Address) {\n+                int i = formatted.lastIndexOf(\"\/\");\n+                formatted = formatted.substring(0, i + 1)\n+                        + \"[\" + formatted.substring(i + 1) + \"]\";\n+            }\n+        }\n+        return formatted + \":\" + port;\n+    }\n+\n+    @Override\n+    public final boolean equals(Object other) {\n+        if (!(other instanceof InetSocketAddress that)) {\n+            return false;\n+        }\n+        boolean sameIP;\n+        if (addr != null) {\n+            sameIP = addr.equals(that.addr);\n+        } else if (hostname != null) {\n+            sameIP = (that.addr == null) &&\n+                    hostname.equalsIgnoreCase(that.hostname);\n+        } else {\n+            sameIP = (that.addr == null) && (that.hostname == null);\n+        }\n+        return sameIP && (port == that.port);\n+    }\n+\n+    @Override\n+    public final int hashCode() {\n+        if (addr != null) {\n+            return addr.hashCode() + port;\n+        }\n+        if (hostname != null) {\n+            return hostname.toLowerCase(Locale.ROOT).hashCode() + port;\n+        }\n+        return port;\n+    }\n+\n+    private static int checkPort(int port) {\n+        if (port < 0 || port > 0xFFFF)\n+            throw new IllegalArgumentException(\"port out of range:\" + port);\n+        return port;\n+    }\n+\n+    private static String checkHost(String hostname) {\n+        if (hostname == null)\n+            throw new IllegalArgumentException(\"hostname can't be null\");\n+        return hostname;\n+    }\n+\n+    private static void doDelay() {\n+        System.out.println(\"intentional delay injected in InetSocketAddress\");\n+        try {\n+            Thread.sleep(10);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Selector\/DeferredClose\/java.base\/java\/net\/InetSocketAddress.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"}]}