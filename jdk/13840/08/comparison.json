{"files":[{"patch":"@@ -1004,0 +1004,17 @@\n+#\n+# Support for the here() function\n+#\n+# This security property determines whether the here() XPath function is\n+# supported in XML Signature generation and verification.\n+#\n+# If this property is set to false, the here() function is not supported.\n+# Generating an XML Signature that uses the here() function will throw an\n+# XMLSignatureException. Validating an existing XML Signature that uses the\n+# here() function will also throw an XMLSignatureException.\n+#\n+# The default value for this property is true.\n+#\n+# Note: This property is currently used by the JDK Reference implementation.\n+# It is not guaranteed to be examined and used by other implementations.\n+#\n+#jdk.xml.dsig.hereFunctionSupported=true\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -99,0 +99,2 @@\n+    permission java.security.SecurityPermission\n+                   \"getProperty.jdk.xml.dsig.hereFunctionSupported\";\n","filename":"src\/java.base\/share\/lib\/security\/default.policy","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -212,0 +212,8 @@\n+        algorithmsMap.put(\n+            XMLSignature.ALGO_ID_SIGNATURE_EDDSA_ED25519,\n+            new Algorithm(\"Ed25519\", \"Ed25519\", \"Signature\")\n+        );\n+        algorithmsMap.put(\n+            XMLSignature.ALGO_ID_SIGNATURE_EDDSA_ED448,\n+            new Algorithm(\"Ed448\", \"Ed448\", \"Signature\")\n+        );\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/algorithms\/JCEMapper.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,4 +34,1 @@\n-import com.sun.org.apache.xml.internal.security.algorithms.implementations.IntegrityHmac;\n-import com.sun.org.apache.xml.internal.security.algorithms.implementations.SignatureBaseRSA;\n-import com.sun.org.apache.xml.internal.security.algorithms.implementations.SignatureDSA;\n-import com.sun.org.apache.xml.internal.security.algorithms.implementations.SignatureECDSA;\n+import com.sun.org.apache.xml.internal.security.algorithms.implementations.*;\n@@ -499,0 +496,6 @@\n+        algorithmHash.put(\n+                XMLSignature.ALGO_ID_SIGNATURE_EDDSA_ED25519, SignatureEDDSA.SignatureEd25519.class\n+        );\n+        algorithmHash.put(\n+                XMLSignature.ALGO_ID_SIGNATURE_EDDSA_ED448, SignatureEDDSA.SignatureEd448.class\n+        );\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/algorithms\/SignatureAlgorithm.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.util.Iterator;\n@@ -789,3 +788,1 @@\n-        Iterator<ECCurveDefinition> ecCurveDefinitionIterator = ecCurveDefinitions.iterator();\n-        while (ecCurveDefinitionIterator.hasNext()) {\n-            ECCurveDefinition ecCurveDefinition = ecCurveDefinitionIterator.next();\n+        for (ECCurveDefinition ecCurveDefinition : ecCurveDefinitions) {\n@@ -801,3 +798,1 @@\n-        Iterator<ECCurveDefinition> ecCurveDefinitionIterator = ecCurveDefinitions.iterator();\n-        while (ecCurveDefinitionIterator.hasNext()) {\n-            ECCurveDefinition ecCurveDefinition = ecCurveDefinitionIterator.next();\n+        for (ECCurveDefinition ecCurveDefinition : ecCurveDefinitions) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/algorithms\/implementations\/ECDSAUtils.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,228 @@\n+\/*\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n+ *\/\n+\/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\/\n+package com.sun.org.apache.xml.internal.security.algorithms.implementations;\n+\n+import com.sun.org.apache.xml.internal.security.algorithms.JCEMapper;\n+import com.sun.org.apache.xml.internal.security.algorithms.SignatureAlgorithmSpi;\n+import com.sun.org.apache.xml.internal.security.signature.XMLSignature;\n+import com.sun.org.apache.xml.internal.security.signature.XMLSignatureException;\n+import com.sun.org.apache.xml.internal.security.utils.XMLUtils;\n+\n+import java.io.IOException;\n+import java.security.*;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+\/**\n+ *\n+ *\/\n+public abstract class SignatureEDDSA extends SignatureAlgorithmSpi {\n+\n+    private static final com.sun.org.slf4j.internal.Logger LOG =\n+        com.sun.org.slf4j.internal.LoggerFactory.getLogger(SignatureEDDSA.class);\n+\n+    private final Signature signatureAlgorithm;\n+\n+\n+    \/**\n+     * Constructor SignatureEDDSA\n+     *\n+     * @throws XMLSignatureException\n+     *\/\n+    public SignatureEDDSA() throws XMLSignatureException {\n+        this(null);\n+    }\n+\n+    public SignatureEDDSA(Provider provider) throws XMLSignatureException {\n+        String algorithmID = JCEMapper.translateURItoJCEID(this.engineGetURI());\n+        LOG.debug(\"Created SignatureEDDSA using {}\", algorithmID);\n+\n+        try {\n+            if (provider == null) {\n+                String providerId = JCEMapper.getProviderId();\n+                if (providerId == null) {\n+                    this.signatureAlgorithm = Signature.getInstance(algorithmID);\n+\n+                } else {\n+                    this.signatureAlgorithm = Signature.getInstance(algorithmID, providerId);\n+                }\n+\n+            } else {\n+                this.signatureAlgorithm = Signature.getInstance(algorithmID, provider);\n+            }\n+\n+        } catch (NoSuchAlgorithmException | NoSuchProviderException ex) {\n+            Object[] exArgs = { algorithmID, ex.getLocalizedMessage() };\n+            throw new XMLSignatureException(\"algorithms.NoSuchAlgorithm\", exArgs);\n+        }\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    protected void engineSetParameter(AlgorithmParameterSpec params)\n+        throws XMLSignatureException {\n+        try {\n+            this.signatureAlgorithm.setParameter(params);\n+        } catch (InvalidAlgorithmParameterException ex) {\n+            throw new XMLSignatureException(ex);\n+        }\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    protected boolean engineVerify(byte[] signature) throws XMLSignatureException {\n+        try {\n+\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Called SignatureEDDSA.verify() on \" + XMLUtils.encodeToString(signature));\n+            }\n+\n+            return this.signatureAlgorithm.verify(signature);\n+        } catch (SignatureException  ex) {\n+            throw new XMLSignatureException(ex);\n+        }\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    protected void engineInitVerify(Key publicKey) throws XMLSignatureException {\n+        engineInitVerify(publicKey, signatureAlgorithm);\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    protected byte[] engineSign() throws XMLSignatureException {\n+        try {\n+            return this.signatureAlgorithm.sign();\n+        } catch (SignatureException ex) {\n+            throw new XMLSignatureException(ex);\n+        }\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    protected void engineInitSign(Key privateKey, SecureRandom secureRandom)\n+        throws XMLSignatureException {\n+\n+        engineInitSign(privateKey, secureRandom, this.signatureAlgorithm);\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    protected void engineInitSign(Key privateKey) throws XMLSignatureException {\n+        engineInitSign(privateKey, (SecureRandom)null);\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    protected void engineUpdate(byte[] input) throws XMLSignatureException {\n+        try {\n+            this.signatureAlgorithm.update(input);\n+        } catch (SignatureException ex) {\n+            throw new XMLSignatureException(ex);\n+        }\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    protected void engineUpdate(byte input) throws XMLSignatureException {\n+        try {\n+            this.signatureAlgorithm.update(input);\n+        } catch (SignatureException ex) {\n+            throw new XMLSignatureException(ex);\n+        }\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    protected void engineUpdate(byte[] buf, int offset, int len) throws XMLSignatureException {\n+        try {\n+            this.signatureAlgorithm.update(buf, offset, len);\n+        } catch (SignatureException ex) {\n+            throw new XMLSignatureException(ex);\n+        }\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    protected String engineGetJCEAlgorithmString() {\n+        return this.signatureAlgorithm.getAlgorithm();\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    protected String engineGetJCEProviderName() {\n+        return this.signatureAlgorithm.getProvider().getName();\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    protected void engineSetHMACOutputLength(int HMACOutputLength)\n+        throws XMLSignatureException {\n+        throw new XMLSignatureException(\"algorithms.HMACOutputLengthOnlyForHMAC\");\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    protected void engineInitSign(\n+        Key signingKey, AlgorithmParameterSpec algorithmParameterSpec\n+    ) throws XMLSignatureException {\n+        throw new XMLSignatureException(\"algorithms.CannotUseAlgorithmParameterSpecOnEdDSA\");\n+    }\n+\n+    \/**\n+     * Class SignatureEd25519\n+     *\n+     *\/\n+    public static class SignatureEd25519 extends SignatureEDDSA {\n+        \/**\n+         * Constructor SignatureEd25519\n+         *\n+         * @throws XMLSignatureException\n+         *\/\n+        public SignatureEd25519() throws XMLSignatureException {\n+            super();\n+        }\n+\n+        public SignatureEd25519(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n+        \/** {@inheritDoc} *\/\n+        @Override\n+        public String engineGetURI() {\n+            return XMLSignature.ALGO_ID_SIGNATURE_EDDSA_ED25519;\n+        }\n+    }\n+\n+    \/**\n+     * Class SignatureEd448\n+     *\/\n+    public static class SignatureEd448 extends SignatureEDDSA {\n+\n+        \/**\n+         * Constructor SignatureEd448\n+         *\n+         * @throws XMLSignatureException\n+         *\/\n+        public SignatureEd448() throws XMLSignatureException {\n+            super();\n+        }\n+\n+        public SignatureEd448(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n+        \/** {@inheritDoc} *\/\n+        @Override\n+        public String engineGetURI() {\n+            return XMLSignature.ALGO_ID_SIGNATURE_EDDSA_ED448;\n+        }\n+    }\n+}\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/algorithms\/implementations\/SignatureEDDSA.java","additions":228,"deletions":0,"binary":false,"changes":228,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.Iterator;\n@@ -461,1 +460,2 @@\n-    protected int isVisibleDO(Node currentNode, int level) {\n+    protected int isVisibleDO(Node currentNode, int level)\n+            throws CanonicalizationException {\n@@ -463,5 +463,8 @@\n-            Iterator<NodeFilter> it = nodeFilter.iterator();\n-            while (it.hasNext()) {\n-                int i = it.next().isNodeIncludeDO(currentNode, level);\n-                if (i != 1) {\n-                    return i;\n+            for (NodeFilter filter : nodeFilter) {\n+                try {\n+                    int i = filter.isNodeIncludeDO(currentNode, level);\n+                    if (i != 1) {\n+                        return i;\n+                    }\n+                } catch (Exception e) {\n+                    throw new CanonicalizationException(e);\n@@ -477,1 +480,2 @@\n-    protected int isVisibleInt(Node currentNode) {\n+    protected int isVisibleInt(Node currentNode)\n+            throws CanonicalizationException {\n@@ -479,5 +483,8 @@\n-            Iterator<NodeFilter> it = nodeFilter.iterator();\n-            while (it.hasNext()) {\n-                int i = it.next().isNodeInclude(currentNode);\n-                if (i != 1) {\n-                    return i;\n+            for (NodeFilter filter : nodeFilter) {\n+                try {\n+                    int i = filter.isNodeInclude(currentNode);\n+                    if (i != 1) {\n+                        return i;\n+                    }\n+                } catch (Exception e) {\n+                    throw new CanonicalizationException(e);\n@@ -493,1 +500,1 @@\n-    protected boolean isVisible(Node currentNode) {\n+    protected boolean isVisible(Node currentNode) throws CanonicalizationException {\n@@ -495,4 +502,7 @@\n-            Iterator<NodeFilter> it = nodeFilter.iterator();\n-            while (it.hasNext()) {\n-                if (it.next().isNodeInclude(currentNode) != 1) {\n-                    return false;\n+            for (NodeFilter filter : nodeFilter) {\n+                try {\n+                    if (filter.isNodeInclude(currentNode) != 1) {\n+                        return false;\n+                    }\n+                } catch (Exception e) {\n+                    throw new CanonicalizationException(e);\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/implementations\/CanonicalizerBase.java","additions":28,"deletions":18,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.util.Iterator;\n@@ -53,1 +52,1 @@\n-    \/**The map betwen prefix-> entry table. *\/\n+    \/**The map between prefix-> entry table. *\/\n@@ -61,1 +60,1 @@\n-     * Default constractor\n+     * Default constructor\n@@ -78,3 +77,1 @@\n-        Iterator<NameSpaceSymbEntry> it = symb.entrySet().iterator();\n-        while (it.hasNext()) {\n-            NameSpaceSymbEntry n = it.next();\n+        for (NameSpaceSymbEntry n : symb.entrySet()) {\n@@ -173,1 +170,1 @@\n-        \/\/ Return the node for outputing.\n+        \/\/ Return the node for outputting.\n@@ -180,1 +177,1 @@\n-     * @param prefix The prefix whose definition is neaded.\n+     * @param prefix The prefix whose definition is needed.\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/implementations\/NameSpaceSymbTable.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -132,1 +132,0 @@\n-                Iterator<Attr> it = col.iterator();\n@@ -135,2 +134,1 @@\n-                while (it.hasNext()) {\n-                    Attr n = it.next();\n+                for (Attr n : col) {\n@@ -143,3 +141,1 @@\n-                it = baseAttrs.iterator();\n-                while (it.hasNext()) {\n-                    Attr n = it.next();\n+                for (Attr n : baseAttrs) {\n@@ -165,3 +161,1 @@\n-                Iterator<Attr> it = e.nodes.iterator();\n-                while (it.hasNext()) {\n-                    Attr n = it.next();\n+                for (Attr n : e.nodes) {\n@@ -355,1 +349,1 @@\n-                \/\/ else delte it.; otherwise,\n+                \/\/ else delete it.; otherwise,\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/implementations\/XmlAttrStack.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-     * @return the managment data\n+     * @return the management data\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/content\/MgmtData.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.util.Iterator;\n@@ -286,1 +285,0 @@\n-        Iterator<Node> it = set.iterator();\n@@ -288,2 +286,1 @@\n-        while (it.hasNext()) {\n-            Node currentNode = it.next();\n+        for (Node currentNode : set) {\n@@ -297,1 +294,1 @@\n-        \/\/ Obtain all the parents of the elemnt\n+        \/\/ Obtain all the parents of the element\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/keyresolver\/implementations\/RetrievalMethodResolver.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -131,0 +131,5 @@\n+\n+      <SignatureAlgorithm URI=\"http:\/\/www.w3.org\/2021\/04\/xmldsig-more#eddsa-ed25519\"\n+                          JAVACLASS=\"com.sun.org.apache.xml.internal.security.algorithms.implementations.SignatureEDDSA$SignatureEd25519\" \/>\n+      <SignatureAlgorithm URI=\"http:\/\/www.w3.org\/2021\/04\/xmldsig-more#eddsa-ed448\"\n+                          JAVACLASS=\"com.sun.org.apache.xml.internal.security.algorithms.implementations.SignatureEDDSA$SignatureEd448\" \/>\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/resource\/config.xml","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.Iterator;\n@@ -360,4 +359,0 @@\n-                        Iterator<Node> nlIterator = nl.iterator();\n-\n-                        while (nlIterator.hasNext()) {\n-                            Node n = nlIterator.next();\n@@ -365,0 +360,1 @@\n+                        for (Node n : nl) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/Manifest.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import com.sun.org.apache.xml.internal.security.transforms.TransformationException;\n@@ -40,1 +41,1 @@\n-    int isNodeInclude(Node n);\n+    int isNodeInclude(Node n) throws TransformationException;\n@@ -53,1 +54,1 @@\n-    int isNodeIncludeDO(Node n, int level);\n+    int isNodeIncludeDO(Node n, int level) throws TransformationException;\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/NodeFilter.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * $todo$ if we remove childen, the boolean values are not updated\n+ * $todo$ if we remove children, the boolean values are not updated\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/ObjectContainer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-     * Constructs {@link SignatureProperty} using sepcified {@code target} attribute and\n+     * Constructs {@link SignatureProperty} using specified {@code target} attribute and\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/SignatureProperty.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-     * of verified referenes associated with this Manifest\n+     * of verified references associated with this Manifest\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/VerifiedReference.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -204,0 +204,8 @@\n+    \/**Signature - EDDSA ED25519 *\/\n+    public static final String ALGO_ID_SIGNATURE_EDDSA_ED25519 =\n+            \"http:\/\/www.w3.org\/2021\/04\/xmldsig-more#eddsa-ed25519\";\n+\n+    \/**Signature - EDDSA ED448 *\/\n+    public static final String ALGO_ID_SIGNATURE_EDDSA_ED448 =\n+            \"http:\/\/www.w3.org\/2021\/04\/xmldsig-more#eddsa-ed448\";\n+\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/XMLSignature.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-     * @param xmlSignatureInput the signatur to pretty print\n+     * @param xmlSignatureInput the signature to pretty print\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/XMLSignatureInputDebugger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -312,1 +312,1 @@\n-     * @param input input {@link XMLSignatureInput} which can supplied Octect\n+     * @param input input {@link XMLSignatureInput} which can supplied Octet\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/Transform.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -23,0 +23,3 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\/\n@@ -27,0 +30,3 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.security.Security;\n@@ -36,4 +42,1 @@\n-import com.sun.org.apache.xml.internal.security.utils.Constants;\n-import com.sun.org.apache.xml.internal.security.utils.XMLUtils;\n-import com.sun.org.apache.xml.internal.security.utils.XPathAPI;\n-import com.sun.org.apache.xml.internal.security.utils.XPathFactory;\n+import com.sun.org.apache.xml.internal.security.utils.*;\n@@ -55,2 +58,19 @@\n-    private static final com.sun.org.slf4j.internal.Logger LOG =\n-            com.sun.org.slf4j.internal.LoggerFactory.getLogger(TransformXPath.class);\n+    \/\/ Whether the here() XPath function is supported.\n+    static final boolean HEREFUNC;\n+\n+    static {\n+        @SuppressWarnings(\"removal\")\n+        String prop =\n+                AccessController.doPrivileged((PrivilegedAction<String>) () ->\n+                        Security.getProperty(\"jdk.xml.dsig.hereFunctionSupported\"));\n+        if (prop == null) {\n+            HEREFUNC = true; \/\/ default true\n+        } else if (prop.equals(\"true\")) {\n+            HEREFUNC = true;\n+        } else if (prop.equals(\"false\")) {\n+            HEREFUNC = false;\n+        } else {\n+            throw new IllegalArgumentException(\n+                    \"Invalid jdk.xml.dsig.hereFunctionSupported setting: \" + prop);\n+        }\n+    }\n@@ -115,1 +135,3 @@\n-        return XPathFactory.newInstance();\n+        return HEREFUNC\n+                ? XPathFactory.newInstance()\n+                : new JDKXPathFactory();\n@@ -143,1 +165,1 @@\n-        public int isNodeInclude(Node currentNode) {\n+        public int isNodeInclude(Node currentNode) throws TransformationException {\n@@ -150,3 +172,2 @@\n-            } catch (TransformerException e) {\n-                LOG.debug(\"Error evaluating XPath expression\", e);\n-                return 0;\n+            } catch (TransformerException ex) {\n+                throw new TransformationException(ex);\n@@ -156,1 +177,1 @@\n-        public int isNodeIncludeDO(Node n, int level) {\n+        public int isNodeIncludeDO(Node n, int level) throws TransformationException {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/implementations\/TransformXPath.java","additions":33,"deletions":12,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import com.sun.org.apache.xml.internal.security.utils.JDKXPathFactory;\n@@ -97,1 +98,3 @@\n-            XPathFactory xpathFactory = XPathFactory.newInstance();\n+            XPathFactory xpathFactory = TransformXPath.HEREFUNC\n+                    ? XPathFactory.newInstance()\n+                    : new JDKXPathFactory();\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/implementations\/TransformXPath2Filter.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-     * translates a message ID into an internationalized String, see alse\n+     * translates a message ID into an internationalized String, see also\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/I18n.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -471,2 +471,2 @@\n-        String trimed = str.trim();\n-        int i = str.indexOf(trimed) + trimed.length();\n+        String trimmed = str.trim();\n+        int i = str.indexOf(trimmed) + trimmed.length();\n@@ -474,3 +474,3 @@\n-        if (str.length() > i && trimed.endsWith(\"\\\\\")\n-            && !trimed.endsWith(\"\\\\\\\\\") && str.charAt(i) == ' ') {\n-            trimed = trimed + \" \";\n+        if (str.length() > i && trimmed.endsWith(\"\\\\\")\n+            && !trimmed.endsWith(\"\\\\\\\\\") && str.charAt(i) == ' ') {\n+            trimmed = trimmed + \" \";\n@@ -479,1 +479,1 @@\n-        return trimed;\n+        return trimmed;\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/RFC2253Parser.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * defined in the <a href=\"http:\/\/www.w3.org\/TR\/xmldsig-core\/\">\n+ * defined in the <a href=\"https:\/\/www.w3.org\/TR\/xmldsig-core\/\">\n@@ -54,0 +54,6 @@\n+ * <p>\n+ * The digest method algorithm URIs defined in this class are specified\n+ * in the <a href=\"https:\/\/www.w3.org\/TR\/xmldsig-core\/\">\n+ * W3C Recommendation for XML-Signature Syntax and Processing<\/a>\n+ * and <a href=\"https:\/\/www.rfc-editor.org\/info\/rfc9231\">\n+ * RFC 9231: Additional XML Security Uniform Resource Identifiers (URIs)<\/a>\n@@ -62,2 +68,0 @@\n-    \/\/ All methods can be found in RFC 6931.\n-\n","filename":"src\/java.xml.crypto\/share\/classes\/javax\/xml\/crypto\/dsig\/DigestMethod.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * as defined in the <a href=\"http:\/\/www.w3.org\/TR\/xmldsig-core\/\">\n+ * as defined in the <a href=\"https:\/\/www.w3.org\/TR\/xmldsig-core\/\">\n@@ -55,0 +55,6 @@\n+ * <p>\n+ * The signature method algorithm URIs defined in this class are specified\n+ * in the <a href=\"https:\/\/www.w3.org\/TR\/xmldsig-core\/\">\n+ * W3C Recommendation for XML-Signature Syntax and Processing<\/a>\n+ * and <a href=\"https:\/\/www.rfc-editor.org\/info\/rfc9231\">\n+ * RFC 9231: Additional XML Security Uniform Resource Identifiers (URIs)<\/a>\n@@ -63,2 +69,0 @@\n-    \/\/ All methods can be found in RFC 6931.\n-\n@@ -258,0 +262,16 @@\n+    \/**\n+     * The <a href=\"http:\/\/www.w3.org\/2021\/04\/xmldsig-more#eddsa-ed25519\">\n+     * ED25519<\/a> signature method algorithm URI.\n+     *\n+     * @since 21\n+     *\/\n+    String ED25519 = \"http:\/\/www.w3.org\/2021\/04\/xmldsig-more#eddsa-ed25519\";\n+\n+    \/**\n+     * The <a href=\"http:\/\/www.w3.org\/2021\/04\/xmldsig-more#eddsa-ed448\">\n+     * ED448<\/a> signature method algorithm URI.\n+     *\n+     * @since 21\n+     *\/\n+    String ED448 = \"http:\/\/www.w3.org\/2021\/04\/xmldsig-more#eddsa-ed448\";\n+\n","filename":"src\/java.xml.crypto\/share\/classes\/javax\/xml\/crypto\/dsig\/SignatureMethod.java","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    enum Type { DSA, RSA, ECDSA, HMAC }\n+    enum Type { DSA, RSA, ECDSA, EDDSA, HMAC }\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/AbstractDOMSignatureMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+\n+import com.sun.org.apache.xml.internal.security.transforms.TransformationException;\n@@ -49,4 +51,0 @@\n-        if (xi.getNodeFilters() != null && !xi.getNodeFilters().isEmpty()) {\n-            return Collections.unmodifiableSet\n-                (getNodeSet(xi.getNodeFilters())).iterator();\n-        }\n@@ -54,0 +52,4 @@\n+            if (xi.getNodeFilters() != null && !xi.getNodeFilters().isEmpty()) {\n+                return Collections.unmodifiableSet\n+                        (getNodeSet(xi.getNodeFilters())).iterator();\n+            }\n@@ -66,1 +68,2 @@\n-    private Set<Node> getNodeSet(List<NodeFilter> nodeFilters) {\n+    private Set<Node> getNodeSet(List<NodeFilter> nodeFilters)\n+            throws TransformationException {\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/ApacheNodeSetData.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -85,0 +85,6 @@\n+    \/\/ see RFC 9231 for these algorithm definitions\n+    static final String ED25519 =\n+        \"http:\/\/www.w3.org\/2021\/04\/xmldsig-more#eddsa-ed25519\";\n+    static final String ED448 =\n+        \"http:\/\/www.w3.org\/2021\/04\/xmldsig-more#eddsa-ed448\";\n+\n@@ -223,0 +229,4 @@\n+        } else if (alg.equals(ED25519)) {\n+            return new EDDSA_ED25519(smElem);\n+        } else if (alg.equals(ED448)) {\n+            return new EDDSA_ED448(smElem);\n@@ -545,0 +555,33 @@\n+    abstract static class AbstractEDDSASignatureMethod\n+            extends DOMSignatureMethod {\n+\n+\n+        AbstractEDDSASignatureMethod(AlgorithmParameterSpec params)\n+                throws InvalidAlgorithmParameterException {\n+            super(params);\n+        }\n+\n+        AbstractEDDSASignatureMethod(Element dmElem) throws MarshalException {\n+            super(dmElem);\n+        }\n+\n+        \/**\n+         * Returns {@code sig}. No extra formatting is necessary for EDDSA\n+         * See the RFC8032\n+         *\/\n+        @Override\n+        byte[] postSignFormat(Key key, byte[] sig) {\n+            return sig;\n+        }\n+\n+        \/**\n+         * Returns {@code sig}. No extra formatting is necessary for EDDSA\n+         * See the RFC8032\n+         *\/\n+        @Override\n+        byte[] preVerifyFormat(Key key, byte[] sig) {\n+            return sig;\n+        }\n+\n+    }\n+\n@@ -1024,0 +1067,52 @@\n+    static final class EDDSA_ED25519 extends AbstractEDDSASignatureMethod {\n+\n+        EDDSA_ED25519(AlgorithmParameterSpec params)\n+                throws InvalidAlgorithmParameterException {\n+            super(params);\n+        }\n+\n+        EDDSA_ED25519(Element dmElem) throws MarshalException {\n+            super(dmElem);\n+        }\n+\n+        @Override\n+        public String getAlgorithm() {\n+            return ED25519;\n+        }\n+\n+        @Override\n+        String getJCAAlgorithm() {\n+            return \"Ed25519\";\n+        }\n+\n+        @Override\n+        Type getAlgorithmType() {\n+            return Type.EDDSA;\n+        }\n+    }\n+\n+    static final class EDDSA_ED448 extends AbstractEDDSASignatureMethod {\n+        EDDSA_ED448(AlgorithmParameterSpec params)\n+                throws InvalidAlgorithmParameterException {\n+            super(params);\n+        }\n+\n+        EDDSA_ED448(Element dmElem) throws MarshalException {\n+            super(dmElem);\n+        }\n+\n+        @Override\n+        public String getAlgorithm() {\n+            return ED448;\n+        }\n+\n+        @Override\n+        String getJCAAlgorithm() {\n+            return \"Ed448\";\n+        }\n+\n+        @Override\n+        Type getAlgorithmType() {\n+            return Type.EDDSA;\n+        }\n+    }\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMSignatureMethod.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -305,0 +305,4 @@\n+        } else if (algorithm.equals(DOMSignatureMethod.ED25519)) {\n+            return new DOMSignatureMethod.EDDSA_ED25519(params);\n+        } else if (algorithm.equals(DOMSignatureMethod.ED448)) {\n+            return new DOMSignatureMethod.EDDSA_ED448(params);\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMXMLSignatureFactory.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-        \/\/ Apache Santuario XML Security for Java, version 2.3.0\n+        \/\/ Apache Santuario XML Security for Java, version 3.0.2\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/XMLDSigRI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,18 +1,1 @@\n-## Apache Santuario v2.3.0\n-\n-### Apache Santuario Notice\n-<pre>\n-\n-  Apache Santuario - XML Security for Java\n-  Copyright 1999-2021 The Apache Software Foundation\n-\n-  This product includes software developed at\n-  The Apache Software Foundation (http:\/\/www.apache.org\/).\n-\n-  It was originally based on software copyright (c) 2001, Institute for\n-  Data Communications Systems, <http:\/\/www.nue.et-inf.uni-siegen.de\/>.\n-\n-  The development of this software was partly funded by the European\n-  Commission in the <WebSig> project in the ISIS Programme.\n-\n-<\/pre>\n+## Apache Santuario v3.0.2\n@@ -21,1 +4,1 @@\n-<pre>\n+```\n@@ -225,1 +208,20 @@\n-<\/pre>\n+```\n+\n+### Apache Santuario Notice\n+```\n+\n+Apache Santuario - XML Security for Java\n+Copyright 1999-2023 The Apache Software Foundation\n+\n+This product includes software developed at\n+The Apache Software Foundation (http:\/\/www.apache.org\/).\n+\n+It was originally based on software copyright (c) 2001, Institute for\n+Data Communications Systems, <http:\/\/www.nue.et-inf.uni-siegen.de\/>.\n+\n+The development of this software was partly funded by the European\n+Commission in the <WebSig> project in the ISIS Programme.\n+\n+This product contains software that is\n+copyright (c) 2021, Oracle and\/or its affiliates.\n+```\n","filename":"src\/java.xml.crypto\/share\/legal\/santuario.md","additions":22,"deletions":20,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -216,0 +216,1 @@\n+    com\/sun\/org\/apache\/xml\/internal\/security \\\n@@ -223,1 +224,0 @@\n-    com\/sun\/org\/apache\/xml\/internal\/security \\\n","filename":"test\/jdk\/TEST.groups","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.SecurityTools;\n+import jdk.test.lib.Utils;\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.List;\n+\n+import static jdk.test.lib.security.XMLUtils.*;\n+\/**\n+ * @test\n+ * @bug 8305972\n+ * @summary Basic tests using XMLUtils\n+ * @library \/test\/lib\n+ * @modules java.xml.crypto\n+ *\/\n+public class Basic {\n+\n+    public static void main(String[] args) throws Exception {\n+        var x = \"<a><b>c<\/b>x<\/a>\";\n+        var p = Files.write(Path.of(\"x.xml\"), List.of(x));\n+        var b = Path.of(\"\").toUri().toString();\n+        var d = string2doc(x);\n+        var pass = \"changeit\".toCharArray();\n+        for (String alg: List.of(\"DSA\", \"RSA\", \"RSASSA-PSS\", \"EC\", \"EdDSA\", \"Ed25519\", \"Ed448\")) {\n+            SecurityTools.keytool(String.format(\n+                    \"-keystore ks -keyalg %s -storepass changeit -genkeypair -alias %s -dname CN=%s\",\n+                    alg, alg, alg)).shouldHaveExitValue(0);\n+            var ks = KeyStore.getInstance(new File(\"ks\"), pass);\n+            var c = (X509Certificate) ks.getCertificate(alg);\n+            var pr = (PrivateKey) ks.getKey(alg, pass);\n+            var pu = c.getPublicKey();\n+\n+            var s0 = signer(pr); \/\/ No KeyInfo\n+            var s1 = signer(pr, c); \/\/ KeyInfo is X509Data\n+            var s2 = signer(ks, alg, pass); \/\/ KeyInfo is KeyName\n+            var v1 = validator(); \/\/ knows nothing\n+            var v2 = validator(ks); \/\/ knows KeyName\n+\n+            Utils.runAndCheckException(() -> v1.validate(s0.sign(d)), IllegalArgumentException.class); \/\/ need PublicKey\n+            s0.sign(string2doc(x));\n+            Asserts.assertTrue(v1.validate(s0.sign(d), pu)); \/\/ need PublicKey\n+            Asserts.assertTrue(v1.validate(s1.sign(d))); \/\/ can read KeyInfo\n+            Asserts.assertTrue(v2.validate(s2.sign(d))); \/\/ can read KeyInfo\n+            Asserts.assertTrue(v2.secureValidation(false).validate(s2.sign(p.toUri()))); \/\/ can read KeyInfo\n+            Asserts.assertTrue(v2.secureValidation(false).baseURI(b).validate(\n+                    s2.sign(p.toAbsolutePath().getParent().toUri(), p.getFileName().toUri()))); \/\/ can read KeyInfo\n+\n+            Asserts.assertTrue(v1.validate(s0.sign(\"text\"), pu)); \/\/ plain text\n+            Asserts.assertTrue(v1.validate(s0.sign(\"binary\".getBytes()), pu)); \/\/ raw data\n+            Asserts.assertTrue(v1.validate(s0.signEnveloping(d, \"x\", \"#x\"), pu));\n+            Asserts.assertTrue(v1.validate(s0.signEnveloping(d, \"x\", \"#xpointer(id('x'))\"), pu));\n+\n+            \/\/ No KeyValue defined for RSASSA-PSS or EdDSA yet\n+            if (!alg.startsWith(\"Ed\") && !alg.equals(\"RSASSA-PSS\")) {\n+                var ss = signer(pr, pu); \/\/ KeyInfo is PublicKey\n+                Asserts.assertTrue(v1.validate(ss.sign(d))); \/\/ can read KeyInfo\n+                Asserts.assertTrue(v1.validate(ss.sign(\"text\"))); \/\/ plain text\n+                Asserts.assertTrue(v1.validate(ss.sign(\"binary\".getBytes()))); \/\/ raw data\n+                Asserts.assertTrue(v1.validate(ss.signEnveloping(d, \"x\", \"#x\")));\n+                Asserts.assertTrue(v1.validate(ss.signEnveloping(d, \"x\", \"#xpointer(id('x'))\")));\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/javax\/xml\/crypto\/dsig\/Basic.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n- *      8046724 8079693 8177334 8205507 8210736 8217878 8241306\n+ *      8046724 8079693 8177334 8205507 8210736 8217878 8241306 8305972\n@@ -59,12 +59,2 @@\n-import java.security.spec.KeySpec;\n-import java.security.spec.DSAPrivateKeySpec;\n-import java.security.spec.DSAPublicKeySpec;\n-import java.security.spec.ECField;\n-import java.security.spec.ECFieldFp;\n-import java.security.spec.ECParameterSpec;\n-import java.security.spec.ECPoint;\n-import java.security.spec.ECPrivateKeySpec;\n-import java.security.spec.ECPublicKeySpec;\n-import java.security.spec.EllipticCurve;\n-import java.security.spec.RSAPrivateKeySpec;\n-import java.security.spec.RSAPublicKeySpec;\n+import java.security.cert.X509Certificate;\n+import java.security.spec.*;\n@@ -113,1 +103,2 @@\n-            rsaSha1mgf1, rsaSha224mgf1, rsaSha256mgf1, rsaSha384mgf1, rsaSha512mgf1, rsaShaPSS;\n+            rsaSha1mgf1, rsaSha224mgf1, rsaSha256mgf1, rsaSha384mgf1, rsaSha512mgf1,\n+            rsaShaPSS, ed25519, ed448;\n@@ -117,1 +108,1 @@\n-                           p256ki, p384ki, p521ki;\n+                           p256ki, p384ki, p521ki, ed25519ki, ed448ki;\n@@ -119,0 +110,1 @@\n+    private static KeySelector x5ks = new KeySelectors.RawX509KeySelector();\n@@ -220,1 +212,2 @@\n-            SignatureMethod.RSA_PSS);\n+            SignatureMethod.RSA_PSS,\n+            SignatureMethod.ED25519);\n@@ -254,1 +247,1 @@\n-        if (allSignatureMethods.length != 23\n+        if (allSignatureMethods.length != 25\n@@ -315,0 +308,2 @@\n+        test_create_signature_enveloping_ed25519();\n+        test_create_signature_enveloping_ed448();\n@@ -362,2 +357,4 @@\n-                                    test_create_detached_signature(c, s, d, t, k,\n-                                            Content.Xml, server.getPort(), false, null);\n+                                    if (!s.contains(\"#eddsa\") || k != KeyInfoType.KeyValue) {\n+                                        test_create_detached_signature(c, s, d, t, k,\n+                                                Content.Xml, server.getPort(), false, null);\n+                                    }\n@@ -373,2 +370,4 @@\n-                                test_create_detached_signature(c, s, d, null, k,\n-                                        Content.Text, server.getPort(), false, null);\n+                                if (!s.contains(\"#eddsa\") || k != KeyInfoType.KeyValue) {\n+                                    test_create_detached_signature(c, s, d, null, k,\n+                                            Content.Text, server.getPort(), false, null);\n+                                }\n@@ -385,3 +384,5 @@\n-                                    test_create_detached_signature(c, s, d, t, k,\n-                                            Content.Base64, server.getPort(),\n-                                            false, null);\n+                                    if (!s.contains(\"#eddsa\") || k != KeyInfoType.KeyValue) {\n+                                        test_create_detached_signature(c, s, d, t, k,\n+                                                Content.Base64, server.getPort(),\n+                                                false, null);\n+                                    }\n@@ -528,0 +529,5 @@\n+        ed25519ki = kifac.newKeyInfo(Collections.singletonList\n+            (kifac.newX509Data(List.of(getEd25519Certificate()))));\n+        ed448ki = kifac.newKeyInfo(Collections.singletonList\n+                (kifac.newX509Data(List.of(getEd448Certificate()))));\n+\n@@ -547,0 +553,3 @@\n+        ed25519 = fac.newSignatureMethod(SignatureMethod.ED25519, null);\n+        ed448 = fac.newSignatureMethod(SignatureMethod.ED448, null);\n+\n@@ -858,0 +867,14 @@\n+    static void test_create_signature_enveloping_ed25519() throws Exception {\n+        System.out.println(\"* Generating signature-enveloping-ed25519.xml\");\n+        test_create_signature_enveloping(sha1, ed25519, ed25519ki,\n+                getEd25519PrivateKey(), x5ks, false, true);\n+        System.out.println();\n+    }\n+\n+    static void test_create_signature_enveloping_ed448() throws Exception {\n+        System.out.println(\"* Generating signature-enveloping-ed448.xml\");\n+        test_create_signature_enveloping(sha1, ed448, ed448ki,\n+                getEd448PrivateKey(), x5ks, false, true);\n+        System.out.println();\n+    }\n+\n@@ -1960,0 +1983,2 @@\n+                    } else if (sm.contains(\"#eddsa-\")) {\n+                        kpg = KeyPairGenerator.getInstance(sm.substring(sm.lastIndexOf('-') + 1));\n@@ -2088,0 +2113,14 @@\n+    private static final String ED25519_CERT =\n+            \"3081d730818aa003020102020822bc4997b1893265300506032b657030123110300e0603550403130745643235353139301e170d3233303431333033303732365a170d3433303430383033303\" +\n+            \"732365a30123110300e0603550403130745643235353139302a300506032b657003210012ecd7383ac90c30035dc531285bdb897faafddfc6969271c2ebd9a82b6078e5300506032b65700341\" +\n+            \"00a3cb7c03bbb3e9fa92eaf3f9a6f2608460d472c6a6ce3bebf0f57f45612e87ebdc6aa6d7527ae9e86c8e10bcccf98963f9b082c0bb44adb240c5fce9bb68b301\";\n+    private static final String ED25519_KEY =\n+            \"b59e57e352fa03b3a643946ae60b7f1e276f9ab41f25accaa63b660ba36168b2\";\n+    private static final String ED448_CERT =\n+            \"3082011f3081a0a003020102020900ceaefd75473d52b2300506032b65713010310e300c060355040313054564343438301e170d3233303431333033303735345a170d3433303430383033303\" +\n+            \"735345a3010310e300c0603550403130545643434383043300506032b6571033a00d605be958f21faf6a1181fa96ebe8580cca3cae9b48dfad5145ee999d9df4ef77c355d33ae8b21e9a3541f\" +\n+            \"b985ae366b9678db1a3fd1fd5c00300506032b65710373000b4dc8de20b261f5ca7cf41777725a2ec6cd107d6b75cd6ad02c00af8096ecf97c7445596aabd70381ce087d2b3b280ca4181566b\" +\n+            \"9230fd6801e22e53f1514989bc5b06cfb5f7cac222ea9a37a0771a3f7cfcbfd1ba9546bbe333d37ee81c3a53d86247d377225114e1e81123f947a391800\";\n+    private static final String ED448_KEY =\n+            \"50b72f081f7f2f3383c4b03975cf49a76ba8b17dec51eaea3cd267b6989b81786e8dd8af4df305eaad60bdd24345b8490548c371d62e926f80\";\n+\n@@ -2161,0 +2200,10 @@\n+    private static X509Certificate getEd25519Certificate() throws Exception {\n+        return (X509Certificate) CertificateFactory.getInstance(\"X.509\")\n+                .generateCertificate(new ByteArrayInputStream(HexFormat.of().parseHex(ED25519_CERT)));\n+    }\n+\n+    private static X509Certificate getEd448Certificate() throws Exception {\n+        return (X509Certificate) CertificateFactory.getInstance(\"X.509\")\n+                .generateCertificate(new ByteArrayInputStream(HexFormat.of().parseHex(ED448_CERT)));\n+    }\n+\n@@ -2214,0 +2263,10 @@\n+    private static PrivateKey getEd25519PrivateKey() throws Exception {\n+        return KeyFactory.getInstance(\"Ed25519\").generatePrivate(new EdECPrivateKeySpec(\n+                NamedParameterSpec.ED25519, HexFormat.of().parseHex(ED25519_KEY)));\n+    }\n+\n+    private static PrivateKey getEd448PrivateKey() throws Exception {\n+        return KeyFactory.getInstance(\"Ed448\").generatePrivate(new EdECPrivateKeySpec(\n+                NamedParameterSpec.ED448, HexFormat.of().parseHex(ED448_KEY)));\n+    }\n+\n","filename":"test\/jdk\/javax\/xml\/crypto\/dsig\/GenerationTests.java","additions":83,"deletions":24,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -0,0 +1,240 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8305972\n+ * @summary Demonstrate here() support for validating XML Signatures\n+ * @modules java.base\/sun.security.util\n+ *          java.base\/sun.security.x509\n+ *          java.xml.crypto\/org.jcp.xml.dsig.internal.dom\n+ * @library \/test\/lib\n+ * @compile -XDignore.symbol.file KeySelectors.java SignatureValidator.java\n+ *     X509KeySelector.java ValidationTests.java\n+ * @run main\/othervm HereFunction default true\n+ * @run main\/othervm HereFunction true true\n+ * @run main\/othervm HereFunction false false\n+ *\/\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.security.*;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.xml.crypto.Data;\n+import javax.xml.crypto.KeySelector;\n+import javax.xml.crypto.OctetStreamData;\n+import javax.xml.crypto.URIDereferencer;\n+import javax.xml.crypto.URIReference;\n+import javax.xml.crypto.URIReferenceException;\n+import javax.xml.crypto.XMLCryptoContext;\n+import javax.xml.crypto.dsig.*;\n+import javax.xml.crypto.dsig.dom.DOMSignContext;\n+import javax.xml.crypto.dsig.dom.DOMValidateContext;\n+import javax.xml.crypto.dsig.keyinfo.KeyInfo;\n+import javax.xml.crypto.dsig.keyinfo.KeyInfoFactory;\n+import javax.xml.crypto.dsig.spec.C14NMethodParameterSpec;\n+import javax.xml.crypto.dsig.spec.XPathFilterParameterSpec;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.security.SecurityUtils;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.NodeList;\n+\n+public class HereFunction {\n+\n+    private final static String DIR = System.getProperty(\"test.src\", \".\");\n+    private final static String DATA_DIR =\n+            DIR + System.getProperty(\"file.separator\") + \"data\";\n+    private final static String KEYSTORE_VERIFY =\n+            DATA_DIR + System.getProperty(\"file.separator\") + \"certs\" +\n+                    System.getProperty(\"file.separator\") + \"xmldsig.jks\";\n+    private final static String KEYSTORE_SIGN =\n+            DATA_DIR + System.getProperty(\"file.separator\") + \"certs\" +\n+                    System.getProperty(\"file.separator\") + \"test.jks\";\n+    private final static String STYLESHEET =\n+            \"http:\/\/www.w3.org\/TR\/xml-stylesheet\";\n+    private final static String STYLESHEET_B64 =\n+            \"http:\/\/www.w3.org\/Signature\/2002\/04\/xml-stylesheet.b64\";\n+    private final static char[] PASS = \"changeit\".toCharArray();\n+\n+    public static void main(String args[]) throws Throwable {\n+        if (!args[0].equals(\"default\")) {\n+            Security.setProperty(\"jdk.xml.dsig.hereFunctionSupported\", args[0]);\n+        }\n+        \/\/ Re-enable sha1 algs\n+        SecurityUtils.removeAlgsFromDSigPolicy(\"sha1\");\n+\n+        boolean expected = Boolean.parseBoolean(args[1]);\n+\n+        sign(expected);\n+\n+        \/\/ Validating an old signature signed by JDK < 21\n+        validate(expected);\n+    }\n+\n+    static void validate(boolean expected) throws Exception {\n+        SignatureValidator validator = new SignatureValidator(new File(DATA_DIR));\n+\n+        KeyStore keystore = KeyStore.getInstance(new File(KEYSTORE_VERIFY), PASS);\n+        KeySelector ks = new X509KeySelector(keystore, false);\n+\n+        if (expected) {\n+            Asserts.assertTrue(validator.validate(\n+                    \"signature.xml\", ks, new HttpURIDereferencer(), false));\n+        } else {\n+            Utils.runAndCheckException(() -> validator.validate(\n+                    \"signature.xml\", ks, new HttpURIDereferencer(), false),\n+                    XMLSignatureException.class);\n+        }\n+    }\n+\n+    static void sign(boolean expected) throws Exception {\n+        XMLSignatureFactory fac = XMLSignatureFactory.getInstance();\n+        DigestMethod sha1 = fac.newDigestMethod(DigestMethod.SHA1, null);\n+        CanonicalizationMethod withoutComments = fac.newCanonicalizationMethod\n+                (CanonicalizationMethod.INCLUSIVE, (C14NMethodParameterSpec)null);\n+        SignatureMethod dsaSha1 = fac.newSignatureMethod(SignatureMethod.DSA_SHA1, null);\n+        KeyInfoFactory kifac = fac.getKeyInfoFactory();\n+        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n+        dbf.setNamespaceAware(true);\n+\n+        String ENVELOPE =\n+                DATA_DIR + System.getProperty(\"file.separator\") + \"envelope.xml\";\n+\n+        var ks = KeyStore.getInstance(new File(KEYSTORE_SIGN), PASS);\n+        var signingKey = ks.getKey(\"user\", PASS);\n+        var signingCert = ks.getCertificate(\"user\");\n+\n+        \/\/ create references\n+        List<Reference> refs = new ArrayList<>();\n+\n+        \/\/ Reference 1\n+        refs.add(fac.newReference(STYLESHEET, sha1));\n+\n+        \/\/ Reference 2\n+        String expr = \"\\n\"\n+                + \" ancestor-or-self::dsig:SignedInfo                  \" + \"\\n\"\n+                + \"  and                                               \" + \"\\n\"\n+                + \" count(ancestor-or-self::dsig:Reference |           \" + \"\\n\"\n+                + \"      here()\/ancestor::dsig:Reference[1]) >         \" + \"\\n\"\n+                + \" count(ancestor-or-self::dsig:Reference)            \" + \"\\n\"\n+                + \"  or                                                \" + \"\\n\"\n+                + \" count(ancestor-or-self::node() |                   \" + \"\\n\"\n+                + \"      id('notaries')) =                             \" + \"\\n\"\n+                + \" count(ancestor-or-self::node())                    \" + \"\\n\";\n+\n+        XPathFilterParameterSpec xfp = new XPathFilterParameterSpec(expr,\n+                Collections.singletonMap(\"dsig\", XMLSignature.XMLNS));\n+        refs.add(fac.newReference(\"\", sha1, Collections.singletonList\n+                        (fac.newTransform(Transform.XPATH, xfp)),\n+                XMLObject.TYPE, null));\n+\n+        \/\/ create SignedInfo\n+        SignedInfo si = fac.newSignedInfo(withoutComments, dsaSha1, refs);\n+\n+        \/\/ create keyinfo\n+        KeyInfo ki = kifac.newKeyInfo(List.of(\n+                kifac.newX509Data(List.of(signingCert))), null);\n+\n+        \/\/ create XMLSignature\n+        XMLSignature sig = fac.newXMLSignature(si, ki, null, \"signature\", null);\n+\n+        dbf.setValidating(false);\n+        Document envDoc = dbf.newDocumentBuilder()\n+                .parse(new FileInputStream(ENVELOPE));\n+        Element ys = (Element)\n+                envDoc.getElementsByTagName(\"YoursSincerely\").item(0);\n+\n+        DOMSignContext dsc = new DOMSignContext(signingKey, ys);\n+        dsc.setURIDereferencer(new HttpURIDereferencer());\n+\n+        if (expected) {\n+            sig.sign(dsc);\n+        } else {\n+            Utils.runAndCheckException(\n+                    () -> sig.sign(dsc), XMLSignatureException.class);\n+            return; \/\/ Signing fails, no need to validate\n+        }\n+\n+\/\/      StringWriter sw = new StringWriter();\n+\/\/        dumpDocument(envDoc, sw);\n+\n+        NodeList nl =\n+                envDoc.getElementsByTagNameNS(XMLSignature.XMLNS, \"Signature\");\n+        if (nl.getLength() == 0) {\n+            throw new Exception(\"Couldn't find signature Element\");\n+        }\n+        Element sigElement = (Element) nl.item(0);\n+\n+        DOMValidateContext dvc = new DOMValidateContext\n+                (new X509KeySelector(ks), sigElement);\n+        dvc.setURIDereferencer(new HttpURIDereferencer());\n+        File f = new File(\n+                System.getProperty(\"dir.test.vector.baltimore\") +\n+                        System.getProperty(\"file.separator\") +\n+                        \"merlin-xmldsig-twenty-three\" +\n+                        System.getProperty(\"file.separator\"));\n+        dvc.setBaseURI(f.toURI().toString());\n+\n+        XMLSignature sig2 = fac.unmarshalXMLSignature(dvc);\n+\n+        if (sig.equals(sig2) == false) {\n+            throw new Exception\n+                    (\"Unmarshalled signature is not equal to generated signature\");\n+        }\n+        if (sig2.validate(dvc) == false) {\n+            throw new Exception(\"Validation of generated signature failed\");\n+        }\n+    }\n+\n+    \/**\n+     * This URIDereferencer returns locally cached copies of http content to\n+     * avoid test failures due to network glitches, etc.\n+     *\/\n+    private static class HttpURIDereferencer implements URIDereferencer {\n+        private final URIDereferencer defaultUd;\n+\n+        HttpURIDereferencer() {\n+            defaultUd = XMLSignatureFactory.getInstance().getURIDereferencer();\n+        }\n+\n+        public Data dereference(final URIReference ref, XMLCryptoContext ctx)\n+                throws URIReferenceException {\n+            String uri = ref.getURI();\n+            if (uri.equals(STYLESHEET) || uri.equals(STYLESHEET_B64)) {\n+                try {\n+                    FileInputStream fis = new FileInputStream(new File\n+                            (DATA_DIR, uri.substring(uri.lastIndexOf('\/'))));\n+                    return new OctetStreamData(fis,ref.getURI(),ref.getType());\n+                } catch (Exception e) { throw new URIReferenceException(e); }\n+            }\n+\n+            \/\/ fallback on builtin deref\n+            return defaultUd.dereference(ref, ctx);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/xml\/crypto\/dsig\/HereFunction.java","additions":240,"deletions":0,"binary":false,"changes":240,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import jdk.test.lib.Asserts;\n@@ -52,1 +51,0 @@\n-import java.io.File;\n@@ -56,2 +54,0 @@\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n@@ -60,0 +56,1 @@\n+import java.security.interfaces.EdECPrivateKey;\n@@ -61,0 +58,1 @@\n+import java.security.spec.NamedParameterSpec;\n@@ -71,31 +69,0 @@\n-    \/\/\/\/\/\/\/\/\/\/\/\/ MAIN as TEST \/\/\/\/\/\/\/\/\/\/\/\/\n-    public static void main(String[] args) throws Exception {\n-        var x = \"<a><b>c<\/b>x<\/a>\";\n-        var p = Files.write(Path.of(\"x.xml\"), List.of(x));\n-        var b = Path.of(\"\").toUri().toString();\n-        var d = string2doc(x);\n-        \/\/ keytool -keystore ks -keyalg ec -storepass changeit -genkeypair -alias a -dname CN=a\n-        var pass = \"changeit\".toCharArray();\n-        var ks = KeyStore.getInstance(new File(\"ks\"), pass);\n-        var c = (X509Certificate) ks.getCertificate(\"a\");\n-        var pr = (PrivateKey) ks.getKey(\"a\", pass);\n-        var pu = c.getPublicKey();\n-        var s0 = signer(pr); \/\/ No KeyInfo\n-        var s1 = signer(pr, pu); \/\/ KeyInfo is PublicKey\n-        var s2 = signer(pr, c); \/\/ KeyInfo is X509Data\n-        var s3 = signer(ks, \"a\", pass); \/\/ KeyInfo is KeyName\n-        var v1 = validator(); \/\/ knows nothing\n-        var v2 = validator(ks); \/\/ knows KeyName\n-        Asserts.assertTrue(v1.validate(s0.sign(d), pu)); \/\/ need PublicKey\n-        Asserts.assertTrue(v1.validate(s1.sign(d))); \/\/ can read KeyInfo\n-        Asserts.assertTrue(v1.validate(s2.sign(d))); \/\/ can read KeyInfo\n-        Asserts.assertTrue(v2.validate(s3.sign(d))); \/\/ can read KeyInfo\n-        Asserts.assertTrue(v2.secureValidation(false).validate(s3.sign(p.toUri()))); \/\/ can read KeyInfo\n-        Asserts.assertTrue(v2.secureValidation(false).baseURI(b).validate(\n-                s3.sign(p.toAbsolutePath().getParent().toUri(), p.getFileName().toUri()))); \/\/ can read KeyInfo\n-        Asserts.assertTrue(v1.validate(s1.sign(\"text\"))); \/\/ plain text\n-        Asserts.assertTrue(v1.validate(s1.sign(\"binary\".getBytes()))); \/\/ raw data\n-        Asserts.assertTrue(v1.validate(s1.signEnveloping(d, \"x\", \"#x\")));\n-        Asserts.assertTrue(v1.validate(s1.signEnveloping(d, \"x\", \"#xpointer(id('x'))\")));\n-    }\n-\n@@ -223,1 +190,2 @@\n-        PrivateKey privateKey;  \/\/ signer key, never null\n+        final PrivateKey privateKey;  \/\/ signer key, never null\n+\n@@ -228,27 +196,8 @@\n-        SignatureMethod sm;     \/\/ default determined by privateKey\n-        DigestMethod dm;        \/\/ default SHA-256\n-        CanonicalizationMethod cm;  \/\/ default EXCLUSIVE\n-        Transform tr;           \/\/ default ENVELOPED\n-\n-        public Signer(PrivateKey privateKey) throws Exception {\n-            this.privateKey = privateKey;\n-            dm(DigestMethod.SHA256);\n-            tr(Transform.ENVELOPED);\n-            cm(CanonicalizationMethod.EXCLUSIVE);\n-            String alg = privateKey.getAlgorithm();\n-            if (alg.equals(\"RSASSA-PSS\")) {\n-                PSSParameterSpec pspec\n-                        = (PSSParameterSpec) ((RSAKey) privateKey).getParams();\n-                if (pspec != null) {\n-                    sm(SignatureMethod.RSA_PSS, new RSAPSSParameterSpec(pspec));\n-                } else {\n-                    sm(SignatureMethod.RSA_PSS);\n-                }\n-            } else {\n-                sm(switch (privateKey.getAlgorithm()) {\n-                    case \"RSA\" -> SignatureMethod.RSA_SHA256;\n-                    case \"DSA\" -> SignatureMethod.DSA_SHA256;\n-                    case \"EC\" -> SignatureMethod.ECDSA_SHA256;\n-                    default -> throw new InvalidKeyException();\n-                });\n-            }\n+        String sm = null;       \/\/ default determined by privateKey\n+        SignatureMethodParameterSpec smSpec = null;\n+        String dm = DigestMethod.SHA256;\n+        String cm = CanonicalizationMethod.EXCLUSIVE;\n+        String tr = Transform.ENVELOPED;\n+\n+        public Signer(PrivateKey privateKey) {\n+            this.privateKey = Objects.requireNonNull(privateKey);\n@@ -276,13 +225,2 @@\n-        public Signer tr(String transform) throws Exception {\n-            TransformParameterSpec params = null;\n-            switch (transform) {\n-                case Transform.XPATH:\n-                    params = new XPathFilterParameterSpec(\"\/\/.\");\n-                    break;\n-                case Transform.XPATH2:\n-                    params = new XPathFilter2ParameterSpec(\n-                            Collections.singletonList(new XPathType(\"\/\/.\",\n-                                    XPathType.Filter.INTERSECT)));\n-                    break;\n-            }\n-            tr = FAC.newTransform(transform, params);\n+        public Signer tr(String transform) {\n+            tr = Objects.requireNonNull(transform);\n@@ -292,2 +230,2 @@\n-        public Signer sm(String method) throws Exception {\n-            sm = FAC.newSignatureMethod(method, null);\n+        public Signer dm(String method) {\n+            dm = Objects.requireNonNull(method);\n@@ -297,2 +235,2 @@\n-        public Signer dm(String method) throws Exception {\n-            dm = FAC.newDigestMethod(method, null);\n+        public Signer cm(String method) {\n+            cm = Objects.requireNonNull(method);\n@@ -302,2 +240,3 @@\n-        public Signer cm(String method) throws Exception {\n-            cm = FAC.newCanonicalizationMethod(method, (C14NMethodParameterSpec) null);\n+        public Signer sm(String method, SignatureMethodParameterSpec spec) {\n+            sm = method;\n+            smSpec = spec;\n@@ -307,10 +246,2 @@\n-        public Signer sm(String method, SignatureMethodParameterSpec spec)\n-                throws Exception {\n-            sm = FAC.newSignatureMethod(method, spec);\n-            return this;\n-        }\n-\n-        public Signer dm(String method, DigestMethodParameterSpec spec)\n-                throws Exception {\n-            dm = FAC.newDigestMethod(method, spec);\n-            return this;\n+        public Signer sm(String method) throws Exception {\n+            return sm(method, null);\n@@ -356,1 +287,1 @@\n-                    buildSignedInfo(FAC.newReference(ref, dm)),\n+                    buildSignedInfo(FAC.newReference(ref, FAC.newDigestMethod(dm, null))),\n@@ -371,1 +302,1 @@\n-                    buildSignedInfo(FAC.newReference(\"#object\", dm, List.of\n+                    buildSignedInfo(FAC.newReference(\"#object\", FAC.newDigestMethod(dm, null), List.of\n@@ -389,1 +320,2 @@\n-                    buildSignedInfo(FAC.newReference(\"#object\", dm)),\n+                    buildSignedInfo(\n+                            FAC.newReference(\"#object\", FAC.newDigestMethod(dm, null))),\n@@ -391,1 +323,2 @@\n-                    List.of(FAC.newXMLObject(List.of(new DOMStructure(newDocument.createTextNode(str))),\n+                    List.of(FAC.newXMLObject(\n+                            List.of(new DOMStructure(newDocument.createTextNode(str))),\n@@ -400,5 +333,2 @@\n-        private SignedInfo buildSignedInfo(String ref) {\n-            return FAC.newSignedInfo(\n-                    cm,\n-                    sm,\n-                    List.of(FAC.newReference(\n+        private SignedInfo buildSignedInfo(String ref) throws Exception {\n+            return buildSignedInfo(FAC.newReference(\n@@ -406,3 +336,10 @@\n-                            dm,\n-                            List.of(tr),\n-                            null, null)));\n+                            FAC.newDigestMethod(dm, null),\n+                            List.of(FAC.newTransform(tr, switch (tr) {\n+                                case Transform.XPATH ->\n+                                    new XPathFilterParameterSpec(\"\/\/.\");\n+                                case Transform.XPATH2 -> new XPathFilter2ParameterSpec(\n+                                            Collections.singletonList(new XPathType(\"\/\/.\",\n+                                                    XPathType.Filter.INTERSECT)));\n+                                default -> null;\n+                            })),\n+                            null, null));\n@@ -412,1 +349,36 @@\n-        private SignedInfo buildSignedInfo(Reference ref) {\n+        private SignedInfo buildSignedInfo(Reference ref) throws Exception {\n+            SignatureMethod signatureMethod;\n+            if (sm == null) {\n+                String alg = privateKey.getAlgorithm().toUpperCase(Locale.ROOT);\n+                if (alg.equals(\"RSASSA-PSS\")) {\n+                    PSSParameterSpec pspec\n+                            = (PSSParameterSpec) ((RSAKey) privateKey).getParams();\n+                    if (pspec != null) {\n+                        signatureMethod = FAC.newSignatureMethod(\n+                                SignatureMethod.RSA_PSS, new RSAPSSParameterSpec(pspec));\n+                    } else {\n+                        signatureMethod = FAC.newSignatureMethod(SignatureMethod.RSA_PSS, null);\n+                    }\n+                } else {\n+                    signatureMethod = FAC.newSignatureMethod(switch (alg) {\n+                        case \"RSA\" -> SignatureMethod.RSA_SHA256;\n+                        case \"DSA\" -> SignatureMethod.DSA_SHA256;\n+                        case \"EC\" -> SignatureMethod.ECDSA_SHA256;\n+                        case \"ED25519\" -> SignatureMethod.ED25519;\n+                        case \"ED448\" -> SignatureMethod.ED448;\n+                        case \"EDDSA\" -> {\n+                            if (privateKey instanceof EdECPrivateKey edsk) {\n+                                yield edsk.getParams().getName()\n+                                        .equals(NamedParameterSpec.ED25519.getName())\n+                                        ? SignatureMethod.ED25519\n+                                        : SignatureMethod.ED448;\n+                            } else {\n+                                throw new InvalidKeyException();\n+                            }\n+                        }\n+                        default -> throw new InvalidKeyException();\n+                    }, null);\n+                }\n+            } else {\n+                signatureMethod = FAC.newSignatureMethod(sm, smSpec);\n+            }\n@@ -414,2 +386,2 @@\n-                    cm,\n-                    sm,\n+                    FAC.newCanonicalizationMethod(cm, (C14NMethodParameterSpec) null),\n+                    signatureMethod,\n@@ -521,1 +493,3 @@\n-                Objects.requireNonNull(keyInfo, \"Null KeyInfo object!\");\n+                if (keyInfo == null) {\n+                    throw new IllegalArgumentException(\"Null KeyInfo object!\");\n+                }\n","filename":"test\/lib\/jdk\/test\/lib\/security\/XMLUtils.java","additions":83,"deletions":109,"binary":false,"changes":192,"status":"modified"}]}