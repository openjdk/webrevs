{"files":[{"patch":"@@ -645,0 +645,2 @@\n+                \/\/ A REFUSED_STREAM error code implies that the stream wasn't processed by the\n+                \/\/ peer and the client is free to retry the request afresh.\n@@ -646,3 +648,7 @@\n-                    \/\/ A REFUSED_STREAM error code implies that the stream wasn't processed by the\n-                    \/\/ peer and the client is free to retry the request afresh.\n-                    \/\/ Here we arrange for the request to be retried.\n+                    \/\/ Here we arrange for the request to be retried. Note that we don't call\n+                    \/\/ closeAsUnprocessed() method here because the \"closed\" state is already set\n+                    \/\/ to true a few lines above and calling close() from within\n+                    \/\/ closeAsUnprocessed() will end up being a no-op. We instead do the additional\n+                    \/\/ bookkeeping here.\n+                    markUnprocessedByPeer();\n+                    errorRef.compareAndSet(null, new IOException(\"request not processed by peer\"));\n@@ -652,11 +658,10 @@\n-                    closeAsUnprocessed();\n-                    return;\n-                }\n-                final String reason = ErrorFrame.stringForCode(error);\n-                final IOException ioe = new IOException(\"Received RST_STREAM: \" + reason);\n-                if (debug.on()) {\n-                    debug.log(streamid + \" received RST_STREAM with code: \" + reason);\n-                }\n-                if (errorRef.compareAndSet(null, ioe)) {\n-                    if (subscriber != null) {\n-                        subscriber.onError(ioe);\n+                } else {\n+                    final String reason = ErrorFrame.stringForCode(error);\n+                    final IOException failureCause = new IOException(\"Received RST_STREAM: \" + reason);\n+                    if (debug.on()) {\n+                        debug.log(streamid + \" received RST_STREAM with code: \" + reason);\n+                    }\n+                    if (errorRef.compareAndSet(null, failureCause)) {\n+                        if (subscriber != null) {\n+                            subscriber.onError(failureCause);\n+                        }\n@@ -1694,5 +1699,14 @@\n-        \/\/ We arrange for the request to be retried on a new connection as allowed by the RFC-9113\n-        markUnprocessedByPeer();\n-        this.errorRef.compareAndSet(null, new IOException(\"request not processed by peer\"));\n-        if (debug.on()) {\n-            debug.log(\"closing \" + this.request + \" as unprocessed by peer\");\n+        try {\n+            \/\/ We arrange for the request to be retried on a new connection as allowed by the RFC-9113\n+            markUnprocessedByPeer();\n+            this.errorRef.compareAndSet(null, new IOException(\"request not processed by peer\"));\n+            if (debug.on()) {\n+                debug.log(\"closing \" + this.request + \" as unprocessed by peer\");\n+            }\n+            \/\/ close the exchange and complete the response CF exceptionally\n+            close();\n+            completeResponseExceptionally(this.errorRef.get());\n+        } finally {\n+            \/\/ decrementStreamsCount isn't really needed but we do it to make sure\n+            \/\/ the log messages, where these counts\/states get reported, show the accurate state.\n+            connection.decrementStreamsCount(streamid);\n@@ -1700,3 +1714,0 @@\n-        \/\/ close the exchange and complete the response CF exceptionally\n-        close();\n-        completeResponseExceptionally(this.errorRef.get());\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":33,"deletions":22,"binary":false,"changes":55,"status":"modified"}]}