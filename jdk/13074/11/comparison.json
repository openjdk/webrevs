{"files":[{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n@@ -33,3 +31,6 @@\n- * <p>{@code MatchException} may be thrown when an exhaustive pattern matching language construct\n- * (such as a switch expression) encounters a value that does not match any of the provided\n- * patterns at runtime. This can arise from a number of cases:\n+ * <p>{@code MatchException} may be thrown when an exhaustive pattern matching\n+ * language construct (such as a {@code switch} expression) encounters a value\n+ * that does not match any of the specified patterns at run time, even though\n+ * the construct has been deemed exhaustive. This is intentional and can arise\n+ * from a number of cases:\n+ *\n@@ -37,13 +38,7 @@\n- *    <li>Separate compilation anomalies, where a sealed interface has a different set of permitted\n- *        subtypes at runtime than it had at compilation time, an enum has a different set of\n- *        constants at runtime than it had at compilation time, or the type hierarchy has changed\n- *        in incompatible ways between compile time and run time.<\/li>\n- *    <li>{@code null} values and nested patterns using sealed types. If an interface or abstract\n- *        class {@code C} is sealed to permit {@code A} and {@code B}, then the set of record\n- *        patterns {@code R(A a)} and {@code R(B b)} are exhaustive on a record {@code R} whose\n- *        sole component is of type {@code C}, but neither of these patterns will match\n- *        {@code new R(null)}.<\/li>\n- *    <li>Null targets and nested record patterns. Given a record type {@code R} whose sole\n- *        component is {@code S}, which in turn is a record whose sole component is {@code String},\n- *        then the nested record pattern {@code R(S(String s))} will not match {@code new R(null)}.<\/li>\n- * <\/ul>\n+ *     <li>Separate compilation anomalies, where parts of the type hierarchy that\n+ *         the patterns reference have been changed, but the pattern matching\n+ *         construct has not been recompiled. For example, if a sealed interface\n+ *         has a different set of permitted subtypes at run time than it had at\n+ *         compile time, or if an enum class has a different set of enum constants\n+ *         at runtime than it had at compile time, or if the type hierarchy has\n+ *         been changed in some incompatible way between compile time and run time.<\/li>\n@@ -51,3 +46,16 @@\n- * <p>Match failures arising from unexpected inputs will generally throw {@code MatchException} only\n- * after all patterns have been tried; even if {@code R(S(String s))} does not match\n- * {@code new R(null)}, a later pattern (such as {@code R r}) may still match the target.\n+ *     <li>{@code null} values and nested patterns involving sealed classes. If,\n+ *         for example, an interface {@code I} is {@code sealed} with two permitted\n+ *         subclasses {@code A} and {@code B}, and a record class {@code R} has a\n+ *         single component of type {@code I}, then the two record patterns {@code\n+ *         R(A a)} and {@code R(B b)} together are considered to be exhaustive for\n+ *         the type {@code R}, but neither of these patterns will match against the\n+ *         result of {@code new R(null)}.<\/li>\n+ *\n+ *     <li>{@code null} values and nested record patterns. Given a record class\n+ *         {@code S} with a single component of type {@code T}, where {@code T} is\n+ *         another record class with a single component of type {@code String},\n+ *         then the nested record pattern {@code R(S(var s))} is considered\n+ *         exhaustive for the type {@code R} but it does not match against the\n+ *         result of {@code new R(null)} (whereas it does match against the result\n+ *         of {@code new R(new S(null))} does).<\/li>\n+ * <\/ul>\n@@ -55,7 +63,9 @@\n- * <p>MatchException may also be thrown when operations performed as part of pattern matching throw\n- * an unexpected exception. For example, pattern matching may cause methods such as record component\n- * accessors to be implicitly invoked in order to extract pattern bindings. If these methods throw\n- * an exception, execution of the pattern matching construct may fail with {@code MatchException}.\n- * The original exception will be set as a {@link Throwable#getCause() cause} of\n- * the {@code MatchException}. No {@link Throwable#addSuppressed(java.lang.Throwable) suppressed}\n- * exceptions will be recorded.\n+ * <p>{@code MatchException} may also be thrown by the process of pattern matching\n+ * a value against a pattern. For example, pattern matching involving a record\n+ * pattern may require accessor methods to be implicitly invoked in order to\n+ * extract the component values. If any of these accessor methods throws an\n+ * exception, pattern matching completes abruptly and throws {@code\n+ * MatchException}. The original exception will be set as a {@link\n+ * Throwable#getCause() cause} of the {@code MatchException}. No {@link\n+ * Throwable#addSuppressed(java.lang.Throwable) suppressed} exceptions will be\n+ * recorded.\n@@ -63,1 +73,1 @@\n- * @jls 14.11.3 Execution of a switch Statement\n+ * @jls 14.11.3 Execution of a {@code switch} Statement\n@@ -65,1 +75,1 @@\n- * @jls 15.28.2 Run-Time Evaluation of switch Expressions\n+ * @jls 15.28.2 Run-Time Evaluation of {@code switch} Expressions\n@@ -67,1 +77,1 @@\n- * @since 19\n+ * @since 21\n@@ -69,1 +79,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/MatchException.java","additions":41,"deletions":32,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.Enum.EnumDesc;\n@@ -34,0 +35,1 @@\n+import java.util.Objects;\n@@ -36,2 +38,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n@@ -39,0 +39,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -46,1 +47,1 @@\n- * @since 17\n+ * @since 21\n@@ -48,1 +49,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING)\n@@ -63,1 +63,2 @@\n-                                           MethodType.methodType(int.class, Enum.class, int.class, Object[].class));\n+                                           MethodType.methodType(int.class, Enum.class, int.class, Object[].class,\n+                                                                 MethodHandles.Lookup.class, Class.class, ResolvedEnumLabels.class));\n@@ -74,1 +75,1 @@\n-     * {@code String} or {@code Integer} or {@code Class}.\n+     * {@code String} or {@code Integer} or {@code Class} or {@code EnumDesc}.\n@@ -92,0 +93,2 @@\n+     *   <li>the element is of type {@code EnumDesc}, that describes a constant that is\n+     *       equals to the target.<\/li>\n@@ -96,0 +99,4 @@\n+     * <p>\n+     * The value of the {@code restart} index must be between {@code 0} (inclusive) and\n+     * the length of the {@code labels} array (inclusive),\n+     * both  or an {@link IndexOutOfBoundsException} is thrown.\n@@ -104,1 +111,1 @@\n-     *               and {@code Class} instances, in any combination\n+     *               and {@code Class} and {@code EnumDesc} instances, in any combination\n@@ -112,1 +119,1 @@\n-     * {@code Integer} or {@code Class}.\n+     * {@code Integer}, {@code Class} or {@code EnumDesc}.\n@@ -141,1 +148,2 @@\n-            labelClass != Integer.class) {\n+            labelClass != Integer.class &&\n+            labelClass != EnumDesc.class) {\n@@ -147,0 +155,2 @@\n+        Objects.checkIndex(startIndex, labels.length + 1);\n+\n@@ -163,0 +173,5 @@\n+            } else if (label instanceof EnumDesc<?> enumDesc) {\n+                if (target.getClass().isEnum() &&\n+                    ((Enum<?>) target).describeConstable().stream().anyMatch(d -> d.equals(enumDesc))) {\n+                    return i;\n+                }\n@@ -203,0 +218,4 @@\n+     * <p>\n+     * The value of the {@code restart} index must be between {@code 0} (inclusive) and\n+     * the length of the {@code labels} array (inclusive),\n+     * both  or an {@link IndexOutOfBoundsException} is thrown.\n@@ -238,1 +257,4 @@\n-        labels = Stream.of(labels).map(l -> convertEnumConstants(lookup, enumClass, l)).toArray();\n+        Stream.of(labels).forEach(l -> validateEnumLabel(enumClass, l));\n+        MethodHandle temporary =\n+                MethodHandles.insertArguments(DO_ENUM_SWITCH, 2, labels, lookup, enumClass, new ResolvedEnumLabels());\n+        temporary = temporary.asType(invocationType);\n@@ -240,3 +262,2 @@\n-        MethodHandle target =\n-                MethodHandles.insertArguments(DO_ENUM_SWITCH, 2, (Object) labels);\n-        target = target.asType(invocationType);\n+        return new ConstantCallSite(temporary);\n+    }\n@@ -244,1 +265,14 @@\n-        return new ConstantCallSite(target);\n+    private static <E extends Enum<E>> void validateEnumLabel(Class<?> enumClassTemplate, Object label) {\n+        if (label == null) {\n+            throw new IllegalArgumentException(\"null label found\");\n+        }\n+        Class<?> labelClass = label.getClass();\n+        if (labelClass == Class.class) {\n+            if (label != enumClassTemplate) {\n+                throw new IllegalArgumentException(\"the Class label: \" + label +\n+                                                   \", expected the provided enum class: \" + enumClassTemplate);\n+            }\n+        } else if (labelClass != String.class) {\n+            throw new IllegalArgumentException(\"label with illegal type found: \" + labelClass +\n+                                               \", expected label of type either String or Class\");\n+        }\n@@ -272,1 +306,5 @@\n-    private static int doEnumSwitch(Enum<?> target, int startIndex, Object[] labels) {\n+    private static int doEnumSwitch(Enum<?> target, int startIndex, Object[] unresolvedLabels,\n+                                    MethodHandles.Lookup lookup, Class<?> enumClass,\n+                                    ResolvedEnumLabels resolvedLabels) {\n+        Objects.checkIndex(startIndex, unresolvedLabels.length + 1);\n+\n@@ -276,0 +314,8 @@\n+        if (resolvedLabels.resolvedLabels == null) {\n+            resolvedLabels.resolvedLabels = Stream.of(unresolvedLabels)\n+                                                  .map(l -> convertEnumConstants(lookup, enumClass, l))\n+                                                  .toArray();\n+        }\n+\n+        Object[] labels = resolvedLabels.resolvedLabels;\n+\n@@ -291,0 +337,4 @@\n+    private static final class ResolvedEnumLabels {\n+        @Stable\n+        public Object[] resolvedLabels;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":65,"deletions":15,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -483,3 +483,1 @@\n-                    for (StorageCalculator.StructStorage(\n-                            long offset, Class<?> ca, int byteWidth, VMStorage storage\n-                    ) : structStorages) {\n+                    for (StorageCalculator.StructStorage structStorage : structStorages) {\n@@ -487,2 +485,2 @@\n-                        bindings.vmLoad(storage, ca)\n-                                .bufferStore(offset, ca, byteWidth);\n+                        bindings.vmLoad(structStorage.storage(), structStorage.carrier())\n+                                .bufferStore(structStorage.offset(), structStorage.carrier(), structStorage.byteWidth());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -67,4 +67,0 @@\n-        @JEP(number=433, title=\"Pattern Matching for switch\", status=\"Fourth Preview\")\n-        SWITCH_PATTERN_MATCHING(),\n-        @JEP(number=432, title=\"Record Patterns\", status=\"Second Preview\")\n-        RECORD_PATTERNS,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n@@ -33,1 +31,1 @@\n- * @since 17\n+ * @since 21\n@@ -35,1 +33,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/CaseLabelTree.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n@@ -75,1 +73,1 @@\n-     * @since 17\n+     * @since 21\n@@ -77,1 +75,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n@@ -80,0 +77,8 @@\n+    \/**\n+     * The guard for the case.\n+     *\n+     * @return the guard\n+     * @since 21\n+     *\/\n+    ExpressionTree getGuard();\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/CaseTree.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n@@ -32,1 +30,1 @@\n- * @since 19\n+ * @since 21\n@@ -34,1 +32,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/ConstantCaseLabelTree.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -34,1 +33,1 @@\n- * @since 19\n+ * @since 21\n@@ -36,1 +35,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/DeconstructionPatternTree.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n@@ -32,1 +30,1 @@\n- * @since 17\n+ * @since 21\n@@ -34,1 +32,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/DefaultCaseLabelTree.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n@@ -46,17 +44,0 @@\n-    \/**\n-     * \"Enhanced\" {@code for} declarations come in two forms:\n-     * <ul>\n-     * <li> local variable declarations and\n-     * <li> record patterns\n-     * <\/ul>\n-     *\n-     * @since 20\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n-    public enum DeclarationKind {\n-        \/** enum constant for local variable declarations *\/\n-        VARIABLE,\n-        \/** enum constant for record pattern declarations *\/\n-        PATTERN\n-    }\n-\n@@ -65,1 +46,1 @@\n-     * @return the control variable, or {@code null} if this \"enhanced\" {@code for} uses a pattern\n+     * @return the control variable\n@@ -69,8 +50,0 @@\n-    \/**\n-     * Returns the control variable or pattern for the loop.\n-     * @return the control variable or pattern\n-     * @since 20\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n-    Tree getVariableOrRecordPattern();\n-\n@@ -88,8 +61,0 @@\n-\n-    \/**\n-     * Returns the kind of the declaration of the \"enhanced\" {@code for}.\n-     * @return the kind of the declaration\n-     * @since 20\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n-    DeclarationKind getDeclarationKind();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/EnhancedForLoopTree.java","additions":1,"deletions":36,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n@@ -46,16 +44,0 @@\n-    \/**\n-     * Two possible variants of instanceof expressions:\n-     * <ul>\n-     * <li> testing types, and\n-     * <li> performing pattern matching\n-     * <\/ul>\n-     * @since 20\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n-    public enum TestKind {\n-        \/** instanceof only testing a type *\/\n-        TYPE,\n-        \/** instanceof doing a pattern matching *\/\n-        PATTERN\n-    }\n-\n@@ -96,8 +78,0 @@\n-    \/**\n-     * Returns the kind of this instanceof expression.\n-     *\n-     * @return the kind of this instanceof expression\n-     * @since 20\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n-    TestKind getTestKind();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/InstanceOfTree.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.source.tree;\n-\n-import jdk.internal.javac.PreviewFeature;\n-\n-\/**\n- * A tree node for a parenthesized pattern.\n- *\n- * For example:\n- * <pre>\n- *   ( <em>pattern<\/em> )\n- * <\/pre>\n- *\n- * @jls 14.30.1 Kinds of Patterns\n- *\n- * @since 17\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n-public interface ParenthesizedPatternTree extends PatternTree {\n-    \/**\n-     * Returns the pattern within the parentheses.\n-     * @return the pattern\n-     *\/\n-    PatternTree getPattern();\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/ParenthesizedPatternTree.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n@@ -32,1 +30,1 @@\n- * @since 19\n+ * @since 21\n@@ -34,1 +32,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n@@ -44,7 +41,0 @@\n-    \/**\n-     * The guard for the case.\n-     *\n-     * @return the guard\n-     *\/\n-    ExpressionTree getGuard();\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/PatternCaseLabelTree.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -237,8 +237,0 @@\n-        \/**\n-         * Used for instances of {@link ParenthesizedPatternTree}.\n-         *\n-         * @since 17\n-         *\/\n-        @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n-        PARENTHESIZED_PATTERN(ParenthesizedPatternTree.class),\n-\n@@ -248,1 +240,1 @@\n-         * @since 17\n+         * @since 21\n@@ -250,1 +242,0 @@\n-        @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n@@ -256,1 +247,1 @@\n-         * @since 19\n+         * @since 21\n@@ -258,1 +249,0 @@\n-        @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n@@ -264,1 +254,1 @@\n-         * @since 19\n+         * @since 21\n@@ -266,1 +256,0 @@\n-        @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n@@ -272,1 +261,1 @@\n-         * @since 19\n+         * @since 21\n@@ -274,1 +263,0 @@\n-        @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -285,1 +285,1 @@\n-     * @since 17\n+     * @since 21\n@@ -287,1 +287,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n@@ -295,1 +294,1 @@\n-     * @since 19\n+     * @since 21\n@@ -297,1 +296,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n@@ -305,1 +303,1 @@\n-     * @since 19\n+     * @since 21\n@@ -307,1 +305,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n@@ -315,1 +312,1 @@\n-     * @since 19\n+     * @since 21\n@@ -317,1 +314,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n@@ -344,10 +340,0 @@\n-    \/**\n-     * Visits a {@code ParenthesizedPatternTree} node.\n-     * @param node the node being visited\n-     * @param p a parameter value\n-     * @return a result value\n-     * @since 17\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n-    R visitParenthesizedPattern(ParenthesizedPatternTree node, P p);\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -667,1 +667,1 @@\n-     * @since 17\n+     * @since 21\n@@ -670,1 +670,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n@@ -683,1 +682,1 @@\n-     * @since 19\n+     * @since 21\n@@ -686,1 +685,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n@@ -699,1 +697,1 @@\n-     * @since 19\n+     * @since 21\n@@ -702,1 +700,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n@@ -715,1 +712,1 @@\n-     * @since 19\n+     * @since 21\n@@ -718,1 +715,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n@@ -751,16 +747,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @implSpec This implementation calls {@code defaultAction}.\n-     *\n-     * @param node {@inheritDoc}\n-     * @param p {@inheritDoc}\n-     * @return  the result of {@code defaultAction}\n-     * @since 17\n-     *\/\n-    @Override\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n-    public R visitParenthesizedPattern(ParenthesizedPatternTree node, P p) {\n-        return defaultAction(node, p);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":4,"deletions":24,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -336,1 +336,1 @@\n-        R r = scan(node.getVariableOrRecordPattern(), p);\n+        R r = scan(node.getVariable(), p);\n@@ -400,0 +400,1 @@\n+        r = scanAndReduce(node.getGuard(), p, r);\n@@ -802,1 +803,1 @@\n-     * @since 17\n+     * @since 21\n@@ -805,1 +806,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n@@ -818,1 +818,1 @@\n-     * @since 19\n+     * @since 21\n@@ -821,1 +821,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n@@ -834,1 +833,1 @@\n-     * @since 19\n+     * @since 21\n@@ -837,1 +836,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n@@ -839,3 +837,1 @@\n-        R r = scan(node.getPattern(), p);\n-        r = scanAndReduce(node.getGuard(), p, r);\n-        return r;\n+        return scan(node.getPattern(), p);\n@@ -852,1 +848,1 @@\n-     * @since 19\n+     * @since 21\n@@ -855,1 +851,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n@@ -896,16 +891,0 @@\n-     * @param p  {@inheritDoc}\n-     * @return the result of scanning\n-     * @since 17\n-     *\/\n-    @Override\n-    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n-    public R visitParenthesizedPattern(ParenthesizedPatternTree node, P p) {\n-        return scan(node.getPattern(), p);\n-    }\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @implSpec This implementation scans the children in left to right order.\n-     *\n-     * @param node  {@inheritDoc}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":7,"deletions":28,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -212,2 +212,0 @@\n-            case CASE_NULL -> true;\n-            case PATTERN_SWITCH -> true;\n@@ -215,2 +213,0 @@\n-            case UNCONDITIONAL_PATTERN_IN_INSTANCEOF -> true;\n-            case RECORD_PATTERNS -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -235,2 +235,2 @@\n-        CASE_NULL(JDK17, Fragments.FeatureCaseNull, DiagKind.NORMAL),\n-        PATTERN_SWITCH(JDK17, Fragments.FeaturePatternSwitch, DiagKind.PLURAL),\n+        CASE_NULL(JDK21, Fragments.FeatureCaseNull, DiagKind.NORMAL),\n+        PATTERN_SWITCH(JDK21, Fragments.FeaturePatternSwitch, DiagKind.PLURAL),\n@@ -238,0 +238,2 @@\n+        UNCONDITIONAL_PATTERN_IN_INSTANCEOF(JDK21, Fragments.FeatureUnconditionalPatternsInInstanceof, DiagKind.PLURAL),\n+        RECORD_PATTERNS(JDK21, Fragments.FeatureDeconstructionPatterns, DiagKind.PLURAL),\n@@ -239,2 +241,0 @@\n-        UNCONDITIONAL_PATTERN_IN_INSTANCEOF(JDK19, Fragments.FeatureUnconditionalPatternsInInstanceof, DiagKind.PLURAL),\n-        RECORD_PATTERNS(JDK19, Fragments.FeatureDeconstructionPatterns, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -194,1 +194,0 @@\n-    public final Type nullPointerExceptionType;\n@@ -227,0 +226,1 @@\n+    public final Type constantBootstrapsType;\n@@ -229,0 +229,2 @@\n+    public final Type classDescType;\n+    public final Type enumDescType;\n@@ -568,1 +570,0 @@\n-        nullPointerExceptionType = enterClass(\"java.lang.NullPointerException\");\n@@ -612,0 +613,1 @@\n+        constantBootstrapsType = enterClass(\"java.lang.invoke.ConstantBootstraps\");\n@@ -614,0 +616,2 @@\n+        classDescType = enterClass(\"java.lang.constant.ClassDesc\");\n+        enumDescType = enterClass(\"java.lang.Enum$EnumDesc\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import com.sun.source.tree.EnhancedForLoopTree;\n@@ -429,2 +428,1 @@\n-            return tree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.VARIABLE &&\n-                    !isImplicitlyTyped((JCVariableDecl) tree.varOrRecordPattern);\n+            return !isImplicitlyTyped(tree.var);\n@@ -434,2 +432,0 @@\n-            Assert.check(oldTree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.VARIABLE);\n-\n@@ -437,1 +433,1 @@\n-            newTree.varOrRecordPattern = rewriteVarType((JCVariableDecl) oldTree.varOrRecordPattern);\n+            newTree.var = rewriteVarType(oldTree.var);\n@@ -443,4 +439,1 @@\n-            Assert.check(oldTree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.VARIABLE);\n-\n-            processVar((JCVariableDecl) oldTree.varOrRecordPattern,\n-                           (JCVariableDecl) newTree.varOrRecordPattern, hasErrors);\n+            processVar(oldTree.var, newTree.var, hasErrors);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Analyzer.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import com.sun.source.tree.EnhancedForLoopTree;\n@@ -174,2 +173,2 @@\n-        allowUnconditionalPatternsInstanceOf = (preview.isEnabled() || !preview.isPreview(Feature.UNCONDITIONAL_PATTERN_IN_INSTANCEOF)) &&\n-                                     Feature.UNCONDITIONAL_PATTERN_IN_INSTANCEOF.allowedInSource(source);\n+        allowUnconditionalPatternsInstanceOf =\n+                             Feature.UNCONDITIONAL_PATTERN_IN_INSTANCEOF.allowedInSource(source);\n@@ -1517,1 +1516,0 @@\n-\n@@ -1524,2 +1522,2 @@\n-            tree.elementType = types.elemtype(exprType); \/\/ perhaps expr is an array?\n-            if (tree.elementType == null) {\n+            Type elemtype = types.elemtype(exprType); \/\/ perhaps expr is an array?\n+            if (elemtype == null) {\n@@ -1532,1 +1530,1 @@\n-                    tree.elementType = types.createErrorType(exprType);\n+                    elemtype = types.createErrorType(exprType);\n@@ -1535,1 +1533,1 @@\n-                    tree.elementType = iterableParams.isEmpty()\n+                    elemtype = iterableParams.isEmpty()\n@@ -1549,33 +1547,3 @@\n-            if (tree.varOrRecordPattern instanceof JCVariableDecl jcVariableDecl) {\n-                if (jcVariableDecl.isImplicitlyTyped()) {\n-                    Type inferredType = chk.checkLocalVarType(jcVariableDecl, tree.elementType, jcVariableDecl.name);\n-                    setSyntheticVariableType(jcVariableDecl, inferredType);\n-                }\n-                attribStat(jcVariableDecl, loopEnv);\n-                chk.checkType(tree.expr.pos(), tree.elementType, jcVariableDecl.sym.type);\n-\n-                loopEnv.tree = tree; \/\/ before, we were not in loop!\n-                attribStat(tree.body, loopEnv);\n-            } else {\n-                Assert.check(tree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.PATTERN);\n-                JCRecordPattern jcRecordPattern = (JCRecordPattern) tree.varOrRecordPattern;\n-\n-                attribExpr(jcRecordPattern, loopEnv, tree.elementType);\n-\n-                \/\/ for(<pattern> x : xs) { y }\n-                \/\/ we include x's bindings when true in y\n-                \/\/ we don't do anything with x's bindings when false\n-\n-                MatchBindings forWithRecordPatternBindings = matchBindings;\n-                Env<AttrContext> recordPatternEnv = bindingEnv(loopEnv, forWithRecordPatternBindings.bindingsWhenTrue);\n-\n-                Type clazztype = jcRecordPattern.type;\n-\n-                checkCastablePattern(tree.expr.pos(), tree.elementType, clazztype);\n-\n-                recordPatternEnv.tree = tree; \/\/ before, we were not in loop!\n-                try {\n-                    attribStat(tree.body, recordPatternEnv);\n-                } finally {\n-                    recordPatternEnv.info.scope.leave();\n-                }\n+            if (tree.var.isImplicitlyTyped()) {\n+                Type inferredType = chk.checkLocalVarType(tree.var, elemtype, tree.var.name);\n+                setSyntheticVariableType(tree.var, inferredType);\n@@ -1583,0 +1551,4 @@\n+            attribStat(tree.var, loopEnv);\n+            chk.checkType(tree.expr.pos(), elemtype, tree.var.sym.type);\n+            loopEnv.tree = tree; \/\/ before, we were not in loop!\n+            attribStat(tree.body, loopEnv);\n@@ -1720,1 +1692,2 @@\n-                for (JCCaseLabel label : c.labels) {\n+                for (List<JCCaseLabel> labels = c.labels; labels.nonEmpty(); labels = labels.tail) {\n+                    JCCaseLabel label = labels.head;\n@@ -1734,1 +1707,5 @@\n-                                log.error(expr.pos(), Errors.EnumLabelMustBeUnqualifiedEnum);\n+                                if (allowPatternSwitch) {\n+                                    attribTree(expr, switchEnv, caseLabelResultInfo(seltype));\n+                                } else {\n+                                    log.error(expr.pos(), Errors.EnumLabelMustBeUnqualifiedEnum);\n+                                }\n@@ -1750,4 +1727,1 @@\n-                            ResultInfo valTypInfo = new ResultInfo(KindSelector.VAL_TYP,\n-                                                                   !seltype.hasTag(ERROR) ? seltype\n-                                                                                          : Type.noType);\n-                            Type pattype = attribTree(expr, switchEnv, valTypInfo);\n+                            Type pattype = attribTree(expr, switchEnv, caseLabelResultInfo(seltype));\n@@ -1760,1 +1734,1 @@\n-                                    } else {\n+                                    } else if ((s != null && !s.isEnum()) || !allowPatternSwitch) {\n@@ -1789,2 +1763,2 @@\n-                        JCExpression guard = patternlabel.guard;\n-                        if (guard != null) {\n+                        JCExpression guard = c.guard;\n+                        if (labels.tail.isEmpty() && guard != null) {\n@@ -1804,1 +1778,1 @@\n-                        boolean unguarded = TreeInfo.unguardedCaseLabel(label) && !pat.hasTag(RECORDPATTERN);\n+                        boolean unguarded = TreeInfo.unguardedCase(c) && !pat.hasTag(RECORDPATTERN);\n@@ -1857,0 +1831,5 @@\n+        private ResultInfo caseLabelResultInfo(Type seltype) {\n+            return new ResultInfo(KindSelector.VAL_TYP,\n+                                  !seltype.hasTag(ERROR) ? seltype\n+                                                         : Type.noType);\n+        }\n@@ -4104,1 +4083,0 @@\n-            tree.pattern.getTag() == PARENTHESIZEDPATTERN ||\n@@ -4112,3 +4090,2 @@\n-                    log.error(tree.pos(), Errors.InstanceofPatternNoSubtype(exprtype, clazztype));\n-                } else if (preview.isPreview(Feature.UNCONDITIONAL_PATTERN_IN_INSTANCEOF)) {\n-                    preview.warnPreview(tree.pattern.pos(), Feature.UNCONDITIONAL_PATTERN_IN_INSTANCEOF);\n+                    log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n+                              Feature.UNCONDITIONAL_PATTERN_IN_INSTANCEOF.error(this.sourceName));\n@@ -4256,5 +4233,0 @@\n-    public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n-        attribExpr(tree.pattern, env);\n-        result = tree.type = tree.pattern.type;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":32,"deletions":60,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -4629,1 +4629,1 @@\n-        List<JCCaseLabel> caseLabels = List.nil();\n+        List<Pair<JCCase, JCCaseLabel>> caseLabels = List.nil();\n@@ -4656,1 +4656,3 @@\n-                for (JCCaseLabel testCaseLabel : caseLabels) {\n+                for (Pair<JCCase, JCCaseLabel> caseAndLabel : caseLabels) {\n+                    JCCase testCase = caseAndLabel.fst;\n+                    JCCaseLabel testCaseLabel = caseAndLabel.snd;\n@@ -4666,1 +4668,1 @@\n-                                   TreeInfo.unguardedCaseLabel(testCaseLabel)) {\n+                                   TreeInfo.unguardedCase(testCase)) {\n@@ -4675,1 +4677,1 @@\n-                caseLabels = caseLabels.prepend(label);\n+                caseLabels = caseLabels.prepend(Pair.of(c, label));\n@@ -4700,6 +4702,0 @@\n-            while (existingPattern instanceof JCParenthesizedPattern parenthesized) {\n-                existingPattern = parenthesized.pattern;\n-            }\n-            while (currentPattern instanceof JCParenthesizedPattern parenthesized) {\n-                currentPattern = parenthesized.pattern;\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-import java.util.stream.Collectors;\n-import java.util.stream.StreamSupport;\n@@ -38,0 +36,1 @@\n+import com.sun.source.tree.CaseTree;\n@@ -41,1 +40,0 @@\n-import com.sun.tools.javac.code.Source.Feature;\n@@ -55,0 +53,1 @@\n+import com.sun.tools.javac.code.Kinds.Kind;\n@@ -58,1 +57,0 @@\n-import static com.sun.tools.javac.code.TypeTag.NONE;\n@@ -60,1 +58,0 @@\n-import com.sun.tools.javac.code.Types.UniqueType;\n@@ -64,0 +61,8 @@\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.Iterator;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import static java.util.stream.Collectors.groupingBy;\n@@ -214,0 +219,1 @@\n+    private final Infer infer;\n@@ -337,0 +343,1 @@\n+        infer = Infer.instance(context);\n@@ -650,15 +657,1 @@\n-            if(tree.varOrRecordPattern instanceof JCVariableDecl jcVariableDecl) {\n-                visitVarDef(jcVariableDecl);\n-            } else if (tree.varOrRecordPattern instanceof JCRecordPattern jcRecordPattern) {\n-                visitRecordPattern(jcRecordPattern);\n-\n-                Set<Symbol> coveredSymbols =\n-                        coveredSymbols(jcRecordPattern.pos(), List.of(jcRecordPattern));\n-\n-                boolean isExhaustive =\n-                        isExhaustive(jcRecordPattern.pos(), tree.elementType, coveredSymbols);\n-\n-                if (!isExhaustive) {\n-                    log.error(tree, Errors.ForeachNotExhaustiveOnType(jcRecordPattern.type, tree.elementType));\n-                }\n-            }\n+            visitVarDef(tree.var);\n@@ -708,2 +701,1 @@\n-                Set<Symbol> coveredSymbols = coveredSymbolsForCases(tree.pos(), tree.cases);\n-                tree.isExhaustive |= isExhaustive(tree.selector.pos(), tree.selector.type, coveredSymbols);\n+                tree.isExhaustive |= exhausts(tree.selector, tree.cases);\n@@ -743,1 +735,0 @@\n-            Set<Symbol> coveredSymbols = coveredSymbolsForCases(tree.pos(), tree.cases);\n@@ -746,1 +737,1 @@\n-                                isExhaustive(tree.selector.pos(), tree.selector.type, coveredSymbols);\n+                                exhausts(tree.selector, tree.cases);\n@@ -754,24 +745,17 @@\n-        private Set<Symbol> coveredSymbolsForCases(DiagnosticPosition pos,\n-                                                   List<JCCase> cases) {\n-            HashSet<JCTree> labelValues = cases.stream()\n-                                               .flatMap(c -> c.labels.stream())\n-                                               .filter(TreeInfo::unguardedCaseLabel)\n-                                               .filter(l -> !l.hasTag(DEFAULTCASELABEL))\n-                                               .map(l -> l.hasTag(CONSTANTCASELABEL) ? ((JCConstantCaseLabel) l).expr\n-                                                                                     : ((JCPatternCaseLabel) l).pat)\n-                                               .collect(Collectors.toCollection(HashSet::new));\n-            return coveredSymbols(pos, labelValues);\n-        }\n-\n-        private Set<Symbol> coveredSymbols(DiagnosticPosition pos,\n-                                           Iterable<? extends JCTree> labels) {\n-            Set<Symbol> coveredSymbols = new HashSet<>();\n-            Map<UniqueType, List<JCRecordPattern>> deconstructionPatternsByType = new HashMap<>();\n-\n-            for (JCTree labelValue : labels) {\n-                switch (labelValue.getTag()) {\n-                    case BINDINGPATTERN, PARENTHESIZEDPATTERN -> {\n-                        Type primaryPatternType = TreeInfo.primaryPatternType((JCPattern) labelValue);\n-                        if (!primaryPatternType.hasTag(NONE)) {\n-                            coveredSymbols.add(primaryPatternType.tsym);\n-                        }\n+        sealed interface PatternDescription {\n+            public static PatternDescription from(Types types, Type selectorType, JCPattern pattern) {\n+                if (pattern instanceof JCBindingPattern binding) {\n+                    Type type = types.isSubtype(selectorType, binding.type)\n+                            ? selectorType : binding.type;\n+                    return new BindingPattern(type);\n+                } else if (pattern instanceof JCRecordPattern record) {\n+                    Type[] componentTypes = ((ClassSymbol) record.type.tsym).getRecordComponents()\n+                            .map(r -> types.memberType(record.type, r))\n+                            .toArray(s -> new Type[s]);\n+                    PatternDescription[] nestedDescriptions =\n+                            new PatternDescription[record.nested.size()];\n+                    int i = 0;\n+                    for (List<JCPattern> it = record.nested;\n+                         it.nonEmpty();\n+                         it = it.tail, i++) {\n+                        nestedDescriptions[i] = PatternDescription.from(types, componentTypes[i], it.head);\n@@ -779,8 +763,51 @@\n-                    case RECORDPATTERN -> {\n-                        JCRecordPattern dpat = (JCRecordPattern) labelValue;\n-                        UniqueType type = new UniqueType(dpat.type, types);\n-                        List<JCRecordPattern> augmentedPatterns =\n-                                deconstructionPatternsByType.getOrDefault(type, List.nil())\n-                                                                 .prepend(dpat);\n-\n-                        deconstructionPatternsByType.put(type, augmentedPatterns);\n+                    return new RecordPattern(record.type, componentTypes, nestedDescriptions);\n+                } else {\n+                    throw Assert.error();\n+                }\n+            }\n+        }\n+\n+        record BindingPattern(Type type) implements PatternDescription {\n+            @Override\n+            public int hashCode() {\n+                return type.tsym.hashCode();\n+            }\n+            @Override\n+            public boolean equals(Object o) {\n+                return o instanceof BindingPattern other &&\n+                       type.tsym == other.type.tsym;\n+            }\n+            @Override\n+            public String toString() {\n+                return type.tsym + \" _\";\n+            }\n+        }\n+\n+        record RecordPattern(Type recordType, int _hashCode, Type[] fullComponentTypes, PatternDescription... nested) implements PatternDescription {\n+\n+            public RecordPattern(Type recordType, Type[] fullComponentTypes, PatternDescription[] nested) {\n+                this(recordType, hashCode(-1, recordType, nested), fullComponentTypes, nested);\n+            }\n+\n+            @Override\n+            public int hashCode() {\n+                return _hashCode;\n+            }\n+\n+            @Override\n+            public boolean equals(Object o) {\n+                return o instanceof RecordPattern other &&\n+                       recordType.tsym == other.recordType.tsym &&\n+                       Arrays.equals(nested, other.nested);\n+            }\n+\n+            public int hashCode(int excludeComponent) {\n+                return hashCode(excludeComponent, recordType, nested);\n+            }\n+\n+            public static int hashCode(int excludeComponent, Type recordType, PatternDescription... nested) {\n+                int hash = 5;\n+                hash =  41 * hash + recordType.tsym.hashCode();\n+                for (int  i = 0; i < nested.length; i++) {\n+                    if (i != excludeComponent) {\n+                        hash = 41 * hash + nested[i].hashCode();\n@@ -788,0 +815,17 @@\n+                }\n+                return hash;\n+            }\n+            @Override\n+            public String toString() {\n+                return recordType.tsym + \"(\" + Arrays.stream(nested)\n+                                                     .map(pd -> pd.toString())\n+                                                     .collect(Collectors.joining(\", \")) + \")\";\n+            }\n+        }\n+\n+        private boolean exhausts(JCExpression selector, List<JCCase> cases) {\n+            Set<PatternDescription> patternSet = new HashSet<>();\n+            Map<Symbol, Set<Symbol>> enum2Constants = new HashMap<>();\n+            for (JCCase c : cases) {\n+                if (!TreeInfo.unguardedCase(c))\n+                    continue;\n@@ -789,5 +833,16 @@\n-                    default -> {\n-                        Assert.check(labelValue instanceof JCExpression, labelValue.getTag().name());\n-                        JCExpression expr = (JCExpression) labelValue;\n-                        if (expr.hasTag(IDENT) && ((JCIdent) expr).sym.isEnum())\n-                            coveredSymbols.add(((JCIdent) expr).sym);\n+                for (var l : c.labels) {\n+                    if (l instanceof JCPatternCaseLabel patternLabel) {\n+                        for (Type component : components(selector.type)) {\n+                            patternSet.add(PatternDescription.from(types, component, patternLabel.pat));\n+                        }\n+                    } else if (l instanceof JCConstantCaseLabel constantLabel) {\n+                        Symbol s = TreeInfo.symbol(constantLabel.expr);\n+                        if (s != null && s.isEnum()) {\n+                            enum2Constants.computeIfAbsent(s.owner, x -> {\n+                                Set<Symbol> result = new HashSet<>();\n+                                s.owner.members()\n+                                       .getSymbols(sym -> sym.kind == Kind.VAR && sym.isEnum())\n+                                       .forEach(result::add);\n+                                return result;\n+                            }).remove(s);\n+                        }\n@@ -797,51 +852,17 @@\n-            for (Entry<UniqueType, List<JCRecordPattern>> e : deconstructionPatternsByType.entrySet()) {\n-                if (e.getValue().stream().anyMatch(r -> r.nested.size() != r.record.getRecordComponents().size())) {\n-                    coveredSymbols.add(syms.errSymbol);\n-                } else if (coversDeconstructionFromComponent(pos, e.getKey().type, e.getValue(), 0)) {\n-                    coveredSymbols.add(e.getKey().type.tsym);\n-                }\n-            }\n-            return coveredSymbols;\n-        }\n-\n-        private boolean coversDeconstructionFromComponent(DiagnosticPosition pos,\n-                                                          Type recordType,\n-                                                          List<JCRecordPattern> deconstructionPatterns,\n-                                                          int component) {\n-            \/\/Given a set of record patterns for the same record, and a starting component,\n-            \/\/this method checks, whether the nested patterns for the components are exhaustive,\n-            \/\/i.e. represent all possible combinations.\n-            \/\/This is done by categorizing the patterns based on the type covered by the given\n-            \/\/starting component.\n-            \/\/For each such category, it is then checked if the nested patterns starting at the next\n-            \/\/component are exhaustive, by recursivelly invoking this method. If these nested patterns\n-            \/\/are exhaustive, the given covered type is accepted.\n-            \/\/All such covered types are then checked whether they cover the declared type of\n-            \/\/the starting component's declaration. If yes, the given set of patterns starting at\n-            \/\/the given component cover the given record exhaustivelly, and true is returned.\n-            List<? extends RecordComponent> components =\n-                    deconstructionPatterns.head.record.getRecordComponents();\n-\n-            if (components.size() == component) {\n-                \/\/no components remain to be checked:\n-                return true;\n-            }\n-\n-            \/\/for the first tested component, gather symbols covered by the nested patterns:\n-            Type instantiatedComponentType = types.memberType(recordType, components.get(component));\n-            List<JCPattern> nestedComponentPatterns = deconstructionPatterns.map(d -> d.nested.get(component));\n-            Set<Symbol> coveredSymbolsForComponent = coveredSymbols(pos,\n-                                                                    nestedComponentPatterns);\n-\n-            \/\/for each of the symbols covered by the starting component, find all deconstruction patterns\n-            \/\/that have the given type, or its supertype, as a type of the starting nested pattern:\n-            Map<Symbol, List<JCRecordPattern>> coveredSymbol2Patterns = new HashMap<>();\n-\n-            for (JCRecordPattern deconstructionPattern : deconstructionPatterns) {\n-                JCPattern nestedPattern = deconstructionPattern.nested.get(component);\n-                Symbol componentPatternType;\n-                switch (nestedPattern.getTag()) {\n-                    case BINDINGPATTERN, PARENTHESIZEDPATTERN -> {\n-                        Type primaryPatternType =\n-                                TreeInfo.primaryPatternType(nestedPattern);\n-                        componentPatternType = primaryPatternType.tsym;\n+            for (Entry<Symbol, Set<Symbol>> e : enum2Constants.entrySet()) {\n+                if (e.getValue().isEmpty()) {\n+                    patternSet.add(new BindingPattern(e.getKey().type));\n+                }\n+            }\n+            List<PatternDescription> patterns = List.from(patternSet);\n+            try {\n+                boolean repeat = true;\n+                while (repeat) {\n+                    List<PatternDescription> updatedPatterns;\n+                    updatedPatterns = reduceBindingPatterns(selector.type, patterns);\n+                    updatedPatterns = reduceNestedPatterns(updatedPatterns);\n+                    updatedPatterns = reduceRecordPatterns(updatedPatterns);\n+                    repeat = updatedPatterns != patterns;\n+                    patterns = updatedPatterns;\n+                    if (checkCovered(selector.type, patterns)) {\n+                        return true;\n@@ -849,2 +870,14 @@\n-                    case RECORDPATTERN -> {\n-                        componentPatternType = ((JCRecordPattern) nestedPattern).record;\n+                }\n+                return checkCovered(selector.type, patterns);\n+            } catch (CompletionFailure cf) {\n+                chk.completionError(selector.pos(), cf);\n+                return true; \/\/error recovery\n+            }\n+        }\n+\n+        private boolean checkCovered(Type seltype, List<PatternDescription> patterns) {\n+            for (Type seltypeComponent : components(seltype)) {\n+                for (PatternDescription pd : patterns) {\n+                    if (pd instanceof BindingPattern bp &&\n+                        types.isSubtype(seltypeComponent, types.erasure(bp.type))) {\n+                        return true;\n@@ -852,2 +885,16 @@\n-                    default -> {\n-                        throw Assert.error(\"Unexpected tree kind: \" + nestedPattern.getTag());\n+                }\n+            }\n+            return false;\n+        }\n+\n+        private List<Type> components(Type seltype) {\n+            return switch (seltype.getTag()) {\n+                case CLASS -> {\n+                    if (seltype.isCompound()) {\n+                        if (seltype.isIntersection()) {\n+                            yield ((Type.IntersectionClassType) seltype).getComponents()\n+                                                                        .stream()\n+                                                                        .flatMap(t -> components(t).stream())\n+                                                                        .collect(List.collector());\n+                        }\n+                        yield List.nil();\n@@ -855,0 +902,1 @@\n+                    yield List.of(types.erasure(seltype));\n@@ -856,7 +904,91 @@\n-                for (Symbol currentType : coveredSymbolsForComponent) {\n-                    if (types.isSubtype(types.erasure(currentType.type),\n-                                        types.erasure(componentPatternType.type))) {\n-                        coveredSymbol2Patterns.put(currentType,\n-                                                   coveredSymbol2Patterns.getOrDefault(currentType,\n-                                                                                       List.nil())\n-                                              .prepend(deconstructionPattern));\n+                case TYPEVAR -> components(((TypeVar) seltype).getUpperBound());\n+                default -> List.of(types.erasure(seltype));\n+            };\n+        }\n+\n+        \/* In a set of patterns, search for a sub-set of binding patterns that\n+         * in combination exhaust their sealed supertype. If such a sub-set\n+         * is found, it is removed, and replaced with a binding pattern\n+         * for the sealed supertype.\n+         *\/\n+        private List<PatternDescription> reduceBindingPatterns(Type selectorType, List<PatternDescription> patterns) {\n+            Set<Symbol> existingBindings = patterns.stream()\n+                                                   .filter(pd -> pd instanceof BindingPattern)\n+                                                   .map(pd -> ((BindingPattern) pd).type.tsym)\n+                                                   .collect(Collectors.toSet());\n+\n+            for (PatternDescription pdOne : patterns) {\n+                if (pdOne instanceof BindingPattern bpOne) {\n+                    Set<PatternDescription> toRemove = new HashSet<>();\n+                    Set<PatternDescription> toAdd = new HashSet<>();\n+\n+                    for (Type sup : types.directSupertypes(bpOne.type)) {\n+                        ClassSymbol clazz = (ClassSymbol) sup.tsym;\n+\n+                        if (clazz.isSealed() && clazz.isAbstract() &&\n+                            \/\/if a binding pattern for clazz already exists, no need to analyze it again:\n+                            !existingBindings.contains(clazz)) {\n+                            ListBuffer<PatternDescription> bindings = new ListBuffer<>();\n+                            \/\/do not reduce to types unrelated to the selector type:\n+                            Type clazzErasure = types.erasure(clazz.type);\n+                            if (components(selectorType).stream()\n+                                                        .map(types::erasure)\n+                                                        .noneMatch(c -> types.isSubtype(clazzErasure, c))) {\n+                                continue;\n+                            }\n+\n+                            Set<Symbol> permitted = allPermittedSubTypes(clazz, csym -> {\n+                                Type instantiated;\n+                                if (csym.type.allparams().isEmpty()) {\n+                                    instantiated = csym.type;\n+                                } else {\n+                                    instantiated = infer.instantiatePatternType(selectorType, csym);\n+                                }\n+\n+                                return instantiated != null && types.isCastable(selectorType, instantiated);\n+                            });\n+\n+                            for (PatternDescription pdOther : patterns) {\n+                                if (pdOther instanceof BindingPattern bpOther) {\n+                                    boolean reduces = false;\n+                                    Set<Symbol> currentPermittedSubTypes =\n+                                            allPermittedSubTypes((ClassSymbol) bpOther.type.tsym, s -> true);\n+\n+                                    PERMITTED: for (Iterator<Symbol> it = permitted.iterator(); it.hasNext();) {\n+                                        Symbol perm = it.next();\n+\n+                                        for (Symbol currentPermitted : currentPermittedSubTypes) {\n+                                            if (types.isSubtype(types.erasure(currentPermitted.type),\n+                                                                types.erasure(perm.type))) {\n+                                                it.remove();\n+                                                continue PERMITTED;\n+                                            }\n+                                        }\n+                                        if (types.isSubtype(types.erasure(perm.type),\n+                                                            types.erasure(bpOther.type))) {\n+                                            it.remove();\n+                                            reduces = true;\n+                                        }\n+                                    }\n+\n+                                    if (reduces) {\n+                                        bindings.append(pdOther);\n+                                    }\n+                                }\n+                            }\n+\n+                            if (permitted.isEmpty()) {\n+                                toRemove.addAll(bindings);\n+                                toAdd.add(new BindingPattern(clazz.type));\n+                            }\n+                        }\n+                    }\n+\n+                    if (!toAdd.isEmpty() || !toRemove.isEmpty()) {\n+                        for (PatternDescription pd : toRemove) {\n+                            patterns = List.filter(patterns, pd);\n+                        }\n+                        for (PatternDescription pd : toAdd) {\n+                            patterns = patterns.prepend(pd);\n+                        }\n+                        return patterns;\n@@ -866,0 +998,9 @@\n+            return patterns;\n+        }\n+\n+        private Set<Symbol> allPermittedSubTypes(ClassSymbol root, Predicate<ClassSymbol> accept) {\n+            Set<Symbol> permitted = new HashSet<>();\n+            List<ClassSymbol> permittedSubtypesClosure = List.of(root);\n+\n+            while (permittedSubtypesClosure.nonEmpty()) {\n+                ClassSymbol current = permittedSubtypesClosure.head;\n@@ -867,4 +1008,1 @@\n-            \/\/Check the components following the starting component, for each of the covered symbol,\n-            \/\/if they are exhaustive. If yes, the given covered symbol should be part of the following\n-            \/\/exhaustiveness check:\n-            Set<Symbol> covered = new HashSet<>();\n+                permittedSubtypesClosure = permittedSubtypesClosure.tail;\n@@ -872,3 +1010,9 @@\n-            for (Entry<Symbol, List<JCRecordPattern>> e : coveredSymbol2Patterns.entrySet()) {\n-                if (coversDeconstructionFromComponent(pos, recordType, e.getValue(), component + 1)) {\n-                    covered.add(e.getKey());\n+                if (current.isSealed() && current.isAbstract()) {\n+                    for (Symbol sym : current.permitted) {\n+                        ClassSymbol csym = (ClassSymbol) sym;\n+\n+                        if (accept.test(csym)) {\n+                            permittedSubtypesClosure = permittedSubtypesClosure.prepend(csym);\n+                            permitted.add(csym);\n+                        }\n+                    }\n@@ -878,2 +1022,1 @@\n-            \/\/verify whether the filtered symbols cover the given record's declared type:\n-            return isExhaustive(pos, instantiatedComponentType, covered);\n+            return permitted;\n@@ -882,13 +1025,58 @@\n-        private void transitiveCovers(DiagnosticPosition pos, Type seltype, Set<Symbol> covered) {\n-            List<Symbol> todo = List.from(covered);\n-            while (todo.nonEmpty()) {\n-                Symbol sym = todo.head;\n-                todo = todo.tail;\n-                switch (sym.kind) {\n-                    case VAR -> {\n-                        Iterable<Symbol> constants = sym.owner\n-                                                        .members()\n-                                                        .getSymbols(s -> s.isEnum() &&\n-                                                                         s.kind == VAR);\n-                        boolean hasAll = StreamSupport.stream(constants.spliterator(), false)\n-                                                      .allMatch(covered::contains);\n+        \/* Among the set of patterns, find sub-set of patterns such:\n+         * $record($prefix$, $nested, $suffix$)\n+         * Where $record, $prefix$ and $suffix$ is the same for each pattern\n+         * in the set, and the patterns only differ in one \"column\" in\n+         * the $nested pattern.\n+         * Then, the set of $nested patterns is taken, and passed recursively\n+         * to reduceNestedPatterns and to reduceBindingPatterns, to\n+         * simplify the pattern. If that succeeds, the original found sub-set\n+         * of patterns is replaced with a new set of patterns of the form:\n+         * $record($prefix$, $resultOfReduction, $suffix$)\n+         *\/\n+        private List<PatternDescription> reduceNestedPatterns(List<PatternDescription> patterns) {\n+            \/* implementation note:\n+             * finding a sub-set of patterns that only differ in a single\n+             * column is time-consuming task, so this method speeds it up by:\n+             * - group the patterns by their record class\n+             * - for each column (nested pattern) do:\n+             * -- group patterns by their hash\n+             * -- in each such by-hash group, find sub-sets that only differ in\n+             *    the chosen column, and then call reduceBindingPatterns and reduceNestedPatterns\n+             *    on patterns in the chosen column, as described above\n+             *\/\n+            var groupByRecordClass =\n+                    patterns.stream()\n+                            .filter(pd -> pd instanceof RecordPattern)\n+                            .map(pd -> (RecordPattern) pd)\n+                            .collect(groupingBy(pd -> (ClassSymbol) pd.recordType.tsym));\n+\n+            for (var e : groupByRecordClass.entrySet()) {\n+                int nestedPatternsCount = e.getKey().getRecordComponents().size();\n+\n+                for (int mismatchingCandidate = 0;\n+                     mismatchingCandidate < nestedPatternsCount;\n+                     mismatchingCandidate++) {\n+                    int mismatchingCandidateFin = mismatchingCandidate;\n+                    var groupByHashes =\n+                            e.getValue()\n+                             .stream()\n+                             \/\/error recovery, ignore patterns with incorrect number of nested patterns:\n+                             .filter(pd -> pd.nested.length == nestedPatternsCount)\n+                             .collect(groupingBy(pd -> pd.hashCode(mismatchingCandidateFin)));\n+                    for (var candidates : groupByHashes.values()) {\n+                        var candidatesArr = candidates.toArray(RecordPattern[]::new);\n+\n+                        for (int firstCandidate = 0;\n+                             firstCandidate < candidatesArr.length;\n+                             firstCandidate++) {\n+                            RecordPattern rpOne = candidatesArr[firstCandidate];\n+                            ListBuffer<RecordPattern> join = new ListBuffer<>();\n+\n+                            join.append(rpOne);\n+\n+                            NEXT_PATTERN: for (int nextCandidate = 0;\n+                                               nextCandidate < candidatesArr.length;\n+                                               nextCandidate++) {\n+                                if (firstCandidate == nextCandidate) {\n+                                    continue;\n+                                }\n@@ -896,4 +1084,11 @@\n-                        if (hasAll && covered.add(sym.owner)) {\n-                            todo = todo.prepend(sym.owner);\n-                        }\n-                    }\n+                                RecordPattern rpOther = candidatesArr[nextCandidate];\n+                                if (rpOne.recordType.tsym == rpOther.recordType.tsym) {\n+                                    for (int i = 0; i < rpOne.nested.length; i++) {\n+                                        if (i != mismatchingCandidate &&\n+                                            !rpOne.nested[i].equals(rpOther.nested[i])) {\n+                                            continue NEXT_PATTERN;\n+                                        }\n+                                    }\n+                                    join.append(rpOther);\n+                                }\n+                            }\n@@ -901,6 +1096,16 @@\n-                    case TYP -> {\n-                        for (Type sup : types.directSupertypes(sym.type)) {\n-                            if (sup.tsym.kind == TYP) {\n-                                if (isTransitivelyCovered(pos, seltype, sup.tsym, covered) &&\n-                                    covered.add(sup.tsym)) {\n-                                    todo = todo.prepend(sup.tsym);\n+                            var nestedPatterns = join.stream().map(rp -> rp.nested[mismatchingCandidateFin]).collect(List.collector());\n+                            var updatedPatterns = reduceNestedPatterns(nestedPatterns);\n+\n+                            updatedPatterns = reduceRecordPatterns(updatedPatterns);\n+                            updatedPatterns = reduceBindingPatterns(rpOne.fullComponentTypes()[mismatchingCandidateFin], updatedPatterns);\n+\n+                            if (nestedPatterns != updatedPatterns) {\n+                                ListBuffer<PatternDescription> result = new ListBuffer<>();\n+                                Set<PatternDescription> toRemove = Collections.newSetFromMap(new IdentityHashMap<>());\n+\n+                                toRemove.addAll(join);\n+\n+                                for (PatternDescription p : patterns) {\n+                                    if (!toRemove.contains(p)) {\n+                                        result.append(p);\n+                                    }\n@@ -908,0 +1113,10 @@\n+\n+                                for (PatternDescription nested : updatedPatterns) {\n+                                    PatternDescription[] newNested =\n+                                            Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n+                                    newNested[mismatchingCandidateFin] = nested;\n+                                    result.append(new RecordPattern(rpOne.recordType(),\n+                                                                    rpOne.fullComponentTypes(),\n+                                                                    newNested));\n+                                }\n+                                return result.toList();\n@@ -913,0 +1128,1 @@\n+            return patterns;\n@@ -915,17 +1131,18 @@\n-        private boolean isTransitivelyCovered(DiagnosticPosition pos, Type seltype,\n-                                              Symbol sealed, Set<Symbol> covered) {\n-            try {\n-                if (covered.stream().anyMatch(c -> sealed.isSubClass(c, types)))\n-                    return true;\n-                if (sealed.kind == TYP && sealed.isAbstract() && sealed.isSealed()) {\n-                    return ((ClassSymbol) sealed).permitted\n-                                                 .stream()\n-                                                 .filter(s -> {\n-                                                     return types.isCastable(seltype, s.type\/*, types.noWarnings*\/);\n-                                                 })\n-                                                 .allMatch(s -> isTransitivelyCovered(pos, seltype, s, covered));\n-                }\n-                return false;\n-            } catch (CompletionFailure cf) {\n-                chk.completionError(pos, cf);\n-                return true;\n+        \/* In the set of patterns, find those for which, given:\n+         * $record($nested1, $nested2, ...)\n+         * all the $nestedX pattern cover the given record component,\n+         * and replace those with a simple binding pattern over $record.\n+         *\/\n+        private List<PatternDescription> reduceRecordPatterns(List<PatternDescription> patterns) {\n+            var newPatterns = new ListBuffer<PatternDescription>();\n+            boolean modified = false;\n+            for (PatternDescription pd : patterns) {\n+                if (pd instanceof RecordPattern rpOne) {\n+                    PatternDescription reducedPattern = reduceRecordPattern(rpOne);\n+                    if (reducedPattern != rpOne) {\n+                        newPatterns.append(reducedPattern);\n+                        modified = true;\n+                        continue;\n+                    }\n+                }\n+                newPatterns.append(pd);\n@@ -933,1 +1150,2 @@\n-        }\n+            return modified ? newPatterns.toList() : patterns;\n+                }\n@@ -935,9 +1153,14 @@\n-        private boolean isExhaustive(DiagnosticPosition pos, Type seltype, Set<Symbol> covered) {\n-            transitiveCovers(pos, seltype, covered);\n-            return switch (seltype.getTag()) {\n-                case CLASS -> {\n-                    if (seltype.isCompound()) {\n-                        if (seltype.isIntersection()) {\n-                            yield ((Type.IntersectionClassType) seltype).getComponents()\n-                                                                        .stream()\n-                                                                        .anyMatch(t -> isExhaustive(pos, t, covered));\n+        private PatternDescription reduceRecordPattern(PatternDescription pattern) {\n+            if (pattern instanceof RecordPattern rpOne) {\n+                Type[] componentType = rpOne.fullComponentTypes();\n+                \/\/error recovery, ignore patterns with incorrect number of nested patterns:\n+                if (componentType.length != rpOne.nested.length) {\n+                    return pattern;\n+                }\n+                PatternDescription[] reducedNestedPatterns = null;\n+                boolean covered = true;\n+                for (int i = 0; i < componentType.length; i++) {\n+                    PatternDescription newNested = reduceRecordPattern(rpOne.nested[i]);\n+                    if (newNested != rpOne.nested[i]) {\n+                        if (reducedNestedPatterns == null) {\n+                            reducedNestedPatterns = Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n@@ -945,1 +1168,1 @@\n-                        yield false;\n+                        reducedNestedPatterns[i] = newNested;\n@@ -947,4 +1170,3 @@\n-                    yield covered.stream()\n-                                 .filter(coveredSym -> coveredSym.kind == TYP)\n-                                 .anyMatch(coveredSym -> types.isSubtype(types.erasure(seltype),\n-                                                                         types.erasure(coveredSym.type)));\n+\n+                    covered &= newNested instanceof BindingPattern bp &&\n+                               types.isSubtype(types.erasure(componentType[i]), types.erasure(bp.type));\n@@ -952,3 +1174,4 @@\n-                case TYPEVAR -> isExhaustive(pos, ((TypeVar) seltype).getUpperBound(), covered);\n-                default -> {\n-                    yield covered.contains(types.erasure(seltype).tsym);\n+                if (covered) {\n+                    return new BindingPattern(rpOne.recordType);\n+                } else if (reducedNestedPatterns != null) {\n+                    return new RecordPattern(rpOne.recordType, rpOne.fullComponentTypes(), reducedNestedPatterns);\n@@ -956,1 +1179,2 @@\n-            };\n+            }\n+            return pattern;\n@@ -1377,5 +1601,1 @@\n-            if(tree.varOrRecordPattern instanceof JCVariableDecl jcVariableDecl) {\n-                visitVarDef(jcVariableDecl);\n-            } else if (tree.varOrRecordPattern instanceof JCRecordPattern jcRecordPattern) {\n-                visitRecordPattern(jcRecordPattern);\n-            }\n+            visitVarDef(tree.var);\n@@ -2180,4 +2400,0 @@\n-            if (inits.isReset()) {\n-                inits.assign(initsWhenTrue);\n-                uninits.assign(uninitsWhenTrue);\n-            }\n@@ -2562,0 +2778,2 @@\n+            visitVarDef(tree.var);\n+\n@@ -2570,7 +2788,1 @@\n-            if(tree.varOrRecordPattern instanceof JCVariableDecl jcVariableDecl) {\n-                visitVarDef(jcVariableDecl);\n-                letInit(tree.pos(), jcVariableDecl.sym);\n-            } else if (tree.varOrRecordPattern instanceof JCRecordPattern jcRecordPattern) {\n-                visitRecordPattern(jcRecordPattern);\n-            }\n-\n+            letInit(tree.pos(), tree.var.sym);\n@@ -2628,11 +2840,4 @@\n-                if (l.head.stats.isEmpty() &&\n-                    l.tail.nonEmpty() &&\n-                    l.tail.head.labels.size() == 1 &&\n-                    TreeInfo.isNullCaseLabel(l.tail.head.labels.head)) {\n-                    \/\/handling:\n-                    \/\/case Integer i:\n-                    \/\/case null:\n-                    \/\/joining these two cases together - processing Integer i pattern,\n-                    \/\/but statements from case null:\n-                    l = l.tail;\n-                    c = l.head;\n+                scan(c.guard);\n+                if (inits.isReset()) {\n+                    inits.assign(initsWhenTrue);\n+                    uninits.assign(uninitsWhenTrue);\n@@ -3031,6 +3236,0 @@\n-        @Override\n-        public void visitPatternCaseLabel(JCPatternCaseLabel tree) {\n-            scan(tree.pat);\n-            scan(tree.guard);\n-        }\n-\n@@ -3107,0 +3306,1 @@\n+        WriteableScope declaredInsideGuard;\n@@ -3120,1 +3320,1 @@\n-                    case PATTERNCASELABEL:\n+                    case CASE:\n@@ -3134,4 +3334,1 @@\n-                if (currentTree != null &&\n-                        sym.kind == VAR &&\n-                        sym.owner.kind == MTH &&\n-                        ((VarSymbol)sym).pos < currentTree.getStartPosition()) {\n+                if (currentTree != null) {\n@@ -3139,4 +3336,12 @@\n-                        case CLASSDEF:\n-                        case CASE:\n-                        case LAMBDA:\n-                            reportEffectivelyFinalError(tree, sym);\n+                        case CLASSDEF, LAMBDA -> {\n+                            if (sym.kind == VAR &&\n+                                sym.owner.kind == MTH &&\n+                                ((VarSymbol)sym).pos < currentTree.getStartPosition()) {\n+                                reportEffectivelyFinalError(tree, sym);\n+                            }\n+                        }\n+                        case CASE -> {\n+                            if (!declaredInsideGuard.includes(sym)) {\n+                                log.error(tree.pos(), Errors.CannotAssignNotDeclaredGuard(sym));\n+                            }\n+                        }\n@@ -3151,1 +3356,1 @@\n-                case PATTERNCASELABEL -> Fragments.Guard;\n+                case CASE -> Fragments.Guard;\n@@ -3191,13 +3396,13 @@\n-        public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n-            scan(tree.pattern);\n-        }\n-\n-        @Override\n-        public void visitPatternCaseLabel(JCPatternCaseLabel tree) {\n-             scan(tree.pat);\n-            JCTree prevTree = currentTree;\n-            try {\n-                currentTree = tree;\n-                scan(tree.guard);\n-            } finally {\n-                currentTree = prevTree;\n+        public void visitCase(JCCase tree) {\n+            scan(tree.labels);\n+            if (tree.guard != null) {\n+                JCTree prevTree = currentTree;\n+                WriteableScope prevDeclaredInsideGuard = declaredInsideGuard;\n+                try {\n+                    currentTree = tree;\n+                    declaredInsideGuard = WriteableScope.create(attrEnv.enclClass.sym);\n+                    scan(tree.guard);\n+                } finally {\n+                    currentTree = prevTree;\n+                    declaredInsideGuard = prevDeclaredInsideGuard;\n+                }\n@@ -3205,0 +3410,1 @@\n+            scan(tree.stats);\n@@ -3259,0 +3465,8 @@\n+        @Override\n+        public void visitVarDef(JCVariableDecl tree) {\n+            if (declaredInsideGuard != null) {\n+                declaredInsideGuard.enter(tree.sym);\n+            }\n+            super.visitVarDef(tree);\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":461,"deletions":247,"binary":false,"changes":708,"status":"modified"},{"patch":"@@ -706,1 +706,1 @@\n-            cases.add(make.Case(JCCase.STATEMENT, List.of(make.ConstantCaseLabel(make.Literal(entry.getKey()))), stmts, null));\n+            cases.add(make.Case(JCCase.STATEMENT, List.of(make.ConstantCaseLabel(make.Literal(entry.getKey()))), null, stmts, null));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import com.sun.source.tree.EnhancedForLoopTree;\n@@ -3561,9 +3560,5 @@\n-\n-            Assert.check(tree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.VARIABLE);\n-            JCVariableDecl jcVariableDecl = (JCVariableDecl) tree.varOrRecordPattern;\n-\n-            JCVariableDecl loopvardef = (JCVariableDecl)make.VarDef(jcVariableDecl.mods,\n-                    jcVariableDecl.name,\n-                    jcVariableDecl.vartype,\n-                    loopvarinit).setType(jcVariableDecl.type);\n-            loopvardef.sym = jcVariableDecl.sym;\n+            JCVariableDecl loopvardef = (JCVariableDecl)make.VarDef(tree.var.mods,\n+                                                  tree.var.name,\n+                                                  tree.var.vartype,\n+                                                  loopvarinit).setType(tree.var.type);\n+            loopvardef.sym = tree.var.sym;\n@@ -3571,2 +3566,1 @@\n-                    Block(0, List.of(loopvardef, tree.body));\n-\n+                Block(0, List.of(loopvardef, tree.body));\n@@ -3651,5 +3645,1 @@\n-\n-            Assert.check(tree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.VARIABLE);\n-\n-            JCVariableDecl var = (JCVariableDecl) tree.varOrRecordPattern;\n-            if (var.type.isPrimitive())\n+            if (tree.var.type.isPrimitive())\n@@ -3658,6 +3648,6 @@\n-                vardefinit = make.TypeCast(var.type, vardefinit);\n-            JCVariableDecl indexDef = (JCVariableDecl) make.VarDef(var.mods,\n-                    var.name,\n-                    var.vartype,\n-                    vardefinit).setType(var.type);\n-            indexDef.sym = var.sym;\n+                vardefinit = make.TypeCast(tree.var.type, vardefinit);\n+            JCVariableDecl indexDef = (JCVariableDecl)make.VarDef(tree.var.mods,\n+                                                  tree.var.name,\n+                                                  tree.var.vartype,\n+                                                  vardefinit).setType(tree.var.type);\n+            indexDef.sym = tree.var.sym;\n@@ -3667,4 +3657,4 @@\n-                    ForLoop(List.of(init),\n-                            cond,\n-                            List.nil(),\n-                            body));\n+                ForLoop(List.of(init),\n+                        cond,\n+                        List.nil(),\n+                        body));\n@@ -3756,1 +3746,1 @@\n-            JCCase c = make.Case(JCCase.STATEMENT, List.of(make.DefaultCaseLabel()), List.of(thr), null);\n+            JCCase c = make.Case(JCCase.STATEMENT, List.of(make.DefaultCaseLabel()), null, List.of(thr), null);\n@@ -3783,0 +3773,1 @@\n+                                                           null,\n@@ -3877,1 +3868,1 @@\n-                newCases.append(make.Case(JCCase.STATEMENT, List.of(make.ConstantCaseLabel(pat)), c.stats, null));\n+                newCases.append(make.Case(JCCase.STATEMENT, List.of(make.ConstantCaseLabel(pat)), null, c.stats, null));\n@@ -4049,0 +4040,1 @@\n+                                            null,\n@@ -4084,0 +4076,1 @@\n+                                    null,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":22,"deletions":29,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-            case PARENTHESIZEDPATTERN: case TYPETEST:\n+            case TYPETEST:\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MatchBindingsComputer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -960,4 +960,0 @@\n-    @Override\n-    public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import com.sun.tools.javac.code.Symbol.DynamicVarSymbol;\n+import com.sun.tools.javac.code.Symbol.MethodHandleSymbol;\n@@ -58,1 +60,0 @@\n-import com.sun.tools.javac.tree.JCTree.JCThrow;\n@@ -97,1 +98,0 @@\n-import com.sun.tools.javac.tree.JCTree.JCParenthesizedPattern;\n@@ -108,0 +108,2 @@\n+import com.sun.tools.javac.util.JCDiagnostic;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n@@ -199,2 +201,1 @@\n-            \/\/first, resolve any parenthesized and record patterns:\n-            pattern = TreeInfo.skipParens(pattern);\n+            \/\/first, resolve any record patterns:\n@@ -283,5 +284,0 @@\n-    @Override\n-    public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n-        result = translate(tree.pattern);\n-    }\n-\n@@ -317,1 +313,1 @@\n-            JCPattern nestedPattern = TreeInfo.skipParens(nestedPatterns.head);\n+            JCPattern nestedPattern = nestedPatterns.head;\n@@ -393,2 +389,0 @@\n-            Assert.check(preview.isEnabled());\n-            Assert.check(preview.usesPreview(env.toplevel.sourcefile));\n@@ -439,1 +433,2 @@\n-                c.head.labels = c.head.labels.map(l -> {\n+                JCCase cse = c.head;\n+                cse.labels = cse.labels.map(l -> {\n@@ -441,1 +436,1 @@\n-                        JCPattern pattern = TreeInfo.skipParens(patternLabel.pat);\n+                        JCPattern pattern = patternLabel.pat;\n@@ -445,2 +440,4 @@\n-                            if (patternLabel.guard != null) {\n-                                guard = mergeConditions(guard, patternLabel.guard);\n+                            if (cse.guard != null) {\n+                                cse.guard = mergeConditions(guard, cse.guard);\n+                            } else {\n+                                cse.guard = guard;\n@@ -448,1 +445,1 @@\n-                            return make.PatternCaseLabel(deconstructed.primaryPattern(), guard);\n+                            return make.PatternCaseLabel(deconstructed.primaryPattern());\n@@ -537,2 +534,2 @@\n-                        if (label.guard != null) {\n-                            JCExpression guard = translate(label.guard);\n+                        if (c.guard != null) {\n+                            JCExpression guard = translate(c.guard);\n@@ -719,1 +716,1 @@\n-                        if (accummulatedFirstLabel.guard instanceof JCBinary binOp) {\n+                        if (accummulated.guard instanceof JCBinary binOp) {\n@@ -724,1 +721,1 @@\n-                            instanceofCheck = (JCInstanceOf) accummulatedFirstLabel.guard;\n+                            instanceofCheck = (JCInstanceOf) accummulated.guard;\n@@ -733,1 +730,1 @@\n-                                    make.PatternCaseLabel(binding, newGuard));\n+                                    make.PatternCaseLabel(binding));\n@@ -735,1 +732,1 @@\n-                            newLabel = List.of(make.PatternCaseLabel(binding, newGuard));\n+                            newLabel = List.of(make.PatternCaseLabel(binding));\n@@ -737,1 +734,2 @@\n-                        nestedCases.add(make.Case(CaseKind.STATEMENT, newLabel, accummulated.stats, null));\n+                        nestedCases.add(make.Case(CaseKind.STATEMENT, newLabel, newGuard,\n+                                                  accummulated.stats, null));\n@@ -748,0 +746,1 @@\n+                                                  null,\n@@ -755,1 +754,0 @@\n-                    leadingTest.guard = null;\n@@ -758,0 +756,1 @@\n+                                         null,\n@@ -779,1 +778,1 @@\n-                if (patternLabel.guard instanceof JCBinary binOp &&\n+                if (c.head.guard instanceof JCBinary binOp &&\n@@ -786,1 +785,1 @@\n-                } else if (patternLabel.guard instanceof JCInstanceOf instanceofCheck &&\n+                } else if (c.head.guard instanceof JCInstanceOf instanceofCheck &&\n@@ -838,1 +837,1 @@\n-        } else if (l.hasTag(Tag.CONSTANTCASELABEL)&& !TreeInfo.isNullCaseLabel(l)) {\n+        } else if (l.hasTag(Tag.CONSTANTCASELABEL) && !TreeInfo.isNullCaseLabel(l)) {\n@@ -840,2 +839,7 @@\n-            if ((expr.type.tsym.flags_field & Flags.ENUM) != 0) {\n-                return LoadableConstant.String(((JCIdent) expr).name.toString());\n+            Symbol sym = TreeInfo.symbol(expr);\n+            if (sym != null && sym.isEnum() && sym.kind == Kind.VAR) {\n+                if (selector.tsym.isEnum()) {\n+                    return LoadableConstant.String(sym.getSimpleName().toString());\n+                } else {\n+                    return createEnumDesc(l.pos(), (ClassSymbol) sym.owner, sym.getSimpleName());\n+                }\n@@ -857,0 +861,32 @@\n+    private LoadableConstant createEnumDesc(DiagnosticPosition pos, ClassSymbol enumClass, Name constant) {\n+        MethodSymbol classDesc = rs.resolveInternalMethod(pos, env, syms.classDescType, names.of, List.of(syms.stringType), List.nil());\n+        MethodSymbol enumDesc = rs.resolveInternalMethod(pos, env, syms.enumDescType, names.of, List.of(syms.classDescType, syms.stringType), List.nil());\n+        return invokeMethodWrapper(pos,\n+                                   enumDesc.asHandle(),\n+                                   invokeMethodWrapper(pos,\n+                                                       classDesc.asHandle(),\n+                                                       LoadableConstant.String(enumClass.flatname.toString())),\n+                                   LoadableConstant.String(constant.toString()));\n+    }\n+\n+    private LoadableConstant invokeMethodWrapper(DiagnosticPosition pos, MethodHandleSymbol toCall, LoadableConstant... params) {\n+        List<Type> bsm_staticArgs = List.of(syms.methodHandleLookupType,\n+                                            syms.stringType,\n+                                            new ClassType(syms.classType.getEnclosingType(),\n+                                                          List.of(syms.botType), \/\/XXX - botType\n+                                                          syms.classType.tsym),\n+                                            syms.methodHandleType,\n+                                            types.makeArrayType(syms.objectType));\n+\n+        MethodSymbol bsm = rs.resolveInternalMethod(pos, env, syms.constantBootstrapsType,\n+                names.invoke, bsm_staticArgs, List.nil());\n+\n+        LoadableConstant[] actualParams = new LoadableConstant[params.length + 1];\n+\n+        actualParams[0] = toCall;\n+\n+        System.arraycopy(params, 0, actualParams, 1, params.length);\n+\n+        return new DynamicVarSymbol(bsm.name, bsm.owner, bsm.asHandle(), toCall.getReturnType(), actualParams);\n+    }\n+\n@@ -901,71 +937,0 @@\n-    @Override\n-    public void visitForeachLoop(JCTree.JCEnhancedForLoop tree) {\n-        bindingContext = new BasicBindingContext();\n-        VarSymbol prevCurrentValue = currentValue;\n-        try {\n-            if (tree.varOrRecordPattern instanceof JCRecordPattern jcRecordPattern) {\n-                \/**\n-                 * A statement of the form\n-                 *\n-                 * <pre>\n-                 *     for (<pattern> : coll ) stmt ;\n-                 * <\/pre>\n-                 *\n-                 * (where coll implements {@code Iterable<R>}) gets translated to\n-                 *\n-                 * <pre>{@code\n-                 *     for (<type-of-coll-item> N$temp : coll) {\n-                 *     switch (N$temp) {\n-                 *         case <pattern>: stmt;\n-                 *         case null: throw new MatchException();\n-                 *     }\n-                 * }<\/pre>\n-                 *\n-                 *\/\n-                Type selectorType = types.classBound(tree.elementType);\n-\n-                currentValue = new VarSymbol(Flags.FINAL | Flags.SYNTHETIC,\n-                        names.fromString(\"patt\" + tree.pos + target.syntheticNameChar() + \"temp\"),\n-                        selectorType,\n-                        currentMethodSym);\n-\n-                JCStatement newForVariableDeclaration =\n-                        make.at(tree.pos).VarDef(currentValue, null).setType(selectorType);\n-\n-                List<JCExpression> nestedNPEParams = List.of(makeNull());\n-                JCNewClass nestedNPE = makeNewClass(syms.nullPointerExceptionType, nestedNPEParams);\n-\n-                List<JCExpression> matchExParams = List.of(makeNull(), nestedNPE);\n-                JCThrow thr = make.Throw(makeNewClass(syms.matchExceptionType, matchExParams));\n-\n-                JCCase caseNull = make.Case(JCCase.STATEMENT, List.of(make.ConstantCaseLabel(makeNull())), List.of(thr), null);\n-\n-                JCCase casePattern = make.Case(CaseTree.CaseKind.STATEMENT,\n-                        List.of(make.PatternCaseLabel(jcRecordPattern, null)),\n-                        List.of(translate(tree.body)),\n-                        null);\n-\n-                JCSwitch switchBody =\n-                        make.Switch(make.Ident(currentValue).setType(selectorType),\n-                                List.of(caseNull, casePattern));\n-\n-                switchBody.patternSwitch = true;\n-\n-                \/\/ re-using the same node to eliminate the need to re-patch targets (break\/continue)\n-                tree.varOrRecordPattern = newForVariableDeclaration.setType(selectorType);\n-                tree.expr = translate(tree.expr);\n-                tree.body = translate(switchBody);\n-\n-                JCTree.JCEnhancedForLoop newForEach = tree;\n-\n-                result = bindingContext.decorateStatement(newForEach);\n-            } else {\n-                super.visitForeachLoop(tree);\n-                result = bindingContext.decorateStatement(tree);\n-            }\n-        } finally {\n-            currentValue = prevCurrentValue;\n-            bindingContext.pop();\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":66,"deletions":101,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -515,1 +515,1 @@\n-        tree.varOrRecordPattern = translate(tree.varOrRecordPattern, null);\n+        tree.var = translate(tree.var, null);\n@@ -554,0 +554,1 @@\n+        tree.guard = translate(tree.guard, syms.booleanType);\n@@ -572,1 +573,0 @@\n-        tree.guard = translate(tree.guard, syms.booleanType);\n@@ -587,6 +587,0 @@\n-    @Override\n-    public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n-        tree.pattern = translate(tree.pattern, null);\n-        result = tree;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -300,1 +300,3 @@\n-        result = scan(tree.labels, that.labels) && scan(tree.stats, that.stats);\n+        result = scan(tree.labels, that.labels) &&\n+                 scan(tree.guard, that.guard) &&\n+                 scan(tree.stats, that.stats);\n@@ -312,1 +314,1 @@\n-        result = scan(tree.pat, that.pat) && scan(tree.guard, that.guard);\n+        result = scan(tree.pat, that.pat);\n@@ -391,1 +393,1 @@\n-                scan(tree.varOrRecordPattern, that.varOrRecordPattern)\n+                scan(tree.var, that.var)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TreeDiffer.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -296,1 +296,1 @@\n-            sr.mergeWith(csp(tree.varOrRecordPattern));\n+            sr.mergeWith(csp(tree.var));\n@@ -326,0 +326,1 @@\n+            sr.mergeWith(csp(tree.guard));\n@@ -346,1 +347,0 @@\n-            sr.mergeWith(csp(tree.guard));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/CRTable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -944,0 +944,9 @@\n+        int lastBootstrapMethods;\n+        do {\n+            lastBootstrapMethods = poolWriter.bootstrapMethods.size();\n+            for (BsmKey bsmKey : java.util.List.copyOf(poolWriter.bootstrapMethods.keySet())) {\n+                for (LoadableConstant arg : bsmKey.staticArgs) {\n+                    poolWriter.putConstant(arg);\n+                }\n+            }\n+        } while (lastBootstrapMethods < poolWriter.bootstrapMethods.size());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1538,5 +1538,0 @@\n-            public void visitParenthesizedPattern(JCTree.JCParenthesizedPattern tree) {\n-                hasPatterns = true;\n-                super.visitParenthesizedPattern(tree);\n-            }\n-            @Override\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -833,0 +833,1 @@\n+\n@@ -836,7 +837,8 @@\n-        if (token.kind == LPAREN && parsedType == null) {\n-            \/\/parenthesized pattern:\n-            int startPos = token.pos;\n-            accept(LPAREN);\n-            JCPattern p = parsePattern(token.pos, null, null, true, false);\n-            accept(RPAREN);\n-            pattern = toP(F.at(startPos).ParenthesizedPattern(p));\n+        mods = mods != null ? mods : optFinal(0);\n+        JCExpression e;\n+        if (parsedType == null) {\n+            boolean var = token.kind == IDENTIFIER && token.name() == names.var;\n+            e = unannotatedType(allowVar, TYPE | NOLAMBDA);\n+            if (var) {\n+                e = null;\n+            }\n@@ -844,8 +846,12 @@\n-            mods = mods != null ? mods : optFinal(0);\n-            JCExpression e;\n-            if (parsedType == null) {\n-                boolean var = token.kind == IDENTIFIER && token.name() == names.var;\n-                e = unannotatedType(allowVar, TYPE | NOLAMBDA);\n-                if (var) {\n-                    e = null;\n-                }\n+            e = parsedType;\n+        }\n+        if (token.kind == LPAREN) {\n+            \/\/deconstruction pattern:\n+            checkSourceLevel(Feature.RECORD_PATTERNS);\n+            ListBuffer<JCPattern> nested = new ListBuffer<>();\n+            if (!peekToken(RPAREN)) {\n+                do {\n+                    nextToken();\n+                    JCPattern nestedPattern = parsePattern(token.pos, null, null, true, false);\n+                    nested.append(nestedPattern);\n+                } while (token.kind == COMMA);\n@@ -853,1 +859,1 @@\n-                e = parsedType;\n+                nextToken();\n@@ -855,12 +861,9 @@\n-            if (token.kind == LPAREN) {\n-                \/\/deconstruction pattern:\n-                checkSourceLevel(Feature.RECORD_PATTERNS);\n-                ListBuffer<JCPattern> nested = new ListBuffer<>();\n-                if (!peekToken(RPAREN)) {\n-                    do {\n-                        nextToken();\n-                        JCPattern nestedPattern = parsePattern(token.pos, null, null, true, false);\n-                        nested.append(nestedPattern);\n-                    } while (token.kind == COMMA);\n-                } else {\n-                    nextToken();\n+            accept(RPAREN);\n+            pattern = toP(F.at(pos).RecordPattern(e, nested.toList()));\n+            if (mods.annotations.nonEmpty()) {\n+                log.error(mods.annotations.head.pos(), Errors.RecordPatternsAnnotationsNotAllowed);\n+            }\n+            new TreeScanner() {\n+                @Override\n+                public void visitAnnotatedType(JCAnnotatedType tree) {\n+                    log.error(tree.pos(), Errors.RecordPatternsAnnotationsNotAllowed);\n@@ -868,6 +871,6 @@\n-                accept(RPAREN);\n-                pattern = toP(F.at(pos).RecordPattern(e, nested.toList()));\n-            } else {\n-                \/\/type test pattern:\n-                JCVariableDecl var = toP(F.at(token.pos).VarDef(mods, ident(), e, null));\n-                pattern = toP(F.at(pos).BindingPattern(var));\n+            }.scan(e);\n+        } else {\n+            \/\/type test pattern:\n+            JCVariableDecl var = toP(F.at(token.pos).VarDef(mods, ident(), e, null));\n+            if (e == null) {\n+                var.startPos = pos;\n@@ -875,0 +878,1 @@\n+            pattern = toP(F.at(pos).BindingPattern(var));\n@@ -1623,0 +1627,1 @@\n+        JCExpression guard = parseGuard(pats.last());\n@@ -1648,1 +1653,1 @@\n-        caseExprs.append(toP(F.at(casePos).Case(kind, pats.toList(), stats, body)));\n+        caseExprs.append(toP(F.at(casePos).Case(kind, pats.toList(), guard, stats, body)));\n@@ -2913,15 +2918,6 @@\n-            JCTree pattern;\n-\n-            ForInitResult initResult = analyzeForInit();\n-\n-            if (initResult == ForInitResult.RecordPattern) {\n-                int patternPos = token.pos;\n-                JCModifiers mods = optFinal(0);\n-                int typePos = token.pos;\n-                JCExpression type = unannotatedType(false);\n-\n-                pattern = parsePattern(patternPos, mods, type, false, false);\n-\n-                if (pattern != null) {\n-                    checkSourceLevel(token.pos, Feature.PATTERN_SWITCH);\n-                }\n+            List<JCStatement> inits = token.kind == SEMI ? List.nil() : forInit();\n+            if (inits.length() == 1 &&\n+                inits.head.hasTag(VARDEF) &&\n+                ((JCVariableDecl) inits.head).init == null &&\n+                token.kind == COLON) {\n+                JCVariableDecl var = (JCVariableDecl)inits.head;\n@@ -2932,1 +2928,1 @@\n-                return F.at(pos).ForeachLoop(pattern, expr, body);\n+                return F.at(pos).ForeachLoop(var, expr, body);\n@@ -2934,20 +2930,7 @@\n-                List<JCStatement> inits = token.kind == SEMI ? List.nil() : forInit();\n-                if (inits.length() == 1 &&\n-                        inits.head.hasTag(VARDEF) &&\n-                        ((JCVariableDecl) inits.head).init == null &&\n-                        token.kind == COLON) {\n-                    JCVariableDecl var = (JCVariableDecl) inits.head;\n-                    accept(COLON);\n-                    JCExpression expr = parseExpression();\n-                    accept(RPAREN);\n-                    JCStatement body = parseStatementAsBlock();\n-                    return F.at(pos).ForeachLoop(var, expr, body);\n-                } else {\n-                    accept(SEMI);\n-                    JCExpression cond = token.kind == SEMI ? null : parseExpression();\n-                    accept(SEMI);\n-                    List<JCExpressionStatement> steps = token.kind == RPAREN ? List.nil() : forUpdate();\n-                    accept(RPAREN);\n-                    JCStatement body = parseStatementAsBlock();\n-                    return F.at(pos).ForLoop(inits, cond, steps, body);\n-                }\n+                accept(SEMI);\n+                JCExpression cond = token.kind == SEMI ? null : parseExpression();\n+                accept(SEMI);\n+                List<JCExpressionStatement> steps = token.kind == RPAREN ? List.nil() : forUpdate();\n+                accept(RPAREN);\n+                JCStatement body = parseStatementAsBlock();\n+                return F.at(pos).ForLoop(inits, cond, steps, body);\n@@ -3070,85 +3053,0 @@\n-    private enum ForInitResult {\n-        LocalVarDecl,\n-        RecordPattern\n-    }\n-\n-    @SuppressWarnings(\"fallthrough\")\n-    ForInitResult analyzeForInit() {\n-        boolean inType = false;\n-        boolean inSelectionAndParenthesis = false;\n-        int typeParameterPossibleStart = -1;\n-        outer: for (int lookahead = 0; ; lookahead++) {\n-            TokenKind tk = S.token(lookahead).kind;\n-            switch (tk) {\n-                case DOT:\n-                    if (inType) break; \/\/ in qualified type\n-                case COMMA:\n-                    typeParameterPossibleStart = lookahead;\n-                    break;\n-                case QUES:\n-                    \/\/ \"?\" only allowed in a type parameter position - otherwise it's an expression\n-                    if (typeParameterPossibleStart == lookahead - 1) break;\n-                    else return ForInitResult.LocalVarDecl;\n-                case EXTENDS: case SUPER: case AMP:\n-                case GTGTGT: case GTGT: case GT:\n-                case FINAL: case ELLIPSIS:\n-                    break;\n-                case BYTE: case SHORT: case INT: case LONG: case FLOAT:\n-                case DOUBLE: case BOOLEAN: case CHAR: case VOID:\n-                    if (peekToken(lookahead, IDENTIFIER)) {\n-                        return inSelectionAndParenthesis ? ForInitResult.RecordPattern\n-                                                         : ForInitResult.LocalVarDecl;\n-                    }\n-                    break;\n-                case LPAREN:\n-                    if (lookahead != 0 && inType) {\n-                        inSelectionAndParenthesis = true;\n-                        inType = false;\n-                    }\n-                    break;\n-                case RPAREN:\n-                    \/\/ a method call in the init part or a record pattern?\n-                    if (inSelectionAndParenthesis) {\n-                        if (peekToken(lookahead, DOT)  ||\n-                                peekToken(lookahead, SEMI) ||\n-                                peekToken(lookahead, ARROW)) {\n-                            return ForInitResult.LocalVarDecl;\n-                        }\n-                        else if(peekToken(lookahead, COLON)) {\n-                            return ForInitResult.RecordPattern;\n-                        }\n-                        break;\n-                    }\n-                case UNDERSCORE:\n-                case ASSERT:\n-                case ENUM:\n-                case IDENTIFIER:\n-                    if (lookahead == 0) {\n-                        inType = true;\n-                    }\n-                    break;\n-                case MONKEYS_AT: {\n-                    int prevLookahead = lookahead;\n-                    lookahead = skipAnnotation(lookahead);\n-                    if (typeParameterPossibleStart == prevLookahead - 1) {\n-                        \/\/ move possible start of type param after the anno\n-                        typeParameterPossibleStart = lookahead;\n-                    }\n-                    break;\n-                }\n-                case LBRACKET:\n-                    if (peekToken(lookahead, RBRACKET)) {\n-                        return inSelectionAndParenthesis ? ForInitResult.RecordPattern\n-                                                         : ForInitResult.LocalVarDecl;\n-                    }\n-                    return ForInitResult.LocalVarDecl;\n-                case LT:\n-                    typeParameterPossibleStart = lookahead;\n-                    break;\n-                default:\n-                    \/\/this includes EOF\n-                    return ForInitResult.LocalVarDecl;\n-            }\n-        }\n-    }\n-\n@@ -3237,0 +3135,1 @@\n+            JCExpression guard = parseGuard(pats.last());\n@@ -3254,1 +3153,1 @@\n-            c = F.at(pos).Case(caseKind, pats.toList(), stats, body);\n+            c = F.at(pos).Case(caseKind, pats.toList(), guard, stats, body);\n@@ -3262,0 +3161,1 @@\n+            JCExpression guard = parseGuard(defaultPattern);\n@@ -3279,1 +3179,1 @@\n-            c = F.at(pos).Case(caseKind, List.of(defaultPattern), stats, body);\n+            c = F.at(pos).Case(caseKind, List.of(defaultPattern), guard, stats, body);\n@@ -3307,6 +3207,1 @@\n-                JCExpression guard = null;\n-                if (token.kind == IDENTIFIER && token.name() == names.when) {\n-                    nextToken();\n-                    guard = term(EXPR | NOLAMBDA);\n-                }\n-                return toP(F.at(patternPos).PatternCaseLabel(p, guard));\n+                return toP(F.at(patternPos).PatternCaseLabel(p));\n@@ -3322,0 +3217,16 @@\n+    private JCExpression parseGuard(JCCaseLabel label) {\n+        JCExpression guard = null;\n+\n+        if (token.kind == IDENTIFIER && token.name() == names.when) {\n+            int pos = token.pos;\n+\n+            nextToken();\n+            guard = term(EXPR | NOLAMBDA);\n+\n+            if (!(label instanceof JCPatternCaseLabel)) {\n+                guard = syntaxError(pos, List.of(guard), Errors.GuardNotAllowed);\n+            }\n+        }\n+\n+        return guard;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":75,"deletions":164,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -531,0 +531,3 @@\n+compiler.err.guard.not.allowed=\\\n+    guards are only allowed for case with a pattern\n+\n@@ -534,0 +537,4 @@\n+# 0: symbol\n+compiler.err.cannot.assign.not.declared.guard=\\\n+    cannot assign to {0}, as it was not declared inside the guard\n+\n@@ -622,4 +629,0 @@\n-# 0: type, 1: type\n-compiler.err.foreach.not.exhaustive.on.type=\\\n-    Pattern {0} is not exhaustive on {1}\n-\n@@ -1503,4 +1506,0 @@\n-# 0: type, 1: type\n-compiler.err.instanceof.pattern.no.subtype=\\\n-    expression type {0} is a subtype of pattern type {1}\n-\n@@ -3857,0 +3856,3 @@\n+compiler.err.record.patterns.annotations.not.allowed=\\\n+    annotations not allowed on record patterns\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -243,1 +243,0 @@\n-        PARENTHESIZEDPATTERN,\n@@ -1225,1 +1224,1 @@\n-        public JCTree varOrRecordPattern;\n+        public JCVariableDecl var;\n@@ -1228,4 +1227,2 @@\n-        public Type elementType;\n-\n-        protected JCEnhancedForLoop(JCTree varOrRecordPattern, JCExpression expr, JCStatement body) {\n-            this.varOrRecordPattern = varOrRecordPattern;\n+        protected JCEnhancedForLoop(JCVariableDecl var, JCExpression expr, JCStatement body) {\n+            this.var = var;\n@@ -1241,5 +1238,1 @@\n-        public JCVariableDecl getVariable() {\n-            return varOrRecordPattern instanceof JCVariableDecl var ? var : null;\n-        }\n-        @DefinedBy(Api.COMPILER_TREE)\n-        public JCTree getVariableOrRecordPattern() { return varOrRecordPattern; }\n+        public JCVariableDecl getVariable() { return var; }\n@@ -1258,4 +1251,0 @@\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public EnhancedForLoopTree.DeclarationKind getDeclarationKind() {\n-            return varOrRecordPattern.hasTag(VARDEF) ? DeclarationKind.VARIABLE : DeclarationKind.PATTERN;\n-        }\n@@ -1337,0 +1326,1 @@\n+        public JCExpression guard;\n@@ -1341,0 +1331,1 @@\n+                         JCExpression guard,\n@@ -1346,0 +1337,1 @@\n+            this.guard = guard;\n@@ -1368,0 +1360,2 @@\n+        public JCExpression getGuard() { return guard; }\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n@@ -2255,4 +2249,0 @@\n-        @DefinedBy(Api.COMPILER_TREE)\n-        public TestKind getTestKind() {\n-            return pattern instanceof JCPatternCaseLabel ? TestKind.PATTERN : TestKind.TYPE;\n-        }\n@@ -2381,1 +2371,0 @@\n-        public JCExpression guard;\n@@ -2383,1 +2372,1 @@\n-        protected JCPatternCaseLabel(JCPattern pat, JCExpression guard) {\n+        protected JCPatternCaseLabel(JCPattern pat) {\n@@ -2385,1 +2374,0 @@\n-            this.guard = guard;\n@@ -2393,5 +2381,0 @@\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public JCExpression getGuard() {\n-            return guard;\n-        }\n-\n@@ -2421,35 +2404,0 @@\n-    public static class JCParenthesizedPattern extends JCPattern\n-            implements ParenthesizedPatternTree {\n-        public JCPattern pattern;\n-\n-        public JCParenthesizedPattern(JCPattern pattern) {\n-            this.pattern = pattern;\n-        }\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public PatternTree getPattern() {\n-            return pattern;\n-        }\n-\n-        @Override\n-        public void accept(Visitor v) {\n-            v.visitParenthesizedPattern(this);\n-        }\n-\n-        @DefinedBy(Api.COMPILER_TREE)\n-        public Kind getKind() {\n-            return Kind.PARENTHESIZED_PATTERN;\n-        }\n-\n-        @Override\n-        @DefinedBy(Api.COMPILER_TREE)\n-        public <R, D> R accept(TreeVisitor<R, D> v, D d) {\n-            return v.visitParenthesizedPattern(this, d);\n-        }\n-\n-        @Override\n-        public Tag getTag() {\n-            return PARENTHESIZEDPATTERN;\n-        }\n-    }\n-\n@@ -3490,1 +3438,1 @@\n-        JCEnhancedForLoop ForeachLoop(JCTree var, JCExpression expr, JCStatement body);\n+        JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body);\n@@ -3494,1 +3442,1 @@\n-        JCCase Case(CaseTree.CaseKind caseKind, List<JCCaseLabel> labels,\n+        JCCase Case(CaseTree.CaseKind caseKind, List<JCCaseLabel> labels, JCExpression guard,\n@@ -3604,1 +3552,0 @@\n-        public void visitParenthesizedPattern(JCParenthesizedPattern that) { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":12,"deletions":65,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -817,1 +817,1 @@\n-            printExpr(tree.varOrRecordPattern);\n+            printExpr(tree.var);\n@@ -865,0 +865,4 @@\n+            if (tree.guard != null) {\n+                print(\" when \");\n+                print(tree.guard);\n+            }\n@@ -907,4 +911,0 @@\n-            if (tree.guard != null) {\n-                print(\" when \");\n-                print(tree.guard);\n-            }\n@@ -944,11 +944,0 @@\n-    @Override\n-    public void visitParenthesizedPattern(JCParenthesizedPattern patt) {\n-        try {\n-            print('(');\n-            printExpr(patt.pattern);\n-            print(')');\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -156,0 +156,1 @@\n+        JCExpression guard = copy(t.guard, p);\n@@ -164,1 +165,1 @@\n-        return M.at(t.pos).Case(t.caseKind, labels, stats, body);\n+        return M.at(t.pos).Case(t.caseKind, labels, guard, stats, body);\n@@ -226,1 +227,1 @@\n-        JCTree varOrRecordPattern = copy(t.varOrRecordPattern, p);\n+        JCVariableDecl var = copy(t.var, p);\n@@ -229,1 +230,1 @@\n-        return M.at(t.pos).ForeachLoop(varOrRecordPattern, expr, body);\n+        return M.at(t.pos).ForeachLoop(var, expr, body);\n@@ -508,7 +509,0 @@\n-    @DefinedBy(Api.COMPILER_TREE)\n-    public JCTree visitParenthesizedPattern(ParenthesizedPatternTree node, P p) {\n-        JCParenthesizedPattern t = (JCParenthesizedPattern) node;\n-        JCPattern pattern = copy(t.pattern, p);\n-        return M.at(t.pos).ParenthesizedPattern(pattern);\n-    }\n-\n@@ -532,2 +526,1 @@\n-        JCExpression guard = copy(t.guard, p);\n-        return M.at(t.pos).PatternCaseLabel(pat, guard);\n+        return M.at(t.pos).PatternCaseLabel(pat);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -651,4 +651,0 @@\n-            case PARENTHESIZEDPATTERN: {\n-                JCParenthesizedPattern node = (JCParenthesizedPattern) tree;\n-                return getEndPos(node.pattern, endPosTable);\n-            }\n@@ -858,9 +854,0 @@\n-    \/** Skip parens and return the enclosed expression\n-     *\/\n-    public static JCPattern skipParens(JCPattern tree) {\n-        while (tree.hasTag(PARENTHESIZEDPATTERN)) {\n-            tree = ((JCParenthesizedPattern) tree).pattern;\n-        }\n-        return tree;\n-    }\n-\n@@ -1361,1 +1348,0 @@\n-            case PARENTHESIZEDPATTERN -> primaryPatternType(((JCParenthesizedPattern) pat).pattern);\n@@ -1370,1 +1356,0 @@\n-            case PARENTHESIZEDPATTERN -> primaryPatternTypeTree(((JCParenthesizedPattern) pat).pattern);\n@@ -1383,5 +1368,2 @@\n-    public static boolean unguardedCaseLabel(JCCaseLabel cse) {\n-        if (!cse.hasTag(PATTERNCASELABEL)) {\n-            return true;\n-        }\n-        JCExpression guard = ((JCPatternCaseLabel) cse).guard;\n+    public static boolean unguardedCase(JCCase cse) {\n+        JCExpression guard = cse.guard;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -277,2 +277,2 @@\n-    public JCEnhancedForLoop ForeachLoop(JCTree varOrRecordPattern, JCExpression expr, JCStatement body) {\n-        JCEnhancedForLoop tree = new JCEnhancedForLoop(varOrRecordPattern, expr, body);\n+    public JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body) {\n+        JCEnhancedForLoop tree = new JCEnhancedForLoop(var, expr, body);\n@@ -296,2 +296,2 @@\n-                       List<JCStatement> stats, JCTree body) {\n-        JCCase tree = new JCCase(caseKind, labels, stats, body);\n+                       JCExpression guard, List<JCStatement> stats, JCTree body) {\n+        JCCase tree = new JCCase(caseKind, labels, guard, stats, body);\n@@ -504,8 +504,2 @@\n-    public JCPatternCaseLabel PatternCaseLabel(JCPattern pat, JCExpression guard) {\n-        JCPatternCaseLabel tree = new JCPatternCaseLabel(pat, guard);\n-        tree.pos = pos;\n-        return tree;\n-    }\n-\n-    public JCParenthesizedPattern ParenthesizedPattern(JCPattern pattern) {\n-        JCParenthesizedPattern tree = new JCParenthesizedPattern(pattern);\n+    public JCPatternCaseLabel PatternCaseLabel(JCPattern pat) {\n+        JCPatternCaseLabel tree = new JCPatternCaseLabel(pat);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-        scan(tree.varOrRecordPattern);\n+        scan(tree.var);\n@@ -181,0 +181,1 @@\n+        scan(tree.guard);\n@@ -322,6 +323,0 @@\n-        scan(tree.guard);\n-    }\n-\n-    @Override\n-    public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n-        scan(tree.pattern);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-        tree.varOrRecordPattern = translate(tree.varOrRecordPattern);\n+        tree.var = translate(tree.var);\n@@ -211,0 +211,1 @@\n+        tree.guard = translate(tree.guard);\n@@ -380,7 +381,0 @@\n-        tree.guard = translate(tree.guard);\n-        result = tree;\n-    }\n-\n-    @Override\n-    public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n-        tree.pattern = translate(tree.pattern);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+    public final Name invoke;\n@@ -98,0 +99,1 @@\n+    public final Name of;\n@@ -224,0 +226,1 @@\n+    public final Name enumConstant;\n@@ -285,0 +288,1 @@\n+        invoke = fromString(\"invoke\");\n@@ -288,0 +292,1 @@\n+        of = fromString(\"of\");\n@@ -418,0 +423,1 @@\n+        enumConstant = fromString(\"enumConstant\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.lang.Enum.EnumDesc;\n+import java.lang.constant.ClassDesc;\n@@ -32,0 +34,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -36,0 +39,2 @@\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n@@ -161,0 +166,22 @@\n+    public void testSwitchLabelTypes() throws Throwable {\n+        enum E {A}\n+        try {\n+            testType(E.A, 0, -1, E.A);\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IllegalArgumentException ex) {\n+            \/\/OK, expected\n+        }\n+    }\n+\n+    public void testSwitchQualifiedEnum() throws Throwable {\n+        enum E {A, B, C}\n+        Object[] labels = new Object[] {\n+            EnumDesc.of(ClassDesc.of(E.class.getName()), \"A\"),\n+            EnumDesc.of(ClassDesc.of(E.class.getName()), \"B\"),\n+            EnumDesc.of(ClassDesc.of(E.class.getName()), \"C\")\n+        };\n+        testType(E.A, 0, 0, labels);\n+        testType(E.B, 0, 1, labels);\n+        testType(E.C, 0, 2, labels);\n+    }\n+\n@@ -191,0 +218,96 @@\n+\n+    private static AtomicBoolean enumInitialized = new AtomicBoolean();\n+    public void testEnumInitialization1() throws Throwable {\n+        enumInitialized.set(false);\n+\n+        enum E {\n+            A;\n+\n+            static {\n+                enumInitialized.set(true);\n+            }\n+        }\n+\n+        MethodType enumSwitchType = MethodType.methodType(int.class, E.class, int.class);\n+\n+        CallSite invocation = (CallSite) BSM_ENUM_SWITCH.invoke(MethodHandles.lookup(), \"\", enumSwitchType, new Object[] {\"A\"});\n+        assertFalse(enumInitialized.get());\n+        assertEquals(invocation.dynamicInvoker().invoke(null, 0), -1);\n+        assertFalse(enumInitialized.get());\n+        E e = E.A;\n+        assertTrue(enumInitialized.get());\n+        assertEquals(invocation.dynamicInvoker().invoke(e, 0), 0);\n+    }\n+\n+    public void testEnumInitialization2() throws Throwable {\n+        enumInitialized.set(false);\n+\n+        enum E {\n+            A;\n+\n+            static {\n+                enumInitialized.set(true);\n+            }\n+        }\n+\n+        MethodType switchType = MethodType.methodType(int.class, Object.class, int.class);\n+        Object[] labels = new Object[] {\n+            EnumDesc.of(ClassDesc.of(E.class.getName()), \"A\"),\n+            \"test\"\n+        };\n+        CallSite invocation = (CallSite) BSM_TYPE_SWITCH.invoke(MethodHandles.lookup(), \"\", switchType, labels);\n+        assertFalse(enumInitialized.get());\n+        assertEquals(invocation.dynamicInvoker().invoke(null, 0), -1);\n+        assertFalse(enumInitialized.get());\n+        assertEquals(invocation.dynamicInvoker().invoke(\"test\", 0), 1);\n+        assertFalse(enumInitialized.get());\n+        E e = E.A;\n+        assertTrue(enumInitialized.get());\n+        assertEquals(invocation.dynamicInvoker().invoke(e, 0), 0);\n+    }\n+\n+    public void testIncorrectEnumLabels() throws Throwable {\n+        try {\n+            testEnum(E1.B, 0, -1, \"B\", 1);\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IllegalArgumentException ex) {\n+            \/\/OK\n+        }\n+        try {\n+            testEnum(E1.B, 0, -1, \"B\", null);\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IllegalArgumentException ex) {\n+            \/\/OK\n+        }\n+    }\n+\n+    public void testIncorrectEnumStartIndex() throws Throwable {\n+        try {\n+            testEnum(E1.B, -1, -1, \"B\");\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/OK\n+        }\n+        try {\n+            testEnum(E1.B, 2, -1, \"B\");\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/OK\n+        }\n+    }\n+\n+    public void testIncorrectTypeStartIndex() throws Throwable {\n+        try {\n+            testType(\"\", -1, -1, \"\");\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/OK\n+        }\n+        try {\n+            testType(\"\", 2, -1, \"\");\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/OK\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/runtime\/SwitchBootstrapsTest.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -102,4 +102,1 @@\n-                    })\n-                .withOption(\"--enable-preview\")\n-                .withOption(\"-source\")\n-                .withOption(String.valueOf(Runtime.version().feature()));\n+                    });\n","filename":"test\/langtools\/tools\/javac\/ConditionalExpressionResolvePending.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @compile\/fail\/ref=T8286797.out --enable-preview -source ${jdk.version} -XDrawDiagnostics -XDshould-stop.at=FLOW T8286797.java\n+ * @compile\/fail\/ref=T8286797.out -XDrawDiagnostics -XDshould-stop.at=FLOW T8286797.java\n","filename":"test\/langtools\/tools\/javac\/T8286797.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,2 +3,0 @@\n-- compiler.note.preview.filename: T8286797.java, DEFAULT\n-- compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/T8286797.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/*\n- * @test\n- * @bug 8290379\n- * @summary Parse error with parenthesized pattern and guard using an array\n- * @enablePreview\n- *\/\n-public class T8290379 {\n-    public static void main(String... args) {\n-        assertEquals(0, test(\"test\"));\n-        assertEquals(1, test(Integer.valueOf(42)));\n-    }\n-\n-    public static int test(Object o)\n-    {\n-        int[] arr = {0, 1};\n-\n-        return switch (o) {\n-            case (String s) when (arr[0] == 0) -> 0;\n-            case (Integer i) when arr[1] == 1 -> 1;\n-            default -> 2;\n-        };\n-    }\n-\n-    static void assertEquals(int expected, int actual) {\n-        if (expected != actual) {\n-            throw new AssertionError(\"Expected: \" + expected + \", actual: \" + actual);\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/T8290379.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -28,1 +28,1 @@\n- * @compile\/fail\/ref=T8295447.out -XDrawDiagnostics --enable-preview -source ${jdk.version} T8295447.java\n+ * @compile\/fail\/ref=T8295447.out -XDrawDiagnostics T8295447.java\n","filename":"test\/langtools\/tools\/javac\/T8295447.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,2 +4,0 @@\n-- compiler.note.preview.filename: T8295447.java, DEFAULT\n-- compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/T8295447.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8297602\n- * @summary Compiler crash with type annotation and generic record during pattern matching\n- * @enablePreview\n- * @compile --enable-preview -source ${jdk.version} -XDrawDiagnostics T8297602.java\n- *\/\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Target;\n-\n-public class T8297602\n-{\n-    void meth(Foo<Integer> p) {\n-        switch(p) {\n-            case Foo<@Annot(field = \"\") Integer>(): {}\n-        };\n-\n-        if (p instanceof Foo<@Annot(field = \"\") Integer>()) {\n-\n-        }\n-    }\n-\n-    @Target({ElementType.TYPE_USE})\n-    @interface Annot {\n-        String field();\n-    }\n-\n-    record Foo<T>() { }\n-}\n","filename":"test\/langtools\/tools\/javac\/T8297602.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -31,1 +31,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/Patterns.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-                     List.of(\"--enable-preview\", \"-source\", System.getProperty(\"java.specification.version\")),\n+                     List.of(),\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/LineNumberTable\/RuleSwitchBreaks.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+compiler.warn.preview.feature.use                       # preview feature support: not generated currently\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.cannot.assign.not.declared.guard\n+\n+class CannotAssignNotDeclaredGuard {\n+    void test(Object i) {\n+        final boolean b;\n+        switch (i) {\n+            case Object o when b = true -> {}\n+            default -> {}\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CannotAssignNotDeclaredGuard.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -28,3 +28,0 @@\n-\/\/ key: compiler.misc.feature.pattern.switch\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantRefNonEffectivelyFinalVar.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+\/\/ key: compiler.err.feature.not.supported.in.source\n@@ -25,2 +26,1 @@\n-\/\/ key: compiler.warn.preview.feature.use\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\/\/ options: -source 20 -Xlint:-options\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CaseNull.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.misc.feature.pattern.switch\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ConstantLabelNotCompatible.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ key: compiler.misc.feature.deconstruction.patterns\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/DeconstructionPatternOnlyRecords.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.misc.feature.pattern.switch\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/DefaultLabelNotAllowed.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.misc.feature.pattern.switch\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/DuplicateUnconditionalPattern.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+\/\/ options: --release 20\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/EnumLabelUnqualified.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.feature.not.supported.in.source.plural\n+\/\/ key: compiler.misc.feature.deconstruction.patterns\n+\/\/ options: -source 20 -Xlint:-options\n+\n+class FeatureDeconstructionPatterns {\n+    Object o;\n+    boolean b = o instanceof R(String s);\n+\n+    record R(Object o) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FeatureDeconstructionPatterns.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -24,0 +24,1 @@\n+\/\/ key:  compiler.err.feature.not.supported.in.source.plural\n@@ -25,4 +26,1 @@\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:-options,preview\n-\n-import java.util.*;\n+\/\/ options: -source 20 -Xlint:-options\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FeatureUnconditionalPatternsInInstanceof.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.misc.feature.pattern.switch\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FlowsThroughFromPattern.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,5 +25,0 @@\n-\/\/ key: compiler.misc.feature.pattern.switch\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ key: compiler.misc.feature.case.null\n-\/\/ key: compiler.warn.preview.feature.use\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FlowsThroughToPattern.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.misc.feature.deconstruction.patterns\n-\/\/ key: compiler.misc.feature.pattern.switch\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ key: compiler.err.foreach.not.exhaustive.on.type\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n-\n-import java.util.List;\n-\n-class ForeachNotExhaustive {\n-    void m(List<Object> points) {\n-        for (Point(var x, var y): points) {\n-            System.out.println();\n-        }\n-    }\n-\n-    record Point(Integer x, Integer y) { }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ForeachNotExhaustive.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.misc.feature.pattern.switch\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/GuardHasConstantFalse.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.guard.not.allowed\n+\n+class GuardNotAllowed {\n+    private void doSwitch(int i, boolean b) {\n+        switch (i) {\n+            case 0 when b -> {}\n+            default -> {}\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/GuardNotAllowed.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.misc.feature.deconstruction.patterns\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/IncorrectNumberOfNestedPatterns.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.instanceof.pattern.no.subtype\n-\n-class InstanceofPatternNoSubtype {\n-    boolean test(Object o) {\n-        return o instanceof Object obj;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/InstanceofPatternNoSubtype.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.misc.feature.case.null\n-\/\/ key: compiler.warn.preview.feature.use\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/InvalidCaseLabelCombination.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,3 +26,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview --source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NotApplicableTypes.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview --source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NotExhaustiveStatement.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.misc.feature.pattern.switch\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PatternDominated.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PatternExpected.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+\/\/ key: compiler.err.feature.not.supported.in.source.plural\n@@ -25,2 +26,1 @@\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\/\/ options: -source 20 -Xlint:-options\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PatternSwitch.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ key: compiler.misc.feature.deconstruction.patterns\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PatternTypeCannotInfer.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.record.patterns.annotations.not.allowed\n+\n+class RecordPatternsAnnotationsNotAllowed {\n+\n+    public boolean test(Object o) {\n+        return o instanceof @Deprecated R(String s);\n+    }\n+\n+    record R(String s) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/RecordPatternsAnnotationsNotAllowed.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.misc.feature.pattern.switch\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnconditionalPatternAndDefault.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n- * @compile\/fail\/ref=EnumSwitch2.out -XDrawDiagnostics EnumSwitch2.java\n+ * @compile\/fail\/ref=EnumSwitch2.out -XDrawDiagnostics --release 20 EnumSwitch2.java\n","filename":"test\/langtools\/tools\/javac\/enum\/EnumSwitch2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -725,1 +725,1 @@\n-            printTree(\"var\", tree.varOrRecordPattern);\n+            printTree(\"var\", tree.var);\n","filename":"test\/langtools\/tools\/javac\/lib\/DPrinter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2345,0 +2345,53 @@\n+    @Test\n+    void testGuardRecovery() throws IOException {\n+        String code = \"\"\"\n+                      package t;\n+                      class Test {\n+                          private int t(Integer i, boolean b) {\n+                              switch (i) {\n+                                  case 0 when b -> {}\n+                                  case null when b -> {}\n+                                  default when b -> {}\n+                              }\n+                              return switch (i) {\n+                                  case 0 when b -> 0;\n+                                  case null when b -> 0;\n+                                  default when b -> 0;\n+                              };\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll, null,\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+        new TreeScanner<Void, Void>() {\n+            @Override\n+            public Void visitCase(CaseTree node, Void p) {\n+                assertNotNull(node.getGuard());\n+                assertEquals(\"guard kind\", Kind.ERRONEOUS, node.getGuard().getKind());\n+                assertEquals(\"guard content\",\n+                             List.of(\"b\"),\n+                             ((ErroneousTree) node.getGuard()).getErrorTrees()\n+                                                              .stream()\n+                                                              .map(t -> t.toString()).toList());\n+                return super.visitCase(node, p);\n+            }\n+        }.scan(cut, null);\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" +  d.getCode());\n+        }\n+\n+        assertEquals(\"testUsupportedTextBlock: \" + codes,\n+                List.of(\"5:20:compiler.err.guard.not.allowed\",\n+                        \"6:23:compiler.err.guard.not.allowed\",\n+                        \"7:21:compiler.err.guard.not.allowed\",\n+                        \"10:20:compiler.err.guard.not.allowed\",\n+                        \"11:23:compiler.err.guard.not.allowed\",\n+                        \"12:21:compiler.err.guard.not.allowed\"),\n+                codes);\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8300543\n+ * @summary Verify error related to annotations and patterns\n+ * @compile\/fail\/ref=AnnotationErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW AnnotationErrors.java\n+ *\/\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Target;\n+\n+public class AnnotationErrors {\n+\n+    private void test(Object o, G<String> g) {\n+        boolean b1 = o instanceof @DA R(var s);\n+        boolean b2 = o instanceof @DTA R(var s);\n+        boolean b3 = o instanceof @TA R(var s);\n+        boolean b5 = g instanceof G<@DTA String>(var s);\n+        boolean b6 = g instanceof G<@TA String>(var s);\n+        switch (o) {\n+            case @DA R(var s) when b1 -> {}\n+            case @DTA R(var s) when b1 -> {}\n+            case @TA R(var s) when b1 -> {}\n+            default -> {}\n+        }\n+        switch (g) {\n+            case G<@DTA String>(var s) when b1 -> {}\n+            case G<@TA String>(var s) when b1 -> {}\n+            default -> {}\n+        }\n+    }\n+\n+    record R(String s) {}\n+    record G<T>(T t) {}\n+\n+    @Target(ElementType.LOCAL_VARIABLE)\n+    @interface DA {}\n+    @Target({ElementType.TYPE_USE, ElementType.LOCAL_VARIABLE})\n+    @interface DTA {}\n+    @Target(ElementType.TYPE_USE)\n+    @interface TA {}\n+}\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/AnnotationErrors.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+AnnotationErrors.java:14:35: compiler.err.record.patterns.annotations.not.allowed\n+AnnotationErrors.java:15:35: compiler.err.record.patterns.annotations.not.allowed\n+AnnotationErrors.java:16:35: compiler.err.record.patterns.annotations.not.allowed\n+AnnotationErrors.java:17:37: compiler.err.record.patterns.annotations.not.allowed\n+AnnotationErrors.java:18:37: compiler.err.record.patterns.annotations.not.allowed\n+AnnotationErrors.java:20:18: compiler.err.record.patterns.annotations.not.allowed\n+AnnotationErrors.java:21:18: compiler.err.record.patterns.annotations.not.allowed\n+AnnotationErrors.java:22:18: compiler.err.record.patterns.annotations.not.allowed\n+AnnotationErrors.java:26:20: compiler.err.record.patterns.annotations.not.allowed\n+AnnotationErrors.java:27:20: compiler.err.record.patterns.annotations.not.allowed\n+10 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/AnnotationErrors.out","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -88,1 +88,1 @@\n-        boolean hasDefault = Arrays.stream(caseLabels).anyMatch(l -> l == CaseLabel.DEFAULT || l == CaseLabel.TYPE_PATTERN || l == CaseLabel.PARENTHESIZED_PATTERN);\n+        boolean hasDefault = Arrays.stream(caseLabels).anyMatch(l -> l == CaseLabel.DEFAULT || l == CaseLabel.TYPE_PATTERN);\n@@ -91,3 +91,1 @@\n-                .withSourceFromTemplate(MAIN_TEMPLATE.replace(\"#{CASES}\", labels).replace(\"#{DEFAULT}\", hasDefault ? \"\" : \"default: break;\"))\n-                .withOption(\"--enable-preview\")\n-                .withOption(\"-source\").withOption(JAVA_VERSION);\n+                .withSourceFromTemplate(MAIN_TEMPLATE.replace(\"#{CASES}\", labels).replace(\"#{DEFAULT}\", hasDefault ? \"\" : \"default: break;\"));\n@@ -97,1 +95,1 @@\n-            long patternCases = Arrays.stream(caseLabels).filter(l -> l == CaseLabel.TYPE_PATTERN || l == CaseLabel.PARENTHESIZED_PATTERN).count();\n+            long patternCases = Arrays.stream(caseLabels).filter(l -> l == CaseLabel.TYPE_PATTERN).count();\n@@ -139,1 +137,0 @@\n-        PARENTHESIZED_PATTERN(\"(Integer i)\"),\n","filename":"test\/langtools\/tools\/javac\/patterns\/CaseStructureTest.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n- * @compile --enable-preview -source ${jdk.version} DeconstructionDesugaring.java\n- * @run main\/othervm --enable-preview DeconstructionDesugaring\n+ * @compile DeconstructionDesugaring.java\n+ * @run main DeconstructionDesugaring\n@@ -82,1 +82,1 @@\n-            case (((R1((((R2((((String s))))))))))) -> { return 1; }\n+            case R1(R2(String s)) -> { return 1; }\n@@ -96,1 +96,1 @@\n-            case (((R1((((R2((((String s))))))))))) -> 1;\n+            case R1(R2(String s)) -> 1;\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionDesugaring.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4,1 +4,0 @@\n- * @enablePreview\n@@ -7,0 +6,1 @@\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,4 +29,1 @@\n-DeconstructionPatternErrors.java:44:9: compiler.err.not.exhaustive.statement\n-- compiler.note.preview.filename: DeconstructionPatternErrors.java, DEFAULT\n-- compiler.note.preview.recompile\n-29 errors\n+28 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.out","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n- * @enablePreview\n@@ -38,1 +37,0 @@\n-import com.sun.source.tree.EnhancedForLoopTree;\n@@ -41,2 +39,0 @@\n-import com.sun.source.tree.PatternTree;\n-import com.sun.source.tree.StatementTree;\n@@ -44,1 +40,0 @@\n-import com.sun.source.tree.Tree.Kind;\n@@ -50,1 +45,0 @@\n-import com.sun.tools.javac.util.Log;\n@@ -52,2 +46,0 @@\n-import java.net.URI;\n-import java.net.URISyntaxException;\n@@ -55,7 +47,0 @@\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import javax.tools.Diagnostic;\n-import javax.tools.DiagnosticListener;\n-import javax.tools.JavaFileObject;\n-import javax.tools.SimpleJavaFileObject;\n@@ -71,1 +56,1 @@\n-        test.disambiguationTest(\"(String s)\",\n+        test.disambiguationTest(\"String s\",\n@@ -73,1 +58,1 @@\n-        test.disambiguationTest(\"(@Ann String s)\",\n+        test.disambiguationTest(\"@Ann String s\",\n@@ -75,1 +60,1 @@\n-        test.disambiguationTest(\"((String s))\",\n+        test.disambiguationTest(\"String s\",\n@@ -95,1 +80,1 @@\n-        test.disambiguationTest(\"(a < c.d > b)\",\n+        test.disambiguationTest(\"a < c.d > b\",\n@@ -127,21 +112,0 @@\n-        test.forDisambiguationTest(\"T[] a\", ForType.ENHANCED_FOR);\n-        test.forDisambiguationTest(\"T[].class.getName()\", ForType.TRADITIONAL_FOR);\n-        test.forDisambiguationTest(\"T[].class\", ForType.TRADITIONAL_FOR, \"compiler.err.not.stmt\");\n-        test.forDisambiguationTest(\"R(T[] a)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n-\n-        test.forDisambiguationTest(\"Point(Integer a, Integer b)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n-        test.forDisambiguationTest(\"ForEachPatterns.Point(Integer a, Integer b)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n-        test.forDisambiguationTest(\"GPoint<Integer>(Integer a, Integer b)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n-        test.forDisambiguationTest(\"@Annot(field = \\\"test\\\") Point p\", ForType.ENHANCED_FOR);\n-        test.forDisambiguationTest(\"GPoint<Point>(Point(Integer a, Integer b), Point c)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n-        test.forDisambiguationTest(\"GPoint<Point>(Point(var a, Integer b), Point c)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n-        test.forDisambiguationTest(\"GPoint<VoidPoint>(VoidPoint(), VoidPoint())\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n-        test.forDisambiguationTest(\"RecordOfLists(List<Integer> lr)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n-        test.forDisambiguationTest(\"RecordOfLists2(List<List<Integer>> lr)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n-        test.forDisambiguationTest(\"GPoint<@Annot(field = \\\"\\\") ? extends Point>(var x, var y)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n-\n-        test.forDisambiguationTest(\"method()\", ForType.TRADITIONAL_FOR);\n-        test.forDisambiguationTest(\"method(), method()\", ForType.TRADITIONAL_FOR);\n-        test.forDisambiguationTest(\"method2((Integer a) -> 42)\", ForType.TRADITIONAL_FOR);\n-        test.forDisambiguationTest(\"m(cond ? b() : i)\", ForType.TRADITIONAL_FOR);\n-        test.forDisambiguationTest(\"m((GPoint<?>)null, cond ? b() : i)\", ForType.TRADITIONAL_FOR);\n@@ -151,1 +115,0 @@\n-    private final List<String> errors = new ArrayList<>();\n@@ -153,1 +116,1 @@\n-    public DisambiguatePatterns() throws URISyntaxException {\n+    public DisambiguatePatterns() {\n@@ -155,5 +118,0 @@\n-        context.put(DiagnosticListener.class, d -> {\n-            if (d.getKind() == Diagnostic.Kind.ERROR) {\n-                errors.add(d.getCode());\n-            }\n-        });\n@@ -162,3 +120,0 @@\n-        SimpleJavaFileObject source =\n-                new SimpleJavaFileObject(new URI(\"mem:\/\/Test.java\"), JavaFileObject.Kind.SOURCE) {};\n-        Log.instance(context).useSource(source);\n@@ -195,52 +150,0 @@\n-    void forDisambiguationTest(String snippet, ForType forType, String... expectedErrors) {\n-        errors.clear();\n-\n-        String codeTemplate = switch (forType) {\n-            case TRADITIONAL_FOR ->\n-                \"\"\"\n-                public class Test {\n-                    private void test() {\n-                        for (SNIPPET; ;) {\n-                        }\n-                    }\n-                }\n-                \"\"\";\n-            case ENHANCED_FOR, ENHANCED_FOR_WITH_PATTERNS ->\n-                \"\"\"\n-                public class Test {\n-                    private void test() {\n-                        for (SNIPPET : collection) {\n-                        }\n-                    }\n-                }\n-                \"\"\";\n-        };\n-\n-        String code = codeTemplate.replace(\"SNIPPET\", snippet);\n-        JavacParser parser = factory.newParser(code, false, false, false);\n-        CompilationUnitTree result = parser.parseCompilationUnit();\n-        if (!Arrays.asList(expectedErrors).equals(errors)) {\n-            throw new AssertionError(\"Expected errors: \" + Arrays.asList(expectedErrors) +\n-                                     \", actual: \" + errors +\n-                                     \", for: \" + code);\n-        }\n-        ClassTree clazz = (ClassTree) result.getTypeDecls().get(0);\n-        MethodTree method = (MethodTree) clazz.getMembers().get(0);\n-        StatementTree st = method.getBody().getStatements().get(0);\n-        if (forType == ForType.TRADITIONAL_FOR) {\n-            if (st.getKind() != Kind.FOR_LOOP) {\n-                throw new AssertionError(\"Unpected statement: \" + st);\n-            }\n-        } else {\n-            EnhancedForLoopTree ef = (EnhancedForLoopTree) st;\n-            ForType actualType = switch (ef.getVariableOrRecordPattern()) {\n-                case PatternTree pattern -> ForType.ENHANCED_FOR_WITH_PATTERNS;\n-                default -> ForType.ENHANCED_FOR;\n-            };\n-            if (forType != actualType) {\n-                throw new AssertionError(\"Expected: \" + forType + \", actual: \" + actualType +\n-                                          \", for: \" + code + \", parsed: \" + result);\n-            }\n-        }\n-    }\n-\n@@ -252,5 +155,0 @@\n-    enum ForType {\n-        TRADITIONAL_FOR,\n-        ENHANCED_FOR,\n-        ENHANCED_FOR_WITH_PATTERNS;\n-    }\n","filename":"test\/langtools\/tools\/javac\/patterns\/DisambiguatePatterns.java","additions":5,"deletions":107,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @enablePreview\n@@ -31,0 +30,1 @@\n+\n@@ -183,2 +183,2 @@\n-            case ((R r)): return 1;\n-            case ((R(int a))): return -1;\n+            case R r: return 1;\n+            case R(int a): return -1;\n@@ -192,2 +192,2 @@\n-            case ((R(int a))): return 1;\n-            case ((R(int a))): return -1;\n+            case R(int a): return 1;\n+            case R(int a): return -1;\n","filename":"test\/langtools\/tools\/javac\/patterns\/Domination.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -19,2 +19,0 @@\n-- compiler.note.preview.filename: Domination.java, DEFAULT\n-- compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/patterns\/Domination.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/patterns\/EmptyRecordClass.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/patterns\/EnumTypeChanges.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @compile EnumTypeChangesNonPreview.java\n+ * @compile --release 20 EnumTypeChangesNonPreview.java\n@@ -31,1 +31,0 @@\n- * @run main\/othervm --enable-preview EnumTypeChangesNonPreview\n","filename":"test\/langtools\/tools\/javac\/patterns\/EnumTypeChangesNonPreview.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,3 @@\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n@@ -41,0 +44,2 @@\n+import java.util.Set;\n+import java.util.stream.Collectors;\n@@ -42,1 +47,0 @@\n-import toolbox.TestRunner;\n@@ -45,0 +49,1 @@\n+import toolbox.TestRunner;\n@@ -49,2 +54,0 @@\n-    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n-\n@@ -122,2 +125,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -184,2 +185,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -217,2 +216,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -281,2 +278,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -410,2 +405,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -416,30 +409,1 @@\n-    public void testExhaustiveStatement3(Path base) throws Exception {\n-        doTest(base,\n-               new String[]{\"\"\"\n-                            package lib;\n-                            public sealed interface S permits A, B {}\n-                            \"\"\",\n-                            \"\"\"\n-                            package lib;\n-                            public final class A implements S {}\n-                            \"\"\",\n-                            \"\"\"\n-                            package lib;\n-                            public final class B implements S {}\n-                            \"\"\"},\n-               \"\"\"\n-               package test;\n-               import lib.*;\n-               public class Test {\n-                   private int test(S obj) {\n-                       return switch (obj) {\n-                           case A a -> 0;\n-                           case S s -> 1;\n-                       };\n-                   }\n-               }\n-               \"\"\");\n-    }\n-\n-    @Test\n-    public void testExhaustiveStatement4(Path base) throws Exception {\n+    public void testExhaustiveExpression1(Path base) throws Exception {\n@@ -471,2 +435,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -477,1 +439,1 @@\n-    public void testExhaustiveStatement5(Path base) throws Exception {\n+    public void testExhaustiveExpression2(Path base) throws Exception {\n@@ -581,2 +543,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -587,1 +547,66 @@\n-    public void testExhaustiveIntersection(Path base) throws Exception {\n+    public void testIntersection(Path base) throws Exception {\n+        record TestCase(String snippet, String... expected){}\n+        TestCase[] testCases = new TestCase[] {\n+            new TestCase(\"\"\"\n+                         return switch (obj) {\n+                             case A a -> 0;\n+                             case C c when b -> 0;\n+                             case C c -> 0;\n+                             case D d -> 0;\n+                         };\n+                         \"\"\"),\n+            new TestCase(\"\"\"\n+                         return switch (obj) {\n+                             case A a -> 0;\n+                             case C c -> 0;\n+                             case D d when b -> 0;\n+                         };\n+                         \"\"\",\n+                         \"Test.java:5:16: compiler.err.not.exhaustive\",\n+                         \"1 error\")\n+        };\n+        for (TestCase tc : testCases) {\n+            doTest(base,\n+                   new String[]{\"\"\"\n+                                package lib;\n+                                public sealed interface S permits A, B {}\n+                                \"\"\",\n+                                \"\"\"\n+                                package lib;\n+                                public abstract class Base {}\n+                                \"\"\",\n+                                \"\"\"\n+                                package lib;\n+                                public interface Marker {}\n+                                \"\"\",\n+                                \"\"\"\n+                                package lib;\n+                                public final class A extends Base implements S, Marker {}\n+                                \"\"\",\n+                                \"\"\"\n+                                package lib;\n+                                public abstract sealed class B extends Base implements S permits C, D {}\n+                                \"\"\",\n+                                \"\"\"\n+                                package lib;\n+                                public final class C extends B implements Marker {}\n+                                \"\"\",\n+                                \"\"\"\n+                                package lib;\n+                                public final class D extends B implements Marker {}\n+                                \"\"\"},\n+                   \"\"\"\n+                   package test;\n+                   import lib.*;\n+                   public class Test {\n+                       private <T extends Base & S & Marker> int test(T obj, boolean b) {\n+                           ${tc.snippet()}\n+                       }\n+                   }\n+                   \"\"\".replace(\"${tc.snippet()}\", tc.snippet()),\n+                   tc.expected());\n+        }\n+    }\n+\n+    @Test\n+    public void testRecordPatterns(Path base) throws Exception {\n@@ -595,1 +620,1 @@\n-                            public abstract class Base {}\n+                            public final class A implements S {}\n@@ -599,1 +624,1 @@\n-                            public interface Marker {}\n+                            public final class B implements S {}\n@@ -603,1 +628,20 @@\n-                            public final class A extends Base implements S, Marker {}\n+                            public record R(S a, S b) {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(R r) {\n+                       return switch (r) {\n+                           case R(A a, A b) -> 0;\n+                           case R(A a, B b) -> 0;\n+                           case R(B a, A b) -> 0;\n+                           case R(B a, B b) -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n@@ -607,1 +651,1 @@\n-                            public abstract sealed class B extends Base implements S permits C, D {}\n+                            public final class A implements S {}\n@@ -611,1 +655,1 @@\n-                            public final class C extends B implements Marker {}\n+                            public record B(Object o) implements S {}\n@@ -615,1 +659,1 @@\n-                            public final class D extends B implements Marker {}\n+                            public record R(S a, S b) {}\n@@ -621,6 +665,6 @@\n-                   private <T extends Base & S & Marker> int test(T obj, boolean b) {\n-                       return switch (obj) {\n-                           case A a -> 0;\n-                           case C c when b -> 0;\n-                           case C c -> 0;\n-                           case D d -> 0;\n+                   private int test(R r) {\n+                       return switch (r) {\n+                           case R(A a, A b) -> 0;\n+                           case R(A a, B b) -> 0;\n+                           case R(B a, A b) -> 0;\n+                           case R(B a, B(String s)) -> 0;\n@@ -630,5 +674,3 @@\n-               \"\"\");\n-    }\n-\n-    @Test\n-    public void testNotExhaustiveIntersection(Path base) throws Exception {\n+               \"\"\",\n+               \"Test.java:5:16: compiler.err.not.exhaustive\",\n+               \"1 error\");\n@@ -642,1 +684,1 @@\n-                            public abstract class Base {}\n+                            public final class A implements S {}\n@@ -646,1 +688,1 @@\n-                            public interface Marker {}\n+                            public record B(Object o) implements S {}\n@@ -650,1 +692,20 @@\n-                            public final class A extends Base implements S, Marker {}\n+                            public record R(S a, S b) {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(R r) {\n+                       return switch (r) {\n+                           case R(A a, A b) -> 0;\n+                           case R(A a, B b) -> 0;\n+                           case R(B a, A b) -> 0;\n+                           case R(B a, B(var o)) -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n@@ -654,1 +715,1 @@\n-                            public abstract sealed class B extends Base implements S permits C, D {}\n+                            public final class A implements S {}\n@@ -658,1 +719,1 @@\n-                            public final class C extends B implements Marker {}\n+                            public record B(Object o) implements S {}\n@@ -662,1 +723,1 @@\n-                            public final class D extends B implements Marker {}\n+                            public record R(S a, S b) {}\n@@ -668,5 +729,6 @@\n-                   private <T extends Base & S & Marker> int test(T obj, boolean b) {\n-                       return switch (obj) {\n-                           case A a -> 0;\n-                           case C c -> 0;\n-                           case D d when b -> 0;\n+                   private int test(R r) {\n+                       return switch (r) {\n+                           case R(A a, A b) -> 0;\n+                           case R(A a, B b) -> 0;\n+                           case R(B a, A b) -> 0;\n+                           case R(B(String s), B b) -> 0;\n@@ -678,2 +740,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -681,4 +741,0 @@\n-    }\n-\n-    @Test\n-    public void testX(Path base) throws Exception {\n@@ -696,1 +752,1 @@\n-                            public final class B implements S {}\n+                            public record B(Object o) implements S {}\n@@ -711,1 +767,1 @@\n-                           case R(B a, B b) -> 0;\n+                           case R(B(Object o), B b) -> 0;\n@@ -741,0 +797,1 @@\n+                           case R(B(String s), B b) -> 0;\n@@ -742,1 +799,0 @@\n-                           case R(B a, B(String s)) -> 0;\n@@ -748,2 +804,18 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n+               \"1 error\");\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public record R(Object o1, Object o2) {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(R r) {\n+                       return switch (r) {\n+                           case R(String s, Object o) -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:5:16: compiler.err.not.exhaustive\",\n@@ -762,1 +834,1 @@\n-                            public record B(Object o) implements S {}\n+                            public record B(S o) implements S {}\n@@ -766,1 +838,1 @@\n-                            public record R(S a, S b) {}\n+                            public record R(S a, String s, S b) {}\n@@ -774,4 +846,38 @@\n-                           case R(A a, A b) -> 0;\n-                           case R(A a, B b) -> 0;\n-                           case R(B a, A b) -> 0;\n-                           case R(B a, B(var o)) -> 0;\n+                           case R(A a, String s, A b) -> 0;\n+                           case R(A a, String s, B b) -> 0;\n+                           case R(B a, String s, A b) -> 0;\n+                           case R(B(A o), String s, B b) -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:5:16: compiler.err.not.exhaustive\",\n+               \"1 error\");\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public record B(S o) implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public record R(S a, String s, S b) {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(R r) {\n+                       return switch (r) {\n+                           case R(A a, String s, A b) -> 0;\n+                           case R(A a, String s, B b) -> 0;\n+                           case R(B a, String s, A b) -> 0;\n+                           case R(B(A o), String s, B b) -> 0;\n+                           case R(B(B o), String s, B b) -> 0;\n@@ -783,0 +889,1 @@\n+\n@@ -820,2 +927,0 @@\n-                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-                         \"- compiler.note.preview.recompile\",\n@@ -828,2 +933,0 @@\n-                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-                         \"- compiler.note.preview.recompile\",\n@@ -836,2 +939,0 @@\n-                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-                         \"- compiler.note.preview.recompile\",\n@@ -846,2 +947,0 @@\n-                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-                         \"- compiler.note.preview.recompile\",\n@@ -856,2 +955,0 @@\n-                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-                         \"- compiler.note.preview.recompile\",\n@@ -866,2 +963,0 @@\n-                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-                         \"- compiler.note.preview.recompile\",\n@@ -965,2 +1060,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -1033,2 +1126,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -1055,2 +1146,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -1109,2 +1198,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -1129,2 +1216,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -1148,2 +1233,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -1168,2 +1251,0 @@\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n@@ -1196,1 +1277,679 @@\n-    private void doTest(Path base, String[] libraryCode, String testCode, String... expectedErrors) throws IOException {\n+    @Test\n+    public void testEnumExhaustiveness(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface Opt {}\n+                   enum A implements Opt { A, B, C; }\n+                   enum B implements Opt { B, C, D; }\n+\n+                   void test(Opt optValue) {\n+                       switch (optValue) {\n+                           case A.A, A.B -> {}\n+                           case A.C, B.C -> {}\n+                           case B.B, B.D -> {}\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    public void testNestedApplicable(Path base) throws Exception {\n+        record TestCase(String cases, String... errors) {}\n+        TestCase[] subCases = new TestCase[] {\n+            new TestCase(\"\"\"\n+                                     case R(C3<Integer> c) -> {}\n+                                     case R(C5<Integer, ?> c) -> {}\n+                                     case R(C6<?, Integer> c) -> {}\n+                         \"\"\"), \/\/OK\n+            new TestCase(\"\"\"\n+                                     case R(C5<Integer, ?> c) -> {}\n+                                     case R(C6<?, Integer> c) -> {}\n+                         \"\"\",\n+                         \"Test.java:12:9: compiler.err.not.exhaustive.statement\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                                     case R(C3<Integer> c) -> {}\n+                                     case R(C6<?, Integer> c) -> {}\n+                         \"\"\",\n+                         \"Test.java:12:9: compiler.err.not.exhaustive.statement\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                                     case R(C3<Integer> c) -> {}\n+                                     case R(C5<Integer, ?> c) -> {}\n+                         \"\"\",\n+                         \"Test.java:12:9: compiler.err.not.exhaustive.statement\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                                     case R(C1 c) -> {}\n+                                     case R(C3<Integer> c) -> {}\n+                                     case R(C5<Integer, ?> c) -> {}\n+                                     case R(C6<?, Integer> c) -> {}\n+                         \"\"\",\n+                         \"Test.java:13:20: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: test.Test.I<java.lang.Integer>, test.Test.C1)\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                                     case R(C2<?> c) -> {}\n+                                     case R(C3<Integer> c) -> {}\n+                                     case R(C5<Integer, ?> c) -> {}\n+                                     case R(C6<?, Integer> c) -> {}\n+                         \"\"\",\n+                         \"Test.java:13:20: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: test.Test.I<java.lang.Integer>, test.Test.C2<?>)\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                                     case R(C4<?, ?> c) -> {}\n+                                     case R(C3<Integer> c) -> {}\n+                                     case R(C5<Integer, ?> c) -> {}\n+                                     case R(C6<?, Integer> c) -> {}\n+                         \"\"\",\n+                         \"Test.java:13:20: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: test.Test.I<java.lang.Integer>, test.Test.C4<?,?>)\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+        };\n+        for (TestCase tc : subCases) {\n+            doTest(base,\n+                   new String[0],\n+                   \"\"\"\n+                   package test;\n+                   public class Test {\n+                       sealed interface I<T> {}\n+                       final class C1 implements I<String> {}\n+                       final class C2<T> implements I<String> {}\n+                       final class C3<T> implements I<T> {}\n+                       final class C4<T, E> implements I<String> {}\n+                       final class C5<T, E> implements I<T> {}\n+                       final class C6<T, E> implements I<E> {}\n+                       record R<T>(I<T> i) {}\n+                       void t(R<Integer> i) {\n+                           switch (i) {\n+                   ${cases}\n+                           }\n+                       }\n+                   }\n+                   \"\"\".replace(\"${cases}\", tc.cases),\n+                   tc.errors);\n+        }\n+    }\n+\n+    @Test\n+    public void testComplexSubTypes1(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I permits I1, I2, I3 {}\n+                   sealed interface I1 extends I permits C1 {}\n+                   sealed interface I2 extends I {}\n+                   sealed interface I3 extends I {}\n+                   final class C1 implements I1, I2 {}\n+                   final class C2 implements I3 {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case I2 i2 ->\n+                               System.out.println(\"I2\");\n+                           case I3 i3 ->\n+                               System.out.println(\"I3\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testComplexSubTypes2(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I permits I1, I2, I3 {}\n+                   sealed interface I1 extends I permits C1 {}\n+                   sealed interface I2 extends I {}\n+                   sealed interface I3 extends I {}\n+                   sealed abstract class C1 implements I1 {}\n+                   final class C2 extends C1 implements I2 {}\n+                   final class C3 extends C1 implements I3 {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case I2 i2 ->\n+                               System.out.println(\"I2\");\n+                           case I3 i3 ->\n+                               System.out.println(\"I3\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testComplexSubTypes3(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed interface I1 extends I {}\n+                   final class I2 implements I1 {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case I1 i1 ->\n+                               System.out.println(\"I1\");\n+                           case I2 i2 ->\n+                               System.out.println(\"I2\");\n+                       }\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:11:18: compiler.err.pattern.dominated\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testComplexSubTypes4(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I permits I1, I2, I3 {}\n+                   sealed interface I1 extends I permits C1 {}\n+                   sealed class I2 implements I {}\n+                   sealed interface I3 extends I {}\n+                   final class C1 extends I2 implements I1 {}\n+                   final class C2 implements I3 {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case I2 i2 ->\n+                               System.out.println(\"I2\");\n+                           case I3 i3 ->\n+                               System.out.println(\"I3\");\n+                       }\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:11:9: compiler.err.not.exhaustive.statement\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testComplexSubTypes5(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               class Test {\n+                   sealed interface I permits A, B, C { }\n+                   interface I3 { }\n+                   sealed interface I2 extends I3 permits B, C { }\n+                   final class A implements I {}\n+                   final class B implements I, I2 {}\n+                   final class C implements I, I2 {}\n+\n+                   int m(I i) {\n+                       return switch (i) {\n+                           case A a -> 1;\n+                           case I3 e -> 2;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testComplexSubTypes6(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               class Test {\n+                   sealed interface I0 permits I1, I2 { }\n+                   sealed interface I00 permits I1, I2 { }\n+\n+                   sealed interface I1 extends I0, I00 permits B, C { }\n+                   sealed interface I2 extends I0, I00 permits B, C { }\n+\n+                   static final class B implements I1, I2 { }\n+                   static final class C implements I1, I2 { }\n+\n+                   int test(Object o) {\n+                       return switch (o) {\n+                           case B c -> 2;\n+                           case C d -> 3;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:12:16: compiler.err.not.exhaustive\",\n+               \"1 error\");\n+    }\n+\n+    private static final int NESTING_CONSTANT = 5;\n+\n+    Set<String> createDeeplyNestedVariants() {\n+        Set<String> variants = new HashSet<>();\n+        variants.add(\"C _\");\n+        variants.add(\"R(I _, I _, I _)\");\n+        for (int n = 0; n < NESTING_CONSTANT; n++) {\n+            Set<String> newVariants = new HashSet<>();\n+            for (String variant : variants) {\n+                if (variant.contains(\", I _\")) {\n+                    newVariants.add(variant.replaceFirst(\", I _\", \", C _\"));\n+                    newVariants.add(variant.replaceFirst(\", I _\", \", R(I _, I _, I _)\"));\n+                } else {\n+                    newVariants.add(variant);\n+                }\n+            }\n+            variants = newVariants;\n+        }\n+        for (int n = 0; n < NESTING_CONSTANT; n++) {\n+            Set<String> newVariants = new HashSet<>();\n+            for (String variant : variants) {\n+                if (variant.contains(\"I _\")) {\n+                    newVariants.add(variant.replaceFirst(\"I _\", \"C _\"));\n+                    newVariants.add(variant.replaceFirst(\"I _\", \"R(I _, I _, I _)\"));\n+                } else {\n+                    newVariants.add(variant);\n+                }\n+            }\n+            variants = newVariants;\n+        }\n+        OUTER: for (int i = 0; i < NESTING_CONSTANT; i++) {\n+            Iterator<String> it = variants.iterator();\n+            while (it.hasNext()) {\n+                String current = it.next();\n+                if (current.contains(\"(I _, I _, I _)\")) {\n+                    it.remove();\n+                    variants.add(current.replaceFirst(\"\\\\(I _, I _, I _\\\\)\", \"(C _, I _, C _)\"));\n+                    variants.add(current.replaceFirst(\"\\\\(I _, I _, I _\\\\)\", \"(C _, I _, R _)\"));\n+                    variants.add(current.replaceFirst(\"\\\\(I _, I _, I _\\\\)\", \"(R _, I _, C _)\"));\n+                    variants.add(current.replaceFirst(\"\\\\(I _, I _, I _\\\\)\", \"(R _, I _, R _)\"));\n+                    continue OUTER;\n+                }\n+            }\n+        }\n+\n+        return variants;\n+    }\n+\n+    String testCodeForVariants(Iterable<String> variants) {\n+        StringBuilder cases = new StringBuilder();\n+\n+        for (String variant : variants) {\n+            cases.append(\"case \");\n+            String[] parts = variant.split(\"_\");\n+            for (int i = 0; i < parts.length; i++) {\n+                cases.append(parts[i]);\n+                if (i + 1 < parts.length || i == 0) {\n+                    cases.append(\"v\" + i);\n+                }\n+            }\n+            cases.append(\" -> System.err.println();\\n\");\n+        }\n+        String code = \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   final class C implements I {}\n+                   record R(I c1, I c2, I c3) implements I {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           ${cases}\n+                       }\n+                   }\n+               }\n+               \"\"\".replace(\"${cases}\", cases);\n+\n+        return code;\n+    }\n+\n+    @Test\n+    public void testDeeplyNestedExhaustive(Path base) throws Exception {\n+        Set<String> variants = createDeeplyNestedVariants();\n+        String code = testCodeForVariants(variants);\n+\n+        System.err.println(\"analyzing:\");\n+        System.err.println(code);\n+        doTest(base,\n+               new String[0],\n+               code,\n+               true);\n+    }\n+\n+    @Test\n+    public void testDeeplyNestedNotExhaustive(Path base) throws Exception {\n+        List<String> variants = createDeeplyNestedVariants().stream().collect(Collectors.toCollection(ArrayList::new));\n+        variants.remove((int) (Math.random() * variants.size()));\n+        String code = testCodeForVariants(variants);\n+\n+        System.err.println(\"analyzing:\");\n+        System.err.println(code);\n+        doTest(base,\n+               new String[0],\n+               code,\n+               new String[] {null});\n+    }\n+\n+    @Test\n+    public void testMultipleSealed(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I1 {}\n+                   sealed interface I2 {}\n+                   final class A_I1 implements I1 {}\n+                   final class B_I2 implements I2 {}\n+                   final class C_I1_I2 implements I1, I2 {}\n+\n+                   <Z extends I1&I2> void test(Z z) {\n+                       switch (z) {\n+                           case C_I1_I2 c ->\n+                               System.out.println(\"C_I1_I2\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testOverfitting(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   final class A implements I {}\n+                   final class B implements I {}\n+                   record R(String s, I i) {}\n+\n+                   void test(R r) {\n+                       switch (r) {\n+                           case R(CharSequence s, A a) ->\n+                               System.out.println(\"A\");\n+                           case R(Object o, B b) ->\n+                               System.out.println(\"B\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testDiamondInheritance1(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed abstract class A {}\n+                   final class C extends A implements I {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case C c ->\n+                               System.out.println(\"C\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testDiamondInheritance2(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed abstract class A {}\n+                   final class C extends A implements I {}\n+                   record R(I i) {}\n+\n+                   void test(R r) {\n+                       switch (r) {\n+                           case R(C c) ->\n+                               System.out.println(\"C\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testDiamondInheritance3(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed interface S1 extends I {}\n+                   sealed interface S2 extends I {}\n+                   final class C1 implements S1 {}\n+                   final class C2 implements S2 {}\n+                   final class C12 implements S1, S2 {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case C1 c ->\n+                               System.out.println(\"C1\");\n+                           case C2 c ->\n+                               System.out.println(\"C2\");\n+                           case C12 c ->\n+                               System.out.println(\"C12\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed interface S1 extends I {}\n+                   sealed interface S2 extends I {}\n+                   final class C1 implements S1 {}\n+                   final class C2 implements S2 {}\n+                   final class C12 implements S1, S2 {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case C12 c ->\n+                               System.out.println(\"C12\");\n+                           case C1 c ->\n+                               System.out.println(\"C1\");\n+                           case C2 c ->\n+                               System.out.println(\"C2\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testDiamondInheritance4(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed interface S1 extends I {}\n+                   sealed interface S2 extends I {}\n+                   final class C1 implements S1 {}\n+                   final class C2 implements S2 {}\n+                   final class C12 implements S1, S2 {}\n+                   record R(I i) {}\n+\n+                   void test(R r) {\n+                       switch (r) {\n+                           case R(C1 c) ->\n+                               System.out.println(\"C1\");\n+                           case R(C2 c) ->\n+                               System.out.println(\"C2\");\n+                           case R(C12 c) ->\n+                               System.out.println(\"C12\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed interface S1 extends I {}\n+                   sealed interface S2 extends I {}\n+                   final class C1 implements S1 {}\n+                   final class C2 implements S2 {}\n+                   final class C12 implements S1, S2 {}\n+                   record R(I i) {}\n+\n+                   void test(R r) {\n+                       switch (r) {\n+                           case R(C12 c) ->\n+                               System.out.println(\"C12\");\n+                           case R(C1 c) ->\n+                               System.out.println(\"C1\");\n+                           case R(C2 c) ->\n+                               System.out.println(\"C2\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testDiamondInheritance5(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed interface S1 extends I {}\n+                   sealed interface S2 extends I {}\n+                   sealed interface S3 extends I {}\n+                   final class C13 implements S1, S3 {}\n+                   final class C23 implements S2, S3 {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case C13 c ->\n+                               System.out.println(\"C13\");\n+                           case C23 c ->\n+                               System.out.println(\"C23\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testDiamondInheritance6(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed interface S1 extends I {}\n+                   sealed interface S2 extends I {}\n+                   final class C1 implements S1 {}\n+                   sealed abstract class C2 implements S2 {}\n+                   final class C2Prime extends C2 {}\n+                   final class C12 implements S1, S2 {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case C1 c ->\n+                               System.out.println(\"C1\");\n+                           case C2Prime c ->\n+                               System.out.println(\"C2\");\n+                           case C12 c ->\n+                               System.out.println(\"C12\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed interface S1 extends I {}\n+                   sealed interface S2 extends I {}\n+                   final class C1 implements S1 {}\n+                   sealed abstract class C2 implements S2 {}\n+                   final class C2Prime extends C2 {}\n+                   final class C12 implements S1, S2 {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case C2Prime c ->\n+                               System.out.println(\"C2\");\n+                           case C1 c ->\n+                               System.out.println(\"C1\");\n+                           case C12 c ->\n+                               System.out.println(\"C12\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed interface S1 extends I {}\n+                   sealed interface S2 extends I {}\n+                   final class C1 implements S1 {}\n+                   sealed abstract class C2 implements S2 {}\n+                   final class C2Prime extends C2 {}\n+                   final class C12 implements S1, S2 {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case C12 c ->\n+                               System.out.println(\"C12\");\n+                           case C1 c ->\n+                               System.out.println(\"C1\");\n+                           case C2Prime c ->\n+                               System.out.println(\"C2\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    private void doTest(Path base, String[] libraryCode, String testCode, String... expectedErrors) throws IOException {\n+        doTest(base, libraryCode, testCode, false, expectedErrors);\n+    }\n+\n+    private void doTest(Path base, String[] libraryCode, String testCode, boolean stopAtFlow, String... expectedErrors) throws IOException {\n@@ -1210,2 +1969,0 @@\n-                    .options(\"--enable-preview\",\n-                             \"-source\", JAVA_VERSION)\n@@ -1226,3 +1983,1 @@\n-                    .options(\"--enable-preview\",\n-                             \"-source\", JAVA_VERSION,\n-                             \"-XDrawDiagnostics\",\n+                    .options(\"-XDrawDiagnostics\",\n@@ -1231,1 +1986,3 @@\n-                             \"-XDshould-stop.at=FLOW\")\n+                             \"-XDshould-stop.at=FLOW\",\n+                             stopAtFlow ? \"-XDshould-stop.ifNoError=FLOW\"\n+                                        : \"-XDnoop\")\n@@ -1237,1 +1994,1 @@\n-        if (expectedErrors.length > 0 && !List.of(expectedErrors).equals(log)) {\n+        if (expectedErrors.length > 0 && expectedErrors[0] != null && !List.of(expectedErrors).equals(log)) {\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":885,"deletions":128,"binary":false,"changes":1013,"status":"modified"},{"patch":"@@ -1,254 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary\n- * @enablePreview\n- *\/\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Target;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.function.Function;\n-\n-public class ForEachPatterns {\n-    public static void main(String[] args) {\n-\n-        List<Point>             in                   = List.of(new Point(1, 2), new Point(2, 3));\n-        List<IPoint>            in_iface             = List.of(new Point(1, 2), new Point(2, 3));\n-        List                    inRaw                = List.of(new Point(1, 2), new Point(2, 3), new Frog(3, 4));\n-        List<PointEx>           inWithPointEx        = List.of(new PointEx(1, 2));\n-        byte[]                  inBytes              = { (byte) 127, (byte) 127 };\n-        List<Point>             inWithNullComponent  = List.of(new Point(1, null), new Point(2, 3));\n-        Point[]                 inArray              = in.toArray(Point[]::new);\n-        List<WithPrimitives>    inWithPrimitives     = List.of(new WithPrimitives(1, 2), new WithPrimitives(2, 3));\n-        IParent                 recs []              = { new Rec(1) };\n-        List<Point>             inWithNull           = new ArrayList<>();\n-        {\n-            inWithNull.add(new Point(2, 3));\n-            inWithNull.add(null);\n-        }\n-\n-        assertEquals(8, iteratorEnhancedFor(in));\n-        assertEquals(8, arrayEnhancedFor(inArray));\n-        assertEquals(8, simpleDecostructionPatternWithAccesses(in));\n-        assertEx(ForEachPatterns::simpleDecostructionPatternWithAccesses, null, NullPointerException.class);\n-        assertMatchExceptionWithNested(ForEachPatterns::simpleDecostructionPatternWithAccesses, inWithNull, NullPointerException.class);\n-        assertEx(ForEachPatterns::simpleDecostructionPatternWithAccesses, inWithNullComponent, NullPointerException.class);\n-        assertMatchExceptionWithNested(ForEachPatterns::simpleDecostructionPatternException, inWithPointEx, TestPatternFailed.class);\n-        assertEx(ForEachPatterns::simpleDecostructionPatternWithAccesses, (List<Point>) inRaw, ClassCastException.class);\n-        assertEquals(2, simpleDecostructionPatternNoComponentAccess(in));\n-        assertMatchExceptionWithNested(ForEachPatterns::simpleDecostructionPatternNoComponentAccess, inWithNull, NullPointerException.class);\n-        assertEquals(2, simpleDecostructionPatternNoComponentAccess(inWithNullComponent));\n-        assertEquals(8, varAndConcrete(in));\n-        assertEquals(3, returnFromEnhancedFor(in));\n-        assertEquals(0, breakFromEnhancedFor(in));\n-        assertEquals(254, primitiveWidening(inBytes));\n-        assertEquals(8, sealedRecordPassBaseType(in_iface));\n-        assertEquals(8, withPrimitives(inWithPrimitives));\n-        assertEquals(List.of(Color.RED), JEPExample());\n-        assertEquals(1, arrayWithSealed(recs));\n-    }\n-\n-    static int iteratorEnhancedFor(List<Point> points) {\n-        int result = 0;\n-        for (Point(Integer a, Integer b) : points) {\n-            result += a + b;\n-        }\n-        return result;\n-    }\n-\n-    static int arrayEnhancedFor(Point[] points) {\n-        int result = 0;\n-        for (Point(Integer a, Integer b) : points) {\n-            result += a + b;\n-        }\n-        return result;\n-    }\n-\n-    static int simpleDecostructionPatternWithAccesses(List<Point> points) {\n-        int result = 0;\n-        for (Point(var a, var b): points) {\n-            result += a + b;\n-        }\n-        return result;\n-    }\n-\n-    static int simpleDecostructionPatternException(List<PointEx> points) {\n-        int result = 0;\n-        for (PointEx(var a, var b): points) {\n-            result += a + b;\n-        }\n-        return result;\n-    }\n-\n-    static int simpleDecostructionPatternNoComponentAccess(List<Point> points) {\n-        int result = 0;\n-        for (Point(var a, var b): points) {\n-            result += 1;\n-        }\n-        return result;\n-    }\n-\n-    static int varAndConcrete(List<Point> points) {\n-        int result = 0;\n-        for (Point(Integer a, var b): points) {\n-            result += a + b;\n-        }\n-        return result;\n-    }\n-\n-    static int returnFromEnhancedFor(List<Point> points) {\n-        for (Point(var a, var b): points) {\n-            return a + b;\n-        }\n-        return -1;\n-    }\n-\n-    static int breakFromEnhancedFor(List<Point> points) {\n-        int i = 1;\n-        int result = 0;\n-        for (Point(var a, var b): points) {\n-            if (i == 1) break;\n-            else result += a + b;\n-        }\n-        return result;\n-    }\n-\n-    static int sealedRecordPassBaseType(List<IPoint> points) {\n-        int result = 0;\n-\n-        for(Point(var x, var y) : points) {\n-            result += (x + y);\n-        }\n-\n-        return result;\n-    }\n-\n-    static int withPrimitives(List<WithPrimitives> points) {\n-        int result = 0;\n-        for (WithPrimitives(int a, double b): points) {\n-            result += a + (int) b;\n-        }\n-        return result;\n-    }\n-\n-    \/\/ Simpler pos tests with local variable declarations\n-    \/\/ Should pass now and in the future if local variable\n-    \/\/ declaration is subsumed by patterns (not just record patterns)\n-    static int primitiveWidening(byte[] inBytes) {\n-        int acc = 0;\n-        for (int i: inBytes) {\n-            acc += i;\n-        }\n-        return acc;\n-    }\n-\n-    static int applicability1(List<Point> points) {\n-        for (IPoint p: points) {\n-            System.out.println(p);\n-        }\n-        return -1;\n-    }\n-\n-    static int applicability2(List<Object> points) {\n-        for (Object p: points) {\n-            System.out.println(p);\n-        }\n-        return -1;\n-    }\n-\n-    static List<Color> JEPExample() {\n-        Rectangle rect = new Rectangle(\n-                new ColoredPoint(new Point(1,2), Color.RED),\n-                new ColoredPoint(new Point(3,4), Color.GREEN)\n-        );\n-        Rectangle[] rArr = {rect};\n-        return printUpperLeftColors(rArr);\n-    }\n-    \/\/where\n-    static List<Color> printUpperLeftColors(Rectangle[] r) {\n-        List<Color> ret = new ArrayList<>();\n-        for (Rectangle(ColoredPoint(Point p, Color c), ColoredPoint lr): r) {\n-            ret.add(c);\n-        }\n-        return ret;\n-    }\n-\n-    static int arrayWithSealed(IParent[] recs){\n-        for (Rec(int a) : recs) {\n-            return a;\n-        }\n-        return -1;\n-    }\n-\n-    enum Color { RED, GREEN, BLUE }\n-    record ColoredPoint(Point p, Color c) {}\n-    record Rectangle(ColoredPoint upperLeft, ColoredPoint lowerRight) {}\n-\n-    sealed interface IParent permits Rec {}\n-    record Rec(int a) implements IParent {}\n-\n-    sealed interface IPoint permits Point {}\n-    record Point(Integer x, Integer y) implements IPoint { }\n-\n-    record GPoint<T>(T x, T y) { }\n-    record VoidPoint() { }\n-    record RecordOfLists(List<Integer> o) {}\n-    record RecordOfLists2(List<List<Integer>> o) {}\n-\n-    @Target({ElementType.TYPE_USE, ElementType.LOCAL_VARIABLE})\n-    @interface Annot {\n-        String field();\n-    }\n-    record Frog(Integer x, Integer y) { }\n-    record PointEx(Integer x, Integer y) {\n-        @Override\n-        public Integer x() {\n-            throw new TestPatternFailed(EXCEPTION_MESSAGE);\n-        }\n-    }\n-    record WithPrimitives(int x, double y) { }\n-    static final String EXCEPTION_MESSAGE = \"exception-message\";\n-    public static class TestPatternFailed extends AssertionError {\n-        public TestPatternFailed(String message) {\n-            super(message);\n-        }\n-    }\n-\n-    \/\/ error handling\n-    static void fail(String message) {\n-        throw new AssertionError(message);\n-    }\n-\n-    static void assertEquals(Object expected, Object actual) {\n-        if (!Objects.equals(expected, actual)) {\n-            throw new AssertionError(\"Expected: \" + expected + \",\" +\n-                    \"got: \" + actual);\n-        }\n-    }\n-\n-    static <T> void assertMatchExceptionWithNested(Function<List<T>, Integer> f, List<T> points, Class<?> nestedExceptionClass) {\n-        try {\n-            f.apply(points);\n-            fail(\"Expected an exception, but none happened!\");\n-        }\n-        catch(Exception ex) {\n-            assertEquals(MatchException.class, ex.getClass());\n-\n-            MatchException me = (MatchException) ex;\n-\n-            assertEquals(nestedExceptionClass, me.getCause().getClass());\n-        }\n-    }\n-\n-    static <T> void assertEx(Function<List<T>, Integer> f, List<T> points, Class<?> exceptionClass) {\n-        try {\n-            f.apply(points);\n-            fail(\"Expected an exception, but none happened!\");\n-        }\n-        catch(Exception ex) {\n-            assertEquals(exceptionClass, ex.getClass());\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/patterns\/ForEachPatterns.java","additions":0,"deletions":254,"binary":false,"changes":254,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary\n- * @enablePreview\n- * @compile\/fail\/ref=ForEachPatternsErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW ForEachPatternsErrors.java\n- *\/\n-\n-import java.util.List;\n-\n-public class ForEachPatternsErrors {\n-\n-    static void exhaustivity_error1(List<Object> points) {\n-        for (Point(var x, var y): points) {\n-            System.out.println();\n-        }\n-    }\n-\n-    static void exhaustivity_error2(List points) {\n-        for (Point(var x, var y): points) {\n-            System.out.println();\n-        }\n-    }\n-\n-    static void exhaustivity_error3(List<OPoint> opoints) {\n-        for (OPoint(String s, String t) : opoints) {\n-            System.out.println(s);\n-        }\n-    }\n-\n-    static void exhaustivity_error4(List<?> f) {\n-        for (Rec(var x): f){\n-        }\n-    }\n-\n-    static void applicability_error(List<Object> points) {\n-        for (Interface p: points) {\n-            System.out.println(p);\n-        }\n-    }\n-\n-    record  Rec(String x) { }\n-    interface Interface {}\n-    sealed interface IPoint permits Point {}\n-    record Point(Integer x, Integer y) implements IPoint { }\n-    record OPoint(Object x, Object y) { }\n-}\n","filename":"test\/langtools\/tools\/javac\/patterns\/ForEachPatternsErrors.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-ForEachPatternsErrors.java:36:27: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object, ForEachPatternsErrors.Interface)\n-ForEachPatternsErrors.java:13:9: compiler.err.foreach.not.exhaustive.on.type: ForEachPatternsErrors.Point, java.lang.Object\n-ForEachPatternsErrors.java:19:9: compiler.err.foreach.not.exhaustive.on.type: ForEachPatternsErrors.Point, java.lang.Object\n-ForEachPatternsErrors.java:25:9: compiler.err.foreach.not.exhaustive.on.type: ForEachPatternsErrors.OPoint, ForEachPatternsErrors.OPoint\n-ForEachPatternsErrors.java:31:9: compiler.err.foreach.not.exhaustive.on.type: ForEachPatternsErrors.Rec, compiler.misc.type.captureof: 1, ?\n-- compiler.note.preview.filename: ForEachPatternsErrors.java, DEFAULT\n-- compiler.note.preview.recompile\n-5 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/ForEachPatternsErrors.out","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -1,12 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary\n- * @enablePreview\n- * @compile -XDfind=all ForEachTestAllAnalyzers.java\n- *\/\n-public class ForEachTestAllAnalyzers {\n-    private void test(Iterable<? extends R> l) {\n-        for (R(Object a) : l) { }\n-    }\n-    record R(Object a) {}\n-}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/ForEachTestAllAnalyzers.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"deleted"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -50,2 +49,0 @@\n-        assertEquals(0, forEachInference(List.of(new Box(\"\"))));\n-        assertEquals(1, forEachInference(List.of(new Box(null))));\n@@ -109,7 +106,0 @@\n-    int forEachInference(Iterable<I<String>> b) {\n-        for (Box(var s) : b) {\n-            return s == null ? 1 : s.length();\n-        }\n-        return -1;\n-    }\n-\n","filename":"test\/langtools\/tools\/javac\/patterns\/GenericRecordDeconstructionPattern.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @enablePreview\n@@ -137,2 +136,2 @@\n-            case (Integer i) when i == 0: o = String.valueOf(i); return \"true\";\n-            case (Integer i) when i == 2: o = String.valueOf(i); return \"second\";\n+            case Integer i when i == 0: o = String.valueOf(i); return \"true\";\n+            case Integer i when i == 2: o = String.valueOf(i); return \"second\";\n@@ -145,2 +144,2 @@\n-            case (Integer i) when i == 0: o = String.valueOf(i); yield \"true\";\n-            case (Integer i) when i == 2: o = String.valueOf(i); yield \"second\";\n+            case Integer i when i == 0: o = String.valueOf(i); yield \"true\";\n+            case Integer i when i == 2: o = String.valueOf(i); yield \"second\";\n@@ -152,1 +151,1 @@\n-        if (o != null && o instanceof (Integer i) && i == 0) {\n+        if (o != null && o instanceof Integer i && i == 0) {\n@@ -154,1 +153,1 @@\n-        } else if (o != null && o instanceof (Integer i) && i == 2 && (o = i) != null) {\n+        } else if (o != null && o instanceof Integer i && i == 2 && (o = i) != null) {\n","filename":"test\/langtools\/tools\/javac\/patterns\/Guards.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @enablePreview\n@@ -44,0 +43,31 @@\n+    void variablesInGuards(Object o) {\n+        final int i1;\n+              int i2 = 0;\n+        switch (o) {\n+            case Integer v when (i1 = 0) == 0 -> {}\n+            case Integer v when i2++ == 0 -> {}\n+            case Integer v when ++i2 == 0 -> {}\n+            case Integer v when new Predicate() {\n+                public boolean test() {\n+                    final int i;\n+                    i = 2;\n+                    return i == 2;\n+                }\n+            }.test() -> {}\n+            case Number v1 when v1 instanceof Integer v2 && (v2 = 0) == 0 -> {}\n+            default -> {}\n+        }\n+    }\n+\n+    GuardsErrors(Object o) {\n+        switch (o) {\n+            case Integer v when (f = 0) == 0 -> {}\n+            default -> throw new RuntimeException();\n+        }\n+    }\n+\n+    final int f;\n+\n+    interface Predicate {\n+        public boolean test();\n+    }\n","filename":"test\/langtools\/tools\/javac\/patterns\/GuardsErrors.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1,4 +1,6 @@\n-GuardsErrors.java:37:38: compiler.err.cant.ref.non.effectively.final.var: check, (compiler.misc.guard)\n-- compiler.note.preview.filename: GuardsErrors.java, DEFAULT\n-- compiler.note.preview.recompile\n-1 error\n+GuardsErrors.java:36:38: compiler.err.cant.ref.non.effectively.final.var: check, (compiler.misc.guard)\n+GuardsErrors.java:47:34: compiler.err.cannot.assign.not.declared.guard: i1\n+GuardsErrors.java:48:33: compiler.err.cant.ref.non.effectively.final.var: i2, (compiler.misc.guard)\n+GuardsErrors.java:49:35: compiler.err.cant.ref.non.effectively.final.var: i2, (compiler.misc.guard)\n+GuardsErrors.java:64:34: compiler.err.cannot.assign.not.declared.guard: f\n+5 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/GuardsErrors.out","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-InstanceofTotalPattern.java:18:37: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.pattern.matching.instanceof), 15, 16\n+InstanceofTotalPattern.java:19:37: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.pattern.matching.instanceof), 15, 16\n","filename":"test\/langtools\/tools\/javac\/patterns\/InstanceofTotalPattern-15.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,3 +1,2 @@\n-InstanceofTotalPattern.java:18:19: compiler.err.instanceof.pattern.no.subtype: java.lang.String, java.lang.String\n-InstanceofTotalPattern.java:22:17: compiler.err.instanceof.pattern.no.subtype: java.lang.String, java.lang.String\n-2 errors\n+InstanceofTotalPattern.java:19:19: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.unconditional.patterns.in.instanceof), 16, 21\n+1 error\n","filename":"test\/langtools\/tools\/javac\/patterns\/InstanceofTotalPattern-16.out","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,2 @@\n+InstanceofTotalPattern.java:19:19: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.unconditional.patterns.in.instanceof), 20, 21\n+1 error\n","filename":"test\/langtools\/tools\/javac\/patterns\/InstanceofTotalPattern-20.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -1,3 +0,0 @@\n-InstanceofTotalPattern.java:18:30: compiler.warn.preview.feature.use.plural: (compiler.misc.feature.unconditional.patterns.in.instanceof)\n-InstanceofTotalPattern.java:22:28: compiler.warn.preview.feature.use.plural: (compiler.misc.feature.unconditional.patterns.in.instanceof)\n-2 warnings\n","filename":"test\/langtools\/tools\/javac\/patterns\/InstanceofTotalPattern-preview.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -6,2 +6,3 @@\n- * @compile\/ref=InstanceofTotalPattern-preview.out --enable-preview -source ${jdk.version} -Xlint:-options,preview -XDrawDiagnostics InstanceofTotalPattern.java\n- * @run main\/othervm --enable-preview InstanceofTotalPattern\n+ * @compile\/fail\/ref=InstanceofTotalPattern-20.out --release 20 -XDrawDiagnostics InstanceofTotalPattern.java\n+ * @compile InstanceofTotalPattern.java\n+ * @run main InstanceofTotalPattern\n","filename":"test\/langtools\/tools\/javac\/patterns\/InstanceofTotalPattern.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/patterns\/LambdaCannotCapturePatternVariables.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @run main\/othervm --enable-preview MatchExceptionTest\n+ * @run main MatchExceptionTest\n@@ -93,3 +93,2 @@\n-            new Setup(false, \"-source\", \"20\"),\n-            new Setup(false, \"-source\", JAVA_VERSION),\n-            new Setup(true, \"-source\", JAVA_VERSION, \"--enable-preview\"),\n+            new Setup(false, \"--release\", \"20\"),\n+            new Setup(true),\n@@ -97,1 +96,1 @@\n-        record Source(String source, boolean needsPreview) {}\n+        record Source(String source, boolean needs21) {}\n@@ -105,2 +104,2 @@\n-                if (source.needsPreview &&\n-                    !Arrays.asList(variant.options).contains(\"--enable-preview\")) {\n+                if (source.needs21 &&\n+                    !Arrays.asList(variant.options).contains(\"21\")) {\n","filename":"test\/langtools\/tools\/javac\/patterns\/MatchExceptionTest.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/patterns\/NestedDeconstructionPattern.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-                .options(\"--enable-preview\", \"-source\", JAVA_VERSION)\n","filename":"test\/langtools\/tools\/javac\/patterns\/NestedPatternVariablesBytecode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/patterns\/NestedPrimitiveDeconstructionPattern.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-                                            \"(String s)\",\n@@ -73,1 +72,0 @@\n-                                            \"(R(int i))\",\n@@ -330,1 +328,1 @@\n-                           case (Integer i) when i > 0 -> 0;\n+                           case Integer i when i > 0 -> 0;\n@@ -347,2 +345,2 @@\n-                           case (Integer i) when i > 0 -> 0;\n-                           case (Integer i) when i > 0 -> 0;\n+                           case Integer i when i > 0 -> 0;\n+                           case Integer i when i > 0 -> 0;\n@@ -361,1 +359,1 @@\n-                           case (Integer i) when i > 0 -> 0;\n+                           case Integer i when i > 0 -> 0;\n@@ -378,1 +376,1 @@\n-                           case (Integer i) when i > 0 -> 0;\n+                           case Integer i when i > 0 -> 0;\n@@ -434,3 +432,1 @@\n-            .options(\"--enable-preview\",\n-                     \"-source\", JAVA_VERSION,\n-                     \"-XDrawDiagnostics\",\n+            .options(\"-XDrawDiagnostics\",\n","filename":"test\/langtools\/tools\/javac\/patterns\/NewCaseStructureTest.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -5,1 +5,5 @@\n- * @compile\/fail\/ref=NoSubtypeCheck.out -XDrawDiagnostics NoSubtypeCheck.java\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main NoSubtypeCheck\n@@ -7,11 +11,89 @@\n-public class NoSubtypeCheck {\n-\n-    public static void main(Object o, String s, List<String> l) {\n-        boolean b1 = o instanceof Object v1;\n-        boolean b2 = o instanceof String v2;\n-        boolean b3 = s instanceof Object v3;\n-        boolean b4 = s instanceof String v4;\n-        boolean b5 = l instanceof List<String> v5;\n-        boolean b6 = l instanceof List2<String> v6;\n-        boolean b7 = undef instanceof String v7;\n-        boolean b8 = o instanceof Undef v7;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class NoSubtypeCheck extends TestRunner {\n+\n+    ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new NoSubtypeCheck().runTests();\n+    }\n+\n+    NoSubtypeCheck() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testSimple(Path base) throws Exception {\n+        record TestCase(String test, String expectedError) {}\n+        TestCase[] testCases = new TestCase[] {\n+            new TestCase(\"boolean b1 = o instanceof Object v1;\",\n+                         \"Test.java:3:24: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.unconditional.patterns.in.instanceof), 20, 21\"),\n+            new TestCase(\"boolean b2 = o instanceof String v2;\", null),\n+            new TestCase(\"boolean b3 = s instanceof Object v3;\",\n+                         \"Test.java:3:24: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.unconditional.patterns.in.instanceof), 20, 21\"),\n+            new TestCase(\"boolean b4 = s instanceof String v4;\",\n+                         \"Test.java:3:24: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.unconditional.patterns.in.instanceof), 20, 21\"),\n+            new TestCase(\"boolean b5 = l instanceof List<String> v5;\",\n+                         \"Test.java:3:24: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.unconditional.patterns.in.instanceof), 20, 21\"),\n+            new TestCase(\"boolean b6 = l instanceof List2<String> v6;\", null),\n+            new TestCase(\"boolean b7 = undef instanceof String v7;\",\n+                         \"Test.java:3:22: compiler.err.cant.resolve.location: kindname.variable, undef, , , (compiler.misc.location: kindname.class, Test, null)\"),\n+            new TestCase(\"boolean b8 = o instanceof Undef v7;\",\n+                         \"Test.java:3:35: compiler.err.cant.resolve.location: kindname.class, Undef, , , (compiler.misc.location: kindname.class, Test, null)\"),\n+        };\n+\n+        for (TestCase testCase : testCases) {\n+            System.err.println(\"==running testcase: \" + testCase.test);\n+            Path current = base.resolve(\".\");\n+            Path src = current.resolve(\"src\");\n+\n+            tb.writeJavaFiles(src, \"\"\"\n+                                   public class Test {\n+                                       public static void main(Object o, String s, List<String> l) {\n+                                           {testCase.test}\n+                                       }\n+\n+                                       public interface List<T> {}\n+                                       public interface List2<T> extends List<T> {}\n+                                   }\n+                                   \"\"\".replace(\"{testCase.test}\", testCase.test));\n+\n+            Path classes = current.resolve(\"classes\");\n+\n+            Files.createDirectories(classes);\n+\n+            List<String> log = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\",\n+                         \"--release\", \"20\")\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(testCase.expectedError != null ? Task.Expect.FAIL : Task.Expect.SUCCESS)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+            if (testCase.expectedError != null) {\n+                List<String> expectedOutput = new ArrayList<>();\n+\n+                expectedOutput.add(testCase.expectedError);\n+                expectedOutput.add(\"1 error\");\n+\n+                if (!expectedOutput.equals(log)) {\n+                    throw new AssertionError(\"Unexpected output:\\n\" + log);\n+                }\n+            }\n+        }\n@@ -20,2 +102,0 @@\n-    public interface List<T> {}\n-    public interface List2<T> extends List<T> {}\n","filename":"test\/langtools\/tools\/javac\/patterns\/NoSubtypeCheck.java","additions":94,"deletions":14,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -5,1 +5,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/patterns\/NullSwitch.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,1 +4,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/patterns\/NullsInDeconstructionPatterns.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * @compile\/fail\/ref=NullsInPatterns.out -XDrawDiagnostics NullsInPatterns.java\n+ * @run main NullsInPatterns\n@@ -11,1 +11,1 @@\n-    public static void meth() {\n+    public static void main(String... args) {\n","filename":"test\/langtools\/tools\/javac\/patterns\/NullsInPatterns.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @enablePreview\n+ * @compile\/fail\/ref=Parenthesized.out -XDrawDiagnostics Parenthesized.java\n","filename":"test\/langtools\/tools\/javac\/patterns\/Parenthesized.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,5 @@\n+Parenthesized.java:38:18: compiler.err.illegal.start.of.type\n+Parenthesized.java:42:18: compiler.err.illegal.start.of.type\n+Parenthesized.java:45:26: compiler.err.illegal.start.of.type\n+Parenthesized.java:48:35: compiler.err.illegal.start.of.type\n+4 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/Parenthesized.out","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -1,169 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-import combo.ComboInstance;\n-import combo.ComboParameter;\n-import combo.ComboTask;\n-import combo.ComboTestHelper;\n-import toolbox.ToolBox;\n-\n-\/*\n- * @test\n- * @bug 8269674\n- * @summary Improve testing of parenthesized patterns\n- * @library \/tools\/lib \/tools\/javac\/lib\n- * @modules\n- *      jdk.compiler\/com.sun.tools.javac.api\n- *      jdk.compiler\/com.sun.tools.javac.file\n- *      jdk.compiler\/com.sun.tools.javac.main\n- *      jdk.compiler\/com.sun.tools.javac.util\n- * @build toolbox.ToolBox toolbox.JavacTask\n- * @build combo.ComboTestHelper\n- * @compile ParenthesizedCombo.java\n- * @run main\/othervm ParenthesizedCombo\n- *\/\n-public class ParenthesizedCombo extends ComboInstance<ParenthesizedCombo> {\n-    protected ToolBox tb;\n-\n-    ParenthesizedCombo() {\n-        super();\n-        tb = new ToolBox();\n-    }\n-\n-    public static void main(String... args) throws Exception {\n-        new ComboTestHelper<ParenthesizedCombo>()\n-                .withDimension(\"PATTERN_USE\", (x, patternUse) -> x.patternUse = patternUse, PATTERN_USE.values())\n-                .withDimension(\"CASE_LABEL\", (x, caseLabel) -> x.caseLabel = caseLabel, CASE_LABEL.values())\n-                .withDimension(\"TYPE_PATTERN\", (x, typePattern) -> x.typePattern = typePattern, TYPE_PATTERN.values())\n-                .run(ParenthesizedCombo::new);\n-    }\n-\n-    private PATTERN_USE patternUse;\n-    private CASE_LABEL caseLabel;\n-    private TYPE_PATTERN typePattern;\n-\n-    private static final String MAIN_TEMPLATE =\n-        \"\"\"\n-        public class Test {\n-            record StringBox(String s1) {}\n-            record StringBox2(StringBox s) {}\n-            public static void test(Object o) {\n-                #{PATTERN_USE}\n-            }\n-        }\n-        \"\"\";\n-\n-    @Override\n-    protected void doWork() throws Throwable {\n-        ComboTask task = newCompilationTask()\n-                .withSourceFromTemplate(MAIN_TEMPLATE, pname -> switch (pname) {\n-                    case \"PATTERN_USE\" -> patternUse;\n-                    case \"CASE_LABEL\" -> caseLabel;\n-                    case \"TYPE_PATTERN\" -> typePattern;\n-                    default -> throw new UnsupportedOperationException(pname);\n-                })\n-                .withOption(\"--enable-preview\")\n-                .withOption(\"-source\")\n-                .withOption(String.valueOf(Runtime.version().feature()));\n-        task.generate(result -> {\n-            if (result.hasErrors()) {\n-                throw new AssertionError(\"Unexpected result: \" + result.compilationInfo());\n-            }\n-        });\n-    }\n-\n-    public enum TYPE_PATTERN implements ComboParameter {\n-        SIMPLE(\"String s1\"),\n-        PARENTHESIZED_SIMPLE(\"(String s1)\");\n-\n-        private final String code;\n-\n-        private TYPE_PATTERN(String code) {\n-            this.code = code;\n-        }\n-\n-        @Override\n-        public String expand(String optParameter) {\n-            return code;\n-        }\n-    }\n-\n-    public enum CASE_LABEL implements ComboParameter {\n-        TYPE_PATTERN(\"#{TYPE_PATTERN}\"),\n-        PARENTHESIZED_RECORD_PATTERN(\"(StringBox(#{TYPE_PATTERN}))\"),\n-        PARENTHESIZED_RECORD_PATTERN_DEEP(\"(StringBox2(StringBox(#{TYPE_PATTERN})))\");\n-\n-        private final String code;\n-\n-        private CASE_LABEL(String code) {\n-            this.code = code;\n-        }\n-\n-        @Override\n-        public String expand(String optParameter) {\n-            return code;\n-        }\n-    }\n-\n-    public enum PATTERN_USE implements ComboParameter {\n-        SWITCH_EXPR_VOID(\n-            \"\"\"\n-            switch (o) {\n-                case #{CASE_LABEL} when s1.isEmpty() -> System.err.println(\"OK: \" + s1);\n-                    default -> throw new AssertionError();\n-            }\n-            \"\"\"),\n-        SWITCH_STAT_VOID(\n-            \"\"\"\n-            switch (o) {\n-                case #{CASE_LABEL} when s1.isEmpty():\n-                    System.err.println(\"OK: \" + s1);\n-                    break;\n-                default:\n-                    throw new AssertionError();\n-            }\n-            \"\"\"),\n-        SWITCH_EXPR_STRING(\n-            \"\"\"\n-            System.err.println(switch (o) {\n-                case #{CASE_LABEL} when s1.isEmpty() -> \"OK: \" + s1;\n-                    default -> throw new AssertionError();\n-            });\n-            \"\"\"),\n-        IF_INSTANCEOF(\n-            \"\"\"\n-            if (o instanceof #{CASE_LABEL} && s1.isEmpty()) {\n-                System.err.println(\"OK: \" + s1);\n-            }\n-            \"\"\");\n-        private final String body;\n-\n-        private PATTERN_USE(String body) {\n-            this.body = body;\n-        }\n-\n-        @Override\n-        public String expand(String optParameter) {\n-            return body;\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/patterns\/ParenthesizedCombo.java","additions":0,"deletions":169,"binary":false,"changes":169,"status":"deleted"},{"patch":"@@ -5,1 +5,0 @@\n- * @enablePreview\n@@ -8,0 +7,1 @@\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/PatternCaseErrorRecovery.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @enablePreview\n@@ -59,2 +58,0 @@\n-    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n-\n@@ -168,2 +165,0 @@\n-                    .options(\"--enable-preview\",\n-                             \"-source\", JAVA_VERSION)\n@@ -184,3 +179,1 @@\n-                    .options(\"--enable-preview\",\n-                             \"-source\", JAVA_VERSION,\n-                             \"-XDrawDiagnostics\",\n+                    .options(\"-XDrawDiagnostics\",\n@@ -264,2 +257,0 @@\n-                    .options(\"--enable-preview\",\n-                             \"-source\", JAVA_VERSION)\n@@ -280,3 +271,1 @@\n-                    .options(\"--enable-preview\",\n-                             \"-source\", JAVA_VERSION,\n-                             \"-XDrawDiagnostics\",\n+                    .options(\"-XDrawDiagnostics\",\n","filename":"test\/langtools\/tools\/javac\/patterns\/PatternDesugaring.java","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,3 +0,0 @@\n-PatternErrorRecovery.java:12:18: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.pattern.switch)\n-PatternErrorRecovery.java:11:18: compiler.err.const.expr.req\n-2 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/PatternErrorRecovery-no-preview.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -0,0 +1,3 @@\n+PatternErrorRecovery.java:12:18: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.pattern.switch), 20, 21\n+PatternErrorRecovery.java:11:18: compiler.err.const.expr.req\n+2 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/PatternErrorRecovery-old.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -5,2 +5,2 @@\n- * @compile\/fail\/ref=PatternErrorRecovery.out -XDrawDiagnostics -XDshould-stop.at=FLOW --enable-preview -source ${jdk.version} PatternErrorRecovery.java\n- * @compile\/fail\/ref=PatternErrorRecovery-no-preview.out -XDrawDiagnostics -XDshould-stop.at=FLOW PatternErrorRecovery.java\n+ * @compile\/fail\/ref=PatternErrorRecovery.out -XDrawDiagnostics -XDshould-stop.at=FLOW PatternErrorRecovery.java\n+ * @compile\/fail\/ref=PatternErrorRecovery-old.out --release 20 -XDrawDiagnostics -XDshould-stop.at=FLOW PatternErrorRecovery.java\n","filename":"test\/langtools\/tools\/javac\/patterns\/PatternErrorRecovery.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,2 +2,0 @@\n-- compiler.note.preview.filename: PatternErrorRecovery.java, DEFAULT\n-- compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/patterns\/PatternErrorRecovery.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @enablePreview\n@@ -96,1 +95,1 @@\n-            List.of(\"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature())), null,\n+            List.of(), null,\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrettyTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/patterns\/ProxyMethodLookup.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5,1 +5,0 @@\n- * @enablePreview\n@@ -8,0 +7,1 @@\n+\n@@ -17,4 +17,0 @@\n-        switch (o) {\n-            case (RawTypeBindingWarning w) -> {}\n-            default -> {}\n-        }\n","filename":"test\/langtools\/tools\/javac\/patterns\/RawTypeBindingWarning.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,5 +3,2 @@\n-RawTypeBindingWarning.java:18:19: compiler.warn.raw.class.use: RawTypeBindingWarning, RawTypeBindingWarning<T>\n-RawTypeBindingWarning.java:22:18: compiler.warn.raw.class.use: RawTypeBindingWarning, RawTypeBindingWarning<T>\n-- compiler.note.preview.filename: RawTypeBindingWarning.java, DEFAULT\n-- compiler.note.preview.recompile\n-4 warnings\n\\ No newline at end of file\n+RawTypeBindingWarning.java:18:18: compiler.warn.raw.class.use: RawTypeBindingWarning, RawTypeBindingWarning<T>\n+3 warnings\n","filename":"test\/langtools\/tools\/javac\/patterns\/RawTypeBindingWarning.out","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/patterns\/SealedTypeChanges.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/patterns\/SimpleAndGuardPattern.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,3 +3,3 @@\n- * @compile\/fail\/ref=SimpleDeconstructionPatternNoPreview.out -XDrawDiagnostics SimpleDeconstructionPattern.java\n- * @compile --enable-preview -source ${jdk.version} SimpleDeconstructionPattern.java\n- * @run main\/othervm --enable-preview SimpleDeconstructionPattern\n+ * @compile\/fail\/ref=SimpleDeconstructionPatternOld.out --release 20 -XDrawDiagnostics SimpleDeconstructionPattern.java\n+ * @compile SimpleDeconstructionPattern.java\n+ * @run main SimpleDeconstructionPattern\n","filename":"test\/langtools\/tools\/javac\/patterns\/SimpleDeconstructionPattern.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-SimpleDeconstructionPattern.java:118:27: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.deconstruction.patterns)\n-1 error\n","filename":"test\/langtools\/tools\/javac\/patterns\/SimpleDeconstructionPatternNoPreview.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -0,0 +1,2 @@\n+SimpleDeconstructionPattern.java:118:27: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.deconstruction.patterns), 20, 21\n+1 error\n","filename":"test\/langtools\/tools\/javac\/patterns\/SimpleDeconstructionPatternOld.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -49,2 +49,0 @@\n-    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n-\n@@ -79,1 +77,1 @@\n-               \"Test.java:5:18: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.pattern.switch)\",\n+               \"Test.java:5:18: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.pattern.switch), 17, 21\",\n@@ -95,1 +93,1 @@\n-               \"Test.java:4:26: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.pattern.switch)\",\n+               \"Test.java:4:26: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.pattern.switch), 17, 21\",\n@@ -112,1 +110,1 @@\n-               \"Test.java:5:18: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.pattern.switch)\",\n+               \"Test.java:5:18: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.pattern.switch), 17, 21\",\n@@ -124,1 +122,1 @@\n-                           case default:\n+                           case null, default:\n@@ -129,1 +127,1 @@\n-               \"Test.java:5:18: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.pattern.switch)\",\n+               \"Test.java:5:24: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.pattern.switch), 17, 21\",\n@@ -143,2 +141,1 @@\n-                    .options(\"-source\", \"11\",\n-                             \"-Xlint:-options\",\n+                    .options(\"--release\", \"17\",\n","filename":"test\/langtools\/tools\/javac\/patterns\/SourceLevelChecks.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -5,1 +5,0 @@\n- * @enablePreview\n@@ -8,0 +7,1 @@\n+\n@@ -192,1 +192,1 @@\n-    void test8269146a2(Integer i) {\n+    void test8269146a2a(Integer i) {\n@@ -195,1 +195,1 @@\n-            case Integer o when o != null, 1:\n+            case Integer o, 1:\n@@ -220,1 +220,1 @@\n-            case 1, Integer o when o != null, default:\n+            case 1, Integer o, default:\n@@ -224,1 +224,1 @@\n-    void test8269301b(Integer i) {\n+    void test8269301ba(Integer i) {\n@@ -227,1 +227,1 @@\n-            case Integer o when o != null, 1, default:\n+            case Integer o, 1, default:\n@@ -255,1 +255,1 @@\n-            case null, ((R r)): break;\n+            case null, R r: break;\n@@ -262,1 +262,1 @@\n-            case null, ((R(var v))): break;\n+            case null, R(var v): break;\n@@ -269,1 +269,1 @@\n-            case ((R r)): case null: break;\n+            case R r: case null: break;\n@@ -276,1 +276,1 @@\n-            case ((R(var v))): case null: break;\n+            case R(var v): case null: break;\n@@ -303,0 +303,23 @@\n+    void test8269146a2b(Integer i) {\n+        switch (i) {\n+            \/\/error - illegal combination of pattern and constant:\n+            case Integer o when o != null, 1:\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+    void test8269301ab(Integer i) {\n+        switch (i) {\n+            \/\/error - illegal combination of pattern, constant and default\n+            case 1, Integer o when o != null, default:\n+                break;\n+        }\n+    }\n+    void test8269301bb(Integer i) {\n+        switch (i) {\n+            \/\/error - illegal combination of pattern, constant and default\n+            case Integer o when o != null, 1, default:\n+                break;\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.java","additions":33,"deletions":10,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -9,2 +9,2 @@\n-SwitchErrors.java:220:47: compiler.err.default.label.not.allowed\n-SwitchErrors.java:227:47: compiler.err.default.label.not.allowed\n+SwitchErrors.java:220:32: compiler.err.default.label.not.allowed\n+SwitchErrors.java:227:32: compiler.err.default.label.not.allowed\n@@ -13,0 +13,3 @@\n+SwitchErrors.java:306:42: compiler.err.expected2: :, ->\n+SwitchErrors.java:315:45: compiler.err.expected2: :, ->\n+SwitchErrors.java:322:42: compiler.err.expected2: :, ->\n@@ -44,1 +47,2 @@\n-SwitchErrors.java:195:44: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:197:13: compiler.err.unconditional.pattern.and.default\n+SwitchErrors.java:195:29: compiler.err.flows.through.from.pattern\n@@ -47,1 +51,1 @@\n-SwitchErrors.java:227:44: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:227:29: compiler.err.flows.through.from.pattern\n@@ -58,0 +62,1 @@\n+SwitchErrors.java:315:21: compiler.err.invalid.case.label.combination\n@@ -70,3 +75,1 @@\n-- compiler.note.preview.filename: SwitchErrors.java, DEFAULT\n-- compiler.note.preview.recompile\n-69 errors\n+74 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.out","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-\n@@ -34,1 +33,0 @@\n- * @enablePreview\n@@ -56,0 +54,1 @@\n+        runEnumTest(this::testEnumWithGuards5);\n@@ -60,0 +59,1 @@\n+        runEnumTest(this::testEnumWithGuardsExpression5);\n@@ -352,0 +352,22 @@\n+    String testEnumWithGuards5(Object e) {\n+        switch (e) {\n+            case E.A: return \"a\";\n+            case E.B: return \"b\";\n+            case Runnable x when \"C\".equals(x.toString()): return \"C\";\n+            case E x: return e == E.C ? \"broken\" : String.valueOf(x);\n+            case null: return \"null\";\n+            default: throw new AssertionError(\"Unexpected case!\");\n+        }\n+    }\n+\n+    String testEnumWithGuardsExpression5(Object e) {\n+        return switch (e) {\n+            case E.A -> \"a\";\n+            case E.B -> \"b\";\n+            case Runnable x when \"C\".equals(x.toString()) -> \"C\";\n+            case E x -> e == E.C ? \"broken\" : String.valueOf(x);\n+            case null -> \"null\";\n+            default -> throw new AssertionError(\"Unexpected case!\");\n+        };\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Switches.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8291657.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n-\n@@ -208,2 +206,0 @@\n-                    .options(\"--enable-preview\",\n-                             \"-source\", JAVA_VERSION)\n@@ -225,3 +221,1 @@\n-            .options(\"--enable-preview\",\n-                     \"-source\", JAVA_VERSION,\n-                     \"-Xlint:-preview\",\n+            .options(\"-Xlint:-preview\",\n","filename":"test\/langtools\/tools\/javac\/patterns\/TranslationTest.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/patterns\/TypedDeconstructionPatternExc.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,1 +4,0 @@\n- * @enablePreview\n@@ -7,0 +6,1 @@\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/VarErrors.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,2 +4,0 @@\n-- compiler.note.preview.filename: VarErrors.java, DEFAULT\n-- compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/patterns\/VarErrors.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -96,2 +96,0 @@\n-                .options(\"--enable-preview\",\n-                         \"-source\", JAVA_VERSION)\n@@ -132,4 +130,1 @@\n-                        .options(\"--enable-preview\",\n-                                 \"-source\", JAVA_VERSION,\n-                                 \"-XDrawDiagnostics\",\n-                                 \"-Xlint:-preview\",\n+                        .options(\"-XDrawDiagnostics\",\n@@ -146,2 +141,0 @@\n-                   \"- compiler.note.preview.filename: Test1.java, DEFAULT\",\n-                   \"- compiler.note.preview.recompile\",\n@@ -176,4 +169,1 @@\n-                        .options(\"--enable-preview\",\n-                                 \"-source\", JAVA_VERSION,\n-                                 \"-XDrawDiagnostics\",\n-                                 \"-Xlint:-preview\",\n+                        .options(\"-XDrawDiagnostics\",\n","filename":"test\/langtools\/tools\/javac\/sealed\/MissingPermittedSubtypes.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+ * @compile --release 20 ExhaustiveEnumSwitch.java\n+ * @compile ExhaustiveEnumSwitchExtra.java\n+ * @run main ExhaustiveEnumSwitch IncompatibleClassChangeError\n@@ -30,1 +33,1 @@\n- * @run main ExhaustiveEnumSwitch\n+ * @run main ExhaustiveEnumSwitch MatchException\n@@ -34,2 +37,3 @@\n-    public static void main(String... args) {\n-        new ExhaustiveEnumSwitch().run();\n+    public static void main(String... args) throws ClassNotFoundException {\n+        boolean matchException = \"MatchException\".equals(args[0]);\n+        new ExhaustiveEnumSwitch().run(matchException);\n@@ -38,1 +42,1 @@\n-    private void run() {\n+    private void run(boolean matchException) throws ClassNotFoundException {\n@@ -45,1 +49,12 @@\n-            \/\/ok\n+            if (matchException) {\n+                throw new AssertionError(\"Expected IncompatibleClassChangeError, but got MatchException!\");\n+            }\n+        } catch (Exception ex) {\n+            \/\/cannot refer to MatchException directly, as it used to be preview API in JDK 20:\n+            if (ex.getClass() == Class.forName(\"java.lang.MatchException\")) {\n+                if (!matchException) {\n+                    throw new AssertionError(\"Expected MatchException, but got IncompatibleClassChangeError!\");\n+                }\n+            } else {\n+                throw ex;\n+            }\n","filename":"test\/langtools\/tools\/javac\/switchexpr\/ExhaustiveEnumSwitch.java","additions":21,"deletions":6,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -100,4 +100,1 @@\n-                    })\n-                .withOption(\"--enable-preview\")\n-                .withOption(\"-source\")\n-                .withOption(String.valueOf(Runtime.version().feature()));\n+                    });\n","filename":"test\/langtools\/tools\/javac\/switchexpr\/SwitchExpressionNoValue.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8300543\n+ * @summary Check switches work correctly with qualified enum constants\n+ * @compile EnumSwitchQualified.java\n+ * @run main EnumSwitchQualified\n+*\/\n+\n+import java.util.Objects;\n+\n+public class EnumSwitchQualified {\n+\n+    public static void main(String... args) {\n+        new EnumSwitchQualified().run();\n+    }\n+\n+    void run() {\n+        assertEquals(1, testPatternMatchingSwitch1(E1.A));\n+        assertEquals(2, testPatternMatchingSwitch1(E1.B));\n+        assertEquals(3, testPatternMatchingSwitch1(E1.C));\n+        assertEquals(4, testPatternMatchingSwitch1(E2.B));\n+        assertEquals(5, testPatternMatchingSwitch1(E2.C));\n+        assertEquals(6, testPatternMatchingSwitch1(E2.D));\n+\n+        assertEquals(1, testPatternMatchingSwitch2(E1.A));\n+        assertEquals(2, testPatternMatchingSwitch2(E1.B));\n+        assertEquals(3, testPatternMatchingSwitch2(E1.C));\n+\n+        assertEquals(1, testPatternMatchingSwitch3(E1.A));\n+        assertEquals(2, testPatternMatchingSwitch3(E1.B));\n+        assertEquals(3, testPatternMatchingSwitch3(E1.C));\n+        assertEquals(4, testPatternMatchingSwitch3(E2.B));\n+        assertEquals(5, testPatternMatchingSwitch3(E2.C));\n+        assertEquals(6, testPatternMatchingSwitch3(E2.D));\n+        assertEquals(7, testPatternMatchingSwitch3(\"\"));\n+    }\n+\n+    int testPatternMatchingSwitch1(I i) {\n+        return switch(i) {\n+            case E1.A -> 1;\n+            case E1.B -> 2;\n+            case E1.C -> 3;\n+            case E2.B -> 4;\n+            case E2.C -> 5;\n+            case E2.D -> 6;\n+        };\n+    }\n+\n+    int testPatternMatchingSwitch2(E1 e) {\n+        return switch(e) {\n+            case E1.A -> 1;\n+            case E1.B -> 2;\n+            case E1.C -> 3;\n+        };\n+    }\n+\n+    int testPatternMatchingSwitch3(Object o) {\n+        return switch(o) {\n+            case E1.A -> 1;\n+            case E1.B -> 2;\n+            case E1.C -> 3;\n+            case E2.B -> 4;\n+            case E2.C -> 5;\n+            case E2.D -> 6;\n+            default -> 7;\n+        };\n+    }\n+\n+    private void assertEquals(Object expected, Object actual) {\n+        if (!Objects.equals(expected, actual)) {\n+            throw new AssertionError(\"Incorrect result, expected: \" + expected +\n+                                     \", actual: \" + actual);\n+        }\n+    }\n+\n+    sealed interface I {}\n+    enum E1 implements I { A, B, C; }\n+    enum E2 implements I { B, C, D; }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/switchextra\/EnumSwitchQualified.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8300543\n+ * @summary Check switches work correctly with qualified enum constants\n+ * @compile\/fail\/ref=EnumSwitchQualifiedErrors.out -XDrawDiagnostics EnumSwitchQualifiedErrors.java\n+*\/\n+\n+public class EnumSwitchQualifiedErrors {\n+\n+    int testPatternMatchingSwitch1(I i) {\n+        return switch(i) {\n+            case E1.A -> 1;\n+            case E2.A -> 2;\n+        };\n+    }\n+\n+    int testPatternMatchingSwitch2(E1 e) {\n+        return switch(e) {\n+            case E1.A -> 1;\n+            case E2.A -> 4;\n+        };\n+    }\n+\n+    int testPatternMatchingSwitch3(Number n) {\n+        return switch(n) {\n+            case E1.A -> 1;\n+            case E2.A -> 2;\n+        };\n+    }\n+\n+    sealed interface I {}\n+    enum E1 implements I { A; }\n+    enum E2 { A; }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/switchextra\/EnumSwitchQualifiedErrors.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+EnumSwitchQualifiedErrors.java:36:20: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: EnumSwitchQualifiedErrors.E2, EnumSwitchQualifiedErrors.I)\n+EnumSwitchQualifiedErrors.java:43:20: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: EnumSwitchQualifiedErrors.E2, EnumSwitchQualifiedErrors.E1)\n+EnumSwitchQualifiedErrors.java:49:20: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: EnumSwitchQualifiedErrors.E1, java.lang.Number)\n+EnumSwitchQualifiedErrors.java:50:20: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: EnumSwitchQualifiedErrors.E2, java.lang.Number)\n+4 errors\n","filename":"test\/langtools\/tools\/javac\/switchextra\/EnumSwitchQualifiedErrors.out","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -98,1 +98,1 @@\n-            List.of(\"--enable-preview\", \"-source\", version), null,\n+            List.of(), null,\n","filename":"test\/langtools\/tools\/javac\/switchextra\/RuleParsingTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-SwitchNoExtraTypes.java:11:16: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.pattern.switch)\n@@ -6,1 +5,1 @@\n-5 errors\n+4 errors\n","filename":"test\/langtools\/tools\/javac\/switchextra\/SwitchNoExtraTypes.out","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-SwitchObject.java:10:16: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.pattern.switch)\n@@ -4,1 +3,1 @@\n-3 errors\n+2 errors\n","filename":"test\/langtools\/tools\/javac\/switchextra\/SwitchObject.out","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/switchnull\/SwitchNull.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-SwitchNullDisabled.java:13:18: compiler.err.preview.feature.disabled: (compiler.misc.feature.case.null)\n-1 error\n","filename":"test\/langtools\/tools\/javac\/switchnull\/SwitchNullDisabled-preview.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -4,4 +4,3 @@\n- * @summary Verify \"case null\" is not allowed for --release 16\n- * @compile\/fail\/ref=SwitchNullDisabled.out -XDrawDiagnostics --release 16 SwitchNullDisabled.java\n- * @compile\/fail\/ref=SwitchNullDisabled-preview.out -XDrawDiagnostics SwitchNullDisabled.java\n- * @compile --enable-preview -source ${jdk.version} SwitchNullDisabled.java\n+ * @summary Verify \"case null\" is not allowed for --release 16, 20\n+ * @compile\/fail\/ref=SwitchNullDisabled.out -XDrawDiagnostics --release 20 SwitchNullDisabled.java\n+ * @compile SwitchNullDisabled.java\n","filename":"test\/langtools\/tools\/javac\/switchnull\/SwitchNullDisabled.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-SwitchNullDisabled.java:13:18: compiler.err.preview.feature.disabled: (compiler.misc.feature.case.null)\n+SwitchNullDisabled.java:12:18: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.case.null), 20, 21\n","filename":"test\/langtools\/tools\/javac\/switchnull\/SwitchNullDisabled.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+        String testQuery = System.getProperty(\"test.query\");\n@@ -86,9 +87,12 @@\n-                try {\n-                    testCount++;\n-                    out.println(\"test: \" + testName);\n-                    m.invoke(this, f.apply(m));\n-                } catch (InvocationTargetException e) {\n-                    errorCount++;\n-                    Throwable cause = e.getCause();\n-                    out.println(\"Exception running test \" + testName + \": \" + e.getCause());\n-                    cause.printStackTrace(out);\n+                if (testQuery == null || testQuery.equals(testName)) {\n+                    try {\n+                        testCount++;\n+                        out.println(\"test: \" + testName);\n+                        m.invoke(this, f.apply(m));\n+                    } catch (InvocationTargetException e) {\n+                        errorCount++;\n+                        Throwable cause = e.getCause();\n+                        out.println(\"Exception running test \" + testName + \": \" + e.getCause());\n+                        cause.printStackTrace(out);\n+                    }\n+                    out.println();\n@@ -96,1 +100,0 @@\n-                out.println();\n","filename":"test\/langtools\/tools\/lib\/toolbox\/TestRunner.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"}]}