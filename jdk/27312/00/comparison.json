{"files":[{"patch":"@@ -2443,7 +2443,1 @@\n-  \/\/ Clear current young cset group to allow adding.\n-  \/\/ It is fine to clear it this late - evacuation does not add any remembered sets\n-  \/\/ by itself, but only marks cards.\n-  \/\/ The regions had their association to this group already removed earlier.\n-  young_regions_cset_group()->clear();\n-\n-  collection_set()->start_incremental_building();\n+  collection_set()->start();\n@@ -2801,6 +2795,1 @@\n-  collection_set()->clear();\n-  collection_set()->stop_incremental_building();\n-\n-  collection_set()->abandon_all_candidates();\n-\n-  young_regions_cset_group()->clear(true \/* uninstall_group_cardset *\/);\n+  collection_set()->abandon();\n@@ -3169,6 +3158,0 @@\n-\n-void G1CollectedHeap::prepare_group_cardsets_for_scan() {\n-  young_regions_cardset()->reset_table_scanner_for_groups();\n-\n-  collection_set()->prepare_for_scan();\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -794,5 +794,0 @@\n-  G1CardSet* young_regions_cardset() { return _young_regions_cset_group.card_set(); };\n-\n-  G1MonotonicArenaMemoryStats young_regions_card_set_memory_stats() { return _young_regions_cset_group.card_set_memory_stats(); }\n-\n-  void prepare_group_cardsets_for_scan();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -102,0 +102,8 @@\n+void G1CollectionSet::abandon() {\n+  _g1h->young_regions_cset_group()->clear(true \/* uninstall_cset_group *\/);\n+  clear();\n+  abandon_all_candidates();\n+\n+  stop_incremental_building();\n+}\n+\n@@ -108,0 +116,1 @@\n+  _g1h->young_regions_cset_group()->card_set()->reset_table_scanner_for_groups();\n@@ -130,1 +139,1 @@\n-void G1CollectionSet::start_incremental_building() {\n+void G1CollectionSet::start() {\n@@ -136,0 +145,3 @@\n+\n+  G1CSetCandidateGroup* young_group = _g1h->young_regions_cset_group();\n+  young_group->clear();\n@@ -326,1 +338,1 @@\n-  size_t num_young_cards = _g1h->young_regions_cardset()->occupied();\n+  size_t num_young_cards = _g1h->young_regions_cset_group()->card_set()->occupied();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -181,0 +181,2 @@\n+  uint groups_increment_length() const;\n+\n@@ -230,0 +232,1 @@\n+\n@@ -237,0 +240,2 @@\n+  \/\/ Drop the collection set and collection set candidates.\n+  void abandon();\n@@ -269,2 +274,2 @@\n-  \/\/ Initialize incremental collection set info.\n-  void start_incremental_building();\n+  \/\/ Start a new collection set for the next mutator phase.\n+  void start();\n@@ -285,2 +290,0 @@\n-  uint groups_increment_length() const;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-  uint length = groups_increment_length();\n@@ -36,1 +35,6 @@\n-  if (length == 0) {\n+  if (offset == 0) {\n+    G1HeapRegionRemSet::iterate_for_merge(_g1h->young_regions_cset_group()->card_set(), cl);\n+  }\n+\n+  uint next_increment_length = groups_increment_length();\n+  if (next_increment_length == 0) {\n@@ -40,1 +44,1 @@\n-  uint start_pos = (worker_id * length) \/ num_workers;\n+  uint start_pos = (worker_id * next_increment_length) \/ num_workers;\n@@ -47,1 +51,1 @@\n-    if (cur_pos == length) {\n+    if (cur_pos == next_increment_length) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.inline.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -120,0 +120,4 @@\n+  size_t cards_occupied() const {\n+    return _card_set.occupied();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -291,1 +291,1 @@\n-    size_t card_rs_length = g1h->young_regions_cardset()->occupied();\n+    size_t card_rs_length = g1h->young_regions_cset_group()->cards_occupied();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1355,4 +1355,0 @@\n-        if (_initial_evacuation) {\n-          G1HeapRegionRemSet::iterate_for_merge(g1h->young_regions_cardset(), merge);\n-        }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -510,1 +510,1 @@\n-    _g1h->prepare_group_cardsets_for_scan();\n+    _g1h->collection_set()->prepare_for_scan();\n@@ -520,1 +520,1 @@\n-    sampled_card_set_stats.add(_g1h->young_regions_card_set_memory_stats());\n+    sampled_card_set_stats.add(_g1h->young_regions_cset_group()->card_set_memory_stats());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}