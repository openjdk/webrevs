{"files":[{"patch":"@@ -1722,1 +1722,6 @@\n-     * Returns a SQL identifier. If {@code identifier} is a simple SQL identifier:\n+     * Returns a {@link #isSimpleIdentifier(String) simple SQL identifier} or a\n+     * delimited identifier.  A delimited identifier represents the name of a\n+     * database object such as a table, column, or view that is enclosed by a\n+     * delimiter, which is typically a double quote as defined by the SQL standard.\n+     * <p>\n+     * If {@code identifier} is a simple SQL identifier:\n@@ -1724,4 +1729,3 @@\n-     * <li>Return the original value if {@code alwaysDelimit} is\n-     * {@code false}<\/li>\n-     * <li>Return a delimited identifier if {@code alwaysDelimit} is\n-     * {@code true}<\/li>\n+     * <li>If {@code alwaysDelimit} is {@code false}, return the original value<\/li>\n+     * <li>if {@code alwaysDelimit} is {@code true}, enquote the original value\n+     * and return as a delimited identifier<\/li>\n@@ -1730,7 +1734,5 @@\n-     * If {@code identifier} is not a simple SQL identifier, {@code identifier} will be\n-     * enclosed in double quotes if not already present. If the datasource does\n-     * not support double quotes for delimited identifiers, the\n-     * identifier should be enclosed by the string returned from\n-     * {@link DatabaseMetaData#getIdentifierQuoteString}.  If the datasource\n-     * does not support delimited identifiers, a\n-     * {@code SQLFeatureNotSupportedException} should be thrown.\n+     * If {@code identifier} is not a simple SQL identifier, the delimited\n+     * {@code identifier} to be returned must be enclosed by the delimiter\n+     * returned from {@link DatabaseMetaData#getIdentifierQuoteString}. If\n+     * the datasource does not support delimited identifiers, a\n+     * {@code SQLFeatureNotSupportedException} is thrown.\n@@ -1739,2 +1741,2 @@\n-     * characters invalid in a delimited identifier or the identifier length is\n-     * invalid for the datasource.\n+     * invalid characters within a delimited identifier or the identifier length\n+     * is invalid for the datasource.\n@@ -1747,3 +1749,5 @@\n-     * <li>The first character is an alphabetic character from a through z, or\n-     * from A through Z<\/li>\n-     * <li>The name only contains alphanumeric characters or the character \"_\"<\/li>\n+     * <li>The first character is an alphabetic character from a ({@code '\\u005C0061'})\n+     * through z ({@code '\\u005Cu007A'}), or from A ({@code '\\u005Cu0041'})\n+     * through Z ({@code '\\u005Cu005A'})<\/li>\n+     * <li>The name only contains alphanumeric characters([0-9A-Za-z])\n+     * or the character \"_\"<\/li>\n@@ -1754,2 +1758,3 @@\n-     * <li>{@code identifier} contains a {@code null} character or double quote and is not\n-     * a simple SQL identifier.<\/li>\n+     * <li> {@link DatabaseMetaData#getIdentifierQuoteString} does not return a\n+     * double quote<\/li>\n+     * <li>{@code identifier} contains a {@code null} character or double quote<\/li>\n@@ -1794,0 +1799,10 @@\n+     * <th scope=\"row\">\"select\"<\/th>\n+     * <td>false<\/td>\n+     * <td>\"select\"<\/td>\n+     * <\/tr>\n+     * <tr>\n+     * <th scope=\"row\">\"select\"<\/th>\n+     * <td>true<\/td>\n+     * <td>\"select\"<\/td>\n+     * <\/tr>\n+     * <tr>\n@@ -1817,1 +1832,1 @@\n-     * returned as a delmited identifier\n+     * returned as a delimited identifier\n@@ -1827,1 +1842,2 @@\n-        return SQLUtils.enquoteIdentifier(identifier, alwaysDelimit);\n+        String delimiter = this.getMetaData().getIdentifierQuoteString();\n+        return SQLUtils.enquoteIdentifier(delimiter, identifier, alwaysDelimit);\n@@ -1831,4 +1847,6 @@\n-     * Retrieves whether {@code identifier} is a simple SQL identifier.\n-     *\n-     * @implSpec The default implementation uses the following criteria to\n-     * determine a valid simple SQL identifier:\n+     * Returns whether {@code identifier} is a simple SQL identifier.\n+     * A simple SQL identifier is referred to as regular (or ordinary) identifier\n+     * within the SQL standard.  A regular identifier represents the name of a database\n+     * object such as a table, column, or view.\n+     * <p>\n+     * The rules for a regular Identifier are:\n@@ -1836,1 +1854,0 @@\n-     * <li>The string is not enclosed in double quotes<\/li>\n@@ -1840,3 +1857,22 @@\n-     * <li>The string only contains alphanumeric characters or the character\n-     * \"_\"<\/li>\n-     * <li>The string is between 1 and 128 characters in length inclusive<\/li>\n+     * <li>The name only contains alphanumeric characters([0-9A-Za-z])\n+     * or the character \"_\"<\/li>\n+     * <li>It cannot be a SQL reserved word<\/li>\n+     * <\/ul>\n+     * <p>\n+     * A datasource may have additional rules for a regular identifier such as:\n+     * <ul>\n+     * <li>Supports additional characters within the name based on\n+     * the locale being used<\/li>\n+     * <li>Supports a different maximum length for the identifier<\/li>\n+     * <\/ul>\n+     *\n+     * @implSpec The default implementation uses the following criteria to\n+     * determine a valid simple SQL identifier:\n+     * <ul>\n+     * <li>The identifier is not enclosed in double quotes<\/li>\n+     * <li>The first character is an alphabetic character from a through z, or\n+     * from A through Z<\/li>\n+     * <li>The identifier only contains alphanumeric characters([0-9A-Za-z]) or\n+     * the character \"_\"<\/li>\n+     * <li>The identifier is not a SQL reserved word<\/li>\n+     * <li>The identifier is between 1 and 128 characters in length inclusive<\/li>\n@@ -1879,0 +1915,7 @@\n+     * <tr>\n+     * <th scope=\"row\">\"select\"<\/th>\n+     * <td>false<\/td>\n+     * <tr>\n+     * <th scope=\"row\">\"from\"<\/th>\n+     * <td>false<\/td>\n+     * <\/tr>\n@@ -1886,1 +1929,1 @@\n-     * @return  true if a simple SQL identifier, false otherwise\n+     * @return true if a simple SQL identifier, false otherwise\n","filename":"src\/java.sql\/share\/classes\/java\/sql\/Connection.java","additions":73,"deletions":30,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n@@ -40,0 +43,77 @@\n+     \/\/ SQL 2023 reserved words\n+    private static final String[] SQL2023_RESERVED_WORDS = {\n+            \"ABS\", \"ABSENT\", \"ACOS\", \"ALL\", \"ALLOCATE\", \"ALTER\", \"AND\", \"ANY\",\n+            \"ANY_VALUE\", \"ARE\", \"ARRAY\", \"ARRAY_AGG\", \"ARRAY_MAX_CARDINALITY\",\n+            \"AS\", \"ASENSITIVE\", \"ASIN\", \"ASYMMETRIC\", \"AT\", \"ATAN\",\n+            \"ATOMIC\", \"AUTHORIZATION\", \"AVG\",\n+            \"BEGIN\", \"BEGIN_FRAME\", \"BEGIN_PARTITION\", \"BETWEEN\", \"BIGINT\",\n+            \"BINARY\", \"BLOB\", \"BOOLEAN\", \"BOTH\", \"BTRIM\", \"BY\",\n+            \"CALL\", \"CALLED\", \"CARDINALITY\", \"CASCADED\", \"CASE\", \"CAST\", \"CEIL\",\n+            \"CEILING\", \"CHAR\", \"CHAR_LENGTH\",\n+            \"CHARACTER\", \"CHARACTER_LENGTH\", \"CHECK\", \"CLASSIFIER\", \"CLOB\",\n+            \"CLOSE\", \"COALESCE\", \"COLLATE\", \"COLLECT\", \"COLUMN\", \"COMMIT\", \"CONDITION\",\n+            \"CONNECT\", \"CONSTRAINT\", \"CONTAINS\", \"CONVERT\", \"COPY\", \"CORR\", \"CORRESPONDING\",\n+            \"COS\", \"COSH\", \"COUNT\", \"COVAR_POP\", \"COVAR_SAMP\", \"CREATE\", \"CROSS\", \"CUBE\",\n+            \"CUME_DIST\", \"CURRENT\",\n+            \"CURRENT_CATALOG\", \"CURRENT_DATE\", \"CURRENT_DEFAULT_TRANSFORM_GROUP\", \"CURRENT_PATH\",\n+            \"CURRENT_ROLE\", \"CURRENT_SCHEMA\", \"CURRENT_TIME\", \"CURRENT_TIMESTAMP\",\n+            \"CURRENT_TRANSFORM_GROUP_FOR_TYPE\", \"CURRENT_USER\", \"CURSOR\", \"CYCLE\",\n+            \"DATE\", \"DAY\", \"DEALLOCATE\", \"DEC\", \"DECFLOAT\", \"DECIMAL\", \"DECLARE\", \"DEFAULT\",\n+            \"DEFINE\", \"DELETE\", \"DENSE_RANK\", \"DEREF\", \"DESCRIBE\", \"DETERMINISTIC\",\n+            \"DISCONNECT\", \"DISTINCT\", \"DOUBLE\", \"DROP\", \"DYNAMIC\",\n+            \"EACH\", \"ELEMENT\", \"ELSE\", \"EMPTY\", \"END\", \"END_FRAME\", \"END_PARTITION\",\n+            \"END-EXEC\", \"EQUALS\", \"ESCAPE\", \"EVERY\", \"EXCEPT\", \"EXEC\", \"EXECUTE\",\n+            \"EXISTS\", \"EXP\", \"EXTERNAL\", \"EXTRACT\",\n+            \"FALSE\", \"FETCH\", \"FILTER\", \"FIRST_VALUE\", \"FLOAT\", \"FLOOR\", \"FOR\", \"FOREIGN\", \"FRAME_ROW\",\n+            \"FREE\", \"FROM\", \"FULL\", \"FUNCTION\", \"FUSION\",\n+            \"GET\", \"GLOBAL\", \"GRANT\", \"GREATEST\", \"GROUP\", \"GROUPING\", \"GROUPS\",\n+            \"HAVING\", \"HOLD\", \"HOUR\",\n+            \"IDENTITY\", \"IN\", \"INDICATOR\", \"INITIAL\", \"INNER\", \"INOUT\", \"INSENSITIVE\",\n+            \"INSERT\", \"INT\", \"INTEGER\",\n+            \"INTERSECT\", \"INTERSECTION\", \"INTERVAL\", \"INTO\", \"IS\",\n+            \"JOIN\", \"JSON\", \"JSON_ARRAY\", \"JSON_ARRAYAGG\", \"JSON_EXISTS\",\n+            \"JSON_OBJECT\", \"JSON_OBJECTAGG\", \"JSON_QUERY\", \"JSON_SCALAR\",\n+            \"JSON_SERIALIZE\", \"JSON_TABLE\", \"JSON_TABLE_PRIMITIVE\", \"JSON_VALUE\",\n+            \"LAG\", \"LANGUAGE\", \"LARGE\", \" LAST_VALUE\", \"LATERAL\", \"LEAD\",\n+            \"LEADING\", \"LEAST\", \"LEFT\", \"LIKE\", \"LIKE_REGEX\", \"LISTAGG\",\n+            \"LN\", \"LOCAL\", \"LOCALTIME\", \"LOCALTIMESTAMP\", \"LOG\", \"LOG10\",\n+            \"LOWER\", \"LPAD\", \"LTRIM\",\n+            \"MATCH\", \"MATCH_NUMBER\", \"MATCH_RECOGNIZE\", \"MATCHES\", \"MAX\",\n+            \"MEMBER\", \"MERGE\", \"METHOD\", \"MIN\", \"MINUTE\", \"MOD\", \"MODIFIES\",\n+            \"MODULE\", \"MONTH\", \"MULTISET\",\n+            \"NATIONAL\", \"NATURAL\", \"NCHAR\", \"NCLOB\", \"NEW\", \"NO\", \"NONE\",\n+            \"NORMALIZE\", \"NOT\", \"NTH_VALUE\", \"NTILE\", \"NULL\", \"NULLIF\", \"NUMERIC\",\n+            \"OCCURRENCES_REGEX\", \"OCTET_LENGTH\", \"OF\", \"OFFSET\", \"OLD\", \"OMIT\",\n+            \"ON\", \"ONE\", \"ONLY\", \"OPEN\", \"OR\", \"ORDER\", \"OUT\", \"OUTER\", \"OUTPUT\",\n+            \"OVER\", \"OVERLAPS\", \"OVERLAY\",\n+            \"PARAMETER\", \"PARTITION\", \"PATTERN\", \"PER\", \"PERCENT\", \"PERCENT_RANK\",\n+            \"PERCENTILE_CONT\", \"PERCENTILE_DISC\", \"PERIOD\", \"PORTION\", \"POSITION\",\n+            \"POSITION_REGEX\", \"POWER\", \"PRECEDES\",\n+            \"PRECISION\", \"PREPARE\", \"PRIMARY\", \"PROCEDURE\", \"PTF\",\n+            \"RANGE\", \"RANK\", \"READS\", \"REAL\", \"RECURSIVE\", \"REF\", \"REFERENCES\",\n+            \"REFERENCING\", \"REGR_AVGX\", \"REGR_AVGY\", \"REGR_COUNT\", \"REGR_INTERCEPT\",\n+            \"REGR_R2\", \"REGR_SLOPE\", \"REGR_SXX\", \"REGR_SXY\", \"REGR_SYY\",\n+            \"RELEASE\", \"RESULT\", \"RETURN\", \"RETURNS\", \"REVOKE\", \"RIGHT\",\n+            \"ROLLBACK\", \"ROLLUP\", \"ROW\", \"ROW_NUMBER\", \"ROWS\", \"RPAD\", \"RTRIM\",\n+            \"RUNNING\",\n+            \"SAVEPOINT\", \"SCOPE\", \"SCROLL\", \"SEARCH\", \"SECOND\", \"SEEK\",\n+            \"SELECT\", \"SENSITIVE\", \"SESSION_USER\", \"SET\", \"SHOW\", \"SIMILAR\",\n+            \"SIN\", \"SINH\", \"SKIP\", \"SMALLINT\",\n+            \"SOME\", \"SPECIFIC\", \"SPECIFICTYPE\", \"SQL\", \"SQLEXCEPTION\", \"SQLSTATE\",\n+            \"SQLWARNING\", \"SQRT\", \"START\", \"STATIC\", \"STDDEV_POP\", \"STDDEV_SAMP\",\n+            \"SUBMULTISET\", \"SUBSET\", \"SUBSTRING\", \"SUBSTRING_REGEX\", \"SUCCEEDS\",\n+            \"SUM\", \"SYMMETRIC\", \"SYSTEM\", \"SYSTEM_TIME\", \"SYSTEM_USER\",\n+            \"TABLE\", \"TABLESAMPLE\", \"TAN\", \"TANH\", \"THEN\", \"TIME\", \"TIMESTAMP\",\n+            \"TIMEZONE_HOUR\", \"TIMEZONE_MINUTE\", \"TO\", \"TRAILING\", \"TRANSLATE\",\n+            \"TRANSLATE_REGEX\", \"TRANSLATION\", \"TREAT\", \"TRIGGER\", \"TRIM\",\n+            \"TRIM_ARRAY\", \"TRUE\", \"TRUNCATE\",\n+            \"UESCAPE\", \"UNION\", \"UNIQUE\", \"UNKNOWN\", \"UNNEST\", \"UPDATE\", \"UPPER\",\n+            \"USER\", \"USING\",\n+            \"VALUE\", \"VALUES\", \"VALUE_OF\", \"VAR_POP\", \"VAR_SAMP\", \"VARBINARY\",\n+            \"VARCHAR\", \"VARYING\", \"VERSIONING\",\n+            \"WHEN\", \"WHENEVER\", \"WHERE\", \"WHILE\", \"WIDTH_BUCKET\", \"WINDOW\",\n+            \"WITH\", \"WITHIN\", \"WITHOUT\",\n+            \"YEAR\"\n+    };\n+    private static final Set<String> SQL_RESERVED_WORDS =\n+            new HashSet<>(Arrays.asList(SQL2023_RESERVED_WORDS));\n@@ -77,1 +157,6 @@\n-     * Returns a SQL identifier. If {@code identifier} is a simple SQL identifier:\n+     * Returns a {@link #isSimpleIdentifier(String) simple SQL identifier} or a\n+     * delimited identifier.  A delimited identifier represents the name of a\n+     * database object such as a table, column, or view that is enclosed by a\n+     * delimiter, which is typically a double quote as defined by the SQL standard.\n+     * <p>\n+     * If {@code identifier} is a simple SQL identifier:\n@@ -79,4 +164,3 @@\n-     * <li>Return the original value if {@code alwaysDelimit} is\n-     * {@code false}<\/li>\n-     * <li>Return a delimited identifier if {@code alwaysDelimit} is\n-     * {@code true}<\/li>\n+     * <li>If {@code alwaysDelimit} is {@code false}, return the original value<\/li>\n+     * <li>if {@code alwaysDelimit} is {@code true}, enquote the original value\n+     * and return as a delimited identifier<\/li>\n@@ -84,8 +168,6 @@\n-     * <p>\n-     * If {@code identifier} is not a simple SQL identifier, {@code identifier} will be\n-     * enclosed in double quotes if not already present. If the datasource does\n-     * not support double quotes for delimited identifiers, the\n-     * identifier should be enclosed by the string returned from\n-     * {@link DatabaseMetaData#getIdentifierQuoteString}.  If the datasource\n-     * does not support delimited identifiers, a\n-     * {@code SQLFeatureNotSupportedException} should be thrown.\n+     *\n+     * If {@code identifier} is not a simple SQL identifier, the delimited\n+     * {@code identifier} to be returned must be enclosed by the delimiter\n+     * returned from {@link DatabaseMetaData#getIdentifierQuoteString}. If\n+     * the datasource does not support delimited identifiers, a\n+     * {@code SQLFeatureNotSupportedException} is thrown.\n@@ -94,2 +176,2 @@\n-     * characters invalid in a delimited identifier or the identifier length is\n-     * invalid for the datasource.\n+     * invalid characters within a delimited identifier or the identifier length\n+     * is invalid for the datasource.\n@@ -97,9 +179,2 @@\n-     * @param identifier  a SQL identifier\n-     * @param alwaysDelimit indicates if a simple SQL identifier should be\n-     *                    returned as a quoted identifier\n-     * @return A simple SQL identifier or a delimited identifier\n-     * @throws SQLException                    if identifier is not a valid identifier\n-     * @throws SQLFeatureNotSupportedException if the datasource does not support\n-     *                                         delimited identifiers\n-     * @throws NullPointerException            if identifier is {@code null}\n-     * @implSpec The default implementation uses the following criteria to\n+     * @implSpec\n+     * The default implementation uses the following criteria to\n@@ -109,2 +184,3 @@\n-     * <li>The first character is an alphabetic character from a through z, or\n-     * from A through Z<\/li>\n+     * <li>The first character is an alphabetic character from a ({@code '\\u005C0061'})\n+     * through z ({@code '\\u005Cu007A'}), or from A ({@code '\\u005Cu0041'})\n+     * through Z ({@code '\\u005Cu005A'})<\/li>\n@@ -113,1 +189,1 @@\n-     * <p>\n+     *\n@@ -116,2 +192,3 @@\n-     * <li>{@code identifier} contains a {@code null} character or double quote and is not\n-     * a simple SQL identifier.<\/li>\n+     * <li> {@link DatabaseMetaData#getIdentifierQuoteString} does not return a\n+     * double quote<\/li>\n+     * <li>{@code identifier} contains a {@code null} character or double quote<\/li>\n@@ -156,0 +233,10 @@\n+     * <th scope=\"row\">\"select\"<\/th>\n+     * <td>false<\/td>\n+     * <td>\"select\"<\/td>\n+     * <\/tr>\n+     * <tr>\n+     * <th scope=\"row\">\"select\"<\/th>\n+     * <td>true<\/td>\n+     * <td>\"select\"<\/td>\n+     * <\/tr>\n+     * <tr>\n@@ -173,1 +260,2 @@\n-     * @implNote JDBC driver implementations may need to provide their own implementation\n+     * @implNote\n+     * JDBC driver implementations may need to provide their own implementation\n@@ -176,0 +264,8 @@\n+     * @param identifier a SQL identifier\n+     * @param alwaysDelimit indicates if a simple SQL identifier should be\n+     * returned as a delimited identifier\n+     * @return A simple SQL identifier or a delimited identifier\n+     * @throws SQLException if identifier is not a valid identifier\n+     * @throws SQLFeatureNotSupportedException if the datasource does not support\n+     * delimited identifiers\n+     * @throws NullPointerException if identifier is {@code null}\n@@ -177,1 +273,1 @@\n-    static String enquoteIdentifier(String identifier, boolean alwaysDelimit) throws SQLException {\n+    static String enquoteIdentifier(String delimiter, String identifier, boolean alwaysDelimit) throws SQLException {\n@@ -180,1 +276,4 @@\n-            throw new SQLException(\"Invalid name\");\n+            throw new SQLException(\"Invalid identifier length\");\n+        }\n+        if (!delimiter.equals(\"\\\"\")) {\n+           throw new SQLException(\"Unsupported delimiter\");\n@@ -182,1 +281,1 @@\n-        if (SIMPLE_IDENTIFIER_PATTERN.matcher(identifier).matches()) {\n+        if (isSimpleIdentifier(identifier)) {\n@@ -198,1 +297,20 @@\n-     * Retrieves whether {@code identifier} is a simple SQL identifier.\n+     * Returns whether {@code identifier} is a simple SQL identifier.\n+     * A simple SQL identifier is referred to as regular (or ordinary) identifier\n+     * within the SQL standard.  A regular identifier represents the name of a database\n+     * object such as a table, column, or view.\n+     * <p>\n+     * The rules for a regular Identifier are:\n+     * <ul>\n+     * <li>The first character is an alphabetic character from a ({@code '\\u005Cu0061'})\n+     * through z ({@code '\\u005Cu007A'}), or from A ({@code '\\u005Cu0041'})\n+     * through Z ({@code '\\u005Cu005A'})<\/li>\n+     * <li>The name only contains alphanumeric characters or the character \"_\"<\/li>\n+     * <li>It cannot be a SQL reserved word<\/li>\n+     * <\/ul>\n+     * <p>\n+     * A datasource may have additional rules for a regular identifier such as:\n+     * <ul>\n+     * <li>Supports additional characters within the name based on\n+     * the locale being used<\/li>\n+     * <li>Supports a different maximum length for the identifier<\/li>\n+     * <\/ul>\n@@ -200,4 +318,0 @@\n-     * @param identifier a SQL identifier\n-     * @return true if a simple SQL identifier, false otherwise\n-     * @throws NullPointerException if identifier is {@code null}\n-     * @throws SQLException         if a database access error occurs\n@@ -207,1 +321,1 @@\n-     * <li>The string is not enclosed in double quotes<\/li>\n+     * <li>The identifier is not enclosed in double quotes<\/li>\n@@ -210,1 +324,1 @@\n-     * <li>The string only contains alphanumeric characters or the character\n+     * <li>The identifier only contains alphanumeric characters or the character\n@@ -212,1 +326,2 @@\n-     * <li>The string is between 1 and 128 characters in length inclusive<\/li>\n+     * <li>The identifier is not a SQL reserved word<\/li>\n+     * <li>The identifier is between 1 and 128 characters in length inclusive<\/li>\n@@ -249,0 +364,7 @@\n+     * <tr>\n+     * <th scope=\"row\">\"select\"<\/th>\n+     * <td>false<\/td>\n+     * <tr>\n+     * <th scope=\"row\">\"from\"<\/th>\n+     * <td>false<\/td>\n+     * <\/tr>\n@@ -255,0 +377,4 @@\n+     * @param identifier a SQL identifier\n+     * @return true if a simple SQL identifier, false otherwise\n+     * @throws NullPointerException if identifier is {@code null}\n+     * @throws SQLException if a database access error occurs\n@@ -258,1 +384,2 @@\n-        return len >= 1 && len <= 128\n+        return !SQL_RESERVED_WORDS.contains(identifier.toUpperCase()) &&\n+                len >= 1 && len <= 128\n","filename":"src\/java.sql\/share\/classes\/java\/sql\/SQLUtils.java","additions":169,"deletions":42,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -1414,2 +1414,7 @@\n-     \/**\n-     * Returns a SQL identifier. If {@code identifier} is a simple SQL identifier:\n+    \/**\n+     * Returns a {@link #isSimpleIdentifier(String) simple SQL identifier} or a\n+     * delimited identifier.  A delimited identifier represents the name of a\n+     * database object such as a table, column, or view that is enclosed by a\n+     * delimiter, which is typically a double quote as defined by the SQL standard.\n+     * <p>\n+     * If {@code identifier} is a simple SQL identifier:\n@@ -1417,4 +1422,3 @@\n-     * <li>Return the original value if {@code alwaysDelimit} is\n-     * {@code false}<\/li>\n-     * <li>Return a delimited identifier if {@code alwaysDelimit} is\n-     * {@code true}<\/li>\n+     * <li>If {@code alwaysDelimit} is {@code false}, return the original value<\/li>\n+     * <li>if {@code alwaysDelimit} is {@code true}, enquote the original value\n+     * and return as a delimited identifier<\/li>\n@@ -1423,7 +1427,5 @@\n-     * If {@code identifier} is not a simple SQL identifier, {@code identifier} will be\n-     * enclosed in double quotes if not already present. If the datasource does\n-     * not support double quotes for delimited identifiers, the\n-     * identifier should be enclosed by the string returned from\n-     * {@link DatabaseMetaData#getIdentifierQuoteString}.  If the datasource\n-     * does not support delimited identifiers, a\n-     * {@code SQLFeatureNotSupportedException} should be thrown.\n+     * If {@code identifier} is not a simple SQL identifier, the delimited\n+     * {@code identifier} to be returned must be enclosed by the delimiter\n+     * returned from {@link DatabaseMetaData#getIdentifierQuoteString}. If\n+     * the datasource does not support delimited identifiers, a\n+     * {@code SQLFeatureNotSupportedException} is thrown.\n@@ -1432,2 +1434,2 @@\n-     * characters invalid in a delimited identifier or the identifier length is\n-     * invalid for the datasource.\n+     * invalid characters within a delimited identifier or the identifier length\n+     * is invalid for the datasource.\n@@ -1440,3 +1442,5 @@\n-     * <li>The first character is an alphabetic character from a through z, or\n-     * from A through Z<\/li>\n-     * <li>The name only contains alphanumeric characters or the character \"_\"<\/li>\n+     * <li>The first character is an alphabetic character from a ({@code '\\u005C0061'})\n+     * through z ({@code '\\u005Cu007A'}), or from A ({@code '\\u005Cu0041'})\n+     * through Z ({@code '\\u005Cu005A'})<\/li>\n+     * <li>The name only contains alphanumeric characters([0-9A-Za-z])\n+     * or the character \"_\"<\/li>\n@@ -1447,2 +1451,3 @@\n-     * <li>{@code identifier} contains a {@code null} character or double quote and is not\n-     * a simple SQL identifier.<\/li>\n+     * <li> {@link DatabaseMetaData#getIdentifierQuoteString} does not return a\n+     * double quote<\/li>\n+     * <li>{@code identifier} contains a {@code null} character or double quote<\/li>\n@@ -1487,0 +1492,10 @@\n+     * <th scope=\"row\">\"select\"<\/th>\n+     * <td>false<\/td>\n+     * <td>\"select\"<\/td>\n+     * <\/tr>\n+     * <tr>\n+     * <th scope=\"row\">\"select\"<\/th>\n+     * <td>true<\/td>\n+     * <td>\"select\"<\/td>\n+     * <\/tr>\n+     * <tr>\n@@ -1520,1 +1535,1 @@\n-        return SQLUtils.enquoteIdentifier(identifier, alwaysDelimit);\n+        return getConnection().enquoteIdentifier(identifier,alwaysDelimit);\n@@ -1524,4 +1539,6 @@\n-     * Retrieves whether {@code identifier} is a simple SQL identifier.\n-     *\n-     * @implSpec The default implementation uses the following criteria to\n-     * determine a valid simple SQL identifier:\n+     * Returns whether {@code identifier} is a simple SQL identifier.\n+     * A simple SQL identifier is referred to as regular (or ordinary) identifier\n+     * within the SQL standard.  A regular identifier represents the name of a database\n+     * object such as a table, column, or view.\n+     * <p>\n+     * The rules for a regular Identifier are:\n@@ -1529,1 +1546,0 @@\n-     * <li>The string is not enclosed in double quotes<\/li>\n@@ -1533,3 +1549,22 @@\n-     * <li>The string only contains alphanumeric characters or the character\n-     * \"_\"<\/li>\n-     * <li>The string is between 1 and 128 characters in length inclusive<\/li>\n+     * <li>The name only contains alphanumeric characters([0-9A-Za-z]) or the\n+     * character \"_\"<\/li>\n+     * <li>It cannot be a SQL reserved word<\/li>\n+     * <\/ul>\n+     * <p>\n+     * A datasource may have additional rules for a regular identifier such as:\n+     * <ul>\n+     * <li>Supports additional characters within the name based on\n+     * the locale being used<\/li>\n+     * <li>Supports a different maximum length for the identifier<\/li>\n+     * <\/ul>\n+     *\n+     * @implSpec The default implementation uses the following criteria to\n+     * determine a valid simple SQL identifier:\n+     * <ul>\n+     * <li>The identifier is not enclosed in double quotes<\/li>\n+     * <li>The first character is an alphabetic character from a through z, or\n+     * from A through Z<\/li>\n+     * <li>The identifier only contains alphanumeric characters([0-9A-Za-z])\n+     * or the character \"_\"<\/li>\n+     * <li>The identifier is not a SQL reserved word<\/li>\n+     * <li>The identifier is between 1 and 128 characters in length inclusive<\/li>\n@@ -1572,0 +1607,7 @@\n+     * <tr>\n+     * <th scope=\"row\">\"select\"<\/th>\n+     * <td>false<\/td>\n+     * <tr>\n+     * <th scope=\"row\">\"from\"<\/th>\n+     * <td>false<\/td>\n+     * <\/tr>\n@@ -1579,1 +1621,1 @@\n-     * @return  true if  a simple SQL identifier, false otherwise\n+     * @return true if a simple SQL identifier, false otherwise\n","filename":"src\/java.sql\/share\/classes\/java\/sql\/Statement.java","additions":72,"deletions":30,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n- *      include a default {@code close} method implentation<\/LI>\n+ *      include a default {@code close} method implementation<\/LI>\n@@ -262,1 +262,0 @@\n- *\n@@ -318,1 +317,0 @@\n- *\n","filename":"src\/java.sql\/share\/classes\/java\/sql\/package-info.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+import org.testng.annotations.AfterMethod;\n@@ -26,1 +27,3 @@\n-import util.StubCallableStatement;\n+import org.testng.annotations.Test;\n+import util.BaseTest;\n+import util.StubConnection;\n@@ -28,1 +31,7 @@\n-public class CallableStatementTests extends PreparedStatementTests {\n+import java.sql.CallableStatement;\n+import java.sql.SQLException;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+public class CallableStatementTests extends BaseTest {\n+    private CallableStatement cstmt;\n@@ -32,1 +41,32 @@\n-        stmt = new StubCallableStatement();\n+        cstmt = new StubConnection().prepareCall(\"{call SuperHero_Proc(?)}\");\n+    }\n+\n+    @AfterMethod\n+    public void tearDownMethod() throws Exception {\n+        cstmt.close();\n+    }\n+\n+    \/*\n+     * Verify that enquoteLiteral creates a  valid literal and converts every\n+     * single quote to two single quotes\n+     *\/\n+    @Test(dataProvider = \"validEnquotedLiteralValues\")\n+    public void test00(String s, String expected) throws SQLException {\n+        assertEquals(cstmt.enquoteLiteral(s), expected);\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * enquoteLiteral is null\n+     *\/\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void test01() throws SQLException {\n+        cstmt.enquoteLiteral(null);\n+    }\n+\n+    \/*\n+     * Validate that enquoteIdentifier returns the expected value\n+     *\/\n+    @Test(dataProvider = \"validIdentifierValues\")\n+    public void test02(String s, boolean alwaysQuote, String expected) throws SQLException {\n+        assertEquals(cstmt.enquoteIdentifier(s, alwaysQuote), expected);\n@@ -35,0 +75,27 @@\n+    \/*\n+     * Validate that a SQLException is thrown for values that are not valid\n+     * for a SQL identifier\n+     *\/\n+    @Test(dataProvider = \"invalidIdentifierValues\",\n+            expectedExceptions = SQLException.class)\n+    public void test03(String s, boolean alwaysQuote) throws SQLException {\n+        cstmt.enquoteIdentifier(s, alwaysQuote);\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown is the string passed to\n+     * enquoteIdentiifer is null\n+     *\/\n+    @Test(dataProvider = \"trueFalse\",\n+            expectedExceptions = NullPointerException.class)\n+    public void test04(boolean alwaysQuote) throws SQLException {\n+        cstmt.enquoteIdentifier(null, alwaysQuote);\n+    }\n+\n+    \/*\n+     * Validate that isSimpleIdentifier returns the expected value\n+     *\/\n+    @Test(dataProvider = \"simpleIdentifierValues\")\n+    public void test05(String s, boolean expected) throws SQLException {\n+        assertEquals(cstmt.isSimpleIdentifier(s), expected);\n+    }\n@@ -36,0 +103,26 @@\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * isSimpleIdentifier is null\n+     *\/\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void test06() throws SQLException {\n+        cstmt.isSimpleIdentifier(null);\n+    }\n+\n+    \/*\n+     * Verify that enquoteLiteral creates a  valid literal and converts every\n+     * single quote to two single quotes\n+     *\/\n+    @Test(dataProvider = \"validEnquotedNCharLiteralValues\")\n+    public void test07(String s, String expected) throws SQLException {\n+        assertEquals(cstmt.enquoteNCharLiteral(s), expected);\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * enquoteNCharLiteral is null\n+     *\/\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void test08() throws SQLException {\n+        cstmt.enquoteNCharLiteral(null);\n+    }\n","filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/CallableStatementTests.java","additions":97,"deletions":4,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import org.testng.annotations.BeforeClass;\n@@ -27,1 +26,0 @@\n-import org.testng.annotations.DataProvider;\n@@ -34,1 +32,1 @@\n-import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.*;\n@@ -39,1 +37,0 @@\n-    protected static String maxIdentifier;\n@@ -46,10 +43,0 @@\n-    @BeforeClass\n-    public static void setUpClass() throws Exception {\n-        int maxLen = 128;\n-        StringBuilder s = new StringBuilder(maxLen);\n-        for (int i = 0; i < maxLen; i++) {\n-            s.append('a');\n-        }\n-        maxIdentifier = s.toString();\n-    }\n-\n@@ -60,1 +47,0 @@\n-\n@@ -137,94 +123,0 @@\n-\n-    \/*\n-     * DataProvider used to provide strings that will be used to validate\n-     * that enquoteLiteral converts a string to a literal and every instance of\n-     * a single quote will be converted into two single quotes in the literal.\n-     *\/\n-    @DataProvider(name = \"validEnquotedLiteralValues\")\n-    protected Object[][] validEnquotedLiteralValues() {\n-        return new Object[][]{\n-            {\"Hello\", \"'Hello'\"},\n-            {\"G'Day\", \"'G''Day'\"},\n-            {\"'G''Day'\", \"'''G''''Day'''\"},\n-            {\"I'''M\", \"'I''''''M'\"},\n-            {\"The Dark Knight\", \"'The Dark Knight'\"}\n-        };\n-    }\n-\n-    \/*\n-     * DataProvider used to provide strings that will be used to validate\n-     * that enqouteIdentifier returns a simple SQL Identifier or a double\n-     * quoted identifier\n-     *\/\n-    @DataProvider(name = \"validIdentifierValues\")\n-    protected Object[][] validEnquotedIdentifierValues() {\n-        return new Object[][]{\n-            {\"b\", false, \"b\"},\n-            {\"b\", true, \"\\\"b\\\"\"},\n-            {maxIdentifier, false, maxIdentifier},\n-            {maxIdentifier, true, \"\\\"\" + maxIdentifier + \"\\\"\"},\n-            {\"Hello\", false, \"Hello\"},\n-            {\"Hello\", true, \"\\\"Hello\\\"\"},\n-            {\"G'Day\", false, \"\\\"G'Day\\\"\"},\n-            {\"G'Day\", true, \"\\\"G'Day\\\"\"},\n-            {\"Bruce Wayne\", false, \"\\\"Bruce Wayne\\\"\"},\n-            {\"Bruce Wayne\", true, \"\\\"Bruce Wayne\\\"\"},\n-            {\"GoodDay$\", false, \"\\\"GoodDay$\\\"\"},\n-            {\"GoodDay$\", true, \"\\\"GoodDay$\\\"\"},\n-        };\n-    }\n-\n-    \/*\n-     * DataProvider used to provide strings are invalid for enquoteIdentifier\n-     * resulting in a SQLException being thrown\n-     *\/\n-    @DataProvider(name = \"invalidIdentifierValues\")\n-    protected Object[][] invalidEnquotedIdentifierValues() {\n-        return new Object[][]{\n-            {\"Hel\\\"lo\", false},\n-            {\"\\\"Hel\\\"lo\\\"\", true},\n-            {\"Hello\" + '\\0', false},\n-            {\"\", false},\n-            {maxIdentifier + 'a', false},\n-        };\n-    }\n-\n-    \/*\n-     * DataProvider used to provide strings that will be used to validate\n-     * that isSimpleIdentifier returns the correct value based on the\n-     * identifier specified.\n-     *\/\n-    @DataProvider(name = \"simpleIdentifierValues\")\n-    protected Object[][] simpleIdentifierValues() {\n-        return new Object[][]{\n-            {\"b\", true},\n-            {\"Hello\", true},\n-            {\"\\\"Gotham\\\"\", false},\n-            {\"G'Day\", false},\n-            {\"Bruce Wayne\", false},\n-            {\"GoodDay$\", false},\n-            {\"Dick_Grayson\", true},\n-            {\"Batmobile1966\", true},\n-            {maxIdentifier, true},\n-            {maxIdentifier + 'a', false},\n-            {\"\", false},\n-        };\n-    }\n-\n-    \/*\n-     * DataProvider used to provide strings that will be used to validate\n-     * that enquoteNCharLiteral converts a string to a National Character\n-     * literal and every instance of\n-     * a single quote will be converted into two single quotes in the literal.\n-     *\/\n-    @DataProvider(name = \"validEnquotedNCharLiteralValues\")\n-    protected Object[][] validEnquotedNCharLiteralValues() {\n-        return new Object[][]{\n-            {\"Hello\", \"N'Hello'\"},\n-            {\"G'Day\", \"N'G''Day'\"},\n-            {\"'G''Day'\", \"N'''G''''Day'''\"},\n-            {\"I'''M\", \"N'I''''''M'\"},\n-            {\"N'Hello'\", \"N'N''Hello'''\"},\n-            {\"The Dark Knight\", \"N'The Dark Knight'\"}\n-        };\n-    }\n","filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/ConnectionTests.java","additions":1,"deletions":109,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+import org.testng.annotations.AfterMethod;\n@@ -26,1 +27,3 @@\n-import util.StubPreparedStatement;\n+import org.testng.annotations.Test;\n+import util.BaseTest;\n+import util.StubConnection;\n@@ -28,1 +31,8 @@\n-public class PreparedStatementTests extends StatementTests {\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+public class PreparedStatementTests extends BaseTest {\n+\n+    private PreparedStatement pstmt;\n@@ -32,1 +42,32 @@\n-        stmt = new StubPreparedStatement();\n+        pstmt = new StubConnection().prepareStatement(\"Select * from foo were bar = ?\");\n+    }\n+\n+    @AfterMethod\n+    public void tearDownMethod() throws Exception {\n+        pstmt.close();\n+    }\n+\n+    \/*\n+     * Verify that enquoteLiteral creates a  valid literal and converts every\n+     * single quote to two single quotes\n+     *\/\n+    @Test(dataProvider = \"validEnquotedLiteralValues\")\n+    public void test00(String s, String expected) throws SQLException {\n+        assertEquals(pstmt.enquoteLiteral(s), expected);\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * enquoteLiteral is null\n+     *\/\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void test01() throws SQLException {\n+        pstmt.enquoteLiteral(null);\n+    }\n+\n+    \/*\n+     * Validate that enquoteIdentifier returns the expected value\n+     *\/\n+    @Test(dataProvider = \"validIdentifierValues\")\n+    public void test02(String s, boolean alwaysQuote, String expected) throws SQLException {\n+        assertEquals(pstmt.enquoteIdentifier(s, alwaysQuote), expected);\n@@ -35,0 +76,54 @@\n+    \/*\n+     * Validate that a SQLException is thrown for values that are not valid\n+     * for a SQL identifier\n+     *\/\n+    @Test(dataProvider = \"invalidIdentifierValues\",\n+            expectedExceptions = SQLException.class)\n+    public void test03(String s, boolean alwaysQuote) throws SQLException {\n+        pstmt.enquoteIdentifier(s, alwaysQuote);\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown is the string passed to\n+     * enquoteIdentiifer is null\n+     *\/\n+    @Test(dataProvider = \"trueFalse\",\n+            expectedExceptions = NullPointerException.class)\n+    public void test04(boolean alwaysQuote) throws SQLException {\n+        pstmt.enquoteIdentifier(null, alwaysQuote);\n+    }\n+\n+    \/*\n+     * Validate that isSimpleIdentifier returns the expected value\n+     *\/\n+    @Test(dataProvider = \"simpleIdentifierValues\")\n+    public void test05(String s, boolean expected) throws SQLException {\n+        assertEquals(pstmt.isSimpleIdentifier(s), expected);\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * isSimpleIdentifier is null\n+     *\/\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void test06() throws SQLException {\n+        pstmt.isSimpleIdentifier(null);\n+    }\n+\n+    \/*\n+     * Verify that enquoteLiteral creates a  valid literal and converts every\n+     * single quote to two single quotes\n+     *\/\n+    @Test(dataProvider = \"validEnquotedNCharLiteralValues\")\n+    public void test07(String s, String expected) throws SQLException {\n+        assertEquals(pstmt.enquoteNCharLiteral(s), expected);\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * enquoteNCharLiteral is null\n+     *\/\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void test08() throws SQLException {\n+        pstmt.enquoteNCharLiteral(null);\n+    }\n","filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/PreparedStatementTests.java","additions":99,"deletions":4,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025,  Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import java.sql.Statement;\n+\n@@ -27,4 +29,2 @@\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+\n+import org.testng.annotations.*;\n@@ -32,1 +32,1 @@\n-import util.StubStatement;\n+import util.StubConnection;\n@@ -36,2 +36,1 @@\n-    protected StubStatement stmt;\n-    protected static String maxIdentifier;\n+    private Statement stmt;\n@@ -41,1 +40,1 @@\n-        stmt = new StubStatement();\n+        stmt = new StubConnection().createStatement();\n@@ -44,8 +43,3 @@\n-    @BeforeClass\n-    public static void setUpClass() throws Exception {\n-        int maxLen = 128;\n-        StringBuilder s = new StringBuilder(maxLen);\n-        for (int i = 0; i < maxLen; i++) {\n-            s.append('a');\n-        }\n-        maxIdentifier = s.toString();\n+    @AfterMethod\n+    public void tearDownMethod() throws Exception {\n+        stmt.close();\n@@ -57,1 +51,0 @@\n-\n@@ -70,1 +63,0 @@\n-\n@@ -79,1 +71,0 @@\n-\n@@ -90,1 +81,0 @@\n-\n@@ -101,1 +91,0 @@\n-\n@@ -119,1 +108,0 @@\n-\n@@ -139,93 +127,0 @@\n-\n-    \/*\n-     * DataProvider used to provide strings that will be used to validate\n-     * that enquoteLiteral converts a string to a literal and every instance of\n-     * a single quote will be converted into two single quotes in the literal.\n-     *\/\n-    @DataProvider(name = \"validEnquotedLiteralValues\")\n-    protected Object[][] validEnquotedLiteralValues() {\n-        return new Object[][]{\n-            {\"Hello\", \"'Hello'\"},\n-            {\"G'Day\", \"'G''Day'\"},\n-            {\"'G''Day'\", \"'''G''''Day'''\"},\n-            {\"I'''M\", \"'I''''''M'\"},\n-            {\"The Dark Knight\", \"'The Dark Knight'\"}\n-\n-        };\n-    }\n-\n-    \/*\n-     * DataProvider used to provide strings that will be used to validate\n-     * that enqouteIdentifier returns a simple SQL Identifier or a double\n-     * quoted identifier\n-     *\/\n-    @DataProvider(name = \"validIdentifierValues\")\n-    protected Object[][] validEnquotedIdentifierValues() {\n-        return new Object[][]{\n-            {\"b\", false, \"b\"},\n-            {\"b\", true, \"\\\"b\\\"\"},\n-            {maxIdentifier, false, maxIdentifier},\n-            {maxIdentifier, true, \"\\\"\" + maxIdentifier + \"\\\"\"},\n-            {\"Hello\", false, \"Hello\"},\n-            {\"Hello\", true, \"\\\"Hello\\\"\"},\n-            {\"G'Day\", false, \"\\\"G'Day\\\"\"},\n-            {\"G'Day\", true, \"\\\"G'Day\\\"\"},\n-            {\"Bruce Wayne\", false, \"\\\"Bruce Wayne\\\"\"},\n-            {\"Bruce Wayne\", true, \"\\\"Bruce Wayne\\\"\"},\n-            {\"GoodDay$\", false, \"\\\"GoodDay$\\\"\"},\n-            {\"GoodDay$\", true, \"\\\"GoodDay$\\\"\"},};\n-    }\n-\n-    \/*\n-     * DataProvider used to provide strings are invalid for enquoteIdentifier\n-     * resulting in a SQLException being thrown\n-     *\/\n-    @DataProvider(name = \"invalidIdentifierValues\")\n-    protected Object[][] invalidEnquotedIdentifierValues() {\n-        return new Object[][]{\n-            {\"Hel\\\"lo\", false},\n-            {\"\\\"Hel\\\"lo\\\"\", true},\n-            {\"Hello\" + '\\0', false},\n-            {\"\", false},\n-            {maxIdentifier + 'a', false},};\n-    }\n-\n-    \/*\n-     * DataProvider used to provide strings that will be used to validate\n-     * that isSimpleIdentifier returns the correct value based on the\n-     * identifier specified.\n-     *\/\n-    @DataProvider(name = \"simpleIdentifierValues\")\n-    protected Object[][] simpleIdentifierValues() {\n-        return new Object[][]{\n-            {\"b\", true},\n-            {\"Hello\", true},\n-            {\"\\\"Gotham\\\"\", false},\n-            {\"G'Day\", false},\n-            {\"Bruce Wayne\", false},\n-            {\"GoodDay$\", false},\n-            {\"Dick_Grayson\", true},\n-            {\"Batmobile1966\", true},\n-            {maxIdentifier, true},\n-            {maxIdentifier + 'a', false},\n-            {\"\", false},};\n-    }\n-\n-    \/*\n-     * DataProvider used to provide strings that will be used to validate\n-     * that enquoteNCharLiteral converts a string to a National Character\n-     * literal and every instance of\n-     * a single quote will be converted into two single quotes in the literal.\n-     *\/\n-    @DataProvider(name = \"validEnquotedNCharLiteralValues\")\n-    protected Object[][] validEnquotedNCharLiteralValues() {\n-        return new Object[][]{\n-            {\"Hello\", \"N'Hello'\"},\n-            {\"G'Day\", \"N'G''Day'\"},\n-            {\"'G''Day'\", \"N'''G''''Day'''\"},\n-            {\"I'''M\", \"N'I''''''M'\"},\n-            {\"N'Hello'\", \"N'N''Hello'''\"},\n-            {\"The Dark Knight\", \"N'The Dark Knight'\"}\n-\n-        };\n-    }\n","filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/StatementTests.java","additions":11,"deletions":116,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.security.Policy;\n@@ -33,4 +32,1 @@\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.BeforeMethod;\n+\n@@ -50,16 +46,1 @@\n-\n-    @BeforeClass\n-    public static void setUpClass() throws Exception {\n-    }\n-\n-    @AfterClass\n-    public static void tearDownClass() throws Exception {\n-    }\n-\n-    @BeforeMethod\n-    public void setUpMethod() throws Exception {\n-    }\n-\n-    @AfterMethod\n-    public void tearDownMethod() throws Exception {\n-    }\n+    private static final String MAX_LENGTH_IDENTIFIER = \"a\".repeat(128);\n@@ -119,0 +100,95 @@\n+\n+    \/*\n+     * DataProvider used to provide strings that will be used to validate\n+     * that enquoteLiteral converts a string to a literal and every instance of\n+     * a single quote will be converted into two single quotes in the literal.\n+     *\/\n+    @DataProvider(name = \"validEnquotedLiteralValues\")\n+    protected Object[][] validEnquotedLiteralValues() {\n+        return new Object[][]{\n+                {\"Hello\", \"'Hello'\"},\n+                {\"G'Day\", \"'G''Day'\"},\n+                {\"'G''Day'\", \"'''G''''Day'''\"},\n+                {\"I'''M\", \"'I''''''M'\"},\n+                {\"The Dark Knight\", \"'The Dark Knight'\"},\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider used to provide strings that will be used to validate\n+     * that enqouteIdentifier returns a simple SQL Identifier or a\n+     * quoted identifier\n+     *\/\n+    @DataProvider(name = \"validIdentifierValues\")\n+    protected Object[][] validEnquotedIdentifierValues() {\n+        return new Object[][]{\n+                {\"b\", false, \"b\"},\n+                {\"b\", true, \"\\\"b\\\"\"},\n+                {MAX_LENGTH_IDENTIFIER, false, MAX_LENGTH_IDENTIFIER},\n+                {MAX_LENGTH_IDENTIFIER, true, \"\\\"\" + MAX_LENGTH_IDENTIFIER + \"\\\"\"},\n+                {\"Hello\", false, \"Hello\"},\n+                {\"Hello\", true, \"\\\"Hello\\\"\"},\n+                {\"G'Day\", false, \"\\\"G'Day\\\"\"},\n+                {\"G'Day\", true, \"\\\"G'Day\\\"\"},\n+                {\"Bruce Wayne\", false, \"\\\"Bruce Wayne\\\"\"},\n+                {\"Bruce Wayne\", true, \"\\\"Bruce Wayne\\\"\"},\n+                {\"select\", false, \"\\\"select\\\"\"},\n+                {\"table\", true, \"\\\"table\\\"\"},\n+                {\"GoodDay$\", false, \"\\\"GoodDay$\\\"\"},\n+                {\"GoodDay$\", true, \"\\\"GoodDay$\\\"\"},};\n+    }\n+\n+    \/*\n+     * DataProvider used to provide strings are invalid for enquoteIdentifier\n+     * resulting in a SQLException being thrown\n+     *\/\n+    @DataProvider(name = \"invalidIdentifierValues\")\n+    protected Object[][] invalidEnquotedIdentifierValues() {\n+        return new Object[][]{\n+                {\"Hel\\\"lo\", false},\n+                {\"\\\"Hel\\\"lo\\\"\", true},\n+                {\"Hello\" + '\\0', false},\n+                {\"\", false},\n+                {MAX_LENGTH_IDENTIFIER + 'a', false},};\n+    }\n+\n+    \/*\n+     * DataProvider used to provide strings that will be used to validate\n+     * that isSimpleIdentifier returns the correct value based on the\n+     * identifier specified.\n+     *\/\n+    @DataProvider(name = \"simpleIdentifierValues\")\n+    protected Object[][] simpleIdentifierValues() {\n+        return new Object[][]{\n+                {\"b\", true},\n+                {\"Hello\", true},\n+                {\"\\\"Gotham\\\"\", false},\n+                {\"G'Day\", false},\n+                {\"Bruce Wayne\", false},\n+                {\"GoodDay$\", false},\n+                {\"Dick_Grayson\", true},\n+                {\"Batmobile1966\", true},\n+                {MAX_LENGTH_IDENTIFIER, true},\n+                {MAX_LENGTH_IDENTIFIER + 'a', false},\n+                {\"\", false},\n+                {\"select\", false}\n+            };\n+    }\n+\n+    \/*\n+     * DataProvider used to provide strings that will be used to validate\n+     * that enquoteNCharLiteral converts a string to a National Character\n+     * literal and every instance of\n+     * a single quote will be converted into two single quotes in the literal.\n+     *\/\n+    @DataProvider(name = \"validEnquotedNCharLiteralValues\")\n+    protected Object[][] validEnquotedNCharLiteralValues() {\n+        return new Object[][]{\n+                {\"Hello\", \"N'Hello'\"},\n+                {\"G'Day\", \"N'G''Day'\"},\n+                {\"'G''Day'\", \"N'''G''''Day'''\"},\n+                {\"I'''M\", \"N'I''''''M'\"},\n+                {\"N'Hello'\", \"N'N''Hello'''\"},\n+                {\"The Dark Knight\", \"N'The Dark Knight'\"}\n+        };\n+    }\n","filename":"test\/jdk\/java\/sql\/testng\/util\/BaseTest.java","additions":98,"deletions":22,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,12 +29,1 @@\n-import java.sql.Array;\n-import java.sql.Blob;\n-import java.sql.CallableStatement;\n-import java.sql.Clob;\n-import java.sql.Date;\n-import java.sql.NClob;\n-import java.sql.Ref;\n-import java.sql.RowId;\n-import java.sql.SQLException;\n-import java.sql.SQLXML;\n-import java.sql.Time;\n-import java.sql.Timestamp;\n+import java.sql.*;\n@@ -47,0 +36,4 @@\n+    public StubCallableStatement(StubConnection con) {\n+        super(con);\n+    }\n+\n@@ -611,1 +604,0 @@\n-\n","filename":"test\/jdk\/java\/sql\/testng\/util\/StubCallableStatement.java","additions":6,"deletions":14,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,5 @@\n+    private boolean isclosed;\n+\n+    public StubConnection() {\n+        isclosed = false;\n+    }\n@@ -50,1 +55,1 @@\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+        return new StubStatement(this);\n@@ -55,1 +60,1 @@\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+        return new StubPreparedStatement(this);\n@@ -60,1 +65,1 @@\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+        return new StubCallableStatement(this);\n@@ -92,1 +97,1 @@\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+        isclosed = true;\n@@ -97,1 +102,1 @@\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+        return isclosed;\n@@ -102,1 +107,1 @@\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+        return new StubDatabaseMetaData();\n","filename":"test\/jdk\/java\/sql\/testng\/util\/StubConnection.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,907 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package util;\n+\n+import java.sql.*;\n+\n+public class StubDatabaseMetaData implements DatabaseMetaData {\n+    @Override\n+    public boolean allProceduresAreCallable() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean allTablesAreSelectable() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public String getURL() throws SQLException {\n+        return \"\";\n+    }\n+\n+    @Override\n+    public String getUserName() throws SQLException {\n+        return \"\";\n+    }\n+\n+    @Override\n+    public boolean isReadOnly() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean nullsAreSortedHigh() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean nullsAreSortedLow() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean nullsAreSortedAtStart() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean nullsAreSortedAtEnd() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public String getDatabaseProductName() throws SQLException {\n+        return \"\";\n+    }\n+\n+    @Override\n+    public String getDatabaseProductVersion() throws SQLException {\n+        return \"\";\n+    }\n+\n+    @Override\n+    public String getDriverName() throws SQLException {\n+        return \"\";\n+    }\n+\n+    @Override\n+    public String getDriverVersion() throws SQLException {\n+        return \"\";\n+    }\n+\n+    @Override\n+    public int getDriverMajorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getDriverMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public boolean usesLocalFiles() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean usesLocalFilePerTable() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsMixedCaseIdentifiers() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean storesUpperCaseIdentifiers() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean storesLowerCaseIdentifiers() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean storesMixedCaseIdentifiers() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsMixedCaseQuotedIdentifiers() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean storesUpperCaseQuotedIdentifiers() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean storesLowerCaseQuotedIdentifiers() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean storesMixedCaseQuotedIdentifiers() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public String getIdentifierQuoteString() throws SQLException {\n+        return \"\\\"\";\n+    }\n+\n+    @Override\n+    public String getSQLKeywords() throws SQLException {\n+        return \"\";\n+    }\n+\n+    @Override\n+    public String getNumericFunctions() throws SQLException {\n+        return \"\";\n+    }\n+\n+    @Override\n+    public String getStringFunctions() throws SQLException {\n+        return \"\";\n+    }\n+\n+    @Override\n+    public String getSystemFunctions() throws SQLException {\n+        return \"\";\n+    }\n+\n+    @Override\n+    public String getTimeDateFunctions() throws SQLException {\n+        return \"\";\n+    }\n+\n+    @Override\n+    public String getSearchStringEscape() throws SQLException {\n+        return \"\";\n+    }\n+\n+    @Override\n+    public String getExtraNameCharacters() throws SQLException {\n+        return \"\";\n+    }\n+\n+    @Override\n+    public boolean supportsAlterTableWithAddColumn() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsAlterTableWithDropColumn() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsColumnAliasing() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean nullPlusNonNullIsNull() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsConvert() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsConvert(int fromType, int toType) throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsTableCorrelationNames() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsDifferentTableCorrelationNames() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsExpressionsInOrderBy() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsOrderByUnrelated() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsGroupBy() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsGroupByUnrelated() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsGroupByBeyondSelect() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsLikeEscapeClause() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsMultipleResultSets() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsMultipleTransactions() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsNonNullableColumns() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsMinimumSQLGrammar() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsCoreSQLGrammar() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsExtendedSQLGrammar() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsANSI92EntryLevelSQL() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsANSI92IntermediateSQL() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsANSI92FullSQL() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsIntegrityEnhancementFacility() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsOuterJoins() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsFullOuterJoins() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsLimitedOuterJoins() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public String getSchemaTerm() throws SQLException {\n+        return \"\";\n+    }\n+\n+    @Override\n+    public String getProcedureTerm() throws SQLException {\n+        return \"\";\n+    }\n+\n+    @Override\n+    public String getCatalogTerm() throws SQLException {\n+        return \"\";\n+    }\n+\n+    @Override\n+    public boolean isCatalogAtStart() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public String getCatalogSeparator() throws SQLException {\n+        return \"\";\n+    }\n+\n+    @Override\n+    public boolean supportsSchemasInDataManipulation() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsSchemasInProcedureCalls() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsSchemasInTableDefinitions() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsSchemasInIndexDefinitions() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsSchemasInPrivilegeDefinitions() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsCatalogsInDataManipulation() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsCatalogsInProcedureCalls() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsCatalogsInTableDefinitions() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsCatalogsInIndexDefinitions() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsCatalogsInPrivilegeDefinitions() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsPositionedDelete() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsPositionedUpdate() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsSelectForUpdate() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsStoredProcedures() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsSubqueriesInComparisons() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsSubqueriesInExists() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsSubqueriesInIns() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsSubqueriesInQuantifieds() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsCorrelatedSubqueries() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsUnion() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsUnionAll() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsOpenCursorsAcrossCommit() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsOpenCursorsAcrossRollback() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsOpenStatementsAcrossCommit() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsOpenStatementsAcrossRollback() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public int getMaxBinaryLiteralLength() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getMaxCharLiteralLength() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getMaxColumnNameLength() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getMaxColumnsInGroupBy() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getMaxColumnsInIndex() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getMaxColumnsInOrderBy() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getMaxColumnsInSelect() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getMaxColumnsInTable() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getMaxConnections() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getMaxCursorNameLength() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getMaxIndexLength() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getMaxSchemaNameLength() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getMaxProcedureNameLength() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getMaxCatalogNameLength() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getMaxRowSize() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public boolean doesMaxRowSizeIncludeBlobs() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public int getMaxStatementLength() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getMaxStatements() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getMaxTableNameLength() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getMaxTablesInSelect() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getMaxUserNameLength() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getDefaultTransactionIsolation() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public boolean supportsTransactions() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsTransactionIsolationLevel(int level) throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsDataDefinitionAndDataManipulationTransactions() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsDataManipulationTransactionsOnly() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean dataDefinitionCausesTransactionCommit() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean dataDefinitionIgnoredInTransactions() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public ResultSet getProcedures(String catalog, String schemaPattern, String procedureNamePattern) throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public ResultSet getProcedureColumns(String catalog, String schemaPattern, String procedureNamePattern, String columnNamePattern) throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public ResultSet getTables(String catalog, String schemaPattern, String tableNamePattern, String[] types) throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public ResultSet getSchemas() throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public ResultSet getCatalogs() throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public ResultSet getTableTypes() throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public ResultSet getColumns(String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern) throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public ResultSet getColumnPrivileges(String catalog, String schema, String table, String columnNamePattern) throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public ResultSet getTablePrivileges(String catalog, String schemaPattern, String tableNamePattern) throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public ResultSet getBestRowIdentifier(String catalog, String schema, String table, int scope, boolean nullable) throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public ResultSet getVersionColumns(String catalog, String schema, String table) throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public ResultSet getPrimaryKeys(String catalog, String schema, String table) throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public ResultSet getImportedKeys(String catalog, String schema, String table) throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public ResultSet getExportedKeys(String catalog, String schema, String table) throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public ResultSet getCrossReference(String parentCatalog, String parentSchema, String parentTable, String foreignCatalog, String foreignSchema, String foreignTable) throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public ResultSet getTypeInfo() throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public ResultSet getIndexInfo(String catalog, String schema, String table, boolean unique, boolean approximate) throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean supportsResultSetType(int type) throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsResultSetConcurrency(int type, int concurrency) throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean ownUpdatesAreVisible(int type) throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean ownDeletesAreVisible(int type) throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean ownInsertsAreVisible(int type) throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean othersUpdatesAreVisible(int type) throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean othersDeletesAreVisible(int type) throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean othersInsertsAreVisible(int type) throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean updatesAreDetected(int type) throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean deletesAreDetected(int type) throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean insertsAreDetected(int type) throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsBatchUpdates() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public ResultSet getUDTs(String catalog, String schemaPattern, String typeNamePattern, int[] types) throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public Connection getConnection() throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean supportsSavepoints() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsNamedParameters() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsMultipleOpenResults() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsGetGeneratedKeys() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public ResultSet getSuperTypes(String catalog, String schemaPattern, String typeNamePattern) throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public ResultSet getSuperTables(String catalog, String schemaPattern, String tableNamePattern) throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public ResultSet getAttributes(String catalog, String schemaPattern, String typeNamePattern, String attributeNamePattern) throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean supportsResultSetHoldability(int holdability) throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public int getResultSetHoldability() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getDatabaseMajorVersion() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getDatabaseMinorVersion() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getJDBCMajorVersion() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getJDBCMinorVersion() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getSQLStateType() throws SQLException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public boolean locatorsUpdateCopy() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsStatementPooling() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public RowIdLifetime getRowIdLifetime() throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public ResultSet getSchemas(String catalog, String schemaPattern) throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean supportsStoredFunctionsUsingCallSyntax() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean autoCommitFailureClosesAllResultSets() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public ResultSet getClientInfoProperties() throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public ResultSet getFunctions(String catalog, String schemaPattern, String functionNamePattern) throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public ResultSet getFunctionColumns(String catalog, String schemaPattern, String functionNamePattern, String columnNamePattern) throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public ResultSet getPseudoColumns(String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern) throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean generatedKeyAlwaysReturned() throws SQLException {\n+        return false;\n+    }\n+\n+    @Override\n+    public <T> T unwrap(Class<T> iface) throws SQLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean isWrapperFor(Class<?> iface) throws SQLException {\n+        return false;\n+    }\n+}\n","filename":"test\/jdk\/java\/sql\/testng\/util\/StubDatabaseMetaData.java","additions":907,"deletions":0,"binary":false,"changes":907,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,15 +29,1 @@\n-import java.sql.Array;\n-import java.sql.Blob;\n-import java.sql.Clob;\n-import java.sql.Date;\n-import java.sql.NClob;\n-import java.sql.ParameterMetaData;\n-import java.sql.PreparedStatement;\n-import java.sql.Ref;\n-import java.sql.ResultSet;\n-import java.sql.ResultSetMetaData;\n-import java.sql.RowId;\n-import java.sql.SQLException;\n-import java.sql.SQLXML;\n-import java.sql.Time;\n-import java.sql.Timestamp;\n+import java.sql.*;\n@@ -48,0 +34,4 @@\n+    public StubPreparedStatement(StubConnection con) {\n+        super(con);\n+    }\n+\n@@ -322,1 +312,0 @@\n-\n","filename":"test\/jdk\/java\/sql\/testng\/util\/StubPreparedStatement.java","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,0 @@\n-import java.util.regex.Pattern;\n-import static java.util.stream.Collectors.joining;\n@@ -35,0 +33,6 @@\n+    protected final Connection con;\n+\n+    public StubStatement(StubConnection con) {\n+        this.con = con;\n+    }\n+\n@@ -47,1 +51,1 @@\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+        con.close();\n@@ -172,1 +176,1 @@\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+        return con;\n@@ -254,3 +258,0 @@\n-\n-\n-\n","filename":"test\/jdk\/java\/sql\/testng\/util\/StubStatement.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,0 @@\n-    @Override\n@@ -123,1 +122,0 @@\n-\n@@ -207,1 +205,0 @@\n-\n@@ -209,1 +206,0 @@\n-\n","filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/serial\/SQLInputImplTests.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,0 @@\n-    @Override\n","filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/serial\/SQLOutputImplTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}