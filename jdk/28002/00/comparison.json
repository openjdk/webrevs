{"files":[{"patch":"@@ -497,2 +497,2 @@\n-   do_name(gcm_crypt_name, \"implGCMCrypt0\")                                                                                 \\\n-   do_signature(aes_gcm_signature, \"([BII[BI[BILcom\/sun\/crypto\/provider\/GCTR;Lcom\/sun\/crypto\/provider\/GHASH;)I\")                                                             \\\n+   do_name(gcm_crypt_name, \"implGCMCrypt0\")                                                                             \\\n+   do_signature(aes_gcm_signature, \"([BII[BI[BILcom\/sun\/crypto\/provider\/GCTR;Lcom\/sun\/crypto\/provider\/GHASH;)I\")        \\\n@@ -1008,0 +1008,1 @@\n+                                      \"I\"                                                                                                      \\\n@@ -1020,0 +1021,1 @@\n+                                       \"I\"                                                                                                     \\\n@@ -1056,0 +1058,1 @@\n+                                        \"I\"                                                                                                    \\\n@@ -1068,0 +1071,1 @@\n+                                            \"I\"                                                                                                \\\n@@ -1079,0 +1083,1 @@\n+                                               \"I\"                                                                                             \\\n@@ -1090,0 +1095,1 @@\n+                                     \"I\"                                                                                                       \\\n@@ -1105,0 +1111,1 @@\n+                                            \"I\"                                                                                                \\\n@@ -1121,0 +1128,1 @@\n+                                      \"I\"                                                                                                      \\\n@@ -1136,0 +1144,1 @@\n+                                             \"I\"                                                                                               \\\n@@ -1153,0 +1162,1 @@\n+                                               \"I\"                                                                                             \\\n@@ -1164,0 +1174,1 @@\n+                                  \"I\"                                                                                                          \\\n@@ -1175,0 +1186,1 @@\n+                                   \"I\"                                                                                                         \\\n@@ -1185,1 +1197,3 @@\n-                                     \"Ljava\/lang\/Class;Ljava\/lang\/Class;\"                                                                      \\\n+                                     \"Ljava\/lang\/Class;\"                                                                                       \\\n+                                     \"Ljava\/lang\/Class;\"                                                                                       \\\n+                                     \"I\"                                                                                                       \\\n@@ -1200,0 +1214,1 @@\n+                                       \"I\"                                                                                                     \\\n@@ -1212,0 +1227,1 @@\n+                                        \"I\"                                                                                                     \\\n@@ -1217,1 +1233,1 @@\n-   do_name(vector_select_from_name, \"selectFromOp\")                                                                                              \\\n+   do_name(vector_select_from_name, \"selectFromOp\")                                                                                            \\\n@@ -1223,0 +1239,1 @@\n+                                     \"I\"                                                                                                       \\\n@@ -1233,0 +1250,1 @@\n+                                    \"I\"                                                                                                        \\\n@@ -1245,0 +1263,1 @@\n+                                           \"I\"                                                                                                 \\\n@@ -1271,0 +1290,1 @@\n+                                     \"I\"                                                                                                       \\\n@@ -1292,0 +1312,1 @@\n+                                      \"I\"                                                                                                      \\\n@@ -1314,0 +1335,1 @@\n+                                        \"I\"                                                                                                    \\\n@@ -1325,0 +1347,1 @@\n+                                      \"I\"                                                                                                      \\\n@@ -1335,0 +1358,1 @@\n+                                       \"I\"                                                                                                     \\\n@@ -1346,0 +1370,1 @@\n+                                                     \"I\"                                                                                                       \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":29,"deletions":4,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -102,0 +102,1 @@\n+  template(CTYPE_name,                                \"CTYPE\")                                              \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  ciField* fd1 = ik->get_field_by_name(ciSymbols::ETYPE_name(), ciSymbols::class_signature(), \/* is_static *\/ true);\n+  ciField* fd1 = ik->get_field_by_name(ciSymbols::CTYPE_name(), ciSymbols::class_signature(), \/* is_static *\/ true);\n@@ -72,0 +72,12 @@\n+static const char* get_opertype_string(int operType) {\n+  switch(operType) {\n+    case VectorSupport::VECTOR_TYPE_PRIM:\n+      return \"VECTOR_TYPE_PRIM\";\n+    case VectorSupport::VECTOR_TYPE_FP16:\n+      return \"VECTOR_TYPE_FP16\";\n+    default:\n+      ShouldNotReachHere();\n+      return nullptr;\n+  }\n+}\n+\n@@ -290,7 +302,0 @@\n-\/\/ public static\n-\/\/ <V extends Vector<E>,\n-\/\/  M extends VectorMask<E>,\n-\/\/  E>\n-\/\/ V unaryOp(int oprId, Class<? extends V> vmClass, Class<? extends M> maskClass, Class<E> elementType,\n-\/\/           int length, V v, M m,\n-\/\/           UnaryOperation<V, M> defaultImpl)\n@@ -298,7 +303,27 @@\n-\/\/ public static\n-\/\/ <V,\n-\/\/  M extends VectorMask<E>,\n-\/\/  E>\n-\/\/ V binaryOp(int oprId, Class<? extends V> vmClass, Class<? extends M> maskClass, Class<E> elementType,\n-\/\/            int length, V v1, V v2, M m,\n-\/\/            BinaryOperation<V, M> defaultImpl)\n+\/\/  <V extends Vector<E>,\n+\/\/   M extends VectorMask<E>,\n+\/\/   E>\n+\/\/  V unaryOp(int oprId,\n+\/\/            Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, int operType,\n+\/\/            int length,\n+\/\/            V v, M m,\n+\/\/            UnaryOperation<V, M> defaultImpl) {\n+\/\/\n+\/\/  <VM extends VectorPayload,\n+\/\/   M extends VectorMask<E>,\n+\/\/   E>\n+\/\/  VM binaryOp(int oprId,\n+\/\/              Class<? extends VM> vmClass, Class<? extends M> mClass, Class<?> cClass, int operType,\n+\/\/              int length,\n+\/\/              VM v1, VM v2, M m,\n+\/\/              BinaryOperation<VM, M> defaultImpl) {\n+\/\/\n+\/\/\n+\/\/  <V extends Vector<E>,\n+\/\/   M extends VectorMask<E>,\n+\/\/   E>\n+\/\/  V ternaryOp(int oprId,\n+\/\/              Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, int operType,\n+\/\/              int length,\n+\/\/              V v1, V v2, V v3, M m,\n+\/\/              TernaryOperation<V, M> defaultImpl) {\n@@ -306,7 +331,0 @@\n-\/\/ public static\n-\/\/ <V extends Vector<E>,\n-\/\/  M extends VectorMask<E>,\n-\/\/  E>\n-\/\/ V ternaryOp(int oprId, Class<? extends V> vmClass, Class<? extends M> maskClass, Class<E> elementType,\n-\/\/             int length, V v1, V v2, V v3, M m,\n-\/\/             TernaryOperation<V, M> defaultImpl)\n@@ -319,1 +337,2 @@\n-  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     operType     = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(5))->isa_int();\n@@ -322,0 +341,1 @@\n+      operType     == nullptr || !operType->is_con() ||\n@@ -325,1 +345,1 @@\n-    log_if_needed(\"  ** missing constant: opr=%s vclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: opr=%s vclass=%s etype=%s operType=%s vlen=%s\",\n@@ -329,1 +349,2 @@\n-                    NodeClassNames[argument(4)->Opcode()]);\n+                    NodeClassNames[argument(4)->Opcode()],\n+                    NodeClassNames[argument(5)->Opcode()]);\n@@ -345,1 +366,1 @@\n-  const Type* vmask_type = gvn().type(argument(n + 5));\n+  const Type* vmask_type = gvn().type(argument(n + 6));\n@@ -369,1 +390,1 @@\n-  int opc = VectorSupport::vop2ideal(opr->get_con(), elem_bt);\n+  int opc = VectorSupport::vop2ideal(opr->get_con(), elem_bt, operType->get_con());\n@@ -404,1 +425,1 @@\n-      opd3 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);\n+      opd3 = unbox_vector(argument(8), vbox_type, elem_bt, num_elem);\n@@ -407,1 +428,1 @@\n-                        NodeClassNames[argument(7)->Opcode()]);\n+                        NodeClassNames[argument(8)->Opcode()]);\n@@ -413,1 +434,1 @@\n-      opd2 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);\n+      opd2 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);\n@@ -416,1 +437,1 @@\n-                        NodeClassNames[argument(6)->Opcode()]);\n+                        NodeClassNames[argument(7)->Opcode()]);\n@@ -422,1 +443,1 @@\n-      opd1 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+      opd1 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);\n@@ -425,1 +446,1 @@\n-                        NodeClassNames[argument(5)->Opcode()]);\n+                        NodeClassNames[argument(6)->Opcode()]);\n@@ -438,1 +459,1 @@\n-    mask = unbox_vector(argument(n + 5), mbox_type, elem_bt, num_elem);\n+    mask = unbox_vector(argument(n + 6), mbox_type, elem_bt, num_elem);\n@@ -441,1 +462,1 @@\n-                      NodeClassNames[argument(n + 5)->Opcode()]);\n+                      NodeClassNames[argument(n + 6)->Opcode()]);\n@@ -480,5 +501,0 @@\n-\/\/ public static\n-\/\/ <V extends Vector<E>, E>\n-\/\/ V libraryUnaryOp(long address, Class<? extends V> vClass, Class<E> elementType, int length, String debugName,\n-\/\/                  V v,\n-\/\/                  UnaryOperation<V, ?> defaultImpl)\n@@ -486,5 +502,10 @@\n-\/\/ public static\n-\/\/ <V extends VectorPayload, E>\n-\/\/ V libraryBinaryOp(long address, Class<? extends V> vClass, Class<E> elementType, int length, String debugName,\n-\/\/            V v1, V v2,\n-\/\/            BinaryOperation<V, ?> defaultImpl)\n+\/\/  <V extends Vector<E>, E>\n+\/\/  V libraryUnaryOp(long addr, Class<? extends V> vClass, Class<?> cClass, int operType, int length, String debugName,\n+\/\/                   V v,\n+\/\/                   UnaryOperation<V,?> defaultImpl)\n+\/\/\n+\/\/  <V extends VectorPayload, E>\n+\/\/  V libraryBinaryOp(long addr, Class<? extends V> vClass, Class<?> cClass, int operType, int length, String debugName,\n+\/\/                    V v1, V v2,\n+\/\/                    BinaryOperation<V,?> defaultImpl)\n+\/\/\n@@ -497,2 +518,3 @@\n-  const TypeInt*     vlen           = gvn().type(argument(4))->isa_int();\n-  const TypeInstPtr* debug_name_oop = gvn().type(argument(5))->isa_instptr();\n+  const TypeInt*     operType       = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     vlen           = gvn().type(argument(5))->isa_int();\n+  const TypeInstPtr* debug_name_oop = gvn().type(argument(6))->isa_instptr();\n@@ -503,1 +525,2 @@\n-      vlen         == nullptr   || !vlen->is_con() ||\n+      operType     == nullptr   || !operType->is_con() ||\n+      vlen  == nullptr   || !vlen->is_con() ||\n@@ -505,1 +528,1 @@\n-    log_if_needed(\"  ** missing constant: opr=%s vclass=%s etype=%s vlen=%s debug_name=%s\",\n+    log_if_needed(\"  ** missing constant: opr=%s vclass=%s etype=%s operType=%s vlen=%s debug_name=%s\",\n@@ -510,1 +533,2 @@\n-                  NodeClassNames[argument(5)->Opcode()]);\n+                  NodeClassNames[argument(5)->Opcode()],\n+                  NodeClassNames[argument(6)->Opcode()]);\n@@ -519,0 +543,5 @@\n+  if (operType->get_con() != VectorSupport::VECTOR_TYPE_PRIM) {\n+    log_if_needed(\"  ** unhandled operType=%s\", get_opertype_string(operType->get_con()));\n+    return false;\n+  }\n+\n@@ -540,1 +569,1 @@\n-  Node* opd1 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);\n+  Node* opd1 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);\n@@ -542,1 +571,1 @@\n-    log_if_needed(\"  ** unbox failed v1=%s\", NodeClassNames[argument(6)->Opcode()]);\n+    log_if_needed(\"  ** unbox failed v1=%s\", NodeClassNames[argument(7)->Opcode()]);\n@@ -548,1 +577,1 @@\n-    opd2 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);\n+    opd2 = unbox_vector(argument(8), vbox_type, elem_bt, num_elem);\n@@ -550,1 +579,1 @@\n-      log_if_needed(\"  ** unbox failed v2=%s\", NodeClassNames[argument(7)->Opcode()]);\n+      log_if_needed(\"  ** unbox failed v2=%s\", NodeClassNames[argument(8)->Opcode()]);\n@@ -582,3 +611,9 @@\n-\/\/ <E, M>\n-\/\/ long maskReductionCoerced(int oper, Class<? extends M> maskClass, Class<?> elemClass,\n-\/\/                          int length, M m, VectorMaskOp<M> defaultImpl)\n+\/\/\n+\/\/  <M extends VectorMask<E>,\n+\/\/   E>\n+\/\/  long maskReductionCoerced(int oper,\n+\/\/                            Class<? extends M> mClass, Class<?> cClass, int operType,\n+\/\/                            int length,\n+\/\/                            M m,\n+\/\/                            VectorMaskOp<M> defaultImpl)\n+\/\/\n@@ -589,2 +624,3 @@\n-  const TypeInt*     vlen       = gvn().type(argument(3))->isa_int();\n-  Node*              mask       = argument(4);\n+  const TypeInt*     operType   = gvn().type(argument(3))->isa_int();\n+  const TypeInt*     vlen       = gvn().type(argument(4))->isa_int();\n+  Node*              mask       = argument(5);\n@@ -594,0 +630,1 @@\n+      operType   == nullptr || !operType->is_con() ||\n@@ -600,0 +637,5 @@\n+  if (operType->get_con() != VectorSupport::VECTOR_TYPE_PRIM) {\n+    log_if_needed(\"  ** unhandled operType=%s\", get_opertype_string(operType->get_con()));\n+    return false;\n+  }\n+\n@@ -607,0 +649,6 @@\n+  if (!elem_type->is_primitive_type()) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n+    }\n+    return false; \/\/ should be primitive type\n+  }\n@@ -621,1 +669,1 @@\n-                      NodeClassNames[argument(4)->Opcode()]);\n+                      NodeClassNames[argument(5)->Opcode()]);\n@@ -639,7 +687,9 @@\n-\/\/ public static\n-\/\/ <M,\n-\/\/  S extends VectorSpecies<E>,\n-\/\/  E>\n-\/\/ M fromBitsCoerced(Class<? extends M> vmClass, Class<E> elementType, int length,\n-\/\/                    long bits, int mode, S s,\n-\/\/                    BroadcastOperation<M, E, S> defaultImpl)\n+\/\/\n+\/\/  <VM extends VectorPayload,\n+\/\/   S extends VectorSpecies<E>,\n+\/\/   E>\n+\/\/  VM fromBitsCoerced(Class<? extends VM> vmClass, Class<?> cClass, int operType,\n+\/\/                     int length,\n+\/\/                     long bits, int mode, S s,\n+\/\/                     FromBitsCoercedOperation<VM, S> defaultImpl)\n+\/\/\n@@ -649,2 +699,3 @@\n-  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();\n-  const TypeLong*    bits_type    = gvn().type(argument(3))->isa_long();\n+  const TypeInt*     operType     = gvn().type(argument(2))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();\n+  const TypeLong*    bits_type    = gvn().type(argument(4))->isa_long();\n@@ -654,1 +705,1 @@\n-  const TypeInt*     mode         = gvn().type(argument(5))->isa_int();\n+  const TypeInt*     mode         = gvn().type(argument(6))->isa_int();\n@@ -658,0 +709,1 @@\n+      operType     == nullptr || !operType->is_con() ||\n@@ -661,1 +713,1 @@\n-    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s bitwise=%s\",\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s operType=%s vlen=%s bitwise=%s\",\n@@ -665,1 +717,2 @@\n-                    NodeClassNames[argument(5)->Opcode()]);\n+                    NodeClassNames[argument(3)->Opcode()],\n+                    NodeClassNames[argument(6)->Opcode()]);\n@@ -669,0 +722,7 @@\n+\n+  int  bcast_mode = mode->get_con();\n+  if (operType->get_con() != VectorSupport::VECTOR_TYPE_PRIM && bcast_mode != VectorSupport::MODE_BROADCAST) {\n+    log_if_needed(\"  ** unhandled operType=%s\", get_opertype_string(operType->get_con()));\n+    return false;\n+  }\n+\n@@ -684,1 +744,0 @@\n-  int  bcast_mode = mode->get_con();\n@@ -706,1 +765,1 @@\n-  Node* bits = argument(3);\n+  Node* bits = argument(4);\n@@ -769,1 +828,1 @@\n-\/\/  public static\n+\/\/\n@@ -774,1 +833,1 @@\n-\/\/  VM load(Class<? extends VM> vmClass, Class<E> eClass,\n+\/\/  VM load(Class<? extends VM> vmClass, Class<?> cClass, int operType,\n@@ -776,5 +835,5 @@\n-\/\/          Object base, long offset,            \/\/ Unsafe addressing\n-\/\/          boolean fromSegment,\n-\/\/          C container, long index, S s,        \/\/ Arguments for default implementation\n-\/\/          LoadOperation<C, VM, S> defaultImpl) {\n-\/\/  public static\n+\/\/          Object base, long offset, boolean fromSegment,\n+\/\/          C container, long index, S s,\n+\/\/          LoadOperation<C, VM, S> defaultImpl)\n+\/\/\n+\/\/\n@@ -783,1 +842,1 @@\n-\/\/  void store(Class<?> vClass, Class<?> eClass,\n+\/\/  void store(Class<?> vClass, Class<?> cClass, int operType,\n@@ -785,4 +844,4 @@\n-\/\/             Object base, long offset,        \/\/ Unsafe addressing\n-\/\/             boolean fromSegment,\n-\/\/             V v, C container, long index,    \/\/ Arguments for default implementation\n-\/\/             StoreVectorOperation<C, V> defaultImpl) {\n+\/\/             Object base, long offset, boolean fromSegment,\n+\/\/             V v, C container, long index,\n+\/\/             StoreVectorOperation<C, V> defaultImpl)\n+\/\/\n@@ -792,2 +851,3 @@\n-  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();\n-  const TypeInt*     from_ms      = gvn().type(argument(6))->isa_int();\n+  const TypeInt*     operType     = gvn().type(argument(2))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();\n+  const TypeInt*     from_ms      = gvn().type(argument(7))->isa_int();\n@@ -797,0 +857,1 @@\n+      operType     == nullptr || !operType->is_con() ||\n@@ -799,1 +860,1 @@\n-    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s from_ms=%s\",\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s operType=%s vlen=%s from_ms=%s\",\n@@ -803,1 +864,2 @@\n-                    NodeClassNames[argument(6)->Opcode()]);\n+                    NodeClassNames[argument(3)->Opcode()],\n+                    NodeClassNames[argument(7)->Opcode()]);\n@@ -830,2 +892,2 @@\n-  Node* base = argument(3);\n-  Node* offset = ConvL2X(argument(4));\n+  Node* base = argument(4);\n+  Node* offset = ConvL2X(argument(5));\n@@ -913,1 +975,1 @@\n-    Node* val = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);\n+    Node* val = unbox_vector(argument(8), vbox_type, elem_bt, num_elem);\n@@ -961,1 +1023,1 @@\n-\/\/  public static\n+\/\/\n@@ -967,3 +1029,2 @@\n-\/\/  V loadMasked(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n-\/\/               int length, Object base, long offset,          \/\/ Unsafe addressing\n-\/\/               boolean fromSegment,\n+\/\/  V loadMasked(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, int operType,\n+\/\/               int length, Object base, long offset, boolean fromSegment,\n@@ -971,3 +1032,3 @@\n-\/\/               C container, long index, S s,                  \/\/ Arguments for default implementation\n-\/\/               LoadVectorMaskedOperation<C, V, S, M> defaultImpl) {\n-\/\/  public static\n+\/\/               C container, long index, S s,\n+\/\/               LoadVectorMaskedOperation<C, V, S, M> defaultImpl)\n+\/\/\n@@ -978,1 +1039,1 @@\n-\/\/  void storeMasked(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n+\/\/  void storeMasked(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, int operType,\n@@ -980,4 +1041,4 @@\n-\/\/                   Object base, long offset,                  \/\/ Unsafe addressing\n-\/\/                   boolean fromSegment,\n-\/\/                   V v, M m, C container, long index,         \/\/ Arguments for default implementation\n-\/\/                   StoreVectorMaskedOperation<C, V, M> defaultImpl) {\n+\/\/                   Object base, long offset, boolean fromSegment,\n+\/\/                   V v, M m, C container, long index,\n+\/\/                   StoreVectorMaskedOperation<C, V, M> defaultImpl)\n+\/\/\n@@ -989,2 +1050,3 @@\n-  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();\n-  const TypeInt*     from_ms      = gvn().type(argument(7))->isa_int();\n+  const TypeInt*     operType     = gvn().type(argument(3))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     from_ms      = gvn().type(argument(8))->isa_int();\n@@ -995,0 +1057,1 @@\n+      operType     == nullptr || !operType->is_con() ||\n@@ -997,1 +1060,1 @@\n-    log_if_needed(\"  ** missing constant: vclass=%s mclass=%s etype=%s vlen=%s from_ms=%s\",\n+    log_if_needed(\"  ** missing constant: vclass=%s mclass=%s etype=%s operType=%s vlen=%s from_ms=%s\",\n@@ -1002,1 +1065,2 @@\n-                    NodeClassNames[argument(7)->Opcode()]);\n+                    NodeClassNames[argument(4)->Opcode()],\n+                    NodeClassNames[argument(8)->Opcode()]);\n@@ -1005,0 +1069,1 @@\n+\n@@ -1024,2 +1089,2 @@\n-  Node* base = argument(4);\n-  Node* offset = ConvL2X(argument(5));\n+  Node* base = argument(5);\n+  Node* offset = ConvL2X(argument(6));\n@@ -1058,1 +1123,1 @@\n-      const TypeInt* offset_in_range = gvn().type(argument(9))->isa_int();\n+      const TypeInt* offset_in_range = gvn().type(argument(10))->isa_int();\n@@ -1061,1 +1126,1 @@\n-                        NodeClassNames[argument(8)->Opcode()]);\n+                        NodeClassNames[argument(10)->Opcode()]);\n@@ -1116,1 +1181,1 @@\n-  Node* mask = unbox_vector(is_store ? argument(9) : argument(8), mbox_type, elem_bt, num_elem);\n+  Node* mask = unbox_vector(is_store ? argument(10) : argument(9), mbox_type, elem_bt, num_elem);\n@@ -1119,2 +1184,2 @@\n-                    is_store ? NodeClassNames[argument(9)->Opcode()]\n-                             : NodeClassNames[argument(8)->Opcode()]);\n+                    is_store ? NodeClassNames[argument(10)->Opcode()]\n+                             : NodeClassNames[argument(9)->Opcode()]);\n@@ -1125,1 +1190,1 @@\n-    Node* val = unbox_vector(argument(8), vbox_type, elem_bt, num_elem);\n+    Node* val = unbox_vector(argument(9), vbox_type, elem_bt, num_elem);\n@@ -1128,1 +1193,1 @@\n-                      NodeClassNames[argument(8)->Opcode()]);\n+                      NodeClassNames[argument(9)->Opcode()]);\n@@ -1192,7 +1257,7 @@\n-\/\/   V loadWithMap(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass, int length,\n-\/\/                 Class<? extends Vector<Integer>> vectorIndexClass, int indexLength,\n-\/\/                 Object base, long offset,\n-\/\/                 W indexVector1, W indexVector2, W indexVector3, W indexVector4,\n-\/\/                 M m, C container, int index, int[] indexMap, int indexM, S s,\n-\/\/                 LoadVectorOperationWithMap<C, V, S, M> defaultImpl)\n-\/\/\n+\/\/  V loadWithMap(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, int operType,\n+\/\/                int length,\n+\/\/                Class<? extends Vector<Integer>> vectorIndexClass,\n+\/\/                int indexLength, Object base, long offset,\n+\/\/                W indexVector1, W indexVector2, W indexVector3, W indexVector4,\n+\/\/                M m, C container, int index, int[] indexMap, int indexM, S s,\n+\/\/                LoadVectorOperationWithMap<C, V, S, M> defaultImpl)\n@@ -1204,6 +1269,8 @@\n-\/\/   void storeWithMap(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass, int length,\n-\/\/                     Class<? extends Vector<Integer>> vectorIndexClass, int indexLength,\n-\/\/                     Object base, long offset, \/\/ Unsafe addressing\n-\/\/                     W indexVector, V v, M m,\n-\/\/                     C container, int index, int[] indexMap, int indexM, \/\/ Arguments for default implementation\n-\/\/                     StoreVectorOperationWithMap<C, V, M> defaultImpl)\n+\/\/  void storeWithMap(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, int operType,\n+\/\/                    int length,\n+\/\/                    Class<? extends Vector<Integer>> vectorIndexClass,\n+\/\/                    int indexLength, Object base, long offset,\n+\/\/                    W indexVector,\n+\/\/                    V v, M m, C container, int index, int[] indexMap, int indexM,\n+\/\/                    StoreVectorOperationWithMap<C, V, M> defaultImpl)\n+\/\/\n@@ -1215,3 +1282,4 @@\n-  const TypeInt*     vlen             = gvn().type(argument(3))->isa_int();\n-  const TypeInstPtr* vector_idx_klass = gvn().type(argument(4))->isa_instptr();\n-  const TypeInt*     idx_vlen         = gvn().type(argument(5))->isa_int();\n+  const TypeInt*     operType         = gvn().type(argument(3))->isa_int();\n+  const TypeInt*     vlen             = gvn().type(argument(4))->isa_int();\n+  const TypeInstPtr* vector_idx_klass = gvn().type(argument(5))->isa_instptr();\n+  const TypeInt*     idx_vlen         = gvn().type(argument(6))->isa_int();\n@@ -1221,0 +1289,1 @@\n+      operType         == nullptr || !operType->is_con() ||\n@@ -1224,1 +1293,1 @@\n-    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s viclass=%s idx_vlen=%s\",\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s operType=%s vlen=%s viclass=%s idx_vlen=%s\",\n@@ -1229,1 +1298,2 @@\n-                    NodeClassNames[argument(5)->Opcode()]);\n+                    NodeClassNames[argument(5)->Opcode()],\n+                    NodeClassNames[argument(6)->Opcode()]);\n@@ -1248,1 +1318,1 @@\n-  Node* m = is_scatter ? argument(11) : argument(13);\n+  Node* m = is_scatter ? argument(12) : argument(14);\n@@ -1294,2 +1364,2 @@\n-  Node* base = argument(6);\n-  Node* offset = ConvL2X(argument(7));\n+  Node* base = argument(7);\n+  Node* offset = ConvL2X(argument(8));\n@@ -1308,1 +1378,1 @@\n-    Node* index = argument(15);\n+    Node* index = argument(16);\n@@ -1334,2 +1404,2 @@\n-    Node* indexMap = argument(16);\n-    Node* indexM   = argument(17);\n+    Node* indexMap = argument(17);\n+    Node* indexM   = argument(18);\n@@ -1339,1 +1409,1 @@\n-    indexes = unbox_vector(argument(9), vbox_idx_type, T_INT, idx_num_elem);\n+    indexes = unbox_vector(argument(10), vbox_idx_type, T_INT, idx_num_elem);\n@@ -1359,1 +1429,1 @@\n-    Node* val = unbox_vector(argument(10), vbox_type, elem_bt, num_elem);\n+    Node* val = unbox_vector(argument(11), vbox_type, elem_bt, num_elem);\n@@ -1388,7 +1458,10 @@\n-\/\/ public static\n-\/\/ <V extends Vector<E>,\n-\/\/  M extends VectorMask<E>,\n-\/\/  E>\n-\/\/ long reductionCoerced(int oprId, Class<? extends V> vectorClass, Class<? extends M> maskClass,\n-\/\/                       Class<E> elementType, int length, V v, M m,\n-\/\/                       ReductionOperation<V, M> defaultImpl)\n+\/\/\n+\/\/  <V extends Vector<E>,\n+\/\/   M extends VectorMask<E>,\n+\/\/   E>\n+\/\/  long reductionCoerced(int oprId,\n+\/\/                        Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, int operType,\n+\/\/                        int length,\n+\/\/                        V v, M m,\n+\/\/                        ReductionOperation<V, M> defaultImpl)\n+\/\/\n@@ -1400,1 +1473,2 @@\n-  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     operType     = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(5))->isa_int();\n@@ -1402,1 +1476,1 @@\n-  if (opr          == nullptr || !opr->is_con() ||\n+  if (opr          == nullptr || !opr->is_con() || !operType->is_con() ||\n@@ -1406,1 +1480,1 @@\n-    log_if_needed(\"  ** missing constant: opr=%s vclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: opr=%s vclass=%s etype=%s operType=%s vlen=%s\",\n@@ -1410,1 +1484,2 @@\n-                    NodeClassNames[argument(4)->Opcode()]);\n+                    NodeClassNames[argument(4)->Opcode()],\n+                    NodeClassNames[argument(5)->Opcode()]);\n@@ -1422,0 +1497,4 @@\n+  if (operType->get_con() != VectorSupport::VECTOR_TYPE_PRIM) {\n+    log_if_needed(\"  ** unhandled operType=%s\", get_opertype_string(operType->get_con()));\n+    return false;\n+  }\n@@ -1423,1 +1502,1 @@\n-  const Type* vmask_type = gvn().type(argument(6));\n+  const Type* vmask_type = gvn().type(argument(7));\n@@ -1466,1 +1545,1 @@\n-  Node* opd = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+  Node* opd = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);\n@@ -1476,1 +1555,1 @@\n-    mask = unbox_vector(argument(6), mbox_type, elem_bt, num_elem);\n+    mask = unbox_vector(argument(7), mbox_type, elem_bt, num_elem);\n@@ -1479,1 +1558,1 @@\n-                      NodeClassNames[argument(6)->Opcode()]);\n+                      NodeClassNames[argument(7)->Opcode()]);\n@@ -1532,3 +1611,11 @@\n-\/\/ public static <V> boolean test(int cond, Class<?> vectorClass, Class<?> elementType, int vlen,\n-\/\/                                V v1, V v2,\n-\/\/                                BiFunction<V, V, Boolean> defaultImpl)\n+\n+\n+\/\/\n+\/\/  <M extends VectorMask<E>,\n+\/\/   E>\n+\/\/  boolean test(int cond,\n+\/\/               Class<?> mClass, Class<?> cClass, int operType,\n+\/\/               int length,\n+\/\/               M m1, M m2,\n+\/\/               BiFunction<M, M, Boolean> defaultImpl)\n+\/\/\n@@ -1540,1 +1627,2 @@\n-  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();\n+  const TypeInt*     operType     = gvn().type(argument(3))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();\n@@ -1545,0 +1633,1 @@\n+      operType     == nullptr || !operType->is_con() ||\n@@ -1546,1 +1635,1 @@\n-    log_if_needed(\"  ** missing constant: cond=%s vclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: cond=%s vclass=%s etype=%s operType=%s vlen=%s\",\n@@ -1550,1 +1639,2 @@\n-                    NodeClassNames[argument(3)->Opcode()]);\n+                    NodeClassNames[argument(3)->Opcode()],\n+                    NodeClassNames[argument(4)->Opcode()]);\n@@ -1553,0 +1643,6 @@\n+\n+  if (operType->get_con() != VectorSupport::VECTOR_TYPE_PRIM) {\n+    log_if_needed(\"  ** unhandled operType=%s\", get_opertype_string(operType->get_con()));\n+    return false;\n+  }\n+\n@@ -1575,1 +1671,1 @@\n-  Node* opd1 = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);\n+  Node* opd1 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n@@ -1579,1 +1675,1 @@\n-    opd2 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+    opd2 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);\n@@ -1598,7 +1694,9 @@\n-\/\/ public static\n-\/\/ <V extends Vector<E>,\n-\/\/  M extends VectorMask<E>,\n-\/\/  E>\n-\/\/ V blend(Class<? extends V> vectorClass, Class<M> maskClass, Class<E> elementType, int vlen,\n-\/\/         V v1, V v2, M m,\n-\/\/         VectorBlendOp<V, M, E> defaultImpl)\n+\/\/\n+\/\/  <V extends Vector<E>,\n+\/\/   M extends VectorMask<E>,\n+\/\/   E>\n+\/\/  V blend(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, int operType,\n+\/\/          int length,\n+\/\/          V v1, V v2, M m,\n+\/\/          VectorBlendOp<V, M> defaultImpl)\n+\/\/\n@@ -1609,1 +1707,2 @@\n-  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();\n+  const TypeInt*     operType     = gvn().type(argument(3))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();\n@@ -1611,1 +1710,1 @@\n-  if (mask_klass == nullptr || vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr) {\n+  if (mask_klass == nullptr || vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr || operType == nullptr) {\n@@ -1615,2 +1714,2 @@\n-      elem_klass->const_oop() == nullptr || !vlen->is_con()) {\n-    log_if_needed(\"  ** missing constant: vclass=%s mclass=%s etype=%s vlen=%s\",\n+      elem_klass->const_oop() == nullptr || !vlen->is_con() || !operType->is_con()) {\n+    log_if_needed(\"  ** missing constant: vclass=%s mclass=%s etype=%s operType=%s vlen=%s\",\n@@ -1620,1 +1719,2 @@\n-                    NodeClassNames[argument(3)->Opcode()]);\n+                    NodeClassNames[argument(3)->Opcode()],\n+                    NodeClassNames[argument(4)->Opcode()]);\n@@ -1623,0 +1723,1 @@\n+\n@@ -1647,3 +1748,3 @@\n-  Node* v1   = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);\n-  Node* v2   = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n-  Node* mask = unbox_vector(argument(6), mbox_type, mask_bt, num_elem);\n+  Node* v1   = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+  Node* v2   = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);\n+  Node* mask = unbox_vector(argument(7), mbox_type, mask_bt, num_elem);\n@@ -1663,1 +1764,2 @@\n-\/\/  public static\n+\n+\/\/\n@@ -1667,1 +1769,3 @@\n-\/\/  M compare(int cond, Class<? extends V> vectorClass, Class<M> maskClass, Class<E> elementType, int vlen,\n+\/\/  M compare(int cond,\n+\/\/            Class<? extends V> vectorClass, Class<M> mClass, Class<?> cClass, int operType,\n+\/\/            int length,\n@@ -1669,1 +1773,2 @@\n-\/\/            VectorCompareOp<V,M> defaultImpl)\n+\/\/            VectorCompareOp<V, M> defaultImpl)\n+\/\/\n@@ -1675,1 +1780,2 @@\n-  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     operType     = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(5))->isa_int();\n@@ -1677,1 +1783,1 @@\n-  if (cond == nullptr || vector_klass == nullptr || mask_klass == nullptr || elem_klass == nullptr || vlen == nullptr) {\n+  if (cond == nullptr || vector_klass == nullptr || mask_klass == nullptr || elem_klass == nullptr || operType == nullptr || vlen == nullptr) {\n@@ -1681,2 +1787,2 @@\n-      elem_klass->const_oop() == nullptr || !vlen->is_con()) {\n-    log_if_needed(\"  ** missing constant: cond=%s vclass=%s mclass=%s etype=%s vlen=%s\",\n+      elem_klass->const_oop() == nullptr || !operType->is_con() || !vlen->is_con()) {\n+    log_if_needed(\"  ** missing constant: cond=%s vclass=%s mclass=%s etype=%s operType=%s vlen=%s\",\n@@ -1687,1 +1793,2 @@\n-                    NodeClassNames[argument(4)->Opcode()]);\n+                    NodeClassNames[argument(4)->Opcode()],\n+                    NodeClassNames[argument(5)->Opcode()]);\n@@ -1690,0 +1797,6 @@\n+\n+  if (operType->get_con() != VectorSupport::VECTOR_TYPE_PRIM) {\n+    log_if_needed(\"  ** unhandled operType=%s\", get_opertype_string(operType->get_con()));\n+    return false;\n+  }\n+\n@@ -1724,2 +1837,2 @@\n-  Node* v1 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n-  Node* v2 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);\n+  Node* v1 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);\n+  Node* v2 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);\n@@ -1727,2 +1840,2 @@\n-  bool is_masked_op = argument(7)->bottom_type() != TypePtr::NULL_PTR;\n-  Node* mask = is_masked_op ? unbox_vector(argument(7), mbox_type, elem_bt, num_elem) : nullptr;\n+  bool is_masked_op = argument(8)->bottom_type() != TypePtr::NULL_PTR;\n+  Node* mask = is_masked_op ? unbox_vector(argument(8), mbox_type, elem_bt, num_elem) : nullptr;\n@@ -1769,8 +1882,10 @@\n-\/\/ public static\n-\/\/ <V extends Vector<E>,\n-\/\/  Sh extends VectorShuffle<E>,\n-\/\/  M extends VectorMask<E>,\n-\/\/  E>\n-\/\/ V rearrangeOp(Class<? extends V> vectorClass, Class<Sh> shuffleClass, Class<M> maskClass, Class<E> elementType, int vlen,\n-\/\/               V v1, Sh sh, M m,\n-\/\/               VectorRearrangeOp<V, Sh, M, E> defaultImpl)\n+\/\/\n+\/\/  <V extends Vector<E>,\n+\/\/   SH extends VectorShuffle<E>,\n+\/\/   M  extends VectorMask<E>,\n+\/\/   E>\n+\/\/  V rearrangeOp(Class<? extends V> vClass, Class<SH> shClass, Class<M> mClass, Class<?> cClass, int operType,\n+\/\/                int length,\n+\/\/                V v, SH sh, M m,\n+\/\/                VectorRearrangeOp<V, SH, M> defaultImpl)\n+\/\/\n@@ -1782,1 +1897,2 @@\n-  const TypeInt*     vlen          = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     operType      = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     vlen          = gvn().type(argument(5))->isa_int();\n@@ -1784,1 +1900,1 @@\n-  if (vector_klass == nullptr  || shuffle_klass == nullptr ||  elem_klass == nullptr || vlen == nullptr) {\n+  if (vector_klass == nullptr  || shuffle_klass == nullptr ||  elem_klass == nullptr || operType == nullptr || vlen == nullptr) {\n@@ -1790,0 +1906,1 @@\n+      !operType->is_con() ||\n@@ -1791,1 +1908,1 @@\n-    log_if_needed(\"  ** missing constant: vclass=%s sclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: vclass=%s sclass=%s etype=%s operType=%s vlen=%s\",\n@@ -1795,1 +1912,2 @@\n-                    NodeClassNames[argument(4)->Opcode()]);\n+                    NodeClassNames[argument(4)->Opcode()],\n+                    NodeClassNames[argument(5)->Opcode()]);\n@@ -1828,1 +1946,1 @@\n-  bool is_masked_op = argument(7)->bottom_type() != TypePtr::NULL_PTR;\n+  bool is_masked_op = argument(8)->bottom_type() != TypePtr::NULL_PTR;\n@@ -1859,2 +1977,2 @@\n-  Node* v1 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n-  Node* shuffle = unbox_vector(argument(6), shbox_type, shuffle_bt, num_elem);\n+  Node* v1 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);\n+  Node* shuffle = unbox_vector(argument(7), shbox_type, shuffle_bt, num_elem);\n@@ -1876,1 +1994,1 @@\n-    mask = unbox_vector(argument(7), mbox_type, elem_bt, num_elem);\n+    mask = unbox_vector(argument(8), mbox_type, elem_bt, num_elem);\n@@ -1908,7 +2026,8 @@\n-\/\/    public static\n-\/\/    <V extends Vector<E>,\n-\/\/     M  extends VectorMask<E>,\n-\/\/     E>\n-\/\/    V selectFromOp(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n-\/\/                   int length, V v1, V v2, M m,\n-\/\/                   VectorSelectFromOp<V, M> defaultImpl)\n+\/\/\n+\/\/  <V extends Vector<E>,\n+\/\/   M  extends VectorMask<E>,\n+\/\/   E>\n+\/\/  V selectFromOp(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, int operType,\n+\/\/                 int length, V v1, V v2, M m,\n+\/\/                 VectorSelectFromOp<V, M> defaultImpl)\n+\/\/\n@@ -1919,1 +2038,2 @@\n-  const TypeInt*     vlen          = gvn().type(argument(3))->isa_int();\n+  const TypeInt*     operType      = gvn().type(argument(3))->isa_int();\n+  const TypeInt*     vlen          = gvn().type(argument(4))->isa_int();\n@@ -1921,1 +2041,1 @@\n-  if (vector_klass == nullptr  || elem_klass == nullptr || vlen == nullptr ||\n+  if (vector_klass == nullptr  || elem_klass == nullptr || operType == nullptr || vlen == nullptr ||\n@@ -1924,0 +2044,1 @@\n+      !operType->is_con() ||\n@@ -1925,1 +2046,1 @@\n-    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s operType=%s vlen=%s\",\n@@ -1928,1 +2049,2 @@\n-                    NodeClassNames[argument(3)->Opcode()]);\n+                    NodeClassNames[argument(3)->Opcode()],\n+                    NodeClassNames[argument(4)->Opcode()]);\n@@ -1935,0 +2057,4 @@\n+  if (operType->get_con() != VectorSupport::VECTOR_TYPE_PRIM) {\n+    log_if_needed(\"  ** unhandled operType=%s\", get_opertype_string(operType->get_con()));\n+    return false;\n+  }\n@@ -1965,1 +2091,1 @@\n-  bool is_masked_op = argument(6)->bottom_type() != TypePtr::NULL_PTR;\n+  bool is_masked_op = argument(7)->bottom_type() != TypePtr::NULL_PTR;\n@@ -1990,1 +2116,1 @@\n-  Node* v1 = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);\n+  Node* v1 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n@@ -1992,1 +2118,1 @@\n-  Node* v2 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+  Node* v2 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);\n@@ -1995,1 +2121,1 @@\n-    log_if_needed(\"  ** unbox failed v1=%s\", NodeClassNames[argument(4)->Opcode()]);\n+    log_if_needed(\"  ** unbox failed v1=%s\", NodeClassNames[argument(6)->Opcode()]);\n@@ -2000,1 +2126,1 @@\n-    log_if_needed(\"  ** unbox failed v2=%s\", NodeClassNames[argument(5)->Opcode()]);\n+    log_if_needed(\"  ** unbox failed v2=%s\", NodeClassNames[argument(7)->Opcode()]);\n@@ -2008,1 +2134,1 @@\n-    mask = unbox_vector(argument(6), mbox_type, elem_bt, num_elem);\n+    mask = unbox_vector(argument(7), mbox_type, elem_bt, num_elem);\n@@ -2010,1 +2136,1 @@\n-      log_if_needed(\"  ** unbox failed mask=%s\", NodeClassNames[argument(6)->Opcode()]);\n+      log_if_needed(\"  ** unbox failed mask=%s\", NodeClassNames[argument(8)->Opcode()]);\n@@ -2064,8 +2190,10 @@\n-\/\/  public static\n-\/\/  <V extends Vector<E>,\n-\/\/   M extends VectorMask<E>,\n-\/\/   E>\n-\/\/  V broadcastInt(int opr, Class<? extends V> vectorClass, Class<? extends M> maskClass,\n-\/\/                 Class<E> elementType, int length,\n-\/\/                 V v, int n, M m,\n-\/\/                 VectorBroadcastIntOp<V, M> defaultImpl)\n+\/\/\n+\/\/    <V extends Vector<E>,\n+\/\/     M extends VectorMask<E>,\n+\/\/     E>\n+\/\/    V broadcastInt(int opr,\n+\/\/                   Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, int operType,\n+\/\/                   int length,\n+\/\/                   V v, int n, M m,\n+\/\/                   VectorBroadcastIntOp<V, M> defaultImpl) {\n+\/\/\n@@ -2077,1 +2205,1 @@\n-  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(5))->isa_int();\n@@ -2087,1 +2215,1 @@\n-                    NodeClassNames[argument(4)->Opcode()]);\n+                    NodeClassNames[argument(5)->Opcode()]);\n@@ -2095,1 +2223,1 @@\n-  const Type* vmask_type = gvn().type(argument(7));\n+  const Type* vmask_type = gvn().type(argument(8));\n@@ -2138,1 +2266,1 @@\n-  Node* cnt  = argument(6);\n+  Node* cnt  = argument(7);\n@@ -2164,1 +2292,1 @@\n-  Node* opd1 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+  Node* opd1 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);\n@@ -2187,1 +2315,1 @@\n-    mask = unbox_vector(argument(7), mbox_type, elem_bt, num_elem);\n+    mask = unbox_vector(argument(8), mbox_type, elem_bt, num_elem);\n@@ -2189,1 +2317,1 @@\n-      log_if_needed(\"  ** unbox failed mask=%s\", NodeClassNames[argument(7)->Opcode()]);\n+      log_if_needed(\"  ** unbox failed mask=%s\", NodeClassNames[argument(8)->Opcode()]);\n@@ -2211,3 +2339,3 @@\n-\/\/ public static <VOUT extends VectorPayload,\n-\/\/                 VIN extends VectorPayload,\n-\/\/                   S extends VectorSpecies>\n+\/\/ <VOUT extends VectorPayload,\n+\/\/  VIN extends VectorPayload,\n+\/\/  S extends VectorSpecies>\n@@ -2406,1 +2534,1 @@\n-\/\/  public static\n+\/\/\n@@ -2409,2 +2537,3 @@\n-\/\/  V insert(Class<? extends V> vectorClass, Class<E> elementType, int vlen,\n-\/\/           V vec, int ix, long val,\n+\/\/  V insert(Class<? extends V> vClass, Class<?> cClass, int operType,\n+\/\/           int length,\n+\/\/           V v, int i, long val,\n@@ -2412,0 +2541,1 @@\n+\/\/\n@@ -2415,2 +2545,3 @@\n-  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();\n-  const TypeInt*     idx          = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     operType     = gvn().type(argument(2))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();\n+  const TypeInt*     idx          = gvn().type(argument(5))->isa_int();\n@@ -2418,1 +2549,1 @@\n-  if (vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr || idx == nullptr) {\n+  if (vector_klass == nullptr || elem_klass == nullptr || operType == nullptr || vlen == nullptr || idx == nullptr) {\n@@ -2421,2 +2552,3 @@\n-  if (vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con() || !idx->is_con()) {\n-    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s idx=%s\",\n+  if (vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !operType->is_con() ||\n+      !vlen->is_con() || !idx->is_con()) {\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s operType=%s vlen=%s idx=%s\",\n@@ -2426,1 +2558,2 @@\n-                    NodeClassNames[argument(4)->Opcode()]);\n+                    NodeClassNames[argument(3)->Opcode()],\n+                    NodeClassNames[argument(5)->Opcode()]);\n@@ -2429,0 +2562,6 @@\n+\n+  if (operType->get_con() != VectorSupport::VECTOR_TYPE_PRIM) {\n+    log_if_needed(\"  ** unhandled operType=%s\", get_opertype_string(operType->get_con()));\n+    return false;\n+  }\n+\n@@ -2449,1 +2588,1 @@\n-  Node* opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+  Node* opd = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);\n@@ -2454,1 +2593,1 @@\n-  Node* insert_val = argument(5);\n+  Node* insert_val = argument(6);\n@@ -2489,1 +2628,1 @@\n-\/\/  public static\n+\/\/\n@@ -2492,1 +2631,1 @@\n-\/\/  long extract(Class<? extends VM> vClass, Class<E> eClass,\n+\/\/  long extract(Class<? extends VM> vClass, Class<?> cClass, int operType,\n@@ -2496,0 +2635,1 @@\n+\/\/\n@@ -2499,2 +2639,3 @@\n-  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();\n-  const TypeInt*     idx          = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     operType     = gvn().type(argument(2))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();\n+  const TypeInt*     idx          = gvn().type(argument(5))->isa_int();\n@@ -2504,0 +2645,1 @@\n+      operType     == nullptr || !operType->is_con() ||\n@@ -2506,1 +2648,1 @@\n-    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s operType=%s vlen=%s\",\n@@ -2509,1 +2651,2 @@\n-                    NodeClassNames[argument(2)->Opcode()]);\n+                    NodeClassNames[argument(2)->Opcode()],\n+                    NodeClassNames[argument(3)->Opcode()]);\n@@ -2512,0 +2655,6 @@\n+\n+  if (operType->get_con() != VectorSupport::VECTOR_TYPE_PRIM) {\n+    log_if_needed(\"  ** unhandled operType=%s\", get_opertype_string(operType->get_con()));\n+    return false;\n+  }\n+\n@@ -2532,1 +2681,1 @@\n-    Node* pos = argument(4); \/\/ can be variable\n+    Node* pos = argument(5); \/\/ can be variable\n@@ -2535,1 +2684,1 @@\n-      opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+      opd = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);\n@@ -2543,1 +2692,1 @@\n-      opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+      opd = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);\n@@ -2562,1 +2711,1 @@\n-      log_if_needed(\"  ** missing constant: idx=%s\", NodeClassNames[argument(4)->Opcode()]);\n+      log_if_needed(\"  ** missing constant: idx=%s\", NodeClassNames[argument(5)->Opcode()]);\n@@ -2573,1 +2722,1 @@\n-    opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+    opd = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);\n@@ -2673,1 +2822,1 @@\n-\/\/  public static\n+\/\/\n@@ -2676,1 +2825,1 @@\n-\/\/  V selectFromTwoVectorOp(Class<? extends V> vClass, Class<E> eClass, int length,\n+\/\/  V selectFromTwoVectorOp(Class<? extends V> vClass, Class<?> cClass, int operType, int length,\n@@ -2679,0 +2828,1 @@\n+\/\/\n@@ -2682,1 +2832,2 @@\n-  const TypeInt* vlen = gvn().type(argument(2))->isa_int();\n+  const TypeInt* operType = gvn().type(argument(2))->isa_int();\n+  const TypeInt* vlen = gvn().type(argument(3))->isa_int();\n@@ -2684,3 +2835,4 @@\n-  if (vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr || vector_klass->const_oop() == nullptr ||\n-      elem_klass->const_oop() == nullptr ||!vlen->is_con()) {\n-    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n+  if (vector_klass == nullptr || elem_klass == nullptr || operType == nullptr || vlen == nullptr ||\n+      vector_klass->const_oop() == nullptr ||\n+      elem_klass->const_oop() == nullptr || !operType->is_con() || !vlen->is_con()) {\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s operType=%s vlen=%s\",\n@@ -2689,1 +2841,2 @@\n-                    NodeClassNames[argument(2)->Opcode()]);\n+                    NodeClassNames[argument(2)->Opcode()],\n+                    NodeClassNames[argument(3)->Opcode()]);\n@@ -2693,0 +2846,5 @@\n+  if (operType->get_con() != VectorSupport::VECTOR_TYPE_PRIM) {\n+    log_if_needed(\"  ** unhandled operType=%s\", get_opertype_string(operType->get_con()));\n+    return false;\n+  }\n+\n@@ -2754,1 +2912,1 @@\n-  Node* opd1 = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+  Node* opd1 = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);\n@@ -2757,1 +2915,1 @@\n-                  NodeClassNames[argument(3)->Opcode()]);\n+                  NodeClassNames[argument(4)->Opcode()]);\n@@ -2760,1 +2918,1 @@\n-  Node* opd2 = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);\n+  Node* opd2 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n@@ -2763,1 +2921,1 @@\n-                  NodeClassNames[argument(4)->Opcode()]);\n+                  NodeClassNames[argument(5)->Opcode()]);\n@@ -2766,1 +2924,1 @@\n-  Node* opd3 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+  Node* opd3 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);\n@@ -2769,1 +2927,1 @@\n-                  NodeClassNames[argument(5)->Opcode()]);\n+                  NodeClassNames[argument(6)->Opcode()]);\n@@ -2796,8 +2954,9 @@\n-\/\/ public static\n-\/\/ <V extends Vector<E>,\n-\/\/  M extends VectorMask<E>,\n-\/\/  E>\n-\/\/  V compressExpandOp(int opr,\n-\/\/                    Class<? extends V> vClass, Class<? extends M> mClass, Class<E> eClass,\n-\/\/                    int length, V v, M m,\n-\/\/                    CompressExpandOperation<V, M> defaultImpl)\n+\/\/\n+\/\/  <V extends Vector<E>,\n+\/\/   M extends VectorMask<E>,\n+\/\/   E>\n+\/\/  VectorPayload compressExpandOp(int opr,\n+\/\/                                 Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, int operType,\n+\/\/                                 int length, V v, M m,\n+\/\/                                 CompressExpandOperation<V, M> defaultImpl)\n+\/\/\n@@ -2809,1 +2968,1 @@\n-  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(5))->isa_int();\n@@ -2821,1 +2980,1 @@\n-                    NodeClassNames[argument(4)->Opcode()]);\n+                    NodeClassNames[argument(5)->Opcode()]);\n@@ -2851,1 +3010,1 @@\n-    opd1 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+    opd1 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);\n@@ -2854,1 +3013,1 @@\n-                      NodeClassNames[argument(5)->Opcode()]);\n+                      NodeClassNames[argument(6)->Opcode()]);\n@@ -2860,1 +3019,1 @@\n-  assert(is_vector_mask(mbox_klass), \"argument(6) should be a mask class\");\n+  assert(is_vector_mask(mbox_klass), \"argument(7) should be a mask class\");\n@@ -2863,1 +3022,1 @@\n-  Node* mask = unbox_vector(argument(6), mbox_type, elem_bt, num_elem);\n+  Node* mask = unbox_vector(argument(7), mbox_type, elem_bt, num_elem);\n@@ -2866,1 +3025,1 @@\n-                    NodeClassNames[argument(6)->Opcode()]);\n+                    NodeClassNames[argument(7)->Opcode()]);\n@@ -2881,5 +3040,5 @@\n-\/\/ public static\n-\/\/ <V extends Vector<E>,\n-\/\/  E,\n-\/\/  S extends VectorSpecies<E>>\n-\/\/  V indexVector(Class<? extends V> vClass, Class<E> eClass,\n+\/\/\n+\/\/  <V extends Vector<E>,\n+\/\/   E,\n+\/\/   S extends VectorSpecies<E>>\n+\/\/  V indexVector(Class<? extends V> vClass, Class<?> cClass, int operType,\n@@ -2888,1 +3047,2 @@\n-\/\/                IndexOperation<V, S> defaultImpl)\n+\/\/                IndexOperation<V, S> defaultImpl) {\n+\/\/\n@@ -2892,1 +3052,2 @@\n-  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();\n+  const TypeInt*     operType     = gvn().type(argument(2))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();\n@@ -2896,0 +3057,1 @@\n+      operType     == nullptr || !operType->is_con() ||\n@@ -2897,1 +3059,1 @@\n-    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s operType=%s vlen=%s\",\n@@ -2900,1 +3062,2 @@\n-                    NodeClassNames[argument(2)->Opcode()]);\n+                    NodeClassNames[argument(2)->Opcode()],\n+                    NodeClassNames[argument(3)->Opcode()]);\n@@ -2904,0 +3067,5 @@\n+  if (operType->get_con() != VectorSupport::VECTOR_TYPE_PRIM) {\n+    log_if_needed(\"  ** unhandled operType=%s\", get_opertype_string(operType->get_con()));\n+    return false;\n+  }\n+\n@@ -2927,1 +3095,1 @@\n-  Node* scale = argument(4);\n+  Node* scale = argument(5);\n@@ -2953,1 +3121,1 @@\n-  Node* opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+  Node* opd = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);\n@@ -2956,1 +3124,1 @@\n-                    NodeClassNames[argument(3)->Opcode()]);\n+                    NodeClassNames[argument(4)->Opcode()]);\n@@ -3017,6 +3185,7 @@\n-\/\/ public static\n-\/\/ <E,\n-\/\/  M extends VectorMask<E>>\n-\/\/ M indexPartiallyInUpperRange(Class<? extends M> mClass, Class<E> eClass, int length,\n-\/\/                              long offset, long limit,\n-\/\/                              IndexPartiallyInUpperRangeOperation<E, M> defaultImpl)\n+\/\/\n+\/\/  <E,\n+\/\/   M extends VectorMask<E>>\n+\/\/  M indexPartiallyInUpperRange(Class<? extends M> mClass, Class<?> cClass, int operType,\n+\/\/                               int length, long offset, long limit,\n+\/\/                               IndexPartiallyInUpperRangeOperation<E, M> defaultImpl)\n+\/\/\n@@ -3026,1 +3195,2 @@\n-  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();\n+  const TypeInt*     operType     = gvn().type(argument(2))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();\n@@ -3030,0 +3200,1 @@\n+      operType   == nullptr || !operType->is_con() ||\n@@ -3031,1 +3202,1 @@\n-    log_if_needed(\"  ** missing constant: mclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: mclass=%s etype=%s operType=%s vlen=%s\",\n@@ -3034,1 +3205,2 @@\n-                    NodeClassNames[argument(2)->Opcode()]);\n+                    NodeClassNames[argument(2)->Opcode()],\n+                    NodeClassNames[argument(3)->Opcode()]);\n@@ -3038,0 +3210,5 @@\n+  if (operType->get_con() != VectorSupport::VECTOR_TYPE_PRIM) {\n+    log_if_needed(\"  ** unhandled operType=%s\", get_opertype_string(operType->get_con()));\n+    return false;\n+  }\n+\n@@ -3074,2 +3251,2 @@\n-  Node* offset = argument(3);\n-  Node* limit = argument(5);\n+  Node* offset = argument(4);\n+  Node* limit = argument(6);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":496,"deletions":319,"binary":false,"changes":815,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  Klass* holder = ik->find_field(vmSymbols::ETYPE_name(), vmSymbols::class_signature(), &fd);\n+  Klass* holder = ik->find_field(vmSymbols::CTYPE_name(), vmSymbols::class_signature(), &fd);\n@@ -202,1 +202,1 @@\n-int VectorSupport::vop2ideal(jint id, BasicType bt) {\n+int VectorSupport::vop2ideal(jint id, BasicType bt, int operType) {\n@@ -208,1 +208,5 @@\n-        case T_SHORT:  \/\/ fall-through\n+        case T_SHORT:\n+          if (operType == VECTOR_TYPE_FP16) {\n+            return Op_AddHF;\n+          }\n+          \/\/ fall-through\n@@ -220,1 +224,5 @@\n-        case T_SHORT:  \/\/ fall-through\n+        case T_SHORT:\n+          if (operType == VECTOR_TYPE_FP16) {\n+            return Op_SubHF;\n+          }\n+          \/\/ fall-through\n@@ -232,1 +240,5 @@\n-        case T_SHORT:  \/\/ fall-through\n+        case T_SHORT:\n+          if (operType == VECTOR_TYPE_FP16) {\n+            return Op_MulHF;\n+          }\n+          \/\/ fall-through\n@@ -244,1 +256,5 @@\n-        case T_SHORT:  \/\/ fall-through\n+        case T_SHORT:\n+          if (operType == VECTOR_TYPE_FP16) {\n+            return Op_DivHF;\n+          }\n+          \/\/ fall-through\n@@ -257,0 +273,4 @@\n+          if (operType == VECTOR_TYPE_FP16) {\n+            return Op_MinHF;\n+          }\n+          \/\/ fall-through\n@@ -269,0 +289,4 @@\n+          if (operType == VECTOR_TYPE_FP16) {\n+            return Op_MaxHF;\n+          }\n+          \/\/ fall-through\n@@ -301,0 +325,4 @@\n+          if (operType == VECTOR_TYPE_FP16) {\n+            return 0;\n+          }\n+          \/\/ fall-through\n@@ -313,0 +341,4 @@\n+          if (operType == VECTOR_TYPE_FP16) {\n+            return 0;\n+          }\n+          \/\/ fall-through\n@@ -353,0 +385,1 @@\n+        case T_SHORT:  return Op_SqrtHF;\n@@ -361,0 +394,1 @@\n+        case T_SHORT:  return Op_FmaHF;\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":40,"deletions":6,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -140,0 +140,7 @@\n+  enum {\n+    VECTOR_TYPE_PRIM = 1,\n+    VECTOR_TYPE_FP16 = 2,\n+    VECTOR_TYPE_FP8  = 3,\n+    VECTOR_TYPE_INT8 = 4\n+  };\n+\n@@ -145,1 +152,1 @@\n-  static int vop2ideal(jint vop, BasicType bt);\n+  static int vop2ideal(jint vop, BasicType bt, int operType = VECTOR_TYPE_PRIM);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -329,1 +329,1 @@\n-    V loadFromMemorySegment(Class<? extends V> vmClass, Class<E> e, int length,\n+    V loadFromMemorySegment(Class<? extends V> vmClass, Class<?> c, int operType, int length,\n@@ -337,1 +337,1 @@\n-                    vmClass, e, length,\n+                    vmClass, c, operType, length,\n@@ -351,1 +351,1 @@\n-                                          Class<? extends V> vmClass, Class<E> e, int length,\n+                                          Class<? extends V> vmClass, Class<?> c, int operType, int length,\n@@ -358,1 +358,1 @@\n-            return VectorSupport.load(vmClass, e, length,\n+            return VectorSupport.load(vmClass, c, operType, length,\n@@ -371,1 +371,1 @@\n-    V loadFromMemorySegmentMasked(Class<? extends V> vmClass, Class<M> maskClass, Class<E> e,\n+    V loadFromMemorySegmentMasked(Class<? extends V> vmClass, Class<M> maskClass, Class<?> c, int operType,\n@@ -378,1 +378,1 @@\n-                    vmClass, maskClass, e, length,\n+                    vmClass, maskClass, c, operType, length,\n@@ -393,1 +393,1 @@\n-                                                Class<M> maskClass, Class<E> e, int length,\n+                                                Class<M> maskClass, Class<?> c, int operType, int length,\n@@ -400,1 +400,1 @@\n-            return VectorSupport.loadMasked(vmClass, maskClass, e, length,\n+            return VectorSupport.loadMasked(vmClass, maskClass, c, operType, length,\n@@ -412,1 +412,1 @@\n-    void storeIntoMemorySegment(Class<? extends V> vmClass, Class<E> e, int length,\n+    void storeIntoMemorySegment(Class<? extends V> vmClass, Class<?> c, int operType, int length,\n@@ -420,1 +420,1 @@\n-                    vmClass, e, length,\n+                    vmClass, c, operType, length,\n@@ -434,1 +434,1 @@\n-                                              Class<? extends V> vmClass, Class<E> e, int length,\n+                                              Class<? extends V> vmClass, Class<?> c, int operType, int length,\n@@ -441,1 +441,1 @@\n-            VectorSupport.store(vmClass, e, length,\n+            VectorSupport.store(vmClass, c, operType, length,\n@@ -454,2 +454,2 @@\n-    void storeIntoMemorySegmentMasked(Class<? extends V> vmClass, Class<M> maskClass, Class<E> e,\n-                                      int length, V v, M m,\n+    void storeIntoMemorySegmentMasked(Class<? extends V> vmClass, Class<M> maskClass, Class<?> c,\n+                                      int operType, int length, V v, M m,\n@@ -462,1 +462,1 @@\n-                    vmClass, maskClass, e, length,\n+                    vmClass, maskClass, c, operType, length,\n@@ -477,1 +477,1 @@\n-                                                    Class<E> e, int length, V v, M m,\n+                                                    Class<?> c, int operType, int length, V v, M m,\n@@ -483,1 +483,1 @@\n-            VectorSupport.storeMasked(vmClass, maskClass, e, length,\n+            VectorSupport.storeMasked(vmClass, maskClass, c, operType, length,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -152,0 +152,6 @@\n+    \/\/ Vector operation types.\n+    public static final int VECTOR_TYPE_PRIM = 1;\n+    public static final int VECTOR_TYPE_FP16 = 2;\n+    public static final int VECTOR_TYPE_FP8  = 3;\n+    public static final int VECTOR_TYPE_INT8 = 4;\n+\n@@ -154,6 +160,7 @@\n-        T_FLOAT   = 6,\n-        T_DOUBLE  = 7,\n-        T_BYTE    = 8,\n-        T_SHORT   = 9,\n-        T_INT     = 10,\n-        T_LONG    = 11;\n+        T_HALFFLOAT = 5,\n+        T_FLOAT     = 6,\n+        T_DOUBLE    = 7,\n+        T_BYTE      = 8,\n+        T_SHORT     = 9,\n+        T_INT       = 10,\n+        T_LONG      = 11;\n@@ -206,1 +213,1 @@\n-    VM fromBitsCoerced(Class<? extends VM> vmClass, Class<E> eClass,\n+    VM fromBitsCoerced(Class<? extends VM> vmClass, Class<?> cClass, int operType,\n@@ -224,1 +231,1 @@\n-    M indexPartiallyInUpperRange(Class<? extends M> mClass, Class<E> eClass,\n+    M indexPartiallyInUpperRange(Class<? extends M> mClass, Class<?> cClass, int operType,\n@@ -242,1 +249,1 @@\n-    V indexVector(Class<? extends V> vClass, Class<E> eClass,\n+    V indexVector(Class<? extends V> vClass, Class<?> cClass, int operType,\n@@ -263,1 +270,1 @@\n-                          Class<? extends V> vClass, Class<? extends M> mClass, Class<E> eClass,\n+                          Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, int operType,\n@@ -282,1 +289,1 @@\n-    long extract(Class<? extends VM> vClass, Class<E> eClass,\n+    long extract(Class<? extends VM> vClass, Class<?> cClass, int operType,\n@@ -300,1 +307,1 @@\n-    V insert(Class<? extends V> vClass, Class<E> eClass,\n+    V insert(Class<? extends V> vClass, Class<?> cClass, int operType,\n@@ -321,1 +328,1 @@\n-              Class<? extends V> vClass, Class<? extends M> mClass, Class<E> eClass,\n+              Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, int operType,\n@@ -359,1 +366,1 @@\n-                Class<? extends VM> vmClass, Class<? extends M> mClass, Class<E> eClass,\n+                Class<? extends VM> vmClass, Class<? extends M> mClass, Class<?> cClass, int operType,\n@@ -394,1 +401,1 @@\n-    V selectFromTwoVectorOp(Class<? extends V> vClass, Class<E> eClass, int length,\n+    V selectFromTwoVectorOp(Class<? extends V> vClass, Class<?> cClass, int operType, int length,\n@@ -416,1 +423,1 @@\n-                Class<? extends V> vClass, Class<? extends M> mClass, Class<E> eClass,\n+                Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, int operType,\n@@ -440,1 +447,1 @@\n-    VM load(Class<? extends VM> vmClass, Class<E> eClass,\n+    VM load(Class<? extends VM> vmClass, Class<?> cClass, int operType,\n@@ -465,1 +472,1 @@\n-    V loadMasked(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n+    V loadMasked(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, int operType,\n@@ -491,1 +498,1 @@\n-    V loadWithMap(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n+    V loadWithMap(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, int operType,\n@@ -513,1 +520,1 @@\n-    void store(Class<?> vClass, Class<?> eClass,\n+    void store(Class<?> vClass, Class<?> cClass, int operType,\n@@ -534,1 +541,1 @@\n-    void storeMasked(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n+    void storeMasked(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, int operType,\n@@ -558,1 +565,1 @@\n-    void storeWithMap(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n+    void storeWithMap(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, int operType,\n@@ -576,1 +583,1 @@\n-                 Class<?> mClass, Class<?> eClass,\n+                 Class<?> mClass, Class<?> cClass, int operType,\n@@ -597,1 +604,1 @@\n-              Class<? extends V> vectorClass, Class<M> mClass, Class<E> eClass,\n+              Class<? extends V> vectorClass, Class<M> mClass, Class<?> cClass, int operType,\n@@ -618,1 +625,1 @@\n-    V rearrangeOp(Class<? extends V> vClass, Class<SH> shClass, Class<M> mClass, Class<E> eClass,\n+    V rearrangeOp(Class<? extends V> vClass, Class<SH> shClass, Class<M> mClass, Class<?> cClass, int operType,\n@@ -636,1 +643,1 @@\n-    V selectFromOp(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n+    V selectFromOp(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, int operType,\n@@ -655,1 +662,1 @@\n-    V blend(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n+    V blend(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, int operType,\n@@ -676,1 +683,1 @@\n-                   Class<? extends V> vClass, Class<? extends M> mClass, Class<E> eClass,\n+                   Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, int operType,\n@@ -722,1 +729,1 @@\n-                                   Class<? extends V> vClass, Class<? extends M> mClass, Class<E> eClass,\n+                                   Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, int operType,\n@@ -751,1 +758,1 @@\n-                              Class<? extends M> mClass, Class<?> eClass,\n+                              Class<? extends M> mClass, Class<?> cClass, int operType,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":37,"deletions":30,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-            vsp.maskType(), vsp.elementType(), laneCount,\n+            vsp.maskType(), vsp.carrierType(), vsp.operType(), laneCount,\n@@ -79,1 +79,1 @@\n-            (c, idx, s) -> System.arraycopy(s.getBits(), 0, c, (int) idx, s.length()));\n+            (c, idx, s) -> System.arraycopy(s.getBits(), 0, c, (int)idx, s.length()));\n@@ -305,2 +305,8 @@\n-        VectorMask<E> badMask =\n-            iota.compare(GE, iota.broadcast(indexLimit));\n+        VectorMask<E> badMask = null, badMask2 = null;\n+        if (vectorSpecies().elementType() == Float16.class) {\n+            badMask =\n+                iota.compare(GE, Float.floatToFloat16((float)indexLimit));\n+        } else {\n+            badMask =\n+                iota.compare(GE, iota.broadcast(indexLimit));\n+        }\n@@ -315,2 +321,7 @@\n-            VectorMask<E> badMask2 =\n-                iota.compare(LT, iota.broadcast(firstGoodIndex));\n+            if (vectorSpecies().elementType() == Float16.class) {\n+                badMask2 =\n+                    iota.compare(LT, iota.broadcast(Float.floatToFloat16((float)firstGoodIndex)));\n+            } else {\n+                badMask2 =\n+                    iota.compare(LT, iota.broadcast(firstGoodIndex));\n+            }\n@@ -380,1 +391,6 @@\n-        VectorMask<E> badMask =\n+        VectorMask<E> badMask = null, badMask2 = null;\n+        if (vectorSpecies().elementType() == Float16.class) {\n+            badMask =\n+                iota.compare(GE, Float.floatToFloat16((float)indexLimit));\n+        } else {\n+            badMask =\n@@ -382,0 +398,1 @@\n+        }\n@@ -391,1 +408,5 @@\n-            VectorMask<E> badMask2 =\n+            if (vectorSpecies().elementType() == Float16.class) {\n+                badMask2 =\n+                    iota.compare(LT, iota.broadcast(Float.floatToFloat16((float)firstGoodIndex)));\n+            } else {\n+                badMask2 =\n@@ -393,0 +414,1 @@\n+            }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractMask.java","additions":30,"deletions":8,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -306,0 +306,6 @@\n+    \/*package-private*\/\n+    abstract Class<?> carrierType();\n+\n+    \/*package-private*\/\n+    abstract int operType();\n+\n@@ -323,1 +329,1 @@\n-        Object za = Array.newInstance(elementType(), laneCount);\n+        Object za = Array.newInstance(carrierType(), laneCount);\n@@ -418,12 +424,25 @@\n-        Object ia = Array.newInstance(laneType.elementType,\n-                                      laneCount);\n-        assert(ia.getClass() == laneType.arrayType);\n-        checkValue(laneCount-1);  \/\/ worst case\n-        for (int i = 0; i < laneCount; i++) {\n-            if ((byte)i == i)\n-                Array.setByte(ia, i, (byte)i);\n-            else if ((short)i == i)\n-                Array.setShort(ia, i, (short)i);\n-            else\n-                Array.setInt(ia, i, i);\n-            assert(Array.getDouble(ia, i) == i);\n+        Object ia = null;\n+        if (elementType() == Float16.class) {\n+            ia = Array.newInstance(carrierType(), laneCount);\n+            checkValue(laneCount - 1);  \/\/ worst case\n+            for (int i = 0; i < laneCount; i++) {\n+                \/\/ All the numbers in the range [0 2048] are directly representable in FP16 format without the precision loss.\n+                if (i < 2049) {\n+                    Array.setShort(ia, i, Float.floatToFloat16((float)i));\n+                } else {\n+                    assert(Float16.valueOf(i).intValue() == i);\n+                }\n+            }\n+        } else {\n+            ia = Array.newInstance(laneType.elementType, laneCount);\n+            assert(ia.getClass() == laneType.arrayType);\n+            checkValue(laneCount-1);  \/\/ worst case\n+            for (int i = 0; i < laneCount; i++) {\n+                if ((byte)i == i)\n+                    Array.setByte(ia, i, (byte)i);\n+                else if ((short)i == i)\n+                    Array.setShort(ia, i, (short)i);\n+                else\n+                    Array.setInt(ia, i, i);\n+                assert(Array.getDouble(ia, i) == i);\n+            }\n@@ -627,0 +646,2 @@\n+        case LaneType.SK_HALFFLOAT:\n+            s = HalffloatVector.species(shape); break;\n@@ -639,1 +660,3 @@\n-        assert(s.laneType == laneType) : s + \"!=\" + laneType;\n+        \/\/ FIXME: Remove the additional check for Halffloat laneTypes from following assertion after proper fix.\n+        \/\/ Currently the incoming laneType does not comply with the laneType of Halffloat species.\n+        assert(s.laneType == laneType) || laneType.switchKey == LaneType.SK_HALFFLOAT : s + \"!=\" + laneType;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractSpecies.java","additions":37,"deletions":14,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -296,0 +296,9 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public HalffloatVector reinterpretAsHalffloats() {\n+        return (HalffloatVector) asVectorRaw(LaneType.HALFFLOAT);\n+    }\n+\n@@ -568,0 +577,2 @@\n+        case LaneType.SK_HALFFLOAT:\n+            return HalffloatVector.fromMemorySegment(rsp.check(Float16.class), ms, 0, bo, m.check(Float16.class)).check0(rsp);\n@@ -630,0 +641,7 @@\n+            case LaneType.SK_HALFFLOAT: {\n+                short[] a = new short[rlength];\n+                for (int i = 0; i < limit; i++) {\n+                    a[i] = Float16.float16ToRawShortBits(Float16.valueOf((float) lanes[i]));\n+                }\n+                return HalffloatVector.fromArray(dsp.check(Float16.class), a, 0).check0(dsp);\n+            }\n@@ -680,0 +698,7 @@\n+            case LaneType.SK_HALFFLOAT: {\n+                short[] a = new short[rlength];\n+                for (int i = 0; i < limit; i++) {\n+                    a[i] = Float16.float16ToRawShortBits(Float16.valueOf((float) lanes[i]));\n+                }\n+                return HalffloatVector.fromArray(dsp.check(Float16.class), a, 0).check0(dsp);\n+            }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+    static final Class<Byte> CTYPE = byte.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Byte> ETYPE = byte.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Byte> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Byte> elementType() { return byte.class; }\n+    public final Class<Byte> elementType() { return ETYPE; }\n@@ -544,1 +551,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -579,1 +586,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -592,1 +599,1 @@\n-        static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+        static final Class<Byte> CTYPE = byte.class; \/\/ used by the JVM\n@@ -694,1 +701,1 @@\n-                Byte128Mask.class, byte.class, VLENGTH, offset, limit,\n+                Byte128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -710,2 +717,3 @@\n-                Byte128Vector.class, Byte128Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Byte128Vector.class, Byte128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -722,1 +730,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte128Mask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte128Mask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -732,1 +740,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte128Mask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte128Mask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -742,1 +750,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte128Mask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte128Mask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -752,2 +760,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte128Mask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte128Mask.class, byte.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -759,2 +768,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte128Mask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte128Mask.class, byte.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -766,2 +776,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte128Mask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte128Mask.class, byte.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -776,1 +787,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte128Mask.class, byte.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte128Mask.class, byte.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -786,1 +798,1 @@\n-            return VectorSupport.extract(Byte128Mask.class, byte.class, VLENGTH,\n+            return VectorSupport.extract(Byte128Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -795,3 +807,3 @@\n-            return VectorSupport.test(BT_ne, Byte128Mask.class, byte.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Byte128Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Byte128Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Byte128Mask)m).getBits()));\n@@ -803,3 +815,3 @@\n-            return VectorSupport.test(BT_overflow, Byte128Mask.class, byte.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Byte128Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Byte128Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Byte128Mask)m).getBits()));\n@@ -811,1 +823,1 @@\n-            return VectorSupport.fromBitsCoerced(Byte128Mask.class, byte.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Byte128Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -824,1 +836,1 @@\n-        static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+        static final Class<Byte> CTYPE = byte.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+    static final Class<Byte> CTYPE = byte.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Byte> ETYPE = byte.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Byte> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Byte> elementType() { return byte.class; }\n+    public final Class<Byte> elementType() { return ETYPE; }\n@@ -560,1 +567,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -611,1 +618,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -624,1 +631,1 @@\n-        static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+        static final Class<Byte> CTYPE = byte.class; \/\/ used by the JVM\n@@ -726,1 +733,1 @@\n-                Byte256Mask.class, byte.class, VLENGTH, offset, limit,\n+                Byte256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -742,2 +749,3 @@\n-                Byte256Vector.class, Byte256Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Byte256Vector.class, Byte256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -754,1 +762,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte256Mask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte256Mask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -764,1 +772,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte256Mask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte256Mask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -774,1 +782,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte256Mask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte256Mask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -784,2 +792,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte256Mask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte256Mask.class, byte.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -791,2 +800,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte256Mask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte256Mask.class, byte.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -798,2 +808,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte256Mask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte256Mask.class, byte.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -808,1 +819,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte256Mask.class, byte.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte256Mask.class, byte.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -818,1 +830,1 @@\n-            return VectorSupport.extract(Byte256Mask.class, byte.class, VLENGTH,\n+            return VectorSupport.extract(Byte256Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -827,3 +839,3 @@\n-            return VectorSupport.test(BT_ne, Byte256Mask.class, byte.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Byte256Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Byte256Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Byte256Mask)m).getBits()));\n@@ -835,3 +847,3 @@\n-            return VectorSupport.test(BT_overflow, Byte256Mask.class, byte.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Byte256Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Byte256Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Byte256Mask)m).getBits()));\n@@ -843,1 +855,1 @@\n-            return VectorSupport.fromBitsCoerced(Byte256Mask.class, byte.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Byte256Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -856,1 +868,1 @@\n-        static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+        static final Class<Byte> CTYPE = byte.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+    static final Class<Byte> CTYPE = byte.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Byte> ETYPE = byte.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Byte> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Byte> elementType() { return byte.class; }\n+    public final Class<Byte> elementType() { return ETYPE; }\n@@ -592,1 +599,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -675,1 +682,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -688,1 +695,1 @@\n-        static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+        static final Class<Byte> CTYPE = byte.class; \/\/ used by the JVM\n@@ -790,1 +797,1 @@\n-                Byte512Mask.class, byte.class, VLENGTH, offset, limit,\n+                Byte512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -806,2 +813,3 @@\n-                Byte512Vector.class, Byte512Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Byte512Vector.class, Byte512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -818,1 +826,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte512Mask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte512Mask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -828,1 +836,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte512Mask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte512Mask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -838,1 +846,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte512Mask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte512Mask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -848,2 +856,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte512Mask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte512Mask.class, byte.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -855,2 +864,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte512Mask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte512Mask.class, byte.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -862,2 +872,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte512Mask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte512Mask.class, byte.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -872,1 +883,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte512Mask.class, byte.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte512Mask.class, byte.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -882,1 +894,1 @@\n-            return VectorSupport.extract(Byte512Mask.class, byte.class, VLENGTH,\n+            return VectorSupport.extract(Byte512Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -891,3 +903,3 @@\n-            return VectorSupport.test(BT_ne, Byte512Mask.class, byte.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Byte512Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Byte512Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Byte512Mask)m).getBits()));\n@@ -899,3 +911,3 @@\n-            return VectorSupport.test(BT_overflow, Byte512Mask.class, byte.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Byte512Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Byte512Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Byte512Mask)m).getBits()));\n@@ -907,1 +919,1 @@\n-            return VectorSupport.fromBitsCoerced(Byte512Mask.class, byte.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Byte512Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -920,1 +932,1 @@\n-        static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+        static final Class<Byte> CTYPE = byte.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+    static final Class<Byte> CTYPE = byte.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Byte> ETYPE = byte.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Byte> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Byte> elementType() { return byte.class; }\n+    public final Class<Byte> elementType() { return ETYPE; }\n@@ -536,1 +543,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -563,1 +570,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -576,1 +583,1 @@\n-        static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+        static final Class<Byte> CTYPE = byte.class; \/\/ used by the JVM\n@@ -678,1 +685,1 @@\n-                Byte64Mask.class, byte.class, VLENGTH, offset, limit,\n+                Byte64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -694,2 +701,3 @@\n-                Byte64Vector.class, Byte64Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Byte64Vector.class, Byte64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -706,1 +714,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte64Mask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte64Mask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -716,1 +724,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte64Mask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte64Mask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -726,1 +734,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte64Mask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte64Mask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -736,2 +744,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte64Mask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte64Mask.class, byte.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -743,2 +752,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte64Mask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte64Mask.class, byte.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -750,2 +760,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte64Mask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte64Mask.class, byte.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -760,1 +771,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte64Mask.class, byte.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte64Mask.class, byte.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -770,1 +782,1 @@\n-            return VectorSupport.extract(Byte64Mask.class, byte.class, VLENGTH,\n+            return VectorSupport.extract(Byte64Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -779,3 +791,3 @@\n-            return VectorSupport.test(BT_ne, Byte64Mask.class, byte.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Byte64Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Byte64Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Byte64Mask)m).getBits()));\n@@ -787,3 +799,3 @@\n-            return VectorSupport.test(BT_overflow, Byte64Mask.class, byte.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Byte64Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Byte64Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Byte64Mask)m).getBits()));\n@@ -795,1 +807,1 @@\n-            return VectorSupport.fromBitsCoerced(Byte64Mask.class, byte.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Byte64Mask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -808,1 +820,1 @@\n-        static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+        static final Class<Byte> CTYPE = byte.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+    static final Class<Byte> CTYPE = byte.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Byte> ETYPE = byte.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Byte> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Byte> elementType() { return byte.class; }\n+    public final Class<Byte> elementType() { return ETYPE; }\n@@ -529,1 +536,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -549,1 +556,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -562,1 +569,1 @@\n-        static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+        static final Class<Byte> CTYPE = byte.class; \/\/ used by the JVM\n@@ -664,1 +671,1 @@\n-                ByteMaxMask.class, byte.class, VLENGTH, offset, limit,\n+                ByteMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -680,2 +687,3 @@\n-                ByteMaxVector.class, ByteMaxMask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                ByteMaxVector.class, ByteMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -692,1 +700,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, ByteMaxMask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, ByteMaxMask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -702,1 +710,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, ByteMaxMask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, ByteMaxMask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -712,1 +720,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, ByteMaxMask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, ByteMaxMask.class, null, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -722,2 +730,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, ByteMaxMask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, ByteMaxMask.class, byte.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -729,2 +738,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, ByteMaxMask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, ByteMaxMask.class, byte.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -736,2 +746,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, ByteMaxMask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, ByteMaxMask.class, byte.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -746,1 +757,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, ByteMaxMask.class, byte.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, ByteMaxMask.class, byte.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -756,1 +768,1 @@\n-            return VectorSupport.extract(ByteMaxMask.class, byte.class, VLENGTH,\n+            return VectorSupport.extract(ByteMaxMask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -765,3 +777,3 @@\n-            return VectorSupport.test(BT_ne, ByteMaxMask.class, byte.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((ByteMaxMask)m).getBits()));\n+            return VectorSupport.test(BT_ne, ByteMaxMask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((ByteMaxMask)m).getBits()));\n@@ -773,3 +785,3 @@\n-            return VectorSupport.test(BT_overflow, ByteMaxMask.class, byte.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((ByteMaxMask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, ByteMaxMask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((ByteMaxMask)m).getBits()));\n@@ -781,1 +793,1 @@\n-            return VectorSupport.fromBitsCoerced(ByteMaxMask.class, byte.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(ByteMaxMask.class, byte.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -794,1 +806,1 @@\n-        static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+        static final Class<Byte> CTYPE = byte.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n+\n@@ -576,1 +578,1 @@\n-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), byte.class, species.length(),\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), byte.class, VECTOR_OPER_TYPE, species.length(),\n@@ -698,1 +700,1 @@\n-            opc, getClass(), null, byte.class, length(),\n+            opc, getClass(), null, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -726,1 +728,1 @@\n-            opc, getClass(), maskClass, byte.class, length(),\n+            opc, getClass(), maskClass, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -799,1 +801,1 @@\n-            opc, getClass(), null, byte.class, length(),\n+            opc, getClass(), null, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -850,1 +852,1 @@\n-            opc, getClass(), maskClass, byte.class, length(),\n+            opc, getClass(), maskClass, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -1037,1 +1039,1 @@\n-            opc, getClass(), null, byte.class, length(),\n+            opc, getClass(), null, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -1058,1 +1060,1 @@\n-            opc, getClass(), maskClass, byte.class, length(),\n+            opc, getClass(), maskClass, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -1135,1 +1137,1 @@\n-            opc, getClass(), null, byte.class, length(),\n+            opc, getClass(), null, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -1175,1 +1177,1 @@\n-            opc, getClass(), maskClass, byte.class, length(),\n+            opc, getClass(), maskClass, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -2073,1 +2075,1 @@\n-            opc, getClass(), maskType, byte.class, length(),\n+            opc, getClass(), maskType, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -2095,1 +2097,1 @@\n-            opc, getClass(), maskType, byte.class, length(),\n+            opc, getClass(), maskType, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -2226,1 +2228,1 @@\n-            getClass(), maskType, byte.class, length(),\n+            getClass(), maskType, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -2243,1 +2245,1 @@\n-            getClass(), byte.class, length(),\n+            getClass(), byte.class, VECTOR_OPER_TYPE, length(),\n@@ -2435,1 +2437,1 @@\n-            getClass(), shuffletype, null, byte.class, length(),\n+            getClass(), shuffletype, null, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -2462,1 +2464,1 @@\n-                   getClass(), shuffletype, masktype, byte.class, length(),\n+                   getClass(), shuffletype, masktype, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -2488,1 +2490,1 @@\n-                getClass(), shuffletype, null, byte.class, length(),\n+                getClass(), shuffletype, null, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -2496,1 +2498,1 @@\n-                getClass(), shuffletype, null, byte.class, length(),\n+                getClass(), shuffletype, null, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -2546,1 +2548,1 @@\n-                                                        byte.class, length(), this, m,\n+                                                        byte.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -2565,1 +2567,1 @@\n-                                                        byte.class, length(), this, m,\n+                                                        byte.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -2580,1 +2582,1 @@\n-        return (ByteVector)VectorSupport.selectFromOp(getClass(), null, byte.class,\n+        return (ByteVector)VectorSupport.selectFromOp(getClass(), null, byte.class, VECTOR_OPER_TYPE,\n@@ -2600,1 +2602,1 @@\n-        return (ByteVector)VectorSupport.selectFromOp(getClass(), masktype, byte.class,\n+        return (ByteVector)VectorSupport.selectFromOp(getClass(), masktype, byte.class, VECTOR_OPER_TYPE,\n@@ -2618,1 +2620,1 @@\n-        return VectorSupport.selectFromTwoVectorOp(getClass(), byte.class, length(), this, v1, v2,\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), byte.class, VECTOR_OPER_TYPE, length(), this, v1, v2,\n@@ -2838,1 +2840,1 @@\n-            opc, getClass(), maskClass, byte.class, length(),\n+            opc, getClass(), maskClass, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -2856,1 +2858,1 @@\n-            opc, getClass(), null, byte.class, length(),\n+            opc, getClass(), null, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -2891,0 +2893,1 @@\n+\n@@ -3146,1 +3149,1 @@\n-            vectorType, null, byte.class, vsp.laneCount(),\n+            vectorType, null, byte.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3481,1 +3484,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3635,1 +3638,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3848,1 +3851,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3865,1 +3868,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3921,1 +3924,1 @@\n-            vectorType, maskClass, byte.class, vsp.laneCount(),\n+            vectorType, maskClass, byte.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3938,1 +3941,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3955,1 +3958,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3969,1 +3972,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3985,1 +3988,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4003,1 +4006,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4020,1 +4023,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4039,1 +4042,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4052,1 +4055,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4069,1 +4072,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4250,0 +4253,13 @@\n+        @ForceInline\n+        final Class<?> carrierType() {\n+            return byte.class;\n+        }\n+\n+        @ForceInline\n+        final int operType() {\n+            if (byte.class.equals(Float16.class)) {\n+                return VECTOR_TYPE_FP16;\n+            }\n+            return VECTOR_TYPE_PRIM;\n+        }\n+\n@@ -4282,1 +4298,1 @@\n-                    vectorType, byte.class, laneCount,\n+                    vectorType, byte.class, VECTOR_OPER_TYPE, laneCount,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":56,"deletions":40,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+    static final Class<Double> CTYPE = double.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Double> ETYPE = double.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Double> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Double> elementType() { return double.class; }\n+    public final Class<Double> elementType() { return ETYPE; }\n@@ -519,1 +526,1 @@\n-                     VCLASS, ETYPE, VLENGTH,\n+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -540,1 +547,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -553,1 +560,1 @@\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+        static final Class<Double> CTYPE = double.class; \/\/ used by the JVM\n@@ -655,1 +662,1 @@\n-                Double128Mask.class, double.class, VLENGTH, offset, limit,\n+                Double128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -671,2 +678,3 @@\n-                Double128Vector.class, Double128Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Double128Vector.class, Double128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -683,1 +691,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Double128Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Double128Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -693,1 +701,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Double128Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Double128Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -703,1 +711,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double128Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double128Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -713,2 +721,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double128Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double128Mask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -720,2 +729,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double128Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double128Mask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -727,2 +737,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double128Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double128Mask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -737,1 +748,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double128Mask.class, long.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double128Mask.class, long.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -747,1 +759,1 @@\n-            return VectorSupport.extract(Double128Mask.class, double.class, VLENGTH,\n+            return VectorSupport.extract(Double128Mask.class, double.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -756,3 +768,3 @@\n-            return VectorSupport.test(BT_ne, Double128Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Double128Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Double128Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Double128Mask)m).getBits()));\n@@ -764,3 +776,3 @@\n-            return VectorSupport.test(BT_overflow, Double128Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Double128Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Double128Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Double128Mask)m).getBits()));\n@@ -772,1 +784,1 @@\n-            return VectorSupport.fromBitsCoerced(Double128Mask.class, long.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Double128Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -785,1 +797,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+    static final Class<Double> CTYPE = double.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Double> ETYPE = double.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Double> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Double> elementType() { return double.class; }\n+    public final Class<Double> elementType() { return ETYPE; }\n@@ -521,1 +528,1 @@\n-                     VCLASS, ETYPE, VLENGTH,\n+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -544,1 +551,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -557,1 +564,1 @@\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+        static final Class<Double> CTYPE = double.class; \/\/ used by the JVM\n@@ -659,1 +666,1 @@\n-                Double256Mask.class, double.class, VLENGTH, offset, limit,\n+                Double256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -675,2 +682,3 @@\n-                Double256Vector.class, Double256Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Double256Vector.class, Double256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -687,1 +695,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Double256Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Double256Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -697,1 +705,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Double256Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Double256Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -707,1 +715,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double256Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double256Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -717,2 +725,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double256Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double256Mask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -724,2 +733,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double256Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double256Mask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -731,2 +741,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double256Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double256Mask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -741,1 +752,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double256Mask.class, long.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double256Mask.class, long.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -751,1 +763,1 @@\n-            return VectorSupport.extract(Double256Mask.class, double.class, VLENGTH,\n+            return VectorSupport.extract(Double256Mask.class, double.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -760,3 +772,3 @@\n-            return VectorSupport.test(BT_ne, Double256Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Double256Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Double256Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Double256Mask)m).getBits()));\n@@ -768,3 +780,3 @@\n-            return VectorSupport.test(BT_overflow, Double256Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Double256Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Double256Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Double256Mask)m).getBits()));\n@@ -776,1 +788,1 @@\n-            return VectorSupport.fromBitsCoerced(Double256Mask.class, long.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Double256Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -789,1 +801,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+    static final Class<Double> CTYPE = double.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Double> ETYPE = double.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Double> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Double> elementType() { return double.class; }\n+    public final Class<Double> elementType() { return ETYPE; }\n@@ -525,1 +532,1 @@\n-                     VCLASS, ETYPE, VLENGTH,\n+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -552,1 +559,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -565,1 +572,1 @@\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+        static final Class<Double> CTYPE = double.class; \/\/ used by the JVM\n@@ -667,1 +674,1 @@\n-                Double512Mask.class, double.class, VLENGTH, offset, limit,\n+                Double512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -683,2 +690,3 @@\n-                Double512Vector.class, Double512Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Double512Vector.class, Double512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -695,1 +703,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Double512Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Double512Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -705,1 +713,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Double512Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Double512Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -715,1 +723,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double512Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double512Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -725,2 +733,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double512Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double512Mask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -732,2 +741,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double512Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double512Mask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -739,2 +749,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double512Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double512Mask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -749,1 +760,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double512Mask.class, long.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double512Mask.class, long.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -759,1 +771,1 @@\n-            return VectorSupport.extract(Double512Mask.class, double.class, VLENGTH,\n+            return VectorSupport.extract(Double512Mask.class, double.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -768,3 +780,3 @@\n-            return VectorSupport.test(BT_ne, Double512Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Double512Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Double512Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Double512Mask)m).getBits()));\n@@ -776,3 +788,3 @@\n-            return VectorSupport.test(BT_overflow, Double512Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Double512Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Double512Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Double512Mask)m).getBits()));\n@@ -784,1 +796,1 @@\n-            return VectorSupport.fromBitsCoerced(Double512Mask.class, long.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Double512Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -797,1 +809,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+    static final Class<Double> CTYPE = double.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Double> ETYPE = double.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Double> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Double> elementType() { return double.class; }\n+    public final Class<Double> elementType() { return ETYPE; }\n@@ -518,1 +525,1 @@\n-                     VCLASS, ETYPE, VLENGTH,\n+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -538,1 +545,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -551,1 +558,1 @@\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+        static final Class<Double> CTYPE = double.class; \/\/ used by the JVM\n@@ -653,1 +660,1 @@\n-                Double64Mask.class, double.class, VLENGTH, offset, limit,\n+                Double64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -669,2 +676,3 @@\n-                Double64Vector.class, Double64Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Double64Vector.class, Double64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -681,1 +689,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Double64Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Double64Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -691,1 +699,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Double64Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Double64Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -701,1 +709,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double64Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double64Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -711,2 +719,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double64Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double64Mask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -718,2 +727,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double64Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double64Mask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -725,2 +735,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double64Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double64Mask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -735,1 +746,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double64Mask.class, long.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double64Mask.class, long.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -745,1 +757,1 @@\n-            return VectorSupport.extract(Double64Mask.class, double.class, VLENGTH,\n+            return VectorSupport.extract(Double64Mask.class, double.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -754,3 +766,3 @@\n-            return VectorSupport.test(BT_ne, Double64Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Double64Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Double64Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Double64Mask)m).getBits()));\n@@ -762,3 +774,3 @@\n-            return VectorSupport.test(BT_overflow, Double64Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Double64Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Double64Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Double64Mask)m).getBits()));\n@@ -770,1 +782,1 @@\n-            return VectorSupport.fromBitsCoerced(Double64Mask.class, long.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Double64Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -783,1 +795,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+    static final Class<Double> CTYPE = double.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Double> ETYPE = double.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Double> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Double> elementType() { return double.class; }\n+    public final Class<Double> elementType() { return ETYPE; }\n@@ -517,1 +524,1 @@\n-                     VCLASS, ETYPE, VLENGTH,\n+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -537,1 +544,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -550,1 +557,1 @@\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+        static final Class<Double> CTYPE = double.class; \/\/ used by the JVM\n@@ -652,1 +659,1 @@\n-                DoubleMaxMask.class, double.class, VLENGTH, offset, limit,\n+                DoubleMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -668,2 +675,3 @@\n-                DoubleMaxVector.class, DoubleMaxMask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                DoubleMaxVector.class, DoubleMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -680,1 +688,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, DoubleMaxMask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, DoubleMaxMask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -690,1 +698,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, DoubleMaxMask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, DoubleMaxMask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -700,1 +708,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, DoubleMaxMask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, DoubleMaxMask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -710,2 +718,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, DoubleMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, DoubleMaxMask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -717,2 +726,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, DoubleMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, DoubleMaxMask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -724,2 +734,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, DoubleMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, DoubleMaxMask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -734,1 +745,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, DoubleMaxMask.class, long.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, DoubleMaxMask.class, long.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -744,1 +756,1 @@\n-            return VectorSupport.extract(DoubleMaxMask.class, double.class, VLENGTH,\n+            return VectorSupport.extract(DoubleMaxMask.class, double.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -753,3 +765,3 @@\n-            return VectorSupport.test(BT_ne, DoubleMaxMask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((DoubleMaxMask)m).getBits()));\n+            return VectorSupport.test(BT_ne, DoubleMaxMask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((DoubleMaxMask)m).getBits()));\n@@ -761,3 +773,3 @@\n-            return VectorSupport.test(BT_overflow, DoubleMaxMask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((DoubleMaxMask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, DoubleMaxMask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((DoubleMaxMask)m).getBits()));\n@@ -769,1 +781,1 @@\n-            return VectorSupport.fromBitsCoerced(DoubleMaxMask.class, long.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(DoubleMaxMask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -782,1 +794,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n+\n@@ -565,1 +567,1 @@\n-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), double.class, species.length(),\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), double.class, VECTOR_OPER_TYPE, species.length(),\n@@ -687,1 +689,1 @@\n-            opc, getClass(), null, double.class, length(),\n+            opc, getClass(), null, double.class, VECTOR_OPER_TYPE, length(),\n@@ -715,1 +717,1 @@\n-            opc, getClass(), maskClass, double.class, length(),\n+            opc, getClass(), maskClass, double.class, VECTOR_OPER_TYPE, length(),\n@@ -804,1 +806,1 @@\n-            opc, getClass(), null, double.class, length(),\n+            opc, getClass(), null, double.class, VECTOR_OPER_TYPE, length(),\n@@ -842,1 +844,1 @@\n-            opc, getClass(), maskClass, double.class, length(),\n+            opc, getClass(), maskClass, double.class, VECTOR_OPER_TYPE, length(),\n@@ -1024,1 +1026,1 @@\n-            opc, getClass(), null, double.class, length(),\n+            opc, getClass(), null, double.class, VECTOR_OPER_TYPE, length(),\n@@ -1059,1 +1061,1 @@\n-            opc, getClass(), maskClass, double.class, length(),\n+            opc, getClass(), maskClass, double.class, VECTOR_OPER_TYPE, length(),\n@@ -1931,1 +1933,1 @@\n-            opc, getClass(), maskType, double.class, length(),\n+            opc, getClass(), maskType, double.class, VECTOR_OPER_TYPE, length(),\n@@ -1953,1 +1955,1 @@\n-            opc, getClass(), maskType, double.class, length(),\n+            opc, getClass(), maskType, double.class, VECTOR_OPER_TYPE, length(),\n@@ -2080,1 +2082,1 @@\n-            getClass(), maskType, double.class, length(),\n+            getClass(), maskType, double.class, VECTOR_OPER_TYPE, length(),\n@@ -2097,1 +2099,1 @@\n-            getClass(), double.class, length(),\n+            getClass(), double.class, VECTOR_OPER_TYPE, length(),\n@@ -2289,1 +2291,1 @@\n-            getClass(), shuffletype, null, double.class, length(),\n+            getClass(), shuffletype, null, double.class, VECTOR_OPER_TYPE, length(),\n@@ -2316,1 +2318,1 @@\n-                   getClass(), shuffletype, masktype, double.class, length(),\n+                   getClass(), shuffletype, masktype, double.class, VECTOR_OPER_TYPE, length(),\n@@ -2342,1 +2344,1 @@\n-                getClass(), shuffletype, null, double.class, length(),\n+                getClass(), shuffletype, null, double.class, VECTOR_OPER_TYPE, length(),\n@@ -2350,1 +2352,1 @@\n-                getClass(), shuffletype, null, double.class, length(),\n+                getClass(), shuffletype, null, double.class, VECTOR_OPER_TYPE, length(),\n@@ -2394,1 +2396,1 @@\n-                                                        double.class, length(), this, m,\n+                                                        double.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -2413,1 +2415,1 @@\n-                                                        double.class, length(), this, m,\n+                                                        double.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -2428,1 +2430,1 @@\n-        return (DoubleVector)VectorSupport.selectFromOp(getClass(), null, double.class,\n+        return (DoubleVector)VectorSupport.selectFromOp(getClass(), null, double.class, VECTOR_OPER_TYPE,\n@@ -2448,1 +2450,1 @@\n-        return (DoubleVector)VectorSupport.selectFromOp(getClass(), masktype, double.class,\n+        return (DoubleVector)VectorSupport.selectFromOp(getClass(), masktype, double.class, VECTOR_OPER_TYPE,\n@@ -2466,1 +2468,1 @@\n-        return VectorSupport.selectFromTwoVectorOp(getClass(), double.class, length(), this, v1, v2,\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), double.class, VECTOR_OPER_TYPE, length(), this, v1, v2,\n@@ -2664,1 +2666,1 @@\n-            opc, getClass(), maskClass, double.class, length(),\n+            opc, getClass(), maskClass, double.class, VECTOR_OPER_TYPE, length(),\n@@ -2682,1 +2684,1 @@\n-            opc, getClass(), null, double.class, length(),\n+            opc, getClass(), null, double.class, VECTOR_OPER_TYPE, length(),\n@@ -2705,0 +2707,1 @@\n+\n@@ -2939,1 +2942,1 @@\n-            vectorType, null, double.class, vsp.laneCount(),\n+            vectorType, null, double.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3122,1 +3125,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3230,1 +3233,1 @@\n-            vsp.vectorType(), null, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), null, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3357,1 +3360,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3374,1 +3377,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3425,1 +3428,1 @@\n-            vectorType, maskClass, double.class, vsp.laneCount(),\n+            vectorType, maskClass, double.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3442,1 +3445,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3458,1 +3461,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3476,1 +3479,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3493,1 +3496,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3541,1 +3544,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3560,1 +3563,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3577,1 +3580,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3749,0 +3752,13 @@\n+        @ForceInline\n+        final Class<?> carrierType() {\n+            return double.class;\n+        }\n+\n+        @ForceInline\n+        final int operType() {\n+            if (double.class.equals(Float16.class)) {\n+                return VECTOR_TYPE_FP16;\n+            }\n+            return VECTOR_TYPE_PRIM;\n+        }\n+\n@@ -3781,1 +3797,1 @@\n-                    vectorType, double.class, laneCount,\n+                    vectorType, double.class, VECTOR_OPER_TYPE, laneCount,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":52,"deletions":36,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+    static final Class<Float> CTYPE = float.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Float> ETYPE = float.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Float> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Float> elementType() { return float.class; }\n+    public final Class<Float> elementType() { return ETYPE; }\n@@ -521,1 +528,1 @@\n-                     VCLASS, ETYPE, VLENGTH,\n+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -544,1 +551,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -557,1 +564,1 @@\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+        static final Class<Float> CTYPE = float.class; \/\/ used by the JVM\n@@ -659,1 +666,1 @@\n-                Float128Mask.class, float.class, VLENGTH, offset, limit,\n+                Float128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -675,2 +682,3 @@\n-                Float128Vector.class, Float128Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Float128Vector.class, Float128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -687,1 +695,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Float128Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Float128Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -697,1 +705,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Float128Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Float128Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -707,1 +715,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float128Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float128Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -717,2 +725,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float128Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float128Mask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -724,2 +733,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float128Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float128Mask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -731,2 +741,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float128Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float128Mask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -741,1 +752,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float128Mask.class, int.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float128Mask.class, int.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -751,1 +763,1 @@\n-            return VectorSupport.extract(Float128Mask.class, float.class, VLENGTH,\n+            return VectorSupport.extract(Float128Mask.class, float.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -760,3 +772,3 @@\n-            return VectorSupport.test(BT_ne, Float128Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Float128Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Float128Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Float128Mask)m).getBits()));\n@@ -768,3 +780,3 @@\n-            return VectorSupport.test(BT_overflow, Float128Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Float128Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Float128Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Float128Mask)m).getBits()));\n@@ -776,1 +788,1 @@\n-            return VectorSupport.fromBitsCoerced(Float128Mask.class, int.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Float128Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -789,1 +801,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+    static final Class<Float> CTYPE = float.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Float> ETYPE = float.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Float> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Float> elementType() { return float.class; }\n+    public final Class<Float> elementType() { return ETYPE; }\n@@ -525,1 +532,1 @@\n-                     VCLASS, ETYPE, VLENGTH,\n+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -552,1 +559,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -565,1 +572,1 @@\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+        static final Class<Float> CTYPE = float.class; \/\/ used by the JVM\n@@ -667,1 +674,1 @@\n-                Float256Mask.class, float.class, VLENGTH, offset, limit,\n+                Float256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -683,2 +690,3 @@\n-                Float256Vector.class, Float256Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Float256Vector.class, Float256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -695,1 +703,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Float256Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Float256Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -705,1 +713,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Float256Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Float256Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -715,1 +723,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float256Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float256Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -725,2 +733,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float256Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float256Mask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -732,2 +741,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float256Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float256Mask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -739,2 +749,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float256Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float256Mask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -749,1 +760,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float256Mask.class, int.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float256Mask.class, int.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -759,1 +771,1 @@\n-            return VectorSupport.extract(Float256Mask.class, float.class, VLENGTH,\n+            return VectorSupport.extract(Float256Mask.class, float.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -768,3 +780,3 @@\n-            return VectorSupport.test(BT_ne, Float256Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Float256Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Float256Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Float256Mask)m).getBits()));\n@@ -776,3 +788,3 @@\n-            return VectorSupport.test(BT_overflow, Float256Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Float256Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Float256Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Float256Mask)m).getBits()));\n@@ -784,1 +796,1 @@\n-            return VectorSupport.fromBitsCoerced(Float256Mask.class, int.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Float256Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -797,1 +809,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+    static final Class<Float> CTYPE = float.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Float> ETYPE = float.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Float> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Float> elementType() { return float.class; }\n+    public final Class<Float> elementType() { return ETYPE; }\n@@ -533,1 +540,1 @@\n-                     VCLASS, ETYPE, VLENGTH,\n+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -568,1 +575,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -581,1 +588,1 @@\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+        static final Class<Float> CTYPE = float.class; \/\/ used by the JVM\n@@ -683,1 +690,1 @@\n-                Float512Mask.class, float.class, VLENGTH, offset, limit,\n+                Float512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -699,2 +706,3 @@\n-                Float512Vector.class, Float512Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Float512Vector.class, Float512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -711,1 +719,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Float512Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Float512Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -721,1 +729,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Float512Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Float512Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -731,1 +739,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float512Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float512Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -741,2 +749,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float512Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float512Mask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -748,2 +757,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float512Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float512Mask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -755,2 +765,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float512Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float512Mask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -765,1 +776,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float512Mask.class, int.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float512Mask.class, int.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -775,1 +787,1 @@\n-            return VectorSupport.extract(Float512Mask.class, float.class, VLENGTH,\n+            return VectorSupport.extract(Float512Mask.class, float.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -784,3 +796,3 @@\n-            return VectorSupport.test(BT_ne, Float512Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Float512Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Float512Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Float512Mask)m).getBits()));\n@@ -792,3 +804,3 @@\n-            return VectorSupport.test(BT_overflow, Float512Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Float512Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Float512Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Float512Mask)m).getBits()));\n@@ -800,1 +812,1 @@\n-            return VectorSupport.fromBitsCoerced(Float512Mask.class, int.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Float512Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -813,1 +825,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+    static final Class<Float> CTYPE = float.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Float> ETYPE = float.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Float> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Float> elementType() { return float.class; }\n+    public final Class<Float> elementType() { return ETYPE; }\n@@ -519,1 +526,1 @@\n-                     VCLASS, ETYPE, VLENGTH,\n+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -540,1 +547,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -553,1 +560,1 @@\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+        static final Class<Float> CTYPE = float.class; \/\/ used by the JVM\n@@ -655,1 +662,1 @@\n-                Float64Mask.class, float.class, VLENGTH, offset, limit,\n+                Float64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -671,2 +678,3 @@\n-                Float64Vector.class, Float64Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Float64Vector.class, Float64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -683,1 +691,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Float64Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Float64Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -693,1 +701,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Float64Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Float64Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -703,1 +711,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float64Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float64Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -713,2 +721,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float64Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float64Mask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -720,2 +729,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float64Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float64Mask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -727,2 +737,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float64Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float64Mask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -737,1 +748,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float64Mask.class, int.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float64Mask.class, int.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -747,1 +759,1 @@\n-            return VectorSupport.extract(Float64Mask.class, float.class, VLENGTH,\n+            return VectorSupport.extract(Float64Mask.class, float.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -756,3 +768,3 @@\n-            return VectorSupport.test(BT_ne, Float64Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Float64Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Float64Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Float64Mask)m).getBits()));\n@@ -764,3 +776,3 @@\n-            return VectorSupport.test(BT_overflow, Float64Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Float64Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Float64Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Float64Mask)m).getBits()));\n@@ -772,1 +784,1 @@\n-            return VectorSupport.fromBitsCoerced(Float64Mask.class, int.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Float64Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -785,1 +797,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+    static final Class<Float> CTYPE = float.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Float> ETYPE = float.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Float> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Float> elementType() { return float.class; }\n+    public final Class<Float> elementType() { return ETYPE; }\n@@ -517,1 +524,1 @@\n-                     VCLASS, ETYPE, VLENGTH,\n+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -537,1 +544,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -550,1 +557,1 @@\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+        static final Class<Float> CTYPE = float.class; \/\/ used by the JVM\n@@ -652,1 +659,1 @@\n-                FloatMaxMask.class, float.class, VLENGTH, offset, limit,\n+                FloatMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -668,2 +675,3 @@\n-                FloatMaxVector.class, FloatMaxMask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                FloatMaxVector.class, FloatMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -680,1 +688,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, FloatMaxMask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, FloatMaxMask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -690,1 +698,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, FloatMaxMask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, FloatMaxMask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -700,1 +708,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, FloatMaxMask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, FloatMaxMask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -710,2 +718,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, FloatMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, FloatMaxMask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -717,2 +726,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, FloatMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, FloatMaxMask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -724,2 +734,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, FloatMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, FloatMaxMask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -734,1 +745,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, FloatMaxMask.class, int.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, FloatMaxMask.class, int.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -744,1 +756,1 @@\n-            return VectorSupport.extract(FloatMaxMask.class, float.class, VLENGTH,\n+            return VectorSupport.extract(FloatMaxMask.class, float.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -753,3 +765,3 @@\n-            return VectorSupport.test(BT_ne, FloatMaxMask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((FloatMaxMask)m).getBits()));\n+            return VectorSupport.test(BT_ne, FloatMaxMask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((FloatMaxMask)m).getBits()));\n@@ -761,3 +773,3 @@\n-            return VectorSupport.test(BT_overflow, FloatMaxMask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((FloatMaxMask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, FloatMaxMask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((FloatMaxMask)m).getBits()));\n@@ -769,1 +781,1 @@\n-            return VectorSupport.fromBitsCoerced(FloatMaxMask.class, int.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(FloatMaxMask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -782,1 +794,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n+\n@@ -565,1 +567,1 @@\n-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), float.class, species.length(),\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), float.class, VECTOR_OPER_TYPE, species.length(),\n@@ -687,1 +689,1 @@\n-            opc, getClass(), null, float.class, length(),\n+            opc, getClass(), null, float.class, VECTOR_OPER_TYPE, length(),\n@@ -715,1 +717,1 @@\n-            opc, getClass(), maskClass, float.class, length(),\n+            opc, getClass(), maskClass, float.class, VECTOR_OPER_TYPE, length(),\n@@ -804,1 +806,1 @@\n-            opc, getClass(), null, float.class, length(),\n+            opc, getClass(), null, float.class, VECTOR_OPER_TYPE, length(),\n@@ -842,1 +844,1 @@\n-            opc, getClass(), maskClass, float.class, length(),\n+            opc, getClass(), maskClass, float.class, VECTOR_OPER_TYPE, length(),\n@@ -1024,1 +1026,1 @@\n-            opc, getClass(), null, float.class, length(),\n+            opc, getClass(), null, float.class, VECTOR_OPER_TYPE, length(),\n@@ -1059,1 +1061,1 @@\n-            opc, getClass(), maskClass, float.class, length(),\n+            opc, getClass(), maskClass, float.class, VECTOR_OPER_TYPE, length(),\n@@ -1943,1 +1945,1 @@\n-            opc, getClass(), maskType, float.class, length(),\n+            opc, getClass(), maskType, float.class, VECTOR_OPER_TYPE, length(),\n@@ -1965,1 +1967,1 @@\n-            opc, getClass(), maskType, float.class, length(),\n+            opc, getClass(), maskType, float.class, VECTOR_OPER_TYPE, length(),\n@@ -2092,1 +2094,1 @@\n-            getClass(), maskType, float.class, length(),\n+            getClass(), maskType, float.class, VECTOR_OPER_TYPE, length(),\n@@ -2109,1 +2111,1 @@\n-            getClass(), float.class, length(),\n+            getClass(), float.class, VECTOR_OPER_TYPE, length(),\n@@ -2301,1 +2303,1 @@\n-            getClass(), shuffletype, null, float.class, length(),\n+            getClass(), shuffletype, null, float.class, VECTOR_OPER_TYPE, length(),\n@@ -2328,1 +2330,1 @@\n-                   getClass(), shuffletype, masktype, float.class, length(),\n+                   getClass(), shuffletype, masktype, float.class, VECTOR_OPER_TYPE, length(),\n@@ -2354,1 +2356,1 @@\n-                getClass(), shuffletype, null, float.class, length(),\n+                getClass(), shuffletype, null, float.class, VECTOR_OPER_TYPE, length(),\n@@ -2362,1 +2364,1 @@\n-                getClass(), shuffletype, null, float.class, length(),\n+                getClass(), shuffletype, null, float.class, VECTOR_OPER_TYPE, length(),\n@@ -2406,1 +2408,1 @@\n-                                                        float.class, length(), this, m,\n+                                                        float.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -2425,1 +2427,1 @@\n-                                                        float.class, length(), this, m,\n+                                                        float.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -2440,1 +2442,1 @@\n-        return (FloatVector)VectorSupport.selectFromOp(getClass(), null, float.class,\n+        return (FloatVector)VectorSupport.selectFromOp(getClass(), null, float.class, VECTOR_OPER_TYPE,\n@@ -2460,1 +2462,1 @@\n-        return (FloatVector)VectorSupport.selectFromOp(getClass(), masktype, float.class,\n+        return (FloatVector)VectorSupport.selectFromOp(getClass(), masktype, float.class, VECTOR_OPER_TYPE,\n@@ -2478,1 +2480,1 @@\n-        return VectorSupport.selectFromTwoVectorOp(getClass(), float.class, length(), this, v1, v2,\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), float.class, VECTOR_OPER_TYPE, length(), this, v1, v2,\n@@ -2684,1 +2686,1 @@\n-            opc, getClass(), maskClass, float.class, length(),\n+            opc, getClass(), maskClass, float.class, VECTOR_OPER_TYPE, length(),\n@@ -2702,1 +2704,1 @@\n-            opc, getClass(), null, float.class, length(),\n+            opc, getClass(), null, float.class, VECTOR_OPER_TYPE, length(),\n@@ -2725,0 +2727,1 @@\n+\n@@ -2945,1 +2948,1 @@\n-            vectorType, null, float.class, vsp.laneCount(),\n+            vectorType, null, float.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3128,1 +3131,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3217,1 +3220,1 @@\n-            vsp.vectorType(), null, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), null, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3344,1 +3347,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3361,1 +3364,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3394,1 +3397,1 @@\n-            vectorType, maskClass, float.class, vsp.laneCount(),\n+            vectorType, maskClass, float.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3411,1 +3414,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3427,1 +3430,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3445,1 +3448,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3462,1 +3465,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3491,1 +3494,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3510,1 +3513,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3527,1 +3530,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3699,0 +3702,13 @@\n+        @ForceInline\n+        final Class<?> carrierType() {\n+            return float.class;\n+        }\n+\n+        @ForceInline\n+        final int operType() {\n+            if (float.class.equals(Float16.class)) {\n+                return VECTOR_TYPE_FP16;\n+            }\n+            return VECTOR_TYPE_PRIM;\n+        }\n+\n@@ -3731,1 +3747,1 @@\n-                    vectorType, float.class, laneCount,\n+                    vectorType, float.class, VECTOR_OPER_TYPE, laneCount,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":52,"deletions":36,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -0,0 +1,1042 @@\n+\/*\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+final class Halffloat128Vector extends HalffloatVector {\n+    static final HalffloatSpecies VSPECIES =\n+        (HalffloatSpecies) HalffloatVector.SPECIES_128;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<Halffloat128Vector> VCLASS = Halffloat128Vector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Short> CTYPE = short.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Float16> ETYPE = Float16.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_FP16;\n+\n+    Halffloat128Vector(short[] v) {\n+        super(v);\n+    }\n+\n+    \/\/ For compatibility as Halffloat128Vector::new,\n+    \/\/ stored into species.vectorFactory.\n+    Halffloat128Vector(Object v) {\n+        this((short[]) v);\n+    }\n+\n+    static final Halffloat128Vector ZERO = new Halffloat128Vector(new short[VLENGTH]);\n+    static final Halffloat128Vector IOTA = new Halffloat128Vector(VSPECIES.iotaArray());\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVector();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public HalffloatSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    final Class<Short> carrierType() { return CTYPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Float16> elementType() { return ETYPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Float16.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final @Override\n+    short[] vec() {\n+        return (short[])getPayload();\n+    }\n+\n+    \/\/ Virtualized constructors\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Vector broadcast(short e) {\n+        return (Halffloat128Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Vector broadcast(long e) {\n+        return (Halffloat128Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat128Mask maskFromArray(boolean[] bits) {\n+        return new Halffloat128Mask(bits);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat128Shuffle iotaShuffle() { return Halffloat128Shuffle.IOTA; }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat128Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+        return (Halffloat128Shuffle) iotaShuffleTemplate((short) start, (short) step, wrap);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat128Shuffle shuffleFromArray(int[] indices, int i) { return new Halffloat128Shuffle(indices, i); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat128Shuffle shuffleFromOp(IntUnaryOperator fn) { return new Halffloat128Shuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector vectorFactory(short[] vec) {\n+        return new Halffloat128Vector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Byte128Vector asByteVectorRaw() {\n+        return (Byte128Vector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector uOp(FUnOp f) {\n+        return (Halffloat128Vector) super.uOpTemplate(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector uOp(VectorMask<Float16> m, FUnOp f) {\n+        return (Halffloat128Vector)\n+            super.uOpTemplate((Halffloat128Mask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector bOp(Vector<Float16> v, FBinOp f) {\n+        return (Halffloat128Vector) super.bOpTemplate((Halffloat128Vector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector bOp(Vector<Float16> v,\n+                     VectorMask<Float16> m, FBinOp f) {\n+        return (Halffloat128Vector)\n+            super.bOpTemplate((Halffloat128Vector)v, (Halffloat128Mask)m,\n+                              f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector tOp(Vector<Float16> v1, Vector<Float16> v2, FTriOp f) {\n+        return (Halffloat128Vector)\n+            super.tOpTemplate((Halffloat128Vector)v1, (Halffloat128Vector)v2,\n+                              f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector tOp(Vector<Float16> v1, Vector<Float16> v2,\n+                     VectorMask<Float16> m, FTriOp f) {\n+        return (Halffloat128Vector)\n+            super.tOpTemplate((Halffloat128Vector)v1, (Halffloat128Vector)v2,\n+                              (Halffloat128Mask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    short rOp(short v, VectorMask<Float16> m, FBinOp f) {\n+        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Float16,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector lanewise(Unary op) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector lanewise(Unary op, VectorMask<Float16> m) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op, Halffloat128Mask.class, (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector lanewise(Binary op, Vector<Float16> v) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector lanewise(Binary op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op, Halffloat128Mask.class, v, (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat128Vector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat128Vector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2, VectorMask<Float16> m) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op, Halffloat128Mask.class, v1, v2, (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat128Vector addIndex(int scale) {\n+        return (Halffloat128Vector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Float16> m) {\n+        return super.reduceLanesTemplate(op, Halffloat128Mask.class, (Halffloat128Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Float16> m) {\n+        return (long) super.reduceLanesTemplate(op, Halffloat128Mask.class, (Halffloat128Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Shuffle toShuffle() {\n+        return (Halffloat128Shuffle) toShuffle(vspecies(), false);\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask test(Test op) {\n+        return super.testTemplate(Halffloat128Mask.class, op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask test(Test op, VectorMask<Float16> m) {\n+        return super.testTemplate(Halffloat128Mask.class, op, (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask compare(Comparison op, Vector<Float16> v) {\n+        return super.compareTemplate(Halffloat128Mask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask compare(Comparison op, short s) {\n+        return super.compareTemplate(Halffloat128Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask compare(Comparison op, long s) {\n+        return super.compareTemplate(Halffloat128Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask compare(Comparison op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return super.compareTemplate(Halffloat128Mask.class, op, v, (Halffloat128Mask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector blend(Vector<Float16> v, VectorMask<Float16> m) {\n+        return (Halffloat128Vector)\n+            super.blendTemplate(Halffloat128Mask.class,\n+                                (Halffloat128Vector) v,\n+                                (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector slice(int origin, Vector<Float16> v) {\n+        return (Halffloat128Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector slice(int origin) {\n+        return (Halffloat128Vector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector unslice(int origin, Vector<Float16> w, int part) {\n+        return (Halffloat128Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector unslice(int origin, Vector<Float16> w, int part, VectorMask<Float16> m) {\n+        return (Halffloat128Vector)\n+            super.unsliceTemplate(Halffloat128Mask.class,\n+                                  origin, w, part,\n+                                  (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector unslice(int origin) {\n+        return (Halffloat128Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector rearrange(VectorShuffle<Float16> s) {\n+        return (Halffloat128Vector)\n+            super.rearrangeTemplate(Halffloat128Shuffle.class,\n+                                    (Halffloat128Shuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector rearrange(VectorShuffle<Float16> shuffle,\n+                                  VectorMask<Float16> m) {\n+        return (Halffloat128Vector)\n+            super.rearrangeTemplate(Halffloat128Shuffle.class,\n+                                    Halffloat128Mask.class,\n+                                    (Halffloat128Shuffle) shuffle,\n+                                    (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector rearrange(VectorShuffle<Float16> s,\n+                                  Vector<Float16> v) {\n+        return (Halffloat128Vector)\n+            super.rearrangeTemplate(Halffloat128Shuffle.class,\n+                                    (Halffloat128Shuffle) s,\n+                                    (Halffloat128Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector compress(VectorMask<Float16> m) {\n+        return (Halffloat128Vector)\n+            super.compressTemplate(Halffloat128Mask.class,\n+                                   (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector expand(VectorMask<Float16> m) {\n+        return (Halffloat128Vector)\n+            super.expandTemplate(Halffloat128Mask.class,\n+                                   (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector selectFrom(Vector<Float16> v) {\n+        return (Halffloat128Vector)\n+            super.selectFromTemplate((Halffloat128Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector selectFrom(Vector<Float16> v,\n+                                   VectorMask<Float16> m) {\n+        return (Halffloat128Vector)\n+            super.selectFromTemplate((Halffloat128Vector) v,\n+                                     Halffloat128Mask.class, (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector selectFrom(Vector<Float16> v1,\n+                                   Vector<Float16> v2) {\n+        return (Halffloat128Vector)\n+            super.selectFromTemplate((Halffloat128Vector) v1, (Halffloat128Vector) v2);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public short lane(int i) {\n+        short bits;\n+        switch(i) {\n+            case 0: bits = laneHelper(0); break;\n+            case 1: bits = laneHelper(1); break;\n+            case 2: bits = laneHelper(2); break;\n+            case 3: bits = laneHelper(3); break;\n+            case 4: bits = laneHelper(4); break;\n+            case 5: bits = laneHelper(5); break;\n+            case 6: bits = laneHelper(6); break;\n+            case 7: bits = laneHelper(7); break;\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return bits;\n+    }\n+\n+    @ForceInline\n+    public short laneHelper(int i) {\n+        return (short) VectorSupport.extract(\n+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                     short[] vecarr = vec.vec();\n+                     return vecarr[ix];\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public Halffloat128Vector withLane(int i, short e) {\n+        switch(i) {\n+            case 0: return withLaneHelper(0, e);\n+            case 1: return withLaneHelper(1, e);\n+            case 2: return withLaneHelper(2, e);\n+            case 3: return withLaneHelper(3, e);\n+            case 4: return withLaneHelper(4, e);\n+            case 5: return withLaneHelper(5, e);\n+            case 6: return withLaneHelper(6, e);\n+            case 7: return withLaneHelper(7, e);\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Halffloat128Vector withLaneHelper(int i, short e) {\n+        return VectorSupport.insert(\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                this, i, (long)e,\n+                                (v, ix, bits) -> {\n+                                    short[] res = v.vec().clone();\n+                                    res[ix] = (short)bits;\n+                                    return v.vectorFactory(res);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final class Halffloat128Mask extends AbstractMask<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n+\n+        Halffloat128Mask(boolean[] bits) {\n+            this(bits, 0);\n+        }\n+\n+        Halffloat128Mask(boolean[] bits, int offset) {\n+            super(prepare(bits, offset));\n+        }\n+\n+        Halffloat128Mask(boolean val) {\n+            super(prepare(val));\n+        }\n+\n+        private static boolean[] prepare(boolean[] bits, int offset) {\n+            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n+            for (int i = 0; i < newBits.length; i++) {\n+                newBits[i] = bits[offset + i];\n+            }\n+            return newBits;\n+        }\n+\n+        private static boolean[] prepare(boolean val) {\n+            boolean[] bits = new boolean[VSPECIES.laneCount()];\n+            Arrays.fill(bits, val);\n+            return bits;\n+        }\n+\n+        @ForceInline\n+        final @Override\n+        public HalffloatSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        boolean[] getBits() {\n+            return (boolean[])getPayload();\n+        }\n+\n+        @Override\n+        Halffloat128Mask uOp(MUnOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i]);\n+            }\n+            return new Halffloat128Mask(res);\n+        }\n+\n+        @Override\n+        Halffloat128Mask bOp(VectorMask<Float16> m, MBinOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            boolean[] mbits = ((Halffloat128Mask)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i], mbits[i]);\n+            }\n+            return new Halffloat128Mask(res);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        Halffloat128Vector toVector() {\n+            return (Halffloat128Vector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+            boolean[] maskArray = toArray();\n+            return  dsp.maskFactory(maskArray).check(dsp);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), ETYPE, VLENGTH,\n+                species.maskType(), species.elementType(), VLENGTH,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.toArray()).check(s));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Halffloat128Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Halffloat128Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Halffloat128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n+                (o, l) -> (Halffloat128Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Mask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Mask compress() {\n+            return (Halffloat128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Halffloat128Vector.class, Halffloat128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                Float16.float16ToShortBits(Float16.valueOf(m1.trueCount()))));\n+        }\n+\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Mask and(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat128Mask m = (Halffloat128Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat128Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Mask or(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat128Mask m = (Halffloat128Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat128Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Mask xor(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat128Mask m = (Halffloat128Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat128Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat128Mask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat128Mask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat128Mask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat128Mask.class, short.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                      (m) -> toLongHelper(m.getBits()));\n+        }\n+\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Halffloat128Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, Halffloat128Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Halffloat128Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, Halffloat128Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Halffloat128Mask)m).getBits()));\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static Halffloat128Mask maskAll(boolean bit) {\n+            return VectorSupport.fromBitsCoerced(Halffloat128Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final Halffloat128Mask  TRUE_MASK = new Halffloat128Mask(true);\n+        private static final Halffloat128Mask FALSE_MASK = new Halffloat128Mask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final class Halffloat128Shuffle extends AbstractShuffle<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n+\n+        Halffloat128Shuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n+        }\n+\n+        Halffloat128Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n+        }\n+\n+        Halffloat128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n+        }\n+\n+        short[] indices() {\n+            return (short[])getPayload();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final Halffloat128Shuffle IOTA = new Halffloat128Shuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Vector toVector() {\n+            return (Halffloat128Vector) toBitsVector().castShape(vspecies(), 0);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        Short128Vector toBitsVector() {\n+            return (Short128Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Short128Vector toBitsVector0() {\n+            return ((Short128Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_128;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoMemorySegment(MemorySegment ms, long offset, ByteOrder bo) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_128;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoMemorySegment(ms, offset, bo);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoMemorySegment(ms, offset + species.vectorByteSize(), bo);\n+         }\n+\n+        @Override\n+        @ForceInline\n+        public final Halffloat128Mask laneIsValid() {\n+            return (Halffloat128Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Halffloat128Shuffle rearrange(VectorShuffle<Float16> shuffle) {\n+            Halffloat128Shuffle concreteShuffle = (Halffloat128Shuffle) shuffle;\n+            return (Halffloat128Shuffle) toBitsVector().rearrange(concreteShuffle.cast(ShortVector.SPECIES_128))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Halffloat128Shuffle wrapIndexes() {\n+            Short128Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Short128Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Short128Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Halffloat128Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromArray0Template(Halffloat128Mask.class, a, offset, (Halffloat128Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float16> m) {\n+        return super.fromArray0Template(Halffloat128Mask.class, a, offset, indexMap, mapOffset, (Halffloat128Mask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromCharArray0Template(Halffloat128Mask.class, a, offset, (Halffloat128Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromMemorySegment0Template(Halffloat128Mask.class, ms, offset, (Halffloat128Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset, VectorMask<Float16> m) {\n+        super.intoArray0Template(Halffloat128Mask.class, a, offset, (Halffloat128Mask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m) {\n+        super.intoMemorySegment0Template(Halffloat128Mask.class, ms, offset, (Halffloat128Mask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<Float16> m) {\n+        super.intoCharArray0Template(Halffloat128Mask.class, a, offset, (Halffloat128Mask) m);\n+    }\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat128Vector.java","additions":1042,"deletions":0,"binary":false,"changes":1042,"status":"added"},{"patch":"@@ -0,0 +1,1058 @@\n+\/*\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+final class Halffloat256Vector extends HalffloatVector {\n+    static final HalffloatSpecies VSPECIES =\n+        (HalffloatSpecies) HalffloatVector.SPECIES_256;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<Halffloat256Vector> VCLASS = Halffloat256Vector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Short> CTYPE = short.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Float16> ETYPE = Float16.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_FP16;\n+\n+    Halffloat256Vector(short[] v) {\n+        super(v);\n+    }\n+\n+    \/\/ For compatibility as Halffloat256Vector::new,\n+    \/\/ stored into species.vectorFactory.\n+    Halffloat256Vector(Object v) {\n+        this((short[]) v);\n+    }\n+\n+    static final Halffloat256Vector ZERO = new Halffloat256Vector(new short[VLENGTH]);\n+    static final Halffloat256Vector IOTA = new Halffloat256Vector(VSPECIES.iotaArray());\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVector();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public HalffloatSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    final Class<Short> carrierType() { return CTYPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Float16> elementType() { return ETYPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Float16.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final @Override\n+    short[] vec() {\n+        return (short[])getPayload();\n+    }\n+\n+    \/\/ Virtualized constructors\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Vector broadcast(short e) {\n+        return (Halffloat256Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Vector broadcast(long e) {\n+        return (Halffloat256Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat256Mask maskFromArray(boolean[] bits) {\n+        return new Halffloat256Mask(bits);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat256Shuffle iotaShuffle() { return Halffloat256Shuffle.IOTA; }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat256Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+        return (Halffloat256Shuffle) iotaShuffleTemplate((short) start, (short) step, wrap);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat256Shuffle shuffleFromArray(int[] indices, int i) { return new Halffloat256Shuffle(indices, i); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat256Shuffle shuffleFromOp(IntUnaryOperator fn) { return new Halffloat256Shuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector vectorFactory(short[] vec) {\n+        return new Halffloat256Vector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Byte256Vector asByteVectorRaw() {\n+        return (Byte256Vector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector uOp(FUnOp f) {\n+        return (Halffloat256Vector) super.uOpTemplate(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector uOp(VectorMask<Float16> m, FUnOp f) {\n+        return (Halffloat256Vector)\n+            super.uOpTemplate((Halffloat256Mask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector bOp(Vector<Float16> v, FBinOp f) {\n+        return (Halffloat256Vector) super.bOpTemplate((Halffloat256Vector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector bOp(Vector<Float16> v,\n+                     VectorMask<Float16> m, FBinOp f) {\n+        return (Halffloat256Vector)\n+            super.bOpTemplate((Halffloat256Vector)v, (Halffloat256Mask)m,\n+                              f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector tOp(Vector<Float16> v1, Vector<Float16> v2, FTriOp f) {\n+        return (Halffloat256Vector)\n+            super.tOpTemplate((Halffloat256Vector)v1, (Halffloat256Vector)v2,\n+                              f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector tOp(Vector<Float16> v1, Vector<Float16> v2,\n+                     VectorMask<Float16> m, FTriOp f) {\n+        return (Halffloat256Vector)\n+            super.tOpTemplate((Halffloat256Vector)v1, (Halffloat256Vector)v2,\n+                              (Halffloat256Mask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    short rOp(short v, VectorMask<Float16> m, FBinOp f) {\n+        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Float16,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector lanewise(Unary op) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector lanewise(Unary op, VectorMask<Float16> m) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op, Halffloat256Mask.class, (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector lanewise(Binary op, Vector<Float16> v) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector lanewise(Binary op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op, Halffloat256Mask.class, v, (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat256Vector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat256Vector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2, VectorMask<Float16> m) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op, Halffloat256Mask.class, v1, v2, (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat256Vector addIndex(int scale) {\n+        return (Halffloat256Vector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Float16> m) {\n+        return super.reduceLanesTemplate(op, Halffloat256Mask.class, (Halffloat256Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Float16> m) {\n+        return (long) super.reduceLanesTemplate(op, Halffloat256Mask.class, (Halffloat256Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Shuffle toShuffle() {\n+        return (Halffloat256Shuffle) toShuffle(vspecies(), false);\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask test(Test op) {\n+        return super.testTemplate(Halffloat256Mask.class, op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask test(Test op, VectorMask<Float16> m) {\n+        return super.testTemplate(Halffloat256Mask.class, op, (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask compare(Comparison op, Vector<Float16> v) {\n+        return super.compareTemplate(Halffloat256Mask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask compare(Comparison op, short s) {\n+        return super.compareTemplate(Halffloat256Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask compare(Comparison op, long s) {\n+        return super.compareTemplate(Halffloat256Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask compare(Comparison op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return super.compareTemplate(Halffloat256Mask.class, op, v, (Halffloat256Mask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector blend(Vector<Float16> v, VectorMask<Float16> m) {\n+        return (Halffloat256Vector)\n+            super.blendTemplate(Halffloat256Mask.class,\n+                                (Halffloat256Vector) v,\n+                                (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector slice(int origin, Vector<Float16> v) {\n+        return (Halffloat256Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector slice(int origin) {\n+        return (Halffloat256Vector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector unslice(int origin, Vector<Float16> w, int part) {\n+        return (Halffloat256Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector unslice(int origin, Vector<Float16> w, int part, VectorMask<Float16> m) {\n+        return (Halffloat256Vector)\n+            super.unsliceTemplate(Halffloat256Mask.class,\n+                                  origin, w, part,\n+                                  (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector unslice(int origin) {\n+        return (Halffloat256Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector rearrange(VectorShuffle<Float16> s) {\n+        return (Halffloat256Vector)\n+            super.rearrangeTemplate(Halffloat256Shuffle.class,\n+                                    (Halffloat256Shuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector rearrange(VectorShuffle<Float16> shuffle,\n+                                  VectorMask<Float16> m) {\n+        return (Halffloat256Vector)\n+            super.rearrangeTemplate(Halffloat256Shuffle.class,\n+                                    Halffloat256Mask.class,\n+                                    (Halffloat256Shuffle) shuffle,\n+                                    (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector rearrange(VectorShuffle<Float16> s,\n+                                  Vector<Float16> v) {\n+        return (Halffloat256Vector)\n+            super.rearrangeTemplate(Halffloat256Shuffle.class,\n+                                    (Halffloat256Shuffle) s,\n+                                    (Halffloat256Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector compress(VectorMask<Float16> m) {\n+        return (Halffloat256Vector)\n+            super.compressTemplate(Halffloat256Mask.class,\n+                                   (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector expand(VectorMask<Float16> m) {\n+        return (Halffloat256Vector)\n+            super.expandTemplate(Halffloat256Mask.class,\n+                                   (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector selectFrom(Vector<Float16> v) {\n+        return (Halffloat256Vector)\n+            super.selectFromTemplate((Halffloat256Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector selectFrom(Vector<Float16> v,\n+                                   VectorMask<Float16> m) {\n+        return (Halffloat256Vector)\n+            super.selectFromTemplate((Halffloat256Vector) v,\n+                                     Halffloat256Mask.class, (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector selectFrom(Vector<Float16> v1,\n+                                   Vector<Float16> v2) {\n+        return (Halffloat256Vector)\n+            super.selectFromTemplate((Halffloat256Vector) v1, (Halffloat256Vector) v2);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public short lane(int i) {\n+        short bits;\n+        switch(i) {\n+            case 0: bits = laneHelper(0); break;\n+            case 1: bits = laneHelper(1); break;\n+            case 2: bits = laneHelper(2); break;\n+            case 3: bits = laneHelper(3); break;\n+            case 4: bits = laneHelper(4); break;\n+            case 5: bits = laneHelper(5); break;\n+            case 6: bits = laneHelper(6); break;\n+            case 7: bits = laneHelper(7); break;\n+            case 8: bits = laneHelper(8); break;\n+            case 9: bits = laneHelper(9); break;\n+            case 10: bits = laneHelper(10); break;\n+            case 11: bits = laneHelper(11); break;\n+            case 12: bits = laneHelper(12); break;\n+            case 13: bits = laneHelper(13); break;\n+            case 14: bits = laneHelper(14); break;\n+            case 15: bits = laneHelper(15); break;\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return bits;\n+    }\n+\n+    @ForceInline\n+    public short laneHelper(int i) {\n+        return (short) VectorSupport.extract(\n+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                     short[] vecarr = vec.vec();\n+                     return vecarr[ix];\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public Halffloat256Vector withLane(int i, short e) {\n+        switch(i) {\n+            case 0: return withLaneHelper(0, e);\n+            case 1: return withLaneHelper(1, e);\n+            case 2: return withLaneHelper(2, e);\n+            case 3: return withLaneHelper(3, e);\n+            case 4: return withLaneHelper(4, e);\n+            case 5: return withLaneHelper(5, e);\n+            case 6: return withLaneHelper(6, e);\n+            case 7: return withLaneHelper(7, e);\n+            case 8: return withLaneHelper(8, e);\n+            case 9: return withLaneHelper(9, e);\n+            case 10: return withLaneHelper(10, e);\n+            case 11: return withLaneHelper(11, e);\n+            case 12: return withLaneHelper(12, e);\n+            case 13: return withLaneHelper(13, e);\n+            case 14: return withLaneHelper(14, e);\n+            case 15: return withLaneHelper(15, e);\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Halffloat256Vector withLaneHelper(int i, short e) {\n+        return VectorSupport.insert(\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                this, i, (long)e,\n+                                (v, ix, bits) -> {\n+                                    short[] res = v.vec().clone();\n+                                    res[ix] = (short)bits;\n+                                    return v.vectorFactory(res);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final class Halffloat256Mask extends AbstractMask<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n+\n+        Halffloat256Mask(boolean[] bits) {\n+            this(bits, 0);\n+        }\n+\n+        Halffloat256Mask(boolean[] bits, int offset) {\n+            super(prepare(bits, offset));\n+        }\n+\n+        Halffloat256Mask(boolean val) {\n+            super(prepare(val));\n+        }\n+\n+        private static boolean[] prepare(boolean[] bits, int offset) {\n+            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n+            for (int i = 0; i < newBits.length; i++) {\n+                newBits[i] = bits[offset + i];\n+            }\n+            return newBits;\n+        }\n+\n+        private static boolean[] prepare(boolean val) {\n+            boolean[] bits = new boolean[VSPECIES.laneCount()];\n+            Arrays.fill(bits, val);\n+            return bits;\n+        }\n+\n+        @ForceInline\n+        final @Override\n+        public HalffloatSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        boolean[] getBits() {\n+            return (boolean[])getPayload();\n+        }\n+\n+        @Override\n+        Halffloat256Mask uOp(MUnOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i]);\n+            }\n+            return new Halffloat256Mask(res);\n+        }\n+\n+        @Override\n+        Halffloat256Mask bOp(VectorMask<Float16> m, MBinOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            boolean[] mbits = ((Halffloat256Mask)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i], mbits[i]);\n+            }\n+            return new Halffloat256Mask(res);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        Halffloat256Vector toVector() {\n+            return (Halffloat256Vector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+            boolean[] maskArray = toArray();\n+            return  dsp.maskFactory(maskArray).check(dsp);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), ETYPE, VLENGTH,\n+                species.maskType(), species.elementType(), VLENGTH,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.toArray()).check(s));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Halffloat256Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Halffloat256Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Halffloat256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n+                (o, l) -> (Halffloat256Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Mask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Mask compress() {\n+            return (Halffloat256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Halffloat256Vector.class, Halffloat256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                Float16.float16ToShortBits(Float16.valueOf(m1.trueCount()))));\n+        }\n+\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Mask and(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat256Mask m = (Halffloat256Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat256Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Mask or(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat256Mask m = (Halffloat256Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat256Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Mask xor(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat256Mask m = (Halffloat256Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat256Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat256Mask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat256Mask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat256Mask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat256Mask.class, short.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                      (m) -> toLongHelper(m.getBits()));\n+        }\n+\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Halffloat256Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, Halffloat256Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Halffloat256Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, Halffloat256Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Halffloat256Mask)m).getBits()));\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static Halffloat256Mask maskAll(boolean bit) {\n+            return VectorSupport.fromBitsCoerced(Halffloat256Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final Halffloat256Mask  TRUE_MASK = new Halffloat256Mask(true);\n+        private static final Halffloat256Mask FALSE_MASK = new Halffloat256Mask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final class Halffloat256Shuffle extends AbstractShuffle<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n+\n+        Halffloat256Shuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n+        }\n+\n+        Halffloat256Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n+        }\n+\n+        Halffloat256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n+        }\n+\n+        short[] indices() {\n+            return (short[])getPayload();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final Halffloat256Shuffle IOTA = new Halffloat256Shuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Vector toVector() {\n+            return (Halffloat256Vector) toBitsVector().castShape(vspecies(), 0);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        Short256Vector toBitsVector() {\n+            return (Short256Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Short256Vector toBitsVector0() {\n+            return ((Short256Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_256;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoMemorySegment(MemorySegment ms, long offset, ByteOrder bo) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_256;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoMemorySegment(ms, offset, bo);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoMemorySegment(ms, offset + species.vectorByteSize(), bo);\n+         }\n+\n+        @Override\n+        @ForceInline\n+        public final Halffloat256Mask laneIsValid() {\n+            return (Halffloat256Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Halffloat256Shuffle rearrange(VectorShuffle<Float16> shuffle) {\n+            Halffloat256Shuffle concreteShuffle = (Halffloat256Shuffle) shuffle;\n+            return (Halffloat256Shuffle) toBitsVector().rearrange(concreteShuffle.cast(ShortVector.SPECIES_256))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Halffloat256Shuffle wrapIndexes() {\n+            Short256Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Short256Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Short256Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Halffloat256Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromArray0Template(Halffloat256Mask.class, a, offset, (Halffloat256Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float16> m) {\n+        return super.fromArray0Template(Halffloat256Mask.class, a, offset, indexMap, mapOffset, (Halffloat256Mask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromCharArray0Template(Halffloat256Mask.class, a, offset, (Halffloat256Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromMemorySegment0Template(Halffloat256Mask.class, ms, offset, (Halffloat256Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset, VectorMask<Float16> m) {\n+        super.intoArray0Template(Halffloat256Mask.class, a, offset, (Halffloat256Mask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m) {\n+        super.intoMemorySegment0Template(Halffloat256Mask.class, ms, offset, (Halffloat256Mask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<Float16> m) {\n+        super.intoCharArray0Template(Halffloat256Mask.class, a, offset, (Halffloat256Mask) m);\n+    }\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat256Vector.java","additions":1058,"deletions":0,"binary":false,"changes":1058,"status":"added"},{"patch":"@@ -0,0 +1,1090 @@\n+\/*\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+final class Halffloat512Vector extends HalffloatVector {\n+    static final HalffloatSpecies VSPECIES =\n+        (HalffloatSpecies) HalffloatVector.SPECIES_512;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<Halffloat512Vector> VCLASS = Halffloat512Vector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Short> CTYPE = short.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Float16> ETYPE = Float16.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_FP16;\n+\n+    Halffloat512Vector(short[] v) {\n+        super(v);\n+    }\n+\n+    \/\/ For compatibility as Halffloat512Vector::new,\n+    \/\/ stored into species.vectorFactory.\n+    Halffloat512Vector(Object v) {\n+        this((short[]) v);\n+    }\n+\n+    static final Halffloat512Vector ZERO = new Halffloat512Vector(new short[VLENGTH]);\n+    static final Halffloat512Vector IOTA = new Halffloat512Vector(VSPECIES.iotaArray());\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVector();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public HalffloatSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    final Class<Short> carrierType() { return CTYPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Float16> elementType() { return ETYPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Float16.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final @Override\n+    short[] vec() {\n+        return (short[])getPayload();\n+    }\n+\n+    \/\/ Virtualized constructors\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Vector broadcast(short e) {\n+        return (Halffloat512Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Vector broadcast(long e) {\n+        return (Halffloat512Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat512Mask maskFromArray(boolean[] bits) {\n+        return new Halffloat512Mask(bits);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat512Shuffle iotaShuffle() { return Halffloat512Shuffle.IOTA; }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat512Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+        return (Halffloat512Shuffle) iotaShuffleTemplate((short) start, (short) step, wrap);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat512Shuffle shuffleFromArray(int[] indices, int i) { return new Halffloat512Shuffle(indices, i); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat512Shuffle shuffleFromOp(IntUnaryOperator fn) { return new Halffloat512Shuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector vectorFactory(short[] vec) {\n+        return new Halffloat512Vector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Byte512Vector asByteVectorRaw() {\n+        return (Byte512Vector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector uOp(FUnOp f) {\n+        return (Halffloat512Vector) super.uOpTemplate(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector uOp(VectorMask<Float16> m, FUnOp f) {\n+        return (Halffloat512Vector)\n+            super.uOpTemplate((Halffloat512Mask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector bOp(Vector<Float16> v, FBinOp f) {\n+        return (Halffloat512Vector) super.bOpTemplate((Halffloat512Vector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector bOp(Vector<Float16> v,\n+                     VectorMask<Float16> m, FBinOp f) {\n+        return (Halffloat512Vector)\n+            super.bOpTemplate((Halffloat512Vector)v, (Halffloat512Mask)m,\n+                              f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector tOp(Vector<Float16> v1, Vector<Float16> v2, FTriOp f) {\n+        return (Halffloat512Vector)\n+            super.tOpTemplate((Halffloat512Vector)v1, (Halffloat512Vector)v2,\n+                              f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector tOp(Vector<Float16> v1, Vector<Float16> v2,\n+                     VectorMask<Float16> m, FTriOp f) {\n+        return (Halffloat512Vector)\n+            super.tOpTemplate((Halffloat512Vector)v1, (Halffloat512Vector)v2,\n+                              (Halffloat512Mask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    short rOp(short v, VectorMask<Float16> m, FBinOp f) {\n+        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Float16,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector lanewise(Unary op) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector lanewise(Unary op, VectorMask<Float16> m) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op, Halffloat512Mask.class, (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector lanewise(Binary op, Vector<Float16> v) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector lanewise(Binary op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op, Halffloat512Mask.class, v, (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat512Vector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat512Vector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2, VectorMask<Float16> m) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op, Halffloat512Mask.class, v1, v2, (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat512Vector addIndex(int scale) {\n+        return (Halffloat512Vector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Float16> m) {\n+        return super.reduceLanesTemplate(op, Halffloat512Mask.class, (Halffloat512Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Float16> m) {\n+        return (long) super.reduceLanesTemplate(op, Halffloat512Mask.class, (Halffloat512Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Shuffle toShuffle() {\n+        return (Halffloat512Shuffle) toShuffle(vspecies(), false);\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask test(Test op) {\n+        return super.testTemplate(Halffloat512Mask.class, op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask test(Test op, VectorMask<Float16> m) {\n+        return super.testTemplate(Halffloat512Mask.class, op, (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask compare(Comparison op, Vector<Float16> v) {\n+        return super.compareTemplate(Halffloat512Mask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask compare(Comparison op, short s) {\n+        return super.compareTemplate(Halffloat512Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask compare(Comparison op, long s) {\n+        return super.compareTemplate(Halffloat512Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask compare(Comparison op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return super.compareTemplate(Halffloat512Mask.class, op, v, (Halffloat512Mask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector blend(Vector<Float16> v, VectorMask<Float16> m) {\n+        return (Halffloat512Vector)\n+            super.blendTemplate(Halffloat512Mask.class,\n+                                (Halffloat512Vector) v,\n+                                (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector slice(int origin, Vector<Float16> v) {\n+        return (Halffloat512Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector slice(int origin) {\n+        return (Halffloat512Vector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector unslice(int origin, Vector<Float16> w, int part) {\n+        return (Halffloat512Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector unslice(int origin, Vector<Float16> w, int part, VectorMask<Float16> m) {\n+        return (Halffloat512Vector)\n+            super.unsliceTemplate(Halffloat512Mask.class,\n+                                  origin, w, part,\n+                                  (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector unslice(int origin) {\n+        return (Halffloat512Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector rearrange(VectorShuffle<Float16> s) {\n+        return (Halffloat512Vector)\n+            super.rearrangeTemplate(Halffloat512Shuffle.class,\n+                                    (Halffloat512Shuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector rearrange(VectorShuffle<Float16> shuffle,\n+                                  VectorMask<Float16> m) {\n+        return (Halffloat512Vector)\n+            super.rearrangeTemplate(Halffloat512Shuffle.class,\n+                                    Halffloat512Mask.class,\n+                                    (Halffloat512Shuffle) shuffle,\n+                                    (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector rearrange(VectorShuffle<Float16> s,\n+                                  Vector<Float16> v) {\n+        return (Halffloat512Vector)\n+            super.rearrangeTemplate(Halffloat512Shuffle.class,\n+                                    (Halffloat512Shuffle) s,\n+                                    (Halffloat512Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector compress(VectorMask<Float16> m) {\n+        return (Halffloat512Vector)\n+            super.compressTemplate(Halffloat512Mask.class,\n+                                   (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector expand(VectorMask<Float16> m) {\n+        return (Halffloat512Vector)\n+            super.expandTemplate(Halffloat512Mask.class,\n+                                   (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector selectFrom(Vector<Float16> v) {\n+        return (Halffloat512Vector)\n+            super.selectFromTemplate((Halffloat512Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector selectFrom(Vector<Float16> v,\n+                                   VectorMask<Float16> m) {\n+        return (Halffloat512Vector)\n+            super.selectFromTemplate((Halffloat512Vector) v,\n+                                     Halffloat512Mask.class, (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector selectFrom(Vector<Float16> v1,\n+                                   Vector<Float16> v2) {\n+        return (Halffloat512Vector)\n+            super.selectFromTemplate((Halffloat512Vector) v1, (Halffloat512Vector) v2);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public short lane(int i) {\n+        short bits;\n+        switch(i) {\n+            case 0: bits = laneHelper(0); break;\n+            case 1: bits = laneHelper(1); break;\n+            case 2: bits = laneHelper(2); break;\n+            case 3: bits = laneHelper(3); break;\n+            case 4: bits = laneHelper(4); break;\n+            case 5: bits = laneHelper(5); break;\n+            case 6: bits = laneHelper(6); break;\n+            case 7: bits = laneHelper(7); break;\n+            case 8: bits = laneHelper(8); break;\n+            case 9: bits = laneHelper(9); break;\n+            case 10: bits = laneHelper(10); break;\n+            case 11: bits = laneHelper(11); break;\n+            case 12: bits = laneHelper(12); break;\n+            case 13: bits = laneHelper(13); break;\n+            case 14: bits = laneHelper(14); break;\n+            case 15: bits = laneHelper(15); break;\n+            case 16: bits = laneHelper(16); break;\n+            case 17: bits = laneHelper(17); break;\n+            case 18: bits = laneHelper(18); break;\n+            case 19: bits = laneHelper(19); break;\n+            case 20: bits = laneHelper(20); break;\n+            case 21: bits = laneHelper(21); break;\n+            case 22: bits = laneHelper(22); break;\n+            case 23: bits = laneHelper(23); break;\n+            case 24: bits = laneHelper(24); break;\n+            case 25: bits = laneHelper(25); break;\n+            case 26: bits = laneHelper(26); break;\n+            case 27: bits = laneHelper(27); break;\n+            case 28: bits = laneHelper(28); break;\n+            case 29: bits = laneHelper(29); break;\n+            case 30: bits = laneHelper(30); break;\n+            case 31: bits = laneHelper(31); break;\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return bits;\n+    }\n+\n+    @ForceInline\n+    public short laneHelper(int i) {\n+        return (short) VectorSupport.extract(\n+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                     short[] vecarr = vec.vec();\n+                     return vecarr[ix];\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public Halffloat512Vector withLane(int i, short e) {\n+        switch(i) {\n+            case 0: return withLaneHelper(0, e);\n+            case 1: return withLaneHelper(1, e);\n+            case 2: return withLaneHelper(2, e);\n+            case 3: return withLaneHelper(3, e);\n+            case 4: return withLaneHelper(4, e);\n+            case 5: return withLaneHelper(5, e);\n+            case 6: return withLaneHelper(6, e);\n+            case 7: return withLaneHelper(7, e);\n+            case 8: return withLaneHelper(8, e);\n+            case 9: return withLaneHelper(9, e);\n+            case 10: return withLaneHelper(10, e);\n+            case 11: return withLaneHelper(11, e);\n+            case 12: return withLaneHelper(12, e);\n+            case 13: return withLaneHelper(13, e);\n+            case 14: return withLaneHelper(14, e);\n+            case 15: return withLaneHelper(15, e);\n+            case 16: return withLaneHelper(16, e);\n+            case 17: return withLaneHelper(17, e);\n+            case 18: return withLaneHelper(18, e);\n+            case 19: return withLaneHelper(19, e);\n+            case 20: return withLaneHelper(20, e);\n+            case 21: return withLaneHelper(21, e);\n+            case 22: return withLaneHelper(22, e);\n+            case 23: return withLaneHelper(23, e);\n+            case 24: return withLaneHelper(24, e);\n+            case 25: return withLaneHelper(25, e);\n+            case 26: return withLaneHelper(26, e);\n+            case 27: return withLaneHelper(27, e);\n+            case 28: return withLaneHelper(28, e);\n+            case 29: return withLaneHelper(29, e);\n+            case 30: return withLaneHelper(30, e);\n+            case 31: return withLaneHelper(31, e);\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Halffloat512Vector withLaneHelper(int i, short e) {\n+        return VectorSupport.insert(\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                this, i, (long)e,\n+                                (v, ix, bits) -> {\n+                                    short[] res = v.vec().clone();\n+                                    res[ix] = (short)bits;\n+                                    return v.vectorFactory(res);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final class Halffloat512Mask extends AbstractMask<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n+\n+        Halffloat512Mask(boolean[] bits) {\n+            this(bits, 0);\n+        }\n+\n+        Halffloat512Mask(boolean[] bits, int offset) {\n+            super(prepare(bits, offset));\n+        }\n+\n+        Halffloat512Mask(boolean val) {\n+            super(prepare(val));\n+        }\n+\n+        private static boolean[] prepare(boolean[] bits, int offset) {\n+            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n+            for (int i = 0; i < newBits.length; i++) {\n+                newBits[i] = bits[offset + i];\n+            }\n+            return newBits;\n+        }\n+\n+        private static boolean[] prepare(boolean val) {\n+            boolean[] bits = new boolean[VSPECIES.laneCount()];\n+            Arrays.fill(bits, val);\n+            return bits;\n+        }\n+\n+        @ForceInline\n+        final @Override\n+        public HalffloatSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        boolean[] getBits() {\n+            return (boolean[])getPayload();\n+        }\n+\n+        @Override\n+        Halffloat512Mask uOp(MUnOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i]);\n+            }\n+            return new Halffloat512Mask(res);\n+        }\n+\n+        @Override\n+        Halffloat512Mask bOp(VectorMask<Float16> m, MBinOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            boolean[] mbits = ((Halffloat512Mask)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i], mbits[i]);\n+            }\n+            return new Halffloat512Mask(res);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        Halffloat512Vector toVector() {\n+            return (Halffloat512Vector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+            boolean[] maskArray = toArray();\n+            return  dsp.maskFactory(maskArray).check(dsp);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), ETYPE, VLENGTH,\n+                species.maskType(), species.elementType(), VLENGTH,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.toArray()).check(s));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Halffloat512Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Halffloat512Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Halffloat512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n+                (o, l) -> (Halffloat512Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Mask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Mask compress() {\n+            return (Halffloat512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Halffloat512Vector.class, Halffloat512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                Float16.float16ToShortBits(Float16.valueOf(m1.trueCount()))));\n+        }\n+\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Mask and(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat512Mask m = (Halffloat512Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat512Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Mask or(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat512Mask m = (Halffloat512Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat512Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Mask xor(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat512Mask m = (Halffloat512Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat512Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat512Mask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat512Mask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat512Mask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat512Mask.class, short.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                      (m) -> toLongHelper(m.getBits()));\n+        }\n+\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Halffloat512Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, Halffloat512Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Halffloat512Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, Halffloat512Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Halffloat512Mask)m).getBits()));\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static Halffloat512Mask maskAll(boolean bit) {\n+            return VectorSupport.fromBitsCoerced(Halffloat512Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final Halffloat512Mask  TRUE_MASK = new Halffloat512Mask(true);\n+        private static final Halffloat512Mask FALSE_MASK = new Halffloat512Mask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final class Halffloat512Shuffle extends AbstractShuffle<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n+\n+        Halffloat512Shuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n+        }\n+\n+        Halffloat512Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n+        }\n+\n+        Halffloat512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n+        }\n+\n+        short[] indices() {\n+            return (short[])getPayload();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final Halffloat512Shuffle IOTA = new Halffloat512Shuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Vector toVector() {\n+            return (Halffloat512Vector) toBitsVector().castShape(vspecies(), 0);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        Short512Vector toBitsVector() {\n+            return (Short512Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Short512Vector toBitsVector0() {\n+            return ((Short512Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_512;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoMemorySegment(MemorySegment ms, long offset, ByteOrder bo) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_512;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoMemorySegment(ms, offset, bo);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoMemorySegment(ms, offset + species.vectorByteSize(), bo);\n+         }\n+\n+        @Override\n+        @ForceInline\n+        public final Halffloat512Mask laneIsValid() {\n+            return (Halffloat512Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Halffloat512Shuffle rearrange(VectorShuffle<Float16> shuffle) {\n+            Halffloat512Shuffle concreteShuffle = (Halffloat512Shuffle) shuffle;\n+            return (Halffloat512Shuffle) toBitsVector().rearrange(concreteShuffle.cast(ShortVector.SPECIES_512))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Halffloat512Shuffle wrapIndexes() {\n+            Short512Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Short512Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Short512Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Halffloat512Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromArray0Template(Halffloat512Mask.class, a, offset, (Halffloat512Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float16> m) {\n+        return super.fromArray0Template(Halffloat512Mask.class, a, offset, indexMap, mapOffset, (Halffloat512Mask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromCharArray0Template(Halffloat512Mask.class, a, offset, (Halffloat512Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromMemorySegment0Template(Halffloat512Mask.class, ms, offset, (Halffloat512Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset, VectorMask<Float16> m) {\n+        super.intoArray0Template(Halffloat512Mask.class, a, offset, (Halffloat512Mask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m) {\n+        super.intoMemorySegment0Template(Halffloat512Mask.class, ms, offset, (Halffloat512Mask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<Float16> m) {\n+        super.intoCharArray0Template(Halffloat512Mask.class, a, offset, (Halffloat512Mask) m);\n+    }\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat512Vector.java","additions":1090,"deletions":0,"binary":false,"changes":1090,"status":"added"},{"patch":"@@ -0,0 +1,1034 @@\n+\/*\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+final class Halffloat64Vector extends HalffloatVector {\n+    static final HalffloatSpecies VSPECIES =\n+        (HalffloatSpecies) HalffloatVector.SPECIES_64;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<Halffloat64Vector> VCLASS = Halffloat64Vector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Short> CTYPE = short.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Float16> ETYPE = Float16.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_FP16;\n+\n+    Halffloat64Vector(short[] v) {\n+        super(v);\n+    }\n+\n+    \/\/ For compatibility as Halffloat64Vector::new,\n+    \/\/ stored into species.vectorFactory.\n+    Halffloat64Vector(Object v) {\n+        this((short[]) v);\n+    }\n+\n+    static final Halffloat64Vector ZERO = new Halffloat64Vector(new short[VLENGTH]);\n+    static final Halffloat64Vector IOTA = new Halffloat64Vector(VSPECIES.iotaArray());\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVector();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public HalffloatSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    final Class<Short> carrierType() { return CTYPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Float16> elementType() { return ETYPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Float16.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final @Override\n+    short[] vec() {\n+        return (short[])getPayload();\n+    }\n+\n+    \/\/ Virtualized constructors\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Vector broadcast(short e) {\n+        return (Halffloat64Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Vector broadcast(long e) {\n+        return (Halffloat64Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat64Mask maskFromArray(boolean[] bits) {\n+        return new Halffloat64Mask(bits);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat64Shuffle iotaShuffle() { return Halffloat64Shuffle.IOTA; }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat64Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+        return (Halffloat64Shuffle) iotaShuffleTemplate((short) start, (short) step, wrap);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat64Shuffle shuffleFromArray(int[] indices, int i) { return new Halffloat64Shuffle(indices, i); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat64Shuffle shuffleFromOp(IntUnaryOperator fn) { return new Halffloat64Shuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector vectorFactory(short[] vec) {\n+        return new Halffloat64Vector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Byte64Vector asByteVectorRaw() {\n+        return (Byte64Vector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector uOp(FUnOp f) {\n+        return (Halffloat64Vector) super.uOpTemplate(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector uOp(VectorMask<Float16> m, FUnOp f) {\n+        return (Halffloat64Vector)\n+            super.uOpTemplate((Halffloat64Mask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector bOp(Vector<Float16> v, FBinOp f) {\n+        return (Halffloat64Vector) super.bOpTemplate((Halffloat64Vector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector bOp(Vector<Float16> v,\n+                     VectorMask<Float16> m, FBinOp f) {\n+        return (Halffloat64Vector)\n+            super.bOpTemplate((Halffloat64Vector)v, (Halffloat64Mask)m,\n+                              f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector tOp(Vector<Float16> v1, Vector<Float16> v2, FTriOp f) {\n+        return (Halffloat64Vector)\n+            super.tOpTemplate((Halffloat64Vector)v1, (Halffloat64Vector)v2,\n+                              f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector tOp(Vector<Float16> v1, Vector<Float16> v2,\n+                     VectorMask<Float16> m, FTriOp f) {\n+        return (Halffloat64Vector)\n+            super.tOpTemplate((Halffloat64Vector)v1, (Halffloat64Vector)v2,\n+                              (Halffloat64Mask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    short rOp(short v, VectorMask<Float16> m, FBinOp f) {\n+        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Float16,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector lanewise(Unary op) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector lanewise(Unary op, VectorMask<Float16> m) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op, Halffloat64Mask.class, (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector lanewise(Binary op, Vector<Float16> v) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector lanewise(Binary op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op, Halffloat64Mask.class, v, (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat64Vector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat64Vector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2, VectorMask<Float16> m) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op, Halffloat64Mask.class, v1, v2, (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat64Vector addIndex(int scale) {\n+        return (Halffloat64Vector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Float16> m) {\n+        return super.reduceLanesTemplate(op, Halffloat64Mask.class, (Halffloat64Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Float16> m) {\n+        return (long) super.reduceLanesTemplate(op, Halffloat64Mask.class, (Halffloat64Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Shuffle toShuffle() {\n+        return (Halffloat64Shuffle) toShuffle(vspecies(), false);\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask test(Test op) {\n+        return super.testTemplate(Halffloat64Mask.class, op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask test(Test op, VectorMask<Float16> m) {\n+        return super.testTemplate(Halffloat64Mask.class, op, (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask compare(Comparison op, Vector<Float16> v) {\n+        return super.compareTemplate(Halffloat64Mask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask compare(Comparison op, short s) {\n+        return super.compareTemplate(Halffloat64Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask compare(Comparison op, long s) {\n+        return super.compareTemplate(Halffloat64Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask compare(Comparison op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return super.compareTemplate(Halffloat64Mask.class, op, v, (Halffloat64Mask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector blend(Vector<Float16> v, VectorMask<Float16> m) {\n+        return (Halffloat64Vector)\n+            super.blendTemplate(Halffloat64Mask.class,\n+                                (Halffloat64Vector) v,\n+                                (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector slice(int origin, Vector<Float16> v) {\n+        return (Halffloat64Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector slice(int origin) {\n+        return (Halffloat64Vector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector unslice(int origin, Vector<Float16> w, int part) {\n+        return (Halffloat64Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector unslice(int origin, Vector<Float16> w, int part, VectorMask<Float16> m) {\n+        return (Halffloat64Vector)\n+            super.unsliceTemplate(Halffloat64Mask.class,\n+                                  origin, w, part,\n+                                  (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector unslice(int origin) {\n+        return (Halffloat64Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector rearrange(VectorShuffle<Float16> s) {\n+        return (Halffloat64Vector)\n+            super.rearrangeTemplate(Halffloat64Shuffle.class,\n+                                    (Halffloat64Shuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector rearrange(VectorShuffle<Float16> shuffle,\n+                                  VectorMask<Float16> m) {\n+        return (Halffloat64Vector)\n+            super.rearrangeTemplate(Halffloat64Shuffle.class,\n+                                    Halffloat64Mask.class,\n+                                    (Halffloat64Shuffle) shuffle,\n+                                    (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector rearrange(VectorShuffle<Float16> s,\n+                                  Vector<Float16> v) {\n+        return (Halffloat64Vector)\n+            super.rearrangeTemplate(Halffloat64Shuffle.class,\n+                                    (Halffloat64Shuffle) s,\n+                                    (Halffloat64Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector compress(VectorMask<Float16> m) {\n+        return (Halffloat64Vector)\n+            super.compressTemplate(Halffloat64Mask.class,\n+                                   (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector expand(VectorMask<Float16> m) {\n+        return (Halffloat64Vector)\n+            super.expandTemplate(Halffloat64Mask.class,\n+                                   (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector selectFrom(Vector<Float16> v) {\n+        return (Halffloat64Vector)\n+            super.selectFromTemplate((Halffloat64Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector selectFrom(Vector<Float16> v,\n+                                   VectorMask<Float16> m) {\n+        return (Halffloat64Vector)\n+            super.selectFromTemplate((Halffloat64Vector) v,\n+                                     Halffloat64Mask.class, (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector selectFrom(Vector<Float16> v1,\n+                                   Vector<Float16> v2) {\n+        return (Halffloat64Vector)\n+            super.selectFromTemplate((Halffloat64Vector) v1, (Halffloat64Vector) v2);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public short lane(int i) {\n+        short bits;\n+        switch(i) {\n+            case 0: bits = laneHelper(0); break;\n+            case 1: bits = laneHelper(1); break;\n+            case 2: bits = laneHelper(2); break;\n+            case 3: bits = laneHelper(3); break;\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return bits;\n+    }\n+\n+    @ForceInline\n+    public short laneHelper(int i) {\n+        return (short) VectorSupport.extract(\n+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                     short[] vecarr = vec.vec();\n+                     return vecarr[ix];\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public Halffloat64Vector withLane(int i, short e) {\n+        switch(i) {\n+            case 0: return withLaneHelper(0, e);\n+            case 1: return withLaneHelper(1, e);\n+            case 2: return withLaneHelper(2, e);\n+            case 3: return withLaneHelper(3, e);\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Halffloat64Vector withLaneHelper(int i, short e) {\n+        return VectorSupport.insert(\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                this, i, (long)e,\n+                                (v, ix, bits) -> {\n+                                    short[] res = v.vec().clone();\n+                                    res[ix] = (short)bits;\n+                                    return v.vectorFactory(res);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final class Halffloat64Mask extends AbstractMask<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n+\n+        Halffloat64Mask(boolean[] bits) {\n+            this(bits, 0);\n+        }\n+\n+        Halffloat64Mask(boolean[] bits, int offset) {\n+            super(prepare(bits, offset));\n+        }\n+\n+        Halffloat64Mask(boolean val) {\n+            super(prepare(val));\n+        }\n+\n+        private static boolean[] prepare(boolean[] bits, int offset) {\n+            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n+            for (int i = 0; i < newBits.length; i++) {\n+                newBits[i] = bits[offset + i];\n+            }\n+            return newBits;\n+        }\n+\n+        private static boolean[] prepare(boolean val) {\n+            boolean[] bits = new boolean[VSPECIES.laneCount()];\n+            Arrays.fill(bits, val);\n+            return bits;\n+        }\n+\n+        @ForceInline\n+        final @Override\n+        public HalffloatSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        boolean[] getBits() {\n+            return (boolean[])getPayload();\n+        }\n+\n+        @Override\n+        Halffloat64Mask uOp(MUnOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i]);\n+            }\n+            return new Halffloat64Mask(res);\n+        }\n+\n+        @Override\n+        Halffloat64Mask bOp(VectorMask<Float16> m, MBinOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            boolean[] mbits = ((Halffloat64Mask)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i], mbits[i]);\n+            }\n+            return new Halffloat64Mask(res);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        Halffloat64Vector toVector() {\n+            return (Halffloat64Vector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+            boolean[] maskArray = toArray();\n+            return  dsp.maskFactory(maskArray).check(dsp);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), ETYPE, VLENGTH,\n+                species.maskType(), species.elementType(), VLENGTH,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.toArray()).check(s));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Halffloat64Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Halffloat64Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Halffloat64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n+                (o, l) -> (Halffloat64Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Mask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Mask compress() {\n+            return (Halffloat64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Halffloat64Vector.class, Halffloat64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                Float16.float16ToShortBits(Float16.valueOf(m1.trueCount()))));\n+        }\n+\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Mask and(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat64Mask m = (Halffloat64Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat64Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Mask or(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat64Mask m = (Halffloat64Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat64Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Mask xor(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat64Mask m = (Halffloat64Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat64Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat64Mask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat64Mask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat64Mask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat64Mask.class, short.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                      (m) -> toLongHelper(m.getBits()));\n+        }\n+\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Halffloat64Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, Halffloat64Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Halffloat64Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, Halffloat64Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Halffloat64Mask)m).getBits()));\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static Halffloat64Mask maskAll(boolean bit) {\n+            return VectorSupport.fromBitsCoerced(Halffloat64Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final Halffloat64Mask  TRUE_MASK = new Halffloat64Mask(true);\n+        private static final Halffloat64Mask FALSE_MASK = new Halffloat64Mask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final class Halffloat64Shuffle extends AbstractShuffle<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n+\n+        Halffloat64Shuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n+        }\n+\n+        Halffloat64Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n+        }\n+\n+        Halffloat64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n+        }\n+\n+        short[] indices() {\n+            return (short[])getPayload();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final Halffloat64Shuffle IOTA = new Halffloat64Shuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Vector toVector() {\n+            return (Halffloat64Vector) toBitsVector().castShape(vspecies(), 0);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        Short64Vector toBitsVector() {\n+            return (Short64Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Short64Vector toBitsVector0() {\n+            return ((Short64Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_64;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoMemorySegment(MemorySegment ms, long offset, ByteOrder bo) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_64;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoMemorySegment(ms, offset, bo);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoMemorySegment(ms, offset + species.vectorByteSize(), bo);\n+         }\n+\n+        @Override\n+        @ForceInline\n+        public final Halffloat64Mask laneIsValid() {\n+            return (Halffloat64Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Halffloat64Shuffle rearrange(VectorShuffle<Float16> shuffle) {\n+            Halffloat64Shuffle concreteShuffle = (Halffloat64Shuffle) shuffle;\n+            return (Halffloat64Shuffle) toBitsVector().rearrange(concreteShuffle.cast(ShortVector.SPECIES_64))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Halffloat64Shuffle wrapIndexes() {\n+            Short64Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Short64Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Short64Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Halffloat64Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromArray0Template(Halffloat64Mask.class, a, offset, (Halffloat64Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float16> m) {\n+        return super.fromArray0Template(Halffloat64Mask.class, a, offset, indexMap, mapOffset, (Halffloat64Mask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromCharArray0Template(Halffloat64Mask.class, a, offset, (Halffloat64Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromMemorySegment0Template(Halffloat64Mask.class, ms, offset, (Halffloat64Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset, VectorMask<Float16> m) {\n+        super.intoArray0Template(Halffloat64Mask.class, a, offset, (Halffloat64Mask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m) {\n+        super.intoMemorySegment0Template(Halffloat64Mask.class, ms, offset, (Halffloat64Mask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<Float16> m) {\n+        super.intoCharArray0Template(Halffloat64Mask.class, a, offset, (Halffloat64Mask) m);\n+    }\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat64Vector.java","additions":1034,"deletions":0,"binary":false,"changes":1034,"status":"added"},{"patch":"@@ -0,0 +1,1027 @@\n+\/*\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+final class HalffloatMaxVector extends HalffloatVector {\n+    static final HalffloatSpecies VSPECIES =\n+        (HalffloatSpecies) HalffloatVector.SPECIES_MAX;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<HalffloatMaxVector> VCLASS = HalffloatMaxVector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Short> CTYPE = short.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Float16> ETYPE = Float16.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_FP16;\n+\n+    HalffloatMaxVector(short[] v) {\n+        super(v);\n+    }\n+\n+    \/\/ For compatibility as HalffloatMaxVector::new,\n+    \/\/ stored into species.vectorFactory.\n+    HalffloatMaxVector(Object v) {\n+        this((short[]) v);\n+    }\n+\n+    static final HalffloatMaxVector ZERO = new HalffloatMaxVector(new short[VLENGTH]);\n+    static final HalffloatMaxVector IOTA = new HalffloatMaxVector(VSPECIES.iotaArray());\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVector();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public HalffloatSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    final Class<Short> carrierType() { return CTYPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Float16> elementType() { return ETYPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Float16.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final @Override\n+    short[] vec() {\n+        return (short[])getPayload();\n+    }\n+\n+    \/\/ Virtualized constructors\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxVector broadcast(short e) {\n+        return (HalffloatMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxVector broadcast(long e) {\n+        return (HalffloatMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    HalffloatMaxMask maskFromArray(boolean[] bits) {\n+        return new HalffloatMaxMask(bits);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    HalffloatMaxShuffle iotaShuffle() { return HalffloatMaxShuffle.IOTA; }\n+\n+    @Override\n+    @ForceInline\n+    HalffloatMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n+        return (HalffloatMaxShuffle) iotaShuffleTemplate((short) start, (short) step, wrap);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    HalffloatMaxShuffle shuffleFromArray(int[] indices, int i) { return new HalffloatMaxShuffle(indices, i); }\n+\n+    @Override\n+    @ForceInline\n+    HalffloatMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new HalffloatMaxShuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector vectorFactory(short[] vec) {\n+        return new HalffloatMaxVector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    ByteMaxVector asByteVectorRaw() {\n+        return (ByteMaxVector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector uOp(FUnOp f) {\n+        return (HalffloatMaxVector) super.uOpTemplate(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector uOp(VectorMask<Float16> m, FUnOp f) {\n+        return (HalffloatMaxVector)\n+            super.uOpTemplate((HalffloatMaxMask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector bOp(Vector<Float16> v, FBinOp f) {\n+        return (HalffloatMaxVector) super.bOpTemplate((HalffloatMaxVector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector bOp(Vector<Float16> v,\n+                     VectorMask<Float16> m, FBinOp f) {\n+        return (HalffloatMaxVector)\n+            super.bOpTemplate((HalffloatMaxVector)v, (HalffloatMaxMask)m,\n+                              f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector tOp(Vector<Float16> v1, Vector<Float16> v2, FTriOp f) {\n+        return (HalffloatMaxVector)\n+            super.tOpTemplate((HalffloatMaxVector)v1, (HalffloatMaxVector)v2,\n+                              f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector tOp(Vector<Float16> v1, Vector<Float16> v2,\n+                     VectorMask<Float16> m, FTriOp f) {\n+        return (HalffloatMaxVector)\n+            super.tOpTemplate((HalffloatMaxVector)v1, (HalffloatMaxVector)v2,\n+                              (HalffloatMaxMask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    short rOp(short v, VectorMask<Float16> m, FBinOp f) {\n+        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Float16,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector lanewise(Unary op) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector lanewise(Unary op, VectorMask<Float16> m) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op, HalffloatMaxMask.class, (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector lanewise(Binary op, Vector<Float16> v) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector lanewise(Binary op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op, HalffloatMaxMask.class, v, (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatMaxVector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatMaxVector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2, VectorMask<Float16> m) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op, HalffloatMaxMask.class, v1, v2, (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatMaxVector addIndex(int scale) {\n+        return (HalffloatMaxVector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Float16> m) {\n+        return super.reduceLanesTemplate(op, HalffloatMaxMask.class, (HalffloatMaxMask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Float16> m) {\n+        return (long) super.reduceLanesTemplate(op, HalffloatMaxMask.class, (HalffloatMaxMask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxShuffle toShuffle() {\n+        return (HalffloatMaxShuffle) toShuffle(vspecies(), false);\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask test(Test op) {\n+        return super.testTemplate(HalffloatMaxMask.class, op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask test(Test op, VectorMask<Float16> m) {\n+        return super.testTemplate(HalffloatMaxMask.class, op, (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask compare(Comparison op, Vector<Float16> v) {\n+        return super.compareTemplate(HalffloatMaxMask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask compare(Comparison op, short s) {\n+        return super.compareTemplate(HalffloatMaxMask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask compare(Comparison op, long s) {\n+        return super.compareTemplate(HalffloatMaxMask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask compare(Comparison op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return super.compareTemplate(HalffloatMaxMask.class, op, v, (HalffloatMaxMask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector blend(Vector<Float16> v, VectorMask<Float16> m) {\n+        return (HalffloatMaxVector)\n+            super.blendTemplate(HalffloatMaxMask.class,\n+                                (HalffloatMaxVector) v,\n+                                (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector slice(int origin, Vector<Float16> v) {\n+        return (HalffloatMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector slice(int origin) {\n+        return (HalffloatMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector unslice(int origin, Vector<Float16> w, int part) {\n+        return (HalffloatMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector unslice(int origin, Vector<Float16> w, int part, VectorMask<Float16> m) {\n+        return (HalffloatMaxVector)\n+            super.unsliceTemplate(HalffloatMaxMask.class,\n+                                  origin, w, part,\n+                                  (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector unslice(int origin) {\n+        return (HalffloatMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector rearrange(VectorShuffle<Float16> s) {\n+        return (HalffloatMaxVector)\n+            super.rearrangeTemplate(HalffloatMaxShuffle.class,\n+                                    (HalffloatMaxShuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector rearrange(VectorShuffle<Float16> shuffle,\n+                                  VectorMask<Float16> m) {\n+        return (HalffloatMaxVector)\n+            super.rearrangeTemplate(HalffloatMaxShuffle.class,\n+                                    HalffloatMaxMask.class,\n+                                    (HalffloatMaxShuffle) shuffle,\n+                                    (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector rearrange(VectorShuffle<Float16> s,\n+                                  Vector<Float16> v) {\n+        return (HalffloatMaxVector)\n+            super.rearrangeTemplate(HalffloatMaxShuffle.class,\n+                                    (HalffloatMaxShuffle) s,\n+                                    (HalffloatMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector compress(VectorMask<Float16> m) {\n+        return (HalffloatMaxVector)\n+            super.compressTemplate(HalffloatMaxMask.class,\n+                                   (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector expand(VectorMask<Float16> m) {\n+        return (HalffloatMaxVector)\n+            super.expandTemplate(HalffloatMaxMask.class,\n+                                   (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector selectFrom(Vector<Float16> v) {\n+        return (HalffloatMaxVector)\n+            super.selectFromTemplate((HalffloatMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector selectFrom(Vector<Float16> v,\n+                                   VectorMask<Float16> m) {\n+        return (HalffloatMaxVector)\n+            super.selectFromTemplate((HalffloatMaxVector) v,\n+                                     HalffloatMaxMask.class, (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector selectFrom(Vector<Float16> v1,\n+                                   Vector<Float16> v2) {\n+        return (HalffloatMaxVector)\n+            super.selectFromTemplate((HalffloatMaxVector) v1, (HalffloatMaxVector) v2);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public short lane(int i) {\n+        if (i < 0 || i >= VLENGTH) {\n+            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        short bits = laneHelper(i);\n+        return bits;\n+    }\n+\n+    @ForceInline\n+    public short laneHelper(int i) {\n+        return (short) VectorSupport.extract(\n+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                     short[] vecarr = vec.vec();\n+                     return vecarr[ix];\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public HalffloatMaxVector withLane(int i, short e) {\n+        if (i < 0 || i >= VLENGTH) {\n+            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return withLaneHelper(i, e);\n+    }\n+\n+    @ForceInline\n+    public HalffloatMaxVector withLaneHelper(int i, short e) {\n+        return VectorSupport.insert(\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                this, i, (long)e,\n+                                (v, ix, bits) -> {\n+                                    short[] res = v.vec().clone();\n+                                    res[ix] = (short)bits;\n+                                    return v.vectorFactory(res);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final class HalffloatMaxMask extends AbstractMask<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n+\n+        HalffloatMaxMask(boolean[] bits) {\n+            this(bits, 0);\n+        }\n+\n+        HalffloatMaxMask(boolean[] bits, int offset) {\n+            super(prepare(bits, offset));\n+        }\n+\n+        HalffloatMaxMask(boolean val) {\n+            super(prepare(val));\n+        }\n+\n+        private static boolean[] prepare(boolean[] bits, int offset) {\n+            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n+            for (int i = 0; i < newBits.length; i++) {\n+                newBits[i] = bits[offset + i];\n+            }\n+            return newBits;\n+        }\n+\n+        private static boolean[] prepare(boolean val) {\n+            boolean[] bits = new boolean[VSPECIES.laneCount()];\n+            Arrays.fill(bits, val);\n+            return bits;\n+        }\n+\n+        @ForceInline\n+        final @Override\n+        public HalffloatSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        boolean[] getBits() {\n+            return (boolean[])getPayload();\n+        }\n+\n+        @Override\n+        HalffloatMaxMask uOp(MUnOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i]);\n+            }\n+            return new HalffloatMaxMask(res);\n+        }\n+\n+        @Override\n+        HalffloatMaxMask bOp(VectorMask<Float16> m, MBinOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            boolean[] mbits = ((HalffloatMaxMask)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i], mbits[i]);\n+            }\n+            return new HalffloatMaxMask(res);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        HalffloatMaxVector toVector() {\n+            return (HalffloatMaxVector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+            boolean[] maskArray = toArray();\n+            return  dsp.maskFactory(maskArray).check(dsp);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), ETYPE, VLENGTH,\n+                species.maskType(), species.elementType(), VLENGTH,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.toArray()).check(s));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        HalffloatMaxMask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (HalffloatMaxMask) VectorSupport.indexPartiallyInUpperRange(\n+                HalffloatMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n+                (o, l) -> (HalffloatMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxMask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxMask compress() {\n+            return (HalffloatMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                HalffloatMaxVector.class, HalffloatMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                Float16.float16ToShortBits(Float16.valueOf(m1.trueCount()))));\n+        }\n+\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxMask and(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            HalffloatMaxMask m = (HalffloatMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, HalffloatMaxMask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxMask or(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            HalffloatMaxMask m = (HalffloatMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, HalffloatMaxMask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxMask xor(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            HalffloatMaxMask m = (HalffloatMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, HalffloatMaxMask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, HalffloatMaxMask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, HalffloatMaxMask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, HalffloatMaxMask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, HalffloatMaxMask.class, short.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                      (m) -> toLongHelper(m.getBits()));\n+        }\n+\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(HalffloatMaxMask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, HalffloatMaxMask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((HalffloatMaxMask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, HalffloatMaxMask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((HalffloatMaxMask)m).getBits()));\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static HalffloatMaxMask maskAll(boolean bit) {\n+            return VectorSupport.fromBitsCoerced(HalffloatMaxMask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final HalffloatMaxMask  TRUE_MASK = new HalffloatMaxMask(true);\n+        private static final HalffloatMaxMask FALSE_MASK = new HalffloatMaxMask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final class HalffloatMaxShuffle extends AbstractShuffle<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n+\n+        HalffloatMaxShuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n+        }\n+\n+        HalffloatMaxShuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n+        }\n+\n+        HalffloatMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n+        }\n+\n+        short[] indices() {\n+            return (short[])getPayload();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final HalffloatMaxShuffle IOTA = new HalffloatMaxShuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxVector toVector() {\n+            return (HalffloatMaxVector) toBitsVector().castShape(vspecies(), 0);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        ShortMaxVector toBitsVector() {\n+            return (ShortMaxVector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        ShortMaxVector toBitsVector0() {\n+            return ((ShortMaxVector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_MAX;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoMemorySegment(MemorySegment ms, long offset, ByteOrder bo) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_MAX;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoMemorySegment(ms, offset, bo);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoMemorySegment(ms, offset + species.vectorByteSize(), bo);\n+         }\n+\n+        @Override\n+        @ForceInline\n+        public final HalffloatMaxMask laneIsValid() {\n+            return (HalffloatMaxMask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final HalffloatMaxShuffle rearrange(VectorShuffle<Float16> shuffle) {\n+            HalffloatMaxShuffle concreteShuffle = (HalffloatMaxShuffle) shuffle;\n+            return (HalffloatMaxShuffle) toBitsVector().rearrange(concreteShuffle.cast(ShortVector.SPECIES_MAX))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final HalffloatMaxShuffle wrapIndexes() {\n+            ShortMaxVector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (ShortMaxVector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (ShortMaxVector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (HalffloatMaxShuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromArray0Template(HalffloatMaxMask.class, a, offset, (HalffloatMaxMask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float16> m) {\n+        return super.fromArray0Template(HalffloatMaxMask.class, a, offset, indexMap, mapOffset, (HalffloatMaxMask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromCharArray0Template(HalffloatMaxMask.class, a, offset, (HalffloatMaxMask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromMemorySegment0Template(HalffloatMaxMask.class, ms, offset, (HalffloatMaxMask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset, VectorMask<Float16> m) {\n+        super.intoArray0Template(HalffloatMaxMask.class, a, offset, (HalffloatMaxMask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m) {\n+        super.intoMemorySegment0Template(HalffloatMaxMask.class, ms, offset, (HalffloatMaxMask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<Float16> m) {\n+        super.intoCharArray0Template(HalffloatMaxMask.class, a, offset, (HalffloatMaxMask) m);\n+    }\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/HalffloatMaxVector.java","additions":1027,"deletions":0,"binary":false,"changes":1027,"status":"added"},{"patch":"@@ -0,0 +1,4364 @@\n+\/*\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+import static jdk.incubator.vector.VectorIntrinsics.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+import jdk.incubator.vector.Float16;\n+import static jdk.incubator.vector.Float16.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+\/**\n+ * A specialized {@link Vector} representing an ordered immutable sequence of\n+ * {@code short} values.\n+ *\/\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+public abstract class HalffloatVector extends AbstractVector<Float16> {\n+\n+    HalffloatVector(short[] vec) {\n+        super(vec);\n+    }\n+\n+    static final int FORBID_OPCODE_KIND = VO_NOFP;\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_FP16;\n+\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n+\n+    @ForceInline\n+    static int opCode(Operator op) {\n+        return VectorOperators.opCode(op, VO_OPCODE_VALID, FORBID_OPCODE_KIND);\n+    }\n+    @ForceInline\n+    static int opCode(Operator op, int requireKind) {\n+        requireKind |= VO_OPCODE_VALID;\n+        return VectorOperators.opCode(op, requireKind, FORBID_OPCODE_KIND);\n+    }\n+    @ForceInline\n+    static boolean opKind(Operator op, int bit) {\n+        return VectorOperators.opKind(op, bit);\n+    }\n+\n+    \/\/ Virtualized factories and operators,\n+    \/\/ coded with portable definitions.\n+    \/\/ These are all @ForceInline in case\n+    \/\/ they need to be used performantly.\n+    \/\/ The various shape-specific subclasses\n+    \/\/ also specialize them by wrapping\n+    \/\/ them in a call like this:\n+    \/\/    return (Byte128Vector)\n+    \/\/       super.bOp((Byte128Vector) o);\n+    \/\/ The purpose of that is to forcibly inline\n+    \/\/ the generic definition from this file\n+    \/\/ into a sharply-typed and size-specific\n+    \/\/ wrapper in the subclass file, so that\n+    \/\/ the JIT can specialize the code.\n+    \/\/ The code is only inlined and expanded\n+    \/\/ if it gets hot.  Think of it as a cheap\n+    \/\/ and lazy version of C++ templates.\n+\n+    \/\/ Virtualized getter\n+\n+    \/*package-private*\/\n+    abstract short[] vec();\n+\n+    \/\/ Virtualized constructors\n+\n+    \/**\n+     * Build a vector directly using my own constructor.\n+     * It is an error if the array is aliased elsewhere.\n+     *\/\n+    \/*package-private*\/\n+    abstract HalffloatVector vectorFactory(short[] vec);\n+\n+    \/**\n+     * Build a mask directly using my species.\n+     * It is an error if the array is aliased elsewhere.\n+     *\/\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    AbstractMask<Float16> maskFactory(boolean[] bits) {\n+        return vspecies().maskFactory(bits);\n+    }\n+\n+    \/\/ Constant loader (takes dummy as vector arg)\n+    interface FVOp {\n+        short apply(int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    HalffloatVector vOp(FVOp f) {\n+        short[] res = new short[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    @ForceInline\n+    final\n+    HalffloatVector vOp(VectorMask<Float16> m, FVOp f) {\n+        short[] res = new short[length()];\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/\/ Unary operator\n+\n+    \/*package-private*\/\n+    interface FUnOp {\n+        short apply(int i, short a);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector uOp(FUnOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector uOpTemplate(FUnOp f) {\n+        short[] vec = vec();\n+        short[] res = new short[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(i, vec[i]);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector uOp(VectorMask<Float16> m,\n+                             FUnOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector uOpTemplate(VectorMask<Float16> m,\n+                                     FUnOp f) {\n+        if (m == null) {\n+            return uOpTemplate(f);\n+        }\n+        short[] vec = vec();\n+        short[] res = new short[length()];\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = mbits[i] ? f.apply(i, vec[i]) : vec[i];\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/\/ Binary operator\n+\n+    \/*package-private*\/\n+    interface FBinOp {\n+        short apply(int i, short a, short b);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector bOp(Vector<Float16> o,\n+                             FBinOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector bOpTemplate(Vector<Float16> o,\n+                                     FBinOp f) {\n+        short[] res = new short[length()];\n+        short[] vec1 = this.vec();\n+        short[] vec2 = ((HalffloatVector)o).vec();\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(i, vec1[i], vec2[i]);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector bOp(Vector<Float16> o,\n+                             VectorMask<Float16> m,\n+                             FBinOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector bOpTemplate(Vector<Float16> o,\n+                                     VectorMask<Float16> m,\n+                                     FBinOp f) {\n+        if (m == null) {\n+            return bOpTemplate(o, f);\n+        }\n+        short[] res = new short[length()];\n+        short[] vec1 = this.vec();\n+        short[] vec2 = ((HalffloatVector)o).vec();\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i]) : vec1[i];\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    \/*package-private*\/\n+    interface FTriOp {\n+        short apply(int i, short a, short b, short c);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector tOp(Vector<Float16> o1,\n+                             Vector<Float16> o2,\n+                             FTriOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector tOpTemplate(Vector<Float16> o1,\n+                                     Vector<Float16> o2,\n+                                     FTriOp f) {\n+        short[] res = new short[length()];\n+        short[] vec1 = this.vec();\n+        short[] vec2 = ((HalffloatVector)o1).vec();\n+        short[] vec3 = ((HalffloatVector)o2).vec();\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(i, vec1[i], vec2[i], vec3[i]);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector tOp(Vector<Float16> o1,\n+                             Vector<Float16> o2,\n+                             VectorMask<Float16> m,\n+                             FTriOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector tOpTemplate(Vector<Float16> o1,\n+                                     Vector<Float16> o2,\n+                                     VectorMask<Float16> m,\n+                                     FTriOp f) {\n+        if (m == null) {\n+            return tOpTemplate(o1, o2, f);\n+        }\n+        short[] res = new short[length()];\n+        short[] vec1 = this.vec();\n+        short[] vec2 = ((HalffloatVector)o1).vec();\n+        short[] vec3 = ((HalffloatVector)o2).vec();\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i], vec3[i]) : vec1[i];\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/\/ Reduction operator\n+\n+    \/*package-private*\/\n+    abstract\n+    short rOp(short v, VectorMask<Float16> m, FBinOp f);\n+\n+    @ForceInline\n+    final\n+    short rOpTemplate(short v, VectorMask<Float16> m, FBinOp f) {\n+        if (m == null) {\n+            return rOpTemplate(v, f);\n+        }\n+        short[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            v = mbits[i] ? f.apply(i, v, vec[i]) : v;\n+        }\n+        return v;\n+    }\n+\n+    @ForceInline\n+    final\n+    short rOpTemplate(short v, FBinOp f) {\n+        short[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            v = f.apply(i, v, vec[i]);\n+        }\n+        return v;\n+    }\n+\n+    \/\/ Memory reference\n+\n+    \/*package-private*\/\n+    interface FLdOp<M> {\n+        short apply(M memory, int offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> HalffloatVector ldOp(M memory, int offset,\n+                                  FLdOp<M> f) {\n+        \/\/dummy; no vec = vec();\n+        short[] res = new short[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> HalffloatVector ldOp(M memory, int offset,\n+                                  VectorMask<Float16> m,\n+                                  FLdOp<M> f) {\n+        \/\/short[] vec = vec();\n+        short[] res = new short[length()];\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    interface FLdLongOp {\n+        short apply(MemorySegment memory, long offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    HalffloatVector ldLongOp(MemorySegment memory, long offset,\n+                                  FLdLongOp f) {\n+        \/\/dummy; no vec = vec();\n+        short[] res = new short[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    HalffloatVector ldLongOp(MemorySegment memory, long offset,\n+                                  VectorMask<Float16> m,\n+                                  FLdLongOp f) {\n+        \/\/short[] vec = vec();\n+        short[] res = new short[length()];\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    static short memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return ms.get(ELEMENT_LAYOUT, o + i * 2L);\n+    }\n+\n+    interface FStOp<M> {\n+        void apply(M memory, int offset, int i, short a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stOp(M memory, int offset,\n+                  FStOp<M> f) {\n+        short[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stOp(M memory, int offset,\n+                  VectorMask<Float16> m,\n+                  FStOp<M> f) {\n+        short[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n+    interface FStLongOp {\n+        void apply(MemorySegment memory, long offset, int i, short a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    void stLongOp(MemorySegment memory, long offset,\n+                  FStLongOp f) {\n+        short[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    void stLongOp(MemorySegment memory, long offset,\n+                  VectorMask<Float16> m,\n+                  FStLongOp f) {\n+        short[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n+    static void memorySegmentSet(MemorySegment ms, long o, int i, short e) {\n+        ms.set(ELEMENT_LAYOUT, o + i * 2L, e);\n+    }\n+\n+    \/\/ Binary test\n+\n+    \/*package-private*\/\n+    interface FBinTest {\n+        boolean apply(int cond, int i, short a, short b);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    AbstractMask<Float16> bTest(int cond,\n+                                  Vector<Float16> o,\n+                                  FBinTest f) {\n+        short[] vec1 = vec();\n+        short[] vec2 = ((HalffloatVector)o).vec();\n+        boolean[] bits = new boolean[length()];\n+        for (int i = 0; i < length(); i++){\n+            bits[i] = f.apply(cond, i, vec1[i], vec2[i]);\n+        }\n+        return maskFactory(bits);\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    abstract HalffloatSpecies vspecies();\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    static long toBits(short e) {\n+        return e;\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    static short fromBits(long bits) {\n+        return (short)bits;\n+    }\n+\n+    static HalffloatVector expandHelper(Vector<Float16> v, VectorMask<Float16> m) {\n+        VectorSpecies<Float16> vsp = m.vectorSpecies();\n+        HalffloatVector r  = (HalffloatVector) vsp.zero();\n+        HalffloatVector vi = (HalffloatVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static HalffloatVector compressHelper(Vector<Float16> v, VectorMask<Float16> m) {\n+        VectorSpecies<Float16> vsp = m.vectorSpecies();\n+        HalffloatVector r  = (HalffloatVector) vsp.zero();\n+        HalffloatVector vi = (HalffloatVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static HalffloatVector selectFromTwoVectorHelper(Vector<Float16> indexes, Vector<Float16> src1, Vector<Float16> src2) {\n+        int vlen = indexes.length();\n+        short[] res = new short[vlen];\n+        short[] vecPayload1 = ((HalffloatVector)indexes).vec();\n+        short[] vecPayload2 = ((HalffloatVector)src1).vec();\n+        short[] vecPayload3 = ((HalffloatVector)src2).vec();\n+        for (int i = 0; i < vlen; i++) {\n+            int index = shortBitsToFloat16(vecPayload1[i]).intValue();\n+            int wrapped_index = VectorIntrinsics.wrapToRange(index, 2 * vlen);\n+            res[i] = wrapped_index >= vlen ? vecPayload3[wrapped_index - vlen] : vecPayload2[wrapped_index];\n+        }\n+        return ((HalffloatVector)src1).vectorFactory(res);\n+    }\n+\n+    \/\/ Static factories (other than memory operations)\n+\n+    \/\/ Note: A surprising behavior in javadoc\n+    \/\/ sometimes makes a lone \/** {@inheritDoc} *\/\n+    \/\/ comment drop the method altogether,\n+    \/\/ apparently if the method mentions a\n+    \/\/ parameter or return type of Vector<Float16>\n+    \/\/ instead of Vector<E> as originally specified.\n+    \/\/ Adding an empty HTML fragment appears to\n+    \/\/ nudge javadoc into providing the desired\n+    \/\/ inherited documentation.  We use the HTML\n+    \/\/ comment <!--workaround--> for this.\n+\n+    \/**\n+     * Returns a vector of the given species\n+     * where all lane elements are set to\n+     * zero, the default primitive value.\n+     *\n+     * @param species species of the desired zero vector\n+     * @return a zero vector\n+     *\/\n+    @ForceInline\n+    public static HalffloatVector zero(VectorSpecies<Float16> species) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), short.class, VECTOR_OPER_TYPE, species.length(),\n+                        toBits((short) 0), MODE_BROADCAST, vsp,\n+                        ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+    }\n+\n+    \/**\n+     * Returns a vector of the same species as this one\n+     * where all lane elements are set to\n+     * the primitive value {@code e}.\n+     *\n+     * The contents of the current vector are discarded;\n+     * only the species is relevant to this operation.\n+     *\n+     * <p> This method returns the value of this expression:\n+     * {@code HalffloatVector.broadcast(this.species(), e)}.\n+     *\n+     * @apiNote\n+     * Unlike the similar method named {@code broadcast()}\n+     * in the supertype {@code Vector}, this method does not\n+     * need to validate its argument, and cannot throw\n+     * {@code IllegalArgumentException}.  This method is\n+     * therefore preferable to the supertype method.\n+     *\n+     * @param e the value to broadcast\n+     * @return a vector where all lane elements are set to\n+     *         the primitive value {@code e}\n+     * @see #broadcast(VectorSpecies,long)\n+     * @see Vector#broadcast(long)\n+     * @see VectorSpecies#broadcast(long)\n+     *\/\n+    public abstract HalffloatVector broadcast(short e);\n+\n+    \/**\n+     * Returns a vector of the given species\n+     * where all lane elements are set to\n+     * the primitive value {@code e}.\n+     *\n+     * @param species species of the desired vector\n+     * @param e the value to broadcast\n+     * @return a vector where all lane elements are set to\n+     *         the primitive value {@code e}\n+     * @see #broadcast(long)\n+     * @see Vector#broadcast(long)\n+     * @see VectorSpecies#broadcast(long)\n+     *\/\n+    @ForceInline\n+    public static HalffloatVector broadcast(VectorSpecies<Float16> species, short e) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.broadcast(e);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final HalffloatVector broadcastTemplate(short e) {\n+        HalffloatSpecies vsp = vspecies();\n+        return vsp.broadcast(e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote\n+     * When working with vector subtypes like {@code HalffloatVector},\n+     * {@linkplain #broadcast(short) the more strongly typed method}\n+     * is typically selected.  It can be explicitly selected\n+     * using a cast: {@code v.broadcast((short)e)}.\n+     * The two expressions will produce numerically identical results.\n+     *\/\n+    @Override\n+    public abstract HalffloatVector broadcast(long e);\n+\n+    \/**\n+     * Returns a vector of the given species\n+     * where all lane elements are set to\n+     * the primitive value {@code e}.\n+     *\n+     * The {@code long} value must be accurately representable\n+     * by the {@code ETYPE} of the vector species, so that\n+     * {@code e==(long)(ETYPE)e}.\n+     *\n+     * @param species species of the desired vector\n+     * @param e the value to broadcast\n+     * @return a vector where all lane elements are set to\n+     *         the primitive value {@code e}\n+     * @throws IllegalArgumentException\n+     *         if the given {@code long} value cannot\n+     *         be represented by the vector's {@code ETYPE}\n+     * @see #broadcast(VectorSpecies,short)\n+     * @see VectorSpecies#checkValue(long)\n+     *\/\n+    @ForceInline\n+    public static HalffloatVector broadcast(VectorSpecies<Float16> species, long e) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.broadcast(e);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final HalffloatVector broadcastTemplate(long e) {\n+        return vspecies().broadcast(e);\n+    }\n+\n+    \/\/ Unary lanewise support\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Unary op);\n+\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Unary op) {\n+        if (opKind(op, VO_SPECIAL)) {\n+            if (op == ZOMO) {\n+                return blend(broadcast(-1), compare(NE, 0));\n+            }\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return unaryMathOp(op);\n+            }\n+        }\n+        int opc = opCode(op);\n+        return VectorSupport.unaryOp(\n+            opc, getClass(), null, short.class, VECTOR_OPER_TYPE, length(),\n+            this, null,\n+            UN_IMPL.find(op, opc, HalffloatVector::unaryOperations));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Unary op,\n+                                  VectorMask<Float16> m);\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Unary op,\n+                                          Class<? extends VectorMask<Float16>> maskClass,\n+                                          VectorMask<Float16> m) {\n+        m.check(maskClass, this);\n+        if (opKind(op, VO_SPECIAL)) {\n+            if (op == ZOMO) {\n+                return blend(broadcast(-1), compare(NE, 0, m));\n+            }\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return blend(unaryMathOp(op), m);\n+            }\n+        }\n+        int opc = opCode(op);\n+        return VectorSupport.unaryOp(\n+            opc, getClass(), maskClass, short.class, VECTOR_OPER_TYPE, length(),\n+            this, m,\n+            UN_IMPL.find(op, opc, HalffloatVector::unaryOperations));\n+    }\n+\n+    @ForceInline\n+    final\n+    HalffloatVector unaryMathOp(VectorOperators.Unary op) {\n+        return VectorMathLibrary.unaryMathOp(op, opCode(op), species(), HalffloatVector::unaryOperations,\n+                                             this);\n+    }\n+\n+    private static final\n+    ImplCache<Unary, UnaryOperation<HalffloatVector, VectorMask<Float16>>>\n+        UN_IMPL = new ImplCache<>(Unary.class, HalffloatVector.class);\n+\n+    private static UnaryOperation<HalffloatVector, VectorMask<Float16>> unaryOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_NEG: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(-(shortBitsToFloat16((short)a).floatValue()))));\n+            case VECTOR_OP_ABS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.abs(shortBitsToFloat16((short)a))));\n+            case VECTOR_OP_SIN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.sin(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_COS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.cos(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_TAN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.tan(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_ASIN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.asin(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_ACOS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.acos(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_ATAN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.atan(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_EXP: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.exp(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_LOG: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.log(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_LOG10: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.log10(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_SQRT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.sqrt(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_CBRT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.cbrt(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_SINH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.sinh(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_COSH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.cosh(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_TANH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.tanh(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_EXPM1: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.expm1(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_LOG1P: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.log1p(shortBitsToFloat16(a).doubleValue()))));\n+            default: return null;\n+        }\n+    }\n+\n+    \/\/ Binary lanewise support\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     * @see #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  Vector<Float16> v);\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Binary op,\n+                                          Vector<Float16> v) {\n+        HalffloatVector that = (HalffloatVector) v;\n+        that.check(this);\n+\n+        if (opKind(op, VO_SPECIAL )) {\n+            if (op == FIRST_NONZERO) {\n+                VectorMask<Short> mask\n+                    = this.viewAsIntegralLanes().compare(EQ, (short) 0);\n+                return this.blend(that, mask.cast(vspecies()));\n+            }\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return binaryMathOp(op, that);\n+            }\n+        }\n+\n+        int opc = opCode(op);\n+        return VectorSupport.binaryOp(\n+            opc, getClass(), null, short.class, VECTOR_OPER_TYPE, length(),\n+            this, that, null,\n+            BIN_IMPL.find(op, opc, HalffloatVector::binaryOperations));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  Vector<Float16> v,\n+                                  VectorMask<Float16> m);\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Binary op,\n+                                          Class<? extends VectorMask<Float16>> maskClass,\n+                                          Vector<Float16> v, VectorMask<Float16> m) {\n+        HalffloatVector that = (HalffloatVector) v;\n+        that.check(this);\n+        m.check(maskClass, this);\n+\n+        if (opKind(op, VO_SPECIAL )) {\n+            if (op == FIRST_NONZERO) {\n+                ShortVector bits = this.viewAsIntegralLanes();\n+                VectorMask<Short> mask\n+                    = bits.compare(EQ, (short) 0, m.cast(bits.vspecies()));\n+                return this.blend(that, mask.cast(vspecies()));\n+            }\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return this.blend(binaryMathOp(op, that), m);\n+            }\n+\n+        }\n+\n+        int opc = opCode(op);\n+        return VectorSupport.binaryOp(\n+            opc, getClass(), maskClass, short.class, VECTOR_OPER_TYPE, length(),\n+            this, that, m,\n+            BIN_IMPL.find(op, opc, HalffloatVector::binaryOperations));\n+    }\n+\n+    @ForceInline\n+    final\n+    HalffloatVector binaryMathOp(VectorOperators.Binary op, HalffloatVector that) {\n+        return VectorMathLibrary.binaryMathOp(op, opCode(op), species(), HalffloatVector::binaryOperations,\n+                                              this, that);\n+    }\n+\n+    private static final\n+    ImplCache<Binary, BinaryOperation<HalffloatVector, VectorMask<Float16>>>\n+        BIN_IMPL = new ImplCache<>(Binary.class, HalffloatVector.class);\n+\n+    private static BinaryOperation<HalffloatVector, VectorMask<Float16>> binaryOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> float16ToShortBits(Float16.add(shortBitsToFloat16(a), shortBitsToFloat16(b))));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> float16ToShortBits(Float16.subtract(shortBitsToFloat16(a), shortBitsToFloat16(b))));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> float16ToShortBits(Float16.multiply(shortBitsToFloat16(a), shortBitsToFloat16(b))));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> float16ToShortBits(Float16.divide(shortBitsToFloat16(a), shortBitsToFloat16(b))));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> float16ToShortBits(Float16.max(shortBitsToFloat16(a), shortBitsToFloat16(b))));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> float16ToShortBits(Float16.min(shortBitsToFloat16(a), shortBitsToFloat16(b))));\n+            case VECTOR_OP_ATAN2: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> float16ToShortBits(Float16.valueOf(Math.atan2(shortBitsToFloat16(a).floatValue(), shortBitsToFloat16(b).floatValue()))));\n+            case VECTOR_OP_POW: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> float16ToShortBits(Float16.valueOf(Math.pow(shortBitsToFloat16(a).floatValue(), shortBitsToFloat16(b).floatValue()))));\n+            case VECTOR_OP_HYPOT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> float16ToShortBits(Float16.valueOf(Math.hypot(shortBitsToFloat16(a).floatValue(), shortBitsToFloat16(b).floatValue()))));\n+            default: return null;\n+        }\n+    }\n+\n+    \/\/ FIXME: Maybe all of the public final methods in this file (the\n+    \/\/ simple ones that just call lanewise) should be pushed down to\n+    \/\/ the X-VectorBits template.  They can't optimize properly at\n+    \/\/ this level, and must rely on inlining.  Does it work?\n+    \/\/ (If it works, of course keep the code here.)\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the value of a broadcast scalar.\n+     *\n+     * This is a lane-wise binary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e))}.\n+     *\n+     * @param op the operation used to process lane values\n+     * @param e the input scalar\n+     * @return the result of applying the operation lane-wise\n+     *         to the two input vectors\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  short e) {\n+        return lanewise(op, broadcast(e));\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the value of a broadcast scalar,\n+     * with selection of lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e), m)}.\n+     *\n+     * @param op the operation used to process lane values\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vector and the scalar\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Binary,Vector,VectorMask)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  short e,\n+                                  VectorMask<Float16> m) {\n+        return lanewise(op, broadcast(e), m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote\n+     * When working with vector subtypes like {@code HalffloatVector},\n+     * {@linkplain #lanewise(VectorOperators.Binary,short)\n+     * the more strongly typed method}\n+     * is typically selected.  It can be explicitly selected\n+     * using a cast: {@code v.lanewise(op,(short)e)}.\n+     * The two expressions will produce numerically identical results.\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  long e) {\n+        short e1 = (short) e;\n+        if ((long)e1 != e) {\n+            vspecies().checkValue(e);  \/\/ for exception\n+        }\n+        return lanewise(op, e1);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote\n+     * When working with vector subtypes like {@code HalffloatVector},\n+     * {@linkplain #lanewise(VectorOperators.Binary,short,VectorMask)\n+     * the more strongly typed method}\n+     * is typically selected.  It can be explicitly selected\n+     * using a cast: {@code v.lanewise(op,(short)e,m)}.\n+     * The two expressions will produce numerically identical results.\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  long e, VectorMask<Float16> m) {\n+        short e1 = (short) e;\n+        if ((long)e1 != e) {\n+            vspecies().checkValue(e);  \/\/ for exception\n+        }\n+        return lanewise(op, e1, m);\n+    }\n+\n+\n+    \/\/ Ternary lanewise support\n+\n+    \/\/ Ternary operators come in eight variations:\n+    \/\/   lanewise(op, [broadcast(e1)|v1], [broadcast(e2)|v2])\n+    \/\/   lanewise(op, [broadcast(e1)|v1], [broadcast(e2)|v2], mask)\n+\n+    \/\/ It is annoying to support all of these variations of masking\n+    \/\/ and broadcast, but it would be more surprising not to continue\n+    \/\/ the obvious pattern started by unary and binary.\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #lanewise(VectorOperators.Ternary,short,short,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,short,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,short,Vector,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,short,short)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,short)\n+     * @see #lanewise(VectorOperators.Ternary,short,Vector)\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Ternary op,\n+                                                  Vector<Float16> v1,\n+                                                  Vector<Float16> v2);\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Ternary op,\n+                                          Vector<Float16> v1,\n+                                          Vector<Float16> v2) {\n+        HalffloatVector that = (HalffloatVector) v1;\n+        HalffloatVector tother = (HalffloatVector) v2;\n+        \/\/ It's a word: https:\/\/www.dictionary.com\/browse\/tother\n+        \/\/ See also Chapter 11 of Dickens, Our Mutual Friend:\n+        \/\/ \"Totherest Governor,\" replied Mr Riderhood...\n+        that.check(this);\n+        tother.check(this);\n+        int opc = opCode(op);\n+        return VectorSupport.ternaryOp(\n+            opc, getClass(), null, short.class, VECTOR_OPER_TYPE, length(),\n+            this, that, tother, null,\n+            TERN_IMPL.find(op, opc, HalffloatVector::ternaryOperations));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #lanewise(VectorOperators.Ternary,short,short,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,short,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,short,Vector,VectorMask)\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Ternary op,\n+                                  Vector<Float16> v1,\n+                                  Vector<Float16> v2,\n+                                  VectorMask<Float16> m);\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Ternary op,\n+                                          Class<? extends VectorMask<Float16>> maskClass,\n+                                          Vector<Float16> v1,\n+                                          Vector<Float16> v2,\n+                                          VectorMask<Float16> m) {\n+        HalffloatVector that = (HalffloatVector) v1;\n+        HalffloatVector tother = (HalffloatVector) v2;\n+        \/\/ It's a word: https:\/\/www.dictionary.com\/browse\/tother\n+        \/\/ See also Chapter 11 of Dickens, Our Mutual Friend:\n+        \/\/ \"Totherest Governor,\" replied Mr Riderhood...\n+        that.check(this);\n+        tother.check(this);\n+        m.check(maskClass, this);\n+\n+        int opc = opCode(op);\n+        return VectorSupport.ternaryOp(\n+            opc, getClass(), maskClass, short.class, VECTOR_OPER_TYPE, length(),\n+            this, that, tother, m,\n+            TERN_IMPL.find(op, opc, HalffloatVector::ternaryOperations));\n+    }\n+\n+    private static final\n+    ImplCache<Ternary, TernaryOperation<HalffloatVector, VectorMask<Float16>>>\n+        TERN_IMPL = new ImplCache<>(Ternary.class, HalffloatVector.class);\n+\n+    private static TernaryOperation<HalffloatVector, VectorMask<Float16>> ternaryOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_FMA: return (v0, v1_, v2_, m) -> v0.tOp(v1_, v2_, m, (i, a, b, c) ->\n+                                        float16ToShortBits(Float16.fma(shortBitsToFloat16(a), shortBitsToFloat16(b), shortBitsToFloat16(c))));\n+            default: return null;\n+        }\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of two broadcast scalars.\n+     *\n+     * This is a lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e1), this.broadcast(e2))}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param e1 the first input scalar\n+     * @param e2 the second input scalar\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vector and the scalars\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector)\n+     * @see #lanewise(VectorOperators.Ternary,short,short,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,e1,e2)\n+                                  short e1,\n+                                  short e2) {\n+        return lanewise(op, broadcast(e1), broadcast(e2));\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of two broadcast scalars,\n+     * with selection of lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e1), this.broadcast(e2), m)}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param e1 the first input scalar\n+     * @param e2 the second input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vector and the scalars\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,short,short)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,e1,e2,m)\n+                                  short e1,\n+                                  short e2,\n+                                  VectorMask<Float16> m) {\n+        return lanewise(op, broadcast(e1), broadcast(e2), m);\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of another vector and a broadcast scalar.\n+     *\n+     * This is a lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, v1, this.broadcast(e2))}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param v1 the other input vector\n+     * @param e2 the input scalar\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vectors and the scalar\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,short,short)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,short,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,v1,e2)\n+                                  Vector<Float16> v1,\n+                                  short e2) {\n+        return lanewise(op, v1, broadcast(e2));\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of another vector and a broadcast scalar,\n+     * with selection of lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, v1, this.broadcast(e2), m)}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param v1 the other input vector\n+     * @param e2 the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vectors and the scalar\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector)\n+     * @see #lanewise(VectorOperators.Ternary,short,short,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,short)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,v1,e2,m)\n+                                  Vector<Float16> v1,\n+                                  short e2,\n+                                  VectorMask<Float16> m) {\n+        return lanewise(op, v1, broadcast(e2), m);\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of another vector and a broadcast scalar.\n+     *\n+     * This is a lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e1), v2)}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param e1 the input scalar\n+     * @param v2 the other input vector\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vectors and the scalar\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector)\n+     * @see #lanewise(VectorOperators.Ternary,short,Vector,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,e1,v2)\n+                                  short e1,\n+                                  Vector<Float16> v2) {\n+        return lanewise(op, broadcast(e1), v2);\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of another vector and a broadcast scalar,\n+     * with selection of lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e1), v2, m)}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param e1 the input scalar\n+     * @param v2 the other input vector\n+     * @param m the mask controlling lane selection\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vectors and the scalar\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,short,Vector)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,e1,v2,m)\n+                                  short e1,\n+                                  Vector<Float16> v2,\n+                                  VectorMask<Float16> m) {\n+        return lanewise(op, broadcast(e1), v2, m);\n+    }\n+\n+    \/\/ (Thus endeth the Great and Mighty Ternary Ogdoad.)\n+    \/\/ https:\/\/en.wikipedia.org\/wiki\/Ogdoad\n+\n+    \/\/\/ FULL-SERVICE BINARY METHODS: ADD, SUB, MUL, DIV\n+    \/\/\n+    \/\/ These include masked and non-masked versions.\n+    \/\/ This subclass adds broadcast (masked or not).\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #add(short)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector add(Vector<Float16> v) {\n+        return lanewise(ADD, v);\n+    }\n+\n+    \/**\n+     * Adds this vector to the broadcast of an input scalar.\n+     *\n+     * This is a lane-wise binary operation which applies\n+     * the primitive addition operation ({@code +}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short)\n+     *    lanewise}{@code (}{@link VectorOperators#ADD\n+     *    ADD}{@code , e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result of adding each lane of this vector to the scalar\n+     * @see #add(Vector)\n+     * @see #broadcast(short)\n+     * @see #add(short,VectorMask)\n+     * @see VectorOperators#ADD\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector add(short e) {\n+        return lanewise(ADD, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #add(short,VectorMask)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector add(Vector<Float16> v,\n+                                          VectorMask<Float16> m) {\n+        return lanewise(ADD, v, m);\n+    }\n+\n+    \/**\n+     * Adds this vector to the broadcast of an input scalar,\n+     * selecting lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the primitive addition operation ({@code +}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *    lanewise}{@code (}{@link VectorOperators#ADD\n+     *    ADD}{@code , s, m)}.\n+     *\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of adding each lane of this vector to the scalar\n+     * @see #add(Vector,VectorMask)\n+     * @see #broadcast(short)\n+     * @see #add(short)\n+     * @see VectorOperators#ADD\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector add(short e,\n+                                          VectorMask<Float16> m) {\n+        return lanewise(ADD, e, m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #sub(short)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector sub(Vector<Float16> v) {\n+        return lanewise(SUB, v);\n+    }\n+\n+    \/**\n+     * Subtracts an input scalar from this vector.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the primitive subtraction operation ({@code -}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short)\n+     *    lanewise}{@code (}{@link VectorOperators#SUB\n+     *    SUB}{@code , e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result of subtracting the scalar from each lane of this vector\n+     * @see #sub(Vector)\n+     * @see #broadcast(short)\n+     * @see #sub(short,VectorMask)\n+     * @see VectorOperators#SUB\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector sub(short e) {\n+        return lanewise(SUB, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #sub(short,VectorMask)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector sub(Vector<Float16> v,\n+                                          VectorMask<Float16> m) {\n+        return lanewise(SUB, v, m);\n+    }\n+\n+    \/**\n+     * Subtracts an input scalar from this vector\n+     * under the control of a mask.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the primitive subtraction operation ({@code -}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *    lanewise}{@code (}{@link VectorOperators#SUB\n+     *    SUB}{@code , s, m)}.\n+     *\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of subtracting the scalar from each lane of this vector\n+     * @see #sub(Vector,VectorMask)\n+     * @see #broadcast(short)\n+     * @see #sub(short)\n+     * @see VectorOperators#SUB\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector sub(short e,\n+                                          VectorMask<Float16> m) {\n+        return lanewise(SUB, e, m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #mul(short)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector mul(Vector<Float16> v) {\n+        return lanewise(MUL, v);\n+    }\n+\n+    \/**\n+     * Multiplies this vector by the broadcast of an input scalar.\n+     *\n+     * This is a lane-wise binary operation which applies\n+     * the primitive multiplication operation ({@code *}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short)\n+     *    lanewise}{@code (}{@link VectorOperators#MUL\n+     *    MUL}{@code , e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result of multiplying this vector by the given scalar\n+     * @see #mul(Vector)\n+     * @see #broadcast(short)\n+     * @see #mul(short,VectorMask)\n+     * @see VectorOperators#MUL\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector mul(short e) {\n+        return lanewise(MUL, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #mul(short,VectorMask)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector mul(Vector<Float16> v,\n+                                          VectorMask<Float16> m) {\n+        return lanewise(MUL, v, m);\n+    }\n+\n+    \/**\n+     * Multiplies this vector by the broadcast of an input scalar,\n+     * selecting lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the primitive multiplication operation ({@code *}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *    lanewise}{@code (}{@link VectorOperators#MUL\n+     *    MUL}{@code , s, m)}.\n+     *\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of muling each lane of this vector to the scalar\n+     * @see #mul(Vector,VectorMask)\n+     * @see #broadcast(short)\n+     * @see #mul(short)\n+     * @see VectorOperators#MUL\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector mul(short e,\n+                                          VectorMask<Float16> m) {\n+        return lanewise(MUL, e, m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote Because the underlying scalar operator is an IEEE\n+     * floating point number, division by zero in fact will\n+     * not throw an exception, but will yield a signed\n+     * infinity or NaN.\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector div(Vector<Float16> v) {\n+        return lanewise(DIV, v);\n+    }\n+\n+    \/**\n+     * Divides this vector by the broadcast of an input scalar.\n+     *\n+     * This is a lane-wise binary operation which applies\n+     * the primitive division operation ({@code \/}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short)\n+     *    lanewise}{@code (}{@link VectorOperators#DIV\n+     *    DIV}{@code , e)}.\n+     *\n+     * @apiNote Because the underlying scalar operator is an IEEE\n+     * floating point number, division by zero in fact will\n+     * not throw an exception, but will yield a signed\n+     * infinity or NaN.\n+     *\n+     * @param e the input scalar\n+     * @return the result of dividing each lane of this vector by the scalar\n+     * @see #div(Vector)\n+     * @see #broadcast(short)\n+     * @see #div(short,VectorMask)\n+     * @see VectorOperators#DIV\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector div(short e) {\n+        return lanewise(DIV, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #div(short,VectorMask)\n+     * @apiNote Because the underlying scalar operator is an IEEE\n+     * floating point number, division by zero in fact will\n+     * not throw an exception, but will yield a signed\n+     * infinity or NaN.\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector div(Vector<Float16> v,\n+                                          VectorMask<Float16> m) {\n+        return lanewise(DIV, v, m);\n+    }\n+\n+    \/**\n+     * Divides this vector by the broadcast of an input scalar,\n+     * selecting lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the primitive division operation ({@code \/}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *    lanewise}{@code (}{@link VectorOperators#DIV\n+     *    DIV}{@code , s, m)}.\n+     *\n+     * @apiNote Because the underlying scalar operator is an IEEE\n+     * floating point number, division by zero in fact will\n+     * not throw an exception, but will yield a signed\n+     * infinity or NaN.\n+     *\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of dividing each lane of this vector by the scalar\n+     * @see #div(Vector,VectorMask)\n+     * @see #broadcast(short)\n+     * @see #div(short)\n+     * @see VectorOperators#DIV\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector div(short e,\n+                                          VectorMask<Float16> m) {\n+        return lanewise(DIV, e, m);\n+    }\n+\n+    \/\/\/ END OF FULL-SERVICE BINARY METHODS\n+\n+    \/\/\/ SECOND-TIER BINARY METHODS\n+    \/\/\n+    \/\/ There are no masked versions.\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote\n+     * For this method, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from, and less\n+     * than the default value (positive zero).\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector min(Vector<Float16> v) {\n+        return lanewise(MIN, v);\n+    }\n+\n+    \/\/ FIXME:  \"broadcast of an input scalar\" is really wordy.  Reduce?\n+    \/**\n+     * Computes the smaller of this vector and the broadcast of an input scalar.\n+     *\n+     * This is a lane-wise binary operation which applies the\n+     * operation {@code Math.min()} to each pair of\n+     * corresponding lane values.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short)\n+     *    lanewise}{@code (}{@link VectorOperators#MIN\n+     *    MIN}{@code , e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result of multiplying this vector by the given scalar\n+     * @see #min(Vector)\n+     * @see #broadcast(short)\n+     * @see VectorOperators#MIN\n+     * @see #lanewise(VectorOperators.Binary,short,VectorMask)\n+     * @apiNote\n+     * For this method, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from, and less\n+     * than the default value (positive zero).\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector min(short e) {\n+        return lanewise(MIN, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote\n+     * For this method, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from, and less\n+     * than the default value (positive zero).\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector max(Vector<Float16> v) {\n+        return lanewise(MAX, v);\n+    }\n+\n+    \/**\n+     * Computes the larger of this vector and the broadcast of an input scalar.\n+     *\n+     * This is a lane-wise binary operation which applies the\n+     * operation {@code Math.max()} to each pair of\n+     * corresponding lane values.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short)\n+     *    lanewise}{@code (}{@link VectorOperators#MAX\n+     *    MAX}{@code , e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result of multiplying this vector by the given scalar\n+     * @see #max(Vector)\n+     * @see #broadcast(short)\n+     * @see VectorOperators#MAX\n+     * @see #lanewise(VectorOperators.Binary,short,VectorMask)\n+     * @apiNote\n+     * For this method, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from, and less\n+     * than the default value (positive zero).\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector max(short e) {\n+        return lanewise(MAX, e);\n+    }\n+\n+\n+    \/\/ common FP operator: pow\n+    \/**\n+     * Raises this vector to the power of a second input vector.\n+     *\n+     * This is a lane-wise binary operation which applies an operation\n+     * conforming to the specification of\n+     * {@link Math#pow Math.pow(a,b)}\n+     * to each pair of corresponding lane values.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,Vector)\n+     *    lanewise}{@code (}{@link VectorOperators#POW\n+     *    POW}{@code , b)}.\n+     *\n+     * <p>\n+     * This is not a full-service named operation like\n+     * {@link #add(Vector) add}.  A masked version of\n+     * this operation is not directly available\n+     * but may be obtained via the masked version of\n+     * {@code lanewise}.\n+     *\n+     * @param b a vector exponent by which to raise this vector\n+     * @return the {@code b}-th power of this vector\n+     * @see #pow(short)\n+     * @see VectorOperators#POW\n+     * @see #lanewise(VectorOperators.Binary,Vector,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector pow(Vector<Float16> b) {\n+        return lanewise(POW, b);\n+    }\n+\n+    \/**\n+     * Raises this vector to a scalar power.\n+     *\n+     * This is a lane-wise binary operation which applies an operation\n+     * conforming to the specification of\n+     * {@link Math#pow Math.pow(a,b)}\n+     * to each pair of corresponding lane values.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,Vector)\n+     *    lanewise}{@code (}{@link VectorOperators#POW\n+     *    POW}{@code , b)}.\n+     *\n+     * @param b a scalar exponent by which to raise this vector\n+     * @return the {@code b}-th power of this vector\n+     * @see #pow(Vector)\n+     * @see VectorOperators#POW\n+     * @see #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector pow(short b) {\n+        return lanewise(POW, b);\n+    }\n+\n+    \/\/\/ UNARY METHODS\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatVector neg() {\n+        return lanewise(NEG);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatVector abs() {\n+        return lanewise(ABS);\n+    }\n+\n+\n+\n+    \/\/ sqrt\n+    \/**\n+     * Computes the square root of this vector.\n+     *\n+     * This is a lane-wise unary operation which applies an operation\n+     * conforming to the specification of\n+     * {@link Math#sqrt Math.sqrt(a)}\n+     * to each lane value.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Unary)\n+     *    lanewise}{@code (}{@link VectorOperators#SQRT\n+     *    SQRT}{@code )}.\n+     *\n+     * @return the square root of this vector\n+     * @see VectorOperators#SQRT\n+     * @see #lanewise(VectorOperators.Unary,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector sqrt() {\n+        return lanewise(SQRT);\n+    }\n+\n+    \/\/\/ COMPARISONS\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    VectorMask<Float16> eq(Vector<Float16> v) {\n+        return compare(EQ, v);\n+    }\n+\n+    \/**\n+     * Tests if this vector is equal to an input scalar.\n+     *\n+     * This is a lane-wise binary test operation which applies\n+     * the primitive equals operation ({@code ==}) to each lane.\n+     * The result is the same as {@code compare(VectorOperators.Comparison.EQ, e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result mask of testing if this vector\n+     *         is equal to {@code e}\n+     * @see #compare(VectorOperators.Comparison,short)\n+     *\/\n+    @ForceInline\n+    public final\n+    VectorMask<Float16> eq(short e) {\n+        return compare(EQ, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    VectorMask<Float16> lt(Vector<Float16> v) {\n+        return compare(LT, v);\n+    }\n+\n+    \/**\n+     * Tests if this vector is less than an input scalar.\n+     *\n+     * This is a lane-wise binary test operation which applies\n+     * the primitive less than operation ({@code <}) to each lane.\n+     * The result is the same as {@code compare(VectorOperators.LT, e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the mask result of testing if this vector\n+     *         is less than the input scalar\n+     * @see #compare(VectorOperators.Comparison,short)\n+     *\/\n+    @ForceInline\n+    public final\n+    VectorMask<Float16> lt(short e) {\n+        return compare(LT, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    VectorMask<Float16> test(VectorOperators.Test op);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    M testTemplate(Class<M> maskType, Test op) {\n+        HalffloatSpecies vsp = vspecies();\n+        if (opKind(op, VO_SPECIAL)) {\n+            ShortVector bits = this.viewAsIntegralLanes();\n+            VectorMask<Short> m;\n+            if (op == IS_DEFAULT) {\n+                m = bits.compare(EQ, (short) 0);\n+            } else if (op == IS_NEGATIVE) {\n+                m = bits.compare(LT, (short) 0);\n+            }\n+            else if (op == IS_FINITE ||\n+                     op == IS_NAN ||\n+                     op == IS_INFINITE) {\n+                \/\/ first kill the sign:\n+                bits = bits.and(Short.MAX_VALUE);\n+                \/\/ next find the bit pattern for infinity:\n+                short infbits = (short) toBits(float16ToShortBits(Float16.POSITIVE_INFINITY));\n+                \/\/ now compare:\n+                if (op == IS_FINITE) {\n+                    m = bits.compare(LT, infbits);\n+                } else if (op == IS_NAN) {\n+                    m = bits.compare(GT, infbits);\n+                } else {\n+                    m = bits.compare(EQ, infbits);\n+                }\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m.cast(vsp));\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    VectorMask<Float16> test(VectorOperators.Test op,\n+                                  VectorMask<Float16> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    M testTemplate(Class<M> maskType, Test op, M mask) {\n+        HalffloatSpecies vsp = vspecies();\n+        mask.check(maskType, this);\n+        if (opKind(op, VO_SPECIAL)) {\n+            ShortVector bits = this.viewAsIntegralLanes();\n+            VectorMask<Short> m = mask.cast(ShortVector.species(shape()));\n+            if (op == IS_DEFAULT) {\n+                m = bits.compare(EQ, (short) 0, m);\n+            } else if (op == IS_NEGATIVE) {\n+                m = bits.compare(LT, (short) 0, m);\n+            }\n+            else if (op == IS_FINITE ||\n+                     op == IS_NAN ||\n+                     op == IS_INFINITE) {\n+                \/\/ first kill the sign:\n+                bits = bits.and(Short.MAX_VALUE);\n+                \/\/ next find the bit pattern for infinity:\n+                short infbits = (short) toBits(float16ToShortBits(Float16.POSITIVE_INFINITY));\n+                \/\/ now compare:\n+                if (op == IS_FINITE) {\n+                    m = bits.compare(LT, infbits, m);\n+                } else if (op == IS_NAN) {\n+                    m = bits.compare(GT, infbits, m);\n+                } else {\n+                    m = bits.compare(EQ, infbits, m);\n+                }\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m.cast(vsp));\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    VectorMask<Float16> compare(VectorOperators.Comparison op, Vector<Float16> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    M compareTemplate(Class<M> maskType, Comparison op, Vector<Float16> v) {\n+        HalffloatVector that = (HalffloatVector) v;\n+        that.check(this);\n+        int opc = opCode(op);\n+        return VectorSupport.compare(\n+            opc, getClass(), maskType, short.class, VECTOR_OPER_TYPE, length(),\n+            this, that, null,\n+            (cond, v0, v1, m1) -> {\n+                AbstractMask<Float16> m\n+                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                               -> compareWithOp(cond, a, b));\n+                @SuppressWarnings(\"unchecked\")\n+                M m2 = (M) m;\n+                return m2;\n+            });\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    M compareTemplate(Class<M> maskType, Comparison op, Vector<Float16> v, M m) {\n+        HalffloatVector that = (HalffloatVector) v;\n+        that.check(this);\n+        m.check(maskType, this);\n+        int opc = opCode(op);\n+        return VectorSupport.compare(\n+            opc, getClass(), maskType, short.class, VECTOR_OPER_TYPE, length(),\n+            this, that, m,\n+            (cond, v0, v1, m1) -> {\n+                AbstractMask<Float16> cmpM\n+                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                               -> compareWithOp(cond, a, b));\n+                @SuppressWarnings(\"unchecked\")\n+                M m2 = (M) cmpM.and(m1);\n+                return m2;\n+            });\n+    }\n+\n+    @ForceInline\n+    private static boolean compareWithOp(int cond, short a, short b) {\n+        return switch (cond) {\n+            case BT_eq -> Float.float16ToFloat(a) == Float.float16ToFloat(b);\n+            case BT_ne -> Float.float16ToFloat(a) != Float.float16ToFloat(b);\n+            case BT_lt -> Float.float16ToFloat(a) < Float.float16ToFloat(b);\n+            case BT_le -> Float.float16ToFloat(a) <= Float.float16ToFloat(b);\n+            case BT_gt -> Float.float16ToFloat(a) > Float.float16ToFloat(b);\n+            case BT_ge -> Float.float16ToFloat(a) >= Float.float16ToFloat(b);\n+            default -> throw new AssertionError();\n+        };\n+    }\n+\n+    \/**\n+     * Tests this vector by comparing it with an input scalar,\n+     * according to the given comparison operation.\n+     *\n+     * This is a lane-wise binary test operation which applies\n+     * the comparison operation to each lane.\n+     * <p>\n+     * The result is the same as\n+     * {@code compare(op, broadcast(species(), e))}.\n+     * That is, the scalar may be regarded as broadcast to\n+     * a vector of the same species, and then compared\n+     * against the original vector, using the selected\n+     * comparison operation.\n+     *\n+     * @param op the operation used to compare lane values\n+     * @param e the input scalar\n+     * @return the mask result of testing lane-wise if this vector\n+     *         compares to the input, according to the selected\n+     *         comparison operator\n+     * @see HalffloatVector#compare(VectorOperators.Comparison,Vector)\n+     * @see #eq(short)\n+     * @see #lt(short)\n+     *\/\n+    public abstract\n+    VectorMask<Float16> compare(Comparison op, short e);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    M compareTemplate(Class<M> maskType, Comparison op, short e) {\n+        return compareTemplate(maskType, op, broadcast(e));\n+    }\n+\n+    \/**\n+     * Tests this vector by comparing it with an input scalar,\n+     * according to the given comparison operation,\n+     * in lanes selected by a mask.\n+     *\n+     * This is a masked lane-wise binary test operation which applies\n+     * to each pair of corresponding lane values.\n+     *\n+     * The returned result is equal to the expression\n+     * {@code compare(op,s).and(m)}.\n+     *\n+     * @param op the operation used to compare lane values\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the mask result of testing lane-wise if this vector\n+     *         compares to the input, according to the selected\n+     *         comparison operator,\n+     *         and only in the lanes selected by the mask\n+     * @see HalffloatVector#compare(VectorOperators.Comparison,Vector,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final VectorMask<Float16> compare(VectorOperators.Comparison op,\n+                                               short e,\n+                                               VectorMask<Float16> m) {\n+        return compare(op, broadcast(e), m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    VectorMask<Float16> compare(Comparison op, long e);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    M compareTemplate(Class<M> maskType, Comparison op, long e) {\n+        return compareTemplate(maskType, op, broadcast(e));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    VectorMask<Float16> compare(Comparison op, long e, VectorMask<Float16> m) {\n+        return compare(op, broadcast(e), m);\n+    }\n+\n+\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override public abstract\n+    HalffloatVector blend(Vector<Float16> v, VectorMask<Float16> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    HalffloatVector\n+    blendTemplate(Class<M> maskType, HalffloatVector v, M m) {\n+        v.check(this);\n+        return VectorSupport.blend(\n+            getClass(), maskType, short.class, VECTOR_OPER_TYPE, length(),\n+            this, v, m,\n+            (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override public abstract HalffloatVector addIndex(int scale);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final HalffloatVector addIndexTemplate(int scale) {\n+        HalffloatSpecies vsp = vspecies();\n+        \/\/ make sure VLENGTH*scale doesn't overflow:\n+        vsp.checkScale(scale);\n+        return VectorSupport.indexVector(\n+            getClass(), short.class, VECTOR_OPER_TYPE, length(),\n+            this, scale, vsp,\n+            (v, scale_, s)\n+            -> {\n+                \/\/ If the platform doesn't support an INDEX\n+                \/\/ instruction directly, load IOTA from memory\n+                \/\/ and multiply.\n+                HalffloatVector iota = s.iota();\n+                short sc = (short) scale_;\n+                return v.add(sc == 1 ? iota : iota.mul(float16ToShortBits(Float16.valueOf(sc))));\n+            });\n+    }\n+\n+    \/**\n+     * Replaces selected lanes of this vector with\n+     * a scalar value\n+     * under the control of a mask.\n+     *\n+     * This is a masked lane-wise binary operation which\n+     * selects each lane value from one or the other input.\n+     *\n+     * The returned result is equal to the expression\n+     * {@code blend(broadcast(e),m)}.\n+     *\n+     * @param e the input scalar, containing the replacement lane value\n+     * @param m the mask controlling lane selection of the scalar\n+     * @return the result of blending the lane elements of this vector with\n+     *         the scalar value\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector blend(short e,\n+                                            VectorMask<Float16> m) {\n+        return blend(broadcast(e), m);\n+    }\n+\n+    \/**\n+     * Replaces selected lanes of this vector with\n+     * a scalar value\n+     * under the control of a mask.\n+     *\n+     * This is a masked lane-wise binary operation which\n+     * selects each lane value from one or the other input.\n+     *\n+     * The returned result is equal to the expression\n+     * {@code blend(broadcast(e),m)}.\n+     *\n+     * @param e the input scalar, containing the replacement lane value\n+     * @param m the mask controlling lane selection of the scalar\n+     * @return the result of blending the lane elements of this vector with\n+     *         the scalar value\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector blend(long e,\n+                                            VectorMask<Float16> m) {\n+        return blend(broadcast(e), m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector slice(int origin, Vector<Float16> v1);\n+\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    HalffloatVector sliceTemplate(int origin, Vector<Float16> v1) {\n+        HalffloatVector that = (HalffloatVector) v1;\n+        that.check(this);\n+        Objects.checkIndex(origin, length() + 1);\n+        ShortVector iotaVector = (ShortVector) iotaShuffle().toBitsVector();\n+        ShortVector filter = ShortVector.broadcast((ShortVector.ShortSpecies) vspecies().asIntegral(), (short)(length() - origin));\n+        VectorMask<Float16> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vspecies());\n+        AbstractShuffle<Float16> iota = iotaShuffle(origin, 1, true);\n+        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatVector slice(int origin,\n+                               Vector<Float16> w,\n+                               VectorMask<Float16> m) {\n+        return broadcast(0).blend(slice(origin, w), m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector slice(int origin);\n+\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    HalffloatVector sliceTemplate(int origin) {\n+        Objects.checkIndex(origin, length() + 1);\n+        ShortVector iotaVector = (ShortVector) iotaShuffle().toBitsVector();\n+        ShortVector filter = ShortVector.broadcast((ShortVector.ShortSpecies) vspecies().asIntegral(), (short)(length() - origin));\n+        VectorMask<Float16> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vspecies());\n+        AbstractShuffle<Float16> iota = iotaShuffle(origin, 1, true);\n+        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector unslice(int origin, Vector<Float16> w, int part);\n+\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    HalffloatVector\n+    unsliceTemplate(int origin, Vector<Float16> w, int part) {\n+        HalffloatVector that = (HalffloatVector) w;\n+        that.check(this);\n+        Objects.checkIndex(origin, length() + 1);\n+        ShortVector iotaVector = (ShortVector) iotaShuffle().toBitsVector();\n+        ShortVector filter = ShortVector.broadcast((ShortVector.ShortSpecies) vspecies().asIntegral(), (short)origin);\n+        VectorMask<Float16> blendMask = iotaVector.compare((part == 0) ? VectorOperators.GE : VectorOperators.LT, filter).cast(vspecies());\n+        AbstractShuffle<Float16> iota = iotaShuffle(-origin, 1, true);\n+        return that.blend(this.rearrange(iota), blendMask);\n+    }\n+\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    <M extends VectorMask<Float16>>\n+    HalffloatVector\n+    unsliceTemplate(Class<M> maskType, int origin, Vector<Float16> w, int part, M m) {\n+        HalffloatVector that = (HalffloatVector) w;\n+        that.check(this);\n+        HalffloatVector slice = that.sliceTemplate(origin, that);\n+        slice = slice.blendTemplate(maskType, this, m);\n+        return slice.unsliceTemplate(origin, w, part);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector unslice(int origin, Vector<Float16> w, int part, VectorMask<Float16> m);\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector unslice(int origin);\n+\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    HalffloatVector\n+    unsliceTemplate(int origin) {\n+        Objects.checkIndex(origin, length() + 1);\n+        ShortVector iotaVector = (ShortVector) iotaShuffle().toBitsVector();\n+        ShortVector filter = ShortVector.broadcast((ShortVector.ShortSpecies) vspecies().asIntegral(), (short)origin);\n+        VectorMask<Float16> blendMask = iotaVector.compare(VectorOperators.GE, filter).cast(vspecies());\n+        AbstractShuffle<Float16> iota = iotaShuffle(-origin, 1, true);\n+        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    }\n+\n+    private ArrayIndexOutOfBoundsException\n+    wrongPartForSlice(int part) {\n+        String msg = String.format(\"bad part number %d for slice operation\",\n+                                   part);\n+        return new ArrayIndexOutOfBoundsException(msg);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector rearrange(VectorShuffle<Float16> shuffle);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <S extends VectorShuffle<Float16>>\n+    HalffloatVector rearrangeTemplate(Class<S> shuffletype, S shuffle) {\n+        Objects.requireNonNull(shuffle);\n+        return VectorSupport.rearrangeOp(\n+            getClass(), shuffletype, null, short.class, VECTOR_OPER_TYPE, length(),\n+            this, shuffle, null,\n+            (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n+                return v1.lane(ei);\n+            }));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector rearrange(VectorShuffle<Float16> s,\n+                                   VectorMask<Float16> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <S extends VectorShuffle<Float16>, M extends VectorMask<Float16>>\n+    HalffloatVector rearrangeTemplate(Class<S> shuffletype,\n+                                           Class<M> masktype,\n+                                           S shuffle,\n+                                           M m) {\n+        Objects.requireNonNull(shuffle);\n+        m.check(masktype, this);\n+        return VectorSupport.rearrangeOp(\n+                   getClass(), shuffletype, masktype, short.class, VECTOR_OPER_TYPE, length(),\n+                   this, shuffle, m,\n+                   (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                        int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n+                        return !m_.laneIsSet(i) ? 0 : v1.lane(ei);\n+                   }));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector rearrange(VectorShuffle<Float16> s,\n+                                   Vector<Float16> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <S extends VectorShuffle<Float16>>\n+    HalffloatVector rearrangeTemplate(Class<S> shuffletype,\n+                                           S shuffle,\n+                                           HalffloatVector v) {\n+        VectorMask<Float16> valid = shuffle.laneIsValid();\n+        HalffloatVector r0 =\n+            VectorSupport.rearrangeOp(\n+                getClass(), shuffletype, null, short.class, VECTOR_OPER_TYPE, length(),\n+                this, shuffle, null,\n+                (v0, s_, m_) -> v0.uOp((i, a) -> {\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());\n+                    return v0.lane(ei);\n+                }));\n+        HalffloatVector r1 =\n+            VectorSupport.rearrangeOp(\n+                getClass(), shuffletype, null, short.class, VECTOR_OPER_TYPE, length(),\n+                v, shuffle, null,\n+                (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n+                    return v1.lane(ei);\n+                }));\n+        return r1.blend(r0, valid);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle0(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @ForceInline\n+    final <F>\n+    VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap) {\n+        assert(dsp.elementSize() == vspecies().elementSize());\n+        ShortVector idx = convert(VectorOperators.H2S, 0).reinterpretAsShorts();\n+        ShortVector wrapped = idx.lanewise(VectorOperators.AND, length() - 1);\n+        if (!wrap) {\n+            ShortVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, length());\n+            VectorMask<Short> inBound = wrapped.compare(VectorOperators.EQ, idx);\n+            wrapped = wrappedEx.blend(wrapped, inBound);\n+        }\n+        return wrapped.bitsToShuffle(dsp);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector compress(VectorMask<Float16> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Float16>>\n+    HalffloatVector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (HalffloatVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,\n+                                                        short.class, VECTOR_OPER_TYPE, length(), this, m,\n+                                                        (v1, m1) -> compressHelper(v1, m1));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector expand(VectorMask<Float16> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Float16>>\n+    HalffloatVector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (HalffloatVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,\n+                                                        short.class, VECTOR_OPER_TYPE, length(), this, m,\n+                                                        (v1, m1) -> expandHelper(v1, m1));\n+    }\n+\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector selectFrom(Vector<Float16> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final HalffloatVector selectFromTemplate(HalffloatVector v) {\n+        return (HalffloatVector)VectorSupport.selectFromOp(getClass(), null, short.class, VECTOR_OPER_TYPE,\n+                                                        length(), this, v, null,\n+                                                        (v1, v2, _m) ->\n+                                                         v2.rearrange(v1.toShuffle()));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector selectFrom(Vector<Float16> s, VectorMask<Float16> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    HalffloatVector selectFromTemplate(HalffloatVector v,\n+                                            Class<M> masktype, M m) {\n+        m.check(masktype, this);\n+        return (HalffloatVector)VectorSupport.selectFromOp(getClass(), masktype, short.class, VECTOR_OPER_TYPE,\n+                                                        length(), this, v, m,\n+                                                        (v1, v2, _m) ->\n+                                                         v2.rearrange(v1.toShuffle(), _m));\n+    }\n+\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector selectFrom(Vector<Float16> v1, Vector<Float16> v2);\n+\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final HalffloatVector selectFromTemplate(HalffloatVector v1, HalffloatVector v2) {\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), short.class, VECTOR_OPER_TYPE, length(), this, v1, v2,\n+                                                   (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));\n+    }\n+\n+    \/\/\/ Ternary operations\n+\n+\n+    \/**\n+     * Multiplies this vector by a second input vector, and sums\n+     * the result with a third.\n+     *\n+     * Extended precision is used for the intermediate result,\n+     * avoiding possible loss of precision from rounding once\n+     * for each of the two operations.\n+     * The result is numerically close to {@code this.mul(b).add(c)},\n+     * and is typically closer to the true mathematical result.\n+     *\n+     * This is a lane-wise ternary operation which applies an operation\n+     * conforming to the specification of\n+     * {@link Math#fma(short,short,short) Math.fma(a,b,c)}\n+     * to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Ternary,Vector,Vector)\n+     *    lanewise}{@code (}{@link VectorOperators#FMA\n+     *    FMA}{@code , b, c)}.\n+     *\n+     * @param b the second input vector, supplying multiplier values\n+     * @param c the third input vector, supplying addend values\n+     * @return the product of this vector and the second input vector\n+     *         summed with the third input vector, using extended precision\n+     *         for the intermediate result\n+     * @see #fma(short,short)\n+     * @see VectorOperators#FMA\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector fma(Vector<Float16> b, Vector<Float16> c) {\n+        return lanewise(FMA, b, c);\n+    }\n+\n+    \/**\n+     * Multiplies this vector by a scalar multiplier, and sums\n+     * the result with a scalar addend.\n+     *\n+     * Extended precision is used for the intermediate result,\n+     * avoiding possible loss of precision from rounding once\n+     * for each of the two operations.\n+     * The result is numerically close to {@code this.mul(b).add(c)},\n+     * and is typically closer to the true mathematical result.\n+     *\n+     * This is a lane-wise ternary operation which applies an operation\n+     * conforming to the specification of\n+     * {@link Math#fma(short,short,short) Math.fma(a,b,c)}\n+     * to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Ternary,Vector,Vector)\n+     *    lanewise}{@code (}{@link VectorOperators#FMA\n+     *    FMA}{@code , b, c)}.\n+     *\n+     * @param b the scalar multiplier\n+     * @param c the scalar addend\n+     * @return the product of this vector and the scalar multiplier\n+     *         summed with scalar addend, using extended precision\n+     *         for the intermediate result\n+     * @see #fma(Vector,Vector)\n+     * @see VectorOperators#FMA\n+     * @see #lanewise(VectorOperators.Ternary,short,short,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector fma(short b, short c) {\n+        return lanewise(FMA, b, c);\n+    }\n+\n+    \/\/ Don't bother with (Vector,short) and (short,Vector) overloadings.\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    \/**\n+     * Returns a value accumulated from all the lanes of this vector.\n+     *\n+     * This is an associative cross-lane reduction operation which\n+     * applies the specified operation to all the lane elements.\n+     * <p>\n+     * A few reduction operations do not support arbitrary reordering\n+     * of their operands, yet are included here because of their\n+     * usefulness.\n+     * <ul>\n+     * <li>\n+     * In the case of {@code FIRST_NONZERO}, the reduction returns\n+     * the value from the lowest-numbered non-zero lane.\n+     * (As with {@code MAX} and {@code MIN}, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from\n+     * the default value, positive zero. So a first-nonzero lane reduction\n+     * might return {@code -0.0} even in the presence of non-zero\n+     * lane values.)\n+     * <li>\n+     * In the case of {@code ADD} and {@code MUL}, the\n+     * precise result will reflect the choice of an arbitrary order\n+     * of operations, which may even vary over time.\n+     * For further details see the section\n+     * <a href=\"VectorOperators.html#fp_assoc\">Operations on floating point vectors<\/a>.\n+     * <li>\n+     * All other reduction operations are fully commutative and\n+     * associative.  The implementation can choose any order of\n+     * processing, yet it will always produce the same result.\n+     * <\/ul>\n+     *\n+     * @param op the operation used to combine lane values\n+     * @return the accumulated result\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #reduceLanes(VectorOperators.Associative,VectorMask)\n+     * @see #add(Vector)\n+     * @see #mul(Vector)\n+     * @see #min(Vector)\n+     * @see #max(Vector)\n+     * @see VectorOperators#FIRST_NONZERO\n+     *\/\n+    public abstract short reduceLanes(VectorOperators.Associative op);\n+\n+    \/**\n+     * Returns a value accumulated from selected lanes of this vector,\n+     * controlled by a mask.\n+     *\n+     * This is an associative cross-lane reduction operation which\n+     * applies the specified operation to the selected lane elements.\n+     * <p>\n+     * If no elements are selected, an operation-specific identity\n+     * value is returned.\n+     * <ul>\n+     * <li>\n+     * If the operation is\n+     *  {@code ADD}\n+     * or {@code FIRST_NONZERO},\n+     * then the identity value is positive zero, the default {@code short} value.\n+     * <li>\n+     * If the operation is {@code MUL},\n+     * then the identity value is one.\n+     * <li>\n+     * If the operation is {@code MAX},\n+     * then the identity value is {@code Float16.NEGATIVE_INFINITY}.\n+     * <li>\n+     * If the operation is {@code MIN},\n+     * then the identity value is {@code Float16.POSITIVE_INFINITY}.\n+     * <\/ul>\n+     * <p>\n+     * A few reduction operations do not support arbitrary reordering\n+     * of their operands, yet are included here because of their\n+     * usefulness.\n+     * <ul>\n+     * <li>\n+     * In the case of {@code FIRST_NONZERO}, the reduction returns\n+     * the value from the lowest-numbered non-zero lane.\n+     * (As with {@code MAX} and {@code MIN}, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from\n+     * the default value, positive zero. So a first-nonzero lane reduction\n+     * might return {@code -0.0} even in the presence of non-zero\n+     * lane values.)\n+     * <li>\n+     * In the case of {@code ADD} and {@code MUL}, the\n+     * precise result will reflect the choice of an arbitrary order\n+     * of operations, which may even vary over time.\n+     * For further details see the section\n+     * <a href=\"VectorOperators.html#fp_assoc\">Operations on floating point vectors<\/a>.\n+     * <li>\n+     * All other reduction operations are fully commutative and\n+     * associative.  The implementation can choose any order of\n+     * processing, yet it will always produce the same result.\n+     * <\/ul>\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param m the mask controlling lane selection\n+     * @return the reduced result accumulated from the selected lane values\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #reduceLanes(VectorOperators.Associative)\n+     *\/\n+    public abstract short reduceLanes(VectorOperators.Associative op,\n+                                       VectorMask<Float16> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    short reduceLanesTemplate(VectorOperators.Associative op,\n+                               Class<? extends VectorMask<Float16>> maskClass,\n+                               VectorMask<Float16> m) {\n+        m.check(maskClass, this);\n+        if (op == FIRST_NONZERO) {\n+            \/\/ FIXME:  The JIT should handle this.\n+            HalffloatVector v = broadcast((short) 0).blend(this, m);\n+            return v.reduceLanesTemplate(op);\n+        }\n+        int opc = opCode(op);\n+        return fromBits(VectorSupport.reductionCoerced(\n+            opc, getClass(), maskClass, short.class, VECTOR_OPER_TYPE, length(),\n+            this, m,\n+            REDUCE_IMPL.find(op, opc, HalffloatVector::reductionOperations)));\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    short reduceLanesTemplate(VectorOperators.Associative op) {\n+        if (op == FIRST_NONZERO) {\n+            \/\/ FIXME:  The JIT should handle this.\n+            VectorMask<Short> thisNZ\n+                = this.viewAsIntegralLanes().compare(NE, (short) 0);\n+            int ft = thisNZ.firstTrue();\n+            return ft < length() ? this.lane(ft) : (short) 0;\n+        }\n+        int opc = opCode(op);\n+        return fromBits(VectorSupport.reductionCoerced(\n+            opc, getClass(), null, short.class, VECTOR_OPER_TYPE, length(),\n+            this, null,\n+            REDUCE_IMPL.find(op, opc, HalffloatVector::reductionOperations)));\n+    }\n+\n+    private static final\n+    ImplCache<Associative, ReductionOperation<HalffloatVector, VectorMask<Float16>>>\n+        REDUCE_IMPL = new ImplCache<>(Associative.class, HalffloatVector.class);\n+\n+    private static ReductionOperation<HalffloatVector, VectorMask<Float16>> reductionOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v, m) ->\n+                    toBits(v.rOp((short)0, m, (i, a, b) -> float16ToShortBits(Float16.add(shortBitsToFloat16(a), shortBitsToFloat16(b)))));\n+            case VECTOR_OP_MUL: return (v, m) ->\n+                    toBits(v.rOp(float16ToShortBits(Float16.valueOf(1.0f)), m, (i, a, b) -> float16ToShortBits(Float16.multiply(shortBitsToFloat16(a), shortBitsToFloat16(b)))));\n+            case VECTOR_OP_MIN: return (v, m) ->\n+                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> float16ToShortBits(Float16.min(shortBitsToFloat16(a), shortBitsToFloat16(b)))));\n+            case VECTOR_OP_MAX: return (v, m) ->\n+                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> float16ToShortBits(Float16.max(shortBitsToFloat16(a), shortBitsToFloat16(b)))));\n+            default: return null;\n+        }\n+    }\n+\n+\n+    private static final short MIN_OR_INF = float16ToShortBits(Float16.NEGATIVE_INFINITY);\n+    private static final short MAX_OR_INF = float16ToShortBits(Float16.POSITIVE_INFINITY);\n+\n+    public @Override abstract long reduceLanesToLong(VectorOperators.Associative op);\n+    public @Override abstract long reduceLanesToLong(VectorOperators.Associative op,\n+                                                     VectorMask<Float16> m);\n+\n+    \/\/ Type specific accessors\n+\n+    \/**\n+     * Gets the lane element at lane index {@code i}\n+     *\n+     * @param i the lane index\n+     * @return the lane element at lane index {@code i}\n+     * @throws IllegalArgumentException if the index is out of range\n+     * ({@code < 0 || >= length()})\n+     *\/\n+    public abstract short lane(int i);\n+\n+    \/**\n+     * Replaces the lane element of this vector at lane index {@code i} with\n+     * value {@code e}.\n+     *\n+     * This is a cross-lane operation and behaves as if it returns the result\n+     * of blending this vector with an input vector that is the result of\n+     * broadcasting {@code e} and a mask that has only one lane set at lane\n+     * index {@code i}.\n+     *\n+     * @param i the lane index of the lane element to be replaced\n+     * @param e the value to be placed\n+     * @return the result of replacing the lane element of this vector at lane\n+     * index {@code i} with value {@code e}.\n+     * @throws IllegalArgumentException if the index is out of range\n+     * ({@code < 0 || >= length()})\n+     *\/\n+    public abstract HalffloatVector withLane(int i, short e);\n+\n+    \/\/ Memory load operations\n+\n+    \/**\n+     * Returns an array of type {@code short[]}\n+     * containing all the lane values.\n+     * The array length is the same as the vector length.\n+     * The array elements are stored in lane order.\n+     * <p>\n+     * This method behaves as if it stores\n+     * this vector into an allocated array\n+     * (using {@link #intoArray(short[], int) intoArray})\n+     * and returns the array as follows:\n+     * <pre>{@code\n+     *   short[] a = new short[this.length()];\n+     *   this.intoArray(a, 0);\n+     *   return a;\n+     * }<\/pre>\n+     *\n+     * @return an array containing the lane values of this vector\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final short[] toArray() {\n+        short[] a = new short[vspecies().laneCount()];\n+        intoArray(a, 0);\n+        return a;\n+    }\n+\n+    \/** {@inheritDoc} <!--workaround-->\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final int[] toIntArray() {\n+        short[] a = toArray();\n+        int[] res = new int[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            short e = a[i];\n+            res[i] = (int) HalffloatSpecies.toIntegralChecked(e, true);\n+        }\n+        return res;\n+    }\n+\n+    \/** {@inheritDoc} <!--workaround-->\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final long[] toLongArray() {\n+        short[] a = toArray();\n+        long[] res = new long[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            short e = shortBitsToFloat16(a[i]).shortValue();\n+            res[i] = HalffloatSpecies.toIntegralChecked(e, false);\n+        }\n+        return res;\n+    }\n+\n+    \/** {@inheritDoc} <!--workaround-->\n+     * @implNote\n+     * When this method is used on vectors\n+     * of type {@code HalffloatVector},\n+     * there will be no loss of precision.\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final double[] toDoubleArray() {\n+        short[] a = toArray();\n+        double[] res = new double[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            res[i] = (double) shortBitsToFloat16(a[i]).doubleValue();\n+        }\n+        return res;\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code short[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N} is placed into the\n+     * resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromArray(VectorSpecies<Float16> species,\n+                                   short[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.dummyVector().fromArray0(a, offset);\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code short[]}\n+     * starting at an offset and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code short} (positive zero).\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N} is placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromArray(VectorSpecies<Float16> species,\n+                                   short[] a, int offset,\n+                                   VectorMask<Float16> m) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        if (VectorIntrinsics.indexInRange(offset, vsp.length(), a.length)) {\n+            return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n+        }\n+\n+        ((AbstractMask<Float16>)m)\n+            .checkIndexByLane(offset, a.length, vsp.iota(), 1);\n+        return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code short[]},\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromArray(VectorSpecies<Float16> species,\n+                                   short[] a, int offset,\n+                                   int[] indexMap, int mapOffset) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n+        Objects.requireNonNull(a);\n+        Objects.requireNonNull(indexMap);\n+        Class<? extends HalffloatVector> vectorType = vsp.vectorType();\n+\n+\n+        \/\/ Constant folding should sweep out following conditonal logic.\n+        VectorSpecies<Integer> lsp;\n+        if (isp.length() > IntVector.SPECIES_PREFERRED.length()) {\n+            lsp = IntVector.SPECIES_PREFERRED;\n+        } else {\n+            lsp = isp;\n+        }\n+\n+        \/\/ Check indices are within array bounds.\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n+        }\n+\n+        return VectorSupport.loadWithMap(\n+            vectorType, null, short.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, null, null, null,\n+            a, offset, indexMap, mapOffset, vsp,\n+            (c, idx, iMap, idy, s, vm) ->\n+            s.vOp(n -> c[idx + iMap[idy+n]]));\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code short[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromArray(VectorSpecies<Float16> species,\n+                                   short[] a, int offset,\n+                                   int[] indexMap, int mapOffset,\n+                                   VectorMask<Float16> m) {\n+        if (m.allTrue()) {\n+            return fromArray(species, a, offset, indexMap, mapOffset);\n+        }\n+        else {\n+            HalffloatSpecies vsp = (HalffloatSpecies) species;\n+            return vsp.dummyVector().fromArray0(a, offset, indexMap, mapOffset, m);\n+        }\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromCharArray(VectorSpecies<Float16> species,\n+                                       char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.dummyVector().fromCharArray0(a, offset);\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code short} (positive zero).\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromCharArray(VectorSpecies<Float16> species,\n+                                       char[] a, int offset,\n+                                       VectorMask<Float16> m) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        if (VectorIntrinsics.indexInRange(offset, vsp.length(), a.length)) {\n+            return vsp.dummyVector().fromCharArray0(a, offset, m, OFFSET_IN_RANGE);\n+        }\n+\n+        ((AbstractMask<Float16>)m)\n+            .checkIndexByLane(offset, a.length, vsp.iota(), 1);\n+        return vsp.dummyVector().fromCharArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromCharArray(VectorSpecies<Float16> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.vOp(n -> (short) a[offset + indexMap[mapOffset + n]]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromCharArray(VectorSpecies<Float16> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset,\n+                                       VectorMask<Float16> m) {\n+        \/\/ FIXME: optimize\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.vOp(m, n -> (short) a[offset + indexMap[mapOffset + n]]);\n+    }\n+\n+\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment.\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * This method behaves as if it returns the result of calling\n+     * {@link #fromMemorySegment(VectorSpecies,MemorySegment,long,ByteOrder,VectorMask)\n+     * fromMemorySegment()} as follows:\n+     * <pre>{@code\n+     * var m = species.maskAll(true);\n+     * return fromMemorySegment(species, ms, offset, bo, m);\n+     * }<\/pre>\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*2 < 0}\n+     *         or {@code offset+N*2 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     * @since 19\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromMemorySegment(VectorSpecies<Float16> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), ms.byteSize());\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+    }\n+\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment\n+     * and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code short} (positive zero).\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * The following pseudocode illustrates the behavior:\n+     * <pre>{@code\n+     * var slice = ms.asSlice(offset);\n+     * short[] ar = new short[species.length()];\n+     * for (int n = 0; n < ar.length; n++) {\n+     *     if (m.laneIsSet(n)) {\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_SHORT.withByteAlignment(1), n);\n+     *     }\n+     * }\n+     * HalffloatVector r = HalffloatVector.fromArray(species, ar, 0);\n+     * }<\/pre>\n+     * @implNote\n+     * This operation is likely to be more efficient if\n+     * the specified byte order is the same as\n+     * {@linkplain ByteOrder#nativeOrder()\n+     * the platform native order},\n+     * since this method will not need to reorder\n+     * the bytes of lane values.\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @param m the mask controlling lane selection\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*2 < 0}\n+     *         or {@code offset+N*2 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     * @since 19\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromMemorySegment(VectorSpecies<Float16> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo,\n+                                           VectorMask<Float16> m) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        if (VectorIntrinsics.indexInRange(offset, vsp.vectorByteSize(), ms.byteSize())) {\n+            return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n+        }\n+\n+        ((AbstractMask<Float16>)m)\n+            .checkIndexByLane(offset, ms.byteSize(), vsp.iota(), 2);\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n+    }\n+\n+    \/\/ Memory store operations\n+\n+    \/**\n+     * Stores this vector into an array of type {@code short[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[offset+N]}.\n+     *\n+     * @param a the array, of type {@code short[]}\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(short[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        HalffloatSpecies vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n+            a, arrayAddress(a, offset), false,\n+            this,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, (int) off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code short[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array, of type {@code short[]}\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(short[] a, int offset,\n+                   VectorMask<Float16> m) {\n+        if (m.allTrue()) {\n+            intoArray(a, offset);\n+        } else {\n+            HalffloatSpecies vsp = vspecies();\n+            if (!VectorIntrinsics.indexInRange(offset, vsp.length(), a.length)) {\n+                ((AbstractMask<Float16>)m)\n+                    .checkIndexByLane(offset, a.length, vsp.iota(), 1);\n+            }\n+            intoArray0(a, offset, m);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code short[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(short[] a, int offset,\n+                   int[] indexMap, int mapOffset) {\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = e;\n+             });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code short[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(short[] a, int offset,\n+                   int[] indexMap, int mapOffset,\n+                   VectorMask<Float16> m) {\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = e;\n+             });\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        HalffloatSpecies vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n+            a, charArrayAddress(a, offset), false,\n+            this,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, (int) off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (char) e));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       VectorMask<Float16> m) {\n+        if (m.allTrue()) {\n+            intoCharArray(a, offset);\n+        } else {\n+            HalffloatSpecies vsp = vspecies();\n+            if (!VectorIntrinsics.indexInRange(offset, vsp.length(), a.length)) {\n+                ((AbstractMask<Float16>)m)\n+                    .checkIndexByLane(offset, a.length, vsp.iota(), 1);\n+            }\n+            intoCharArray0(a, offset, m);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (char) e;\n+             });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset,\n+                       VectorMask<Float16> m) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (char) e;\n+             });\n+    }\n+\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo) {\n+        if (ms.isReadOnly()) {\n+            throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+        }\n+\n+        offset = checkFromIndexSize(offset, byteSize(), ms.byteSize());\n+        maybeSwap(bo).intoMemorySegment0(ms, offset);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo,\n+                           VectorMask<Float16> m) {\n+        if (m.allTrue()) {\n+            intoMemorySegment(ms, offset, bo);\n+        } else {\n+            if (ms.isReadOnly()) {\n+                throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+            }\n+            HalffloatSpecies vsp = vspecies();\n+            if (!VectorIntrinsics.indexInRange(offset, vsp.vectorByteSize(), ms.byteSize())) {\n+                ((AbstractMask<Float16>)m)\n+                    .checkIndexByLane(offset, ms.byteSize(), vsp.iota(), 2);\n+            }\n+            maybeSwap(bo).intoMemorySegment0(ms, offset, m);\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Low-level memory operations.\n+    \/\/\n+    \/\/ Note that all of these operations *must* inline into a context\n+    \/\/ where the exact species of the involved vector is a\n+    \/\/ compile-time constant.  Otherwise, the intrinsic generation\n+    \/\/ will fail and performance will suffer.\n+    \/\/\n+    \/\/ In many cases this is achieved by re-deriving a version of the\n+    \/\/ method in each concrete subclass (per species).  The re-derived\n+    \/\/ method simply calls one of these generic methods, with exact\n+    \/\/ parameters for the controlling metadata, which is either a\n+    \/\/ typed vector or constant species instance.\n+\n+    \/\/ Unchecked loading operations in native byte order.\n+    \/\/ Caller is responsible for applying index checks, masking, and\n+    \/\/ byte swapping.\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector fromArray0(short[] a, int offset);\n+    @ForceInline\n+    final\n+    HalffloatVector fromArray0Template(short[] a, int offset) {\n+        HalffloatSpecies vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n+            a, arrayAddress(a, offset), false,\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n+                                    (arr_, off_, i) -> arr_[off_ + i]));\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Float16> m, int offsetInRange);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    HalffloatVector fromArray0Template(Class<M> maskClass, short[] a, int offset, M m, int offsetInRange) {\n+        m.check(species());\n+        HalffloatSpecies vsp = vspecies();\n+        return VectorSupport.loadMasked(\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n+            a, arrayAddress(a, offset), false, m, offsetInRange,\n+            a, offset, vsp,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+                                        (arr_, off_, i) -> arr_[off_ + i]));\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector fromArray0(short[] a, int offset,\n+                                    int[] indexMap, int mapOffset,\n+                                    VectorMask<Float16> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    HalffloatVector fromArray0Template(Class<M> maskClass, short[] a, int offset,\n+                                            int[] indexMap, int mapOffset, M m) {\n+        HalffloatSpecies vsp = vspecies();\n+        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n+        Objects.requireNonNull(a);\n+        Objects.requireNonNull(indexMap);\n+        m.check(vsp);\n+        Class<? extends HalffloatVector> vectorType = vsp.vectorType();\n+\n+\n+        \/\/ Constant folding should sweep out following conditonal logic.\n+        VectorSpecies<Integer> lsp;\n+        if (isp.length() > IntVector.SPECIES_PREFERRED.length()) {\n+            lsp = IntVector.SPECIES_PREFERRED;\n+        } else {\n+            lsp = isp;\n+        }\n+\n+        \/\/ Check indices are within array bounds.\n+        \/\/ FIXME: Check index under mask controlling.\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n+        }\n+\n+        return VectorSupport.loadWithMap(\n+            vectorType, maskClass, short.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, null, null, m,\n+            a, offset, indexMap, mapOffset, vsp,\n+            (c, idx, iMap, idy, s, vm) ->\n+            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector fromCharArray0(char[] a, int offset);\n+    @ForceInline\n+    final\n+    HalffloatVector fromCharArray0Template(char[] a, int offset) {\n+        HalffloatSpecies vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n+            a, charArrayAddress(a, offset), false,\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n+                                    (arr_, off_, i) -> (short) arr_[off_ + i]));\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Float16> m, int offsetInRange);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    HalffloatVector fromCharArray0Template(Class<M> maskClass, char[] a, int offset, M m, int offsetInRange) {\n+        m.check(species());\n+        HalffloatSpecies vsp = vspecies();\n+        return VectorSupport.loadMasked(\n+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n+                a, charArrayAddress(a, offset), false, m, offsetInRange,\n+                a, offset, vsp,\n+                (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+                                            (arr_, off_, i) -> (short) arr_[off_ + i]));\n+    }\n+\n+\n+    abstract\n+    HalffloatVector fromMemorySegment0(MemorySegment bb, long offset);\n+    @ForceInline\n+    final\n+    HalffloatVector fromMemorySegment0Template(MemorySegment ms, long offset) {\n+        HalffloatSpecies vsp = vspecies();\n+        return ScopedMemoryAccess.loadFromMemorySegment(\n+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n+                (AbstractMemorySegmentImpl) ms, offset, vsp,\n+                (msp, off, s) -> {\n+                    return s.ldLongOp((MemorySegment) msp, off, HalffloatVector::memorySegmentGet);\n+                });\n+    }\n+\n+    abstract\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m, int offsetInRange);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    HalffloatVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m, int offsetInRange) {\n+        HalffloatSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return ScopedMemoryAccess.loadFromMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n+                (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,\n+                (msp, off, s, vm) -> {\n+                    return s.ldLongOp((MemorySegment) msp, off, vm, HalffloatVector::memorySegmentGet);\n+                });\n+    }\n+\n+    \/\/ Unchecked storing operations in native byte order.\n+    \/\/ Caller is responsible for applying index checks, masking, and\n+    \/\/ byte swapping.\n+\n+    abstract\n+    void intoArray0(short[] a, int offset);\n+    @ForceInline\n+    final\n+    void intoArray0Template(short[] a, int offset) {\n+        HalffloatSpecies vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n+            a, arrayAddress(a, offset), false,\n+            this, a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, (int) off,\n+                      (arr_, off_, i, e) -> arr_[off_+i] = e));\n+    }\n+\n+    abstract\n+    void intoArray0(short[] a, int offset, VectorMask<Float16> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    void intoArray0Template(Class<M> maskClass, short[] a, int offset, M m) {\n+        m.check(species());\n+        HalffloatSpecies vsp = vspecies();\n+        VectorSupport.storeMasked(\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n+            a, arrayAddress(a, offset), false,\n+            this, m, a, offset,\n+            (arr, off, v, vm)\n+            -> v.stOp(arr, (int) off, vm,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+    }\n+\n+\n+\n+    @ForceInline\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset) {\n+        HalffloatSpecies vsp = vspecies();\n+        ScopedMemoryAccess.storeIntoMemorySegment(\n+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n+                this,\n+                (AbstractMemorySegmentImpl) ms, offset,\n+                (msp, off, v) -> {\n+                    v.stLongOp((MemorySegment) msp, off, HalffloatVector::memorySegmentSet);\n+                });\n+    }\n+\n+    abstract\n+    void intoMemorySegment0(MemorySegment bb, long offset, VectorMask<Float16> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        HalffloatSpecies vsp = vspecies();\n+        m.check(vsp);\n+        ScopedMemoryAccess.storeIntoMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n+                this, m,\n+                (AbstractMemorySegmentImpl) ms, offset,\n+                (msp, off, v, vm) -> {\n+                    v.stLongOp((MemorySegment) msp, off, vm, HalffloatVector::memorySegmentSet);\n+                });\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    void intoCharArray0(char[] a, int offset, VectorMask<Float16> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    void intoCharArray0Template(Class<M> maskClass, char[] a, int offset, M m) {\n+        m.check(species());\n+        HalffloatSpecies vsp = vspecies();\n+        VectorSupport.storeMasked(\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n+            a, charArrayAddress(a, offset), false,\n+            this, m, a, offset,\n+            (arr, off, v, vm)\n+            -> v.stOp(arr, (int) off, vm,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (char) e));\n+    }\n+\n+    \/\/ End of low-level memory operations.\n+\n+    @ForceInline\n+    private void conditionalStoreNYI(int offset,\n+                                     HalffloatSpecies vsp,\n+                                     VectorMask<Float16> m,\n+                                     int scale,\n+                                     int limit) {\n+        if (offset < 0 || offset + vsp.laneCount() * scale > limit) {\n+            String msg =\n+                String.format(\"unimplemented: store @%d in [0..%d), %s in %s\",\n+                              offset, limit, m, vsp);\n+            throw new AssertionError(msg);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    final\n+    HalffloatVector maybeSwap(ByteOrder bo) {\n+        if (bo != NATIVE_ENDIAN) {\n+            return this.reinterpretAsBytes()\n+                .rearrange(swapBytesShuffle())\n+                .reinterpretAsHalffloats();\n+        }\n+        return this;\n+    }\n+\n+    static final int ARRAY_SHIFT =\n+        31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_SHORT_INDEX_SCALE);\n+    static final long ARRAY_BASE =\n+        Unsafe.ARRAY_SHORT_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long arrayAddress(short[] a, int index) {\n+        return ARRAY_BASE + (((long)index) << ARRAY_SHIFT);\n+    }\n+\n+    static final int ARRAY_CHAR_SHIFT =\n+            31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_CHAR_INDEX_SCALE);\n+    static final long ARRAY_CHAR_BASE =\n+            Unsafe.ARRAY_CHAR_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long charArrayAddress(char[] a, int index) {\n+        return ARRAY_CHAR_BASE + (((long)index) << ARRAY_CHAR_SHIFT);\n+    }\n+\n+\n+    @ForceInline\n+    static long byteArrayAddress(byte[] a, int index) {\n+        return Unsafe.ARRAY_BYTE_BASE_OFFSET + index;\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/\/ Reinterpreting view methods:\n+    \/\/   lanewise reinterpret: viewAsXVector()\n+    \/\/   keep shape, redraw lanes: reinterpretAsEs()\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final ByteVector reinterpretAsBytes() {\n+         \/\/ Going to ByteVector, pay close attention to byte order.\n+         assert(REGISTER_ENDIAN == ByteOrder.LITTLE_ENDIAN);\n+         return asByteVectorRaw();\n+         \/\/return asByteVectorRaw().rearrange(swapBytesShuffle());\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final ShortVector viewAsIntegralLanes() {\n+        LaneType ilt = LaneType.SHORT.asIntegral();\n+        return (ShortVector) asVectorRaw(ilt);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\n+     * @implNote This method always throws\n+     * {@code UnsupportedOperationException}, because there is no floating\n+     * point type of the same size as {@code short}.  The return type\n+     * of this method is arbitrarily designated as\n+     * {@code Vector<?>}.  Future versions of this API may change the return\n+     * type if additional floating point types become available.\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final\n+    HalffloatVector\n+    viewAsFloatingLanes() {\n+        return this;\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/\/ Object methods: toString, equals, hashCode\n+    \/\/\n+    \/\/ Object methods are defined as if via Arrays.toString, etc.,\n+    \/\/ is applied to the array of elements.  Two equal vectors\n+    \/\/ are required to have equal species and equal lane values.\n+\n+    \/**\n+     * Returns a string representation of this vector, of the form\n+     * {@code \"[0,1,2...]\"}, reporting the lane values of this vector,\n+     * in lane order.\n+     *\n+     * The string is produced as if by a call to {@link\n+     * java.util.Arrays#toString(short[]) Arrays.toString()},\n+     * as appropriate to the {@code short} array returned by\n+     * {@link #toArray this.toArray()}.\n+     *\n+     * @return a string of the form {@code \"[0,1,2...]\"}\n+     * reporting the lane values of this vector\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    String toString() {\n+        \/\/ now that toArray is strongly typed, we can define this\n+        return Arrays.toString(toArray());\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    boolean equals(Object obj) {\n+        if (obj instanceof Vector) {\n+            Vector<?> that = (Vector<?>) obj;\n+            if (this.species().equals(that.species())) {\n+                return this.eq(that.check(this.species())).allTrue();\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    int hashCode() {\n+        \/\/ now that toArray is strongly typed, we can define this\n+        return Objects.hash(species(), Arrays.hashCode(toArray()));\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Species\n+\n+    \/**\n+     * Class representing {@link HalffloatVector}'s of the same {@link VectorShape VectorShape}.\n+     *\/\n+    \/*package-private*\/\n+    static final class HalffloatSpecies extends AbstractSpecies<Float16> {\n+        private HalffloatSpecies(VectorShape shape,\n+                Class<? extends HalffloatVector> vectorType,\n+                Class<? extends AbstractMask<Float16>> maskType,\n+                Class<? extends AbstractShuffle<Float16>> shuffleType,\n+                Function<Object, HalffloatVector> vectorFactory) {\n+            super(shape, LaneType.of(Float16.class),\n+                  vectorType, maskType, shuffleType,\n+                  vectorFactory);\n+            assert(this.elementSize() == Float16.SIZE);\n+        }\n+\n+        \/\/ Specializing overrides:\n+\n+        @ForceInline\n+        final Class<?> carrierType() {\n+            return short.class;\n+        }\n+\n+        @ForceInline\n+        final int operType() {\n+            if (Float16.class.equals(Float16.class)) {\n+                return VECTOR_TYPE_FP16;\n+            }\n+            return VECTOR_TYPE_PRIM;\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final Class<Float16> elementType() {\n+            return Float16.class;\n+        }\n+\n+        @Override\n+        @ForceInline\n+        final Class<Float16> genericElementType() {\n+            return Float16.class;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        @ForceInline\n+        public final Class<? extends HalffloatVector> vectorType() {\n+            return (Class<? extends HalffloatVector>) vectorType;\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final long checkValue(long e) {\n+            longToElementBits(e);  \/\/ only for exception\n+            return e;\n+        }\n+\n+        \/*package-private*\/\n+        @Override\n+        @ForceInline\n+        final HalffloatVector broadcastBits(long bits) {\n+            return (HalffloatVector)\n+                VectorSupport.fromBitsCoerced(\n+                    vectorType, short.class, VECTOR_OPER_TYPE, laneCount,\n+                    bits, MODE_BROADCAST, this,\n+                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        final HalffloatVector broadcast(short e) {\n+            return broadcastBits(toBits(e));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final HalffloatVector broadcast(long e) {\n+            return broadcastBits(longToElementBits(e));\n+        }\n+\n+        \/*package-private*\/\n+        final @Override\n+        @ForceInline\n+        long longToElementBits(long value) {\n+            \/\/ Do the conversion, and then test it for failure.\n+            short e = (short) value;\n+            if ((long) e != value) {\n+                throw badElementBits(value, e);\n+            }\n+            return toBits(e);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        static long toIntegralChecked(short e, boolean convertToInt) {\n+            long value = convertToInt ? (int) e : (long) e;\n+            if ((short) value != e) {\n+                throw badArrayBits(e, convertToInt, value);\n+            }\n+            return value;\n+        }\n+\n+        \/* this non-public one is for internal conversions *\/\n+        @Override\n+        @ForceInline\n+        final HalffloatVector fromIntValues(int[] values) {\n+            VectorIntrinsics.requireLength(values.length, laneCount);\n+            short[] va = new short[laneCount()];\n+            for (int i = 0; i < va.length; i++) {\n+                int lv = values[i];\n+                short v = float16ToShortBits(Float16.valueOf(lv));\n+                va[i] = v;\n+                if (Float16.valueOf(lv).intValue() != lv) {\n+                    throw badElementBits(lv, v);\n+                }\n+            }\n+            return dummyVector().fromArray0(va, 0);\n+        }\n+\n+        \/\/ Virtual constructors\n+\n+        @ForceInline\n+        @Override final\n+        public HalffloatVector fromArray(Object a, int offset) {\n+            \/\/ User entry point\n+            \/\/ Defer only to the equivalent method on the vector class, using the same inputs\n+            return HalffloatVector\n+                .fromArray(this, (short[]) a, offset);\n+        }\n+\n+        @ForceInline\n+        @Override final\n+        public HalffloatVector fromMemorySegment(MemorySegment ms, long offset, ByteOrder bo) {\n+            \/\/ User entry point\n+            \/\/ Defer only to the equivalent method on the vector class, using the same inputs\n+            return HalffloatVector\n+                .fromMemorySegment(this, ms, offset, bo);\n+        }\n+\n+        @ForceInline\n+        @Override final\n+        HalffloatVector dummyVector() {\n+            return (HalffloatVector) super.dummyVector();\n+        }\n+\n+        \/*package-private*\/\n+        final @Override\n+        @ForceInline\n+        HalffloatVector rvOp(RVOp f) {\n+            short[] res = new short[laneCount()];\n+            for (int i = 0; i < res.length; i++) {\n+                short bits = (short) f.apply(i);\n+                res[i] = fromBits(bits);\n+            }\n+            return dummyVector().vectorFactory(res);\n+        }\n+\n+        HalffloatVector vOp(FVOp f) {\n+            short[] res = new short[laneCount()];\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i);\n+            }\n+            return dummyVector().vectorFactory(res);\n+        }\n+\n+        HalffloatVector vOp(VectorMask<Float16> m, FVOp f) {\n+            short[] res = new short[laneCount()];\n+            boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                if (mbits[i]) {\n+                    res[i] = f.apply(i);\n+                }\n+            }\n+            return dummyVector().vectorFactory(res);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> HalffloatVector ldOp(M memory, int offset,\n+                                      FLdOp<M> f) {\n+            return dummyVector().ldOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> HalffloatVector ldOp(M memory, int offset,\n+                                      VectorMask<Float16> m,\n+                                      FLdOp<M> f) {\n+            return dummyVector().ldOp(memory, offset, m, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        HalffloatVector ldLongOp(MemorySegment memory, long offset,\n+                                      FLdLongOp f) {\n+            return dummyVector().ldLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        HalffloatVector ldLongOp(MemorySegment memory, long offset,\n+                                      VectorMask<Float16> m,\n+                                      FLdLongOp f) {\n+            return dummyVector().ldLongOp(memory, offset, m, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stOp(M memory, int offset, FStOp<M> f) {\n+            dummyVector().stOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stOp(M memory, int offset,\n+                      AbstractMask<Float16> m,\n+                      FStOp<M> f) {\n+            dummyVector().stOp(memory, offset, m, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n+            dummyVector().stLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        void stLongOp(MemorySegment memory, long offset,\n+                      AbstractMask<Float16> m,\n+                      FStLongOp f) {\n+            dummyVector().stLongOp(memory, offset, m, f);\n+        }\n+\n+        \/\/ N.B. Make sure these constant vectors and\n+        \/\/ masks load up correctly into registers.\n+        \/\/\n+        \/\/ Also, see if we can avoid all that switching.\n+        \/\/ Could we cache both vectors and both masks in\n+        \/\/ this species object?\n+\n+        \/\/ Zero and iota vector access\n+        @Override\n+        @ForceInline\n+        public final HalffloatVector zero() {\n+            if ((Class<?>) vectorType() == HalffloatMaxVector.class)\n+                return HalffloatMaxVector.ZERO;\n+            switch (vectorBitSize()) {\n+                case 64: return Halffloat64Vector.ZERO;\n+                case 128: return Halffloat128Vector.ZERO;\n+                case 256: return Halffloat256Vector.ZERO;\n+                case 512: return Halffloat512Vector.ZERO;\n+            }\n+            throw new AssertionError();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final HalffloatVector iota() {\n+            if ((Class<?>) vectorType() == HalffloatMaxVector.class)\n+                return HalffloatMaxVector.IOTA;\n+            switch (vectorBitSize()) {\n+                case 64: return Halffloat64Vector.IOTA;\n+                case 128: return Halffloat128Vector.IOTA;\n+                case 256: return Halffloat256Vector.IOTA;\n+                case 512: return Halffloat512Vector.IOTA;\n+            }\n+            throw new AssertionError();\n+        }\n+\n+        \/\/ Mask access\n+        @Override\n+        @ForceInline\n+        public final VectorMask<Float16> maskAll(boolean bit) {\n+            if ((Class<?>) vectorType() == HalffloatMaxVector.class)\n+                return HalffloatMaxVector.HalffloatMaxMask.maskAll(bit);\n+            switch (vectorBitSize()) {\n+                case 64: return Halffloat64Vector.Halffloat64Mask.maskAll(bit);\n+                case 128: return Halffloat128Vector.Halffloat128Mask.maskAll(bit);\n+                case 256: return Halffloat256Vector.Halffloat256Mask.maskAll(bit);\n+                case 512: return Halffloat512Vector.Halffloat512Mask.maskAll(bit);\n+            }\n+            throw new AssertionError();\n+        }\n+    }\n+\n+    \/**\n+     * Finds a species for an element type of {@code short} and shape.\n+     *\n+     * @param s the shape\n+     * @return a species for an element type of {@code short} and shape\n+     * @throws IllegalArgumentException if no such species exists for the shape\n+     *\/\n+    static HalffloatSpecies species(VectorShape s) {\n+        Objects.requireNonNull(s);\n+        switch (s.switchKey) {\n+            case VectorShape.SK_64_BIT: return (HalffloatSpecies) SPECIES_64;\n+            case VectorShape.SK_128_BIT: return (HalffloatSpecies) SPECIES_128;\n+            case VectorShape.SK_256_BIT: return (HalffloatSpecies) SPECIES_256;\n+            case VectorShape.SK_512_BIT: return (HalffloatSpecies) SPECIES_512;\n+            case VectorShape.SK_Max_BIT: return (HalffloatSpecies) SPECIES_MAX;\n+            default: throw new IllegalArgumentException(\"Bad shape: \" + s);\n+        }\n+    }\n+\n+    \/** Species representing {@link HalffloatVector}s of {@link VectorShape#S_64_BIT VectorShape.S_64_BIT}. *\/\n+    public static final VectorSpecies<Float16> SPECIES_64\n+        = new HalffloatSpecies(VectorShape.S_64_BIT,\n+                            Halffloat64Vector.class,\n+                            Halffloat64Vector.Halffloat64Mask.class,\n+                            Halffloat64Vector.Halffloat64Shuffle.class,\n+                            Halffloat64Vector::new);\n+\n+    \/** Species representing {@link HalffloatVector}s of {@link VectorShape#S_128_BIT VectorShape.S_128_BIT}. *\/\n+    public static final VectorSpecies<Float16> SPECIES_128\n+        = new HalffloatSpecies(VectorShape.S_128_BIT,\n+                            Halffloat128Vector.class,\n+                            Halffloat128Vector.Halffloat128Mask.class,\n+                            Halffloat128Vector.Halffloat128Shuffle.class,\n+                            Halffloat128Vector::new);\n+\n+    \/** Species representing {@link HalffloatVector}s of {@link VectorShape#S_256_BIT VectorShape.S_256_BIT}. *\/\n+    public static final VectorSpecies<Float16> SPECIES_256\n+        = new HalffloatSpecies(VectorShape.S_256_BIT,\n+                            Halffloat256Vector.class,\n+                            Halffloat256Vector.Halffloat256Mask.class,\n+                            Halffloat256Vector.Halffloat256Shuffle.class,\n+                            Halffloat256Vector::new);\n+\n+    \/** Species representing {@link HalffloatVector}s of {@link VectorShape#S_512_BIT VectorShape.S_512_BIT}. *\/\n+    public static final VectorSpecies<Float16> SPECIES_512\n+        = new HalffloatSpecies(VectorShape.S_512_BIT,\n+                            Halffloat512Vector.class,\n+                            Halffloat512Vector.Halffloat512Mask.class,\n+                            Halffloat512Vector.Halffloat512Shuffle.class,\n+                            Halffloat512Vector::new);\n+\n+    \/** Species representing {@link HalffloatVector}s of {@link VectorShape#S_Max_BIT VectorShape.S_Max_BIT}. *\/\n+    public static final VectorSpecies<Float16> SPECIES_MAX\n+        = new HalffloatSpecies(VectorShape.S_Max_BIT,\n+                            HalffloatMaxVector.class,\n+                            HalffloatMaxVector.HalffloatMaxMask.class,\n+                            HalffloatMaxVector.HalffloatMaxShuffle.class,\n+                            HalffloatMaxVector::new);\n+\n+    \/**\n+     * Preferred species for {@link HalffloatVector}s.\n+     * A preferred species is a species of maximal bit-size for the platform.\n+     *\/\n+    public static final VectorSpecies<Float16> SPECIES_PREFERRED\n+        = (HalffloatSpecies) VectorSpecies.ofPreferred(Float16.class);\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/HalffloatVector.java","additions":4364,"deletions":0,"binary":false,"changes":4364,"status":"added"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+    static final Class<Integer> CTYPE = int.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Integer> ETYPE = int.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Integer> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Integer> elementType() { return int.class; }\n+    public final Class<Integer> elementType() { return ETYPE; }\n@@ -532,1 +539,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -555,1 +562,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -568,1 +575,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n@@ -670,1 +677,1 @@\n-                Int128Mask.class, int.class, VLENGTH, offset, limit,\n+                Int128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -686,2 +693,3 @@\n-                Int128Vector.class, Int128Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Int128Vector.class, Int128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -698,1 +706,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Int128Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Int128Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -708,1 +716,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Int128Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Int128Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -718,1 +726,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int128Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int128Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -728,2 +736,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int128Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int128Mask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -735,2 +744,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int128Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int128Mask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -742,2 +752,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int128Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int128Mask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -752,1 +763,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int128Mask.class, int.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int128Mask.class, int.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -762,1 +774,1 @@\n-            return VectorSupport.extract(Int128Mask.class, int.class, VLENGTH,\n+            return VectorSupport.extract(Int128Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -771,3 +783,3 @@\n-            return VectorSupport.test(BT_ne, Int128Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Int128Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Int128Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Int128Mask)m).getBits()));\n@@ -779,3 +791,3 @@\n-            return VectorSupport.test(BT_overflow, Int128Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Int128Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Int128Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Int128Mask)m).getBits()));\n@@ -787,1 +799,1 @@\n-            return VectorSupport.fromBitsCoerced(Int128Mask.class, int.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Int128Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -800,1 +812,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+    static final Class<Integer> CTYPE = int.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Integer> ETYPE = int.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Integer> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Integer> elementType() { return int.class; }\n+    public final Class<Integer> elementType() { return ETYPE; }\n@@ -536,1 +543,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -563,1 +570,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -576,1 +583,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n@@ -678,1 +685,1 @@\n-                Int256Mask.class, int.class, VLENGTH, offset, limit,\n+                Int256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -694,2 +701,3 @@\n-                Int256Vector.class, Int256Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Int256Vector.class, Int256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -706,1 +714,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Int256Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Int256Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -716,1 +724,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Int256Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Int256Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -726,1 +734,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int256Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int256Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -736,2 +744,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int256Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int256Mask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -743,2 +752,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int256Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int256Mask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -750,2 +760,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int256Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int256Mask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -760,1 +771,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int256Mask.class, int.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int256Mask.class, int.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -770,1 +782,1 @@\n-            return VectorSupport.extract(Int256Mask.class, int.class, VLENGTH,\n+            return VectorSupport.extract(Int256Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -779,3 +791,3 @@\n-            return VectorSupport.test(BT_ne, Int256Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Int256Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Int256Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Int256Mask)m).getBits()));\n@@ -787,3 +799,3 @@\n-            return VectorSupport.test(BT_overflow, Int256Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Int256Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Int256Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Int256Mask)m).getBits()));\n@@ -795,1 +807,1 @@\n-            return VectorSupport.fromBitsCoerced(Int256Mask.class, int.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Int256Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -808,1 +820,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+    static final Class<Integer> CTYPE = int.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Integer> ETYPE = int.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Integer> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Integer> elementType() { return int.class; }\n+    public final Class<Integer> elementType() { return ETYPE; }\n@@ -544,1 +551,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -579,1 +586,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -592,1 +599,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n@@ -694,1 +701,1 @@\n-                Int512Mask.class, int.class, VLENGTH, offset, limit,\n+                Int512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -710,2 +717,3 @@\n-                Int512Vector.class, Int512Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Int512Vector.class, Int512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -722,1 +730,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Int512Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Int512Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -732,1 +740,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Int512Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Int512Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -742,1 +750,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int512Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int512Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -752,2 +760,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int512Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int512Mask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -759,2 +768,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int512Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int512Mask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -766,2 +776,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int512Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int512Mask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -776,1 +787,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int512Mask.class, int.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int512Mask.class, int.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -786,1 +798,1 @@\n-            return VectorSupport.extract(Int512Mask.class, int.class, VLENGTH,\n+            return VectorSupport.extract(Int512Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -795,3 +807,3 @@\n-            return VectorSupport.test(BT_ne, Int512Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Int512Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Int512Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Int512Mask)m).getBits()));\n@@ -803,3 +815,3 @@\n-            return VectorSupport.test(BT_overflow, Int512Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Int512Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Int512Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Int512Mask)m).getBits()));\n@@ -811,1 +823,1 @@\n-            return VectorSupport.fromBitsCoerced(Int512Mask.class, int.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Int512Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -824,1 +836,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+    static final Class<Integer> CTYPE = int.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Integer> ETYPE = int.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Integer> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Integer> elementType() { return int.class; }\n+    public final Class<Integer> elementType() { return ETYPE; }\n@@ -530,1 +537,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -551,1 +558,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -564,1 +571,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n@@ -666,1 +673,1 @@\n-                Int64Mask.class, int.class, VLENGTH, offset, limit,\n+                Int64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -682,2 +689,3 @@\n-                Int64Vector.class, Int64Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Int64Vector.class, Int64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -694,1 +702,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Int64Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Int64Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -704,1 +712,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Int64Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Int64Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -714,1 +722,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int64Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int64Mask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -724,2 +732,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int64Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int64Mask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -731,2 +740,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int64Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int64Mask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -738,2 +748,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int64Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int64Mask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -748,1 +759,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int64Mask.class, int.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int64Mask.class, int.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -758,1 +770,1 @@\n-            return VectorSupport.extract(Int64Mask.class, int.class, VLENGTH,\n+            return VectorSupport.extract(Int64Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -767,3 +779,3 @@\n-            return VectorSupport.test(BT_ne, Int64Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Int64Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Int64Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Int64Mask)m).getBits()));\n@@ -775,3 +787,3 @@\n-            return VectorSupport.test(BT_overflow, Int64Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Int64Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Int64Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Int64Mask)m).getBits()));\n@@ -783,1 +795,1 @@\n-            return VectorSupport.fromBitsCoerced(Int64Mask.class, int.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Int64Mask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -796,1 +808,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+    static final Class<Integer> CTYPE = int.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Integer> ETYPE = int.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Integer> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Integer> elementType() { return int.class; }\n+    public final Class<Integer> elementType() { return ETYPE; }\n@@ -529,1 +536,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -549,1 +556,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -562,1 +569,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n@@ -664,1 +671,1 @@\n-                IntMaxMask.class, int.class, VLENGTH, offset, limit,\n+                IntMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -680,2 +687,3 @@\n-                IntMaxVector.class, IntMaxMask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                IntMaxVector.class, IntMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -692,1 +700,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, IntMaxMask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, IntMaxMask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -702,1 +710,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, IntMaxMask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, IntMaxMask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -712,1 +720,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, IntMaxMask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, IntMaxMask.class, null, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -722,2 +730,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, IntMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, IntMaxMask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -729,2 +738,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, IntMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, IntMaxMask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -736,2 +746,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, IntMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, IntMaxMask.class, int.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -746,1 +757,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, IntMaxMask.class, int.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, IntMaxMask.class, int.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -756,1 +768,1 @@\n-            return VectorSupport.extract(IntMaxMask.class, int.class, VLENGTH,\n+            return VectorSupport.extract(IntMaxMask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -765,3 +777,3 @@\n-            return VectorSupport.test(BT_ne, IntMaxMask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((IntMaxMask)m).getBits()));\n+            return VectorSupport.test(BT_ne, IntMaxMask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((IntMaxMask)m).getBits()));\n@@ -773,3 +785,3 @@\n-            return VectorSupport.test(BT_overflow, IntMaxMask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((IntMaxMask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, IntMaxMask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((IntMaxMask)m).getBits()));\n@@ -781,1 +793,1 @@\n-            return VectorSupport.fromBitsCoerced(IntMaxMask.class, int.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(IntMaxMask.class, int.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -805,1 +817,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n+\n@@ -576,1 +578,1 @@\n-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), int.class, species.length(),\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), int.class, VECTOR_OPER_TYPE, species.length(),\n@@ -698,1 +700,1 @@\n-            opc, getClass(), null, int.class, length(),\n+            opc, getClass(), null, int.class, VECTOR_OPER_TYPE, length(),\n@@ -726,1 +728,1 @@\n-            opc, getClass(), maskClass, int.class, length(),\n+            opc, getClass(), maskClass, int.class, VECTOR_OPER_TYPE, length(),\n@@ -799,1 +801,1 @@\n-            opc, getClass(), null, int.class, length(),\n+            opc, getClass(), null, int.class, VECTOR_OPER_TYPE, length(),\n@@ -850,1 +852,1 @@\n-            opc, getClass(), maskClass, int.class, length(),\n+            opc, getClass(), maskClass, int.class, VECTOR_OPER_TYPE, length(),\n@@ -1041,1 +1043,1 @@\n-            opc, getClass(), null, int.class, length(),\n+            opc, getClass(), null, int.class, VECTOR_OPER_TYPE, length(),\n@@ -1062,1 +1064,1 @@\n-            opc, getClass(), maskClass, int.class, length(),\n+            opc, getClass(), maskClass, int.class, VECTOR_OPER_TYPE, length(),\n@@ -1138,1 +1140,1 @@\n-            opc, getClass(), null, int.class, length(),\n+            opc, getClass(), null, int.class, VECTOR_OPER_TYPE, length(),\n@@ -1178,1 +1180,1 @@\n-            opc, getClass(), maskClass, int.class, length(),\n+            opc, getClass(), maskClass, int.class, VECTOR_OPER_TYPE, length(),\n@@ -2058,1 +2060,1 @@\n-            opc, getClass(), maskType, int.class, length(),\n+            opc, getClass(), maskType, int.class, VECTOR_OPER_TYPE, length(),\n@@ -2080,1 +2082,1 @@\n-            opc, getClass(), maskType, int.class, length(),\n+            opc, getClass(), maskType, int.class, VECTOR_OPER_TYPE, length(),\n@@ -2211,1 +2213,1 @@\n-            getClass(), maskType, int.class, length(),\n+            getClass(), maskType, int.class, VECTOR_OPER_TYPE, length(),\n@@ -2228,1 +2230,1 @@\n-            getClass(), int.class, length(),\n+            getClass(), int.class, VECTOR_OPER_TYPE, length(),\n@@ -2420,1 +2422,1 @@\n-            getClass(), shuffletype, null, int.class, length(),\n+            getClass(), shuffletype, null, int.class, VECTOR_OPER_TYPE, length(),\n@@ -2447,1 +2449,1 @@\n-                   getClass(), shuffletype, masktype, int.class, length(),\n+                   getClass(), shuffletype, masktype, int.class, VECTOR_OPER_TYPE, length(),\n@@ -2473,1 +2475,1 @@\n-                getClass(), shuffletype, null, int.class, length(),\n+                getClass(), shuffletype, null, int.class, VECTOR_OPER_TYPE, length(),\n@@ -2481,1 +2483,1 @@\n-                getClass(), shuffletype, null, int.class, length(),\n+                getClass(), shuffletype, null, int.class, VECTOR_OPER_TYPE, length(),\n@@ -2531,1 +2533,1 @@\n-                                                        int.class, length(), this, m,\n+                                                        int.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -2550,1 +2552,1 @@\n-                                                        int.class, length(), this, m,\n+                                                        int.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -2565,1 +2567,1 @@\n-        return (IntVector)VectorSupport.selectFromOp(getClass(), null, int.class,\n+        return (IntVector)VectorSupport.selectFromOp(getClass(), null, int.class, VECTOR_OPER_TYPE,\n@@ -2585,1 +2587,1 @@\n-        return (IntVector)VectorSupport.selectFromOp(getClass(), masktype, int.class,\n+        return (IntVector)VectorSupport.selectFromOp(getClass(), masktype, int.class, VECTOR_OPER_TYPE,\n@@ -2603,1 +2605,1 @@\n-        return VectorSupport.selectFromTwoVectorOp(getClass(), int.class, length(), this, v1, v2,\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), int.class, VECTOR_OPER_TYPE, length(), this, v1, v2,\n@@ -2823,1 +2825,1 @@\n-            opc, getClass(), maskClass, int.class, length(),\n+            opc, getClass(), maskClass, int.class, VECTOR_OPER_TYPE, length(),\n@@ -2841,1 +2843,1 @@\n-            opc, getClass(), null, int.class, length(),\n+            opc, getClass(), null, int.class, VECTOR_OPER_TYPE, length(),\n@@ -2876,0 +2878,1 @@\n+\n@@ -3101,1 +3104,1 @@\n-            vectorType, null, int.class, vsp.laneCount(),\n+            vectorType, null, int.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3284,1 +3287,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3373,1 +3376,1 @@\n-            vsp.vectorType(), null, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), null, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3500,1 +3503,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3517,1 +3520,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3550,1 +3553,1 @@\n-            vectorType, maskClass, int.class, vsp.laneCount(),\n+            vectorType, maskClass, int.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3567,1 +3570,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3583,1 +3586,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3601,1 +3604,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3618,1 +3621,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3647,1 +3650,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3666,1 +3669,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3683,1 +3686,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3855,0 +3858,13 @@\n+        @ForceInline\n+        final Class<?> carrierType() {\n+            return int.class;\n+        }\n+\n+        @ForceInline\n+        final int operType() {\n+            if (int.class.equals(Float16.class)) {\n+                return VECTOR_TYPE_FP16;\n+            }\n+            return VECTOR_TYPE_PRIM;\n+        }\n+\n@@ -3887,1 +3903,1 @@\n-                    vectorType, int.class, laneCount,\n+                    vectorType, int.class, VECTOR_OPER_TYPE, laneCount,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":54,"deletions":38,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -43,1 +43,2 @@\n-    LONG(long.class, Long.class, long[].class, 'I', -1, Long.SIZE, T_LONG);\n+    LONG(long.class, Long.class, long[].class, 'I', -1, Long.SIZE, T_LONG),\n+    HALFFLOAT(Float16.class, Short.class, short[].class, 'F', 11, Float16.SIZE, T_HALFFLOAT);\n@@ -69,1 +70,6 @@\n-        assert(\"FDBSIL\".indexOf(typeChar) == ordinal()) : this;\n+        if (basicType == T_HALFFLOAT) {\n+          assert(\"FDBSILS\".indexOf(typeChar, \"FDBSILS\".indexOf(typeChar) + 1) == ordinal()) : this;\n+        }\n+        else {\n+          assert(\"FDBSILS\".indexOf(typeChar) == ordinal()) : this;\n+        }\n@@ -75,1 +81,1 @@\n-        assert(\"....zcFDBSILoav..\".charAt(basicType) == typeChar);\n+        assert(\"....zSFDBSILSoav..\".charAt(basicType) == typeChar);\n@@ -181,7 +187,8 @@\n-        SK_FLOAT    = 1,\n-        SK_DOUBLE   = 2,\n-        SK_BYTE     = 3,\n-        SK_SHORT    = 4,\n-        SK_INT      = 5,\n-        SK_LONG     = 6,\n-        SK_LIMIT    = 7;\n+        SK_FLOAT     = 1,\n+        SK_DOUBLE    = 2,\n+        SK_BYTE      = 3,\n+        SK_SHORT     = 4,\n+        SK_INT       = 5,\n+        SK_LONG      = 6,\n+        SK_HALFFLOAT = 7,\n+        SK_LIMIT     = 8;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LaneType.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+    static final Class<Long> CTYPE = long.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Long> ETYPE = long.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Long> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Long> elementType() { return long.class; }\n+    public final Class<Long> elementType() { return ETYPE; }\n@@ -520,1 +527,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -541,1 +548,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -554,1 +561,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n@@ -656,1 +663,1 @@\n-                Long128Mask.class, long.class, VLENGTH, offset, limit,\n+                Long128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -672,2 +679,3 @@\n-                Long128Vector.class, Long128Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Long128Vector.class, Long128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -684,1 +692,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Long128Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Long128Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -694,1 +702,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Long128Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Long128Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -704,1 +712,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long128Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long128Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -714,2 +722,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long128Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long128Mask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -721,2 +730,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long128Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long128Mask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -728,2 +738,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long128Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long128Mask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -738,1 +749,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long128Mask.class, long.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long128Mask.class, long.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -748,1 +760,1 @@\n-            return VectorSupport.extract(Long128Mask.class, long.class, VLENGTH,\n+            return VectorSupport.extract(Long128Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -757,3 +769,3 @@\n-            return VectorSupport.test(BT_ne, Long128Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Long128Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Long128Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Long128Mask)m).getBits()));\n@@ -765,3 +777,3 @@\n-            return VectorSupport.test(BT_overflow, Long128Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Long128Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Long128Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Long128Mask)m).getBits()));\n@@ -773,1 +785,1 @@\n-            return VectorSupport.fromBitsCoerced(Long128Mask.class, long.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Long128Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -786,1 +798,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+    static final Class<Long> CTYPE = long.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Long> ETYPE = long.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Long> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Long> elementType() { return long.class; }\n+    public final Class<Long> elementType() { return ETYPE; }\n@@ -522,1 +529,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -545,1 +552,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -558,1 +565,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n@@ -660,1 +667,1 @@\n-                Long256Mask.class, long.class, VLENGTH, offset, limit,\n+                Long256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -676,2 +683,3 @@\n-                Long256Vector.class, Long256Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Long256Vector.class, Long256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -688,1 +696,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Long256Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Long256Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -698,1 +706,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Long256Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Long256Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -708,1 +716,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long256Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long256Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -718,2 +726,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long256Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long256Mask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -725,2 +734,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long256Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long256Mask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -732,2 +742,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long256Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long256Mask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -742,1 +753,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long256Mask.class, long.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long256Mask.class, long.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -752,1 +764,1 @@\n-            return VectorSupport.extract(Long256Mask.class, long.class, VLENGTH,\n+            return VectorSupport.extract(Long256Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -761,3 +773,3 @@\n-            return VectorSupport.test(BT_ne, Long256Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Long256Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Long256Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Long256Mask)m).getBits()));\n@@ -769,3 +781,3 @@\n-            return VectorSupport.test(BT_overflow, Long256Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Long256Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Long256Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Long256Mask)m).getBits()));\n@@ -777,1 +789,1 @@\n-            return VectorSupport.fromBitsCoerced(Long256Mask.class, long.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Long256Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -790,1 +802,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+    static final Class<Long> CTYPE = long.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Long> ETYPE = long.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Long> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Long> elementType() { return long.class; }\n+    public final Class<Long> elementType() { return ETYPE; }\n@@ -526,1 +533,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -553,1 +560,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -566,1 +573,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n@@ -668,1 +675,1 @@\n-                Long512Mask.class, long.class, VLENGTH, offset, limit,\n+                Long512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -684,2 +691,3 @@\n-                Long512Vector.class, Long512Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Long512Vector.class, Long512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -696,1 +704,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Long512Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Long512Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -706,1 +714,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Long512Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Long512Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -716,1 +724,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long512Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long512Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -726,2 +734,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long512Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long512Mask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -733,2 +742,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long512Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long512Mask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -740,2 +750,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long512Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long512Mask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -750,1 +761,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long512Mask.class, long.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long512Mask.class, long.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -760,1 +772,1 @@\n-            return VectorSupport.extract(Long512Mask.class, long.class, VLENGTH,\n+            return VectorSupport.extract(Long512Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -769,3 +781,3 @@\n-            return VectorSupport.test(BT_ne, Long512Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Long512Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Long512Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Long512Mask)m).getBits()));\n@@ -777,3 +789,3 @@\n-            return VectorSupport.test(BT_overflow, Long512Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Long512Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Long512Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Long512Mask)m).getBits()));\n@@ -785,1 +797,1 @@\n-            return VectorSupport.fromBitsCoerced(Long512Mask.class, long.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Long512Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -798,1 +810,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+    static final Class<Long> CTYPE = long.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Long> ETYPE = long.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Long> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Long> elementType() { return long.class; }\n+    public final Class<Long> elementType() { return ETYPE; }\n@@ -519,1 +526,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -539,1 +546,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -552,1 +559,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n@@ -654,1 +661,1 @@\n-                Long64Mask.class, long.class, VLENGTH, offset, limit,\n+                Long64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -670,2 +677,3 @@\n-                Long64Vector.class, Long64Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Long64Vector.class, Long64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -682,1 +690,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Long64Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Long64Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -692,1 +700,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Long64Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Long64Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -702,1 +710,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long64Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long64Mask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -712,2 +720,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long64Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long64Mask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -719,2 +728,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long64Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long64Mask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -726,2 +736,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long64Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long64Mask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -736,1 +747,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long64Mask.class, long.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long64Mask.class, long.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -746,1 +758,1 @@\n-            return VectorSupport.extract(Long64Mask.class, long.class, VLENGTH,\n+            return VectorSupport.extract(Long64Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -755,3 +767,3 @@\n-            return VectorSupport.test(BT_ne, Long64Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Long64Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Long64Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Long64Mask)m).getBits()));\n@@ -763,3 +775,3 @@\n-            return VectorSupport.test(BT_overflow, Long64Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Long64Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Long64Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Long64Mask)m).getBits()));\n@@ -771,1 +783,1 @@\n-            return VectorSupport.fromBitsCoerced(Long64Mask.class, long.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Long64Mask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -784,1 +796,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+    static final Class<Long> CTYPE = long.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Long> ETYPE = long.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Long> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Long> elementType() { return long.class; }\n+    public final Class<Long> elementType() { return ETYPE; }\n@@ -519,1 +526,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -539,1 +546,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -552,1 +559,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n@@ -654,1 +661,1 @@\n-                LongMaxMask.class, long.class, VLENGTH, offset, limit,\n+                LongMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -670,2 +677,3 @@\n-                LongMaxVector.class, LongMaxMask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                LongMaxVector.class, LongMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -682,1 +690,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, LongMaxMask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, LongMaxMask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -692,1 +700,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, LongMaxMask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, LongMaxMask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -702,1 +710,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, LongMaxMask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, LongMaxMask.class, null, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -712,2 +720,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, LongMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, LongMaxMask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -719,2 +728,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, LongMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, LongMaxMask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -726,2 +736,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, LongMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, LongMaxMask.class, long.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -736,1 +747,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, LongMaxMask.class, long.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, LongMaxMask.class, long.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -746,1 +758,1 @@\n-            return VectorSupport.extract(LongMaxMask.class, long.class, VLENGTH,\n+            return VectorSupport.extract(LongMaxMask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -755,3 +767,3 @@\n-            return VectorSupport.test(BT_ne, LongMaxMask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((LongMaxMask)m).getBits()));\n+            return VectorSupport.test(BT_ne, LongMaxMask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((LongMaxMask)m).getBits()));\n@@ -763,3 +775,3 @@\n-            return VectorSupport.test(BT_overflow, LongMaxMask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((LongMaxMask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, LongMaxMask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((LongMaxMask)m).getBits()));\n@@ -771,1 +783,1 @@\n-            return VectorSupport.fromBitsCoerced(LongMaxMask.class, long.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(LongMaxMask.class, long.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -784,1 +796,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n+\n@@ -576,1 +578,1 @@\n-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), long.class, species.length(),\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), long.class, VECTOR_OPER_TYPE, species.length(),\n@@ -656,1 +658,1 @@\n-            opc, getClass(), null, long.class, length(),\n+            opc, getClass(), null, long.class, VECTOR_OPER_TYPE, length(),\n@@ -684,1 +686,1 @@\n-            opc, getClass(), maskClass, long.class, length(),\n+            opc, getClass(), maskClass, long.class, VECTOR_OPER_TYPE, length(),\n@@ -757,1 +759,1 @@\n-            opc, getClass(), null, long.class, length(),\n+            opc, getClass(), null, long.class, VECTOR_OPER_TYPE, length(),\n@@ -808,1 +810,1 @@\n-            opc, getClass(), maskClass, long.class, length(),\n+            opc, getClass(), maskClass, long.class, VECTOR_OPER_TYPE, length(),\n@@ -954,1 +956,1 @@\n-            opc, getClass(), null, long.class, length(),\n+            opc, getClass(), null, long.class, VECTOR_OPER_TYPE, length(),\n@@ -975,1 +977,1 @@\n-            opc, getClass(), maskClass, long.class, length(),\n+            opc, getClass(), maskClass, long.class, VECTOR_OPER_TYPE, length(),\n@@ -1051,1 +1053,1 @@\n-            opc, getClass(), null, long.class, length(),\n+            opc, getClass(), null, long.class, VECTOR_OPER_TYPE, length(),\n@@ -1091,1 +1093,1 @@\n-            opc, getClass(), maskClass, long.class, length(),\n+            opc, getClass(), maskClass, long.class, VECTOR_OPER_TYPE, length(),\n@@ -1971,1 +1973,1 @@\n-            opc, getClass(), maskType, long.class, length(),\n+            opc, getClass(), maskType, long.class, VECTOR_OPER_TYPE, length(),\n@@ -1993,1 +1995,1 @@\n-            opc, getClass(), maskType, long.class, length(),\n+            opc, getClass(), maskType, long.class, VECTOR_OPER_TYPE, length(),\n@@ -2098,1 +2100,1 @@\n-            getClass(), maskType, long.class, length(),\n+            getClass(), maskType, long.class, VECTOR_OPER_TYPE, length(),\n@@ -2115,1 +2117,1 @@\n-            getClass(), long.class, length(),\n+            getClass(), long.class, VECTOR_OPER_TYPE, length(),\n@@ -2286,1 +2288,1 @@\n-            getClass(), shuffletype, null, long.class, length(),\n+            getClass(), shuffletype, null, long.class, VECTOR_OPER_TYPE, length(),\n@@ -2313,1 +2315,1 @@\n-                   getClass(), shuffletype, masktype, long.class, length(),\n+                   getClass(), shuffletype, masktype, long.class, VECTOR_OPER_TYPE, length(),\n@@ -2339,1 +2341,1 @@\n-                getClass(), shuffletype, null, long.class, length(),\n+                getClass(), shuffletype, null, long.class, VECTOR_OPER_TYPE, length(),\n@@ -2347,1 +2349,1 @@\n-                getClass(), shuffletype, null, long.class, length(),\n+                getClass(), shuffletype, null, long.class, VECTOR_OPER_TYPE, length(),\n@@ -2397,1 +2399,1 @@\n-                                                        long.class, length(), this, m,\n+                                                        long.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -2416,1 +2418,1 @@\n-                                                        long.class, length(), this, m,\n+                                                        long.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -2431,1 +2433,1 @@\n-        return (LongVector)VectorSupport.selectFromOp(getClass(), null, long.class,\n+        return (LongVector)VectorSupport.selectFromOp(getClass(), null, long.class, VECTOR_OPER_TYPE,\n@@ -2451,1 +2453,1 @@\n-        return (LongVector)VectorSupport.selectFromOp(getClass(), masktype, long.class,\n+        return (LongVector)VectorSupport.selectFromOp(getClass(), masktype, long.class, VECTOR_OPER_TYPE,\n@@ -2469,1 +2471,1 @@\n-        return VectorSupport.selectFromTwoVectorOp(getClass(), long.class, length(), this, v1, v2,\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), long.class, VECTOR_OPER_TYPE, length(), this, v1, v2,\n@@ -2689,1 +2691,1 @@\n-            opc, getClass(), maskClass, long.class, length(),\n+            opc, getClass(), maskClass, long.class, VECTOR_OPER_TYPE, length(),\n@@ -2707,1 +2709,1 @@\n-            opc, getClass(), null, long.class, length(),\n+            opc, getClass(), null, long.class, VECTOR_OPER_TYPE, length(),\n@@ -2742,0 +2744,1 @@\n+\n@@ -2980,1 +2983,1 @@\n-            vectorType, null, long.class, vsp.laneCount(),\n+            vectorType, null, long.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3163,1 +3166,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3271,1 +3274,1 @@\n-            vsp.vectorType(), null, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), null, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3398,1 +3401,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3415,1 +3418,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3466,1 +3469,1 @@\n-            vectorType, maskClass, long.class, vsp.laneCount(),\n+            vectorType, maskClass, long.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3483,1 +3486,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3499,1 +3502,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3517,1 +3520,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3534,1 +3537,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3582,1 +3585,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3601,1 +3604,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3618,1 +3621,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3790,0 +3793,13 @@\n+        @ForceInline\n+        final Class<?> carrierType() {\n+            return long.class;\n+        }\n+\n+        @ForceInline\n+        final int operType() {\n+            if (long.class.equals(Float16.class)) {\n+                return VECTOR_TYPE_FP16;\n+            }\n+            return VECTOR_TYPE_PRIM;\n+        }\n+\n@@ -3822,1 +3838,1 @@\n-                    vectorType, long.class, laneCount,\n+                    vectorType, long.class, VECTOR_OPER_TYPE, laneCount,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":54,"deletions":38,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+    static final Class<Short> CTYPE = short.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Short> ETYPE = short.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Short> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Short> elementType() { return short.class; }\n+    public final Class<Short> elementType() { return ETYPE; }\n@@ -536,1 +543,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -563,1 +570,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -576,1 +583,1 @@\n-        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n@@ -678,1 +685,1 @@\n-                Short128Mask.class, short.class, VLENGTH, offset, limit,\n+                Short128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -694,2 +701,3 @@\n-                Short128Vector.class, Short128Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Short128Vector.class, Short128Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -706,1 +714,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Short128Mask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Short128Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -716,1 +724,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Short128Mask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Short128Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -726,1 +734,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short128Mask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short128Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -736,2 +744,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short128Mask.class, short.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short128Mask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -743,2 +752,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short128Mask.class, short.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short128Mask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -750,2 +760,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short128Mask.class, short.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short128Mask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -760,1 +771,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short128Mask.class, short.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short128Mask.class, short.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -770,1 +782,1 @@\n-            return VectorSupport.extract(Short128Mask.class, short.class, VLENGTH,\n+            return VectorSupport.extract(Short128Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -779,3 +791,3 @@\n-            return VectorSupport.test(BT_ne, Short128Mask.class, short.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Short128Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Short128Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Short128Mask)m).getBits()));\n@@ -787,3 +799,3 @@\n-            return VectorSupport.test(BT_overflow, Short128Mask.class, short.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Short128Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Short128Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Short128Mask)m).getBits()));\n@@ -795,1 +807,1 @@\n-            return VectorSupport.fromBitsCoerced(Short128Mask.class, short.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Short128Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -808,1 +820,1 @@\n-        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+    static final Class<Short> CTYPE = short.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Short> ETYPE = short.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Short> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Short> elementType() { return short.class; }\n+    public final Class<Short> elementType() { return ETYPE; }\n@@ -544,1 +551,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -579,1 +586,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -592,1 +599,1 @@\n-        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n@@ -694,1 +701,1 @@\n-                Short256Mask.class, short.class, VLENGTH, offset, limit,\n+                Short256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -710,2 +717,3 @@\n-                Short256Vector.class, Short256Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Short256Vector.class, Short256Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -722,1 +730,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Short256Mask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Short256Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -732,1 +740,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Short256Mask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Short256Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -742,1 +750,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short256Mask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short256Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -752,2 +760,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short256Mask.class, short.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short256Mask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -759,2 +768,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short256Mask.class, short.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short256Mask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -766,2 +776,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short256Mask.class, short.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short256Mask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -776,1 +787,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short256Mask.class, short.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short256Mask.class, short.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -786,1 +798,1 @@\n-            return VectorSupport.extract(Short256Mask.class, short.class, VLENGTH,\n+            return VectorSupport.extract(Short256Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -795,3 +807,3 @@\n-            return VectorSupport.test(BT_ne, Short256Mask.class, short.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Short256Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Short256Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Short256Mask)m).getBits()));\n@@ -803,3 +815,3 @@\n-            return VectorSupport.test(BT_overflow, Short256Mask.class, short.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Short256Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Short256Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Short256Mask)m).getBits()));\n@@ -811,1 +823,1 @@\n-            return VectorSupport.fromBitsCoerced(Short256Mask.class, short.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Short256Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -824,1 +836,1 @@\n-        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+    static final Class<Short> CTYPE = short.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Short> ETYPE = short.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Short> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Short> elementType() { return short.class; }\n+    public final Class<Short> elementType() { return ETYPE; }\n@@ -560,1 +567,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -611,1 +618,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -624,1 +631,1 @@\n-        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n@@ -726,1 +733,1 @@\n-                Short512Mask.class, short.class, VLENGTH, offset, limit,\n+                Short512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -742,2 +749,3 @@\n-                Short512Vector.class, Short512Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Short512Vector.class, Short512Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -754,1 +762,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Short512Mask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Short512Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -764,1 +772,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Short512Mask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Short512Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -774,1 +782,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short512Mask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short512Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -784,2 +792,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short512Mask.class, short.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short512Mask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -791,2 +800,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short512Mask.class, short.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short512Mask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -798,2 +808,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short512Mask.class, short.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short512Mask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -808,1 +819,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short512Mask.class, short.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short512Mask.class, short.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -818,1 +830,1 @@\n-            return VectorSupport.extract(Short512Mask.class, short.class, VLENGTH,\n+            return VectorSupport.extract(Short512Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -827,3 +839,3 @@\n-            return VectorSupport.test(BT_ne, Short512Mask.class, short.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Short512Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Short512Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Short512Mask)m).getBits()));\n@@ -835,3 +847,3 @@\n-            return VectorSupport.test(BT_overflow, Short512Mask.class, short.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Short512Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Short512Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Short512Mask)m).getBits()));\n@@ -843,1 +855,1 @@\n-            return VectorSupport.fromBitsCoerced(Short512Mask.class, short.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Short512Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -856,1 +868,1 @@\n-        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+    static final Class<Short> CTYPE = short.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Short> ETYPE = short.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Short> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Short> elementType() { return short.class; }\n+    public final Class<Short> elementType() { return ETYPE; }\n@@ -532,1 +539,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -555,1 +562,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -568,1 +575,1 @@\n-        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n@@ -670,1 +677,1 @@\n-                Short64Mask.class, short.class, VLENGTH, offset, limit,\n+                Short64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -686,2 +693,3 @@\n-                Short64Vector.class, Short64Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Short64Vector.class, Short64Mask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -698,1 +706,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Short64Mask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Short64Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -708,1 +716,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Short64Mask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Short64Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -718,1 +726,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short64Mask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short64Mask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -728,2 +736,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short64Mask.class, short.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short64Mask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -735,2 +744,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short64Mask.class, short.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short64Mask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -742,2 +752,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short64Mask.class, short.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short64Mask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -752,1 +763,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short64Mask.class, short.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short64Mask.class, short.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -762,1 +774,1 @@\n-            return VectorSupport.extract(Short64Mask.class, short.class, VLENGTH,\n+            return VectorSupport.extract(Short64Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -771,3 +783,3 @@\n-            return VectorSupport.test(BT_ne, Short64Mask.class, short.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Short64Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Short64Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Short64Mask)m).getBits()));\n@@ -779,3 +791,3 @@\n-            return VectorSupport.test(BT_overflow, Short64Mask.class, short.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Short64Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Short64Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Short64Mask)m).getBits()));\n@@ -787,1 +799,1 @@\n-            return VectorSupport.fromBitsCoerced(Short64Mask.class, short.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Short64Mask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -800,1 +812,1 @@\n-        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+    static final Class<Short> CTYPE = short.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Short> ETYPE = short.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Short> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Short> elementType() { return short.class; }\n+    public final Class<Short> elementType() { return ETYPE; }\n@@ -529,1 +536,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -549,1 +556,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -562,1 +569,1 @@\n-        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n@@ -664,1 +671,1 @@\n-                ShortMaxMask.class, short.class, VLENGTH, offset, limit,\n+                ShortMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -680,2 +687,3 @@\n-                ShortMaxVector.class, ShortMaxMask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                ShortMaxVector.class, ShortMaxMask.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -692,1 +700,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, ShortMaxMask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, ShortMaxMask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -702,1 +710,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, ShortMaxMask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, ShortMaxMask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -712,1 +720,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, ShortMaxMask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, ShortMaxMask.class, null, short.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -722,2 +730,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, ShortMaxMask.class, short.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, ShortMaxMask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -729,2 +738,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, ShortMaxMask.class, short.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, ShortMaxMask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -736,2 +746,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, ShortMaxMask.class, short.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, ShortMaxMask.class, short.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -746,1 +757,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, ShortMaxMask.class, short.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, ShortMaxMask.class, short.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -756,1 +768,1 @@\n-            return VectorSupport.extract(ShortMaxMask.class, short.class, VLENGTH,\n+            return VectorSupport.extract(ShortMaxMask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -765,3 +777,3 @@\n-            return VectorSupport.test(BT_ne, ShortMaxMask.class, short.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((ShortMaxMask)m).getBits()));\n+            return VectorSupport.test(BT_ne, ShortMaxMask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((ShortMaxMask)m).getBits()));\n@@ -773,3 +785,3 @@\n-            return VectorSupport.test(BT_overflow, ShortMaxMask.class, short.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((ShortMaxMask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, ShortMaxMask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((ShortMaxMask)m).getBits()));\n@@ -781,1 +793,1 @@\n-            return VectorSupport.fromBitsCoerced(ShortMaxMask.class, short.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(ShortMaxMask.class, short.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -794,1 +806,1 @@\n-        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n+\n@@ -576,1 +578,1 @@\n-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), short.class, species.length(),\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), short.class, VECTOR_OPER_TYPE, species.length(),\n@@ -698,1 +700,1 @@\n-            opc, getClass(), null, short.class, length(),\n+            opc, getClass(), null, short.class, VECTOR_OPER_TYPE, length(),\n@@ -726,1 +728,1 @@\n-            opc, getClass(), maskClass, short.class, length(),\n+            opc, getClass(), maskClass, short.class, VECTOR_OPER_TYPE, length(),\n@@ -799,1 +801,1 @@\n-            opc, getClass(), null, short.class, length(),\n+            opc, getClass(), null, short.class, VECTOR_OPER_TYPE, length(),\n@@ -850,1 +852,1 @@\n-            opc, getClass(), maskClass, short.class, length(),\n+            opc, getClass(), maskClass, short.class, VECTOR_OPER_TYPE, length(),\n@@ -1037,1 +1039,1 @@\n-            opc, getClass(), null, short.class, length(),\n+            opc, getClass(), null, short.class, VECTOR_OPER_TYPE, length(),\n@@ -1058,1 +1060,1 @@\n-            opc, getClass(), maskClass, short.class, length(),\n+            opc, getClass(), maskClass, short.class, VECTOR_OPER_TYPE, length(),\n@@ -1135,1 +1137,1 @@\n-            opc, getClass(), null, short.class, length(),\n+            opc, getClass(), null, short.class, VECTOR_OPER_TYPE, length(),\n@@ -1175,1 +1177,1 @@\n-            opc, getClass(), maskClass, short.class, length(),\n+            opc, getClass(), maskClass, short.class, VECTOR_OPER_TYPE, length(),\n@@ -2074,1 +2076,1 @@\n-            opc, getClass(), maskType, short.class, length(),\n+            opc, getClass(), maskType, short.class, VECTOR_OPER_TYPE, length(),\n@@ -2096,1 +2098,1 @@\n-            opc, getClass(), maskType, short.class, length(),\n+            opc, getClass(), maskType, short.class, VECTOR_OPER_TYPE, length(),\n@@ -2227,1 +2229,1 @@\n-            getClass(), maskType, short.class, length(),\n+            getClass(), maskType, short.class, VECTOR_OPER_TYPE, length(),\n@@ -2244,1 +2246,1 @@\n-            getClass(), short.class, length(),\n+            getClass(), short.class, VECTOR_OPER_TYPE, length(),\n@@ -2436,1 +2438,1 @@\n-            getClass(), shuffletype, null, short.class, length(),\n+            getClass(), shuffletype, null, short.class, VECTOR_OPER_TYPE, length(),\n@@ -2463,1 +2465,1 @@\n-                   getClass(), shuffletype, masktype, short.class, length(),\n+                   getClass(), shuffletype, masktype, short.class, VECTOR_OPER_TYPE, length(),\n@@ -2489,1 +2491,1 @@\n-                getClass(), shuffletype, null, short.class, length(),\n+                getClass(), shuffletype, null, short.class, VECTOR_OPER_TYPE, length(),\n@@ -2497,1 +2499,1 @@\n-                getClass(), shuffletype, null, short.class, length(),\n+                getClass(), shuffletype, null, short.class, VECTOR_OPER_TYPE, length(),\n@@ -2547,1 +2549,1 @@\n-                                                        short.class, length(), this, m,\n+                                                        short.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -2566,1 +2568,1 @@\n-                                                        short.class, length(), this, m,\n+                                                        short.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -2581,1 +2583,1 @@\n-        return (ShortVector)VectorSupport.selectFromOp(getClass(), null, short.class,\n+        return (ShortVector)VectorSupport.selectFromOp(getClass(), null, short.class, VECTOR_OPER_TYPE,\n@@ -2601,1 +2603,1 @@\n-        return (ShortVector)VectorSupport.selectFromOp(getClass(), masktype, short.class,\n+        return (ShortVector)VectorSupport.selectFromOp(getClass(), masktype, short.class, VECTOR_OPER_TYPE,\n@@ -2619,1 +2621,1 @@\n-        return VectorSupport.selectFromTwoVectorOp(getClass(), short.class, length(), this, v1, v2,\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), short.class, VECTOR_OPER_TYPE, length(), this, v1, v2,\n@@ -2839,1 +2841,1 @@\n-            opc, getClass(), maskClass, short.class, length(),\n+            opc, getClass(), maskClass, short.class, VECTOR_OPER_TYPE, length(),\n@@ -2857,1 +2859,1 @@\n-            opc, getClass(), null, short.class, length(),\n+            opc, getClass(), null, short.class, VECTOR_OPER_TYPE, length(),\n@@ -2892,0 +2894,1 @@\n+\n@@ -3138,1 +3141,1 @@\n-            vectorType, null, short.class, vsp.laneCount(),\n+            vectorType, null, short.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3471,1 +3474,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3620,1 +3623,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3825,1 +3828,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3842,1 +3845,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3889,1 +3892,1 @@\n-            vectorType, maskClass, short.class, vsp.laneCount(),\n+            vectorType, maskClass, short.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3905,1 +3908,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3922,1 +3925,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3937,1 +3940,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3953,1 +3956,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3971,1 +3974,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3988,1 +3991,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4003,1 +4006,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4020,1 +4023,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4038,1 +4041,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4141,1 +4144,1 @@\n-    Vector<?>\n+    HalffloatVector\n@@ -4144,2 +4147,1 @@\n-        \/\/ asFloating() will throw UnsupportedOperationException for the unsupported type short\n-        throw new AssertionError(\"Cannot reach here\");\n+        return (HalffloatVector) asVectorRaw(flt);\n@@ -4226,0 +4228,13 @@\n+        @ForceInline\n+        final Class<?> carrierType() {\n+            return short.class;\n+        }\n+\n+        @ForceInline\n+        final int operType() {\n+            if (short.class.equals(Float16.class)) {\n+                return VECTOR_TYPE_FP16;\n+            }\n+            return VECTOR_TYPE_PRIM;\n+        }\n+\n@@ -4258,1 +4273,1 @@\n-                    vectorType, short.class, laneCount,\n+                    vectorType, short.class, VECTOR_OPER_TYPE, laneCount,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":58,"deletions":43,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -3072,0 +3072,13 @@\n+    \/**\n+     * Reinterprets this vector as a vector of the same shape\n+     * and contents but a lane type of {@code halffloat},\n+     * where the lanes are assembled from successive bytes\n+     * according to little-endian order.\n+     * It is a convenience method for the expression\n+     * {@code reinterpretShape(species().withLanes(halffloat.class))}.\n+     * It may be considered an inverse to {@link Vector#reinterpretAsBytes()}.\n+     *\n+     * @return a {@code HalffloatVector} with the same shape and information content\n+     *\/\n+    public abstract HalffloatVector reinterpretAsHalffloats();\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Vector.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -35,0 +36,2 @@\n+    static final Unsafe U = Unsafe.getUnsafe();\n+\n@@ -151,0 +154,4 @@\n+    static <V> V maybeRebox(V v) {\n+        U.loadFence();\n+        return v;\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorIntrinsics.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n@@ -210,2 +212,2 @@\n-                vsp.maskType(), vsp.elementType(), laneCount,\n-                bits, (long) offset + Unsafe.ARRAY_BOOLEAN_BASE_OFFSET, false,\n+                vsp.maskType(), vsp.carrierType(), vsp.operType(), laneCount, bits,\n+                (long) offset + Unsafe.ARRAY_BOOLEAN_BASE_OFFSET, false,\n@@ -214,1 +216,1 @@\n-                  -> s.opm(n -> c[((int )idx) + n]));\n+                  -> s.opm(n -> c[((int)idx) + n]));\n@@ -243,1 +245,2 @@\n-        return VectorSupport.fromBitsCoerced(vsp.maskType(), vsp.elementType(), vsp.laneCount(), bits,\n+        return VectorSupport.fromBitsCoerced(vsp.maskType(), vsp.carrierType(),\n+                                             vsp.operType(), vsp.laneCount(), bits,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorMask.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -697,0 +697,2 @@\n+    \/** Convert {@code byteVal} to {@code (halffloat)byteVal}. *\/\n+    public static final Conversion<Byte,Float16> B2H = convert(\"B2H\", 'C', byte.class, Float16.class, VO_KIND_CAST, VO_ALL);\n@@ -707,0 +709,2 @@\n+    \/** Convert {@code doubleVal} to {@code (halffloat)doubleVal}. *\/\n+    public static final Conversion<Double,Float16> D2H = convert(\"D2H\", 'C', double.class, Float16.class, VO_KIND_CAST, VO_ALL);\n@@ -717,0 +721,2 @@\n+    \/** Convert {@code floatVal} to {@code (halffloat)floatVal}. *\/\n+    public static final Conversion<Float,Float16> F2H = convert(\"F2H\", 'C', float.class, Float16.class, VO_KIND_CAST, VO_ALL);\n@@ -727,0 +733,2 @@\n+    \/** Convert {@code intVal} to {@code (halffloat)intVal}. *\/\n+    public static final Conversion<Integer,Float16> I2H = convert(\"I2H\", 'C', int.class, Float16.class, VO_KIND_CAST, VO_ALL);\n@@ -737,0 +745,2 @@\n+    \/** Convert {@code longVal} to {@code (halffloat)longVal}. *\/\n+    public static final Conversion<Long,Float16> L2H = convert(\"L2H\", 'C', long.class, Float16.class, VO_KIND_CAST, VO_ALL);\n@@ -747,0 +757,15 @@\n+    \/** Convert {@code shortVal} to {@code (halffloat)shortVal}. *\/\n+    public static final Conversion<Short,Float16> S2H = convert(\"S2H\", 'C', short.class, Float16.class, VO_KIND_CAST, VO_ALL);\n+    \/** Convert {@code halffloatVal} to {@code (byte)halffloatVal}. *\/\n+    public static final Conversion<Float16,Byte> H2B = convert(\"H2B\", 'C', Float16.class, byte.class, VO_KIND_CAST, VO_ALL);\n+    \/** Convert {@code halffloatVal} to {@code (short)halffloatVal}. *\/\n+    public static final Conversion<Float16,Short> H2S = convert(\"H2S\", 'C', Float16.class, short.class, VO_KIND_CAST, VO_ALL);\n+    \/** Convert {@code halffloatVal} to {@code (double)halffloatVal}. *\/\n+    public static final Conversion<Float16,Double> H2D = convert(\"H2D\", 'C', Float16.class, double.class, VO_KIND_CAST, VO_ALL);\n+    \/** Convert {@code halffloatVal} to {@code (float)halffloatVal}. *\/\n+    public static final Conversion<Float16,Float> H2F = convert(\"H2F\", 'C', Float16.class, float.class, VO_KIND_CAST, VO_ALL);\n+    \/** Convert {@code halffloatVal} to {@code (int)halffloatVal}. *\/\n+    public static final Conversion<Float16,Integer> H2I = convert(\"H2I\", 'C', Float16.class, int.class, VO_KIND_CAST, VO_ALL);\n+    \/** Convert {@code halffloatVal} to {@code (long)halffloatVal}. *\/\n+    public static final Conversion<Float16,Long> H2L = convert(\"H2L\", 'C', Float16.class, long.class, VO_KIND_CAST, VO_ALL);\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -275,0 +275,3 @@\n+        if (etype == Float16.class) {\n+            etype = short.class;\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorShape.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,0 +44,4 @@\n+#if[FP16]\n+import jdk.incubator.vector.Float16;\n+import static jdk.incubator.vector.Float16.*;\n+#end[FP16]\n@@ -64,1 +68,3 @@\n-    static final ValueLayout.Of$Type$ ELEMENT_LAYOUT = ValueLayout.JAVA_$TYPE$.withByteAlignment(1);\n+    static final int VECTOR_OPER_TYPE = {#if[FP16]?VECTOR_TYPE_FP16:VECTOR_TYPE_PRIM};\n+\n+    static final ValueLayout.Of$ElemLayout$ ELEMENT_LAYOUT = ValueLayout.JAVA_$TYPE$.withByteAlignment(1);\n@@ -514,0 +520,3 @@\n+#if[FP16]\n+        return e;\n+#else[FP16]\n@@ -515,0 +524,1 @@\n+#end[FP16]\n@@ -520,0 +530,3 @@\n+#if[FP16]\n+        return (short)bits;\n+#else[FP16]\n@@ -521,0 +534,1 @@\n+#end[FP16]\n@@ -560,0 +574,4 @@\n+#if[FP16]\n+            int index = shortBitsToFloat16(vecPayload1[i]).intValue();\n+            int wrapped_index = VectorIntrinsics.wrapToRange(index, 2 * vlen);\n+#else[FP16]\n@@ -561,0 +579,1 @@\n+#end[FP16]\n@@ -591,2 +610,2 @@\n-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), $type$.class, species.length(),\n-                        toBits(0.0f), MODE_BROADCAST, vsp,\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), $carriertype$.class, VECTOR_OPER_TYPE, species.length(),\n+                        toBits({#if[FP16]?(short) 0:0.0f}), MODE_BROADCAST, vsp,\n@@ -595,1 +614,1 @@\n-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), $type$.class, species.length(),\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), $carriertype$.class, VECTOR_OPER_TYPE, species.length(),\n@@ -727,1 +746,1 @@\n-            opc, getClass(), null, $type$.class, length(),\n+            opc, getClass(), null, $carriertype$.class, VECTOR_OPER_TYPE, length(),\n@@ -762,1 +781,1 @@\n-            opc, getClass(), maskClass, $type$.class, length(),\n+            opc, getClass(), maskClass, $carriertype$.class, VECTOR_OPER_TYPE, length(),\n@@ -782,0 +801,6 @@\n+#if[FP16]\n+            case VECTOR_OP_NEG: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(-(shortBitsToFloat16(($type$)a).floatValue()))));\n+            case VECTOR_OP_ABS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.abs(shortBitsToFloat16(($type$)a))));\n+#else[FP16]\n@@ -786,0 +811,1 @@\n+#end[FP16]\n@@ -817,0 +843,1 @@\n+#if[!FP16]\n@@ -849,0 +876,34 @@\n+#else[!FP16]\n+            case VECTOR_OP_SIN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.sin(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_COS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.cos(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_TAN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.tan(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_ASIN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.asin(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_ACOS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.acos(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_ATAN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.atan(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_EXP: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.exp(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_LOG: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.log(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_LOG10: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.log10(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_SQRT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.sqrt(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_CBRT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.cbrt(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_SINH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.sinh(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_COSH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.cosh(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_TANH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.tanh(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_EXPM1: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.expm1(shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_LOG1P: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> float16ToShortBits(Float16.valueOf(Math.log1p(shortBitsToFloat16(a).doubleValue()))));\n+#end[!FP16]\n@@ -906,1 +967,1 @@\n-            opc, getClass(), null, $type$.class, length(),\n+            opc, getClass(), null, $carriertype$.class, VECTOR_OPER_TYPE, length(),\n@@ -973,1 +1034,1 @@\n-            opc, getClass(), maskClass, $type$.class, length(),\n+            opc, getClass(), maskClass, $carriertype$.class, VECTOR_OPER_TYPE, length(),\n@@ -993,0 +1054,14 @@\n+#if[FP16]\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> float16ToShortBits(Float16.add(shortBitsToFloat16(a), shortBitsToFloat16(b))));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> float16ToShortBits(Float16.subtract(shortBitsToFloat16(a), shortBitsToFloat16(b))));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> float16ToShortBits(Float16.multiply(shortBitsToFloat16(a), shortBitsToFloat16(b))));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> float16ToShortBits(Float16.divide(shortBitsToFloat16(a), shortBitsToFloat16(b))));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> float16ToShortBits(Float16.max(shortBitsToFloat16(a), shortBitsToFloat16(b))));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> float16ToShortBits(Float16.min(shortBitsToFloat16(a), shortBitsToFloat16(b))));\n+#else[FP16]\n@@ -1005,0 +1080,1 @@\n+#end[FP16]\n@@ -1042,0 +1118,1 @@\n+#if[!FP16]\n@@ -1050,0 +1127,8 @@\n+#else[!FP16]\n+            case VECTOR_OP_ATAN2: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> float16ToShortBits(Float16.valueOf(Math.atan2(shortBitsToFloat16(a).floatValue(), shortBitsToFloat16(b).floatValue()))));\n+            case VECTOR_OP_POW: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> float16ToShortBits(Float16.valueOf(Math.pow(shortBitsToFloat16(a).floatValue(), shortBitsToFloat16(b).floatValue()))));\n+            case VECTOR_OP_HYPOT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> float16ToShortBits(Float16.valueOf(Math.hypot(shortBitsToFloat16(a).floatValue(), shortBitsToFloat16(b).floatValue()))));\n+#end[!FP16]\n@@ -1201,1 +1286,1 @@\n-            opc, getClass(), null, $type$.class, length(),\n+            opc, getClass(), null, $carriertype$.class, VECTOR_OPER_TYPE, length(),\n@@ -1222,1 +1307,1 @@\n-            opc, getClass(), maskClass, $type$.class, length(),\n+            opc, getClass(), maskClass, $carriertype$.class, VECTOR_OPER_TYPE, length(),\n@@ -1306,1 +1391,1 @@\n-            opc, getClass(), null, $type$.class, length(),\n+            opc, getClass(), null, $carriertype$.class, VECTOR_OPER_TYPE, length(),\n@@ -1348,1 +1433,1 @@\n-            opc, getClass(), maskClass, $type$.class, length(),\n+            opc, getClass(), maskClass, $carriertype$.class, VECTOR_OPER_TYPE, length(),\n@@ -1360,0 +1445,4 @@\n+#if[FP16]\n+            case VECTOR_OP_FMA: return (v0, v1_, v2_, m) -> v0.tOp(v1_, v2_, m, (i, a, b, c) ->\n+                                        float16ToShortBits(Float16.fma(shortBitsToFloat16(a), shortBitsToFloat16(b), shortBitsToFloat16(c))));\n+#else[FP16]\n@@ -1362,0 +1451,1 @@\n+#end[FP16]\n@@ -2390,1 +2480,1 @@\n-                $bitstype$ infbits = ($bitstype$) toBits($Boxtype$.POSITIVE_INFINITY);\n+                $bitstype$ infbits = ($bitstype$) toBits({#if[FP16]?float16ToShortBits($Boxtype$.POSITIVE_INFINITY):$Boxtype$.POSITIVE_INFINITY});\n@@ -2444,1 +2534,1 @@\n-                $bitstype$ infbits = ($bitstype$) toBits($Boxtype$.POSITIVE_INFINITY);\n+                $bitstype$ infbits = ($bitstype$) toBits({#if[FP16]?float16ToShortBits($Boxtype$.POSITIVE_INFINITY):$Boxtype$.POSITIVE_INFINITY});\n@@ -2480,1 +2570,1 @@\n-            opc, getClass(), maskType, $type$.class, length(),\n+            opc, getClass(), maskType, $carriertype$.class, VECTOR_OPER_TYPE, length(),\n@@ -2502,1 +2592,1 @@\n-            opc, getClass(), maskType, $type$.class, length(),\n+            opc, getClass(), maskType, $carriertype$.class, VECTOR_OPER_TYPE, length(),\n@@ -2515,1 +2605,1 @@\n-    private static boolean compareWithOp(int cond, $type$ a, $type$ b) {\n+    private static boolean compareWithOp(int cond, $carriertype$ a, $carriertype$ b) {\n@@ -2517,0 +2607,8 @@\n+#if[FP16]\n+            case BT_eq -> Float.float16ToFloat(a) == Float.float16ToFloat(b);\n+            case BT_ne -> Float.float16ToFloat(a) != Float.float16ToFloat(b);\n+            case BT_lt -> Float.float16ToFloat(a) < Float.float16ToFloat(b);\n+            case BT_le -> Float.float16ToFloat(a) <= Float.float16ToFloat(b);\n+            case BT_gt -> Float.float16ToFloat(a) > Float.float16ToFloat(b);\n+            case BT_ge -> Float.float16ToFloat(a) >= Float.float16ToFloat(b);\n+#else[FP16]\n@@ -2523,0 +2621,1 @@\n+#end[FP16]\n@@ -2637,1 +2736,1 @@\n-            getClass(), maskType, $type$.class, length(),\n+            getClass(), maskType, $carriertype$.class, VECTOR_OPER_TYPE, length(),\n@@ -2654,1 +2753,1 @@\n-            getClass(), $type$.class, length(),\n+            getClass(), $carriertype$.class, VECTOR_OPER_TYPE, length(),\n@@ -2663,1 +2762,1 @@\n-                return v.add(sc == 1 ? iota : iota.mul(sc));\n+                return v.add(sc == 1 ? iota : iota.mul({#if[FP16]?float16ToShortBits(Float16.valueOf(sc)):sc}));\n@@ -2868,1 +2967,1 @@\n-            getClass(), shuffletype, null, $type$.class, length(),\n+            getClass(), shuffletype, null, $carriertype$.class, VECTOR_OPER_TYPE, length(),\n@@ -2895,1 +2994,1 @@\n-                   getClass(), shuffletype, masktype, $type$.class, length(),\n+                   getClass(), shuffletype, masktype, $carriertype$.class, VECTOR_OPER_TYPE, length(),\n@@ -2921,1 +3020,1 @@\n-                getClass(), shuffletype, null, $type$.class, length(),\n+                getClass(), shuffletype, null, $carriertype$.class, VECTOR_OPER_TYPE, length(),\n@@ -2929,1 +3028,1 @@\n-                getClass(), shuffletype, null, $type$.class, length(),\n+                getClass(), shuffletype, null, $carriertype$.class, VECTOR_OPER_TYPE, length(),\n@@ -2958,0 +3057,3 @@\n+#if[FP16]\n+        ShortVector idx = convert(VectorOperators.H2S, 0).reinterpretAsShorts();\n+#end[FP16]\n@@ -2991,1 +3093,1 @@\n-                                                        $type$.class, length(), this, m,\n+                                                        $carriertype$.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -3010,1 +3112,1 @@\n-                                                        $type$.class, length(), this, m,\n+                                                        $carriertype$.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -3025,1 +3127,1 @@\n-        return ($Type$Vector)VectorSupport.selectFromOp(getClass(), null, $type$.class,\n+        return ($Type$Vector)VectorSupport.selectFromOp(getClass(), null, $carriertype$.class, VECTOR_OPER_TYPE,\n@@ -3045,1 +3147,1 @@\n-        return ($Type$Vector)VectorSupport.selectFromOp(getClass(), masktype, $type$.class,\n+        return ($Type$Vector)VectorSupport.selectFromOp(getClass(), masktype, $carriertype$.class, VECTOR_OPER_TYPE,\n@@ -3063,1 +3165,1 @@\n-        return VectorSupport.selectFromTwoVectorOp(getClass(), $type$.class, length(), this, v1, v2,\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), $carriertype$.class, VECTOR_OPER_TYPE, length(), this, v1, v2,\n@@ -3412,1 +3514,1 @@\n-            opc, getClass(), maskClass, $type$.class, length(),\n+            opc, getClass(), maskClass, $carriertype$.class, VECTOR_OPER_TYPE, length(),\n@@ -3430,1 +3532,1 @@\n-            opc, getClass(), null, $type$.class, length(),\n+            opc, getClass(), null, $carriertype$.class, VECTOR_OPER_TYPE, length(),\n@@ -3441,0 +3543,10 @@\n+#if[FP16]\n+            case VECTOR_OP_ADD: return (v, m) ->\n+                    toBits(v.rOp(($type$)0, m, (i, a, b) -> float16ToShortBits(Float16.add(shortBitsToFloat16(a), shortBitsToFloat16(b)))));\n+            case VECTOR_OP_MUL: return (v, m) ->\n+                    toBits(v.rOp(float16ToShortBits(Float16.valueOf(1.0f)), m, (i, a, b) -> float16ToShortBits(Float16.multiply(shortBitsToFloat16(a), shortBitsToFloat16(b)))));\n+            case VECTOR_OP_MIN: return (v, m) ->\n+                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> float16ToShortBits(Float16.min(shortBitsToFloat16(a), shortBitsToFloat16(b)))));\n+            case VECTOR_OP_MAX: return (v, m) ->\n+                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> float16ToShortBits(Float16.max(shortBitsToFloat16(a), shortBitsToFloat16(b)))));\n+#else[FP16]\n@@ -3449,0 +3561,1 @@\n+#end[FP16]\n@@ -3469,0 +3582,1 @@\n+\n@@ -3470,2 +3584,2 @@\n-    private static final $type$ MIN_OR_INF = $Boxtype$.NEGATIVE_INFINITY;\n-    private static final $type$ MAX_OR_INF = $Boxtype$.POSITIVE_INFINITY;\n+    private static final $type$ MIN_OR_INF = {#if[FP16]?float16ToShortBits($Boxtype$.NEGATIVE_INFINITY):$Boxtype$.NEGATIVE_INFINITY};\n+    private static final $type$ MAX_OR_INF = {#if[FP16]?float16ToShortBits($Boxtype$.POSITIVE_INFINITY):$Boxtype$.POSITIVE_INFINITY};\n@@ -3608,1 +3722,1 @@\n-            $type$ e = a[i];\n+            $type$ e = {#if[FP16]?shortBitsToFloat16(a[i]).shortValue():a[i]};\n@@ -3649,1 +3763,1 @@\n-            res[i] = (double) a[i];\n+            res[i] = (double) {#if[FP16]?shortBitsToFloat16(a[i]).doubleValue():a[i]};\n@@ -3790,1 +3904,1 @@\n-            vectorType, null, $type$.class, vsp.laneCount(),\n+            vectorType, null, $carriertype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3798,1 +3912,1 @@\n-            vectorType, null, $type$.class, vsp.laneCount(),\n+            vectorType, null, $carriertype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3851,1 +3965,1 @@\n-            vectorType, null, $type$.class, vsp.laneCount(),\n+            vectorType, null, $carriertype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4350,1 +4464,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4477,1 +4591,1 @@\n-            vsp.vectorType(), null, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), null, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4570,1 +4684,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4732,1 +4846,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4946,1 +5060,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4963,1 +5077,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5021,1 +5135,1 @@\n-            vectorType, maskClass, $type$.class, vsp.laneCount(),\n+            vectorType, maskClass, $carriertype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5029,1 +5143,1 @@\n-            vectorType, maskClass, $type$.class, vsp.laneCount(),\n+            vectorType, maskClass, $carriertype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5084,1 +5198,1 @@\n-            vectorType, maskClass, $type$.class, vsp.laneCount(),\n+            vectorType, maskClass, $carriertype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5102,1 +5216,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5119,1 +5233,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5136,1 +5250,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5153,1 +5267,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5168,1 +5282,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5184,1 +5298,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5202,1 +5316,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5219,1 +5333,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5275,1 +5389,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5300,1 +5414,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5314,1 +5428,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5331,1 +5445,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5350,1 +5464,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5480,1 +5594,5 @@\n-    {#if[byteOrShort]?Vector<?>:$Fptype$Vector}\n+#if[FP16]\n+    $Type$Vector\n+#else[FP16]\n+    {#if[byte]?Vector<?>:$Fptype$Vector}\n+#end[FP16]\n@@ -5486,1 +5604,1 @@\n-#if[!byteOrShort]\n+#if[!byte]\n@@ -5488,1 +5606,1 @@\n-#else[!byteOrShort]\n+#else[!byte]\n@@ -5491,1 +5609,1 @@\n-#end[!byteOrShort]\n+#end[!byte]\n@@ -5565,1 +5683,1 @@\n-            super(shape, LaneType.of($type$.class),\n+            super(shape, LaneType.of($elemtype$.class),\n@@ -5573,0 +5691,13 @@\n+        @ForceInline\n+        final Class<?> carrierType() {\n+            return $carriertype$.class;\n+        }\n+\n+        @ForceInline\n+        final int operType() {\n+            if ($elemtype$.class.equals(Float16.class)) {\n+                return VECTOR_TYPE_FP16;\n+            }\n+            return VECTOR_TYPE_PRIM;\n+        }\n+\n@@ -5576,1 +5707,1 @@\n-            return $type$.class;\n+            return $elemtype$.class;\n@@ -5605,1 +5736,1 @@\n-                    vectorType, $type$.class, laneCount,\n+                    vectorType, $carriertype$.class, VECTOR_OPER_TYPE, laneCount,\n@@ -5659,0 +5790,7 @@\n+#if[FP16]\n+                $type$ v = float16ToShortBits(Float16.valueOf(lv));\n+                va[i] = v;\n+                if (Float16.valueOf(lv).intValue() != lv) {\n+                    throw badElementBits(lv, v);\n+                }\n+#else[FP16]\n@@ -5664,0 +5802,1 @@\n+#end[FP16]\n@@ -5899,1 +6038,1 @@\n-        = ($Type$Species) VectorSpecies.ofPreferred($type$.class);\n+        = ($Type$Species) VectorSpecies.ofPreferred($elemtype$.class);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":207,"deletions":68,"binary":false,"changes":275,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<$Boxtype$> ETYPE = $type$.class; \/\/ used by the JVM\n+    static final Class<$Carriertype$> CTYPE = $carriertype$.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<$Boxtype$> ETYPE = $elemtype$.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = {#if[FP16]?VECTOR_TYPE_FP16:VECTOR_TYPE_PRIM};\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<$Carriertype$> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<$Boxtype$> elementType() { return $type$.class; }\n+    public final Class<$Boxtype$> elementType() { return ETYPE; }\n@@ -562,0 +569,18 @@\n+#if[!16L]\n+            case 16: bits = laneHelper(16); break;\n+            case 17: bits = laneHelper(17); break;\n+            case 18: bits = laneHelper(18); break;\n+            case 19: bits = laneHelper(19); break;\n+            case 20: bits = laneHelper(20); break;\n+            case 21: bits = laneHelper(21); break;\n+            case 22: bits = laneHelper(22); break;\n+            case 23: bits = laneHelper(23); break;\n+            case 24: bits = laneHelper(24); break;\n+            case 25: bits = laneHelper(25); break;\n+            case 26: bits = laneHelper(26); break;\n+            case 27: bits = laneHelper(27); break;\n+            case 28: bits = laneHelper(28); break;\n+            case 29: bits = laneHelper(29); break;\n+            case 30: bits = laneHelper(30); break;\n+            case 31: bits = laneHelper(31); break;\n+#end[!16L]\n@@ -574,1 +599,1 @@\n-        return $Type$.$bitstype$BitsTo$Fptype$(bits);\n+        return {#if[FP16]?bits:$Type$.$bitstype$BitsTo$Fptype$(bits)};\n@@ -580,1 +605,1 @@\n-                     VCLASS, ETYPE, VLENGTH,\n+                     VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -584,1 +609,1 @@\n-                     return (long)$Type$.$type$ToRaw$Bitstype$Bits(vecarr[ix]);\n+                     return {#if[FP16]?vecarr[ix]:(long)$Type$.$type$ToRaw$Bitstype$Bits(vecarr[ix])};\n@@ -613,0 +638,18 @@\n+#if[!16L]\n+            case 16: return withLaneHelper(16, e);\n+            case 17: return withLaneHelper(17, e);\n+            case 18: return withLaneHelper(18, e);\n+            case 19: return withLaneHelper(19, e);\n+            case 20: return withLaneHelper(20, e);\n+            case 21: return withLaneHelper(21, e);\n+            case 22: return withLaneHelper(22, e);\n+            case 23: return withLaneHelper(23, e);\n+            case 24: return withLaneHelper(24, e);\n+            case 25: return withLaneHelper(25, e);\n+            case 26: return withLaneHelper(26, e);\n+            case 27: return withLaneHelper(27, e);\n+            case 28: return withLaneHelper(28, e);\n+            case 29: return withLaneHelper(29, e);\n+            case 30: return withLaneHelper(30, e);\n+            case 31: return withLaneHelper(31, e);\n+#end[!16L]\n@@ -630,2 +673,2 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i, (long)$Type$.$type$ToRaw$Bitstype$Bits(e),\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                this, i, (long){#if[FP16]?e:$Type$.$type$ToRaw$Bitstype$Bits(e)},\n@@ -634,1 +677,1 @@\n-                                    res[ix] = $Type$.$bitstype$BitsTo$Type$(($bitstype$)bits);\n+                                    res[ix] = {#if[FP16]?($bitstype$)bits:$Type$.$bitstype$BitsTo$Type$(($bitstype$)bits)};\n@@ -733,1 +776,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -835,1 +878,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -849,1 +892,1 @@\n-        static final Class<$Boxtype$> ETYPE = $type$.class; \/\/ used by the JVM\n+        static final Class<$Carriertype$> CTYPE = $carriertype$.class; \/\/ used by the JVM\n@@ -951,1 +994,1 @@\n-                $masktype$.class, $type$.class, VLENGTH, offset, limit,\n+                $masktype$.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -967,2 +1010,3 @@\n-                $vectortype$.class, $masktype$.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                $vectortype$.class, $masktype$.class, CTYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                {#if[FP16]?Float16.float16ToShortBits(Float16.valueOf(m1.trueCount())):m1.trueCount()}));\n@@ -979,1 +1023,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, $masktype$.class, null, $bitstype$.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, $masktype$.class, null, $bitstype$.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -989,1 +1033,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, $masktype$.class, null, $bitstype$.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, $masktype$.class, null, $bitstype$.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -999,1 +1043,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, $masktype$.class, null, $bitstype$.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, $masktype$.class, null, $bitstype$.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -1009,2 +1053,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, $masktype$.class, $bitstype$.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, $masktype$.class, $bitstype$.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -1016,2 +1061,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, $masktype$.class, $bitstype$.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, $masktype$.class, $bitstype$.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -1023,2 +1069,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, $masktype$.class, $bitstype$.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, $masktype$.class, $bitstype$.class,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -1033,1 +1080,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, $masktype$.class, $bitstype$.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, $masktype$.class, $bitstype$.class,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -1043,1 +1091,1 @@\n-            return VectorSupport.extract($masktype$.class, $type$.class, VLENGTH,\n+            return VectorSupport.extract($masktype$.class, $type$.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -1052,3 +1100,3 @@\n-            return VectorSupport.test(BT_ne, $masktype$.class, $bitstype$.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper((($masktype$)m).getBits()));\n+            return VectorSupport.test(BT_ne, $masktype$.class, $bitstype$.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper((($masktype$)m).getBits()));\n@@ -1060,3 +1108,3 @@\n-            return VectorSupport.test(BT_overflow, $masktype$.class, $bitstype$.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper((($masktype$)m).getBits()));\n+            return VectorSupport.test(BT_overflow, $masktype$.class, $bitstype$.class, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper((($masktype$)m).getBits()));\n@@ -1068,1 +1116,1 @@\n-            return VectorSupport.fromBitsCoerced($masktype$.class, $bitstype$.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced($masktype$.class, $bitstype$.class, VECTOR_OPER_TYPE, VLENGTH,\n@@ -1096,1 +1144,1 @@\n-        static final Class<$Boxbitstype$> ETYPE = $bitstype$.class; \/\/ used by the JVM\n+        static final Class<$Boxbitstype$> CTYPE = $bitstype$.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":81,"deletions":33,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-for type in byte short int long float double\n+for type in byte short int long float double halffloat\n@@ -58,0 +58,1 @@\n+\n@@ -60,0 +61,8 @@\n+\n+  case $type in\n+    halffloat)\n+       type=short\n+       TYPE=SHORT\n+       ;;\n+  esac\n+\n@@ -65,0 +74,1 @@\n+  ElemLayout=$Type\n@@ -69,0 +79,1 @@\n+  maskbitstype=$type\n@@ -75,0 +86,4 @@\n+  carriertype=$type\n+  Carriertype=$Type\n+  elemtype=$type\n+  FPtype=$type\n@@ -76,2 +91,2 @@\n-  case $type in\n-    byte)\n+  case $Type in\n+    Byte)\n@@ -82,1 +97,4 @@\n-    short)\n+    Short)\n+      fptype=halffloat\n+      Fptype=Halffloat\n+      Boxfptype=Halffloat\n@@ -87,1 +105,1 @@\n-    int)\n+    Int)\n@@ -89,0 +107,1 @@\n+      Carriertype=Integer\n@@ -97,1 +116,1 @@\n-    long)\n+    Long)\n@@ -104,1 +123,1 @@\n-    float)\n+    Float)\n@@ -107,0 +126,1 @@\n+      maskbitstype=int\n@@ -111,0 +131,1 @@\n+      FPtype=FP32\n@@ -112,1 +133,1 @@\n-    double)\n+    Double)\n@@ -115,0 +136,1 @@\n+      maskbitstype=long\n@@ -119,0 +141,16 @@\n+      FPtype=FP64\n+      ;;\n+    Halffloat)\n+      kind=FP\n+      bitstype=short\n+      maskbitstype=short\n+      Bitstype=Short\n+      Boxbitstype=Short\n+      sizeInBytes=2\n+      carriertype=short\n+      Carriertype=Short\n+      FPtype=FP16\n+      Boxtype=Float16\n+      elemtype=Float16\n+      ElemLayout=Short\n+      args=\"$args -KbyteOrShort -KshortOrFP -KshortOrHalffloat\"\n@@ -122,2 +160,3 @@\n-  args=\"$args -K$kind -DBoxtype=$Boxtype -DWideboxtype=$Wideboxtype\"\n-  args=\"$args -Dbitstype=$bitstype -DBitstype=$Bitstype -DBoxbitstype=$Boxbitstype\"\n+\n+  args=\"$args -K$FPtype -K$kind -DBoxtype=$Boxtype -DWideboxtype=$Wideboxtype\"\n+  args=\"$args -DElemLayout=$ElemLayout -Dbitstype=$bitstype -Dmaskbitstype=$maskbitstype -DBitstype=$Bitstype -DBoxbitstype=$Boxbitstype\"\n@@ -126,0 +165,1 @@\n+  args=\"$args -Dcarriertype=$carriertype -Delemtype=$elemtype -DCarriertype=$Carriertype\"\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/gen-src.sh","additions":51,"deletions":11,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -0,0 +1,568 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8370691\n+* @summary Test intrinsification of HalffloatVector operations\n+* @modules jdk.incubator.vector\n+* @library \/test\/lib \/\n+* @compile TestHalffloatVectorOperations.java\n+* @run driver\/timeout=480 compiler.vectorapi.TestHalffloatVectorOperations\n+*\/\n+\n+package compiler.vectorapi;\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.*;\n+import static jdk.incubator.vector.Float16.*;\n+import static java.lang.Float.*;\n+import java.util.Arrays;\n+import jdk.test.lib.*;\n+import compiler.lib.generators.Generator;\n+import static compiler.lib.generators.Generators.G;\n+\n+public class TestHalffloatVectorOperations {\n+    short[] input1;\n+    short[] input2;\n+    short[] input3;\n+    short[] output;\n+    static final int LEN = 2048;\n+    static short FP16_SCALAR = (short)0x7777;\n+\n+    static final Float16 FP16_CONST = Float16.valueOf(1023.0f);\n+    static final VectorSpecies<Float16> SPECIES = HalffloatVector.SPECIES_PREFERRED;\n+\n+    public static void main(String args[]) {\n+        \/\/ Test with default MaxVectorSize\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\");\n+\n+        \/\/ Test with different values of MaxVectorSize\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:MaxVectorSize=8\");\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:MaxVectorSize=16\");\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:MaxVectorSize=32\");\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:MaxVectorSize=64\");\n+    }\n+\n+    static void assertResults(int arity, short ... values) {\n+        assert values.length == (arity + 2);\n+        Float16 expected_fp16 = shortBitsToFloat16(values[arity]);\n+        Float16 actual_fp16 = shortBitsToFloat16(values[arity + 1]);\n+        if(!expected_fp16.equals(actual_fp16)) {\n+            String inputs = Arrays.toString(Arrays.copyOfRange(values, 0, arity - 1));\n+            throw new AssertionError(\"Result Mismatch!, input = \" + inputs + \" actual = \" + actual_fp16 +  \" expected = \" + expected_fp16);\n+        }\n+    }\n+\n+    public TestHalffloatVectorOperations() {\n+        input1 = new short[LEN];\n+        input2 = new short[LEN];\n+        input3 = new short[LEN];\n+        output = new short[LEN];\n+\n+        short min_value = float16ToRawShortBits(Float16.MIN_VALUE);\n+        short max_value = float16ToRawShortBits(Float16.MAX_VALUE);\n+        Generator<Short> gen = G.float16s();\n+        for (int i = 0; i < LEN; ++i) {\n+            input1[i] = gen.next();\n+            input2[i] = gen.next();\n+            input3[i] = gen.next();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VHF, \" >0 \"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VHF, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    void vectorAddFloat16() {\n+        int i = 0;\n+        for (; i < SPECIES.loopBound(LEN); i += SPECIES.length()) {\n+            HalffloatVector.fromArray(SPECIES, input1, i)\n+                           .lanewise(VectorOperators.ADD,\n+                                     HalffloatVector.fromArray(SPECIES, input2, i))\n+                           .intoArray(output, i);\n+        }\n+        for (; i < LEN; i++) {\n+            output[i] = float16ToRawShortBits(\n+                            add(shortBitsToFloat16(input1[i]),\n+                                shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorAddFloat16\")\n+    void checkResultAdd() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(float16ToFloat(input1[i]) + float16ToFloat(input2[i]));\n+            assertResults(2, input1[i], input2[i], expected, output[i]);\n+        }\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB_VHF, \" >0 \"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.SUB_VHF, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    void vectorSubFloat16() {\n+        int i = 0;\n+        for (; i < SPECIES.loopBound(LEN); i += SPECIES.length()) {\n+            HalffloatVector.fromArray(SPECIES, input1, i)\n+                           .lanewise(VectorOperators.SUB,\n+                                     HalffloatVector.fromArray(SPECIES, input2, i))\n+                           .intoArray(output, i);\n+        }\n+        for (; i < LEN; i++) {\n+            output[i] = float16ToRawShortBits(\n+                            subtract(shortBitsToFloat16(input1[i]),\n+                                     shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorSubFloat16\")\n+    void checkResultSub() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(float16ToFloat(input1[i]) - float16ToFloat(input2[i]));\n+            assertResults(2, input1[i], input2[i], expected, output[i]);\n+        }\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_VHF, \" >0 \"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.MUL_VHF, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    void vectorMulFloat16() {\n+        int i = 0;\n+        for (; i < SPECIES.loopBound(LEN); i += SPECIES.length()) {\n+            HalffloatVector.fromArray(SPECIES, input1, i)\n+                           .lanewise(VectorOperators.MUL,\n+                                     HalffloatVector.fromArray(SPECIES, input2, i))\n+                           .intoArray(output, i);\n+        }\n+        for (; i < LEN; i++) {\n+            output[i] = float16ToRawShortBits(\n+                            multiply(shortBitsToFloat16(input1[i]),\n+                                     shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorMulFloat16\")\n+    void checkResultMul() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(float16ToFloat(input1[i]) * float16ToFloat(input2[i]));\n+            assertResults(2, input1[i], input2[i], expected, output[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.DIV_VHF, \" >0 \"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.DIV_VHF, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    void vectorDivFloat16() {\n+        int i = 0;\n+        for (; i < SPECIES.loopBound(LEN); i += SPECIES.length()) {\n+            HalffloatVector.fromArray(SPECIES, input1, i)\n+                           .lanewise(VectorOperators.DIV,\n+                                     HalffloatVector.fromArray(SPECIES, input2, i))\n+                           .intoArray(output, i);\n+        }\n+        for (; i < LEN; i++) {\n+            output[i] = float16ToRawShortBits(\n+                            divide(shortBitsToFloat16(input1[i]),\n+                                   shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorDivFloat16\")\n+    void checkResultDiv() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(float16ToFloat(input1[i]) \/ float16ToFloat(input2[i]));\n+            assertResults(2, input1[i], input2[i], expected, output[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MIN_VHF, \" >0 \"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.MIN_VHF, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    void vectorMinFloat16() {\n+        int i = 0;\n+        for (; i < SPECIES.loopBound(LEN); i += SPECIES.length()) {\n+            HalffloatVector.fromArray(SPECIES, input1, i)\n+                           .lanewise(VectorOperators.MIN,\n+                                     HalffloatVector.fromArray(SPECIES, input2, i))\n+                           .intoArray(output, i);\n+        }\n+        for (; i < LEN; i++) {\n+            output[i] = float16ToRawShortBits(\n+                            min(shortBitsToFloat16(input1[i]),\n+                                shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorMinFloat16\")\n+    void checkResultMin() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(Math.min(float16ToFloat(input1[i]), float16ToFloat(input2[i])));\n+            assertResults(2, input1[i], input2[i], expected, output[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MAX_VHF, \" >0 \"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.MAX_VHF, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    void vectorMaxFloat16() {\n+        int i = 0;\n+        for (; i < SPECIES.loopBound(LEN); i += SPECIES.length()) {\n+            HalffloatVector.fromArray(SPECIES, input1, i)\n+                           .lanewise(VectorOperators.MAX,\n+                                     HalffloatVector.fromArray(SPECIES, input2, i))\n+                           .intoArray(output, i);\n+        }\n+        for (; i < LEN; i++) {\n+            output[i] = float16ToRawShortBits(\n+                            max(shortBitsToFloat16(input1[i]),\n+                                shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorMaxFloat16\")\n+    void checkResultMax() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(Math.max(float16ToFloat(input1[i]), float16ToFloat(input2[i])));\n+            assertResults(2, input1[i], input2[i], expected, output[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SQRT_VHF, \" >0 \"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.SQRT_VHF, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    void vectorSqrtFloat16() {\n+        int i = 0;\n+        for (; i < SPECIES.loopBound(LEN); i += SPECIES.length()) {\n+            HalffloatVector.fromArray(SPECIES, input1, i)\n+                           .lanewise(VectorOperators.SQRT)\n+                           .intoArray(output, i);\n+        }\n+        for (; i < LEN; i++) {\n+            output[i] = float16ToRawShortBits(shortBitsToFloat16(input1[i]));\n+        }\n+    }\n+\n+    @Check(test=\"vectorSqrtFloat16\")\n+    void checkResultSqrt() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = float16ToRawShortBits(sqrt(shortBitsToFloat16(input1[i])));\n+            assertResults(1, input1[i], expected, output[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.FMA_VHF, \" >0 \"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.FMA_VHF, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    void vectorFmaFloat16() {\n+        int i = 0;\n+        for (; i < SPECIES.loopBound(LEN); i += SPECIES.length()) {\n+            HalffloatVector.fromArray(SPECIES, input1, i)\n+                           .lanewise(VectorOperators.FMA,\n+                                     HalffloatVector.fromArray(SPECIES, input2, i),\n+                                     HalffloatVector.fromArray(SPECIES, input3, i))\n+                           .intoArray(output, i);\n+        }\n+        for (; i < LEN; i++) {\n+            output[i] = float16ToRawShortBits(\n+                            fma(shortBitsToFloat16(input1[i]),\n+                                shortBitsToFloat16(input2[i]),\n+                                shortBitsToFloat16(input3[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorFmaFloat16\")\n+    void checkResultFma() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i]),\n+                                                       shortBitsToFloat16(input3[i])));\n+            assertResults(3, input1[i], input2[i], input3[i], expected, output[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.FMA_VHF, \" >0 \"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.FMA_VHF, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    void vectorFmaFloat16ScalarMixedConstants() {\n+        int i = 0;\n+        for (; i < SPECIES.loopBound(LEN); i += SPECIES.length()) {\n+            HalffloatVector.fromArray(SPECIES, input1, i)\n+                           .lanewise(VectorOperators.FMA,\n+                                     FP16_SCALAR,\n+                                     floatToFloat16(3.0f))\n+                           .intoArray(output, i);\n+        }\n+        for (; i < LEN; i++) {\n+            output[i] = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]),\n+                                                  shortBitsToFloat16(FP16_SCALAR),\n+                                                  shortBitsToFloat16(floatToFloat16(3.0f))));\n+        }\n+    }\n+\n+    @Check(test=\"vectorFmaFloat16ScalarMixedConstants\")\n+    void checkResultFmaScalarMixedConstants() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(FP16_SCALAR),\n+                                                       shortBitsToFloat16(floatToFloat16(3.0f))));\n+            assertResults(2, input1[i], FP16_SCALAR, expected, output[i]);\n+        }\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.FMA_VHF, \" >0 \"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.FMA_VHF, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    void vectorFmaFloat16MixedConstants() {\n+        short input3 = floatToFloat16(3.0f);\n+        int i = 0;\n+        for (; i < SPECIES.loopBound(LEN); i += SPECIES.length()) {\n+            HalffloatVector.fromArray(SPECIES, input1, i)\n+                           .lanewise(VectorOperators.FMA,\n+                                     HalffloatVector.fromArray(SPECIES, input2, i),\n+                                     input3)\n+                           .intoArray(output, i);\n+        }\n+        for (; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]),\n+                                                  shortBitsToFloat16(input2[i]),\n+                                                  shortBitsToFloat16(input3)));\n+        }\n+    }\n+\n+\n+    @Check(test=\"vectorFmaFloat16MixedConstants\")\n+    void checkResultFmaMixedConstants() {\n+        short input3 = floatToFloat16(3.0f);\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i]), shortBitsToFloat16(input3)));\n+            assertResults(3, input1[i], input2[i], input3, expected, output[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.FMA_VHF, \" >0 \"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.FMA_VHF, \" 0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    void vectorFmaFloat16AllConstants() {\n+        short input1 = floatToFloat16(1.0f);\n+        short input2 = floatToFloat16(2.0f);\n+        short input3 = floatToFloat16(3.0f);\n+        int i = 0;\n+        for (; i < SPECIES.loopBound(LEN); i += SPECIES.length()) {\n+            HalffloatVector.broadcast(SPECIES, input1)\n+                           .lanewise(VectorOperators.FMA,\n+                                     input2,\n+                                     input3)\n+                           .intoArray(output, i);\n+        }\n+        for (; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(fma(shortBitsToFloat16(input1),\n+                                                  shortBitsToFloat16(input2),\n+                                                  shortBitsToFloat16(input3)));\n+        }\n+    }\n+\n+    @Check(test=\"vectorFmaFloat16AllConstants\")\n+    void checkResultFmaAllConstants() {\n+        short input1 = floatToFloat16(1.0f);\n+        short input2 = floatToFloat16(2.0f);\n+        short input3 = floatToFloat16(3.0f);\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = float16ToRawShortBits(fma(shortBitsToFloat16(input1), shortBitsToFloat16(input2), shortBitsToFloat16(input3)));\n+            assertResults(3, input1, input2, input3, expected, output[i]);\n+        }\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VHF, \" >0 \"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VHF, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    void vectorAddConstInputFloat16() {\n+        int i = 0;\n+        for (; i < SPECIES.loopBound(LEN); i += SPECIES.length()) {\n+            HalffloatVector.fromArray(SPECIES, input1, i)\n+                           .lanewise(VectorOperators.ADD,\n+                                     float16ToRawShortBits(FP16_CONST))\n+                           .intoArray(output, i);\n+        }\n+        for (; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(add(shortBitsToFloat16(input1[i]),\n+                                                  FP16_CONST));\n+        }\n+     }\n+\n+    @Check(test=\"vectorAddConstInputFloat16\")\n+    void checkResultAddConstantInputFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(float16ToFloat(input1[i]) + FP16_CONST.floatValue());\n+            assertResults(2, input1[i], float16ToRawShortBits(FP16_CONST), expected, output[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB_VHF, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    void vectorSubConstInputFloat16() {\n+        int i = 0;\n+        for (; i < SPECIES.loopBound(LEN); i += SPECIES.length()) {\n+            HalffloatVector.fromArray(SPECIES, input1, i)\n+                           .lanewise(VectorOperators.SUB,\n+                                     float16ToRawShortBits(FP16_CONST))\n+                           .intoArray(output, i);\n+        }\n+        for (; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(subtract(shortBitsToFloat16(input1[i]),\n+                                                       FP16_CONST));\n+        }\n+    }\n+\n+    @Check(test=\"vectorSubConstInputFloat16\")\n+    void checkResultSubConstantInputFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(float16ToFloat(input1[i]) - FP16_CONST.floatValue());\n+            assertResults(2, input1[i], float16ToRawShortBits(FP16_CONST), expected, output[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_VHF, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    void vectorMulConstantInputFloat16() {\n+        int i = 0;\n+        for (; i < SPECIES.loopBound(LEN); i += SPECIES.length()) {\n+            HalffloatVector.fromArray(SPECIES, input2, i)\n+                           .lanewise(VectorOperators.MUL,\n+                                     float16ToRawShortBits(FP16_CONST))\n+                           .intoArray(output, i);\n+        }\n+        for (; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(multiply(FP16_CONST,\n+                                                       shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorMulConstantInputFloat16\")\n+    void checkResultMulConstantInputFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(FP16_CONST.floatValue() * float16ToFloat(input2[i]));\n+            assertResults(2, float16ToRawShortBits(FP16_CONST), input2[i], expected, output[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.DIV_VHF, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    void vectorDivConstantInputFloat16() {\n+        int i = 0;\n+        for (; i < SPECIES.loopBound(LEN); i += SPECIES.length()) {\n+            HalffloatVector.fromArray(SPECIES, input2, i)\n+                           .lanewise(VectorOperators.DIV,\n+                                     float16ToRawShortBits(FP16_CONST))\n+                           .intoArray(output, i);\n+        }\n+        for (; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(divide(shortBitsToFloat16(input2[i]),\n+                                                     FP16_CONST));\n+        }\n+    }\n+\n+    @Check(test=\"vectorDivConstantInputFloat16\")\n+    void checkResultDivConstantInputFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(float16ToFloat(input2[i]) \/ FP16_CONST.floatValue());\n+            assertResults(2, input2[i], float16ToRawShortBits(FP16_CONST), expected, output[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MAX_VHF, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    void vectorMaxConstantInputFloat16() {\n+        int i = 0;\n+        for (; i < SPECIES.loopBound(LEN); i += SPECIES.length()) {\n+            HalffloatVector.fromArray(SPECIES, input2, i)\n+                           .lanewise(VectorOperators.MAX,\n+                                     float16ToRawShortBits(FP16_CONST))\n+                           .intoArray(output, i);\n+        }\n+        for (; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(max(FP16_CONST,\n+                                                  shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorMaxConstantInputFloat16\")\n+    void checkResultMaxConstantInputFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(Math.max(FP16_CONST.floatValue(), float16ToFloat(input2[i])));\n+            assertResults(2, float16ToRawShortBits(FP16_CONST), input2[i], expected, output[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MIN_VHF, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    void vectorMinConstantInputFloat16() {\n+        int i = 0;\n+        for (; i < SPECIES.loopBound(LEN); i += SPECIES.length()) {\n+            HalffloatVector.fromArray(SPECIES, input2, i)\n+                           .lanewise(VectorOperators.MIN,\n+                                     float16ToRawShortBits(FP16_CONST))\n+                           .intoArray(output, i);\n+        }\n+        for (; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(min(FP16_CONST,\n+                                                  shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorMinConstantInputFloat16\")\n+    void checkResultMinConstantInputFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(Math.min(FP16_CONST.floatValue(), float16ToFloat(input2[i])));\n+            assertResults(2, float16ToRawShortBits(FP16_CONST), input2[i], expected, output[i]);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestHalffloatVectorOperations.java","additions":568,"deletions":0,"binary":false,"changes":568,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import jdk.incubator.vector.Float16;\n@@ -159,0 +160,25 @@\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill_halffloat(int s, ToHalffloatF f) {\n+        return fill_halffloat(new short[s], f);\n+    }\n+\n+    static short[] fill_halffloat(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        if (a.length > 7) {\n+            a[0] = Float16.float16ToRawShortBits(Float16.MAX_VALUE);\n+            a[1] = Float16.float16ToRawShortBits(Float16.MIN_VALUE);\n+            a[2] = Float16.float16ToRawShortBits(Float16.NEGATIVE_INFINITY);\n+            a[3] = Float16.float16ToRawShortBits(Float16.POSITIVE_INFINITY);\n+            a[4] = Float16.float16ToRawShortBits(Float16.NaN);\n+            a[5] = (short)0.0;\n+            a[6] = Short.MIN_VALUE;\n+        }\n+        return a;\n+    }\n+\n+\n@@ -183,0 +209,4 @@\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16(i)\", (int s) -> fill_halffloat(s, i -> (short) (i * 100 + 1)))\n+    );\n+\n@@ -202,0 +232,3 @@\n+        else if (src == Float16.class) {\n+            return HALFFLOAT_GENERATORS;\n+        }\n@@ -209,1 +242,1 @@\n-        for (Class<?> srcE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class)) {\n+        for (Class<?> srcE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class, Float16.class)) {\n@@ -213,1 +246,1 @@\n-            for (Class<?> dstE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class)) {\n+            for (Class<?> dstE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class, Float16.class)) {\n@@ -228,1 +261,1 @@\n-        for (Class<?> srcE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class)) {\n+        for (Class<?> srcE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class, Float16.class)) {\n@@ -233,1 +266,1 @@\n-                for (Class<?> dstE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class)) {\n+                for (Class<?> dstE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class, Float16.class)) {\n@@ -248,1 +281,1 @@\n-        for (Class<?> srcE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class)) {\n+        for (Class<?> srcE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class, Float16.class)) {\n@@ -251,1 +284,1 @@\n-                for (Class<?> dstE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class)) {\n+                for (Class<?> dstE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class, Float16.class)) {\n@@ -264,0 +297,16 @@\n+    static Short float16_conversion_adapter(Number in) {\n+        if (in.getClass() == Short.class)\n+            return Float16.float16ToRawShortBits(Float16.valueOf(in.shortValue()));\n+        else if (in.getClass() == Integer.class)\n+            return Float16.float16ToRawShortBits(Float16.valueOf(in.intValue()));\n+        else if (in.getClass() == Long.class)\n+            return Float16.float16ToRawShortBits(Float16.valueOf(in.longValue()));\n+        else if (in.getClass() == Float.class)\n+            return Float16.float16ToRawShortBits(Float16.valueOf(in.floatValue()));\n+        else if (in.getClass() == Double.class)\n+            return Float16.float16ToRawShortBits(Float16.valueOf(in.doubleValue()));\n+        else if (in.getClass() == Byte.class)\n+            return Float16.float16ToRawShortBits(Float16.valueOf(in.byteValue()));\n+        else\n+            throw new IllegalStateException();\n+    }\n@@ -276,0 +325,2 @@\n+        else if (to == Float16.class)\n+            return (N) -> float16_conversion_adapter(N);\n@@ -285,1 +336,1 @@\n-        else if (from == short.class)\n+        else if (from == short.class || from == Float16.class)\n@@ -302,1 +353,1 @@\n-        else if (to == short.class)\n+        else if (to == short.class || to == Float16.class)\n@@ -338,0 +389,2 @@\n+                                    VectorSpecies srcSpecies,\n+                                    VectorSpecies dstSpecies,\n@@ -339,0 +392,4 @@\n+        if (srcSpecies.elementType() == dstSpecies.elementType()) {\n+            System.arraycopy(src, srcPos, dest, destPos, length);\n+            return;\n+        }\n@@ -341,1 +398,8 @@\n-            Array.set(dest, destPos + i, c.apply(v));\n+            if (srcSpecies.elementType() == Float16.class) {\n+                v = (Number) Float16.shortBitsToFloat16(v.shortValue());\n+            }\n+            v = (Number) c.apply(v);\n+            if (dstSpecies.elementType() == Float16.class) {\n+                v = (Number) v.shortValue();\n+            }\n+            Array.set(dest, destPos + i, v);\n@@ -423,2 +487,8 @@\n-        Object expected = Array.newInstance(destSpecies.elementType(), out_len);\n-        Object actual = Array.newInstance(destSpecies.elementType(), out_len);\n+        Object expected = null, actual = null;\n+        if (destSpecies.elementType() == Float16.class) {\n+            expected = Array.newInstance(short.class, out_len);\n+            actual = Array.newInstance(short.class, out_len);\n+        } else {\n+            expected = Array.newInstance(destSpecies.elementType(), out_len);\n+            actual = Array.newInstance(destSpecies.elementType(), out_len);\n+        }\n@@ -435,1 +505,1 @@\n-                copyConversionArray(in, i, expected, start_idx + j, src_species_len, convertValue);\n+                copyConversionArray(in, i, expected, start_idx + j, src_species_len, srcSpecies, destSpecies, convertValue);\n@@ -438,1 +508,1 @@\n-                copyConversionArray(in, start_idx + i, expected, j, dst_species_len, convertValue);\n+                copyConversionArray(in, start_idx + i, expected, j, dst_species_len, srcSpecies, destSpecies, convertValue);\n@@ -440,0 +510,1 @@\n+\n@@ -455,1 +526,0 @@\n-\n@@ -472,2 +542,8 @@\n-        Object expected = Array.newInstance(dstSpecies.elementType(), out_len);\n-        Object actual = Array.newInstance(dstSpecies.elementType(), out_len);\n+        Object expected = null, actual = null;\n+        if (dstSpecies.elementType() == Float16.class) {\n+            expected = Array.newInstance(short.class, out_len);\n+            actual = Array.newInstance(short.class, out_len);\n+        } else {\n+            expected = Array.newInstance(dstSpecies.elementType(), out_len);\n+            actual = Array.newInstance(dstSpecies.elementType(), out_len);\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorConversionTest.java","additions":93,"deletions":17,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,45 @@\n+    static ByteVector bcast_vec = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    static void AssertEquals(byte actual, byte expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(byte actual, byte expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(byte actual, byte expected, byte delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(byte actual, byte expected, byte delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(byte [] actual, byte [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(byte [] actual, byte [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -87,1 +132,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -90,1 +135,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -102,1 +147,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -108,1 +153,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -118,1 +163,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -121,1 +166,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -137,1 +182,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -139,1 +184,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -142,2 +187,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -159,1 +204,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -161,1 +206,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -164,2 +209,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -181,1 +226,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -183,1 +228,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -186,2 +231,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -203,1 +248,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -205,1 +250,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -208,2 +253,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -221,1 +266,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -224,1 +269,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -236,1 +281,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -239,1 +284,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -248,1 +293,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -253,1 +298,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -264,1 +309,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -269,1 +314,1 @@\n-                    Assert.assertEquals(r[i + k], (byte)0);\n+                    AssertEquals(r[i + k], (byte)0);\n@@ -275,1 +320,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -277,1 +322,1 @@\n-                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (byte)0, \"at index #\" + idx);\n@@ -289,1 +334,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -292,1 +337,1 @@\n-                        Assert.assertEquals(r[i + j], (byte)0);\n+                        AssertEquals(r[i + j], (byte)0);\n@@ -299,1 +344,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -301,1 +346,1 @@\n-                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (byte)0, \"at index #\" + idx);\n@@ -317,1 +362,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -321,1 +366,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -327,0 +372,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -330,1 +376,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -334,2 +382,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -345,1 +392,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -347,1 +394,1 @@\n-                         Assert.assertEquals(r[i+j], (byte)0);\n+                         AssertEquals(r[i+j], (byte)0);\n@@ -353,1 +400,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -355,1 +402,1 @@\n-                Assert.assertEquals(r[i+j], (byte)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (byte)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -361,0 +408,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -364,0 +412,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -365,1 +415,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -367,1 +417,1 @@\n-                         Assert.assertEquals(r[i+j], (byte)0);\n+                         AssertEquals(r[i+j], (byte)0);\n@@ -371,1 +421,0 @@\n-            int idx = i + j;\n@@ -373,1 +422,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -375,1 +424,1 @@\n-                Assert.assertEquals(r[i+j], (byte)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (byte)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -389,1 +438,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -392,1 +441,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -413,1 +462,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -416,1 +465,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -419,1 +468,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -422,3 +471,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -439,1 +488,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -442,1 +491,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -445,1 +494,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -448,3 +497,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -458,1 +507,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -461,1 +510,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -469,1 +518,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -472,1 +521,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -480,1 +529,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -483,1 +532,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -492,1 +541,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -495,1 +544,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -508,1 +557,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -511,1 +560,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -523,1 +572,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -526,1 +575,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -538,1 +587,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -541,1 +590,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -556,1 +605,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -559,1 +608,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -572,1 +621,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -576,1 +625,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -590,1 +639,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -594,1 +643,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -616,1 +665,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -620,1 +669,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -634,1 +683,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -638,1 +687,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -658,1 +707,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -661,1 +710,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -673,1 +722,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -676,1 +725,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -685,1 +734,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -688,1 +737,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -698,1 +747,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -701,1 +750,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -717,1 +766,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -721,1 +770,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -738,1 +787,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -742,1 +791,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -753,1 +802,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -757,1 +806,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -774,1 +823,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -778,1 +827,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -796,1 +845,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -802,1 +851,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -823,1 +872,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -829,1 +878,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -844,1 +893,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -850,1 +899,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -871,1 +920,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -877,1 +926,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -891,1 +940,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -897,1 +946,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -912,1 +961,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -918,1 +967,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -933,1 +982,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -939,1 +988,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -955,1 +1004,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -961,1 +1010,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -969,0 +1018,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -974,1 +1027,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -977,1 +1030,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -986,1 +1039,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -989,1 +1042,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -997,1 +1050,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -1000,1 +1053,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1008,1 +1061,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                AssertEquals(r[i], (double)(a[i+offs]));\n@@ -1011,1 +1064,1 @@\n-            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1020,1 +1073,1 @@\n-            withToString(\"byte[-i * 5]\", (int s) -> {\n+            withToString(\"Byte[-i * 5]\", (int s) -> {\n@@ -1022,1 +1075,1 @@\n-                            i -> (byte)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1024,1 +1077,1 @@\n-            withToString(\"byte[i * 5]\", (int s) -> {\n+            withToString(\"Byte[i * 5]\", (int s) -> {\n@@ -1026,1 +1079,1 @@\n-                            i -> (byte)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1028,1 +1081,1 @@\n-            withToString(\"byte[i + 1]\", (int s) -> {\n+            withToString(\"Byte[i + 1]\", (int s) -> {\n@@ -1030,1 +1083,1 @@\n-                            i -> (((byte)(i + 1) == 0) ? 1 : (byte)(i + 1)));\n+                            i -> (((byte)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1477,0 +1530,212 @@\n+    static byte firstNonZero(byte a, byte b) {\n+        return Byte.compare(a, (byte) 0) != 0 ? a : b;\n+    }\n+\n+    static byte multiplicativeIdentity() {\n+        return (byte)1;\n+    }\n+\n+    static byte scalar_or(byte a, byte b) {\n+        return (byte)(a | b);\n+    }\n+\n+    static byte scalar_and(byte a, byte b) {\n+        return (byte)(a & b);\n+    }\n+\n+    static byte scalar_xor(byte a, byte b) {\n+        return (byte)(a ^ b);\n+    }\n+\n+    static byte scalar_add(byte a, byte b) {\n+        return (byte)(a + b);\n+    }\n+\n+    static byte scalar_sub(byte a, byte b) {\n+        return (byte)(a - b);\n+    }\n+\n+    static byte scalar_mul(byte a, byte b) {\n+        return (byte)(a * b);\n+    }\n+\n+    static byte scalar_min(byte a, byte b) {\n+        return (byte)(Math.min(a, b));\n+    }\n+\n+    static byte scalar_max(byte a, byte b) {\n+        return (byte)(Math.max(a, b));\n+    }\n+\n+    static byte scalar_div(byte a, byte b) {\n+        return (byte)(a \/ b);\n+    }\n+\n+    static byte scalar_fma(byte a, byte b, byte c) {\n+        return (byte)(Math.fma(a, b, c));\n+    }\n+\n+    static byte scalar_abs(byte a) {\n+        return (byte)(Math.abs(a));\n+    }\n+\n+    static byte scalar_neg(byte a) {\n+        return ((byte)-a);\n+    }\n+\n+    static byte scalar_sin(byte a) {\n+        return (byte)Math.sin((double)a);\n+    }\n+\n+    static byte scalar_exp(byte a) {\n+        return (byte)Math.exp((double)a);\n+    }\n+\n+    static byte scalar_log1p(byte a) {\n+        return (byte)Math.log1p((double)a);\n+    }\n+\n+    static byte scalar_log(byte a) {\n+        return (byte)Math.log((double)a);\n+    }\n+\n+    static byte scalar_log10(byte a) {\n+        return (byte)Math.log10((double)a);\n+    }\n+\n+    static byte scalar_expm1(byte a) {\n+        return (byte)Math.expm1((double)a);\n+    }\n+\n+    static byte scalar_cos(byte a) {\n+        return (byte)Math.cos((double)a);\n+    }\n+\n+    static byte scalar_tan(byte a) {\n+        return (byte)Math.tan((double)a);\n+    }\n+\n+    static byte scalar_sinh(byte a) {\n+        return (byte)Math.sinh((double)a);\n+    }\n+\n+    static byte scalar_cosh(byte a) {\n+        return (byte)Math.cosh((double)a);\n+    }\n+\n+    static byte scalar_tanh(byte a) {\n+        return (byte)Math.tanh((double)a);\n+    }\n+\n+    static byte scalar_asin(byte a) {\n+        return (byte)Math.asin((double)a);\n+    }\n+\n+    static byte scalar_acos(byte a) {\n+        return (byte)Math.acos((double)a);\n+    }\n+\n+    static byte scalar_atan(byte a) {\n+        return (byte)Math.atan((double)a);\n+    }\n+\n+    static byte scalar_cbrt(byte a) {\n+        return (byte)Math.cbrt((double)a);\n+    }\n+\n+    static byte scalar_sqrt(byte a) {\n+        return (byte)Math.sqrt((double)a);\n+    }\n+\n+    static byte scalar_hypot(byte a, byte b) {\n+        return (byte)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static byte scalar_pow(byte a, byte b) {\n+        return (byte)Math.pow((double)a, (double)b);\n+    }\n+\n+    static byte scalar_atan2(byte a, byte b) {\n+        return (byte)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static byte strict_scalar_sin(byte a) {\n+        return (byte)StrictMath.sin((double)a);\n+    }\n+\n+    static byte strict_scalar_exp(byte a) {\n+        return (byte)StrictMath.exp((double)a);\n+    }\n+\n+    static byte strict_scalar_log1p(byte a) {\n+        return (byte)StrictMath.log1p((double)a);\n+    }\n+\n+    static byte strict_scalar_log(byte a) {\n+        return (byte)StrictMath.log((double)a);\n+    }\n+\n+    static byte strict_scalar_log10(byte a) {\n+        return (byte)StrictMath.log10((double)a);\n+    }\n+\n+    static byte strict_scalar_expm1(byte a) {\n+        return (byte)StrictMath.expm1((double)a);\n+    }\n+\n+    static byte strict_scalar_cos(byte a) {\n+        return (byte)StrictMath.cos((double)a);\n+    }\n+\n+    static byte strict_scalar_tan(byte a) {\n+        return (byte)StrictMath.tan((double)a);\n+    }\n+\n+    static byte strict_scalar_sinh(byte a) {\n+        return (byte)StrictMath.sinh((double)a);\n+    }\n+\n+    static byte strict_scalar_cosh(byte a) {\n+        return (byte)StrictMath.cosh((double)a);\n+    }\n+\n+    static byte strict_scalar_tanh(byte a) {\n+        return (byte)StrictMath.tanh((double)a);\n+    }\n+\n+    static byte strict_scalar_asin(byte a) {\n+        return (byte)StrictMath.asin((double)a);\n+    }\n+\n+    static byte strict_scalar_acos(byte a) {\n+        return (byte)StrictMath.acos((double)a);\n+    }\n+\n+    static byte strict_scalar_atan(byte a) {\n+        return (byte)StrictMath.atan((double)a);\n+    }\n+\n+    static byte strict_scalar_cbrt(byte a) {\n+        return (byte)StrictMath.cbrt((double)a);\n+    }\n+\n+    static byte strict_scalar_sqrt(byte a) {\n+        return (byte)StrictMath.sqrt((double)a);\n+    }\n+\n+    static byte strict_scalar_hypot(byte a, byte b) {\n+        return (byte)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static byte strict_scalar_pow(byte a, byte b) {\n+        return (byte)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static byte strict_scalar_atan2(byte a, byte b) {\n+        return (byte)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static byte additiveIdentity() {\n+        return (byte)0;\n+    }\n+\n+\n@@ -1493,2 +1758,10 @@\n-    static byte firstNonZero(byte a, byte b) {\n-        return Byte.compare(a, (byte) 0) != 0 ? a : b;\n+    static byte zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static byte maxValue() {\n+        return Byte.MAX_VALUE;\n+    }\n+\n+    static byte minValue() {\n+        return Byte.MIN_VALUE;\n@@ -1497,0 +1770,1 @@\n+\n@@ -1532,1 +1806,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1547,1 +1821,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1553,1 +1827,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1559,1 +1833,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1574,1 +1848,1 @@\n-        Assert.assertEquals(asIntegral.species(), SPECIES);\n+        AssertEquals(asIntegral.species(), SPECIES);\n@@ -1604,1 +1878,1 @@\n-        return (byte)(a + b);\n+        return (byte)(scalar_add(a, b));\n@@ -1625,1 +1899,1 @@\n-        return (byte)(a + b);\n+        return (byte)(scalar_add(a, b));\n@@ -1682,1 +1956,1 @@\n-        return (byte)(a - b);\n+        return (byte)(scalar_sub(a, b));\n@@ -1703,1 +1977,1 @@\n-        return (byte)(a - b);\n+        return (byte)(scalar_sub(a, b));\n@@ -1760,1 +2034,1 @@\n-        return (byte)(a * b);\n+        return (byte)(scalar_mul(a, b));\n@@ -1781,1 +2055,1 @@\n-        return (byte)(a * b);\n+        return (byte)(scalar_mul(a, b));\n@@ -1928,1 +2202,1 @@\n-        return (byte)((a)!=0?a:b);\n+        return (byte)(firstNonZero(a, b));\n@@ -3035,2 +3309,0 @@\n-    static ByteVector bv_MIN = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3045,1 +3317,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -3052,2 +3324,0 @@\n-    static ByteVector bv_min = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3062,1 +3332,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -3069,2 +3339,0 @@\n-    static ByteVector bv_MIN_M = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3081,1 +3349,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -3088,2 +3356,0 @@\n-    static ByteVector bv_MAX = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3098,1 +3364,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -3105,2 +3371,0 @@\n-    static ByteVector bv_max = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3115,1 +3379,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -3122,2 +3386,0 @@\n-    static ByteVector bv_MAX_M = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3134,1 +3396,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -3142,1 +3404,1 @@\n-        return (byte)(Math.min(a, b));\n+        return (byte)(scalar_min(a, b));\n@@ -3163,1 +3425,1 @@\n-        return (byte)(Math.min(a, b));\n+        return (byte)(scalar_min(a, b));\n@@ -3182,1 +3444,1 @@\n-        return (byte)(Math.max(a, b));\n+        return (byte)(scalar_max(a, b));\n@@ -3203,1 +3465,1 @@\n-        return (byte)(Math.max(a, b));\n+        return (byte)(scalar_max(a, b));\n@@ -3571,1 +3833,1 @@\n-            res &= a[i];\n+            res = scalar_and(res, a[i]);\n@@ -3580,1 +3842,1 @@\n-            res &= ANDReduce(a, i);\n+            res = scalar_and(res, ANDReduce(a, i));\n@@ -3603,1 +3865,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND));\n@@ -3615,1 +3877,1 @@\n-                res &= a[i];\n+                res = scalar_and(res, a[i]);\n@@ -3624,1 +3886,1 @@\n-            res &= ANDReduceMasked(a, i, mask);\n+            res = scalar_and(res, ANDReduceMasked(a, i, mask));\n@@ -3649,1 +3911,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND, vmask));\n@@ -3660,1 +3922,1 @@\n-            res |= a[i];\n+            res = scalar_or(res, a[i]);\n@@ -3669,1 +3931,1 @@\n-            res |= ORReduce(a, i);\n+            res = scalar_or(res, ORReduce(a, i));\n@@ -3692,1 +3954,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR));\n@@ -3704,1 +3966,1 @@\n-                res |= a[i];\n+                res = scalar_or(res, a[i]);\n@@ -3713,1 +3975,1 @@\n-            res |= ORReduceMasked(a, i, mask);\n+            res = scalar_or(res, ORReduceMasked(a, i, mask));\n@@ -3738,1 +4000,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR, vmask));\n@@ -3749,1 +4011,1 @@\n-            res ^= a[i];\n+            res = scalar_xor(res, a[i]);\n@@ -3758,1 +4020,1 @@\n-            res ^= XORReduce(a, i);\n+            res = scalar_xor(res, XORReduce(a, i));\n@@ -3781,1 +4043,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR));\n@@ -3793,1 +4055,1 @@\n-                res ^= a[i];\n+                res = scalar_xor(res, a[i]);\n@@ -3802,1 +4064,1 @@\n-            res ^= XORReduceMasked(a, i, mask);\n+            res = scalar_xor(res, XORReduceMasked(a, i, mask));\n@@ -3827,1 +4089,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR, vmask));\n@@ -3836,1 +4098,1 @@\n-        byte res = 0;\n+        byte res = additiveIdentity();\n@@ -3838,1 +4100,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -3845,1 +4107,1 @@\n-        byte res = 0;\n+        byte res = additiveIdentity();\n@@ -3847,1 +4109,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -3857,1 +4119,1 @@\n-        byte ra = 0;\n+        byte ra = additiveIdentity();\n@@ -3867,1 +4129,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3870,1 +4132,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -3879,1 +4141,1 @@\n-        byte res = 0;\n+        byte res = additiveIdentity();\n@@ -3882,1 +4144,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -3889,1 +4151,1 @@\n-        byte res = 0;\n+        byte res = additiveIdentity();\n@@ -3891,1 +4153,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -3903,1 +4165,1 @@\n-        byte ra = 0;\n+        byte ra = additiveIdentity();\n@@ -3913,1 +4175,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3916,1 +4178,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -3925,1 +4187,1 @@\n-        byte res = 1;\n+        byte res = multiplicativeIdentity();\n@@ -3927,1 +4189,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -3934,1 +4196,1 @@\n-        byte res = 1;\n+        byte res = multiplicativeIdentity();\n@@ -3936,1 +4198,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -3946,1 +4208,1 @@\n-        byte ra = 1;\n+        byte ra = multiplicativeIdentity();\n@@ -3956,1 +4218,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -3959,1 +4221,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -3968,1 +4230,1 @@\n-        byte res = 1;\n+        byte res = multiplicativeIdentity();\n@@ -3971,1 +4233,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -3978,1 +4240,1 @@\n-        byte res = 1;\n+        byte res = multiplicativeIdentity();\n@@ -3980,1 +4242,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -3992,1 +4254,1 @@\n-        byte ra = 1;\n+        byte ra = multiplicativeIdentity();\n@@ -4002,1 +4264,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -4005,1 +4267,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -4014,1 +4276,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4016,1 +4278,1 @@\n-            res = (byte) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -4023,1 +4285,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4025,1 +4287,1 @@\n-            res = (byte) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -4035,1 +4297,1 @@\n-        byte ra = Byte.MAX_VALUE;\n+        byte ra = maxValue();\n@@ -4045,1 +4307,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = maxValue();\n@@ -4048,1 +4310,1 @@\n-                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -4057,1 +4319,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4060,1 +4322,1 @@\n-                res = (byte) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -4067,1 +4329,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4069,1 +4331,1 @@\n-            res = (byte) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -4081,1 +4343,1 @@\n-        byte ra = Byte.MAX_VALUE;\n+        byte ra = maxValue();\n@@ -4091,1 +4353,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = maxValue();\n@@ -4094,1 +4356,1 @@\n-                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -4103,1 +4365,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4105,1 +4367,1 @@\n-            res = (byte) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -4112,1 +4374,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4114,1 +4376,1 @@\n-            res = (byte) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -4124,1 +4386,1 @@\n-        byte ra = Byte.MIN_VALUE;\n+        byte ra = minValue();\n@@ -4134,1 +4396,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = minValue();\n@@ -4137,1 +4399,1 @@\n-                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -4146,1 +4408,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4149,1 +4411,1 @@\n-                res = (byte) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -4156,1 +4418,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4158,1 +4420,1 @@\n-            res = (byte) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -4170,1 +4432,1 @@\n-        byte ra = Byte.MIN_VALUE;\n+        byte ra = minValue();\n@@ -4180,1 +4442,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = minValue();\n@@ -4183,1 +4445,1 @@\n-                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -4192,1 +4454,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4201,1 +4463,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4213,1 +4475,1 @@\n-        byte ra = Byte.MAX_VALUE;\n+        byte ra = maxValue();\n@@ -4223,1 +4485,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = maxValue();\n@@ -4235,1 +4497,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4245,1 +4507,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4259,1 +4521,1 @@\n-        byte ra = Byte.MAX_VALUE;\n+        byte ra = maxValue();\n@@ -4269,1 +4531,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = maxValue();\n@@ -4281,1 +4543,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4290,1 +4552,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4302,1 +4564,1 @@\n-        byte ra = Byte.MIN_VALUE;\n+        byte ra = minValue();\n@@ -4312,1 +4574,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = minValue();\n@@ -4324,1 +4586,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4334,1 +4596,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4348,1 +4610,1 @@\n-        byte ra = Byte.MIN_VALUE;\n+        byte ra = minValue();\n@@ -4358,1 +4620,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = minValue();\n@@ -4370,1 +4632,1 @@\n-        byte res = (byte) 0;\n+        byte res = zeroValue();\n@@ -4379,1 +4641,1 @@\n-        byte res = (byte) 0;\n+        byte res = zeroValue();\n@@ -4391,1 +4653,1 @@\n-        byte ra = (byte) 0;\n+        byte ra = zeroValue();\n@@ -4401,1 +4663,1 @@\n-            ra = (byte) 0;\n+            ra = zeroValue();\n@@ -4413,1 +4675,1 @@\n-        byte res = (byte) 0;\n+        byte res = zeroValue();\n@@ -4423,1 +4685,1 @@\n-        byte res = (byte) 0;\n+        byte res = zeroValue();\n@@ -4437,1 +4699,1 @@\n-        byte ra = (byte) 0;\n+        byte ra = zeroValue();\n@@ -4447,1 +4709,1 @@\n-            ra = (byte) 0;\n+            ra = zeroValue();\n@@ -4507,1 +4769,1 @@\n-        byte res = 0;\n+        byte res = zeroValue();\n@@ -4516,1 +4778,1 @@\n-        byte res = 0;\n+        byte res = zeroValue();\n@@ -4528,1 +4790,1 @@\n-        byte ra = 0;\n+        byte ra = zeroValue();\n@@ -4538,1 +4800,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4550,1 +4812,1 @@\n-        byte res = 0;\n+        byte res = zeroValue();\n@@ -4560,1 +4822,1 @@\n-        byte res = 0;\n+        byte res = zeroValue();\n@@ -4573,1 +4835,1 @@\n-        byte ra = 0;\n+        byte ra = zeroValue();\n@@ -4583,1 +4845,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4628,1 +4890,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -4648,1 +4910,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -4669,1 +4931,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -4689,1 +4951,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -4708,1 +4970,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4727,1 +4989,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4750,1 +5012,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -4769,1 +5031,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -4792,1 +5054,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -4811,1 +5073,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4830,1 +5092,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4853,1 +5115,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -4872,1 +5134,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -4895,1 +5157,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -4914,1 +5176,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -4937,1 +5199,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -4956,1 +5218,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -4979,1 +5241,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -4998,1 +5260,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n@@ -5021,1 +5283,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n@@ -5040,1 +5302,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n@@ -5063,1 +5325,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -5082,1 +5344,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n@@ -5105,1 +5367,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n@@ -5124,1 +5386,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n@@ -5147,1 +5409,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n@@ -5164,1 +5426,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -5184,1 +5446,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -5200,1 +5462,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < (byte)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (byte)((long)b[i])));\n@@ -5220,1 +5482,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < (byte)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(byte)((long)b[i]))));\n@@ -5236,1 +5498,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -5256,1 +5518,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -5272,1 +5534,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == (byte)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (byte)((long)b[i])));\n@@ -5292,1 +5554,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == (byte)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(byte)((long)b[i]))));\n@@ -5573,1 +5835,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -6004,1 +6266,1 @@\n-        return (byte)(-((byte)a));\n+        return (byte)(scalar_neg((byte)a));\n@@ -6008,1 +6270,1 @@\n-        return (byte)(-((byte)a));\n+        return (byte)(scalar_neg((byte)a));\n@@ -6060,1 +6322,1 @@\n-        return (byte)(Math.abs((byte)a));\n+        return (byte)(scalar_abs((byte)a));\n@@ -6064,1 +6326,1 @@\n-        return (byte)(Math.abs((byte)a));\n+        return (byte)(scalar_abs((byte)a));\n@@ -6404,1 +6666,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -6420,1 +6682,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -6527,1 +6789,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6568,1 +6830,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6671,1 +6933,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -6699,1 +6961,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -6713,1 +6975,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -6910,1 +7172,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -6930,1 +7192,1 @@\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -6953,1 +7215,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6967,1 +7229,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6989,1 +7251,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -6997,1 +7259,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -7004,1 +7266,1 @@\n-        Assert.assertEquals(elsize, Byte.SIZE);\n+        AssertEquals(elsize, Byte.SIZE);\n@@ -7023,1 +7285,1 @@\n-    static void ElementTypeByte128VectorTestsSmokeTest() {\n+    static void ByteByte128VectorTestsSmokeTest() {\n@@ -7058,1 +7320,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":594,"deletions":332,"binary":false,"changes":926,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,45 @@\n+    static ByteVector bcast_vec = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    static void AssertEquals(byte actual, byte expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(byte actual, byte expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(byte actual, byte expected, byte delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(byte actual, byte expected, byte delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(byte [] actual, byte [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(byte [] actual, byte [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -87,1 +132,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -90,1 +135,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -102,1 +147,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -108,1 +153,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -118,1 +163,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -121,1 +166,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -137,1 +182,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -139,1 +184,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -142,2 +187,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -159,1 +204,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -161,1 +206,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -164,2 +209,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -181,1 +226,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -183,1 +228,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -186,2 +231,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -203,1 +248,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -205,1 +250,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -208,2 +253,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -221,1 +266,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -224,1 +269,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -236,1 +281,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -239,1 +284,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -248,1 +293,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -253,1 +298,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -264,1 +309,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -269,1 +314,1 @@\n-                    Assert.assertEquals(r[i + k], (byte)0);\n+                    AssertEquals(r[i + k], (byte)0);\n@@ -275,1 +320,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -277,1 +322,1 @@\n-                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (byte)0, \"at index #\" + idx);\n@@ -289,1 +334,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -292,1 +337,1 @@\n-                        Assert.assertEquals(r[i + j], (byte)0);\n+                        AssertEquals(r[i + j], (byte)0);\n@@ -299,1 +344,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -301,1 +346,1 @@\n-                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (byte)0, \"at index #\" + idx);\n@@ -317,1 +362,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -321,1 +366,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -327,0 +372,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -330,1 +376,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -334,2 +382,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -345,1 +392,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -347,1 +394,1 @@\n-                         Assert.assertEquals(r[i+j], (byte)0);\n+                         AssertEquals(r[i+j], (byte)0);\n@@ -353,1 +400,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -355,1 +402,1 @@\n-                Assert.assertEquals(r[i+j], (byte)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (byte)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -361,0 +408,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -364,0 +412,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -365,1 +415,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -367,1 +417,1 @@\n-                         Assert.assertEquals(r[i+j], (byte)0);\n+                         AssertEquals(r[i+j], (byte)0);\n@@ -371,1 +421,0 @@\n-            int idx = i + j;\n@@ -373,1 +422,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -375,1 +424,1 @@\n-                Assert.assertEquals(r[i+j], (byte)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (byte)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -389,1 +438,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -392,1 +441,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -413,1 +462,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -416,1 +465,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -419,1 +468,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -422,3 +471,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -439,1 +488,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -442,1 +491,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -445,1 +494,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -448,3 +497,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -458,1 +507,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -461,1 +510,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -469,1 +518,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -472,1 +521,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -480,1 +529,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -483,1 +532,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -492,1 +541,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -495,1 +544,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -508,1 +557,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -511,1 +560,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -523,1 +572,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -526,1 +575,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -538,1 +587,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -541,1 +590,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -556,1 +605,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -559,1 +608,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -572,1 +621,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -576,1 +625,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -590,1 +639,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -594,1 +643,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -616,1 +665,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -620,1 +669,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -634,1 +683,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -638,1 +687,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -658,1 +707,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -661,1 +710,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -673,1 +722,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -676,1 +725,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -685,1 +734,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -688,1 +737,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -698,1 +747,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -701,1 +750,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -717,1 +766,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -721,1 +770,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -738,1 +787,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -742,1 +791,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -753,1 +802,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -757,1 +806,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -774,1 +823,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -778,1 +827,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -796,1 +845,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -802,1 +851,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -823,1 +872,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -829,1 +878,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -844,1 +893,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -850,1 +899,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -871,1 +920,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -877,1 +926,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -891,1 +940,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -897,1 +946,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -912,1 +961,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -918,1 +967,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -933,1 +982,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -939,1 +988,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -955,1 +1004,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -961,1 +1010,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -969,0 +1018,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -974,1 +1027,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -977,1 +1030,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -986,1 +1039,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -989,1 +1042,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -997,1 +1050,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -1000,1 +1053,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1008,1 +1061,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                AssertEquals(r[i], (double)(a[i+offs]));\n@@ -1011,1 +1064,1 @@\n-            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1020,1 +1073,1 @@\n-            withToString(\"byte[-i * 5]\", (int s) -> {\n+            withToString(\"Byte[-i * 5]\", (int s) -> {\n@@ -1022,1 +1075,1 @@\n-                            i -> (byte)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1024,1 +1077,1 @@\n-            withToString(\"byte[i * 5]\", (int s) -> {\n+            withToString(\"Byte[i * 5]\", (int s) -> {\n@@ -1026,1 +1079,1 @@\n-                            i -> (byte)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1028,1 +1081,1 @@\n-            withToString(\"byte[i + 1]\", (int s) -> {\n+            withToString(\"Byte[i + 1]\", (int s) -> {\n@@ -1030,1 +1083,1 @@\n-                            i -> (((byte)(i + 1) == 0) ? 1 : (byte)(i + 1)));\n+                            i -> (((byte)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1477,0 +1530,212 @@\n+    static byte firstNonZero(byte a, byte b) {\n+        return Byte.compare(a, (byte) 0) != 0 ? a : b;\n+    }\n+\n+    static byte multiplicativeIdentity() {\n+        return (byte)1;\n+    }\n+\n+    static byte scalar_or(byte a, byte b) {\n+        return (byte)(a | b);\n+    }\n+\n+    static byte scalar_and(byte a, byte b) {\n+        return (byte)(a & b);\n+    }\n+\n+    static byte scalar_xor(byte a, byte b) {\n+        return (byte)(a ^ b);\n+    }\n+\n+    static byte scalar_add(byte a, byte b) {\n+        return (byte)(a + b);\n+    }\n+\n+    static byte scalar_sub(byte a, byte b) {\n+        return (byte)(a - b);\n+    }\n+\n+    static byte scalar_mul(byte a, byte b) {\n+        return (byte)(a * b);\n+    }\n+\n+    static byte scalar_min(byte a, byte b) {\n+        return (byte)(Math.min(a, b));\n+    }\n+\n+    static byte scalar_max(byte a, byte b) {\n+        return (byte)(Math.max(a, b));\n+    }\n+\n+    static byte scalar_div(byte a, byte b) {\n+        return (byte)(a \/ b);\n+    }\n+\n+    static byte scalar_fma(byte a, byte b, byte c) {\n+        return (byte)(Math.fma(a, b, c));\n+    }\n+\n+    static byte scalar_abs(byte a) {\n+        return (byte)(Math.abs(a));\n+    }\n+\n+    static byte scalar_neg(byte a) {\n+        return ((byte)-a);\n+    }\n+\n+    static byte scalar_sin(byte a) {\n+        return (byte)Math.sin((double)a);\n+    }\n+\n+    static byte scalar_exp(byte a) {\n+        return (byte)Math.exp((double)a);\n+    }\n+\n+    static byte scalar_log1p(byte a) {\n+        return (byte)Math.log1p((double)a);\n+    }\n+\n+    static byte scalar_log(byte a) {\n+        return (byte)Math.log((double)a);\n+    }\n+\n+    static byte scalar_log10(byte a) {\n+        return (byte)Math.log10((double)a);\n+    }\n+\n+    static byte scalar_expm1(byte a) {\n+        return (byte)Math.expm1((double)a);\n+    }\n+\n+    static byte scalar_cos(byte a) {\n+        return (byte)Math.cos((double)a);\n+    }\n+\n+    static byte scalar_tan(byte a) {\n+        return (byte)Math.tan((double)a);\n+    }\n+\n+    static byte scalar_sinh(byte a) {\n+        return (byte)Math.sinh((double)a);\n+    }\n+\n+    static byte scalar_cosh(byte a) {\n+        return (byte)Math.cosh((double)a);\n+    }\n+\n+    static byte scalar_tanh(byte a) {\n+        return (byte)Math.tanh((double)a);\n+    }\n+\n+    static byte scalar_asin(byte a) {\n+        return (byte)Math.asin((double)a);\n+    }\n+\n+    static byte scalar_acos(byte a) {\n+        return (byte)Math.acos((double)a);\n+    }\n+\n+    static byte scalar_atan(byte a) {\n+        return (byte)Math.atan((double)a);\n+    }\n+\n+    static byte scalar_cbrt(byte a) {\n+        return (byte)Math.cbrt((double)a);\n+    }\n+\n+    static byte scalar_sqrt(byte a) {\n+        return (byte)Math.sqrt((double)a);\n+    }\n+\n+    static byte scalar_hypot(byte a, byte b) {\n+        return (byte)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static byte scalar_pow(byte a, byte b) {\n+        return (byte)Math.pow((double)a, (double)b);\n+    }\n+\n+    static byte scalar_atan2(byte a, byte b) {\n+        return (byte)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static byte strict_scalar_sin(byte a) {\n+        return (byte)StrictMath.sin((double)a);\n+    }\n+\n+    static byte strict_scalar_exp(byte a) {\n+        return (byte)StrictMath.exp((double)a);\n+    }\n+\n+    static byte strict_scalar_log1p(byte a) {\n+        return (byte)StrictMath.log1p((double)a);\n+    }\n+\n+    static byte strict_scalar_log(byte a) {\n+        return (byte)StrictMath.log((double)a);\n+    }\n+\n+    static byte strict_scalar_log10(byte a) {\n+        return (byte)StrictMath.log10((double)a);\n+    }\n+\n+    static byte strict_scalar_expm1(byte a) {\n+        return (byte)StrictMath.expm1((double)a);\n+    }\n+\n+    static byte strict_scalar_cos(byte a) {\n+        return (byte)StrictMath.cos((double)a);\n+    }\n+\n+    static byte strict_scalar_tan(byte a) {\n+        return (byte)StrictMath.tan((double)a);\n+    }\n+\n+    static byte strict_scalar_sinh(byte a) {\n+        return (byte)StrictMath.sinh((double)a);\n+    }\n+\n+    static byte strict_scalar_cosh(byte a) {\n+        return (byte)StrictMath.cosh((double)a);\n+    }\n+\n+    static byte strict_scalar_tanh(byte a) {\n+        return (byte)StrictMath.tanh((double)a);\n+    }\n+\n+    static byte strict_scalar_asin(byte a) {\n+        return (byte)StrictMath.asin((double)a);\n+    }\n+\n+    static byte strict_scalar_acos(byte a) {\n+        return (byte)StrictMath.acos((double)a);\n+    }\n+\n+    static byte strict_scalar_atan(byte a) {\n+        return (byte)StrictMath.atan((double)a);\n+    }\n+\n+    static byte strict_scalar_cbrt(byte a) {\n+        return (byte)StrictMath.cbrt((double)a);\n+    }\n+\n+    static byte strict_scalar_sqrt(byte a) {\n+        return (byte)StrictMath.sqrt((double)a);\n+    }\n+\n+    static byte strict_scalar_hypot(byte a, byte b) {\n+        return (byte)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static byte strict_scalar_pow(byte a, byte b) {\n+        return (byte)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static byte strict_scalar_atan2(byte a, byte b) {\n+        return (byte)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static byte additiveIdentity() {\n+        return (byte)0;\n+    }\n+\n+\n@@ -1493,2 +1758,10 @@\n-    static byte firstNonZero(byte a, byte b) {\n-        return Byte.compare(a, (byte) 0) != 0 ? a : b;\n+    static byte zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static byte maxValue() {\n+        return Byte.MAX_VALUE;\n+    }\n+\n+    static byte minValue() {\n+        return Byte.MIN_VALUE;\n@@ -1497,0 +1770,1 @@\n+\n@@ -1532,1 +1806,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1547,1 +1821,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1553,1 +1827,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1559,1 +1833,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1574,1 +1848,1 @@\n-        Assert.assertEquals(asIntegral.species(), SPECIES);\n+        AssertEquals(asIntegral.species(), SPECIES);\n@@ -1604,1 +1878,1 @@\n-        return (byte)(a + b);\n+        return (byte)(scalar_add(a, b));\n@@ -1625,1 +1899,1 @@\n-        return (byte)(a + b);\n+        return (byte)(scalar_add(a, b));\n@@ -1682,1 +1956,1 @@\n-        return (byte)(a - b);\n+        return (byte)(scalar_sub(a, b));\n@@ -1703,1 +1977,1 @@\n-        return (byte)(a - b);\n+        return (byte)(scalar_sub(a, b));\n@@ -1760,1 +2034,1 @@\n-        return (byte)(a * b);\n+        return (byte)(scalar_mul(a, b));\n@@ -1781,1 +2055,1 @@\n-        return (byte)(a * b);\n+        return (byte)(scalar_mul(a, b));\n@@ -1928,1 +2202,1 @@\n-        return (byte)((a)!=0?a:b);\n+        return (byte)(firstNonZero(a, b));\n@@ -3035,2 +3309,0 @@\n-    static ByteVector bv_MIN = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3045,1 +3317,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -3052,2 +3324,0 @@\n-    static ByteVector bv_min = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3062,1 +3332,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -3069,2 +3339,0 @@\n-    static ByteVector bv_MIN_M = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3081,1 +3349,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -3088,2 +3356,0 @@\n-    static ByteVector bv_MAX = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3098,1 +3364,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -3105,2 +3371,0 @@\n-    static ByteVector bv_max = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3115,1 +3379,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -3122,2 +3386,0 @@\n-    static ByteVector bv_MAX_M = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3134,1 +3396,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -3142,1 +3404,1 @@\n-        return (byte)(Math.min(a, b));\n+        return (byte)(scalar_min(a, b));\n@@ -3163,1 +3425,1 @@\n-        return (byte)(Math.min(a, b));\n+        return (byte)(scalar_min(a, b));\n@@ -3182,1 +3444,1 @@\n-        return (byte)(Math.max(a, b));\n+        return (byte)(scalar_max(a, b));\n@@ -3203,1 +3465,1 @@\n-        return (byte)(Math.max(a, b));\n+        return (byte)(scalar_max(a, b));\n@@ -3571,1 +3833,1 @@\n-            res &= a[i];\n+            res = scalar_and(res, a[i]);\n@@ -3580,1 +3842,1 @@\n-            res &= ANDReduce(a, i);\n+            res = scalar_and(res, ANDReduce(a, i));\n@@ -3603,1 +3865,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND));\n@@ -3615,1 +3877,1 @@\n-                res &= a[i];\n+                res = scalar_and(res, a[i]);\n@@ -3624,1 +3886,1 @@\n-            res &= ANDReduceMasked(a, i, mask);\n+            res = scalar_and(res, ANDReduceMasked(a, i, mask));\n@@ -3649,1 +3911,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND, vmask));\n@@ -3660,1 +3922,1 @@\n-            res |= a[i];\n+            res = scalar_or(res, a[i]);\n@@ -3669,1 +3931,1 @@\n-            res |= ORReduce(a, i);\n+            res = scalar_or(res, ORReduce(a, i));\n@@ -3692,1 +3954,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR));\n@@ -3704,1 +3966,1 @@\n-                res |= a[i];\n+                res = scalar_or(res, a[i]);\n@@ -3713,1 +3975,1 @@\n-            res |= ORReduceMasked(a, i, mask);\n+            res = scalar_or(res, ORReduceMasked(a, i, mask));\n@@ -3738,1 +4000,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR, vmask));\n@@ -3749,1 +4011,1 @@\n-            res ^= a[i];\n+            res = scalar_xor(res, a[i]);\n@@ -3758,1 +4020,1 @@\n-            res ^= XORReduce(a, i);\n+            res = scalar_xor(res, XORReduce(a, i));\n@@ -3781,1 +4043,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR));\n@@ -3793,1 +4055,1 @@\n-                res ^= a[i];\n+                res = scalar_xor(res, a[i]);\n@@ -3802,1 +4064,1 @@\n-            res ^= XORReduceMasked(a, i, mask);\n+            res = scalar_xor(res, XORReduceMasked(a, i, mask));\n@@ -3827,1 +4089,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR, vmask));\n@@ -3836,1 +4098,1 @@\n-        byte res = 0;\n+        byte res = additiveIdentity();\n@@ -3838,1 +4100,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -3845,1 +4107,1 @@\n-        byte res = 0;\n+        byte res = additiveIdentity();\n@@ -3847,1 +4109,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -3857,1 +4119,1 @@\n-        byte ra = 0;\n+        byte ra = additiveIdentity();\n@@ -3867,1 +4129,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3870,1 +4132,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -3879,1 +4141,1 @@\n-        byte res = 0;\n+        byte res = additiveIdentity();\n@@ -3882,1 +4144,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -3889,1 +4151,1 @@\n-        byte res = 0;\n+        byte res = additiveIdentity();\n@@ -3891,1 +4153,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -3903,1 +4165,1 @@\n-        byte ra = 0;\n+        byte ra = additiveIdentity();\n@@ -3913,1 +4175,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3916,1 +4178,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -3925,1 +4187,1 @@\n-        byte res = 1;\n+        byte res = multiplicativeIdentity();\n@@ -3927,1 +4189,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -3934,1 +4196,1 @@\n-        byte res = 1;\n+        byte res = multiplicativeIdentity();\n@@ -3936,1 +4198,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -3946,1 +4208,1 @@\n-        byte ra = 1;\n+        byte ra = multiplicativeIdentity();\n@@ -3956,1 +4218,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -3959,1 +4221,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -3968,1 +4230,1 @@\n-        byte res = 1;\n+        byte res = multiplicativeIdentity();\n@@ -3971,1 +4233,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -3978,1 +4240,1 @@\n-        byte res = 1;\n+        byte res = multiplicativeIdentity();\n@@ -3980,1 +4242,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -3992,1 +4254,1 @@\n-        byte ra = 1;\n+        byte ra = multiplicativeIdentity();\n@@ -4002,1 +4264,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -4005,1 +4267,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -4014,1 +4276,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4016,1 +4278,1 @@\n-            res = (byte) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -4023,1 +4285,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4025,1 +4287,1 @@\n-            res = (byte) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -4035,1 +4297,1 @@\n-        byte ra = Byte.MAX_VALUE;\n+        byte ra = maxValue();\n@@ -4045,1 +4307,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = maxValue();\n@@ -4048,1 +4310,1 @@\n-                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -4057,1 +4319,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4060,1 +4322,1 @@\n-                res = (byte) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -4067,1 +4329,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4069,1 +4331,1 @@\n-            res = (byte) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -4081,1 +4343,1 @@\n-        byte ra = Byte.MAX_VALUE;\n+        byte ra = maxValue();\n@@ -4091,1 +4353,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = maxValue();\n@@ -4094,1 +4356,1 @@\n-                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -4103,1 +4365,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4105,1 +4367,1 @@\n-            res = (byte) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -4112,1 +4374,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4114,1 +4376,1 @@\n-            res = (byte) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -4124,1 +4386,1 @@\n-        byte ra = Byte.MIN_VALUE;\n+        byte ra = minValue();\n@@ -4134,1 +4396,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = minValue();\n@@ -4137,1 +4399,1 @@\n-                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -4146,1 +4408,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4149,1 +4411,1 @@\n-                res = (byte) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -4156,1 +4418,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4158,1 +4420,1 @@\n-            res = (byte) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -4170,1 +4432,1 @@\n-        byte ra = Byte.MIN_VALUE;\n+        byte ra = minValue();\n@@ -4180,1 +4442,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = minValue();\n@@ -4183,1 +4445,1 @@\n-                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -4192,1 +4454,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4201,1 +4463,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4213,1 +4475,1 @@\n-        byte ra = Byte.MAX_VALUE;\n+        byte ra = maxValue();\n@@ -4223,1 +4485,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = maxValue();\n@@ -4235,1 +4497,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4245,1 +4507,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4259,1 +4521,1 @@\n-        byte ra = Byte.MAX_VALUE;\n+        byte ra = maxValue();\n@@ -4269,1 +4531,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = maxValue();\n@@ -4281,1 +4543,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4290,1 +4552,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4302,1 +4564,1 @@\n-        byte ra = Byte.MIN_VALUE;\n+        byte ra = minValue();\n@@ -4312,1 +4574,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = minValue();\n@@ -4324,1 +4586,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4334,1 +4596,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4348,1 +4610,1 @@\n-        byte ra = Byte.MIN_VALUE;\n+        byte ra = minValue();\n@@ -4358,1 +4620,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = minValue();\n@@ -4370,1 +4632,1 @@\n-        byte res = (byte) 0;\n+        byte res = zeroValue();\n@@ -4379,1 +4641,1 @@\n-        byte res = (byte) 0;\n+        byte res = zeroValue();\n@@ -4391,1 +4653,1 @@\n-        byte ra = (byte) 0;\n+        byte ra = zeroValue();\n@@ -4401,1 +4663,1 @@\n-            ra = (byte) 0;\n+            ra = zeroValue();\n@@ -4413,1 +4675,1 @@\n-        byte res = (byte) 0;\n+        byte res = zeroValue();\n@@ -4423,1 +4685,1 @@\n-        byte res = (byte) 0;\n+        byte res = zeroValue();\n@@ -4437,1 +4699,1 @@\n-        byte ra = (byte) 0;\n+        byte ra = zeroValue();\n@@ -4447,1 +4709,1 @@\n-            ra = (byte) 0;\n+            ra = zeroValue();\n@@ -4507,1 +4769,1 @@\n-        byte res = 0;\n+        byte res = zeroValue();\n@@ -4516,1 +4778,1 @@\n-        byte res = 0;\n+        byte res = zeroValue();\n@@ -4528,1 +4790,1 @@\n-        byte ra = 0;\n+        byte ra = zeroValue();\n@@ -4538,1 +4800,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4550,1 +4812,1 @@\n-        byte res = 0;\n+        byte res = zeroValue();\n@@ -4560,1 +4822,1 @@\n-        byte res = 0;\n+        byte res = zeroValue();\n@@ -4573,1 +4835,1 @@\n-        byte ra = 0;\n+        byte ra = zeroValue();\n@@ -4583,1 +4845,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4628,1 +4890,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -4648,1 +4910,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -4669,1 +4931,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -4689,1 +4951,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -4708,1 +4970,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4727,1 +4989,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4750,1 +5012,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -4769,1 +5031,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -4792,1 +5054,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -4811,1 +5073,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4830,1 +5092,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4853,1 +5115,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -4872,1 +5134,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -4895,1 +5157,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -4914,1 +5176,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -4937,1 +5199,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -4956,1 +5218,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -4979,1 +5241,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -4998,1 +5260,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n@@ -5021,1 +5283,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n@@ -5040,1 +5302,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n@@ -5063,1 +5325,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -5082,1 +5344,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n@@ -5105,1 +5367,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n@@ -5124,1 +5386,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n@@ -5147,1 +5409,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n@@ -5164,1 +5426,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -5184,1 +5446,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -5200,1 +5462,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < (byte)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (byte)((long)b[i])));\n@@ -5220,1 +5482,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < (byte)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(byte)((long)b[i]))));\n@@ -5236,1 +5498,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -5256,1 +5518,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -5272,1 +5534,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == (byte)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (byte)((long)b[i])));\n@@ -5292,1 +5554,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == (byte)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(byte)((long)b[i]))));\n@@ -5573,1 +5835,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -6004,1 +6266,1 @@\n-        return (byte)(-((byte)a));\n+        return (byte)(scalar_neg((byte)a));\n@@ -6008,1 +6270,1 @@\n-        return (byte)(-((byte)a));\n+        return (byte)(scalar_neg((byte)a));\n@@ -6060,1 +6322,1 @@\n-        return (byte)(Math.abs((byte)a));\n+        return (byte)(scalar_abs((byte)a));\n@@ -6064,1 +6326,1 @@\n-        return (byte)(Math.abs((byte)a));\n+        return (byte)(scalar_abs((byte)a));\n@@ -6404,1 +6666,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -6420,1 +6682,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -6527,1 +6789,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6568,1 +6830,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6671,1 +6933,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -6699,1 +6961,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -6713,1 +6975,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -6910,1 +7172,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -6930,1 +7192,1 @@\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -6953,1 +7215,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6967,1 +7229,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6989,1 +7251,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -6997,1 +7259,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -7004,1 +7266,1 @@\n-        Assert.assertEquals(elsize, Byte.SIZE);\n+        AssertEquals(elsize, Byte.SIZE);\n@@ -7023,1 +7285,1 @@\n-    static void ElementTypeByte256VectorTestsSmokeTest() {\n+    static void ByteByte256VectorTestsSmokeTest() {\n@@ -7058,1 +7320,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":594,"deletions":332,"binary":false,"changes":926,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,45 @@\n+    static ByteVector bcast_vec = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    static void AssertEquals(byte actual, byte expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(byte actual, byte expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(byte actual, byte expected, byte delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(byte actual, byte expected, byte delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(byte [] actual, byte [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(byte [] actual, byte [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -87,1 +132,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -90,1 +135,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -102,1 +147,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -108,1 +153,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -118,1 +163,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -121,1 +166,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -137,1 +182,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -139,1 +184,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -142,2 +187,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -159,1 +204,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -161,1 +206,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -164,2 +209,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -181,1 +226,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -183,1 +228,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -186,2 +231,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -203,1 +248,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -205,1 +250,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -208,2 +253,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -221,1 +266,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -224,1 +269,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -236,1 +281,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -239,1 +284,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -248,1 +293,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -253,1 +298,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -264,1 +309,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -269,1 +314,1 @@\n-                    Assert.assertEquals(r[i + k], (byte)0);\n+                    AssertEquals(r[i + k], (byte)0);\n@@ -275,1 +320,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -277,1 +322,1 @@\n-                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (byte)0, \"at index #\" + idx);\n@@ -289,1 +334,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -292,1 +337,1 @@\n-                        Assert.assertEquals(r[i + j], (byte)0);\n+                        AssertEquals(r[i + j], (byte)0);\n@@ -299,1 +344,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -301,1 +346,1 @@\n-                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (byte)0, \"at index #\" + idx);\n@@ -317,1 +362,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -321,1 +366,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -327,0 +372,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -330,1 +376,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -334,2 +382,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -345,1 +392,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -347,1 +394,1 @@\n-                         Assert.assertEquals(r[i+j], (byte)0);\n+                         AssertEquals(r[i+j], (byte)0);\n@@ -353,1 +400,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -355,1 +402,1 @@\n-                Assert.assertEquals(r[i+j], (byte)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (byte)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -361,0 +408,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -364,0 +412,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -365,1 +415,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -367,1 +417,1 @@\n-                         Assert.assertEquals(r[i+j], (byte)0);\n+                         AssertEquals(r[i+j], (byte)0);\n@@ -371,1 +421,0 @@\n-            int idx = i + j;\n@@ -373,1 +422,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -375,1 +424,1 @@\n-                Assert.assertEquals(r[i+j], (byte)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (byte)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -389,1 +438,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -392,1 +441,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -413,1 +462,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -416,1 +465,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -419,1 +468,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -422,3 +471,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -439,1 +488,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -442,1 +491,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -445,1 +494,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -448,3 +497,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -458,1 +507,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -461,1 +510,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -469,1 +518,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -472,1 +521,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -480,1 +529,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -483,1 +532,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -492,1 +541,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -495,1 +544,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -508,1 +557,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -511,1 +560,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -523,1 +572,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -526,1 +575,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -538,1 +587,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -541,1 +590,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -556,1 +605,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -559,1 +608,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -572,1 +621,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -576,1 +625,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -590,1 +639,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -594,1 +643,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -616,1 +665,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -620,1 +669,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -634,1 +683,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -638,1 +687,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -658,1 +707,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -661,1 +710,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -673,1 +722,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -676,1 +725,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -685,1 +734,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -688,1 +737,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -698,1 +747,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -701,1 +750,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -717,1 +766,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -721,1 +770,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -738,1 +787,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -742,1 +791,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -753,1 +802,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -757,1 +806,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -774,1 +823,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -778,1 +827,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -796,1 +845,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -802,1 +851,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -823,1 +872,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -829,1 +878,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -844,1 +893,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -850,1 +899,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -871,1 +920,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -877,1 +926,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -891,1 +940,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -897,1 +946,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -912,1 +961,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -918,1 +967,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -933,1 +982,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -939,1 +988,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -955,1 +1004,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -961,1 +1010,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -969,0 +1018,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -974,1 +1027,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -977,1 +1030,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -986,1 +1039,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -989,1 +1042,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -997,1 +1050,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -1000,1 +1053,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1008,1 +1061,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                AssertEquals(r[i], (double)(a[i+offs]));\n@@ -1011,1 +1064,1 @@\n-            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1020,1 +1073,1 @@\n-            withToString(\"byte[-i * 5]\", (int s) -> {\n+            withToString(\"Byte[-i * 5]\", (int s) -> {\n@@ -1022,1 +1075,1 @@\n-                            i -> (byte)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1024,1 +1077,1 @@\n-            withToString(\"byte[i * 5]\", (int s) -> {\n+            withToString(\"Byte[i * 5]\", (int s) -> {\n@@ -1026,1 +1079,1 @@\n-                            i -> (byte)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1028,1 +1081,1 @@\n-            withToString(\"byte[i + 1]\", (int s) -> {\n+            withToString(\"Byte[i + 1]\", (int s) -> {\n@@ -1030,1 +1083,1 @@\n-                            i -> (((byte)(i + 1) == 0) ? 1 : (byte)(i + 1)));\n+                            i -> (((byte)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1477,0 +1530,212 @@\n+    static byte firstNonZero(byte a, byte b) {\n+        return Byte.compare(a, (byte) 0) != 0 ? a : b;\n+    }\n+\n+    static byte multiplicativeIdentity() {\n+        return (byte)1;\n+    }\n+\n+    static byte scalar_or(byte a, byte b) {\n+        return (byte)(a | b);\n+    }\n+\n+    static byte scalar_and(byte a, byte b) {\n+        return (byte)(a & b);\n+    }\n+\n+    static byte scalar_xor(byte a, byte b) {\n+        return (byte)(a ^ b);\n+    }\n+\n+    static byte scalar_add(byte a, byte b) {\n+        return (byte)(a + b);\n+    }\n+\n+    static byte scalar_sub(byte a, byte b) {\n+        return (byte)(a - b);\n+    }\n+\n+    static byte scalar_mul(byte a, byte b) {\n+        return (byte)(a * b);\n+    }\n+\n+    static byte scalar_min(byte a, byte b) {\n+        return (byte)(Math.min(a, b));\n+    }\n+\n+    static byte scalar_max(byte a, byte b) {\n+        return (byte)(Math.max(a, b));\n+    }\n+\n+    static byte scalar_div(byte a, byte b) {\n+        return (byte)(a \/ b);\n+    }\n+\n+    static byte scalar_fma(byte a, byte b, byte c) {\n+        return (byte)(Math.fma(a, b, c));\n+    }\n+\n+    static byte scalar_abs(byte a) {\n+        return (byte)(Math.abs(a));\n+    }\n+\n+    static byte scalar_neg(byte a) {\n+        return ((byte)-a);\n+    }\n+\n+    static byte scalar_sin(byte a) {\n+        return (byte)Math.sin((double)a);\n+    }\n+\n+    static byte scalar_exp(byte a) {\n+        return (byte)Math.exp((double)a);\n+    }\n+\n+    static byte scalar_log1p(byte a) {\n+        return (byte)Math.log1p((double)a);\n+    }\n+\n+    static byte scalar_log(byte a) {\n+        return (byte)Math.log((double)a);\n+    }\n+\n+    static byte scalar_log10(byte a) {\n+        return (byte)Math.log10((double)a);\n+    }\n+\n+    static byte scalar_expm1(byte a) {\n+        return (byte)Math.expm1((double)a);\n+    }\n+\n+    static byte scalar_cos(byte a) {\n+        return (byte)Math.cos((double)a);\n+    }\n+\n+    static byte scalar_tan(byte a) {\n+        return (byte)Math.tan((double)a);\n+    }\n+\n+    static byte scalar_sinh(byte a) {\n+        return (byte)Math.sinh((double)a);\n+    }\n+\n+    static byte scalar_cosh(byte a) {\n+        return (byte)Math.cosh((double)a);\n+    }\n+\n+    static byte scalar_tanh(byte a) {\n+        return (byte)Math.tanh((double)a);\n+    }\n+\n+    static byte scalar_asin(byte a) {\n+        return (byte)Math.asin((double)a);\n+    }\n+\n+    static byte scalar_acos(byte a) {\n+        return (byte)Math.acos((double)a);\n+    }\n+\n+    static byte scalar_atan(byte a) {\n+        return (byte)Math.atan((double)a);\n+    }\n+\n+    static byte scalar_cbrt(byte a) {\n+        return (byte)Math.cbrt((double)a);\n+    }\n+\n+    static byte scalar_sqrt(byte a) {\n+        return (byte)Math.sqrt((double)a);\n+    }\n+\n+    static byte scalar_hypot(byte a, byte b) {\n+        return (byte)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static byte scalar_pow(byte a, byte b) {\n+        return (byte)Math.pow((double)a, (double)b);\n+    }\n+\n+    static byte scalar_atan2(byte a, byte b) {\n+        return (byte)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static byte strict_scalar_sin(byte a) {\n+        return (byte)StrictMath.sin((double)a);\n+    }\n+\n+    static byte strict_scalar_exp(byte a) {\n+        return (byte)StrictMath.exp((double)a);\n+    }\n+\n+    static byte strict_scalar_log1p(byte a) {\n+        return (byte)StrictMath.log1p((double)a);\n+    }\n+\n+    static byte strict_scalar_log(byte a) {\n+        return (byte)StrictMath.log((double)a);\n+    }\n+\n+    static byte strict_scalar_log10(byte a) {\n+        return (byte)StrictMath.log10((double)a);\n+    }\n+\n+    static byte strict_scalar_expm1(byte a) {\n+        return (byte)StrictMath.expm1((double)a);\n+    }\n+\n+    static byte strict_scalar_cos(byte a) {\n+        return (byte)StrictMath.cos((double)a);\n+    }\n+\n+    static byte strict_scalar_tan(byte a) {\n+        return (byte)StrictMath.tan((double)a);\n+    }\n+\n+    static byte strict_scalar_sinh(byte a) {\n+        return (byte)StrictMath.sinh((double)a);\n+    }\n+\n+    static byte strict_scalar_cosh(byte a) {\n+        return (byte)StrictMath.cosh((double)a);\n+    }\n+\n+    static byte strict_scalar_tanh(byte a) {\n+        return (byte)StrictMath.tanh((double)a);\n+    }\n+\n+    static byte strict_scalar_asin(byte a) {\n+        return (byte)StrictMath.asin((double)a);\n+    }\n+\n+    static byte strict_scalar_acos(byte a) {\n+        return (byte)StrictMath.acos((double)a);\n+    }\n+\n+    static byte strict_scalar_atan(byte a) {\n+        return (byte)StrictMath.atan((double)a);\n+    }\n+\n+    static byte strict_scalar_cbrt(byte a) {\n+        return (byte)StrictMath.cbrt((double)a);\n+    }\n+\n+    static byte strict_scalar_sqrt(byte a) {\n+        return (byte)StrictMath.sqrt((double)a);\n+    }\n+\n+    static byte strict_scalar_hypot(byte a, byte b) {\n+        return (byte)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static byte strict_scalar_pow(byte a, byte b) {\n+        return (byte)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static byte strict_scalar_atan2(byte a, byte b) {\n+        return (byte)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static byte additiveIdentity() {\n+        return (byte)0;\n+    }\n+\n+\n@@ -1493,2 +1758,10 @@\n-    static byte firstNonZero(byte a, byte b) {\n-        return Byte.compare(a, (byte) 0) != 0 ? a : b;\n+    static byte zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static byte maxValue() {\n+        return Byte.MAX_VALUE;\n+    }\n+\n+    static byte minValue() {\n+        return Byte.MIN_VALUE;\n@@ -1497,0 +1770,1 @@\n+\n@@ -1532,1 +1806,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1547,1 +1821,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1553,1 +1827,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1559,1 +1833,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1574,1 +1848,1 @@\n-        Assert.assertEquals(asIntegral.species(), SPECIES);\n+        AssertEquals(asIntegral.species(), SPECIES);\n@@ -1604,1 +1878,1 @@\n-        return (byte)(a + b);\n+        return (byte)(scalar_add(a, b));\n@@ -1625,1 +1899,1 @@\n-        return (byte)(a + b);\n+        return (byte)(scalar_add(a, b));\n@@ -1682,1 +1956,1 @@\n-        return (byte)(a - b);\n+        return (byte)(scalar_sub(a, b));\n@@ -1703,1 +1977,1 @@\n-        return (byte)(a - b);\n+        return (byte)(scalar_sub(a, b));\n@@ -1760,1 +2034,1 @@\n-        return (byte)(a * b);\n+        return (byte)(scalar_mul(a, b));\n@@ -1781,1 +2055,1 @@\n-        return (byte)(a * b);\n+        return (byte)(scalar_mul(a, b));\n@@ -1928,1 +2202,1 @@\n-        return (byte)((a)!=0?a:b);\n+        return (byte)(firstNonZero(a, b));\n@@ -3035,2 +3309,0 @@\n-    static ByteVector bv_MIN = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3045,1 +3317,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -3052,2 +3324,0 @@\n-    static ByteVector bv_min = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3062,1 +3332,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -3069,2 +3339,0 @@\n-    static ByteVector bv_MIN_M = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3081,1 +3349,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -3088,2 +3356,0 @@\n-    static ByteVector bv_MAX = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3098,1 +3364,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -3105,2 +3371,0 @@\n-    static ByteVector bv_max = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3115,1 +3379,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -3122,2 +3386,0 @@\n-    static ByteVector bv_MAX_M = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3134,1 +3396,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -3142,1 +3404,1 @@\n-        return (byte)(Math.min(a, b));\n+        return (byte)(scalar_min(a, b));\n@@ -3163,1 +3425,1 @@\n-        return (byte)(Math.min(a, b));\n+        return (byte)(scalar_min(a, b));\n@@ -3182,1 +3444,1 @@\n-        return (byte)(Math.max(a, b));\n+        return (byte)(scalar_max(a, b));\n@@ -3203,1 +3465,1 @@\n-        return (byte)(Math.max(a, b));\n+        return (byte)(scalar_max(a, b));\n@@ -3571,1 +3833,1 @@\n-            res &= a[i];\n+            res = scalar_and(res, a[i]);\n@@ -3580,1 +3842,1 @@\n-            res &= ANDReduce(a, i);\n+            res = scalar_and(res, ANDReduce(a, i));\n@@ -3603,1 +3865,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND));\n@@ -3615,1 +3877,1 @@\n-                res &= a[i];\n+                res = scalar_and(res, a[i]);\n@@ -3624,1 +3886,1 @@\n-            res &= ANDReduceMasked(a, i, mask);\n+            res = scalar_and(res, ANDReduceMasked(a, i, mask));\n@@ -3649,1 +3911,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND, vmask));\n@@ -3660,1 +3922,1 @@\n-            res |= a[i];\n+            res = scalar_or(res, a[i]);\n@@ -3669,1 +3931,1 @@\n-            res |= ORReduce(a, i);\n+            res = scalar_or(res, ORReduce(a, i));\n@@ -3692,1 +3954,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR));\n@@ -3704,1 +3966,1 @@\n-                res |= a[i];\n+                res = scalar_or(res, a[i]);\n@@ -3713,1 +3975,1 @@\n-            res |= ORReduceMasked(a, i, mask);\n+            res = scalar_or(res, ORReduceMasked(a, i, mask));\n@@ -3738,1 +4000,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR, vmask));\n@@ -3749,1 +4011,1 @@\n-            res ^= a[i];\n+            res = scalar_xor(res, a[i]);\n@@ -3758,1 +4020,1 @@\n-            res ^= XORReduce(a, i);\n+            res = scalar_xor(res, XORReduce(a, i));\n@@ -3781,1 +4043,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR));\n@@ -3793,1 +4055,1 @@\n-                res ^= a[i];\n+                res = scalar_xor(res, a[i]);\n@@ -3802,1 +4064,1 @@\n-            res ^= XORReduceMasked(a, i, mask);\n+            res = scalar_xor(res, XORReduceMasked(a, i, mask));\n@@ -3827,1 +4089,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR, vmask));\n@@ -3836,1 +4098,1 @@\n-        byte res = 0;\n+        byte res = additiveIdentity();\n@@ -3838,1 +4100,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -3845,1 +4107,1 @@\n-        byte res = 0;\n+        byte res = additiveIdentity();\n@@ -3847,1 +4109,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -3857,1 +4119,1 @@\n-        byte ra = 0;\n+        byte ra = additiveIdentity();\n@@ -3867,1 +4129,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3870,1 +4132,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -3879,1 +4141,1 @@\n-        byte res = 0;\n+        byte res = additiveIdentity();\n@@ -3882,1 +4144,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -3889,1 +4151,1 @@\n-        byte res = 0;\n+        byte res = additiveIdentity();\n@@ -3891,1 +4153,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -3903,1 +4165,1 @@\n-        byte ra = 0;\n+        byte ra = additiveIdentity();\n@@ -3913,1 +4175,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3916,1 +4178,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -3925,1 +4187,1 @@\n-        byte res = 1;\n+        byte res = multiplicativeIdentity();\n@@ -3927,1 +4189,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -3934,1 +4196,1 @@\n-        byte res = 1;\n+        byte res = multiplicativeIdentity();\n@@ -3936,1 +4198,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -3946,1 +4208,1 @@\n-        byte ra = 1;\n+        byte ra = multiplicativeIdentity();\n@@ -3956,1 +4218,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -3959,1 +4221,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -3968,1 +4230,1 @@\n-        byte res = 1;\n+        byte res = multiplicativeIdentity();\n@@ -3971,1 +4233,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -3978,1 +4240,1 @@\n-        byte res = 1;\n+        byte res = multiplicativeIdentity();\n@@ -3980,1 +4242,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -3992,1 +4254,1 @@\n-        byte ra = 1;\n+        byte ra = multiplicativeIdentity();\n@@ -4002,1 +4264,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -4005,1 +4267,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -4014,1 +4276,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4016,1 +4278,1 @@\n-            res = (byte) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -4023,1 +4285,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4025,1 +4287,1 @@\n-            res = (byte) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -4035,1 +4297,1 @@\n-        byte ra = Byte.MAX_VALUE;\n+        byte ra = maxValue();\n@@ -4045,1 +4307,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = maxValue();\n@@ -4048,1 +4310,1 @@\n-                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -4057,1 +4319,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4060,1 +4322,1 @@\n-                res = (byte) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -4067,1 +4329,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4069,1 +4331,1 @@\n-            res = (byte) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -4081,1 +4343,1 @@\n-        byte ra = Byte.MAX_VALUE;\n+        byte ra = maxValue();\n@@ -4091,1 +4353,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = maxValue();\n@@ -4094,1 +4356,1 @@\n-                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -4103,1 +4365,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4105,1 +4367,1 @@\n-            res = (byte) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -4112,1 +4374,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4114,1 +4376,1 @@\n-            res = (byte) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -4124,1 +4386,1 @@\n-        byte ra = Byte.MIN_VALUE;\n+        byte ra = minValue();\n@@ -4134,1 +4396,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = minValue();\n@@ -4137,1 +4399,1 @@\n-                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -4146,1 +4408,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4149,1 +4411,1 @@\n-                res = (byte) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -4156,1 +4418,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4158,1 +4420,1 @@\n-            res = (byte) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -4170,1 +4432,1 @@\n-        byte ra = Byte.MIN_VALUE;\n+        byte ra = minValue();\n@@ -4180,1 +4442,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = minValue();\n@@ -4183,1 +4445,1 @@\n-                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -4192,1 +4454,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4201,1 +4463,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4213,1 +4475,1 @@\n-        byte ra = Byte.MAX_VALUE;\n+        byte ra = maxValue();\n@@ -4223,1 +4485,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = maxValue();\n@@ -4235,1 +4497,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4245,1 +4507,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4259,1 +4521,1 @@\n-        byte ra = Byte.MAX_VALUE;\n+        byte ra = maxValue();\n@@ -4269,1 +4531,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = maxValue();\n@@ -4281,1 +4543,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4290,1 +4552,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4302,1 +4564,1 @@\n-        byte ra = Byte.MIN_VALUE;\n+        byte ra = minValue();\n@@ -4312,1 +4574,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = minValue();\n@@ -4324,1 +4586,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4334,1 +4596,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4348,1 +4610,1 @@\n-        byte ra = Byte.MIN_VALUE;\n+        byte ra = minValue();\n@@ -4358,1 +4620,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = minValue();\n@@ -4370,1 +4632,1 @@\n-        byte res = (byte) 0;\n+        byte res = zeroValue();\n@@ -4379,1 +4641,1 @@\n-        byte res = (byte) 0;\n+        byte res = zeroValue();\n@@ -4391,1 +4653,1 @@\n-        byte ra = (byte) 0;\n+        byte ra = zeroValue();\n@@ -4401,1 +4663,1 @@\n-            ra = (byte) 0;\n+            ra = zeroValue();\n@@ -4413,1 +4675,1 @@\n-        byte res = (byte) 0;\n+        byte res = zeroValue();\n@@ -4423,1 +4685,1 @@\n-        byte res = (byte) 0;\n+        byte res = zeroValue();\n@@ -4437,1 +4699,1 @@\n-        byte ra = (byte) 0;\n+        byte ra = zeroValue();\n@@ -4447,1 +4709,1 @@\n-            ra = (byte) 0;\n+            ra = zeroValue();\n@@ -4507,1 +4769,1 @@\n-        byte res = 0;\n+        byte res = zeroValue();\n@@ -4516,1 +4778,1 @@\n-        byte res = 0;\n+        byte res = zeroValue();\n@@ -4528,1 +4790,1 @@\n-        byte ra = 0;\n+        byte ra = zeroValue();\n@@ -4538,1 +4800,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4550,1 +4812,1 @@\n-        byte res = 0;\n+        byte res = zeroValue();\n@@ -4560,1 +4822,1 @@\n-        byte res = 0;\n+        byte res = zeroValue();\n@@ -4573,1 +4835,1 @@\n-        byte ra = 0;\n+        byte ra = zeroValue();\n@@ -4583,1 +4845,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4628,1 +4890,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -4648,1 +4910,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -4669,1 +4931,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -4689,1 +4951,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -4708,1 +4970,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4727,1 +4989,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4750,1 +5012,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -4769,1 +5031,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -4792,1 +5054,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -4811,1 +5073,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4830,1 +5092,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4853,1 +5115,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -4872,1 +5134,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -4895,1 +5157,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -4914,1 +5176,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -4937,1 +5199,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -4956,1 +5218,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -4979,1 +5241,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -4998,1 +5260,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n@@ -5021,1 +5283,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n@@ -5040,1 +5302,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n@@ -5063,1 +5325,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -5082,1 +5344,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n@@ -5105,1 +5367,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n@@ -5124,1 +5386,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n@@ -5147,1 +5409,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n@@ -5164,1 +5426,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -5184,1 +5446,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -5200,1 +5462,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < (byte)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (byte)((long)b[i])));\n@@ -5220,1 +5482,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < (byte)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(byte)((long)b[i]))));\n@@ -5236,1 +5498,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -5256,1 +5518,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -5272,1 +5534,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == (byte)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (byte)((long)b[i])));\n@@ -5292,1 +5554,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == (byte)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(byte)((long)b[i]))));\n@@ -5573,1 +5835,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -6004,1 +6266,1 @@\n-        return (byte)(-((byte)a));\n+        return (byte)(scalar_neg((byte)a));\n@@ -6008,1 +6270,1 @@\n-        return (byte)(-((byte)a));\n+        return (byte)(scalar_neg((byte)a));\n@@ -6060,1 +6322,1 @@\n-        return (byte)(Math.abs((byte)a));\n+        return (byte)(scalar_abs((byte)a));\n@@ -6064,1 +6326,1 @@\n-        return (byte)(Math.abs((byte)a));\n+        return (byte)(scalar_abs((byte)a));\n@@ -6404,1 +6666,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -6420,1 +6682,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -6527,1 +6789,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6568,1 +6830,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6671,1 +6933,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -6699,1 +6961,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -6713,1 +6975,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -6910,1 +7172,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -6930,1 +7192,1 @@\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -6953,1 +7215,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6967,1 +7229,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6989,1 +7251,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -6997,1 +7259,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -7004,1 +7266,1 @@\n-        Assert.assertEquals(elsize, Byte.SIZE);\n+        AssertEquals(elsize, Byte.SIZE);\n@@ -7023,1 +7285,1 @@\n-    static void ElementTypeByte512VectorTestsSmokeTest() {\n+    static void ByteByte512VectorTestsSmokeTest() {\n@@ -7058,1 +7320,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":594,"deletions":332,"binary":false,"changes":926,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,45 @@\n+    static ByteVector bcast_vec = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    static void AssertEquals(byte actual, byte expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(byte actual, byte expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(byte actual, byte expected, byte delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(byte actual, byte expected, byte delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(byte [] actual, byte [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(byte [] actual, byte [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -87,1 +132,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -90,1 +135,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -102,1 +147,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -108,1 +153,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -118,1 +163,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -121,1 +166,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -137,1 +182,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -139,1 +184,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -142,2 +187,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -159,1 +204,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -161,1 +206,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -164,2 +209,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -181,1 +226,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -183,1 +228,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -186,2 +231,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -203,1 +248,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -205,1 +250,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -208,2 +253,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -221,1 +266,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -224,1 +269,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -236,1 +281,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -239,1 +284,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -248,1 +293,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -253,1 +298,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -264,1 +309,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -269,1 +314,1 @@\n-                    Assert.assertEquals(r[i + k], (byte)0);\n+                    AssertEquals(r[i + k], (byte)0);\n@@ -275,1 +320,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -277,1 +322,1 @@\n-                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (byte)0, \"at index #\" + idx);\n@@ -289,1 +334,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -292,1 +337,1 @@\n-                        Assert.assertEquals(r[i + j], (byte)0);\n+                        AssertEquals(r[i + j], (byte)0);\n@@ -299,1 +344,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -301,1 +346,1 @@\n-                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (byte)0, \"at index #\" + idx);\n@@ -317,1 +362,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -321,1 +366,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -327,0 +372,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -330,1 +376,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -334,2 +382,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -345,1 +392,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -347,1 +394,1 @@\n-                         Assert.assertEquals(r[i+j], (byte)0);\n+                         AssertEquals(r[i+j], (byte)0);\n@@ -353,1 +400,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -355,1 +402,1 @@\n-                Assert.assertEquals(r[i+j], (byte)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (byte)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -361,0 +408,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -364,0 +412,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -365,1 +415,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -367,1 +417,1 @@\n-                         Assert.assertEquals(r[i+j], (byte)0);\n+                         AssertEquals(r[i+j], (byte)0);\n@@ -371,1 +421,0 @@\n-            int idx = i + j;\n@@ -373,1 +422,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -375,1 +424,1 @@\n-                Assert.assertEquals(r[i+j], (byte)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (byte)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -389,1 +438,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -392,1 +441,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -413,1 +462,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -416,1 +465,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -419,1 +468,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -422,3 +471,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -439,1 +488,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -442,1 +491,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -445,1 +494,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -448,3 +497,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -458,1 +507,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -461,1 +510,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -469,1 +518,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -472,1 +521,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -480,1 +529,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -483,1 +532,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -492,1 +541,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -495,1 +544,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -508,1 +557,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -511,1 +560,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -523,1 +572,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -526,1 +575,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -538,1 +587,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -541,1 +590,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -556,1 +605,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -559,1 +608,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -572,1 +621,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -576,1 +625,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -590,1 +639,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -594,1 +643,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -616,1 +665,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -620,1 +669,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -634,1 +683,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -638,1 +687,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -658,1 +707,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -661,1 +710,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -673,1 +722,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -676,1 +725,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -685,1 +734,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -688,1 +737,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -698,1 +747,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -701,1 +750,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -717,1 +766,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -721,1 +770,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -738,1 +787,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -742,1 +791,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -753,1 +802,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -757,1 +806,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -774,1 +823,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -778,1 +827,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -796,1 +845,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -802,1 +851,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -823,1 +872,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -829,1 +878,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -844,1 +893,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -850,1 +899,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -871,1 +920,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -877,1 +926,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -891,1 +940,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -897,1 +946,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -912,1 +961,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -918,1 +967,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -933,1 +982,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -939,1 +988,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -955,1 +1004,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -961,1 +1010,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -969,0 +1018,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -974,1 +1027,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -977,1 +1030,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -986,1 +1039,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -989,1 +1042,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -997,1 +1050,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -1000,1 +1053,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1008,1 +1061,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                AssertEquals(r[i], (double)(a[i+offs]));\n@@ -1011,1 +1064,1 @@\n-            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1020,1 +1073,1 @@\n-            withToString(\"byte[-i * 5]\", (int s) -> {\n+            withToString(\"Byte[-i * 5]\", (int s) -> {\n@@ -1022,1 +1075,1 @@\n-                            i -> (byte)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1024,1 +1077,1 @@\n-            withToString(\"byte[i * 5]\", (int s) -> {\n+            withToString(\"Byte[i * 5]\", (int s) -> {\n@@ -1026,1 +1079,1 @@\n-                            i -> (byte)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1028,1 +1081,1 @@\n-            withToString(\"byte[i + 1]\", (int s) -> {\n+            withToString(\"Byte[i + 1]\", (int s) -> {\n@@ -1030,1 +1083,1 @@\n-                            i -> (((byte)(i + 1) == 0) ? 1 : (byte)(i + 1)));\n+                            i -> (((byte)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1477,0 +1530,212 @@\n+    static byte firstNonZero(byte a, byte b) {\n+        return Byte.compare(a, (byte) 0) != 0 ? a : b;\n+    }\n+\n+    static byte multiplicativeIdentity() {\n+        return (byte)1;\n+    }\n+\n+    static byte scalar_or(byte a, byte b) {\n+        return (byte)(a | b);\n+    }\n+\n+    static byte scalar_and(byte a, byte b) {\n+        return (byte)(a & b);\n+    }\n+\n+    static byte scalar_xor(byte a, byte b) {\n+        return (byte)(a ^ b);\n+    }\n+\n+    static byte scalar_add(byte a, byte b) {\n+        return (byte)(a + b);\n+    }\n+\n+    static byte scalar_sub(byte a, byte b) {\n+        return (byte)(a - b);\n+    }\n+\n+    static byte scalar_mul(byte a, byte b) {\n+        return (byte)(a * b);\n+    }\n+\n+    static byte scalar_min(byte a, byte b) {\n+        return (byte)(Math.min(a, b));\n+    }\n+\n+    static byte scalar_max(byte a, byte b) {\n+        return (byte)(Math.max(a, b));\n+    }\n+\n+    static byte scalar_div(byte a, byte b) {\n+        return (byte)(a \/ b);\n+    }\n+\n+    static byte scalar_fma(byte a, byte b, byte c) {\n+        return (byte)(Math.fma(a, b, c));\n+    }\n+\n+    static byte scalar_abs(byte a) {\n+        return (byte)(Math.abs(a));\n+    }\n+\n+    static byte scalar_neg(byte a) {\n+        return ((byte)-a);\n+    }\n+\n+    static byte scalar_sin(byte a) {\n+        return (byte)Math.sin((double)a);\n+    }\n+\n+    static byte scalar_exp(byte a) {\n+        return (byte)Math.exp((double)a);\n+    }\n+\n+    static byte scalar_log1p(byte a) {\n+        return (byte)Math.log1p((double)a);\n+    }\n+\n+    static byte scalar_log(byte a) {\n+        return (byte)Math.log((double)a);\n+    }\n+\n+    static byte scalar_log10(byte a) {\n+        return (byte)Math.log10((double)a);\n+    }\n+\n+    static byte scalar_expm1(byte a) {\n+        return (byte)Math.expm1((double)a);\n+    }\n+\n+    static byte scalar_cos(byte a) {\n+        return (byte)Math.cos((double)a);\n+    }\n+\n+    static byte scalar_tan(byte a) {\n+        return (byte)Math.tan((double)a);\n+    }\n+\n+    static byte scalar_sinh(byte a) {\n+        return (byte)Math.sinh((double)a);\n+    }\n+\n+    static byte scalar_cosh(byte a) {\n+        return (byte)Math.cosh((double)a);\n+    }\n+\n+    static byte scalar_tanh(byte a) {\n+        return (byte)Math.tanh((double)a);\n+    }\n+\n+    static byte scalar_asin(byte a) {\n+        return (byte)Math.asin((double)a);\n+    }\n+\n+    static byte scalar_acos(byte a) {\n+        return (byte)Math.acos((double)a);\n+    }\n+\n+    static byte scalar_atan(byte a) {\n+        return (byte)Math.atan((double)a);\n+    }\n+\n+    static byte scalar_cbrt(byte a) {\n+        return (byte)Math.cbrt((double)a);\n+    }\n+\n+    static byte scalar_sqrt(byte a) {\n+        return (byte)Math.sqrt((double)a);\n+    }\n+\n+    static byte scalar_hypot(byte a, byte b) {\n+        return (byte)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static byte scalar_pow(byte a, byte b) {\n+        return (byte)Math.pow((double)a, (double)b);\n+    }\n+\n+    static byte scalar_atan2(byte a, byte b) {\n+        return (byte)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static byte strict_scalar_sin(byte a) {\n+        return (byte)StrictMath.sin((double)a);\n+    }\n+\n+    static byte strict_scalar_exp(byte a) {\n+        return (byte)StrictMath.exp((double)a);\n+    }\n+\n+    static byte strict_scalar_log1p(byte a) {\n+        return (byte)StrictMath.log1p((double)a);\n+    }\n+\n+    static byte strict_scalar_log(byte a) {\n+        return (byte)StrictMath.log((double)a);\n+    }\n+\n+    static byte strict_scalar_log10(byte a) {\n+        return (byte)StrictMath.log10((double)a);\n+    }\n+\n+    static byte strict_scalar_expm1(byte a) {\n+        return (byte)StrictMath.expm1((double)a);\n+    }\n+\n+    static byte strict_scalar_cos(byte a) {\n+        return (byte)StrictMath.cos((double)a);\n+    }\n+\n+    static byte strict_scalar_tan(byte a) {\n+        return (byte)StrictMath.tan((double)a);\n+    }\n+\n+    static byte strict_scalar_sinh(byte a) {\n+        return (byte)StrictMath.sinh((double)a);\n+    }\n+\n+    static byte strict_scalar_cosh(byte a) {\n+        return (byte)StrictMath.cosh((double)a);\n+    }\n+\n+    static byte strict_scalar_tanh(byte a) {\n+        return (byte)StrictMath.tanh((double)a);\n+    }\n+\n+    static byte strict_scalar_asin(byte a) {\n+        return (byte)StrictMath.asin((double)a);\n+    }\n+\n+    static byte strict_scalar_acos(byte a) {\n+        return (byte)StrictMath.acos((double)a);\n+    }\n+\n+    static byte strict_scalar_atan(byte a) {\n+        return (byte)StrictMath.atan((double)a);\n+    }\n+\n+    static byte strict_scalar_cbrt(byte a) {\n+        return (byte)StrictMath.cbrt((double)a);\n+    }\n+\n+    static byte strict_scalar_sqrt(byte a) {\n+        return (byte)StrictMath.sqrt((double)a);\n+    }\n+\n+    static byte strict_scalar_hypot(byte a, byte b) {\n+        return (byte)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static byte strict_scalar_pow(byte a, byte b) {\n+        return (byte)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static byte strict_scalar_atan2(byte a, byte b) {\n+        return (byte)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static byte additiveIdentity() {\n+        return (byte)0;\n+    }\n+\n+\n@@ -1493,2 +1758,10 @@\n-    static byte firstNonZero(byte a, byte b) {\n-        return Byte.compare(a, (byte) 0) != 0 ? a : b;\n+    static byte zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static byte maxValue() {\n+        return Byte.MAX_VALUE;\n+    }\n+\n+    static byte minValue() {\n+        return Byte.MIN_VALUE;\n@@ -1497,0 +1770,1 @@\n+\n@@ -1532,1 +1806,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1547,1 +1821,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1553,1 +1827,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1559,1 +1833,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1574,1 +1848,1 @@\n-        Assert.assertEquals(asIntegral.species(), SPECIES);\n+        AssertEquals(asIntegral.species(), SPECIES);\n@@ -1604,1 +1878,1 @@\n-        return (byte)(a + b);\n+        return (byte)(scalar_add(a, b));\n@@ -1625,1 +1899,1 @@\n-        return (byte)(a + b);\n+        return (byte)(scalar_add(a, b));\n@@ -1682,1 +1956,1 @@\n-        return (byte)(a - b);\n+        return (byte)(scalar_sub(a, b));\n@@ -1703,1 +1977,1 @@\n-        return (byte)(a - b);\n+        return (byte)(scalar_sub(a, b));\n@@ -1760,1 +2034,1 @@\n-        return (byte)(a * b);\n+        return (byte)(scalar_mul(a, b));\n@@ -1781,1 +2055,1 @@\n-        return (byte)(a * b);\n+        return (byte)(scalar_mul(a, b));\n@@ -1928,1 +2202,1 @@\n-        return (byte)((a)!=0?a:b);\n+        return (byte)(firstNonZero(a, b));\n@@ -3035,2 +3309,0 @@\n-    static ByteVector bv_MIN = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3045,1 +3317,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -3052,2 +3324,0 @@\n-    static ByteVector bv_min = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3062,1 +3332,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -3069,2 +3339,0 @@\n-    static ByteVector bv_MIN_M = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3081,1 +3349,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -3088,2 +3356,0 @@\n-    static ByteVector bv_MAX = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3098,1 +3364,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -3105,2 +3371,0 @@\n-    static ByteVector bv_max = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3115,1 +3379,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -3122,2 +3386,0 @@\n-    static ByteVector bv_MAX_M = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3134,1 +3396,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -3142,1 +3404,1 @@\n-        return (byte)(Math.min(a, b));\n+        return (byte)(scalar_min(a, b));\n@@ -3163,1 +3425,1 @@\n-        return (byte)(Math.min(a, b));\n+        return (byte)(scalar_min(a, b));\n@@ -3182,1 +3444,1 @@\n-        return (byte)(Math.max(a, b));\n+        return (byte)(scalar_max(a, b));\n@@ -3203,1 +3465,1 @@\n-        return (byte)(Math.max(a, b));\n+        return (byte)(scalar_max(a, b));\n@@ -3571,1 +3833,1 @@\n-            res &= a[i];\n+            res = scalar_and(res, a[i]);\n@@ -3580,1 +3842,1 @@\n-            res &= ANDReduce(a, i);\n+            res = scalar_and(res, ANDReduce(a, i));\n@@ -3603,1 +3865,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND));\n@@ -3615,1 +3877,1 @@\n-                res &= a[i];\n+                res = scalar_and(res, a[i]);\n@@ -3624,1 +3886,1 @@\n-            res &= ANDReduceMasked(a, i, mask);\n+            res = scalar_and(res, ANDReduceMasked(a, i, mask));\n@@ -3649,1 +3911,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND, vmask));\n@@ -3660,1 +3922,1 @@\n-            res |= a[i];\n+            res = scalar_or(res, a[i]);\n@@ -3669,1 +3931,1 @@\n-            res |= ORReduce(a, i);\n+            res = scalar_or(res, ORReduce(a, i));\n@@ -3692,1 +3954,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR));\n@@ -3704,1 +3966,1 @@\n-                res |= a[i];\n+                res = scalar_or(res, a[i]);\n@@ -3713,1 +3975,1 @@\n-            res |= ORReduceMasked(a, i, mask);\n+            res = scalar_or(res, ORReduceMasked(a, i, mask));\n@@ -3738,1 +4000,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR, vmask));\n@@ -3749,1 +4011,1 @@\n-            res ^= a[i];\n+            res = scalar_xor(res, a[i]);\n@@ -3758,1 +4020,1 @@\n-            res ^= XORReduce(a, i);\n+            res = scalar_xor(res, XORReduce(a, i));\n@@ -3781,1 +4043,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR));\n@@ -3793,1 +4055,1 @@\n-                res ^= a[i];\n+                res = scalar_xor(res, a[i]);\n@@ -3802,1 +4064,1 @@\n-            res ^= XORReduceMasked(a, i, mask);\n+            res = scalar_xor(res, XORReduceMasked(a, i, mask));\n@@ -3827,1 +4089,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR, vmask));\n@@ -3836,1 +4098,1 @@\n-        byte res = 0;\n+        byte res = additiveIdentity();\n@@ -3838,1 +4100,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -3845,1 +4107,1 @@\n-        byte res = 0;\n+        byte res = additiveIdentity();\n@@ -3847,1 +4109,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -3857,1 +4119,1 @@\n-        byte ra = 0;\n+        byte ra = additiveIdentity();\n@@ -3867,1 +4129,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3870,1 +4132,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -3879,1 +4141,1 @@\n-        byte res = 0;\n+        byte res = additiveIdentity();\n@@ -3882,1 +4144,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -3889,1 +4151,1 @@\n-        byte res = 0;\n+        byte res = additiveIdentity();\n@@ -3891,1 +4153,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -3903,1 +4165,1 @@\n-        byte ra = 0;\n+        byte ra = additiveIdentity();\n@@ -3913,1 +4175,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3916,1 +4178,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -3925,1 +4187,1 @@\n-        byte res = 1;\n+        byte res = multiplicativeIdentity();\n@@ -3927,1 +4189,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -3934,1 +4196,1 @@\n-        byte res = 1;\n+        byte res = multiplicativeIdentity();\n@@ -3936,1 +4198,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -3946,1 +4208,1 @@\n-        byte ra = 1;\n+        byte ra = multiplicativeIdentity();\n@@ -3956,1 +4218,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -3959,1 +4221,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -3968,1 +4230,1 @@\n-        byte res = 1;\n+        byte res = multiplicativeIdentity();\n@@ -3971,1 +4233,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -3978,1 +4240,1 @@\n-        byte res = 1;\n+        byte res = multiplicativeIdentity();\n@@ -3980,1 +4242,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -3992,1 +4254,1 @@\n-        byte ra = 1;\n+        byte ra = multiplicativeIdentity();\n@@ -4002,1 +4264,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -4005,1 +4267,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -4014,1 +4276,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4016,1 +4278,1 @@\n-            res = (byte) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -4023,1 +4285,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4025,1 +4287,1 @@\n-            res = (byte) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -4035,1 +4297,1 @@\n-        byte ra = Byte.MAX_VALUE;\n+        byte ra = maxValue();\n@@ -4045,1 +4307,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = maxValue();\n@@ -4048,1 +4310,1 @@\n-                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -4057,1 +4319,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4060,1 +4322,1 @@\n-                res = (byte) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -4067,1 +4329,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4069,1 +4331,1 @@\n-            res = (byte) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -4081,1 +4343,1 @@\n-        byte ra = Byte.MAX_VALUE;\n+        byte ra = maxValue();\n@@ -4091,1 +4353,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = maxValue();\n@@ -4094,1 +4356,1 @@\n-                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -4103,1 +4365,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4105,1 +4367,1 @@\n-            res = (byte) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -4112,1 +4374,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4114,1 +4376,1 @@\n-            res = (byte) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -4124,1 +4386,1 @@\n-        byte ra = Byte.MIN_VALUE;\n+        byte ra = minValue();\n@@ -4134,1 +4396,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = minValue();\n@@ -4137,1 +4399,1 @@\n-                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -4146,1 +4408,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4149,1 +4411,1 @@\n-                res = (byte) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -4156,1 +4418,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4158,1 +4420,1 @@\n-            res = (byte) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -4170,1 +4432,1 @@\n-        byte ra = Byte.MIN_VALUE;\n+        byte ra = minValue();\n@@ -4180,1 +4442,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = minValue();\n@@ -4183,1 +4445,1 @@\n-                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -4192,1 +4454,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4201,1 +4463,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4213,1 +4475,1 @@\n-        byte ra = Byte.MAX_VALUE;\n+        byte ra = maxValue();\n@@ -4223,1 +4485,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = maxValue();\n@@ -4235,1 +4497,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4245,1 +4507,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4259,1 +4521,1 @@\n-        byte ra = Byte.MAX_VALUE;\n+        byte ra = maxValue();\n@@ -4269,1 +4531,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = maxValue();\n@@ -4281,1 +4543,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4290,1 +4552,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4302,1 +4564,1 @@\n-        byte ra = Byte.MIN_VALUE;\n+        byte ra = minValue();\n@@ -4312,1 +4574,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = minValue();\n@@ -4324,1 +4586,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4334,1 +4596,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4348,1 +4610,1 @@\n-        byte ra = Byte.MIN_VALUE;\n+        byte ra = minValue();\n@@ -4358,1 +4620,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = minValue();\n@@ -4370,1 +4632,1 @@\n-        byte res = (byte) 0;\n+        byte res = zeroValue();\n@@ -4379,1 +4641,1 @@\n-        byte res = (byte) 0;\n+        byte res = zeroValue();\n@@ -4391,1 +4653,1 @@\n-        byte ra = (byte) 0;\n+        byte ra = zeroValue();\n@@ -4401,1 +4663,1 @@\n-            ra = (byte) 0;\n+            ra = zeroValue();\n@@ -4413,1 +4675,1 @@\n-        byte res = (byte) 0;\n+        byte res = zeroValue();\n@@ -4423,1 +4685,1 @@\n-        byte res = (byte) 0;\n+        byte res = zeroValue();\n@@ -4437,1 +4699,1 @@\n-        byte ra = (byte) 0;\n+        byte ra = zeroValue();\n@@ -4447,1 +4709,1 @@\n-            ra = (byte) 0;\n+            ra = zeroValue();\n@@ -4507,1 +4769,1 @@\n-        byte res = 0;\n+        byte res = zeroValue();\n@@ -4516,1 +4778,1 @@\n-        byte res = 0;\n+        byte res = zeroValue();\n@@ -4528,1 +4790,1 @@\n-        byte ra = 0;\n+        byte ra = zeroValue();\n@@ -4538,1 +4800,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4550,1 +4812,1 @@\n-        byte res = 0;\n+        byte res = zeroValue();\n@@ -4560,1 +4822,1 @@\n-        byte res = 0;\n+        byte res = zeroValue();\n@@ -4573,1 +4835,1 @@\n-        byte ra = 0;\n+        byte ra = zeroValue();\n@@ -4583,1 +4845,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4628,1 +4890,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -4648,1 +4910,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -4669,1 +4931,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -4689,1 +4951,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -4708,1 +4970,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4727,1 +4989,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4750,1 +5012,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -4769,1 +5031,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -4792,1 +5054,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -4811,1 +5073,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4830,1 +5092,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4853,1 +5115,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -4872,1 +5134,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -4895,1 +5157,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -4914,1 +5176,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -4937,1 +5199,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -4956,1 +5218,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -4979,1 +5241,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -4998,1 +5260,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n@@ -5021,1 +5283,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n@@ -5040,1 +5302,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n@@ -5063,1 +5325,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -5082,1 +5344,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n@@ -5105,1 +5367,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n@@ -5124,1 +5386,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n@@ -5147,1 +5409,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n@@ -5164,1 +5426,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -5184,1 +5446,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -5200,1 +5462,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < (byte)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (byte)((long)b[i])));\n@@ -5220,1 +5482,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < (byte)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(byte)((long)b[i]))));\n@@ -5236,1 +5498,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -5256,1 +5518,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -5272,1 +5534,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == (byte)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (byte)((long)b[i])));\n@@ -5292,1 +5554,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == (byte)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(byte)((long)b[i]))));\n@@ -5573,1 +5835,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -6004,1 +6266,1 @@\n-        return (byte)(-((byte)a));\n+        return (byte)(scalar_neg((byte)a));\n@@ -6008,1 +6270,1 @@\n-        return (byte)(-((byte)a));\n+        return (byte)(scalar_neg((byte)a));\n@@ -6060,1 +6322,1 @@\n-        return (byte)(Math.abs((byte)a));\n+        return (byte)(scalar_abs((byte)a));\n@@ -6064,1 +6326,1 @@\n-        return (byte)(Math.abs((byte)a));\n+        return (byte)(scalar_abs((byte)a));\n@@ -6404,1 +6666,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -6420,1 +6682,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -6527,1 +6789,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6568,1 +6830,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6671,1 +6933,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -6699,1 +6961,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -6713,1 +6975,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -6910,1 +7172,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -6930,1 +7192,1 @@\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -6953,1 +7215,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6967,1 +7229,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6989,1 +7251,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -6997,1 +7259,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -7004,1 +7266,1 @@\n-        Assert.assertEquals(elsize, Byte.SIZE);\n+        AssertEquals(elsize, Byte.SIZE);\n@@ -7023,1 +7285,1 @@\n-    static void ElementTypeByte64VectorTestsSmokeTest() {\n+    static void ByteByte64VectorTestsSmokeTest() {\n@@ -7058,1 +7320,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":594,"deletions":332,"binary":false,"changes":926,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,45 @@\n+    static ByteVector bcast_vec = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    static void AssertEquals(byte actual, byte expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(byte actual, byte expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(byte actual, byte expected, byte delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(byte actual, byte expected, byte delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(byte [] actual, byte [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(byte [] actual, byte [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -92,1 +137,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -95,1 +140,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -107,1 +152,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -113,1 +158,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -123,1 +168,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -126,1 +171,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -142,1 +187,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -144,1 +189,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -147,2 +192,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -164,1 +209,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -166,1 +211,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -169,2 +214,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -186,1 +231,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -188,1 +233,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -191,2 +236,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -208,1 +253,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -210,1 +255,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -213,2 +258,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -226,1 +271,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -229,1 +274,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -241,1 +286,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -244,1 +289,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -253,1 +298,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -258,1 +303,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -269,1 +314,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -274,1 +319,1 @@\n-                    Assert.assertEquals(r[i + k], (byte)0);\n+                    AssertEquals(r[i + k], (byte)0);\n@@ -280,1 +325,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -282,1 +327,1 @@\n-                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (byte)0, \"at index #\" + idx);\n@@ -294,1 +339,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -297,1 +342,1 @@\n-                        Assert.assertEquals(r[i + j], (byte)0);\n+                        AssertEquals(r[i + j], (byte)0);\n@@ -304,1 +349,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -306,1 +351,1 @@\n-                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (byte)0, \"at index #\" + idx);\n@@ -322,1 +367,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -326,1 +371,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -332,0 +377,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -335,1 +381,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -339,2 +387,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -350,1 +397,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -352,1 +399,1 @@\n-                         Assert.assertEquals(r[i+j], (byte)0);\n+                         AssertEquals(r[i+j], (byte)0);\n@@ -358,1 +405,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -360,1 +407,1 @@\n-                Assert.assertEquals(r[i+j], (byte)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (byte)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -366,0 +413,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -369,0 +417,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -370,1 +420,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -372,1 +422,1 @@\n-                         Assert.assertEquals(r[i+j], (byte)0);\n+                         AssertEquals(r[i+j], (byte)0);\n@@ -376,1 +426,0 @@\n-            int idx = i + j;\n@@ -378,1 +427,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -380,1 +429,1 @@\n-                Assert.assertEquals(r[i+j], (byte)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (byte)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -394,1 +443,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -397,1 +446,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -418,1 +467,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -421,1 +470,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -424,1 +473,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -427,3 +476,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -444,1 +493,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -447,1 +496,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -450,1 +499,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -453,3 +502,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -463,1 +512,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -466,1 +515,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -474,1 +523,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -477,1 +526,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -485,1 +534,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -488,1 +537,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -497,1 +546,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -500,1 +549,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -513,1 +562,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -516,1 +565,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -528,1 +577,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -531,1 +580,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -543,1 +592,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -546,1 +595,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -561,1 +610,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -564,1 +613,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (byte)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -577,1 +626,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -581,1 +630,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -595,1 +644,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -599,1 +648,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -621,1 +670,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -625,1 +674,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -639,1 +688,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -643,1 +692,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -663,1 +712,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -666,1 +715,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -678,1 +727,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -681,1 +730,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -690,1 +739,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -693,1 +742,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -703,1 +752,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -706,1 +755,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -722,1 +771,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -726,1 +775,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -743,1 +792,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -747,1 +796,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -758,1 +807,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -762,1 +811,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -779,1 +828,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -783,1 +832,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -801,1 +850,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -807,1 +856,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -828,1 +877,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -834,1 +883,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -849,1 +898,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -855,1 +904,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -876,1 +925,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -882,1 +931,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -896,1 +945,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -902,1 +951,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -917,1 +966,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -923,1 +972,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -938,1 +987,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -944,1 +993,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -960,1 +1009,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -966,1 +1015,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -974,0 +1023,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -979,1 +1032,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -982,1 +1035,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -991,1 +1044,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -994,1 +1047,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1002,1 +1055,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -1005,1 +1058,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1013,1 +1066,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                AssertEquals(r[i], (double)(a[i+offs]));\n@@ -1016,1 +1069,1 @@\n-            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1025,1 +1078,1 @@\n-            withToString(\"byte[-i * 5]\", (int s) -> {\n+            withToString(\"Byte[-i * 5]\", (int s) -> {\n@@ -1027,1 +1080,1 @@\n-                            i -> (byte)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1029,1 +1082,1 @@\n-            withToString(\"byte[i * 5]\", (int s) -> {\n+            withToString(\"Byte[i * 5]\", (int s) -> {\n@@ -1031,1 +1084,1 @@\n-                            i -> (byte)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1033,1 +1086,1 @@\n-            withToString(\"byte[i + 1]\", (int s) -> {\n+            withToString(\"Byte[i + 1]\", (int s) -> {\n@@ -1035,1 +1088,1 @@\n-                            i -> (((byte)(i + 1) == 0) ? 1 : (byte)(i + 1)));\n+                            i -> (((byte)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1482,0 +1535,212 @@\n+    static byte firstNonZero(byte a, byte b) {\n+        return Byte.compare(a, (byte) 0) != 0 ? a : b;\n+    }\n+\n+    static byte multiplicativeIdentity() {\n+        return (byte)1;\n+    }\n+\n+    static byte scalar_or(byte a, byte b) {\n+        return (byte)(a | b);\n+    }\n+\n+    static byte scalar_and(byte a, byte b) {\n+        return (byte)(a & b);\n+    }\n+\n+    static byte scalar_xor(byte a, byte b) {\n+        return (byte)(a ^ b);\n+    }\n+\n+    static byte scalar_add(byte a, byte b) {\n+        return (byte)(a + b);\n+    }\n+\n+    static byte scalar_sub(byte a, byte b) {\n+        return (byte)(a - b);\n+    }\n+\n+    static byte scalar_mul(byte a, byte b) {\n+        return (byte)(a * b);\n+    }\n+\n+    static byte scalar_min(byte a, byte b) {\n+        return (byte)(Math.min(a, b));\n+    }\n+\n+    static byte scalar_max(byte a, byte b) {\n+        return (byte)(Math.max(a, b));\n+    }\n+\n+    static byte scalar_div(byte a, byte b) {\n+        return (byte)(a \/ b);\n+    }\n+\n+    static byte scalar_fma(byte a, byte b, byte c) {\n+        return (byte)(Math.fma(a, b, c));\n+    }\n+\n+    static byte scalar_abs(byte a) {\n+        return (byte)(Math.abs(a));\n+    }\n+\n+    static byte scalar_neg(byte a) {\n+        return ((byte)-a);\n+    }\n+\n+    static byte scalar_sin(byte a) {\n+        return (byte)Math.sin((double)a);\n+    }\n+\n+    static byte scalar_exp(byte a) {\n+        return (byte)Math.exp((double)a);\n+    }\n+\n+    static byte scalar_log1p(byte a) {\n+        return (byte)Math.log1p((double)a);\n+    }\n+\n+    static byte scalar_log(byte a) {\n+        return (byte)Math.log((double)a);\n+    }\n+\n+    static byte scalar_log10(byte a) {\n+        return (byte)Math.log10((double)a);\n+    }\n+\n+    static byte scalar_expm1(byte a) {\n+        return (byte)Math.expm1((double)a);\n+    }\n+\n+    static byte scalar_cos(byte a) {\n+        return (byte)Math.cos((double)a);\n+    }\n+\n+    static byte scalar_tan(byte a) {\n+        return (byte)Math.tan((double)a);\n+    }\n+\n+    static byte scalar_sinh(byte a) {\n+        return (byte)Math.sinh((double)a);\n+    }\n+\n+    static byte scalar_cosh(byte a) {\n+        return (byte)Math.cosh((double)a);\n+    }\n+\n+    static byte scalar_tanh(byte a) {\n+        return (byte)Math.tanh((double)a);\n+    }\n+\n+    static byte scalar_asin(byte a) {\n+        return (byte)Math.asin((double)a);\n+    }\n+\n+    static byte scalar_acos(byte a) {\n+        return (byte)Math.acos((double)a);\n+    }\n+\n+    static byte scalar_atan(byte a) {\n+        return (byte)Math.atan((double)a);\n+    }\n+\n+    static byte scalar_cbrt(byte a) {\n+        return (byte)Math.cbrt((double)a);\n+    }\n+\n+    static byte scalar_sqrt(byte a) {\n+        return (byte)Math.sqrt((double)a);\n+    }\n+\n+    static byte scalar_hypot(byte a, byte b) {\n+        return (byte)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static byte scalar_pow(byte a, byte b) {\n+        return (byte)Math.pow((double)a, (double)b);\n+    }\n+\n+    static byte scalar_atan2(byte a, byte b) {\n+        return (byte)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static byte strict_scalar_sin(byte a) {\n+        return (byte)StrictMath.sin((double)a);\n+    }\n+\n+    static byte strict_scalar_exp(byte a) {\n+        return (byte)StrictMath.exp((double)a);\n+    }\n+\n+    static byte strict_scalar_log1p(byte a) {\n+        return (byte)StrictMath.log1p((double)a);\n+    }\n+\n+    static byte strict_scalar_log(byte a) {\n+        return (byte)StrictMath.log((double)a);\n+    }\n+\n+    static byte strict_scalar_log10(byte a) {\n+        return (byte)StrictMath.log10((double)a);\n+    }\n+\n+    static byte strict_scalar_expm1(byte a) {\n+        return (byte)StrictMath.expm1((double)a);\n+    }\n+\n+    static byte strict_scalar_cos(byte a) {\n+        return (byte)StrictMath.cos((double)a);\n+    }\n+\n+    static byte strict_scalar_tan(byte a) {\n+        return (byte)StrictMath.tan((double)a);\n+    }\n+\n+    static byte strict_scalar_sinh(byte a) {\n+        return (byte)StrictMath.sinh((double)a);\n+    }\n+\n+    static byte strict_scalar_cosh(byte a) {\n+        return (byte)StrictMath.cosh((double)a);\n+    }\n+\n+    static byte strict_scalar_tanh(byte a) {\n+        return (byte)StrictMath.tanh((double)a);\n+    }\n+\n+    static byte strict_scalar_asin(byte a) {\n+        return (byte)StrictMath.asin((double)a);\n+    }\n+\n+    static byte strict_scalar_acos(byte a) {\n+        return (byte)StrictMath.acos((double)a);\n+    }\n+\n+    static byte strict_scalar_atan(byte a) {\n+        return (byte)StrictMath.atan((double)a);\n+    }\n+\n+    static byte strict_scalar_cbrt(byte a) {\n+        return (byte)StrictMath.cbrt((double)a);\n+    }\n+\n+    static byte strict_scalar_sqrt(byte a) {\n+        return (byte)StrictMath.sqrt((double)a);\n+    }\n+\n+    static byte strict_scalar_hypot(byte a, byte b) {\n+        return (byte)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static byte strict_scalar_pow(byte a, byte b) {\n+        return (byte)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static byte strict_scalar_atan2(byte a, byte b) {\n+        return (byte)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static byte additiveIdentity() {\n+        return (byte)0;\n+    }\n+\n+\n@@ -1498,2 +1763,10 @@\n-    static byte firstNonZero(byte a, byte b) {\n-        return Byte.compare(a, (byte) 0) != 0 ? a : b;\n+    static byte zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static byte maxValue() {\n+        return Byte.MAX_VALUE;\n+    }\n+\n+    static byte minValue() {\n+        return Byte.MIN_VALUE;\n@@ -1502,0 +1775,1 @@\n+\n@@ -1537,1 +1811,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1552,1 +1826,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1558,1 +1832,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1564,1 +1838,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1579,1 +1853,1 @@\n-        Assert.assertEquals(asIntegral.species(), SPECIES);\n+        AssertEquals(asIntegral.species(), SPECIES);\n@@ -1609,1 +1883,1 @@\n-        return (byte)(a + b);\n+        return (byte)(scalar_add(a, b));\n@@ -1630,1 +1904,1 @@\n-        return (byte)(a + b);\n+        return (byte)(scalar_add(a, b));\n@@ -1687,1 +1961,1 @@\n-        return (byte)(a - b);\n+        return (byte)(scalar_sub(a, b));\n@@ -1708,1 +1982,1 @@\n-        return (byte)(a - b);\n+        return (byte)(scalar_sub(a, b));\n@@ -1765,1 +2039,1 @@\n-        return (byte)(a * b);\n+        return (byte)(scalar_mul(a, b));\n@@ -1786,1 +2060,1 @@\n-        return (byte)(a * b);\n+        return (byte)(scalar_mul(a, b));\n@@ -1933,1 +2207,1 @@\n-        return (byte)((a)!=0?a:b);\n+        return (byte)(firstNonZero(a, b));\n@@ -3040,2 +3314,0 @@\n-    static ByteVector bv_MIN = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3050,1 +3322,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -3057,2 +3329,0 @@\n-    static ByteVector bv_min = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3067,1 +3337,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -3074,2 +3344,0 @@\n-    static ByteVector bv_MIN_M = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3086,1 +3354,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -3093,2 +3361,0 @@\n-    static ByteVector bv_MAX = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3103,1 +3369,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -3110,2 +3376,0 @@\n-    static ByteVector bv_max = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3120,1 +3384,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -3127,2 +3391,0 @@\n-    static ByteVector bv_MAX_M = ByteVector.broadcast(SPECIES, (byte)10);\n-\n@@ -3139,1 +3401,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -3147,1 +3409,1 @@\n-        return (byte)(Math.min(a, b));\n+        return (byte)(scalar_min(a, b));\n@@ -3168,1 +3430,1 @@\n-        return (byte)(Math.min(a, b));\n+        return (byte)(scalar_min(a, b));\n@@ -3187,1 +3449,1 @@\n-        return (byte)(Math.max(a, b));\n+        return (byte)(scalar_max(a, b));\n@@ -3208,1 +3470,1 @@\n-        return (byte)(Math.max(a, b));\n+        return (byte)(scalar_max(a, b));\n@@ -3576,1 +3838,1 @@\n-            res &= a[i];\n+            res = scalar_and(res, a[i]);\n@@ -3585,1 +3847,1 @@\n-            res &= ANDReduce(a, i);\n+            res = scalar_and(res, ANDReduce(a, i));\n@@ -3608,1 +3870,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND));\n@@ -3620,1 +3882,1 @@\n-                res &= a[i];\n+                res = scalar_and(res, a[i]);\n@@ -3629,1 +3891,1 @@\n-            res &= ANDReduceMasked(a, i, mask);\n+            res = scalar_and(res, ANDReduceMasked(a, i, mask));\n@@ -3654,1 +3916,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND, vmask));\n@@ -3665,1 +3927,1 @@\n-            res |= a[i];\n+            res = scalar_or(res, a[i]);\n@@ -3674,1 +3936,1 @@\n-            res |= ORReduce(a, i);\n+            res = scalar_or(res, ORReduce(a, i));\n@@ -3697,1 +3959,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR));\n@@ -3709,1 +3971,1 @@\n-                res |= a[i];\n+                res = scalar_or(res, a[i]);\n@@ -3718,1 +3980,1 @@\n-            res |= ORReduceMasked(a, i, mask);\n+            res = scalar_or(res, ORReduceMasked(a, i, mask));\n@@ -3743,1 +4005,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR, vmask));\n@@ -3754,1 +4016,1 @@\n-            res ^= a[i];\n+            res = scalar_xor(res, a[i]);\n@@ -3763,1 +4025,1 @@\n-            res ^= XORReduce(a, i);\n+            res = scalar_xor(res, XORReduce(a, i));\n@@ -3786,1 +4048,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR));\n@@ -3798,1 +4060,1 @@\n-                res ^= a[i];\n+                res = scalar_xor(res, a[i]);\n@@ -3807,1 +4069,1 @@\n-            res ^= XORReduceMasked(a, i, mask);\n+            res = scalar_xor(res, XORReduceMasked(a, i, mask));\n@@ -3832,1 +4094,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR, vmask));\n@@ -3841,1 +4103,1 @@\n-        byte res = 0;\n+        byte res = additiveIdentity();\n@@ -3843,1 +4105,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -3850,1 +4112,1 @@\n-        byte res = 0;\n+        byte res = additiveIdentity();\n@@ -3852,1 +4114,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -3862,1 +4124,1 @@\n-        byte ra = 0;\n+        byte ra = additiveIdentity();\n@@ -3872,1 +4134,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3875,1 +4137,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -3884,1 +4146,1 @@\n-        byte res = 0;\n+        byte res = additiveIdentity();\n@@ -3887,1 +4149,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -3894,1 +4156,1 @@\n-        byte res = 0;\n+        byte res = additiveIdentity();\n@@ -3896,1 +4158,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -3908,1 +4170,1 @@\n-        byte ra = 0;\n+        byte ra = additiveIdentity();\n@@ -3918,1 +4180,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3921,1 +4183,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -3930,1 +4192,1 @@\n-        byte res = 1;\n+        byte res = multiplicativeIdentity();\n@@ -3932,1 +4194,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -3939,1 +4201,1 @@\n-        byte res = 1;\n+        byte res = multiplicativeIdentity();\n@@ -3941,1 +4203,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -3951,1 +4213,1 @@\n-        byte ra = 1;\n+        byte ra = multiplicativeIdentity();\n@@ -3961,1 +4223,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -3964,1 +4226,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -3973,1 +4235,1 @@\n-        byte res = 1;\n+        byte res = multiplicativeIdentity();\n@@ -3976,1 +4238,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -3983,1 +4245,1 @@\n-        byte res = 1;\n+        byte res = multiplicativeIdentity();\n@@ -3985,1 +4247,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -3997,1 +4259,1 @@\n-        byte ra = 1;\n+        byte ra = multiplicativeIdentity();\n@@ -4007,1 +4269,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -4010,1 +4272,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -4019,1 +4281,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4021,1 +4283,1 @@\n-            res = (byte) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -4028,1 +4290,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4030,1 +4292,1 @@\n-            res = (byte) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -4040,1 +4302,1 @@\n-        byte ra = Byte.MAX_VALUE;\n+        byte ra = maxValue();\n@@ -4050,1 +4312,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = maxValue();\n@@ -4053,1 +4315,1 @@\n-                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -4062,1 +4324,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4065,1 +4327,1 @@\n-                res = (byte) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -4072,1 +4334,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4074,1 +4336,1 @@\n-            res = (byte) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -4086,1 +4348,1 @@\n-        byte ra = Byte.MAX_VALUE;\n+        byte ra = maxValue();\n@@ -4096,1 +4358,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = maxValue();\n@@ -4099,1 +4361,1 @@\n-                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -4108,1 +4370,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4110,1 +4372,1 @@\n-            res = (byte) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -4117,1 +4379,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4119,1 +4381,1 @@\n-            res = (byte) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -4129,1 +4391,1 @@\n-        byte ra = Byte.MIN_VALUE;\n+        byte ra = minValue();\n@@ -4139,1 +4401,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = minValue();\n@@ -4142,1 +4404,1 @@\n-                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -4151,1 +4413,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4154,1 +4416,1 @@\n-                res = (byte) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -4161,1 +4423,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4163,1 +4425,1 @@\n-            res = (byte) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -4175,1 +4437,1 @@\n-        byte ra = Byte.MIN_VALUE;\n+        byte ra = minValue();\n@@ -4185,1 +4447,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = minValue();\n@@ -4188,1 +4450,1 @@\n-                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -4197,1 +4459,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4206,1 +4468,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4218,1 +4480,1 @@\n-        byte ra = Byte.MAX_VALUE;\n+        byte ra = maxValue();\n@@ -4228,1 +4490,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = maxValue();\n@@ -4240,1 +4502,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4250,1 +4512,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = maxValue();\n@@ -4264,1 +4526,1 @@\n-        byte ra = Byte.MAX_VALUE;\n+        byte ra = maxValue();\n@@ -4274,1 +4536,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = maxValue();\n@@ -4286,1 +4548,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4295,1 +4557,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4307,1 +4569,1 @@\n-        byte ra = Byte.MIN_VALUE;\n+        byte ra = minValue();\n@@ -4317,1 +4579,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = minValue();\n@@ -4329,1 +4591,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4339,1 +4601,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = minValue();\n@@ -4353,1 +4615,1 @@\n-        byte ra = Byte.MIN_VALUE;\n+        byte ra = minValue();\n@@ -4363,1 +4625,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = minValue();\n@@ -4375,1 +4637,1 @@\n-        byte res = (byte) 0;\n+        byte res = zeroValue();\n@@ -4384,1 +4646,1 @@\n-        byte res = (byte) 0;\n+        byte res = zeroValue();\n@@ -4396,1 +4658,1 @@\n-        byte ra = (byte) 0;\n+        byte ra = zeroValue();\n@@ -4406,1 +4668,1 @@\n-            ra = (byte) 0;\n+            ra = zeroValue();\n@@ -4418,1 +4680,1 @@\n-        byte res = (byte) 0;\n+        byte res = zeroValue();\n@@ -4428,1 +4690,1 @@\n-        byte res = (byte) 0;\n+        byte res = zeroValue();\n@@ -4442,1 +4704,1 @@\n-        byte ra = (byte) 0;\n+        byte ra = zeroValue();\n@@ -4452,1 +4714,1 @@\n-            ra = (byte) 0;\n+            ra = zeroValue();\n@@ -4512,1 +4774,1 @@\n-        byte res = 0;\n+        byte res = zeroValue();\n@@ -4521,1 +4783,1 @@\n-        byte res = 0;\n+        byte res = zeroValue();\n@@ -4533,1 +4795,1 @@\n-        byte ra = 0;\n+        byte ra = zeroValue();\n@@ -4543,1 +4805,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4555,1 +4817,1 @@\n-        byte res = 0;\n+        byte res = zeroValue();\n@@ -4565,1 +4827,1 @@\n-        byte res = 0;\n+        byte res = zeroValue();\n@@ -4578,1 +4840,1 @@\n-        byte ra = 0;\n+        byte ra = zeroValue();\n@@ -4588,1 +4850,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4633,1 +4895,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -4653,1 +4915,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -4674,1 +4936,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -4694,1 +4956,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -4713,1 +4975,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4732,1 +4994,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4755,1 +5017,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -4774,1 +5036,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -4797,1 +5059,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -4816,1 +5078,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4835,1 +5097,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4858,1 +5120,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -4877,1 +5139,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -4900,1 +5162,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -4919,1 +5181,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -4942,1 +5204,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -4961,1 +5223,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -4984,1 +5246,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -5003,1 +5265,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n@@ -5026,1 +5288,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n@@ -5045,1 +5307,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n@@ -5068,1 +5330,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -5087,1 +5349,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n@@ -5110,1 +5372,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n@@ -5129,1 +5391,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n@@ -5152,1 +5414,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n@@ -5169,1 +5431,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -5189,1 +5451,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -5205,1 +5467,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < (byte)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (byte)((long)b[i])));\n@@ -5225,1 +5487,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < (byte)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(byte)((long)b[i]))));\n@@ -5241,1 +5503,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -5261,1 +5523,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -5277,1 +5539,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == (byte)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (byte)((long)b[i])));\n@@ -5297,1 +5559,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == (byte)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(byte)((long)b[i]))));\n@@ -5578,1 +5840,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -6009,1 +6271,1 @@\n-        return (byte)(-((byte)a));\n+        return (byte)(scalar_neg((byte)a));\n@@ -6013,1 +6275,1 @@\n-        return (byte)(-((byte)a));\n+        return (byte)(scalar_neg((byte)a));\n@@ -6065,1 +6327,1 @@\n-        return (byte)(Math.abs((byte)a));\n+        return (byte)(scalar_abs((byte)a));\n@@ -6069,1 +6331,1 @@\n-        return (byte)(Math.abs((byte)a));\n+        return (byte)(scalar_abs((byte)a));\n@@ -6409,1 +6671,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -6425,1 +6687,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -6532,1 +6794,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6573,1 +6835,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6676,1 +6938,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -6704,1 +6966,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -6718,1 +6980,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -6915,1 +7177,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -6942,1 +7204,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6956,1 +7218,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6978,1 +7240,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -6986,1 +7248,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -6993,1 +7255,1 @@\n-        Assert.assertEquals(elsize, Byte.SIZE);\n+        AssertEquals(elsize, Byte.SIZE);\n@@ -7012,1 +7274,1 @@\n-    static void ElementTypeByteMaxVectorTestsSmokeTest() {\n+    static void ByteByteMaxVectorTestsSmokeTest() {\n@@ -7047,1 +7309,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":593,"deletions":331,"binary":false,"changes":924,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,39 @@\n+    static DoubleVector bcast_vec = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(double actual, double expected, double delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(double actual, double expected, double delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(double [] actual, double [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double [] actual, double [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -92,1 +131,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -95,1 +134,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -107,1 +146,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -113,1 +152,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -123,1 +162,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -126,1 +165,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -148,1 +187,1 @@\n-            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);\n+            AssertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);\n@@ -150,1 +189,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);\n+                AssertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);\n@@ -153,2 +192,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, \"at index #\" + i);\n@@ -176,1 +215,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n+            AssertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -178,2 +217,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n-relativeError));\n+                AssertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError));\n@@ -182,2 +220,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -199,1 +237,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -201,1 +239,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -204,2 +242,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -221,1 +259,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -223,1 +261,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -226,2 +264,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -239,1 +277,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -242,1 +280,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -254,1 +292,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -257,1 +295,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -266,1 +304,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -271,1 +309,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -282,1 +320,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -287,1 +325,1 @@\n-                    Assert.assertEquals(r[i + k], (double)0);\n+                    AssertEquals(r[i + k], (double)0);\n@@ -293,1 +331,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -295,1 +333,1 @@\n-                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (double)0, \"at index #\" + idx);\n@@ -307,1 +345,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -310,1 +348,1 @@\n-                        Assert.assertEquals(r[i + j], (double)0);\n+                        AssertEquals(r[i + j], (double)0);\n@@ -317,1 +355,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -319,1 +357,1 @@\n-                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (double)0, \"at index #\" + idx);\n@@ -335,1 +373,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -339,1 +377,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -345,0 +383,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -348,1 +387,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -352,2 +393,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -363,1 +403,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -365,1 +405,1 @@\n-                         Assert.assertEquals(r[i+j], (double)0);\n+                         AssertEquals(r[i+j], (double)0);\n@@ -371,1 +411,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -373,1 +413,1 @@\n-                Assert.assertEquals(r[i+j], (double)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (double)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -379,0 +419,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -382,0 +423,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -383,1 +426,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -385,1 +428,1 @@\n-                         Assert.assertEquals(r[i+j], (double)0);\n+                         AssertEquals(r[i+j], (double)0);\n@@ -389,1 +432,0 @@\n-            int idx = i + j;\n@@ -391,1 +433,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -393,1 +435,1 @@\n-                Assert.assertEquals(r[i+j], (double)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (double)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -407,1 +449,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -410,1 +452,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -431,1 +473,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -434,1 +476,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -437,1 +479,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -440,3 +482,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -457,1 +499,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -460,1 +502,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -463,1 +505,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -466,3 +508,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -476,1 +518,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -479,1 +521,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -487,1 +529,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -490,1 +532,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -498,1 +540,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -501,1 +543,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -510,1 +552,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -513,1 +555,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -526,1 +568,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -529,1 +571,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -541,1 +583,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -544,1 +586,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -556,1 +598,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -559,1 +601,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -574,1 +616,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -577,1 +619,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -590,1 +632,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -594,1 +636,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -608,1 +650,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -612,1 +654,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -634,1 +676,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -638,1 +680,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -652,1 +694,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -656,1 +698,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -676,1 +718,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -679,1 +721,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -691,1 +733,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -694,1 +736,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -703,1 +745,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -706,1 +748,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -716,1 +758,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -719,1 +761,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -735,1 +777,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -739,1 +781,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -756,1 +798,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -760,1 +802,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -771,1 +813,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -775,1 +817,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -792,1 +834,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -796,1 +838,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -849,1 +891,1 @@\n-            Assert.assertTrue(Double.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(Double.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n@@ -888,1 +930,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -894,1 +936,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -915,1 +957,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -921,1 +963,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -936,1 +978,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -942,1 +984,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -963,1 +1005,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -969,1 +1011,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -983,1 +1025,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -989,1 +1031,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1004,1 +1046,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1010,1 +1052,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1025,1 +1067,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1031,1 +1073,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1047,1 +1089,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1053,1 +1095,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1061,0 +1103,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -1077,1 +1123,1 @@\n-            withToString(\"double[-i * 5]\", (int s) -> {\n+            withToString(\"Double[-i * 5]\", (int s) -> {\n@@ -1079,1 +1125,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1081,1 +1127,1 @@\n-            withToString(\"double[i * 5]\", (int s) -> {\n+            withToString(\"Double[i * 5]\", (int s) -> {\n@@ -1083,1 +1129,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1085,1 +1131,1 @@\n-            withToString(\"double[i + 1]\", (int s) -> {\n+            withToString(\"Double[i + 1]\", (int s) -> {\n@@ -1087,1 +1133,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1089,1 +1135,1 @@\n-            withToString(\"double[intCornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Double[intCornerCaseValue(i)]\", (int s) -> {\n@@ -1099,1 +1145,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -1102,1 +1148,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1121,0 +1167,4 @@\n+    static double genValue(long i) {\n+        return (double) i;\n+    }\n+\n@@ -1122,1 +1172,1 @@\n-            withToString(\"double[-i * 5]\", (int s) -> {\n+            withToString(\"Double[-i * 5]\", (int s) -> {\n@@ -1124,1 +1174,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1126,1 +1176,1 @@\n-            withToString(\"double[i * 5]\", (int s) -> {\n+            withToString(\"Double[i * 5]\", (int s) -> {\n@@ -1128,1 +1178,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1130,1 +1180,1 @@\n-            withToString(\"double[i + 1]\", (int s) -> {\n+            withToString(\"Double[i + 1]\", (int s) -> {\n@@ -1132,1 +1182,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1134,1 +1184,1 @@\n-            withToString(\"double[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Double[cornerCaseValue(i)]\", (int s) -> {\n@@ -1145,1 +1195,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -1148,1 +1198,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1153,1 +1203,1 @@\n-        return  Double.doubleToLongBits(e);\n+        return Double.doubleToLongBits(e);\n@@ -1157,1 +1207,1 @@\n-            withToString(\"double[-i * 5]\", (int s) -> {\n+            withToString(\"Double[-i * 5]\", (int s) -> {\n@@ -1159,1 +1209,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1161,1 +1211,1 @@\n-            withToString(\"double[i * 5]\", (int s) -> {\n+            withToString(\"Double[i * 5]\", (int s) -> {\n@@ -1163,1 +1213,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1165,1 +1215,1 @@\n-            withToString(\"double[i + 1]\", (int s) -> {\n+            withToString(\"Double[i + 1]\", (int s) -> {\n@@ -1167,1 +1217,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1171,1 +1221,1 @@\n-                            i -> (double)0.01 + ((double)i \/ (i + 1)));\n+                            i -> ((double)0.01 + ((double)i \/ (i + 1))));\n@@ -1175,1 +1225,1 @@\n-                            i -> i % 17 == 0 ? cornerCaseValue(i) : (double)0.01 + ((double)i \/ (i + 1)));\n+                            i -> (i % 17 == 0) ? cornerCaseValue(i) : ((double)0.01 + ((double)i \/ (i + 1))));\n@@ -1499,0 +1549,219 @@\n+    static double multiplicativeIdentity() {\n+        return (double)1;\n+    }\n+\n+\n+    static double scalar_add(double a, double b) {\n+        return (double)(a + b);\n+    }\n+\n+    static double scalar_sub(double a, double b) {\n+        return (double)(a - b);\n+    }\n+\n+    static double scalar_mul(double a, double b) {\n+        return (double)(a * b);\n+    }\n+\n+    static double scalar_min(double a, double b) {\n+        return (double)(Math.min(a, b));\n+    }\n+\n+    static double scalar_max(double a, double b) {\n+        return (double)(Math.max(a, b));\n+    }\n+\n+    static double scalar_div(double a, double b) {\n+        return (double)(a \/ b);\n+    }\n+\n+    static double scalar_fma(double a, double b, double c) {\n+        return (double)(Math.fma(a, b, c));\n+    }\n+\n+    static double scalar_abs(double a) {\n+        return (double)(Math.abs(a));\n+    }\n+\n+    static double scalar_neg(double a) {\n+        return ((double)-a);\n+    }\n+\n+    static double scalar_sin(double a) {\n+        return (double)Math.sin((double)a);\n+    }\n+\n+    static double scalar_exp(double a) {\n+        return (double)Math.exp((double)a);\n+    }\n+\n+    static double scalar_log1p(double a) {\n+        return (double)Math.log1p((double)a);\n+    }\n+\n+    static double scalar_log(double a) {\n+        return (double)Math.log((double)a);\n+    }\n+\n+    static double scalar_log10(double a) {\n+        return (double)Math.log10((double)a);\n+    }\n+\n+    static double scalar_expm1(double a) {\n+        return (double)Math.expm1((double)a);\n+    }\n+\n+    static double scalar_cos(double a) {\n+        return (double)Math.cos((double)a);\n+    }\n+\n+    static double scalar_tan(double a) {\n+        return (double)Math.tan((double)a);\n+    }\n+\n+    static double scalar_sinh(double a) {\n+        return (double)Math.sinh((double)a);\n+    }\n+\n+    static double scalar_cosh(double a) {\n+        return (double)Math.cosh((double)a);\n+    }\n+\n+    static double scalar_tanh(double a) {\n+        return (double)Math.tanh((double)a);\n+    }\n+\n+    static double scalar_asin(double a) {\n+        return (double)Math.asin((double)a);\n+    }\n+\n+    static double scalar_acos(double a) {\n+        return (double)Math.acos((double)a);\n+    }\n+\n+    static double scalar_atan(double a) {\n+        return (double)Math.atan((double)a);\n+    }\n+\n+    static double scalar_cbrt(double a) {\n+        return (double)Math.cbrt((double)a);\n+    }\n+\n+    static double scalar_sqrt(double a) {\n+        return (double)Math.sqrt((double)a);\n+    }\n+\n+    static double scalar_hypot(double a, double b) {\n+        return (double)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static double scalar_pow(double a, double b) {\n+        return (double)Math.pow((double)a, (double)b);\n+    }\n+\n+    static double scalar_atan2(double a, double b) {\n+        return (double)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static double strict_scalar_sin(double a) {\n+        return (double)StrictMath.sin((double)a);\n+    }\n+\n+    static double strict_scalar_exp(double a) {\n+        return (double)StrictMath.exp((double)a);\n+    }\n+\n+    static double strict_scalar_log1p(double a) {\n+        return (double)StrictMath.log1p((double)a);\n+    }\n+\n+    static double strict_scalar_log(double a) {\n+        return (double)StrictMath.log((double)a);\n+    }\n+\n+    static double strict_scalar_log10(double a) {\n+        return (double)StrictMath.log10((double)a);\n+    }\n+\n+    static double strict_scalar_expm1(double a) {\n+        return (double)StrictMath.expm1((double)a);\n+    }\n+\n+    static double strict_scalar_cos(double a) {\n+        return (double)StrictMath.cos((double)a);\n+    }\n+\n+    static double strict_scalar_tan(double a) {\n+        return (double)StrictMath.tan((double)a);\n+    }\n+\n+    static double strict_scalar_sinh(double a) {\n+        return (double)StrictMath.sinh((double)a);\n+    }\n+\n+    static double strict_scalar_cosh(double a) {\n+        return (double)StrictMath.cosh((double)a);\n+    }\n+\n+    static double strict_scalar_tanh(double a) {\n+        return (double)StrictMath.tanh((double)a);\n+    }\n+\n+    static double strict_scalar_asin(double a) {\n+        return (double)StrictMath.asin((double)a);\n+    }\n+\n+    static double strict_scalar_acos(double a) {\n+        return (double)StrictMath.acos((double)a);\n+    }\n+\n+    static double strict_scalar_atan(double a) {\n+        return (double)StrictMath.atan((double)a);\n+    }\n+\n+    static double strict_scalar_cbrt(double a) {\n+        return (double)StrictMath.cbrt((double)a);\n+    }\n+\n+    static double strict_scalar_sqrt(double a) {\n+        return (double)StrictMath.sqrt((double)a);\n+    }\n+\n+    static double strict_scalar_hypot(double a, double b) {\n+        return (double)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static double strict_scalar_pow(double a, double b) {\n+        return (double)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static double strict_scalar_atan2(double a, double b) {\n+        return (double)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static double additiveIdentity() {\n+        return (double)0;\n+    }\n+\n+\n+    static double zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static double maxValue() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    static double minValue() {\n+        return Double.NEGATIVE_INFINITY;\n+    }\n+\n+    static boolean isNaN(double a) {\n+        return Double.isNaN(a);\n+    }\n+    static boolean isFinite(double a) {\n+        return Double.isFinite(a);\n+    }\n+    static boolean isInfinite(double a) {\n+        return Double.isInfinite(a);\n+    }\n+\n@@ -1536,1 +1805,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1551,1 +1820,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1557,1 +1826,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1563,1 +1832,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1580,3 +1849,3 @@\n-        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n-        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n-        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+        AssertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        AssertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n@@ -1588,1 +1857,1 @@\n-        Assert.assertEquals(asFloating.species(), SPECIES);\n+        AssertEquals(asFloating.species(), SPECIES);\n@@ -1592,1 +1861,1 @@\n-        return (double)(a + b);\n+        return (double)(scalar_add(a, b));\n@@ -1613,1 +1882,1 @@\n-        return (double)(a + b);\n+        return (double)(scalar_add(a, b));\n@@ -1670,1 +1939,1 @@\n-        return (double)(a - b);\n+        return (double)(scalar_sub(a, b));\n@@ -1691,1 +1960,1 @@\n-        return (double)(a - b);\n+        return (double)(scalar_sub(a, b));\n@@ -1748,1 +2017,1 @@\n-        return (double)(a * b);\n+        return (double)(scalar_mul(a, b));\n@@ -1769,1 +2038,1 @@\n-        return (double)(a * b);\n+        return (double)(scalar_mul(a, b));\n@@ -1826,1 +2095,1 @@\n-        return (double)(a \/ b);\n+        return (double)(scalar_div(a, b));\n@@ -1847,1 +2116,1 @@\n-        return (double)(a \/ b);\n+        return (double)(scalar_div(a, b));\n@@ -1904,1 +2173,1 @@\n-        return (double)(Double.doubleToLongBits(a)!=0?a:b);\n+        return (double)(firstNonZero(a, b));\n@@ -2099,2 +2368,0 @@\n-    static DoubleVector bv_MIN = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2109,1 +2376,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -2116,2 +2383,0 @@\n-    static DoubleVector bv_min = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2126,1 +2391,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -2133,2 +2398,0 @@\n-    static DoubleVector bv_MIN_M = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2145,1 +2408,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -2152,2 +2415,0 @@\n-    static DoubleVector bv_MAX = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2162,1 +2423,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -2169,2 +2430,0 @@\n-    static DoubleVector bv_max = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2179,1 +2438,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -2186,2 +2445,0 @@\n-    static DoubleVector bv_MAX_M = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2198,1 +2455,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -2206,1 +2463,1 @@\n-        return (double)(Math.min(a, b));\n+        return (double)(scalar_min(a, b));\n@@ -2227,1 +2484,1 @@\n-        return (double)(Math.min(a, b));\n+        return (double)(scalar_min(a, b));\n@@ -2246,1 +2503,1 @@\n-        return (double)(Math.max(a, b));\n+        return (double)(scalar_max(a, b));\n@@ -2267,1 +2524,1 @@\n-        return (double)(Math.max(a, b));\n+        return (double)(scalar_max(a, b));\n@@ -2342,1 +2599,1 @@\n-        double res = 0;\n+        double res = additiveIdentity();\n@@ -2344,1 +2601,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -2351,1 +2608,1 @@\n-        double res = 0;\n+        double res = additiveIdentity();\n@@ -2353,1 +2610,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -2363,1 +2620,1 @@\n-        double ra = 0;\n+        double ra = additiveIdentity();\n@@ -2373,1 +2630,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -2376,1 +2633,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -2385,1 +2642,1 @@\n-        double res = 0;\n+        double res = additiveIdentity();\n@@ -2388,1 +2645,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -2395,1 +2652,1 @@\n-        double res = 0;\n+        double res = additiveIdentity();\n@@ -2397,1 +2654,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -2409,1 +2666,1 @@\n-        double ra = 0;\n+        double ra = additiveIdentity();\n@@ -2419,1 +2676,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -2422,1 +2679,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -2431,1 +2688,1 @@\n-        double res = 1;\n+        double res = multiplicativeIdentity();\n@@ -2433,1 +2690,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -2440,1 +2697,1 @@\n-        double res = 1;\n+        double res = multiplicativeIdentity();\n@@ -2442,1 +2699,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -2452,1 +2709,1 @@\n-        double ra = 1;\n+        double ra = multiplicativeIdentity();\n@@ -2462,1 +2719,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -2465,1 +2722,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -2474,1 +2731,1 @@\n-        double res = 1;\n+        double res = multiplicativeIdentity();\n@@ -2477,1 +2734,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -2484,1 +2741,1 @@\n-        double res = 1;\n+        double res = multiplicativeIdentity();\n@@ -2486,1 +2743,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -2498,1 +2755,1 @@\n-        double ra = 1;\n+        double ra = multiplicativeIdentity();\n@@ -2508,1 +2765,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -2511,1 +2768,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -2520,1 +2777,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = maxValue();\n@@ -2522,1 +2779,1 @@\n-            res = (double) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -2529,1 +2786,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = maxValue();\n@@ -2531,1 +2788,1 @@\n-            res = (double) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -2541,1 +2798,1 @@\n-        double ra = Double.POSITIVE_INFINITY;\n+        double ra = maxValue();\n@@ -2551,1 +2808,1 @@\n-            ra = Double.POSITIVE_INFINITY;\n+            ra = maxValue();\n@@ -2554,1 +2811,1 @@\n-                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -2563,1 +2820,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = maxValue();\n@@ -2566,1 +2823,1 @@\n-                res = (double) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -2573,1 +2830,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = maxValue();\n@@ -2575,1 +2832,1 @@\n-            res = (double) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -2587,1 +2844,1 @@\n-        double ra = Double.POSITIVE_INFINITY;\n+        double ra = maxValue();\n@@ -2597,1 +2854,1 @@\n-            ra = Double.POSITIVE_INFINITY;\n+            ra = maxValue();\n@@ -2600,1 +2857,1 @@\n-                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -2609,1 +2866,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = minValue();\n@@ -2611,1 +2868,1 @@\n-            res = (double) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -2618,1 +2875,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = minValue();\n@@ -2620,1 +2877,1 @@\n-            res = (double) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -2630,1 +2887,1 @@\n-        double ra = Double.NEGATIVE_INFINITY;\n+        double ra = minValue();\n@@ -2640,1 +2897,1 @@\n-            ra = Double.NEGATIVE_INFINITY;\n+            ra = minValue();\n@@ -2643,1 +2900,1 @@\n-                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -2652,1 +2909,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = minValue();\n@@ -2655,1 +2912,1 @@\n-                res = (double) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -2662,1 +2919,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = minValue();\n@@ -2664,1 +2921,1 @@\n-            res = (double) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -2676,1 +2933,1 @@\n-        double ra = Double.NEGATIVE_INFINITY;\n+        double ra = minValue();\n@@ -2686,1 +2943,1 @@\n-            ra = Double.NEGATIVE_INFINITY;\n+            ra = minValue();\n@@ -2689,1 +2946,1 @@\n-                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -2698,1 +2955,1 @@\n-        double res = (double) 0;\n+        double res = zeroValue();\n@@ -2707,1 +2964,1 @@\n-        double res = (double) 0;\n+        double res = zeroValue();\n@@ -2719,1 +2976,1 @@\n-        double ra = (double) 0;\n+        double ra = zeroValue();\n@@ -2729,1 +2986,1 @@\n-            ra = (double) 0;\n+            ra = zeroValue();\n@@ -2741,1 +2998,1 @@\n-        double res = (double) 0;\n+        double res = zeroValue();\n@@ -2751,1 +3008,1 @@\n-        double res = (double) 0;\n+        double res = zeroValue();\n@@ -2765,1 +3022,1 @@\n-        double ra = (double) 0;\n+        double ra = zeroValue();\n@@ -2775,1 +3032,1 @@\n-            ra = (double) 0;\n+            ra = zeroValue();\n@@ -2820,1 +3077,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -2840,1 +3097,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -2861,1 +3118,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -2881,1 +3138,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -2888,1 +3145,1 @@\n-        return Double.isFinite(a);\n+        return isFinite(a);\n@@ -2902,1 +3159,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_FINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_FINITE(a[i + j]));\n@@ -2922,1 +3179,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n@@ -2929,1 +3186,1 @@\n-        return Double.isNaN(a);\n+        return isNaN(a);\n@@ -2943,1 +3200,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NAN(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NAN(a[i + j]));\n@@ -2963,1 +3220,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n@@ -2970,1 +3227,1 @@\n-        return Double.isInfinite(a);\n+        return isInfinite(a);\n@@ -2984,1 +3241,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_INFINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_INFINITE(a[i + j]));\n@@ -3004,1 +3261,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n@@ -3023,1 +3280,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3042,1 +3299,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3065,1 +3322,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3084,1 +3341,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3107,1 +3364,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3126,1 +3383,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3145,1 +3402,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3168,1 +3425,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3187,1 +3444,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3210,1 +3467,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3229,1 +3486,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3252,1 +3509,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3271,1 +3528,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3294,1 +3551,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -3311,1 +3568,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -3331,1 +3588,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -3347,1 +3604,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < (double)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (double)((long)b[i])));\n@@ -3367,1 +3624,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < (double)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(double)((long)b[i]))));\n@@ -3383,1 +3640,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -3403,1 +3660,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -3419,1 +3676,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == (double)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (double)((long)b[i])));\n@@ -3439,1 +3696,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == (double)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(double)((long)b[i]))));\n@@ -3720,1 +3977,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -3939,1 +4196,1 @@\n-        return (double)(Math.sin((double)a));\n+        return (double)(scalar_sin(a));\n@@ -3943,1 +4200,1 @@\n-        return (double)(StrictMath.sin((double)a));\n+        return (double)(strict_scalar_sin(a));\n@@ -3962,1 +4219,1 @@\n-        return (double)(Math.exp((double)a));\n+        return (double)(scalar_exp(a));\n@@ -3966,1 +4223,1 @@\n-        return (double)(StrictMath.exp((double)a));\n+        return (double)(strict_scalar_exp(a));\n@@ -3985,1 +4242,1 @@\n-        return (double)(Math.log1p((double)a));\n+        return (double)(scalar_log1p(a));\n@@ -3989,1 +4246,1 @@\n-        return (double)(StrictMath.log1p((double)a));\n+        return (double)(strict_scalar_log1p(a));\n@@ -4008,1 +4265,1 @@\n-        return (double)(Math.log((double)a));\n+        return (double)(scalar_log(a));\n@@ -4012,1 +4269,1 @@\n-        return (double)(StrictMath.log((double)a));\n+        return (double)(strict_scalar_log(a));\n@@ -4031,1 +4288,1 @@\n-        return (double)(Math.log10((double)a));\n+        return (double)(scalar_log10(a));\n@@ -4035,1 +4292,1 @@\n-        return (double)(StrictMath.log10((double)a));\n+        return (double)(strict_scalar_log10(a));\n@@ -4054,1 +4311,1 @@\n-        return (double)(Math.expm1((double)a));\n+        return (double)(scalar_expm1(a));\n@@ -4058,1 +4315,1 @@\n-        return (double)(StrictMath.expm1((double)a));\n+        return (double)(strict_scalar_expm1(a));\n@@ -4077,1 +4334,1 @@\n-        return (double)(Math.cos((double)a));\n+        return (double)(scalar_cos(a));\n@@ -4081,1 +4338,1 @@\n-        return (double)(StrictMath.cos((double)a));\n+        return (double)(strict_scalar_cos(a));\n@@ -4100,1 +4357,1 @@\n-        return (double)(Math.tan((double)a));\n+        return (double)(scalar_tan(a));\n@@ -4104,1 +4361,1 @@\n-        return (double)(StrictMath.tan((double)a));\n+        return (double)(strict_scalar_tan(a));\n@@ -4123,1 +4380,1 @@\n-        return (double)(Math.sinh((double)a));\n+        return (double)(scalar_sinh(a));\n@@ -4127,1 +4384,1 @@\n-        return (double)(StrictMath.sinh((double)a));\n+        return (double)(strict_scalar_sinh(a));\n@@ -4146,1 +4403,1 @@\n-        return (double)(Math.cosh((double)a));\n+        return (double)(scalar_cosh(a));\n@@ -4150,1 +4407,1 @@\n-        return (double)(StrictMath.cosh((double)a));\n+        return (double)(strict_scalar_cosh(a));\n@@ -4169,1 +4426,1 @@\n-        return (double)(Math.tanh((double)a));\n+        return (double)(scalar_tanh(a));\n@@ -4173,1 +4430,1 @@\n-        return (double)(StrictMath.tanh((double)a));\n+        return (double)(strict_scalar_tanh(a));\n@@ -4192,1 +4449,1 @@\n-        return (double)(Math.asin((double)a));\n+        return (double)(scalar_asin(a));\n@@ -4196,1 +4453,1 @@\n-        return (double)(StrictMath.asin((double)a));\n+        return (double)(strict_scalar_asin(a));\n@@ -4215,1 +4472,1 @@\n-        return (double)(Math.acos((double)a));\n+        return (double)(scalar_acos(a));\n@@ -4219,1 +4476,1 @@\n-        return (double)(StrictMath.acos((double)a));\n+        return (double)(strict_scalar_acos(a));\n@@ -4238,1 +4495,1 @@\n-        return (double)(Math.atan((double)a));\n+        return (double)(scalar_atan(a));\n@@ -4242,1 +4499,1 @@\n-        return (double)(StrictMath.atan((double)a));\n+        return (double)(strict_scalar_atan(a));\n@@ -4261,1 +4518,1 @@\n-        return (double)(Math.cbrt((double)a));\n+        return (double)(scalar_cbrt(a));\n@@ -4265,1 +4522,1 @@\n-        return (double)(StrictMath.cbrt((double)a));\n+        return (double)(strict_scalar_cbrt(a));\n@@ -4284,1 +4541,1 @@\n-        return (double)(Math.hypot((double)a, (double)b));\n+        return (double)(scalar_hypot(a, b));\n@@ -4288,1 +4545,1 @@\n-        return (double)(StrictMath.hypot((double)a, (double)b));\n+        return (double)(strict_scalar_hypot(a, b));\n@@ -4310,1 +4567,1 @@\n-        return (double)(Math.pow((double)a, (double)b));\n+        return (double)(scalar_pow(a, b));\n@@ -4314,1 +4571,1 @@\n-        return (double)(StrictMath.pow((double)a, (double)b));\n+        return (double)(strict_scalar_pow(a, b));\n@@ -4336,1 +4593,1 @@\n-        return (double)(Math.pow((double)a, (double)b));\n+        return (double)(scalar_pow(a, b));\n@@ -4340,1 +4597,1 @@\n-        return (double)(StrictMath.pow((double)a, (double)b));\n+        return (double)(strict_scalar_pow(a, b));\n@@ -4362,1 +4619,1 @@\n-        return (double)(Math.atan2((double)a, (double)b));\n+        return (double)(scalar_atan2(a, b));\n@@ -4366,1 +4623,1 @@\n-        return (double)(StrictMath.atan2((double)a, (double)b));\n+        return (double)(strict_scalar_atan2(a, b));\n@@ -4418,1 +4675,1 @@\n-        return (double)(Math.fma(a, b, c));\n+        return (double)(scalar_fma(a, b, c));\n@@ -4422,1 +4679,1 @@\n-        return (double)(Math.fma(a, b, c));\n+        return (double)(scalar_fma(a, b, c));\n@@ -4642,1 +4899,1 @@\n-        return (double)(-((double)a));\n+        return (double)(scalar_neg((double)a));\n@@ -4646,1 +4903,1 @@\n-        return (double)(-((double)a));\n+        return (double)(scalar_neg((double)a));\n@@ -4698,1 +4955,1 @@\n-        return (double)(Math.abs((double)a));\n+        return (double)(scalar_abs((double)a));\n@@ -4702,1 +4959,1 @@\n-        return (double)(Math.abs((double)a));\n+        return (double)(scalar_abs((double)a));\n@@ -4754,1 +5011,1 @@\n-        return (double)(Math.sqrt((double)a));\n+        return (double)(scalar_sqrt(a));\n@@ -4758,1 +5015,1 @@\n-        return (double)(Math.sqrt((double)a));\n+        return (double)(scalar_sqrt(a));\n@@ -4820,1 +5077,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -4836,1 +5093,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -4922,1 +5179,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -4963,1 +5220,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -5066,1 +5323,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -5094,1 +5351,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -5108,1 +5365,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -5305,1 +5562,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -5325,1 +5582,1 @@\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5348,1 +5605,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -5362,1 +5619,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -5384,1 +5641,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -5392,1 +5649,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -5399,1 +5656,1 @@\n-        Assert.assertEquals(elsize, Double.SIZE);\n+        AssertEquals(elsize, Double.SIZE);\n@@ -5418,1 +5675,1 @@\n-    static void ElementTypeDouble128VectorTestsSmokeTest() {\n+    static void DoubleDouble128VectorTestsSmokeTest() {\n@@ -5453,1 +5710,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":608,"deletions":351,"binary":false,"changes":959,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,39 @@\n+    static DoubleVector bcast_vec = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(double actual, double expected, double delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(double actual, double expected, double delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(double [] actual, double [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double [] actual, double [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -92,1 +131,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -95,1 +134,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -107,1 +146,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -113,1 +152,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -123,1 +162,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -126,1 +165,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -148,1 +187,1 @@\n-            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);\n+            AssertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);\n@@ -150,1 +189,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);\n+                AssertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);\n@@ -153,2 +192,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, \"at index #\" + i);\n@@ -176,1 +215,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n+            AssertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -178,2 +217,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n-relativeError));\n+                AssertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError));\n@@ -182,2 +220,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -199,1 +237,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -201,1 +239,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -204,2 +242,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -221,1 +259,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -223,1 +261,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -226,2 +264,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -239,1 +277,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -242,1 +280,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -254,1 +292,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -257,1 +295,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -266,1 +304,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -271,1 +309,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -282,1 +320,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -287,1 +325,1 @@\n-                    Assert.assertEquals(r[i + k], (double)0);\n+                    AssertEquals(r[i + k], (double)0);\n@@ -293,1 +331,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -295,1 +333,1 @@\n-                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (double)0, \"at index #\" + idx);\n@@ -307,1 +345,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -310,1 +348,1 @@\n-                        Assert.assertEquals(r[i + j], (double)0);\n+                        AssertEquals(r[i + j], (double)0);\n@@ -317,1 +355,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -319,1 +357,1 @@\n-                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (double)0, \"at index #\" + idx);\n@@ -335,1 +373,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -339,1 +377,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -345,0 +383,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -348,1 +387,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -352,2 +393,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -363,1 +403,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -365,1 +405,1 @@\n-                         Assert.assertEquals(r[i+j], (double)0);\n+                         AssertEquals(r[i+j], (double)0);\n@@ -371,1 +411,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -373,1 +413,1 @@\n-                Assert.assertEquals(r[i+j], (double)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (double)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -379,0 +419,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -382,0 +423,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -383,1 +426,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -385,1 +428,1 @@\n-                         Assert.assertEquals(r[i+j], (double)0);\n+                         AssertEquals(r[i+j], (double)0);\n@@ -389,1 +432,0 @@\n-            int idx = i + j;\n@@ -391,1 +433,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -393,1 +435,1 @@\n-                Assert.assertEquals(r[i+j], (double)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (double)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -407,1 +449,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -410,1 +452,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -431,1 +473,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -434,1 +476,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -437,1 +479,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -440,3 +482,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -457,1 +499,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -460,1 +502,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -463,1 +505,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -466,3 +508,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -476,1 +518,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -479,1 +521,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -487,1 +529,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -490,1 +532,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -498,1 +540,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -501,1 +543,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -510,1 +552,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -513,1 +555,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -526,1 +568,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -529,1 +571,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -541,1 +583,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -544,1 +586,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -556,1 +598,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -559,1 +601,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -574,1 +616,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -577,1 +619,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -590,1 +632,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -594,1 +636,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -608,1 +650,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -612,1 +654,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -634,1 +676,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -638,1 +680,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -652,1 +694,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -656,1 +698,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -676,1 +718,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -679,1 +721,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -691,1 +733,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -694,1 +736,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -703,1 +745,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -706,1 +748,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -716,1 +758,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -719,1 +761,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -735,1 +777,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -739,1 +781,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -756,1 +798,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -760,1 +802,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -771,1 +813,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -775,1 +817,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -792,1 +834,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -796,1 +838,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -849,1 +891,1 @@\n-            Assert.assertTrue(Double.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(Double.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n@@ -888,1 +930,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -894,1 +936,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -915,1 +957,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -921,1 +963,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -936,1 +978,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -942,1 +984,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -963,1 +1005,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -969,1 +1011,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -983,1 +1025,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -989,1 +1031,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1004,1 +1046,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1010,1 +1052,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1025,1 +1067,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1031,1 +1073,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1047,1 +1089,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1053,1 +1095,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1061,0 +1103,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -1077,1 +1123,1 @@\n-            withToString(\"double[-i * 5]\", (int s) -> {\n+            withToString(\"Double[-i * 5]\", (int s) -> {\n@@ -1079,1 +1125,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1081,1 +1127,1 @@\n-            withToString(\"double[i * 5]\", (int s) -> {\n+            withToString(\"Double[i * 5]\", (int s) -> {\n@@ -1083,1 +1129,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1085,1 +1131,1 @@\n-            withToString(\"double[i + 1]\", (int s) -> {\n+            withToString(\"Double[i + 1]\", (int s) -> {\n@@ -1087,1 +1133,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1089,1 +1135,1 @@\n-            withToString(\"double[intCornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Double[intCornerCaseValue(i)]\", (int s) -> {\n@@ -1099,1 +1145,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -1102,1 +1148,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1121,0 +1167,4 @@\n+    static double genValue(long i) {\n+        return (double) i;\n+    }\n+\n@@ -1122,1 +1172,1 @@\n-            withToString(\"double[-i * 5]\", (int s) -> {\n+            withToString(\"Double[-i * 5]\", (int s) -> {\n@@ -1124,1 +1174,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1126,1 +1176,1 @@\n-            withToString(\"double[i * 5]\", (int s) -> {\n+            withToString(\"Double[i * 5]\", (int s) -> {\n@@ -1128,1 +1178,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1130,1 +1180,1 @@\n-            withToString(\"double[i + 1]\", (int s) -> {\n+            withToString(\"Double[i + 1]\", (int s) -> {\n@@ -1132,1 +1182,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1134,1 +1184,1 @@\n-            withToString(\"double[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Double[cornerCaseValue(i)]\", (int s) -> {\n@@ -1145,1 +1195,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -1148,1 +1198,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1153,1 +1203,1 @@\n-        return  Double.doubleToLongBits(e);\n+        return Double.doubleToLongBits(e);\n@@ -1157,1 +1207,1 @@\n-            withToString(\"double[-i * 5]\", (int s) -> {\n+            withToString(\"Double[-i * 5]\", (int s) -> {\n@@ -1159,1 +1209,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1161,1 +1211,1 @@\n-            withToString(\"double[i * 5]\", (int s) -> {\n+            withToString(\"Double[i * 5]\", (int s) -> {\n@@ -1163,1 +1213,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1165,1 +1215,1 @@\n-            withToString(\"double[i + 1]\", (int s) -> {\n+            withToString(\"Double[i + 1]\", (int s) -> {\n@@ -1167,1 +1217,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1171,1 +1221,1 @@\n-                            i -> (double)0.01 + ((double)i \/ (i + 1)));\n+                            i -> ((double)0.01 + ((double)i \/ (i + 1))));\n@@ -1175,1 +1225,1 @@\n-                            i -> i % 17 == 0 ? cornerCaseValue(i) : (double)0.01 + ((double)i \/ (i + 1)));\n+                            i -> (i % 17 == 0) ? cornerCaseValue(i) : ((double)0.01 + ((double)i \/ (i + 1))));\n@@ -1499,0 +1549,219 @@\n+    static double multiplicativeIdentity() {\n+        return (double)1;\n+    }\n+\n+\n+    static double scalar_add(double a, double b) {\n+        return (double)(a + b);\n+    }\n+\n+    static double scalar_sub(double a, double b) {\n+        return (double)(a - b);\n+    }\n+\n+    static double scalar_mul(double a, double b) {\n+        return (double)(a * b);\n+    }\n+\n+    static double scalar_min(double a, double b) {\n+        return (double)(Math.min(a, b));\n+    }\n+\n+    static double scalar_max(double a, double b) {\n+        return (double)(Math.max(a, b));\n+    }\n+\n+    static double scalar_div(double a, double b) {\n+        return (double)(a \/ b);\n+    }\n+\n+    static double scalar_fma(double a, double b, double c) {\n+        return (double)(Math.fma(a, b, c));\n+    }\n+\n+    static double scalar_abs(double a) {\n+        return (double)(Math.abs(a));\n+    }\n+\n+    static double scalar_neg(double a) {\n+        return ((double)-a);\n+    }\n+\n+    static double scalar_sin(double a) {\n+        return (double)Math.sin((double)a);\n+    }\n+\n+    static double scalar_exp(double a) {\n+        return (double)Math.exp((double)a);\n+    }\n+\n+    static double scalar_log1p(double a) {\n+        return (double)Math.log1p((double)a);\n+    }\n+\n+    static double scalar_log(double a) {\n+        return (double)Math.log((double)a);\n+    }\n+\n+    static double scalar_log10(double a) {\n+        return (double)Math.log10((double)a);\n+    }\n+\n+    static double scalar_expm1(double a) {\n+        return (double)Math.expm1((double)a);\n+    }\n+\n+    static double scalar_cos(double a) {\n+        return (double)Math.cos((double)a);\n+    }\n+\n+    static double scalar_tan(double a) {\n+        return (double)Math.tan((double)a);\n+    }\n+\n+    static double scalar_sinh(double a) {\n+        return (double)Math.sinh((double)a);\n+    }\n+\n+    static double scalar_cosh(double a) {\n+        return (double)Math.cosh((double)a);\n+    }\n+\n+    static double scalar_tanh(double a) {\n+        return (double)Math.tanh((double)a);\n+    }\n+\n+    static double scalar_asin(double a) {\n+        return (double)Math.asin((double)a);\n+    }\n+\n+    static double scalar_acos(double a) {\n+        return (double)Math.acos((double)a);\n+    }\n+\n+    static double scalar_atan(double a) {\n+        return (double)Math.atan((double)a);\n+    }\n+\n+    static double scalar_cbrt(double a) {\n+        return (double)Math.cbrt((double)a);\n+    }\n+\n+    static double scalar_sqrt(double a) {\n+        return (double)Math.sqrt((double)a);\n+    }\n+\n+    static double scalar_hypot(double a, double b) {\n+        return (double)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static double scalar_pow(double a, double b) {\n+        return (double)Math.pow((double)a, (double)b);\n+    }\n+\n+    static double scalar_atan2(double a, double b) {\n+        return (double)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static double strict_scalar_sin(double a) {\n+        return (double)StrictMath.sin((double)a);\n+    }\n+\n+    static double strict_scalar_exp(double a) {\n+        return (double)StrictMath.exp((double)a);\n+    }\n+\n+    static double strict_scalar_log1p(double a) {\n+        return (double)StrictMath.log1p((double)a);\n+    }\n+\n+    static double strict_scalar_log(double a) {\n+        return (double)StrictMath.log((double)a);\n+    }\n+\n+    static double strict_scalar_log10(double a) {\n+        return (double)StrictMath.log10((double)a);\n+    }\n+\n+    static double strict_scalar_expm1(double a) {\n+        return (double)StrictMath.expm1((double)a);\n+    }\n+\n+    static double strict_scalar_cos(double a) {\n+        return (double)StrictMath.cos((double)a);\n+    }\n+\n+    static double strict_scalar_tan(double a) {\n+        return (double)StrictMath.tan((double)a);\n+    }\n+\n+    static double strict_scalar_sinh(double a) {\n+        return (double)StrictMath.sinh((double)a);\n+    }\n+\n+    static double strict_scalar_cosh(double a) {\n+        return (double)StrictMath.cosh((double)a);\n+    }\n+\n+    static double strict_scalar_tanh(double a) {\n+        return (double)StrictMath.tanh((double)a);\n+    }\n+\n+    static double strict_scalar_asin(double a) {\n+        return (double)StrictMath.asin((double)a);\n+    }\n+\n+    static double strict_scalar_acos(double a) {\n+        return (double)StrictMath.acos((double)a);\n+    }\n+\n+    static double strict_scalar_atan(double a) {\n+        return (double)StrictMath.atan((double)a);\n+    }\n+\n+    static double strict_scalar_cbrt(double a) {\n+        return (double)StrictMath.cbrt((double)a);\n+    }\n+\n+    static double strict_scalar_sqrt(double a) {\n+        return (double)StrictMath.sqrt((double)a);\n+    }\n+\n+    static double strict_scalar_hypot(double a, double b) {\n+        return (double)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static double strict_scalar_pow(double a, double b) {\n+        return (double)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static double strict_scalar_atan2(double a, double b) {\n+        return (double)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static double additiveIdentity() {\n+        return (double)0;\n+    }\n+\n+\n+    static double zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static double maxValue() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    static double minValue() {\n+        return Double.NEGATIVE_INFINITY;\n+    }\n+\n+    static boolean isNaN(double a) {\n+        return Double.isNaN(a);\n+    }\n+    static boolean isFinite(double a) {\n+        return Double.isFinite(a);\n+    }\n+    static boolean isInfinite(double a) {\n+        return Double.isInfinite(a);\n+    }\n+\n@@ -1536,1 +1805,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1551,1 +1820,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1557,1 +1826,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1563,1 +1832,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1580,3 +1849,3 @@\n-        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n-        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n-        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+        AssertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        AssertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n@@ -1588,1 +1857,1 @@\n-        Assert.assertEquals(asFloating.species(), SPECIES);\n+        AssertEquals(asFloating.species(), SPECIES);\n@@ -1592,1 +1861,1 @@\n-        return (double)(a + b);\n+        return (double)(scalar_add(a, b));\n@@ -1613,1 +1882,1 @@\n-        return (double)(a + b);\n+        return (double)(scalar_add(a, b));\n@@ -1670,1 +1939,1 @@\n-        return (double)(a - b);\n+        return (double)(scalar_sub(a, b));\n@@ -1691,1 +1960,1 @@\n-        return (double)(a - b);\n+        return (double)(scalar_sub(a, b));\n@@ -1748,1 +2017,1 @@\n-        return (double)(a * b);\n+        return (double)(scalar_mul(a, b));\n@@ -1769,1 +2038,1 @@\n-        return (double)(a * b);\n+        return (double)(scalar_mul(a, b));\n@@ -1826,1 +2095,1 @@\n-        return (double)(a \/ b);\n+        return (double)(scalar_div(a, b));\n@@ -1847,1 +2116,1 @@\n-        return (double)(a \/ b);\n+        return (double)(scalar_div(a, b));\n@@ -1904,1 +2173,1 @@\n-        return (double)(Double.doubleToLongBits(a)!=0?a:b);\n+        return (double)(firstNonZero(a, b));\n@@ -2099,2 +2368,0 @@\n-    static DoubleVector bv_MIN = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2109,1 +2376,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -2116,2 +2383,0 @@\n-    static DoubleVector bv_min = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2126,1 +2391,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -2133,2 +2398,0 @@\n-    static DoubleVector bv_MIN_M = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2145,1 +2408,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -2152,2 +2415,0 @@\n-    static DoubleVector bv_MAX = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2162,1 +2423,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -2169,2 +2430,0 @@\n-    static DoubleVector bv_max = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2179,1 +2438,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -2186,2 +2445,0 @@\n-    static DoubleVector bv_MAX_M = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2198,1 +2455,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -2206,1 +2463,1 @@\n-        return (double)(Math.min(a, b));\n+        return (double)(scalar_min(a, b));\n@@ -2227,1 +2484,1 @@\n-        return (double)(Math.min(a, b));\n+        return (double)(scalar_min(a, b));\n@@ -2246,1 +2503,1 @@\n-        return (double)(Math.max(a, b));\n+        return (double)(scalar_max(a, b));\n@@ -2267,1 +2524,1 @@\n-        return (double)(Math.max(a, b));\n+        return (double)(scalar_max(a, b));\n@@ -2342,1 +2599,1 @@\n-        double res = 0;\n+        double res = additiveIdentity();\n@@ -2344,1 +2601,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -2351,1 +2608,1 @@\n-        double res = 0;\n+        double res = additiveIdentity();\n@@ -2353,1 +2610,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -2363,1 +2620,1 @@\n-        double ra = 0;\n+        double ra = additiveIdentity();\n@@ -2373,1 +2630,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -2376,1 +2633,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -2385,1 +2642,1 @@\n-        double res = 0;\n+        double res = additiveIdentity();\n@@ -2388,1 +2645,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -2395,1 +2652,1 @@\n-        double res = 0;\n+        double res = additiveIdentity();\n@@ -2397,1 +2654,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -2409,1 +2666,1 @@\n-        double ra = 0;\n+        double ra = additiveIdentity();\n@@ -2419,1 +2676,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -2422,1 +2679,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -2431,1 +2688,1 @@\n-        double res = 1;\n+        double res = multiplicativeIdentity();\n@@ -2433,1 +2690,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -2440,1 +2697,1 @@\n-        double res = 1;\n+        double res = multiplicativeIdentity();\n@@ -2442,1 +2699,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -2452,1 +2709,1 @@\n-        double ra = 1;\n+        double ra = multiplicativeIdentity();\n@@ -2462,1 +2719,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -2465,1 +2722,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -2474,1 +2731,1 @@\n-        double res = 1;\n+        double res = multiplicativeIdentity();\n@@ -2477,1 +2734,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -2484,1 +2741,1 @@\n-        double res = 1;\n+        double res = multiplicativeIdentity();\n@@ -2486,1 +2743,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -2498,1 +2755,1 @@\n-        double ra = 1;\n+        double ra = multiplicativeIdentity();\n@@ -2508,1 +2765,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -2511,1 +2768,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -2520,1 +2777,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = maxValue();\n@@ -2522,1 +2779,1 @@\n-            res = (double) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -2529,1 +2786,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = maxValue();\n@@ -2531,1 +2788,1 @@\n-            res = (double) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -2541,1 +2798,1 @@\n-        double ra = Double.POSITIVE_INFINITY;\n+        double ra = maxValue();\n@@ -2551,1 +2808,1 @@\n-            ra = Double.POSITIVE_INFINITY;\n+            ra = maxValue();\n@@ -2554,1 +2811,1 @@\n-                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -2563,1 +2820,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = maxValue();\n@@ -2566,1 +2823,1 @@\n-                res = (double) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -2573,1 +2830,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = maxValue();\n@@ -2575,1 +2832,1 @@\n-            res = (double) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -2587,1 +2844,1 @@\n-        double ra = Double.POSITIVE_INFINITY;\n+        double ra = maxValue();\n@@ -2597,1 +2854,1 @@\n-            ra = Double.POSITIVE_INFINITY;\n+            ra = maxValue();\n@@ -2600,1 +2857,1 @@\n-                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -2609,1 +2866,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = minValue();\n@@ -2611,1 +2868,1 @@\n-            res = (double) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -2618,1 +2875,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = minValue();\n@@ -2620,1 +2877,1 @@\n-            res = (double) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -2630,1 +2887,1 @@\n-        double ra = Double.NEGATIVE_INFINITY;\n+        double ra = minValue();\n@@ -2640,1 +2897,1 @@\n-            ra = Double.NEGATIVE_INFINITY;\n+            ra = minValue();\n@@ -2643,1 +2900,1 @@\n-                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -2652,1 +2909,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = minValue();\n@@ -2655,1 +2912,1 @@\n-                res = (double) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -2662,1 +2919,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = minValue();\n@@ -2664,1 +2921,1 @@\n-            res = (double) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -2676,1 +2933,1 @@\n-        double ra = Double.NEGATIVE_INFINITY;\n+        double ra = minValue();\n@@ -2686,1 +2943,1 @@\n-            ra = Double.NEGATIVE_INFINITY;\n+            ra = minValue();\n@@ -2689,1 +2946,1 @@\n-                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -2698,1 +2955,1 @@\n-        double res = (double) 0;\n+        double res = zeroValue();\n@@ -2707,1 +2964,1 @@\n-        double res = (double) 0;\n+        double res = zeroValue();\n@@ -2719,1 +2976,1 @@\n-        double ra = (double) 0;\n+        double ra = zeroValue();\n@@ -2729,1 +2986,1 @@\n-            ra = (double) 0;\n+            ra = zeroValue();\n@@ -2741,1 +2998,1 @@\n-        double res = (double) 0;\n+        double res = zeroValue();\n@@ -2751,1 +3008,1 @@\n-        double res = (double) 0;\n+        double res = zeroValue();\n@@ -2765,1 +3022,1 @@\n-        double ra = (double) 0;\n+        double ra = zeroValue();\n@@ -2775,1 +3032,1 @@\n-            ra = (double) 0;\n+            ra = zeroValue();\n@@ -2820,1 +3077,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -2840,1 +3097,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -2861,1 +3118,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -2881,1 +3138,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -2888,1 +3145,1 @@\n-        return Double.isFinite(a);\n+        return isFinite(a);\n@@ -2902,1 +3159,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_FINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_FINITE(a[i + j]));\n@@ -2922,1 +3179,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n@@ -2929,1 +3186,1 @@\n-        return Double.isNaN(a);\n+        return isNaN(a);\n@@ -2943,1 +3200,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NAN(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NAN(a[i + j]));\n@@ -2963,1 +3220,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n@@ -2970,1 +3227,1 @@\n-        return Double.isInfinite(a);\n+        return isInfinite(a);\n@@ -2984,1 +3241,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_INFINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_INFINITE(a[i + j]));\n@@ -3004,1 +3261,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n@@ -3023,1 +3280,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3042,1 +3299,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3065,1 +3322,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3084,1 +3341,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3107,1 +3364,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3126,1 +3383,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3145,1 +3402,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3168,1 +3425,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3187,1 +3444,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3210,1 +3467,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3229,1 +3486,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3252,1 +3509,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3271,1 +3528,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3294,1 +3551,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -3311,1 +3568,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -3331,1 +3588,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -3347,1 +3604,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < (double)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (double)((long)b[i])));\n@@ -3367,1 +3624,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < (double)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(double)((long)b[i]))));\n@@ -3383,1 +3640,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -3403,1 +3660,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -3419,1 +3676,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == (double)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (double)((long)b[i])));\n@@ -3439,1 +3696,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == (double)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(double)((long)b[i]))));\n@@ -3720,1 +3977,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -3939,1 +4196,1 @@\n-        return (double)(Math.sin((double)a));\n+        return (double)(scalar_sin(a));\n@@ -3943,1 +4200,1 @@\n-        return (double)(StrictMath.sin((double)a));\n+        return (double)(strict_scalar_sin(a));\n@@ -3962,1 +4219,1 @@\n-        return (double)(Math.exp((double)a));\n+        return (double)(scalar_exp(a));\n@@ -3966,1 +4223,1 @@\n-        return (double)(StrictMath.exp((double)a));\n+        return (double)(strict_scalar_exp(a));\n@@ -3985,1 +4242,1 @@\n-        return (double)(Math.log1p((double)a));\n+        return (double)(scalar_log1p(a));\n@@ -3989,1 +4246,1 @@\n-        return (double)(StrictMath.log1p((double)a));\n+        return (double)(strict_scalar_log1p(a));\n@@ -4008,1 +4265,1 @@\n-        return (double)(Math.log((double)a));\n+        return (double)(scalar_log(a));\n@@ -4012,1 +4269,1 @@\n-        return (double)(StrictMath.log((double)a));\n+        return (double)(strict_scalar_log(a));\n@@ -4031,1 +4288,1 @@\n-        return (double)(Math.log10((double)a));\n+        return (double)(scalar_log10(a));\n@@ -4035,1 +4292,1 @@\n-        return (double)(StrictMath.log10((double)a));\n+        return (double)(strict_scalar_log10(a));\n@@ -4054,1 +4311,1 @@\n-        return (double)(Math.expm1((double)a));\n+        return (double)(scalar_expm1(a));\n@@ -4058,1 +4315,1 @@\n-        return (double)(StrictMath.expm1((double)a));\n+        return (double)(strict_scalar_expm1(a));\n@@ -4077,1 +4334,1 @@\n-        return (double)(Math.cos((double)a));\n+        return (double)(scalar_cos(a));\n@@ -4081,1 +4338,1 @@\n-        return (double)(StrictMath.cos((double)a));\n+        return (double)(strict_scalar_cos(a));\n@@ -4100,1 +4357,1 @@\n-        return (double)(Math.tan((double)a));\n+        return (double)(scalar_tan(a));\n@@ -4104,1 +4361,1 @@\n-        return (double)(StrictMath.tan((double)a));\n+        return (double)(strict_scalar_tan(a));\n@@ -4123,1 +4380,1 @@\n-        return (double)(Math.sinh((double)a));\n+        return (double)(scalar_sinh(a));\n@@ -4127,1 +4384,1 @@\n-        return (double)(StrictMath.sinh((double)a));\n+        return (double)(strict_scalar_sinh(a));\n@@ -4146,1 +4403,1 @@\n-        return (double)(Math.cosh((double)a));\n+        return (double)(scalar_cosh(a));\n@@ -4150,1 +4407,1 @@\n-        return (double)(StrictMath.cosh((double)a));\n+        return (double)(strict_scalar_cosh(a));\n@@ -4169,1 +4426,1 @@\n-        return (double)(Math.tanh((double)a));\n+        return (double)(scalar_tanh(a));\n@@ -4173,1 +4430,1 @@\n-        return (double)(StrictMath.tanh((double)a));\n+        return (double)(strict_scalar_tanh(a));\n@@ -4192,1 +4449,1 @@\n-        return (double)(Math.asin((double)a));\n+        return (double)(scalar_asin(a));\n@@ -4196,1 +4453,1 @@\n-        return (double)(StrictMath.asin((double)a));\n+        return (double)(strict_scalar_asin(a));\n@@ -4215,1 +4472,1 @@\n-        return (double)(Math.acos((double)a));\n+        return (double)(scalar_acos(a));\n@@ -4219,1 +4476,1 @@\n-        return (double)(StrictMath.acos((double)a));\n+        return (double)(strict_scalar_acos(a));\n@@ -4238,1 +4495,1 @@\n-        return (double)(Math.atan((double)a));\n+        return (double)(scalar_atan(a));\n@@ -4242,1 +4499,1 @@\n-        return (double)(StrictMath.atan((double)a));\n+        return (double)(strict_scalar_atan(a));\n@@ -4261,1 +4518,1 @@\n-        return (double)(Math.cbrt((double)a));\n+        return (double)(scalar_cbrt(a));\n@@ -4265,1 +4522,1 @@\n-        return (double)(StrictMath.cbrt((double)a));\n+        return (double)(strict_scalar_cbrt(a));\n@@ -4284,1 +4541,1 @@\n-        return (double)(Math.hypot((double)a, (double)b));\n+        return (double)(scalar_hypot(a, b));\n@@ -4288,1 +4545,1 @@\n-        return (double)(StrictMath.hypot((double)a, (double)b));\n+        return (double)(strict_scalar_hypot(a, b));\n@@ -4310,1 +4567,1 @@\n-        return (double)(Math.pow((double)a, (double)b));\n+        return (double)(scalar_pow(a, b));\n@@ -4314,1 +4571,1 @@\n-        return (double)(StrictMath.pow((double)a, (double)b));\n+        return (double)(strict_scalar_pow(a, b));\n@@ -4336,1 +4593,1 @@\n-        return (double)(Math.pow((double)a, (double)b));\n+        return (double)(scalar_pow(a, b));\n@@ -4340,1 +4597,1 @@\n-        return (double)(StrictMath.pow((double)a, (double)b));\n+        return (double)(strict_scalar_pow(a, b));\n@@ -4362,1 +4619,1 @@\n-        return (double)(Math.atan2((double)a, (double)b));\n+        return (double)(scalar_atan2(a, b));\n@@ -4366,1 +4623,1 @@\n-        return (double)(StrictMath.atan2((double)a, (double)b));\n+        return (double)(strict_scalar_atan2(a, b));\n@@ -4418,1 +4675,1 @@\n-        return (double)(Math.fma(a, b, c));\n+        return (double)(scalar_fma(a, b, c));\n@@ -4422,1 +4679,1 @@\n-        return (double)(Math.fma(a, b, c));\n+        return (double)(scalar_fma(a, b, c));\n@@ -4642,1 +4899,1 @@\n-        return (double)(-((double)a));\n+        return (double)(scalar_neg((double)a));\n@@ -4646,1 +4903,1 @@\n-        return (double)(-((double)a));\n+        return (double)(scalar_neg((double)a));\n@@ -4698,1 +4955,1 @@\n-        return (double)(Math.abs((double)a));\n+        return (double)(scalar_abs((double)a));\n@@ -4702,1 +4959,1 @@\n-        return (double)(Math.abs((double)a));\n+        return (double)(scalar_abs((double)a));\n@@ -4754,1 +5011,1 @@\n-        return (double)(Math.sqrt((double)a));\n+        return (double)(scalar_sqrt(a));\n@@ -4758,1 +5015,1 @@\n-        return (double)(Math.sqrt((double)a));\n+        return (double)(scalar_sqrt(a));\n@@ -4820,1 +5077,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -4836,1 +5093,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -4922,1 +5179,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -4963,1 +5220,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -5066,1 +5323,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -5094,1 +5351,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -5108,1 +5365,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -5305,1 +5562,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -5325,1 +5582,1 @@\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5348,1 +5605,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -5362,1 +5619,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -5384,1 +5641,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -5392,1 +5649,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -5399,1 +5656,1 @@\n-        Assert.assertEquals(elsize, Double.SIZE);\n+        AssertEquals(elsize, Double.SIZE);\n@@ -5418,1 +5675,1 @@\n-    static void ElementTypeDouble256VectorTestsSmokeTest() {\n+    static void DoubleDouble256VectorTestsSmokeTest() {\n@@ -5453,1 +5710,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":608,"deletions":351,"binary":false,"changes":959,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,39 @@\n+    static DoubleVector bcast_vec = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(double actual, double expected, double delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(double actual, double expected, double delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(double [] actual, double [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double [] actual, double [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -92,1 +131,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -95,1 +134,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -107,1 +146,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -113,1 +152,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -123,1 +162,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -126,1 +165,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -148,1 +187,1 @@\n-            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);\n+            AssertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);\n@@ -150,1 +189,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);\n+                AssertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);\n@@ -153,2 +192,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, \"at index #\" + i);\n@@ -176,1 +215,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n+            AssertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -178,2 +217,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n-relativeError));\n+                AssertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError));\n@@ -182,2 +220,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -199,1 +237,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -201,1 +239,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -204,2 +242,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -221,1 +259,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -223,1 +261,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -226,2 +264,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -239,1 +277,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -242,1 +280,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -254,1 +292,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -257,1 +295,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -266,1 +304,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -271,1 +309,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -282,1 +320,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -287,1 +325,1 @@\n-                    Assert.assertEquals(r[i + k], (double)0);\n+                    AssertEquals(r[i + k], (double)0);\n@@ -293,1 +331,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -295,1 +333,1 @@\n-                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (double)0, \"at index #\" + idx);\n@@ -307,1 +345,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -310,1 +348,1 @@\n-                        Assert.assertEquals(r[i + j], (double)0);\n+                        AssertEquals(r[i + j], (double)0);\n@@ -317,1 +355,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -319,1 +357,1 @@\n-                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (double)0, \"at index #\" + idx);\n@@ -335,1 +373,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -339,1 +377,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -345,0 +383,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -348,1 +387,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -352,2 +393,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -363,1 +403,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -365,1 +405,1 @@\n-                         Assert.assertEquals(r[i+j], (double)0);\n+                         AssertEquals(r[i+j], (double)0);\n@@ -371,1 +411,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -373,1 +413,1 @@\n-                Assert.assertEquals(r[i+j], (double)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (double)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -379,0 +419,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -382,0 +423,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -383,1 +426,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -385,1 +428,1 @@\n-                         Assert.assertEquals(r[i+j], (double)0);\n+                         AssertEquals(r[i+j], (double)0);\n@@ -389,1 +432,0 @@\n-            int idx = i + j;\n@@ -391,1 +433,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -393,1 +435,1 @@\n-                Assert.assertEquals(r[i+j], (double)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (double)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -407,1 +449,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -410,1 +452,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -431,1 +473,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -434,1 +476,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -437,1 +479,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -440,3 +482,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -457,1 +499,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -460,1 +502,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -463,1 +505,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -466,3 +508,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -476,1 +518,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -479,1 +521,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -487,1 +529,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -490,1 +532,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -498,1 +540,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -501,1 +543,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -510,1 +552,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -513,1 +555,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -526,1 +568,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -529,1 +571,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -541,1 +583,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -544,1 +586,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -556,1 +598,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -559,1 +601,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -574,1 +616,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -577,1 +619,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -590,1 +632,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -594,1 +636,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -608,1 +650,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -612,1 +654,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -634,1 +676,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -638,1 +680,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -652,1 +694,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -656,1 +698,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -676,1 +718,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -679,1 +721,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -691,1 +733,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -694,1 +736,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -703,1 +745,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -706,1 +748,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -716,1 +758,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -719,1 +761,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -735,1 +777,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -739,1 +781,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -756,1 +798,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -760,1 +802,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -771,1 +813,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -775,1 +817,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -792,1 +834,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -796,1 +838,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -849,1 +891,1 @@\n-            Assert.assertTrue(Double.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(Double.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n@@ -888,1 +930,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -894,1 +936,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -915,1 +957,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -921,1 +963,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -936,1 +978,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -942,1 +984,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -963,1 +1005,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -969,1 +1011,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -983,1 +1025,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -989,1 +1031,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1004,1 +1046,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1010,1 +1052,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1025,1 +1067,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1031,1 +1073,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1047,1 +1089,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1053,1 +1095,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1061,0 +1103,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -1077,1 +1123,1 @@\n-            withToString(\"double[-i * 5]\", (int s) -> {\n+            withToString(\"Double[-i * 5]\", (int s) -> {\n@@ -1079,1 +1125,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1081,1 +1127,1 @@\n-            withToString(\"double[i * 5]\", (int s) -> {\n+            withToString(\"Double[i * 5]\", (int s) -> {\n@@ -1083,1 +1129,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1085,1 +1131,1 @@\n-            withToString(\"double[i + 1]\", (int s) -> {\n+            withToString(\"Double[i + 1]\", (int s) -> {\n@@ -1087,1 +1133,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1089,1 +1135,1 @@\n-            withToString(\"double[intCornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Double[intCornerCaseValue(i)]\", (int s) -> {\n@@ -1099,1 +1145,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -1102,1 +1148,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1121,0 +1167,4 @@\n+    static double genValue(long i) {\n+        return (double) i;\n+    }\n+\n@@ -1122,1 +1172,1 @@\n-            withToString(\"double[-i * 5]\", (int s) -> {\n+            withToString(\"Double[-i * 5]\", (int s) -> {\n@@ -1124,1 +1174,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1126,1 +1176,1 @@\n-            withToString(\"double[i * 5]\", (int s) -> {\n+            withToString(\"Double[i * 5]\", (int s) -> {\n@@ -1128,1 +1178,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1130,1 +1180,1 @@\n-            withToString(\"double[i + 1]\", (int s) -> {\n+            withToString(\"Double[i + 1]\", (int s) -> {\n@@ -1132,1 +1182,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1134,1 +1184,1 @@\n-            withToString(\"double[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Double[cornerCaseValue(i)]\", (int s) -> {\n@@ -1145,1 +1195,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -1148,1 +1198,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1153,1 +1203,1 @@\n-        return  Double.doubleToLongBits(e);\n+        return Double.doubleToLongBits(e);\n@@ -1157,1 +1207,1 @@\n-            withToString(\"double[-i * 5]\", (int s) -> {\n+            withToString(\"Double[-i * 5]\", (int s) -> {\n@@ -1159,1 +1209,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1161,1 +1211,1 @@\n-            withToString(\"double[i * 5]\", (int s) -> {\n+            withToString(\"Double[i * 5]\", (int s) -> {\n@@ -1163,1 +1213,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1165,1 +1215,1 @@\n-            withToString(\"double[i + 1]\", (int s) -> {\n+            withToString(\"Double[i + 1]\", (int s) -> {\n@@ -1167,1 +1217,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1171,1 +1221,1 @@\n-                            i -> (double)0.01 + ((double)i \/ (i + 1)));\n+                            i -> ((double)0.01 + ((double)i \/ (i + 1))));\n@@ -1175,1 +1225,1 @@\n-                            i -> i % 17 == 0 ? cornerCaseValue(i) : (double)0.01 + ((double)i \/ (i + 1)));\n+                            i -> (i % 17 == 0) ? cornerCaseValue(i) : ((double)0.01 + ((double)i \/ (i + 1))));\n@@ -1499,0 +1549,219 @@\n+    static double multiplicativeIdentity() {\n+        return (double)1;\n+    }\n+\n+\n+    static double scalar_add(double a, double b) {\n+        return (double)(a + b);\n+    }\n+\n+    static double scalar_sub(double a, double b) {\n+        return (double)(a - b);\n+    }\n+\n+    static double scalar_mul(double a, double b) {\n+        return (double)(a * b);\n+    }\n+\n+    static double scalar_min(double a, double b) {\n+        return (double)(Math.min(a, b));\n+    }\n+\n+    static double scalar_max(double a, double b) {\n+        return (double)(Math.max(a, b));\n+    }\n+\n+    static double scalar_div(double a, double b) {\n+        return (double)(a \/ b);\n+    }\n+\n+    static double scalar_fma(double a, double b, double c) {\n+        return (double)(Math.fma(a, b, c));\n+    }\n+\n+    static double scalar_abs(double a) {\n+        return (double)(Math.abs(a));\n+    }\n+\n+    static double scalar_neg(double a) {\n+        return ((double)-a);\n+    }\n+\n+    static double scalar_sin(double a) {\n+        return (double)Math.sin((double)a);\n+    }\n+\n+    static double scalar_exp(double a) {\n+        return (double)Math.exp((double)a);\n+    }\n+\n+    static double scalar_log1p(double a) {\n+        return (double)Math.log1p((double)a);\n+    }\n+\n+    static double scalar_log(double a) {\n+        return (double)Math.log((double)a);\n+    }\n+\n+    static double scalar_log10(double a) {\n+        return (double)Math.log10((double)a);\n+    }\n+\n+    static double scalar_expm1(double a) {\n+        return (double)Math.expm1((double)a);\n+    }\n+\n+    static double scalar_cos(double a) {\n+        return (double)Math.cos((double)a);\n+    }\n+\n+    static double scalar_tan(double a) {\n+        return (double)Math.tan((double)a);\n+    }\n+\n+    static double scalar_sinh(double a) {\n+        return (double)Math.sinh((double)a);\n+    }\n+\n+    static double scalar_cosh(double a) {\n+        return (double)Math.cosh((double)a);\n+    }\n+\n+    static double scalar_tanh(double a) {\n+        return (double)Math.tanh((double)a);\n+    }\n+\n+    static double scalar_asin(double a) {\n+        return (double)Math.asin((double)a);\n+    }\n+\n+    static double scalar_acos(double a) {\n+        return (double)Math.acos((double)a);\n+    }\n+\n+    static double scalar_atan(double a) {\n+        return (double)Math.atan((double)a);\n+    }\n+\n+    static double scalar_cbrt(double a) {\n+        return (double)Math.cbrt((double)a);\n+    }\n+\n+    static double scalar_sqrt(double a) {\n+        return (double)Math.sqrt((double)a);\n+    }\n+\n+    static double scalar_hypot(double a, double b) {\n+        return (double)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static double scalar_pow(double a, double b) {\n+        return (double)Math.pow((double)a, (double)b);\n+    }\n+\n+    static double scalar_atan2(double a, double b) {\n+        return (double)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static double strict_scalar_sin(double a) {\n+        return (double)StrictMath.sin((double)a);\n+    }\n+\n+    static double strict_scalar_exp(double a) {\n+        return (double)StrictMath.exp((double)a);\n+    }\n+\n+    static double strict_scalar_log1p(double a) {\n+        return (double)StrictMath.log1p((double)a);\n+    }\n+\n+    static double strict_scalar_log(double a) {\n+        return (double)StrictMath.log((double)a);\n+    }\n+\n+    static double strict_scalar_log10(double a) {\n+        return (double)StrictMath.log10((double)a);\n+    }\n+\n+    static double strict_scalar_expm1(double a) {\n+        return (double)StrictMath.expm1((double)a);\n+    }\n+\n+    static double strict_scalar_cos(double a) {\n+        return (double)StrictMath.cos((double)a);\n+    }\n+\n+    static double strict_scalar_tan(double a) {\n+        return (double)StrictMath.tan((double)a);\n+    }\n+\n+    static double strict_scalar_sinh(double a) {\n+        return (double)StrictMath.sinh((double)a);\n+    }\n+\n+    static double strict_scalar_cosh(double a) {\n+        return (double)StrictMath.cosh((double)a);\n+    }\n+\n+    static double strict_scalar_tanh(double a) {\n+        return (double)StrictMath.tanh((double)a);\n+    }\n+\n+    static double strict_scalar_asin(double a) {\n+        return (double)StrictMath.asin((double)a);\n+    }\n+\n+    static double strict_scalar_acos(double a) {\n+        return (double)StrictMath.acos((double)a);\n+    }\n+\n+    static double strict_scalar_atan(double a) {\n+        return (double)StrictMath.atan((double)a);\n+    }\n+\n+    static double strict_scalar_cbrt(double a) {\n+        return (double)StrictMath.cbrt((double)a);\n+    }\n+\n+    static double strict_scalar_sqrt(double a) {\n+        return (double)StrictMath.sqrt((double)a);\n+    }\n+\n+    static double strict_scalar_hypot(double a, double b) {\n+        return (double)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static double strict_scalar_pow(double a, double b) {\n+        return (double)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static double strict_scalar_atan2(double a, double b) {\n+        return (double)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static double additiveIdentity() {\n+        return (double)0;\n+    }\n+\n+\n+    static double zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static double maxValue() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    static double minValue() {\n+        return Double.NEGATIVE_INFINITY;\n+    }\n+\n+    static boolean isNaN(double a) {\n+        return Double.isNaN(a);\n+    }\n+    static boolean isFinite(double a) {\n+        return Double.isFinite(a);\n+    }\n+    static boolean isInfinite(double a) {\n+        return Double.isInfinite(a);\n+    }\n+\n@@ -1536,1 +1805,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1551,1 +1820,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1557,1 +1826,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1563,1 +1832,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1580,3 +1849,3 @@\n-        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n-        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n-        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+        AssertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        AssertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n@@ -1588,1 +1857,1 @@\n-        Assert.assertEquals(asFloating.species(), SPECIES);\n+        AssertEquals(asFloating.species(), SPECIES);\n@@ -1592,1 +1861,1 @@\n-        return (double)(a + b);\n+        return (double)(scalar_add(a, b));\n@@ -1613,1 +1882,1 @@\n-        return (double)(a + b);\n+        return (double)(scalar_add(a, b));\n@@ -1670,1 +1939,1 @@\n-        return (double)(a - b);\n+        return (double)(scalar_sub(a, b));\n@@ -1691,1 +1960,1 @@\n-        return (double)(a - b);\n+        return (double)(scalar_sub(a, b));\n@@ -1748,1 +2017,1 @@\n-        return (double)(a * b);\n+        return (double)(scalar_mul(a, b));\n@@ -1769,1 +2038,1 @@\n-        return (double)(a * b);\n+        return (double)(scalar_mul(a, b));\n@@ -1826,1 +2095,1 @@\n-        return (double)(a \/ b);\n+        return (double)(scalar_div(a, b));\n@@ -1847,1 +2116,1 @@\n-        return (double)(a \/ b);\n+        return (double)(scalar_div(a, b));\n@@ -1904,1 +2173,1 @@\n-        return (double)(Double.doubleToLongBits(a)!=0?a:b);\n+        return (double)(firstNonZero(a, b));\n@@ -2099,2 +2368,0 @@\n-    static DoubleVector bv_MIN = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2109,1 +2376,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -2116,2 +2383,0 @@\n-    static DoubleVector bv_min = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2126,1 +2391,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -2133,2 +2398,0 @@\n-    static DoubleVector bv_MIN_M = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2145,1 +2408,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -2152,2 +2415,0 @@\n-    static DoubleVector bv_MAX = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2162,1 +2423,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -2169,2 +2430,0 @@\n-    static DoubleVector bv_max = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2179,1 +2438,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -2186,2 +2445,0 @@\n-    static DoubleVector bv_MAX_M = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2198,1 +2455,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -2206,1 +2463,1 @@\n-        return (double)(Math.min(a, b));\n+        return (double)(scalar_min(a, b));\n@@ -2227,1 +2484,1 @@\n-        return (double)(Math.min(a, b));\n+        return (double)(scalar_min(a, b));\n@@ -2246,1 +2503,1 @@\n-        return (double)(Math.max(a, b));\n+        return (double)(scalar_max(a, b));\n@@ -2267,1 +2524,1 @@\n-        return (double)(Math.max(a, b));\n+        return (double)(scalar_max(a, b));\n@@ -2342,1 +2599,1 @@\n-        double res = 0;\n+        double res = additiveIdentity();\n@@ -2344,1 +2601,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -2351,1 +2608,1 @@\n-        double res = 0;\n+        double res = additiveIdentity();\n@@ -2353,1 +2610,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -2363,1 +2620,1 @@\n-        double ra = 0;\n+        double ra = additiveIdentity();\n@@ -2373,1 +2630,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -2376,1 +2633,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -2385,1 +2642,1 @@\n-        double res = 0;\n+        double res = additiveIdentity();\n@@ -2388,1 +2645,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -2395,1 +2652,1 @@\n-        double res = 0;\n+        double res = additiveIdentity();\n@@ -2397,1 +2654,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -2409,1 +2666,1 @@\n-        double ra = 0;\n+        double ra = additiveIdentity();\n@@ -2419,1 +2676,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -2422,1 +2679,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -2431,1 +2688,1 @@\n-        double res = 1;\n+        double res = multiplicativeIdentity();\n@@ -2433,1 +2690,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -2440,1 +2697,1 @@\n-        double res = 1;\n+        double res = multiplicativeIdentity();\n@@ -2442,1 +2699,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -2452,1 +2709,1 @@\n-        double ra = 1;\n+        double ra = multiplicativeIdentity();\n@@ -2462,1 +2719,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -2465,1 +2722,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -2474,1 +2731,1 @@\n-        double res = 1;\n+        double res = multiplicativeIdentity();\n@@ -2477,1 +2734,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -2484,1 +2741,1 @@\n-        double res = 1;\n+        double res = multiplicativeIdentity();\n@@ -2486,1 +2743,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -2498,1 +2755,1 @@\n-        double ra = 1;\n+        double ra = multiplicativeIdentity();\n@@ -2508,1 +2765,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -2511,1 +2768,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -2520,1 +2777,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = maxValue();\n@@ -2522,1 +2779,1 @@\n-            res = (double) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -2529,1 +2786,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = maxValue();\n@@ -2531,1 +2788,1 @@\n-            res = (double) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -2541,1 +2798,1 @@\n-        double ra = Double.POSITIVE_INFINITY;\n+        double ra = maxValue();\n@@ -2551,1 +2808,1 @@\n-            ra = Double.POSITIVE_INFINITY;\n+            ra = maxValue();\n@@ -2554,1 +2811,1 @@\n-                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -2563,1 +2820,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = maxValue();\n@@ -2566,1 +2823,1 @@\n-                res = (double) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -2573,1 +2830,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = maxValue();\n@@ -2575,1 +2832,1 @@\n-            res = (double) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -2587,1 +2844,1 @@\n-        double ra = Double.POSITIVE_INFINITY;\n+        double ra = maxValue();\n@@ -2597,1 +2854,1 @@\n-            ra = Double.POSITIVE_INFINITY;\n+            ra = maxValue();\n@@ -2600,1 +2857,1 @@\n-                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -2609,1 +2866,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = minValue();\n@@ -2611,1 +2868,1 @@\n-            res = (double) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -2618,1 +2875,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = minValue();\n@@ -2620,1 +2877,1 @@\n-            res = (double) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -2630,1 +2887,1 @@\n-        double ra = Double.NEGATIVE_INFINITY;\n+        double ra = minValue();\n@@ -2640,1 +2897,1 @@\n-            ra = Double.NEGATIVE_INFINITY;\n+            ra = minValue();\n@@ -2643,1 +2900,1 @@\n-                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -2652,1 +2909,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = minValue();\n@@ -2655,1 +2912,1 @@\n-                res = (double) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -2662,1 +2919,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = minValue();\n@@ -2664,1 +2921,1 @@\n-            res = (double) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -2676,1 +2933,1 @@\n-        double ra = Double.NEGATIVE_INFINITY;\n+        double ra = minValue();\n@@ -2686,1 +2943,1 @@\n-            ra = Double.NEGATIVE_INFINITY;\n+            ra = minValue();\n@@ -2689,1 +2946,1 @@\n-                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -2698,1 +2955,1 @@\n-        double res = (double) 0;\n+        double res = zeroValue();\n@@ -2707,1 +2964,1 @@\n-        double res = (double) 0;\n+        double res = zeroValue();\n@@ -2719,1 +2976,1 @@\n-        double ra = (double) 0;\n+        double ra = zeroValue();\n@@ -2729,1 +2986,1 @@\n-            ra = (double) 0;\n+            ra = zeroValue();\n@@ -2741,1 +2998,1 @@\n-        double res = (double) 0;\n+        double res = zeroValue();\n@@ -2751,1 +3008,1 @@\n-        double res = (double) 0;\n+        double res = zeroValue();\n@@ -2765,1 +3022,1 @@\n-        double ra = (double) 0;\n+        double ra = zeroValue();\n@@ -2775,1 +3032,1 @@\n-            ra = (double) 0;\n+            ra = zeroValue();\n@@ -2820,1 +3077,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -2840,1 +3097,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -2861,1 +3118,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -2881,1 +3138,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -2888,1 +3145,1 @@\n-        return Double.isFinite(a);\n+        return isFinite(a);\n@@ -2902,1 +3159,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_FINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_FINITE(a[i + j]));\n@@ -2922,1 +3179,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n@@ -2929,1 +3186,1 @@\n-        return Double.isNaN(a);\n+        return isNaN(a);\n@@ -2943,1 +3200,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NAN(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NAN(a[i + j]));\n@@ -2963,1 +3220,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n@@ -2970,1 +3227,1 @@\n-        return Double.isInfinite(a);\n+        return isInfinite(a);\n@@ -2984,1 +3241,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_INFINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_INFINITE(a[i + j]));\n@@ -3004,1 +3261,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n@@ -3023,1 +3280,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3042,1 +3299,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3065,1 +3322,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3084,1 +3341,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3107,1 +3364,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3126,1 +3383,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3145,1 +3402,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3168,1 +3425,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3187,1 +3444,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3210,1 +3467,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3229,1 +3486,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3252,1 +3509,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3271,1 +3528,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3294,1 +3551,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -3311,1 +3568,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -3331,1 +3588,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -3347,1 +3604,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < (double)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (double)((long)b[i])));\n@@ -3367,1 +3624,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < (double)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(double)((long)b[i]))));\n@@ -3383,1 +3640,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -3403,1 +3660,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -3419,1 +3676,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == (double)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (double)((long)b[i])));\n@@ -3439,1 +3696,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == (double)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(double)((long)b[i]))));\n@@ -3720,1 +3977,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -3939,1 +4196,1 @@\n-        return (double)(Math.sin((double)a));\n+        return (double)(scalar_sin(a));\n@@ -3943,1 +4200,1 @@\n-        return (double)(StrictMath.sin((double)a));\n+        return (double)(strict_scalar_sin(a));\n@@ -3962,1 +4219,1 @@\n-        return (double)(Math.exp((double)a));\n+        return (double)(scalar_exp(a));\n@@ -3966,1 +4223,1 @@\n-        return (double)(StrictMath.exp((double)a));\n+        return (double)(strict_scalar_exp(a));\n@@ -3985,1 +4242,1 @@\n-        return (double)(Math.log1p((double)a));\n+        return (double)(scalar_log1p(a));\n@@ -3989,1 +4246,1 @@\n-        return (double)(StrictMath.log1p((double)a));\n+        return (double)(strict_scalar_log1p(a));\n@@ -4008,1 +4265,1 @@\n-        return (double)(Math.log((double)a));\n+        return (double)(scalar_log(a));\n@@ -4012,1 +4269,1 @@\n-        return (double)(StrictMath.log((double)a));\n+        return (double)(strict_scalar_log(a));\n@@ -4031,1 +4288,1 @@\n-        return (double)(Math.log10((double)a));\n+        return (double)(scalar_log10(a));\n@@ -4035,1 +4292,1 @@\n-        return (double)(StrictMath.log10((double)a));\n+        return (double)(strict_scalar_log10(a));\n@@ -4054,1 +4311,1 @@\n-        return (double)(Math.expm1((double)a));\n+        return (double)(scalar_expm1(a));\n@@ -4058,1 +4315,1 @@\n-        return (double)(StrictMath.expm1((double)a));\n+        return (double)(strict_scalar_expm1(a));\n@@ -4077,1 +4334,1 @@\n-        return (double)(Math.cos((double)a));\n+        return (double)(scalar_cos(a));\n@@ -4081,1 +4338,1 @@\n-        return (double)(StrictMath.cos((double)a));\n+        return (double)(strict_scalar_cos(a));\n@@ -4100,1 +4357,1 @@\n-        return (double)(Math.tan((double)a));\n+        return (double)(scalar_tan(a));\n@@ -4104,1 +4361,1 @@\n-        return (double)(StrictMath.tan((double)a));\n+        return (double)(strict_scalar_tan(a));\n@@ -4123,1 +4380,1 @@\n-        return (double)(Math.sinh((double)a));\n+        return (double)(scalar_sinh(a));\n@@ -4127,1 +4384,1 @@\n-        return (double)(StrictMath.sinh((double)a));\n+        return (double)(strict_scalar_sinh(a));\n@@ -4146,1 +4403,1 @@\n-        return (double)(Math.cosh((double)a));\n+        return (double)(scalar_cosh(a));\n@@ -4150,1 +4407,1 @@\n-        return (double)(StrictMath.cosh((double)a));\n+        return (double)(strict_scalar_cosh(a));\n@@ -4169,1 +4426,1 @@\n-        return (double)(Math.tanh((double)a));\n+        return (double)(scalar_tanh(a));\n@@ -4173,1 +4430,1 @@\n-        return (double)(StrictMath.tanh((double)a));\n+        return (double)(strict_scalar_tanh(a));\n@@ -4192,1 +4449,1 @@\n-        return (double)(Math.asin((double)a));\n+        return (double)(scalar_asin(a));\n@@ -4196,1 +4453,1 @@\n-        return (double)(StrictMath.asin((double)a));\n+        return (double)(strict_scalar_asin(a));\n@@ -4215,1 +4472,1 @@\n-        return (double)(Math.acos((double)a));\n+        return (double)(scalar_acos(a));\n@@ -4219,1 +4476,1 @@\n-        return (double)(StrictMath.acos((double)a));\n+        return (double)(strict_scalar_acos(a));\n@@ -4238,1 +4495,1 @@\n-        return (double)(Math.atan((double)a));\n+        return (double)(scalar_atan(a));\n@@ -4242,1 +4499,1 @@\n-        return (double)(StrictMath.atan((double)a));\n+        return (double)(strict_scalar_atan(a));\n@@ -4261,1 +4518,1 @@\n-        return (double)(Math.cbrt((double)a));\n+        return (double)(scalar_cbrt(a));\n@@ -4265,1 +4522,1 @@\n-        return (double)(StrictMath.cbrt((double)a));\n+        return (double)(strict_scalar_cbrt(a));\n@@ -4284,1 +4541,1 @@\n-        return (double)(Math.hypot((double)a, (double)b));\n+        return (double)(scalar_hypot(a, b));\n@@ -4288,1 +4545,1 @@\n-        return (double)(StrictMath.hypot((double)a, (double)b));\n+        return (double)(strict_scalar_hypot(a, b));\n@@ -4310,1 +4567,1 @@\n-        return (double)(Math.pow((double)a, (double)b));\n+        return (double)(scalar_pow(a, b));\n@@ -4314,1 +4571,1 @@\n-        return (double)(StrictMath.pow((double)a, (double)b));\n+        return (double)(strict_scalar_pow(a, b));\n@@ -4336,1 +4593,1 @@\n-        return (double)(Math.pow((double)a, (double)b));\n+        return (double)(scalar_pow(a, b));\n@@ -4340,1 +4597,1 @@\n-        return (double)(StrictMath.pow((double)a, (double)b));\n+        return (double)(strict_scalar_pow(a, b));\n@@ -4362,1 +4619,1 @@\n-        return (double)(Math.atan2((double)a, (double)b));\n+        return (double)(scalar_atan2(a, b));\n@@ -4366,1 +4623,1 @@\n-        return (double)(StrictMath.atan2((double)a, (double)b));\n+        return (double)(strict_scalar_atan2(a, b));\n@@ -4418,1 +4675,1 @@\n-        return (double)(Math.fma(a, b, c));\n+        return (double)(scalar_fma(a, b, c));\n@@ -4422,1 +4679,1 @@\n-        return (double)(Math.fma(a, b, c));\n+        return (double)(scalar_fma(a, b, c));\n@@ -4642,1 +4899,1 @@\n-        return (double)(-((double)a));\n+        return (double)(scalar_neg((double)a));\n@@ -4646,1 +4903,1 @@\n-        return (double)(-((double)a));\n+        return (double)(scalar_neg((double)a));\n@@ -4698,1 +4955,1 @@\n-        return (double)(Math.abs((double)a));\n+        return (double)(scalar_abs((double)a));\n@@ -4702,1 +4959,1 @@\n-        return (double)(Math.abs((double)a));\n+        return (double)(scalar_abs((double)a));\n@@ -4754,1 +5011,1 @@\n-        return (double)(Math.sqrt((double)a));\n+        return (double)(scalar_sqrt(a));\n@@ -4758,1 +5015,1 @@\n-        return (double)(Math.sqrt((double)a));\n+        return (double)(scalar_sqrt(a));\n@@ -4820,1 +5077,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -4836,1 +5093,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -4922,1 +5179,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -4963,1 +5220,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -5066,1 +5323,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -5094,1 +5351,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -5108,1 +5365,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -5305,1 +5562,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -5325,1 +5582,1 @@\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5348,1 +5605,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -5362,1 +5619,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -5384,1 +5641,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -5392,1 +5649,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -5399,1 +5656,1 @@\n-        Assert.assertEquals(elsize, Double.SIZE);\n+        AssertEquals(elsize, Double.SIZE);\n@@ -5418,1 +5675,1 @@\n-    static void ElementTypeDouble512VectorTestsSmokeTest() {\n+    static void DoubleDouble512VectorTestsSmokeTest() {\n@@ -5453,1 +5710,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":608,"deletions":351,"binary":false,"changes":959,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,39 @@\n+    static DoubleVector bcast_vec = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(double actual, double expected, double delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(double actual, double expected, double delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(double [] actual, double [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double [] actual, double [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -92,1 +131,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -95,1 +134,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -107,1 +146,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -113,1 +152,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -123,1 +162,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -126,1 +165,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -148,1 +187,1 @@\n-            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);\n+            AssertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);\n@@ -150,1 +189,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);\n+                AssertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);\n@@ -153,2 +192,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, \"at index #\" + i);\n@@ -176,1 +215,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n+            AssertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -178,2 +217,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n-relativeError));\n+                AssertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError));\n@@ -182,2 +220,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -199,1 +237,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -201,1 +239,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -204,2 +242,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -221,1 +259,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -223,1 +261,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -226,2 +264,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -239,1 +277,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -242,1 +280,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -254,1 +292,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -257,1 +295,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -266,1 +304,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -271,1 +309,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -282,1 +320,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -287,1 +325,1 @@\n-                    Assert.assertEquals(r[i + k], (double)0);\n+                    AssertEquals(r[i + k], (double)0);\n@@ -293,1 +331,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -295,1 +333,1 @@\n-                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (double)0, \"at index #\" + idx);\n@@ -307,1 +345,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -310,1 +348,1 @@\n-                        Assert.assertEquals(r[i + j], (double)0);\n+                        AssertEquals(r[i + j], (double)0);\n@@ -317,1 +355,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -319,1 +357,1 @@\n-                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (double)0, \"at index #\" + idx);\n@@ -335,1 +373,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -339,1 +377,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -345,0 +383,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -348,1 +387,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -352,2 +393,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -363,1 +403,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -365,1 +405,1 @@\n-                         Assert.assertEquals(r[i+j], (double)0);\n+                         AssertEquals(r[i+j], (double)0);\n@@ -371,1 +411,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -373,1 +413,1 @@\n-                Assert.assertEquals(r[i+j], (double)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (double)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -379,0 +419,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -382,0 +423,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -383,1 +426,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -385,1 +428,1 @@\n-                         Assert.assertEquals(r[i+j], (double)0);\n+                         AssertEquals(r[i+j], (double)0);\n@@ -389,1 +432,0 @@\n-            int idx = i + j;\n@@ -391,1 +433,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -393,1 +435,1 @@\n-                Assert.assertEquals(r[i+j], (double)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (double)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -407,1 +449,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -410,1 +452,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -431,1 +473,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -434,1 +476,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -437,1 +479,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -440,3 +482,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -457,1 +499,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -460,1 +502,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -463,1 +505,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -466,3 +508,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -476,1 +518,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -479,1 +521,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -487,1 +529,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -490,1 +532,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -498,1 +540,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -501,1 +543,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -510,1 +552,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -513,1 +555,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -526,1 +568,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -529,1 +571,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -541,1 +583,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -544,1 +586,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -556,1 +598,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -559,1 +601,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -574,1 +616,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -577,1 +619,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -590,1 +632,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -594,1 +636,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -608,1 +650,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -612,1 +654,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -634,1 +676,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -638,1 +680,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -652,1 +694,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -656,1 +698,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -676,1 +718,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -679,1 +721,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -691,1 +733,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -694,1 +736,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -703,1 +745,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -706,1 +748,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -716,1 +758,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -719,1 +761,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -735,1 +777,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -739,1 +781,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -756,1 +798,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -760,1 +802,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -771,1 +813,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -775,1 +817,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -792,1 +834,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -796,1 +838,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -849,1 +891,1 @@\n-            Assert.assertTrue(Double.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(Double.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n@@ -888,1 +930,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -894,1 +936,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -915,1 +957,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -921,1 +963,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -936,1 +978,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -942,1 +984,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -963,1 +1005,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -969,1 +1011,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -983,1 +1025,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -989,1 +1031,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1004,1 +1046,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1010,1 +1052,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1025,1 +1067,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1031,1 +1073,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1047,1 +1089,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1053,1 +1095,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1061,0 +1103,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -1077,1 +1123,1 @@\n-            withToString(\"double[-i * 5]\", (int s) -> {\n+            withToString(\"Double[-i * 5]\", (int s) -> {\n@@ -1079,1 +1125,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1081,1 +1127,1 @@\n-            withToString(\"double[i * 5]\", (int s) -> {\n+            withToString(\"Double[i * 5]\", (int s) -> {\n@@ -1083,1 +1129,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1085,1 +1131,1 @@\n-            withToString(\"double[i + 1]\", (int s) -> {\n+            withToString(\"Double[i + 1]\", (int s) -> {\n@@ -1087,1 +1133,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1089,1 +1135,1 @@\n-            withToString(\"double[intCornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Double[intCornerCaseValue(i)]\", (int s) -> {\n@@ -1099,1 +1145,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -1102,1 +1148,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1121,0 +1167,4 @@\n+    static double genValue(long i) {\n+        return (double) i;\n+    }\n+\n@@ -1122,1 +1172,1 @@\n-            withToString(\"double[-i * 5]\", (int s) -> {\n+            withToString(\"Double[-i * 5]\", (int s) -> {\n@@ -1124,1 +1174,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1126,1 +1176,1 @@\n-            withToString(\"double[i * 5]\", (int s) -> {\n+            withToString(\"Double[i * 5]\", (int s) -> {\n@@ -1128,1 +1178,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1130,1 +1180,1 @@\n-            withToString(\"double[i + 1]\", (int s) -> {\n+            withToString(\"Double[i + 1]\", (int s) -> {\n@@ -1132,1 +1182,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1134,1 +1184,1 @@\n-            withToString(\"double[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Double[cornerCaseValue(i)]\", (int s) -> {\n@@ -1145,1 +1195,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -1148,1 +1198,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1153,1 +1203,1 @@\n-        return  Double.doubleToLongBits(e);\n+        return Double.doubleToLongBits(e);\n@@ -1157,1 +1207,1 @@\n-            withToString(\"double[-i * 5]\", (int s) -> {\n+            withToString(\"Double[-i * 5]\", (int s) -> {\n@@ -1159,1 +1209,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1161,1 +1211,1 @@\n-            withToString(\"double[i * 5]\", (int s) -> {\n+            withToString(\"Double[i * 5]\", (int s) -> {\n@@ -1163,1 +1213,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1165,1 +1215,1 @@\n-            withToString(\"double[i + 1]\", (int s) -> {\n+            withToString(\"Double[i + 1]\", (int s) -> {\n@@ -1167,1 +1217,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1171,1 +1221,1 @@\n-                            i -> (double)0.01 + ((double)i \/ (i + 1)));\n+                            i -> ((double)0.01 + ((double)i \/ (i + 1))));\n@@ -1175,1 +1225,1 @@\n-                            i -> i % 17 == 0 ? cornerCaseValue(i) : (double)0.01 + ((double)i \/ (i + 1)));\n+                            i -> (i % 17 == 0) ? cornerCaseValue(i) : ((double)0.01 + ((double)i \/ (i + 1))));\n@@ -1499,0 +1549,219 @@\n+    static double multiplicativeIdentity() {\n+        return (double)1;\n+    }\n+\n+\n+    static double scalar_add(double a, double b) {\n+        return (double)(a + b);\n+    }\n+\n+    static double scalar_sub(double a, double b) {\n+        return (double)(a - b);\n+    }\n+\n+    static double scalar_mul(double a, double b) {\n+        return (double)(a * b);\n+    }\n+\n+    static double scalar_min(double a, double b) {\n+        return (double)(Math.min(a, b));\n+    }\n+\n+    static double scalar_max(double a, double b) {\n+        return (double)(Math.max(a, b));\n+    }\n+\n+    static double scalar_div(double a, double b) {\n+        return (double)(a \/ b);\n+    }\n+\n+    static double scalar_fma(double a, double b, double c) {\n+        return (double)(Math.fma(a, b, c));\n+    }\n+\n+    static double scalar_abs(double a) {\n+        return (double)(Math.abs(a));\n+    }\n+\n+    static double scalar_neg(double a) {\n+        return ((double)-a);\n+    }\n+\n+    static double scalar_sin(double a) {\n+        return (double)Math.sin((double)a);\n+    }\n+\n+    static double scalar_exp(double a) {\n+        return (double)Math.exp((double)a);\n+    }\n+\n+    static double scalar_log1p(double a) {\n+        return (double)Math.log1p((double)a);\n+    }\n+\n+    static double scalar_log(double a) {\n+        return (double)Math.log((double)a);\n+    }\n+\n+    static double scalar_log10(double a) {\n+        return (double)Math.log10((double)a);\n+    }\n+\n+    static double scalar_expm1(double a) {\n+        return (double)Math.expm1((double)a);\n+    }\n+\n+    static double scalar_cos(double a) {\n+        return (double)Math.cos((double)a);\n+    }\n+\n+    static double scalar_tan(double a) {\n+        return (double)Math.tan((double)a);\n+    }\n+\n+    static double scalar_sinh(double a) {\n+        return (double)Math.sinh((double)a);\n+    }\n+\n+    static double scalar_cosh(double a) {\n+        return (double)Math.cosh((double)a);\n+    }\n+\n+    static double scalar_tanh(double a) {\n+        return (double)Math.tanh((double)a);\n+    }\n+\n+    static double scalar_asin(double a) {\n+        return (double)Math.asin((double)a);\n+    }\n+\n+    static double scalar_acos(double a) {\n+        return (double)Math.acos((double)a);\n+    }\n+\n+    static double scalar_atan(double a) {\n+        return (double)Math.atan((double)a);\n+    }\n+\n+    static double scalar_cbrt(double a) {\n+        return (double)Math.cbrt((double)a);\n+    }\n+\n+    static double scalar_sqrt(double a) {\n+        return (double)Math.sqrt((double)a);\n+    }\n+\n+    static double scalar_hypot(double a, double b) {\n+        return (double)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static double scalar_pow(double a, double b) {\n+        return (double)Math.pow((double)a, (double)b);\n+    }\n+\n+    static double scalar_atan2(double a, double b) {\n+        return (double)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static double strict_scalar_sin(double a) {\n+        return (double)StrictMath.sin((double)a);\n+    }\n+\n+    static double strict_scalar_exp(double a) {\n+        return (double)StrictMath.exp((double)a);\n+    }\n+\n+    static double strict_scalar_log1p(double a) {\n+        return (double)StrictMath.log1p((double)a);\n+    }\n+\n+    static double strict_scalar_log(double a) {\n+        return (double)StrictMath.log((double)a);\n+    }\n+\n+    static double strict_scalar_log10(double a) {\n+        return (double)StrictMath.log10((double)a);\n+    }\n+\n+    static double strict_scalar_expm1(double a) {\n+        return (double)StrictMath.expm1((double)a);\n+    }\n+\n+    static double strict_scalar_cos(double a) {\n+        return (double)StrictMath.cos((double)a);\n+    }\n+\n+    static double strict_scalar_tan(double a) {\n+        return (double)StrictMath.tan((double)a);\n+    }\n+\n+    static double strict_scalar_sinh(double a) {\n+        return (double)StrictMath.sinh((double)a);\n+    }\n+\n+    static double strict_scalar_cosh(double a) {\n+        return (double)StrictMath.cosh((double)a);\n+    }\n+\n+    static double strict_scalar_tanh(double a) {\n+        return (double)StrictMath.tanh((double)a);\n+    }\n+\n+    static double strict_scalar_asin(double a) {\n+        return (double)StrictMath.asin((double)a);\n+    }\n+\n+    static double strict_scalar_acos(double a) {\n+        return (double)StrictMath.acos((double)a);\n+    }\n+\n+    static double strict_scalar_atan(double a) {\n+        return (double)StrictMath.atan((double)a);\n+    }\n+\n+    static double strict_scalar_cbrt(double a) {\n+        return (double)StrictMath.cbrt((double)a);\n+    }\n+\n+    static double strict_scalar_sqrt(double a) {\n+        return (double)StrictMath.sqrt((double)a);\n+    }\n+\n+    static double strict_scalar_hypot(double a, double b) {\n+        return (double)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static double strict_scalar_pow(double a, double b) {\n+        return (double)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static double strict_scalar_atan2(double a, double b) {\n+        return (double)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static double additiveIdentity() {\n+        return (double)0;\n+    }\n+\n+\n+    static double zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static double maxValue() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    static double minValue() {\n+        return Double.NEGATIVE_INFINITY;\n+    }\n+\n+    static boolean isNaN(double a) {\n+        return Double.isNaN(a);\n+    }\n+    static boolean isFinite(double a) {\n+        return Double.isFinite(a);\n+    }\n+    static boolean isInfinite(double a) {\n+        return Double.isInfinite(a);\n+    }\n+\n@@ -1536,1 +1805,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1551,1 +1820,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1557,1 +1826,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1563,1 +1832,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1580,3 +1849,3 @@\n-        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n-        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n-        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+        AssertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        AssertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n@@ -1588,1 +1857,1 @@\n-        Assert.assertEquals(asFloating.species(), SPECIES);\n+        AssertEquals(asFloating.species(), SPECIES);\n@@ -1592,1 +1861,1 @@\n-        return (double)(a + b);\n+        return (double)(scalar_add(a, b));\n@@ -1613,1 +1882,1 @@\n-        return (double)(a + b);\n+        return (double)(scalar_add(a, b));\n@@ -1670,1 +1939,1 @@\n-        return (double)(a - b);\n+        return (double)(scalar_sub(a, b));\n@@ -1691,1 +1960,1 @@\n-        return (double)(a - b);\n+        return (double)(scalar_sub(a, b));\n@@ -1748,1 +2017,1 @@\n-        return (double)(a * b);\n+        return (double)(scalar_mul(a, b));\n@@ -1769,1 +2038,1 @@\n-        return (double)(a * b);\n+        return (double)(scalar_mul(a, b));\n@@ -1826,1 +2095,1 @@\n-        return (double)(a \/ b);\n+        return (double)(scalar_div(a, b));\n@@ -1847,1 +2116,1 @@\n-        return (double)(a \/ b);\n+        return (double)(scalar_div(a, b));\n@@ -1904,1 +2173,1 @@\n-        return (double)(Double.doubleToLongBits(a)!=0?a:b);\n+        return (double)(firstNonZero(a, b));\n@@ -2099,2 +2368,0 @@\n-    static DoubleVector bv_MIN = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2109,1 +2376,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -2116,2 +2383,0 @@\n-    static DoubleVector bv_min = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2126,1 +2391,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -2133,2 +2398,0 @@\n-    static DoubleVector bv_MIN_M = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2145,1 +2408,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -2152,2 +2415,0 @@\n-    static DoubleVector bv_MAX = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2162,1 +2423,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -2169,2 +2430,0 @@\n-    static DoubleVector bv_max = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2179,1 +2438,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -2186,2 +2445,0 @@\n-    static DoubleVector bv_MAX_M = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2198,1 +2455,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -2206,1 +2463,1 @@\n-        return (double)(Math.min(a, b));\n+        return (double)(scalar_min(a, b));\n@@ -2227,1 +2484,1 @@\n-        return (double)(Math.min(a, b));\n+        return (double)(scalar_min(a, b));\n@@ -2246,1 +2503,1 @@\n-        return (double)(Math.max(a, b));\n+        return (double)(scalar_max(a, b));\n@@ -2267,1 +2524,1 @@\n-        return (double)(Math.max(a, b));\n+        return (double)(scalar_max(a, b));\n@@ -2342,1 +2599,1 @@\n-        double res = 0;\n+        double res = additiveIdentity();\n@@ -2344,1 +2601,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -2351,1 +2608,1 @@\n-        double res = 0;\n+        double res = additiveIdentity();\n@@ -2353,1 +2610,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -2363,1 +2620,1 @@\n-        double ra = 0;\n+        double ra = additiveIdentity();\n@@ -2373,1 +2630,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -2376,1 +2633,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -2385,1 +2642,1 @@\n-        double res = 0;\n+        double res = additiveIdentity();\n@@ -2388,1 +2645,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -2395,1 +2652,1 @@\n-        double res = 0;\n+        double res = additiveIdentity();\n@@ -2397,1 +2654,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -2409,1 +2666,1 @@\n-        double ra = 0;\n+        double ra = additiveIdentity();\n@@ -2419,1 +2676,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -2422,1 +2679,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -2431,1 +2688,1 @@\n-        double res = 1;\n+        double res = multiplicativeIdentity();\n@@ -2433,1 +2690,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -2440,1 +2697,1 @@\n-        double res = 1;\n+        double res = multiplicativeIdentity();\n@@ -2442,1 +2699,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -2452,1 +2709,1 @@\n-        double ra = 1;\n+        double ra = multiplicativeIdentity();\n@@ -2462,1 +2719,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -2465,1 +2722,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -2474,1 +2731,1 @@\n-        double res = 1;\n+        double res = multiplicativeIdentity();\n@@ -2477,1 +2734,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -2484,1 +2741,1 @@\n-        double res = 1;\n+        double res = multiplicativeIdentity();\n@@ -2486,1 +2743,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -2498,1 +2755,1 @@\n-        double ra = 1;\n+        double ra = multiplicativeIdentity();\n@@ -2508,1 +2765,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -2511,1 +2768,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -2520,1 +2777,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = maxValue();\n@@ -2522,1 +2779,1 @@\n-            res = (double) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -2529,1 +2786,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = maxValue();\n@@ -2531,1 +2788,1 @@\n-            res = (double) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -2541,1 +2798,1 @@\n-        double ra = Double.POSITIVE_INFINITY;\n+        double ra = maxValue();\n@@ -2551,1 +2808,1 @@\n-            ra = Double.POSITIVE_INFINITY;\n+            ra = maxValue();\n@@ -2554,1 +2811,1 @@\n-                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -2563,1 +2820,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = maxValue();\n@@ -2566,1 +2823,1 @@\n-                res = (double) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -2573,1 +2830,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = maxValue();\n@@ -2575,1 +2832,1 @@\n-            res = (double) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -2587,1 +2844,1 @@\n-        double ra = Double.POSITIVE_INFINITY;\n+        double ra = maxValue();\n@@ -2597,1 +2854,1 @@\n-            ra = Double.POSITIVE_INFINITY;\n+            ra = maxValue();\n@@ -2600,1 +2857,1 @@\n-                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -2609,1 +2866,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = minValue();\n@@ -2611,1 +2868,1 @@\n-            res = (double) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -2618,1 +2875,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = minValue();\n@@ -2620,1 +2877,1 @@\n-            res = (double) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -2630,1 +2887,1 @@\n-        double ra = Double.NEGATIVE_INFINITY;\n+        double ra = minValue();\n@@ -2640,1 +2897,1 @@\n-            ra = Double.NEGATIVE_INFINITY;\n+            ra = minValue();\n@@ -2643,1 +2900,1 @@\n-                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -2652,1 +2909,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = minValue();\n@@ -2655,1 +2912,1 @@\n-                res = (double) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -2662,1 +2919,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = minValue();\n@@ -2664,1 +2921,1 @@\n-            res = (double) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -2676,1 +2933,1 @@\n-        double ra = Double.NEGATIVE_INFINITY;\n+        double ra = minValue();\n@@ -2686,1 +2943,1 @@\n-            ra = Double.NEGATIVE_INFINITY;\n+            ra = minValue();\n@@ -2689,1 +2946,1 @@\n-                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -2698,1 +2955,1 @@\n-        double res = (double) 0;\n+        double res = zeroValue();\n@@ -2707,1 +2964,1 @@\n-        double res = (double) 0;\n+        double res = zeroValue();\n@@ -2719,1 +2976,1 @@\n-        double ra = (double) 0;\n+        double ra = zeroValue();\n@@ -2729,1 +2986,1 @@\n-            ra = (double) 0;\n+            ra = zeroValue();\n@@ -2741,1 +2998,1 @@\n-        double res = (double) 0;\n+        double res = zeroValue();\n@@ -2751,1 +3008,1 @@\n-        double res = (double) 0;\n+        double res = zeroValue();\n@@ -2765,1 +3022,1 @@\n-        double ra = (double) 0;\n+        double ra = zeroValue();\n@@ -2775,1 +3032,1 @@\n-            ra = (double) 0;\n+            ra = zeroValue();\n@@ -2820,1 +3077,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -2840,1 +3097,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -2861,1 +3118,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -2881,1 +3138,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -2888,1 +3145,1 @@\n-        return Double.isFinite(a);\n+        return isFinite(a);\n@@ -2902,1 +3159,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_FINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_FINITE(a[i + j]));\n@@ -2922,1 +3179,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n@@ -2929,1 +3186,1 @@\n-        return Double.isNaN(a);\n+        return isNaN(a);\n@@ -2943,1 +3200,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NAN(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NAN(a[i + j]));\n@@ -2963,1 +3220,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n@@ -2970,1 +3227,1 @@\n-        return Double.isInfinite(a);\n+        return isInfinite(a);\n@@ -2984,1 +3241,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_INFINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_INFINITE(a[i + j]));\n@@ -3004,1 +3261,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n@@ -3023,1 +3280,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3042,1 +3299,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3065,1 +3322,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3084,1 +3341,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3107,1 +3364,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3126,1 +3383,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3145,1 +3402,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3168,1 +3425,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3187,1 +3444,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3210,1 +3467,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3229,1 +3486,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3252,1 +3509,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3271,1 +3528,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3294,1 +3551,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -3311,1 +3568,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -3331,1 +3588,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -3347,1 +3604,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < (double)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (double)((long)b[i])));\n@@ -3367,1 +3624,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < (double)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(double)((long)b[i]))));\n@@ -3383,1 +3640,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -3403,1 +3660,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -3419,1 +3676,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == (double)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (double)((long)b[i])));\n@@ -3439,1 +3696,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == (double)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(double)((long)b[i]))));\n@@ -3720,1 +3977,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -3939,1 +4196,1 @@\n-        return (double)(Math.sin((double)a));\n+        return (double)(scalar_sin(a));\n@@ -3943,1 +4200,1 @@\n-        return (double)(StrictMath.sin((double)a));\n+        return (double)(strict_scalar_sin(a));\n@@ -3962,1 +4219,1 @@\n-        return (double)(Math.exp((double)a));\n+        return (double)(scalar_exp(a));\n@@ -3966,1 +4223,1 @@\n-        return (double)(StrictMath.exp((double)a));\n+        return (double)(strict_scalar_exp(a));\n@@ -3985,1 +4242,1 @@\n-        return (double)(Math.log1p((double)a));\n+        return (double)(scalar_log1p(a));\n@@ -3989,1 +4246,1 @@\n-        return (double)(StrictMath.log1p((double)a));\n+        return (double)(strict_scalar_log1p(a));\n@@ -4008,1 +4265,1 @@\n-        return (double)(Math.log((double)a));\n+        return (double)(scalar_log(a));\n@@ -4012,1 +4269,1 @@\n-        return (double)(StrictMath.log((double)a));\n+        return (double)(strict_scalar_log(a));\n@@ -4031,1 +4288,1 @@\n-        return (double)(Math.log10((double)a));\n+        return (double)(scalar_log10(a));\n@@ -4035,1 +4292,1 @@\n-        return (double)(StrictMath.log10((double)a));\n+        return (double)(strict_scalar_log10(a));\n@@ -4054,1 +4311,1 @@\n-        return (double)(Math.expm1((double)a));\n+        return (double)(scalar_expm1(a));\n@@ -4058,1 +4315,1 @@\n-        return (double)(StrictMath.expm1((double)a));\n+        return (double)(strict_scalar_expm1(a));\n@@ -4077,1 +4334,1 @@\n-        return (double)(Math.cos((double)a));\n+        return (double)(scalar_cos(a));\n@@ -4081,1 +4338,1 @@\n-        return (double)(StrictMath.cos((double)a));\n+        return (double)(strict_scalar_cos(a));\n@@ -4100,1 +4357,1 @@\n-        return (double)(Math.tan((double)a));\n+        return (double)(scalar_tan(a));\n@@ -4104,1 +4361,1 @@\n-        return (double)(StrictMath.tan((double)a));\n+        return (double)(strict_scalar_tan(a));\n@@ -4123,1 +4380,1 @@\n-        return (double)(Math.sinh((double)a));\n+        return (double)(scalar_sinh(a));\n@@ -4127,1 +4384,1 @@\n-        return (double)(StrictMath.sinh((double)a));\n+        return (double)(strict_scalar_sinh(a));\n@@ -4146,1 +4403,1 @@\n-        return (double)(Math.cosh((double)a));\n+        return (double)(scalar_cosh(a));\n@@ -4150,1 +4407,1 @@\n-        return (double)(StrictMath.cosh((double)a));\n+        return (double)(strict_scalar_cosh(a));\n@@ -4169,1 +4426,1 @@\n-        return (double)(Math.tanh((double)a));\n+        return (double)(scalar_tanh(a));\n@@ -4173,1 +4430,1 @@\n-        return (double)(StrictMath.tanh((double)a));\n+        return (double)(strict_scalar_tanh(a));\n@@ -4192,1 +4449,1 @@\n-        return (double)(Math.asin((double)a));\n+        return (double)(scalar_asin(a));\n@@ -4196,1 +4453,1 @@\n-        return (double)(StrictMath.asin((double)a));\n+        return (double)(strict_scalar_asin(a));\n@@ -4215,1 +4472,1 @@\n-        return (double)(Math.acos((double)a));\n+        return (double)(scalar_acos(a));\n@@ -4219,1 +4476,1 @@\n-        return (double)(StrictMath.acos((double)a));\n+        return (double)(strict_scalar_acos(a));\n@@ -4238,1 +4495,1 @@\n-        return (double)(Math.atan((double)a));\n+        return (double)(scalar_atan(a));\n@@ -4242,1 +4499,1 @@\n-        return (double)(StrictMath.atan((double)a));\n+        return (double)(strict_scalar_atan(a));\n@@ -4261,1 +4518,1 @@\n-        return (double)(Math.cbrt((double)a));\n+        return (double)(scalar_cbrt(a));\n@@ -4265,1 +4522,1 @@\n-        return (double)(StrictMath.cbrt((double)a));\n+        return (double)(strict_scalar_cbrt(a));\n@@ -4284,1 +4541,1 @@\n-        return (double)(Math.hypot((double)a, (double)b));\n+        return (double)(scalar_hypot(a, b));\n@@ -4288,1 +4545,1 @@\n-        return (double)(StrictMath.hypot((double)a, (double)b));\n+        return (double)(strict_scalar_hypot(a, b));\n@@ -4310,1 +4567,1 @@\n-        return (double)(Math.pow((double)a, (double)b));\n+        return (double)(scalar_pow(a, b));\n@@ -4314,1 +4571,1 @@\n-        return (double)(StrictMath.pow((double)a, (double)b));\n+        return (double)(strict_scalar_pow(a, b));\n@@ -4336,1 +4593,1 @@\n-        return (double)(Math.pow((double)a, (double)b));\n+        return (double)(scalar_pow(a, b));\n@@ -4340,1 +4597,1 @@\n-        return (double)(StrictMath.pow((double)a, (double)b));\n+        return (double)(strict_scalar_pow(a, b));\n@@ -4362,1 +4619,1 @@\n-        return (double)(Math.atan2((double)a, (double)b));\n+        return (double)(scalar_atan2(a, b));\n@@ -4366,1 +4623,1 @@\n-        return (double)(StrictMath.atan2((double)a, (double)b));\n+        return (double)(strict_scalar_atan2(a, b));\n@@ -4418,1 +4675,1 @@\n-        return (double)(Math.fma(a, b, c));\n+        return (double)(scalar_fma(a, b, c));\n@@ -4422,1 +4679,1 @@\n-        return (double)(Math.fma(a, b, c));\n+        return (double)(scalar_fma(a, b, c));\n@@ -4642,1 +4899,1 @@\n-        return (double)(-((double)a));\n+        return (double)(scalar_neg((double)a));\n@@ -4646,1 +4903,1 @@\n-        return (double)(-((double)a));\n+        return (double)(scalar_neg((double)a));\n@@ -4698,1 +4955,1 @@\n-        return (double)(Math.abs((double)a));\n+        return (double)(scalar_abs((double)a));\n@@ -4702,1 +4959,1 @@\n-        return (double)(Math.abs((double)a));\n+        return (double)(scalar_abs((double)a));\n@@ -4754,1 +5011,1 @@\n-        return (double)(Math.sqrt((double)a));\n+        return (double)(scalar_sqrt(a));\n@@ -4758,1 +5015,1 @@\n-        return (double)(Math.sqrt((double)a));\n+        return (double)(scalar_sqrt(a));\n@@ -4820,1 +5077,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -4836,1 +5093,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -4922,1 +5179,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -4963,1 +5220,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -5066,1 +5323,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -5094,1 +5351,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -5108,1 +5365,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -5305,1 +5562,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -5325,1 +5582,1 @@\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5348,1 +5605,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -5362,1 +5619,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -5384,1 +5641,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -5392,1 +5649,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -5399,1 +5656,1 @@\n-        Assert.assertEquals(elsize, Double.SIZE);\n+        AssertEquals(elsize, Double.SIZE);\n@@ -5418,1 +5675,1 @@\n-    static void ElementTypeDouble64VectorTestsSmokeTest() {\n+    static void DoubleDouble64VectorTestsSmokeTest() {\n@@ -5453,1 +5710,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":608,"deletions":351,"binary":false,"changes":959,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,39 @@\n+    static DoubleVector bcast_vec = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(double actual, double expected, double delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(double actual, double expected, double delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(double [] actual, double [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double [] actual, double [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -97,1 +136,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -100,1 +139,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -112,1 +151,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -118,1 +157,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -128,1 +167,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -131,1 +170,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -153,1 +192,1 @@\n-            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);\n+            AssertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);\n@@ -155,1 +194,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);\n+                AssertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);\n@@ -158,2 +197,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, \"at index #\" + i);\n@@ -181,1 +220,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n+            AssertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -183,2 +222,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n-relativeError));\n+                AssertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError));\n@@ -187,2 +225,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -204,1 +242,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -206,1 +244,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -209,2 +247,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -226,1 +264,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -228,1 +266,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -231,2 +269,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -244,1 +282,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -247,1 +285,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -259,1 +297,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -262,1 +300,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -271,1 +309,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -276,1 +314,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -287,1 +325,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -292,1 +330,1 @@\n-                    Assert.assertEquals(r[i + k], (double)0);\n+                    AssertEquals(r[i + k], (double)0);\n@@ -298,1 +336,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -300,1 +338,1 @@\n-                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (double)0, \"at index #\" + idx);\n@@ -312,1 +350,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -315,1 +353,1 @@\n-                        Assert.assertEquals(r[i + j], (double)0);\n+                        AssertEquals(r[i + j], (double)0);\n@@ -322,1 +360,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -324,1 +362,1 @@\n-                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (double)0, \"at index #\" + idx);\n@@ -340,1 +378,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -344,1 +382,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -350,0 +388,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -353,1 +392,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -357,2 +398,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -368,1 +408,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -370,1 +410,1 @@\n-                         Assert.assertEquals(r[i+j], (double)0);\n+                         AssertEquals(r[i+j], (double)0);\n@@ -376,1 +416,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -378,1 +418,1 @@\n-                Assert.assertEquals(r[i+j], (double)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (double)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -384,0 +424,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -387,0 +428,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -388,1 +431,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -390,1 +433,1 @@\n-                         Assert.assertEquals(r[i+j], (double)0);\n+                         AssertEquals(r[i+j], (double)0);\n@@ -394,1 +437,0 @@\n-            int idx = i + j;\n@@ -396,1 +438,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -398,1 +440,1 @@\n-                Assert.assertEquals(r[i+j], (double)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (double)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -412,1 +454,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -415,1 +457,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -436,1 +478,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -439,1 +481,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -442,1 +484,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -445,3 +487,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -462,1 +504,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -465,1 +507,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -468,1 +510,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -471,3 +513,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -481,1 +523,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -484,1 +526,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -492,1 +534,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -495,1 +537,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -503,1 +545,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -506,1 +548,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -515,1 +557,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -518,1 +560,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -531,1 +573,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -534,1 +576,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -546,1 +588,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -549,1 +591,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -561,1 +603,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -564,1 +606,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -579,1 +621,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -582,1 +624,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (double)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -595,1 +637,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -599,1 +641,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -613,1 +655,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -617,1 +659,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -639,1 +681,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -643,1 +685,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -657,1 +699,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -661,1 +703,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -681,1 +723,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -684,1 +726,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -696,1 +738,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -699,1 +741,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -708,1 +750,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -711,1 +753,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -721,1 +763,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -724,1 +766,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -740,1 +782,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -744,1 +786,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -761,1 +803,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -765,1 +807,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -776,1 +818,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -780,1 +822,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -797,1 +839,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -801,1 +843,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -854,1 +896,1 @@\n-            Assert.assertTrue(Double.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(Double.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n@@ -893,1 +935,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -899,1 +941,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -920,1 +962,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -926,1 +968,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -941,1 +983,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -947,1 +989,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -968,1 +1010,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -974,1 +1016,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -988,1 +1030,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -994,1 +1036,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1009,1 +1051,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1015,1 +1057,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1030,1 +1072,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1036,1 +1078,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1052,1 +1094,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1058,1 +1100,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1066,0 +1108,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -1082,1 +1128,1 @@\n-            withToString(\"double[-i * 5]\", (int s) -> {\n+            withToString(\"Double[-i * 5]\", (int s) -> {\n@@ -1084,1 +1130,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1086,1 +1132,1 @@\n-            withToString(\"double[i * 5]\", (int s) -> {\n+            withToString(\"Double[i * 5]\", (int s) -> {\n@@ -1088,1 +1134,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1090,1 +1136,1 @@\n-            withToString(\"double[i + 1]\", (int s) -> {\n+            withToString(\"Double[i + 1]\", (int s) -> {\n@@ -1092,1 +1138,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1094,1 +1140,1 @@\n-            withToString(\"double[intCornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Double[intCornerCaseValue(i)]\", (int s) -> {\n@@ -1104,1 +1150,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -1107,1 +1153,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1126,0 +1172,4 @@\n+    static double genValue(long i) {\n+        return (double) i;\n+    }\n+\n@@ -1127,1 +1177,1 @@\n-            withToString(\"double[-i * 5]\", (int s) -> {\n+            withToString(\"Double[-i * 5]\", (int s) -> {\n@@ -1129,1 +1179,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1131,1 +1181,1 @@\n-            withToString(\"double[i * 5]\", (int s) -> {\n+            withToString(\"Double[i * 5]\", (int s) -> {\n@@ -1133,1 +1183,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1135,1 +1185,1 @@\n-            withToString(\"double[i + 1]\", (int s) -> {\n+            withToString(\"Double[i + 1]\", (int s) -> {\n@@ -1137,1 +1187,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1139,1 +1189,1 @@\n-            withToString(\"double[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Double[cornerCaseValue(i)]\", (int s) -> {\n@@ -1150,1 +1200,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -1153,1 +1203,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1158,1 +1208,1 @@\n-        return  Double.doubleToLongBits(e);\n+        return Double.doubleToLongBits(e);\n@@ -1162,1 +1212,1 @@\n-            withToString(\"double[-i * 5]\", (int s) -> {\n+            withToString(\"Double[-i * 5]\", (int s) -> {\n@@ -1164,1 +1214,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1166,1 +1216,1 @@\n-            withToString(\"double[i * 5]\", (int s) -> {\n+            withToString(\"Double[i * 5]\", (int s) -> {\n@@ -1168,1 +1218,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1170,1 +1220,1 @@\n-            withToString(\"double[i + 1]\", (int s) -> {\n+            withToString(\"Double[i + 1]\", (int s) -> {\n@@ -1172,1 +1222,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1176,1 +1226,1 @@\n-                            i -> (double)0.01 + ((double)i \/ (i + 1)));\n+                            i -> ((double)0.01 + ((double)i \/ (i + 1))));\n@@ -1180,1 +1230,1 @@\n-                            i -> i % 17 == 0 ? cornerCaseValue(i) : (double)0.01 + ((double)i \/ (i + 1)));\n+                            i -> (i % 17 == 0) ? cornerCaseValue(i) : ((double)0.01 + ((double)i \/ (i + 1))));\n@@ -1504,0 +1554,219 @@\n+    static double multiplicativeIdentity() {\n+        return (double)1;\n+    }\n+\n+\n+    static double scalar_add(double a, double b) {\n+        return (double)(a + b);\n+    }\n+\n+    static double scalar_sub(double a, double b) {\n+        return (double)(a - b);\n+    }\n+\n+    static double scalar_mul(double a, double b) {\n+        return (double)(a * b);\n+    }\n+\n+    static double scalar_min(double a, double b) {\n+        return (double)(Math.min(a, b));\n+    }\n+\n+    static double scalar_max(double a, double b) {\n+        return (double)(Math.max(a, b));\n+    }\n+\n+    static double scalar_div(double a, double b) {\n+        return (double)(a \/ b);\n+    }\n+\n+    static double scalar_fma(double a, double b, double c) {\n+        return (double)(Math.fma(a, b, c));\n+    }\n+\n+    static double scalar_abs(double a) {\n+        return (double)(Math.abs(a));\n+    }\n+\n+    static double scalar_neg(double a) {\n+        return ((double)-a);\n+    }\n+\n+    static double scalar_sin(double a) {\n+        return (double)Math.sin((double)a);\n+    }\n+\n+    static double scalar_exp(double a) {\n+        return (double)Math.exp((double)a);\n+    }\n+\n+    static double scalar_log1p(double a) {\n+        return (double)Math.log1p((double)a);\n+    }\n+\n+    static double scalar_log(double a) {\n+        return (double)Math.log((double)a);\n+    }\n+\n+    static double scalar_log10(double a) {\n+        return (double)Math.log10((double)a);\n+    }\n+\n+    static double scalar_expm1(double a) {\n+        return (double)Math.expm1((double)a);\n+    }\n+\n+    static double scalar_cos(double a) {\n+        return (double)Math.cos((double)a);\n+    }\n+\n+    static double scalar_tan(double a) {\n+        return (double)Math.tan((double)a);\n+    }\n+\n+    static double scalar_sinh(double a) {\n+        return (double)Math.sinh((double)a);\n+    }\n+\n+    static double scalar_cosh(double a) {\n+        return (double)Math.cosh((double)a);\n+    }\n+\n+    static double scalar_tanh(double a) {\n+        return (double)Math.tanh((double)a);\n+    }\n+\n+    static double scalar_asin(double a) {\n+        return (double)Math.asin((double)a);\n+    }\n+\n+    static double scalar_acos(double a) {\n+        return (double)Math.acos((double)a);\n+    }\n+\n+    static double scalar_atan(double a) {\n+        return (double)Math.atan((double)a);\n+    }\n+\n+    static double scalar_cbrt(double a) {\n+        return (double)Math.cbrt((double)a);\n+    }\n+\n+    static double scalar_sqrt(double a) {\n+        return (double)Math.sqrt((double)a);\n+    }\n+\n+    static double scalar_hypot(double a, double b) {\n+        return (double)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static double scalar_pow(double a, double b) {\n+        return (double)Math.pow((double)a, (double)b);\n+    }\n+\n+    static double scalar_atan2(double a, double b) {\n+        return (double)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static double strict_scalar_sin(double a) {\n+        return (double)StrictMath.sin((double)a);\n+    }\n+\n+    static double strict_scalar_exp(double a) {\n+        return (double)StrictMath.exp((double)a);\n+    }\n+\n+    static double strict_scalar_log1p(double a) {\n+        return (double)StrictMath.log1p((double)a);\n+    }\n+\n+    static double strict_scalar_log(double a) {\n+        return (double)StrictMath.log((double)a);\n+    }\n+\n+    static double strict_scalar_log10(double a) {\n+        return (double)StrictMath.log10((double)a);\n+    }\n+\n+    static double strict_scalar_expm1(double a) {\n+        return (double)StrictMath.expm1((double)a);\n+    }\n+\n+    static double strict_scalar_cos(double a) {\n+        return (double)StrictMath.cos((double)a);\n+    }\n+\n+    static double strict_scalar_tan(double a) {\n+        return (double)StrictMath.tan((double)a);\n+    }\n+\n+    static double strict_scalar_sinh(double a) {\n+        return (double)StrictMath.sinh((double)a);\n+    }\n+\n+    static double strict_scalar_cosh(double a) {\n+        return (double)StrictMath.cosh((double)a);\n+    }\n+\n+    static double strict_scalar_tanh(double a) {\n+        return (double)StrictMath.tanh((double)a);\n+    }\n+\n+    static double strict_scalar_asin(double a) {\n+        return (double)StrictMath.asin((double)a);\n+    }\n+\n+    static double strict_scalar_acos(double a) {\n+        return (double)StrictMath.acos((double)a);\n+    }\n+\n+    static double strict_scalar_atan(double a) {\n+        return (double)StrictMath.atan((double)a);\n+    }\n+\n+    static double strict_scalar_cbrt(double a) {\n+        return (double)StrictMath.cbrt((double)a);\n+    }\n+\n+    static double strict_scalar_sqrt(double a) {\n+        return (double)StrictMath.sqrt((double)a);\n+    }\n+\n+    static double strict_scalar_hypot(double a, double b) {\n+        return (double)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static double strict_scalar_pow(double a, double b) {\n+        return (double)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static double strict_scalar_atan2(double a, double b) {\n+        return (double)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static double additiveIdentity() {\n+        return (double)0;\n+    }\n+\n+\n+    static double zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static double maxValue() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    static double minValue() {\n+        return Double.NEGATIVE_INFINITY;\n+    }\n+\n+    static boolean isNaN(double a) {\n+        return Double.isNaN(a);\n+    }\n+    static boolean isFinite(double a) {\n+        return Double.isFinite(a);\n+    }\n+    static boolean isInfinite(double a) {\n+        return Double.isInfinite(a);\n+    }\n+\n@@ -1541,1 +1810,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1556,1 +1825,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1562,1 +1831,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1568,1 +1837,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1585,3 +1854,3 @@\n-        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n-        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n-        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+        AssertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        AssertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n@@ -1593,1 +1862,1 @@\n-        Assert.assertEquals(asFloating.species(), SPECIES);\n+        AssertEquals(asFloating.species(), SPECIES);\n@@ -1597,1 +1866,1 @@\n-        return (double)(a + b);\n+        return (double)(scalar_add(a, b));\n@@ -1618,1 +1887,1 @@\n-        return (double)(a + b);\n+        return (double)(scalar_add(a, b));\n@@ -1675,1 +1944,1 @@\n-        return (double)(a - b);\n+        return (double)(scalar_sub(a, b));\n@@ -1696,1 +1965,1 @@\n-        return (double)(a - b);\n+        return (double)(scalar_sub(a, b));\n@@ -1753,1 +2022,1 @@\n-        return (double)(a * b);\n+        return (double)(scalar_mul(a, b));\n@@ -1774,1 +2043,1 @@\n-        return (double)(a * b);\n+        return (double)(scalar_mul(a, b));\n@@ -1831,1 +2100,1 @@\n-        return (double)(a \/ b);\n+        return (double)(scalar_div(a, b));\n@@ -1852,1 +2121,1 @@\n-        return (double)(a \/ b);\n+        return (double)(scalar_div(a, b));\n@@ -1909,1 +2178,1 @@\n-        return (double)(Double.doubleToLongBits(a)!=0?a:b);\n+        return (double)(firstNonZero(a, b));\n@@ -2104,2 +2373,0 @@\n-    static DoubleVector bv_MIN = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2114,1 +2381,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -2121,2 +2388,0 @@\n-    static DoubleVector bv_min = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2131,1 +2396,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -2138,2 +2403,0 @@\n-    static DoubleVector bv_MIN_M = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2150,1 +2413,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -2157,2 +2420,0 @@\n-    static DoubleVector bv_MAX = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2167,1 +2428,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -2174,2 +2435,0 @@\n-    static DoubleVector bv_max = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2184,1 +2443,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -2191,2 +2450,0 @@\n-    static DoubleVector bv_MAX_M = DoubleVector.broadcast(SPECIES, (double)10);\n-\n@@ -2203,1 +2460,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -2211,1 +2468,1 @@\n-        return (double)(Math.min(a, b));\n+        return (double)(scalar_min(a, b));\n@@ -2232,1 +2489,1 @@\n-        return (double)(Math.min(a, b));\n+        return (double)(scalar_min(a, b));\n@@ -2251,1 +2508,1 @@\n-        return (double)(Math.max(a, b));\n+        return (double)(scalar_max(a, b));\n@@ -2272,1 +2529,1 @@\n-        return (double)(Math.max(a, b));\n+        return (double)(scalar_max(a, b));\n@@ -2347,1 +2604,1 @@\n-        double res = 0;\n+        double res = additiveIdentity();\n@@ -2349,1 +2606,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -2356,1 +2613,1 @@\n-        double res = 0;\n+        double res = additiveIdentity();\n@@ -2358,1 +2615,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -2368,1 +2625,1 @@\n-        double ra = 0;\n+        double ra = additiveIdentity();\n@@ -2378,1 +2635,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -2381,1 +2638,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -2390,1 +2647,1 @@\n-        double res = 0;\n+        double res = additiveIdentity();\n@@ -2393,1 +2650,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -2400,1 +2657,1 @@\n-        double res = 0;\n+        double res = additiveIdentity();\n@@ -2402,1 +2659,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -2414,1 +2671,1 @@\n-        double ra = 0;\n+        double ra = additiveIdentity();\n@@ -2424,1 +2681,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -2427,1 +2684,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -2436,1 +2693,1 @@\n-        double res = 1;\n+        double res = multiplicativeIdentity();\n@@ -2438,1 +2695,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -2445,1 +2702,1 @@\n-        double res = 1;\n+        double res = multiplicativeIdentity();\n@@ -2447,1 +2704,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -2457,1 +2714,1 @@\n-        double ra = 1;\n+        double ra = multiplicativeIdentity();\n@@ -2467,1 +2724,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -2470,1 +2727,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -2479,1 +2736,1 @@\n-        double res = 1;\n+        double res = multiplicativeIdentity();\n@@ -2482,1 +2739,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -2489,1 +2746,1 @@\n-        double res = 1;\n+        double res = multiplicativeIdentity();\n@@ -2491,1 +2748,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -2503,1 +2760,1 @@\n-        double ra = 1;\n+        double ra = multiplicativeIdentity();\n@@ -2513,1 +2770,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -2516,1 +2773,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -2525,1 +2782,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = maxValue();\n@@ -2527,1 +2784,1 @@\n-            res = (double) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -2534,1 +2791,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = maxValue();\n@@ -2536,1 +2793,1 @@\n-            res = (double) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -2546,1 +2803,1 @@\n-        double ra = Double.POSITIVE_INFINITY;\n+        double ra = maxValue();\n@@ -2556,1 +2813,1 @@\n-            ra = Double.POSITIVE_INFINITY;\n+            ra = maxValue();\n@@ -2559,1 +2816,1 @@\n-                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -2568,1 +2825,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = maxValue();\n@@ -2571,1 +2828,1 @@\n-                res = (double) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -2578,1 +2835,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = maxValue();\n@@ -2580,1 +2837,1 @@\n-            res = (double) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -2592,1 +2849,1 @@\n-        double ra = Double.POSITIVE_INFINITY;\n+        double ra = maxValue();\n@@ -2602,1 +2859,1 @@\n-            ra = Double.POSITIVE_INFINITY;\n+            ra = maxValue();\n@@ -2605,1 +2862,1 @@\n-                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -2614,1 +2871,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = minValue();\n@@ -2616,1 +2873,1 @@\n-            res = (double) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -2623,1 +2880,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = minValue();\n@@ -2625,1 +2882,1 @@\n-            res = (double) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -2635,1 +2892,1 @@\n-        double ra = Double.NEGATIVE_INFINITY;\n+        double ra = minValue();\n@@ -2645,1 +2902,1 @@\n-            ra = Double.NEGATIVE_INFINITY;\n+            ra = minValue();\n@@ -2648,1 +2905,1 @@\n-                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -2657,1 +2914,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = minValue();\n@@ -2660,1 +2917,1 @@\n-                res = (double) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -2667,1 +2924,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = minValue();\n@@ -2669,1 +2926,1 @@\n-            res = (double) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -2681,1 +2938,1 @@\n-        double ra = Double.NEGATIVE_INFINITY;\n+        double ra = minValue();\n@@ -2691,1 +2948,1 @@\n-            ra = Double.NEGATIVE_INFINITY;\n+            ra = minValue();\n@@ -2694,1 +2951,1 @@\n-                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -2703,1 +2960,1 @@\n-        double res = (double) 0;\n+        double res = zeroValue();\n@@ -2712,1 +2969,1 @@\n-        double res = (double) 0;\n+        double res = zeroValue();\n@@ -2724,1 +2981,1 @@\n-        double ra = (double) 0;\n+        double ra = zeroValue();\n@@ -2734,1 +2991,1 @@\n-            ra = (double) 0;\n+            ra = zeroValue();\n@@ -2746,1 +3003,1 @@\n-        double res = (double) 0;\n+        double res = zeroValue();\n@@ -2756,1 +3013,1 @@\n-        double res = (double) 0;\n+        double res = zeroValue();\n@@ -2770,1 +3027,1 @@\n-        double ra = (double) 0;\n+        double ra = zeroValue();\n@@ -2780,1 +3037,1 @@\n-            ra = (double) 0;\n+            ra = zeroValue();\n@@ -2825,1 +3082,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -2845,1 +3102,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -2866,1 +3123,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -2886,1 +3143,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -2893,1 +3150,1 @@\n-        return Double.isFinite(a);\n+        return isFinite(a);\n@@ -2907,1 +3164,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_FINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_FINITE(a[i + j]));\n@@ -2927,1 +3184,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n@@ -2934,1 +3191,1 @@\n-        return Double.isNaN(a);\n+        return isNaN(a);\n@@ -2948,1 +3205,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NAN(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NAN(a[i + j]));\n@@ -2968,1 +3225,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n@@ -2975,1 +3232,1 @@\n-        return Double.isInfinite(a);\n+        return isInfinite(a);\n@@ -2989,1 +3246,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_INFINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_INFINITE(a[i + j]));\n@@ -3009,1 +3266,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n@@ -3028,1 +3285,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3047,1 +3304,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3070,1 +3327,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3089,1 +3346,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3112,1 +3369,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3131,1 +3388,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3150,1 +3407,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3173,1 +3430,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3192,1 +3449,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3215,1 +3472,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3234,1 +3491,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3257,1 +3514,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3276,1 +3533,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3299,1 +3556,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -3316,1 +3573,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -3336,1 +3593,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -3352,1 +3609,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < (double)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (double)((long)b[i])));\n@@ -3372,1 +3629,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < (double)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(double)((long)b[i]))));\n@@ -3388,1 +3645,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -3408,1 +3665,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -3424,1 +3681,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == (double)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (double)((long)b[i])));\n@@ -3444,1 +3701,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == (double)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(double)((long)b[i]))));\n@@ -3725,1 +3982,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -3944,1 +4201,1 @@\n-        return (double)(Math.sin((double)a));\n+        return (double)(scalar_sin(a));\n@@ -3948,1 +4205,1 @@\n-        return (double)(StrictMath.sin((double)a));\n+        return (double)(strict_scalar_sin(a));\n@@ -3967,1 +4224,1 @@\n-        return (double)(Math.exp((double)a));\n+        return (double)(scalar_exp(a));\n@@ -3971,1 +4228,1 @@\n-        return (double)(StrictMath.exp((double)a));\n+        return (double)(strict_scalar_exp(a));\n@@ -3990,1 +4247,1 @@\n-        return (double)(Math.log1p((double)a));\n+        return (double)(scalar_log1p(a));\n@@ -3994,1 +4251,1 @@\n-        return (double)(StrictMath.log1p((double)a));\n+        return (double)(strict_scalar_log1p(a));\n@@ -4013,1 +4270,1 @@\n-        return (double)(Math.log((double)a));\n+        return (double)(scalar_log(a));\n@@ -4017,1 +4274,1 @@\n-        return (double)(StrictMath.log((double)a));\n+        return (double)(strict_scalar_log(a));\n@@ -4036,1 +4293,1 @@\n-        return (double)(Math.log10((double)a));\n+        return (double)(scalar_log10(a));\n@@ -4040,1 +4297,1 @@\n-        return (double)(StrictMath.log10((double)a));\n+        return (double)(strict_scalar_log10(a));\n@@ -4059,1 +4316,1 @@\n-        return (double)(Math.expm1((double)a));\n+        return (double)(scalar_expm1(a));\n@@ -4063,1 +4320,1 @@\n-        return (double)(StrictMath.expm1((double)a));\n+        return (double)(strict_scalar_expm1(a));\n@@ -4082,1 +4339,1 @@\n-        return (double)(Math.cos((double)a));\n+        return (double)(scalar_cos(a));\n@@ -4086,1 +4343,1 @@\n-        return (double)(StrictMath.cos((double)a));\n+        return (double)(strict_scalar_cos(a));\n@@ -4105,1 +4362,1 @@\n-        return (double)(Math.tan((double)a));\n+        return (double)(scalar_tan(a));\n@@ -4109,1 +4366,1 @@\n-        return (double)(StrictMath.tan((double)a));\n+        return (double)(strict_scalar_tan(a));\n@@ -4128,1 +4385,1 @@\n-        return (double)(Math.sinh((double)a));\n+        return (double)(scalar_sinh(a));\n@@ -4132,1 +4389,1 @@\n-        return (double)(StrictMath.sinh((double)a));\n+        return (double)(strict_scalar_sinh(a));\n@@ -4151,1 +4408,1 @@\n-        return (double)(Math.cosh((double)a));\n+        return (double)(scalar_cosh(a));\n@@ -4155,1 +4412,1 @@\n-        return (double)(StrictMath.cosh((double)a));\n+        return (double)(strict_scalar_cosh(a));\n@@ -4174,1 +4431,1 @@\n-        return (double)(Math.tanh((double)a));\n+        return (double)(scalar_tanh(a));\n@@ -4178,1 +4435,1 @@\n-        return (double)(StrictMath.tanh((double)a));\n+        return (double)(strict_scalar_tanh(a));\n@@ -4197,1 +4454,1 @@\n-        return (double)(Math.asin((double)a));\n+        return (double)(scalar_asin(a));\n@@ -4201,1 +4458,1 @@\n-        return (double)(StrictMath.asin((double)a));\n+        return (double)(strict_scalar_asin(a));\n@@ -4220,1 +4477,1 @@\n-        return (double)(Math.acos((double)a));\n+        return (double)(scalar_acos(a));\n@@ -4224,1 +4481,1 @@\n-        return (double)(StrictMath.acos((double)a));\n+        return (double)(strict_scalar_acos(a));\n@@ -4243,1 +4500,1 @@\n-        return (double)(Math.atan((double)a));\n+        return (double)(scalar_atan(a));\n@@ -4247,1 +4504,1 @@\n-        return (double)(StrictMath.atan((double)a));\n+        return (double)(strict_scalar_atan(a));\n@@ -4266,1 +4523,1 @@\n-        return (double)(Math.cbrt((double)a));\n+        return (double)(scalar_cbrt(a));\n@@ -4270,1 +4527,1 @@\n-        return (double)(StrictMath.cbrt((double)a));\n+        return (double)(strict_scalar_cbrt(a));\n@@ -4289,1 +4546,1 @@\n-        return (double)(Math.hypot((double)a, (double)b));\n+        return (double)(scalar_hypot(a, b));\n@@ -4293,1 +4550,1 @@\n-        return (double)(StrictMath.hypot((double)a, (double)b));\n+        return (double)(strict_scalar_hypot(a, b));\n@@ -4315,1 +4572,1 @@\n-        return (double)(Math.pow((double)a, (double)b));\n+        return (double)(scalar_pow(a, b));\n@@ -4319,1 +4576,1 @@\n-        return (double)(StrictMath.pow((double)a, (double)b));\n+        return (double)(strict_scalar_pow(a, b));\n@@ -4341,1 +4598,1 @@\n-        return (double)(Math.pow((double)a, (double)b));\n+        return (double)(scalar_pow(a, b));\n@@ -4345,1 +4602,1 @@\n-        return (double)(StrictMath.pow((double)a, (double)b));\n+        return (double)(strict_scalar_pow(a, b));\n@@ -4367,1 +4624,1 @@\n-        return (double)(Math.atan2((double)a, (double)b));\n+        return (double)(scalar_atan2(a, b));\n@@ -4371,1 +4628,1 @@\n-        return (double)(StrictMath.atan2((double)a, (double)b));\n+        return (double)(strict_scalar_atan2(a, b));\n@@ -4423,1 +4680,1 @@\n-        return (double)(Math.fma(a, b, c));\n+        return (double)(scalar_fma(a, b, c));\n@@ -4427,1 +4684,1 @@\n-        return (double)(Math.fma(a, b, c));\n+        return (double)(scalar_fma(a, b, c));\n@@ -4647,1 +4904,1 @@\n-        return (double)(-((double)a));\n+        return (double)(scalar_neg((double)a));\n@@ -4651,1 +4908,1 @@\n-        return (double)(-((double)a));\n+        return (double)(scalar_neg((double)a));\n@@ -4703,1 +4960,1 @@\n-        return (double)(Math.abs((double)a));\n+        return (double)(scalar_abs((double)a));\n@@ -4707,1 +4964,1 @@\n-        return (double)(Math.abs((double)a));\n+        return (double)(scalar_abs((double)a));\n@@ -4759,1 +5016,1 @@\n-        return (double)(Math.sqrt((double)a));\n+        return (double)(scalar_sqrt(a));\n@@ -4763,1 +5020,1 @@\n-        return (double)(Math.sqrt((double)a));\n+        return (double)(scalar_sqrt(a));\n@@ -4825,1 +5082,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -4841,1 +5098,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -4927,1 +5184,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -4968,1 +5225,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -5071,1 +5328,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -5099,1 +5356,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -5113,1 +5370,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -5310,1 +5567,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -5337,1 +5594,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -5351,1 +5608,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -5373,1 +5630,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -5381,1 +5638,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -5388,1 +5645,1 @@\n-        Assert.assertEquals(elsize, Double.SIZE);\n+        AssertEquals(elsize, Double.SIZE);\n@@ -5407,1 +5664,1 @@\n-    static void ElementTypeDoubleMaxVectorTestsSmokeTest() {\n+    static void DoubleDoubleMaxVectorTestsSmokeTest() {\n@@ -5442,1 +5699,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":607,"deletions":350,"binary":false,"changes":957,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,45 @@\n+    static FloatVector bcast_vec = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    static void AssertEquals(float actual, float expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(float actual, float expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(float actual, float expected, float delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(float actual, float expected, float delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(float [] actual, float [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(float [] actual, float [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -92,1 +137,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -95,1 +140,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -107,1 +152,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -113,1 +158,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -123,1 +168,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -126,1 +171,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -148,1 +193,1 @@\n-            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);\n+            AssertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);\n@@ -150,1 +195,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);\n+                AssertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);\n@@ -153,2 +198,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, \"at index #\" + i);\n@@ -176,1 +221,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n+            AssertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -178,2 +223,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n-relativeError));\n+                AssertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError));\n@@ -182,2 +226,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -199,1 +243,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -201,1 +245,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -204,2 +248,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -221,1 +265,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -223,1 +267,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -226,2 +270,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -239,1 +283,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -242,1 +286,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -254,1 +298,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -257,1 +301,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -266,1 +310,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -271,1 +315,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -282,1 +326,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -287,1 +331,1 @@\n-                    Assert.assertEquals(r[i + k], (float)0);\n+                    AssertEquals(r[i + k], (float)0);\n@@ -293,1 +337,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -295,1 +339,1 @@\n-                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (float)0, \"at index #\" + idx);\n@@ -307,1 +351,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -310,1 +354,1 @@\n-                        Assert.assertEquals(r[i + j], (float)0);\n+                        AssertEquals(r[i + j], (float)0);\n@@ -317,1 +361,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -319,1 +363,1 @@\n-                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (float)0, \"at index #\" + idx);\n@@ -335,1 +379,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -339,1 +383,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -345,0 +389,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -348,1 +393,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -352,2 +399,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -363,1 +409,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -365,1 +411,1 @@\n-                         Assert.assertEquals(r[i+j], (float)0);\n+                         AssertEquals(r[i+j], (float)0);\n@@ -371,1 +417,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -373,1 +419,1 @@\n-                Assert.assertEquals(r[i+j], (float)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (float)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -379,0 +425,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -382,0 +429,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -383,1 +432,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -385,1 +434,1 @@\n-                         Assert.assertEquals(r[i+j], (float)0);\n+                         AssertEquals(r[i+j], (float)0);\n@@ -389,1 +438,0 @@\n-            int idx = i + j;\n@@ -391,1 +439,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -393,1 +441,1 @@\n-                Assert.assertEquals(r[i+j], (float)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (float)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -407,1 +455,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -410,1 +458,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -431,1 +479,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -434,1 +482,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -437,1 +485,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -440,3 +488,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -457,1 +505,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -460,1 +508,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -463,1 +511,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -466,3 +514,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -476,1 +524,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -479,1 +527,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -487,1 +535,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -490,1 +538,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -498,1 +546,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -501,1 +549,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -510,1 +558,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -513,1 +561,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -526,1 +574,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -529,1 +577,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -541,1 +589,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -544,1 +592,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -556,1 +604,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -559,1 +607,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -574,1 +622,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -577,1 +625,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -590,1 +638,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -594,1 +642,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -608,1 +656,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -612,1 +660,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -634,1 +682,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -638,1 +686,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -652,1 +700,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -656,1 +704,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -676,1 +724,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -679,1 +727,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -691,1 +739,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -694,1 +742,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -703,1 +751,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -706,1 +754,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -716,1 +764,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -719,1 +767,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -735,1 +783,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -739,1 +787,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -756,1 +804,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -760,1 +808,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -771,1 +819,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -775,1 +823,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -792,1 +840,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -796,1 +844,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -849,1 +897,1 @@\n-            Assert.assertTrue(Float.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(Float.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n@@ -888,1 +936,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -894,1 +942,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -915,1 +963,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -921,1 +969,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -936,1 +984,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -942,1 +990,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -963,1 +1011,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -969,1 +1017,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -983,1 +1031,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -989,1 +1037,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1004,1 +1052,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1010,1 +1058,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1025,1 +1073,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1031,1 +1079,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1047,1 +1095,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1053,1 +1101,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1061,0 +1109,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -1077,1 +1129,1 @@\n-            withToString(\"float[-i * 5]\", (int s) -> {\n+            withToString(\"Float[-i * 5]\", (int s) -> {\n@@ -1079,1 +1131,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1081,1 +1133,1 @@\n-            withToString(\"float[i * 5]\", (int s) -> {\n+            withToString(\"Float[i * 5]\", (int s) -> {\n@@ -1083,1 +1135,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1085,1 +1137,1 @@\n-            withToString(\"float[i + 1]\", (int s) -> {\n+            withToString(\"Float[i + 1]\", (int s) -> {\n@@ -1087,1 +1139,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1089,1 +1141,1 @@\n-            withToString(\"float[intCornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Float[intCornerCaseValue(i)]\", (int s) -> {\n@@ -1099,1 +1151,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -1102,1 +1154,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1121,0 +1173,4 @@\n+    static float genValue(long i) {\n+        return (float) i;\n+    }\n+\n@@ -1122,1 +1178,1 @@\n-            withToString(\"float[-i * 5]\", (int s) -> {\n+            withToString(\"Float[-i * 5]\", (int s) -> {\n@@ -1124,1 +1180,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1126,1 +1182,1 @@\n-            withToString(\"float[i * 5]\", (int s) -> {\n+            withToString(\"Float[i * 5]\", (int s) -> {\n@@ -1128,1 +1184,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1130,1 +1186,1 @@\n-            withToString(\"float[i + 1]\", (int s) -> {\n+            withToString(\"Float[i + 1]\", (int s) -> {\n@@ -1132,1 +1188,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1134,1 +1190,1 @@\n-            withToString(\"float[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Float[cornerCaseValue(i)]\", (int s) -> {\n@@ -1145,1 +1201,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -1148,1 +1204,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1156,1 +1212,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                AssertEquals(r[i], (double)(a[i+offs]));\n@@ -1159,1 +1215,1 @@\n-            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1164,1 +1220,1 @@\n-        return  Float.floatToIntBits(e);\n+        return Float.floatToIntBits(e);\n@@ -1168,1 +1224,1 @@\n-            withToString(\"float[-i * 5]\", (int s) -> {\n+            withToString(\"Float[-i * 5]\", (int s) -> {\n@@ -1170,1 +1226,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1172,1 +1228,1 @@\n-            withToString(\"float[i * 5]\", (int s) -> {\n+            withToString(\"Float[i * 5]\", (int s) -> {\n@@ -1174,1 +1230,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1176,1 +1232,1 @@\n-            withToString(\"float[i + 1]\", (int s) -> {\n+            withToString(\"Float[i + 1]\", (int s) -> {\n@@ -1178,1 +1234,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1182,1 +1238,1 @@\n-                            i -> (float)0.01 + ((float)i \/ (i + 1)));\n+                            i -> ((float)0.01 + ((float)i \/ (i + 1))));\n@@ -1186,1 +1242,1 @@\n-                            i -> i % 17 == 0 ? cornerCaseValue(i) : (float)0.01 + ((float)i \/ (i + 1)));\n+                            i -> (i % 17 == 0) ? cornerCaseValue(i) : ((float)0.01 + ((float)i \/ (i + 1))));\n@@ -1510,0 +1566,219 @@\n+    static float multiplicativeIdentity() {\n+        return (float)1;\n+    }\n+\n+\n+    static float scalar_add(float a, float b) {\n+        return (float)(a + b);\n+    }\n+\n+    static float scalar_sub(float a, float b) {\n+        return (float)(a - b);\n+    }\n+\n+    static float scalar_mul(float a, float b) {\n+        return (float)(a * b);\n+    }\n+\n+    static float scalar_min(float a, float b) {\n+        return (float)(Math.min(a, b));\n+    }\n+\n+    static float scalar_max(float a, float b) {\n+        return (float)(Math.max(a, b));\n+    }\n+\n+    static float scalar_div(float a, float b) {\n+        return (float)(a \/ b);\n+    }\n+\n+    static float scalar_fma(float a, float b, float c) {\n+        return (float)(Math.fma(a, b, c));\n+    }\n+\n+    static float scalar_abs(float a) {\n+        return (float)(Math.abs(a));\n+    }\n+\n+    static float scalar_neg(float a) {\n+        return ((float)-a);\n+    }\n+\n+    static float scalar_sin(float a) {\n+        return (float)Math.sin((double)a);\n+    }\n+\n+    static float scalar_exp(float a) {\n+        return (float)Math.exp((double)a);\n+    }\n+\n+    static float scalar_log1p(float a) {\n+        return (float)Math.log1p((double)a);\n+    }\n+\n+    static float scalar_log(float a) {\n+        return (float)Math.log((double)a);\n+    }\n+\n+    static float scalar_log10(float a) {\n+        return (float)Math.log10((double)a);\n+    }\n+\n+    static float scalar_expm1(float a) {\n+        return (float)Math.expm1((double)a);\n+    }\n+\n+    static float scalar_cos(float a) {\n+        return (float)Math.cos((double)a);\n+    }\n+\n+    static float scalar_tan(float a) {\n+        return (float)Math.tan((double)a);\n+    }\n+\n+    static float scalar_sinh(float a) {\n+        return (float)Math.sinh((double)a);\n+    }\n+\n+    static float scalar_cosh(float a) {\n+        return (float)Math.cosh((double)a);\n+    }\n+\n+    static float scalar_tanh(float a) {\n+        return (float)Math.tanh((double)a);\n+    }\n+\n+    static float scalar_asin(float a) {\n+        return (float)Math.asin((double)a);\n+    }\n+\n+    static float scalar_acos(float a) {\n+        return (float)Math.acos((double)a);\n+    }\n+\n+    static float scalar_atan(float a) {\n+        return (float)Math.atan((double)a);\n+    }\n+\n+    static float scalar_cbrt(float a) {\n+        return (float)Math.cbrt((double)a);\n+    }\n+\n+    static float scalar_sqrt(float a) {\n+        return (float)Math.sqrt((double)a);\n+    }\n+\n+    static float scalar_hypot(float a, float b) {\n+        return (float)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static float scalar_pow(float a, float b) {\n+        return (float)Math.pow((double)a, (double)b);\n+    }\n+\n+    static float scalar_atan2(float a, float b) {\n+        return (float)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static float strict_scalar_sin(float a) {\n+        return (float)StrictMath.sin((double)a);\n+    }\n+\n+    static float strict_scalar_exp(float a) {\n+        return (float)StrictMath.exp((double)a);\n+    }\n+\n+    static float strict_scalar_log1p(float a) {\n+        return (float)StrictMath.log1p((double)a);\n+    }\n+\n+    static float strict_scalar_log(float a) {\n+        return (float)StrictMath.log((double)a);\n+    }\n+\n+    static float strict_scalar_log10(float a) {\n+        return (float)StrictMath.log10((double)a);\n+    }\n+\n+    static float strict_scalar_expm1(float a) {\n+        return (float)StrictMath.expm1((double)a);\n+    }\n+\n+    static float strict_scalar_cos(float a) {\n+        return (float)StrictMath.cos((double)a);\n+    }\n+\n+    static float strict_scalar_tan(float a) {\n+        return (float)StrictMath.tan((double)a);\n+    }\n+\n+    static float strict_scalar_sinh(float a) {\n+        return (float)StrictMath.sinh((double)a);\n+    }\n+\n+    static float strict_scalar_cosh(float a) {\n+        return (float)StrictMath.cosh((double)a);\n+    }\n+\n+    static float strict_scalar_tanh(float a) {\n+        return (float)StrictMath.tanh((double)a);\n+    }\n+\n+    static float strict_scalar_asin(float a) {\n+        return (float)StrictMath.asin((double)a);\n+    }\n+\n+    static float strict_scalar_acos(float a) {\n+        return (float)StrictMath.acos((double)a);\n+    }\n+\n+    static float strict_scalar_atan(float a) {\n+        return (float)StrictMath.atan((double)a);\n+    }\n+\n+    static float strict_scalar_cbrt(float a) {\n+        return (float)StrictMath.cbrt((double)a);\n+    }\n+\n+    static float strict_scalar_sqrt(float a) {\n+        return (float)StrictMath.sqrt((double)a);\n+    }\n+\n+    static float strict_scalar_hypot(float a, float b) {\n+        return (float)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static float strict_scalar_pow(float a, float b) {\n+        return (float)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static float strict_scalar_atan2(float a, float b) {\n+        return (float)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static float additiveIdentity() {\n+        return (float)0;\n+    }\n+\n+\n+    static float zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static float maxValue() {\n+        return Float.POSITIVE_INFINITY;\n+    }\n+\n+    static float minValue() {\n+        return Float.NEGATIVE_INFINITY;\n+    }\n+\n+    static boolean isNaN(float a) {\n+        return Float.isNaN(a);\n+    }\n+    static boolean isFinite(float a) {\n+        return Float.isFinite(a);\n+    }\n+    static boolean isInfinite(float a) {\n+        return Float.isInfinite(a);\n+    }\n+\n@@ -1547,1 +1822,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1562,1 +1837,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1568,1 +1843,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1574,1 +1849,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1591,3 +1866,3 @@\n-        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n-        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n-        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+        AssertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        AssertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n@@ -1599,1 +1874,1 @@\n-        Assert.assertEquals(asFloating.species(), SPECIES);\n+        AssertEquals(asFloating.species(), SPECIES);\n@@ -1603,1 +1878,1 @@\n-        return (float)(a + b);\n+        return (float)(scalar_add(a, b));\n@@ -1624,1 +1899,1 @@\n-        return (float)(a + b);\n+        return (float)(scalar_add(a, b));\n@@ -1681,1 +1956,1 @@\n-        return (float)(a - b);\n+        return (float)(scalar_sub(a, b));\n@@ -1702,1 +1977,1 @@\n-        return (float)(a - b);\n+        return (float)(scalar_sub(a, b));\n@@ -1759,1 +2034,1 @@\n-        return (float)(a * b);\n+        return (float)(scalar_mul(a, b));\n@@ -1780,1 +2055,1 @@\n-        return (float)(a * b);\n+        return (float)(scalar_mul(a, b));\n@@ -1837,1 +2112,1 @@\n-        return (float)(a \/ b);\n+        return (float)(scalar_div(a, b));\n@@ -1858,1 +2133,1 @@\n-        return (float)(a \/ b);\n+        return (float)(scalar_div(a, b));\n@@ -1915,1 +2190,1 @@\n-        return (float)(Double.doubleToLongBits(a)!=0?a:b);\n+        return (float)(firstNonZero(a, b));\n@@ -2110,2 +2385,0 @@\n-    static FloatVector bv_MIN = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2120,1 +2393,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -2127,2 +2400,0 @@\n-    static FloatVector bv_min = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2137,1 +2408,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -2144,2 +2415,0 @@\n-    static FloatVector bv_MIN_M = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2156,1 +2425,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -2163,2 +2432,0 @@\n-    static FloatVector bv_MAX = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2173,1 +2440,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -2180,2 +2447,0 @@\n-    static FloatVector bv_max = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2190,1 +2455,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -2197,2 +2462,0 @@\n-    static FloatVector bv_MAX_M = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2209,1 +2472,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -2217,1 +2480,1 @@\n-        return (float)(Math.min(a, b));\n+        return (float)(scalar_min(a, b));\n@@ -2238,1 +2501,1 @@\n-        return (float)(Math.min(a, b));\n+        return (float)(scalar_min(a, b));\n@@ -2257,1 +2520,1 @@\n-        return (float)(Math.max(a, b));\n+        return (float)(scalar_max(a, b));\n@@ -2278,1 +2541,1 @@\n-        return (float)(Math.max(a, b));\n+        return (float)(scalar_max(a, b));\n@@ -2353,1 +2616,1 @@\n-        float res = 0;\n+        float res = additiveIdentity();\n@@ -2355,1 +2618,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -2362,1 +2625,1 @@\n-        float res = 0;\n+        float res = additiveIdentity();\n@@ -2364,1 +2627,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -2374,1 +2637,1 @@\n-        float ra = 0;\n+        float ra = additiveIdentity();\n@@ -2384,1 +2647,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -2387,1 +2650,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -2396,1 +2659,1 @@\n-        float res = 0;\n+        float res = additiveIdentity();\n@@ -2399,1 +2662,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -2406,1 +2669,1 @@\n-        float res = 0;\n+        float res = additiveIdentity();\n@@ -2408,1 +2671,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -2420,1 +2683,1 @@\n-        float ra = 0;\n+        float ra = additiveIdentity();\n@@ -2430,1 +2693,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -2433,1 +2696,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -2442,1 +2705,1 @@\n-        float res = 1;\n+        float res = multiplicativeIdentity();\n@@ -2444,1 +2707,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -2451,1 +2714,1 @@\n-        float res = 1;\n+        float res = multiplicativeIdentity();\n@@ -2453,1 +2716,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -2463,1 +2726,1 @@\n-        float ra = 1;\n+        float ra = multiplicativeIdentity();\n@@ -2473,1 +2736,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -2476,1 +2739,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -2485,1 +2748,1 @@\n-        float res = 1;\n+        float res = multiplicativeIdentity();\n@@ -2488,1 +2751,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -2495,1 +2758,1 @@\n-        float res = 1;\n+        float res = multiplicativeIdentity();\n@@ -2497,1 +2760,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -2509,1 +2772,1 @@\n-        float ra = 1;\n+        float ra = multiplicativeIdentity();\n@@ -2519,1 +2782,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -2522,1 +2785,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -2531,1 +2794,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = maxValue();\n@@ -2533,1 +2796,1 @@\n-            res = (float) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -2540,1 +2803,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = maxValue();\n@@ -2542,1 +2805,1 @@\n-            res = (float) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -2552,1 +2815,1 @@\n-        float ra = Float.POSITIVE_INFINITY;\n+        float ra = maxValue();\n@@ -2562,1 +2825,1 @@\n-            ra = Float.POSITIVE_INFINITY;\n+            ra = maxValue();\n@@ -2565,1 +2828,1 @@\n-                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -2574,1 +2837,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = maxValue();\n@@ -2577,1 +2840,1 @@\n-                res = (float) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -2584,1 +2847,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = maxValue();\n@@ -2586,1 +2849,1 @@\n-            res = (float) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -2598,1 +2861,1 @@\n-        float ra = Float.POSITIVE_INFINITY;\n+        float ra = maxValue();\n@@ -2608,1 +2871,1 @@\n-            ra = Float.POSITIVE_INFINITY;\n+            ra = maxValue();\n@@ -2611,1 +2874,1 @@\n-                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -2620,1 +2883,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = minValue();\n@@ -2622,1 +2885,1 @@\n-            res = (float) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -2629,1 +2892,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = minValue();\n@@ -2631,1 +2894,1 @@\n-            res = (float) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -2641,1 +2904,1 @@\n-        float ra = Float.NEGATIVE_INFINITY;\n+        float ra = minValue();\n@@ -2651,1 +2914,1 @@\n-            ra = Float.NEGATIVE_INFINITY;\n+            ra = minValue();\n@@ -2654,1 +2917,1 @@\n-                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -2663,1 +2926,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = minValue();\n@@ -2666,1 +2929,1 @@\n-                res = (float) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -2673,1 +2936,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = minValue();\n@@ -2675,1 +2938,1 @@\n-            res = (float) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -2687,1 +2950,1 @@\n-        float ra = Float.NEGATIVE_INFINITY;\n+        float ra = minValue();\n@@ -2697,1 +2960,1 @@\n-            ra = Float.NEGATIVE_INFINITY;\n+            ra = minValue();\n@@ -2700,1 +2963,1 @@\n-                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -2709,1 +2972,1 @@\n-        float res = (float) 0;\n+        float res = zeroValue();\n@@ -2718,1 +2981,1 @@\n-        float res = (float) 0;\n+        float res = zeroValue();\n@@ -2730,1 +2993,1 @@\n-        float ra = (float) 0;\n+        float ra = zeroValue();\n@@ -2740,1 +3003,1 @@\n-            ra = (float) 0;\n+            ra = zeroValue();\n@@ -2752,1 +3015,1 @@\n-        float res = (float) 0;\n+        float res = zeroValue();\n@@ -2762,1 +3025,1 @@\n-        float res = (float) 0;\n+        float res = zeroValue();\n@@ -2776,1 +3039,1 @@\n-        float ra = (float) 0;\n+        float ra = zeroValue();\n@@ -2786,1 +3049,1 @@\n-            ra = (float) 0;\n+            ra = zeroValue();\n@@ -2831,1 +3094,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -2851,1 +3114,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -2872,1 +3135,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -2892,1 +3155,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -2899,1 +3162,1 @@\n-        return Float.isFinite(a);\n+        return isFinite(a);\n@@ -2913,1 +3176,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_FINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_FINITE(a[i + j]));\n@@ -2933,1 +3196,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n@@ -2940,1 +3203,1 @@\n-        return Float.isNaN(a);\n+        return isNaN(a);\n@@ -2954,1 +3217,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NAN(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NAN(a[i + j]));\n@@ -2974,1 +3237,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n@@ -2981,1 +3244,1 @@\n-        return Float.isInfinite(a);\n+        return isInfinite(a);\n@@ -2995,1 +3258,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_INFINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_INFINITE(a[i + j]));\n@@ -3015,1 +3278,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n@@ -3034,1 +3297,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3053,1 +3316,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3076,1 +3339,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3095,1 +3358,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3118,1 +3381,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3137,1 +3400,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3156,1 +3419,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3179,1 +3442,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3198,1 +3461,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3221,1 +3484,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3240,1 +3503,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3263,1 +3526,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3282,1 +3545,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3305,1 +3568,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -3322,1 +3585,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -3342,1 +3605,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -3358,1 +3621,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < (float)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (float)((long)b[i])));\n@@ -3378,1 +3641,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < (float)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(float)((long)b[i]))));\n@@ -3394,1 +3657,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -3414,1 +3677,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -3430,1 +3693,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == (float)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (float)((long)b[i])));\n@@ -3450,1 +3713,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == (float)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(float)((long)b[i]))));\n@@ -3731,1 +3994,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -3950,1 +4213,1 @@\n-        return (float)(Math.sin((double)a));\n+        return (float)(scalar_sin(a));\n@@ -3954,1 +4217,1 @@\n-        return (float)(StrictMath.sin((double)a));\n+        return (float)(strict_scalar_sin(a));\n@@ -3973,1 +4236,1 @@\n-        return (float)(Math.exp((double)a));\n+        return (float)(scalar_exp(a));\n@@ -3977,1 +4240,1 @@\n-        return (float)(StrictMath.exp((double)a));\n+        return (float)(strict_scalar_exp(a));\n@@ -3996,1 +4259,1 @@\n-        return (float)(Math.log1p((double)a));\n+        return (float)(scalar_log1p(a));\n@@ -4000,1 +4263,1 @@\n-        return (float)(StrictMath.log1p((double)a));\n+        return (float)(strict_scalar_log1p(a));\n@@ -4019,1 +4282,1 @@\n-        return (float)(Math.log((double)a));\n+        return (float)(scalar_log(a));\n@@ -4023,1 +4286,1 @@\n-        return (float)(StrictMath.log((double)a));\n+        return (float)(strict_scalar_log(a));\n@@ -4042,1 +4305,1 @@\n-        return (float)(Math.log10((double)a));\n+        return (float)(scalar_log10(a));\n@@ -4046,1 +4309,1 @@\n-        return (float)(StrictMath.log10((double)a));\n+        return (float)(strict_scalar_log10(a));\n@@ -4065,1 +4328,1 @@\n-        return (float)(Math.expm1((double)a));\n+        return (float)(scalar_expm1(a));\n@@ -4069,1 +4332,1 @@\n-        return (float)(StrictMath.expm1((double)a));\n+        return (float)(strict_scalar_expm1(a));\n@@ -4088,1 +4351,1 @@\n-        return (float)(Math.cos((double)a));\n+        return (float)(scalar_cos(a));\n@@ -4092,1 +4355,1 @@\n-        return (float)(StrictMath.cos((double)a));\n+        return (float)(strict_scalar_cos(a));\n@@ -4111,1 +4374,1 @@\n-        return (float)(Math.tan((double)a));\n+        return (float)(scalar_tan(a));\n@@ -4115,1 +4378,1 @@\n-        return (float)(StrictMath.tan((double)a));\n+        return (float)(strict_scalar_tan(a));\n@@ -4134,1 +4397,1 @@\n-        return (float)(Math.sinh((double)a));\n+        return (float)(scalar_sinh(a));\n@@ -4138,1 +4401,1 @@\n-        return (float)(StrictMath.sinh((double)a));\n+        return (float)(strict_scalar_sinh(a));\n@@ -4157,1 +4420,1 @@\n-        return (float)(Math.cosh((double)a));\n+        return (float)(scalar_cosh(a));\n@@ -4161,1 +4424,1 @@\n-        return (float)(StrictMath.cosh((double)a));\n+        return (float)(strict_scalar_cosh(a));\n@@ -4180,1 +4443,1 @@\n-        return (float)(Math.tanh((double)a));\n+        return (float)(scalar_tanh(a));\n@@ -4184,1 +4447,1 @@\n-        return (float)(StrictMath.tanh((double)a));\n+        return (float)(strict_scalar_tanh(a));\n@@ -4203,1 +4466,1 @@\n-        return (float)(Math.asin((double)a));\n+        return (float)(scalar_asin(a));\n@@ -4207,1 +4470,1 @@\n-        return (float)(StrictMath.asin((double)a));\n+        return (float)(strict_scalar_asin(a));\n@@ -4226,1 +4489,1 @@\n-        return (float)(Math.acos((double)a));\n+        return (float)(scalar_acos(a));\n@@ -4230,1 +4493,1 @@\n-        return (float)(StrictMath.acos((double)a));\n+        return (float)(strict_scalar_acos(a));\n@@ -4249,1 +4512,1 @@\n-        return (float)(Math.atan((double)a));\n+        return (float)(scalar_atan(a));\n@@ -4253,1 +4516,1 @@\n-        return (float)(StrictMath.atan((double)a));\n+        return (float)(strict_scalar_atan(a));\n@@ -4272,1 +4535,1 @@\n-        return (float)(Math.cbrt((double)a));\n+        return (float)(scalar_cbrt(a));\n@@ -4276,1 +4539,1 @@\n-        return (float)(StrictMath.cbrt((double)a));\n+        return (float)(strict_scalar_cbrt(a));\n@@ -4295,1 +4558,1 @@\n-        return (float)(Math.hypot((double)a, (double)b));\n+        return (float)(scalar_hypot(a, b));\n@@ -4299,1 +4562,1 @@\n-        return (float)(StrictMath.hypot((double)a, (double)b));\n+        return (float)(strict_scalar_hypot(a, b));\n@@ -4321,1 +4584,1 @@\n-        return (float)(Math.pow((double)a, (double)b));\n+        return (float)(scalar_pow(a, b));\n@@ -4325,1 +4588,1 @@\n-        return (float)(StrictMath.pow((double)a, (double)b));\n+        return (float)(strict_scalar_pow(a, b));\n@@ -4347,1 +4610,1 @@\n-        return (float)(Math.pow((double)a, (double)b));\n+        return (float)(scalar_pow(a, b));\n@@ -4351,1 +4614,1 @@\n-        return (float)(StrictMath.pow((double)a, (double)b));\n+        return (float)(strict_scalar_pow(a, b));\n@@ -4373,1 +4636,1 @@\n-        return (float)(Math.atan2((double)a, (double)b));\n+        return (float)(scalar_atan2(a, b));\n@@ -4377,1 +4640,1 @@\n-        return (float)(StrictMath.atan2((double)a, (double)b));\n+        return (float)(strict_scalar_atan2(a, b));\n@@ -4429,1 +4692,1 @@\n-        return (float)(Math.fma(a, b, c));\n+        return (float)(scalar_fma(a, b, c));\n@@ -4433,1 +4696,1 @@\n-        return (float)(Math.fma(a, b, c));\n+        return (float)(scalar_fma(a, b, c));\n@@ -4611,1 +4874,1 @@\n-        return (float)(-((float)a));\n+        return (float)(scalar_neg((float)a));\n@@ -4615,1 +4878,1 @@\n-        return (float)(-((float)a));\n+        return (float)(scalar_neg((float)a));\n@@ -4667,1 +4930,1 @@\n-        return (float)(Math.abs((float)a));\n+        return (float)(scalar_abs((float)a));\n@@ -4671,1 +4934,1 @@\n-        return (float)(Math.abs((float)a));\n+        return (float)(scalar_abs((float)a));\n@@ -4723,1 +4986,1 @@\n-        return (float)(Math.sqrt((double)a));\n+        return (float)(scalar_sqrt(a));\n@@ -4727,1 +4990,1 @@\n-        return (float)(Math.sqrt((double)a));\n+        return (float)(scalar_sqrt(a));\n@@ -4789,1 +5052,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -4805,1 +5068,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -4901,1 +5164,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -4942,1 +5205,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -5045,1 +5308,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -5073,1 +5336,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -5087,1 +5350,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -5284,1 +5547,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -5304,1 +5567,1 @@\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5327,1 +5590,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -5341,1 +5604,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -5363,1 +5626,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -5371,1 +5634,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -5378,1 +5641,1 @@\n-        Assert.assertEquals(elsize, Float.SIZE);\n+        AssertEquals(elsize, Float.SIZE);\n@@ -5397,1 +5660,1 @@\n-    static void ElementTypeFloat128VectorTestsSmokeTest() {\n+    static void FloatFloat128VectorTestsSmokeTest() {\n@@ -5432,1 +5695,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":616,"deletions":353,"binary":false,"changes":969,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,45 @@\n+    static FloatVector bcast_vec = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    static void AssertEquals(float actual, float expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(float actual, float expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(float actual, float expected, float delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(float actual, float expected, float delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(float [] actual, float [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(float [] actual, float [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -92,1 +137,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -95,1 +140,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -107,1 +152,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -113,1 +158,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -123,1 +168,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -126,1 +171,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -148,1 +193,1 @@\n-            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);\n+            AssertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);\n@@ -150,1 +195,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);\n+                AssertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);\n@@ -153,2 +198,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, \"at index #\" + i);\n@@ -176,1 +221,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n+            AssertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -178,2 +223,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n-relativeError));\n+                AssertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError));\n@@ -182,2 +226,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -199,1 +243,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -201,1 +245,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -204,2 +248,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -221,1 +265,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -223,1 +267,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -226,2 +270,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -239,1 +283,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -242,1 +286,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -254,1 +298,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -257,1 +301,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -266,1 +310,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -271,1 +315,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -282,1 +326,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -287,1 +331,1 @@\n-                    Assert.assertEquals(r[i + k], (float)0);\n+                    AssertEquals(r[i + k], (float)0);\n@@ -293,1 +337,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -295,1 +339,1 @@\n-                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (float)0, \"at index #\" + idx);\n@@ -307,1 +351,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -310,1 +354,1 @@\n-                        Assert.assertEquals(r[i + j], (float)0);\n+                        AssertEquals(r[i + j], (float)0);\n@@ -317,1 +361,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -319,1 +363,1 @@\n-                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (float)0, \"at index #\" + idx);\n@@ -335,1 +379,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -339,1 +383,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -345,0 +389,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -348,1 +393,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -352,2 +399,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -363,1 +409,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -365,1 +411,1 @@\n-                         Assert.assertEquals(r[i+j], (float)0);\n+                         AssertEquals(r[i+j], (float)0);\n@@ -371,1 +417,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -373,1 +419,1 @@\n-                Assert.assertEquals(r[i+j], (float)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (float)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -379,0 +425,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -382,0 +429,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -383,1 +432,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -385,1 +434,1 @@\n-                         Assert.assertEquals(r[i+j], (float)0);\n+                         AssertEquals(r[i+j], (float)0);\n@@ -389,1 +438,0 @@\n-            int idx = i + j;\n@@ -391,1 +439,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -393,1 +441,1 @@\n-                Assert.assertEquals(r[i+j], (float)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (float)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -407,1 +455,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -410,1 +458,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -431,1 +479,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -434,1 +482,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -437,1 +485,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -440,3 +488,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -457,1 +505,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -460,1 +508,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -463,1 +511,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -466,3 +514,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -476,1 +524,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -479,1 +527,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -487,1 +535,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -490,1 +538,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -498,1 +546,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -501,1 +549,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -510,1 +558,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -513,1 +561,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -526,1 +574,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -529,1 +577,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -541,1 +589,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -544,1 +592,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -556,1 +604,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -559,1 +607,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -574,1 +622,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -577,1 +625,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -590,1 +638,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -594,1 +642,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -608,1 +656,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -612,1 +660,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -634,1 +682,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -638,1 +686,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -652,1 +700,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -656,1 +704,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -676,1 +724,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -679,1 +727,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -691,1 +739,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -694,1 +742,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -703,1 +751,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -706,1 +754,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -716,1 +764,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -719,1 +767,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -735,1 +783,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -739,1 +787,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -756,1 +804,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -760,1 +808,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -771,1 +819,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -775,1 +823,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -792,1 +840,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -796,1 +844,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -849,1 +897,1 @@\n-            Assert.assertTrue(Float.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(Float.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n@@ -888,1 +936,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -894,1 +942,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -915,1 +963,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -921,1 +969,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -936,1 +984,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -942,1 +990,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -963,1 +1011,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -969,1 +1017,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -983,1 +1031,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -989,1 +1037,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1004,1 +1052,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1010,1 +1058,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1025,1 +1073,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1031,1 +1079,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1047,1 +1095,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1053,1 +1101,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1061,0 +1109,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -1077,1 +1129,1 @@\n-            withToString(\"float[-i * 5]\", (int s) -> {\n+            withToString(\"Float[-i * 5]\", (int s) -> {\n@@ -1079,1 +1131,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1081,1 +1133,1 @@\n-            withToString(\"float[i * 5]\", (int s) -> {\n+            withToString(\"Float[i * 5]\", (int s) -> {\n@@ -1083,1 +1135,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1085,1 +1137,1 @@\n-            withToString(\"float[i + 1]\", (int s) -> {\n+            withToString(\"Float[i + 1]\", (int s) -> {\n@@ -1087,1 +1139,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1089,1 +1141,1 @@\n-            withToString(\"float[intCornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Float[intCornerCaseValue(i)]\", (int s) -> {\n@@ -1099,1 +1151,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -1102,1 +1154,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1121,0 +1173,4 @@\n+    static float genValue(long i) {\n+        return (float) i;\n+    }\n+\n@@ -1122,1 +1178,1 @@\n-            withToString(\"float[-i * 5]\", (int s) -> {\n+            withToString(\"Float[-i * 5]\", (int s) -> {\n@@ -1124,1 +1180,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1126,1 +1182,1 @@\n-            withToString(\"float[i * 5]\", (int s) -> {\n+            withToString(\"Float[i * 5]\", (int s) -> {\n@@ -1128,1 +1184,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1130,1 +1186,1 @@\n-            withToString(\"float[i + 1]\", (int s) -> {\n+            withToString(\"Float[i + 1]\", (int s) -> {\n@@ -1132,1 +1188,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1134,1 +1190,1 @@\n-            withToString(\"float[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Float[cornerCaseValue(i)]\", (int s) -> {\n@@ -1145,1 +1201,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -1148,1 +1204,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1156,1 +1212,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                AssertEquals(r[i], (double)(a[i+offs]));\n@@ -1159,1 +1215,1 @@\n-            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1164,1 +1220,1 @@\n-        return  Float.floatToIntBits(e);\n+        return Float.floatToIntBits(e);\n@@ -1168,1 +1224,1 @@\n-            withToString(\"float[-i * 5]\", (int s) -> {\n+            withToString(\"Float[-i * 5]\", (int s) -> {\n@@ -1170,1 +1226,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1172,1 +1228,1 @@\n-            withToString(\"float[i * 5]\", (int s) -> {\n+            withToString(\"Float[i * 5]\", (int s) -> {\n@@ -1174,1 +1230,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1176,1 +1232,1 @@\n-            withToString(\"float[i + 1]\", (int s) -> {\n+            withToString(\"Float[i + 1]\", (int s) -> {\n@@ -1178,1 +1234,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1182,1 +1238,1 @@\n-                            i -> (float)0.01 + ((float)i \/ (i + 1)));\n+                            i -> ((float)0.01 + ((float)i \/ (i + 1))));\n@@ -1186,1 +1242,1 @@\n-                            i -> i % 17 == 0 ? cornerCaseValue(i) : (float)0.01 + ((float)i \/ (i + 1)));\n+                            i -> (i % 17 == 0) ? cornerCaseValue(i) : ((float)0.01 + ((float)i \/ (i + 1))));\n@@ -1510,0 +1566,219 @@\n+    static float multiplicativeIdentity() {\n+        return (float)1;\n+    }\n+\n+\n+    static float scalar_add(float a, float b) {\n+        return (float)(a + b);\n+    }\n+\n+    static float scalar_sub(float a, float b) {\n+        return (float)(a - b);\n+    }\n+\n+    static float scalar_mul(float a, float b) {\n+        return (float)(a * b);\n+    }\n+\n+    static float scalar_min(float a, float b) {\n+        return (float)(Math.min(a, b));\n+    }\n+\n+    static float scalar_max(float a, float b) {\n+        return (float)(Math.max(a, b));\n+    }\n+\n+    static float scalar_div(float a, float b) {\n+        return (float)(a \/ b);\n+    }\n+\n+    static float scalar_fma(float a, float b, float c) {\n+        return (float)(Math.fma(a, b, c));\n+    }\n+\n+    static float scalar_abs(float a) {\n+        return (float)(Math.abs(a));\n+    }\n+\n+    static float scalar_neg(float a) {\n+        return ((float)-a);\n+    }\n+\n+    static float scalar_sin(float a) {\n+        return (float)Math.sin((double)a);\n+    }\n+\n+    static float scalar_exp(float a) {\n+        return (float)Math.exp((double)a);\n+    }\n+\n+    static float scalar_log1p(float a) {\n+        return (float)Math.log1p((double)a);\n+    }\n+\n+    static float scalar_log(float a) {\n+        return (float)Math.log((double)a);\n+    }\n+\n+    static float scalar_log10(float a) {\n+        return (float)Math.log10((double)a);\n+    }\n+\n+    static float scalar_expm1(float a) {\n+        return (float)Math.expm1((double)a);\n+    }\n+\n+    static float scalar_cos(float a) {\n+        return (float)Math.cos((double)a);\n+    }\n+\n+    static float scalar_tan(float a) {\n+        return (float)Math.tan((double)a);\n+    }\n+\n+    static float scalar_sinh(float a) {\n+        return (float)Math.sinh((double)a);\n+    }\n+\n+    static float scalar_cosh(float a) {\n+        return (float)Math.cosh((double)a);\n+    }\n+\n+    static float scalar_tanh(float a) {\n+        return (float)Math.tanh((double)a);\n+    }\n+\n+    static float scalar_asin(float a) {\n+        return (float)Math.asin((double)a);\n+    }\n+\n+    static float scalar_acos(float a) {\n+        return (float)Math.acos((double)a);\n+    }\n+\n+    static float scalar_atan(float a) {\n+        return (float)Math.atan((double)a);\n+    }\n+\n+    static float scalar_cbrt(float a) {\n+        return (float)Math.cbrt((double)a);\n+    }\n+\n+    static float scalar_sqrt(float a) {\n+        return (float)Math.sqrt((double)a);\n+    }\n+\n+    static float scalar_hypot(float a, float b) {\n+        return (float)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static float scalar_pow(float a, float b) {\n+        return (float)Math.pow((double)a, (double)b);\n+    }\n+\n+    static float scalar_atan2(float a, float b) {\n+        return (float)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static float strict_scalar_sin(float a) {\n+        return (float)StrictMath.sin((double)a);\n+    }\n+\n+    static float strict_scalar_exp(float a) {\n+        return (float)StrictMath.exp((double)a);\n+    }\n+\n+    static float strict_scalar_log1p(float a) {\n+        return (float)StrictMath.log1p((double)a);\n+    }\n+\n+    static float strict_scalar_log(float a) {\n+        return (float)StrictMath.log((double)a);\n+    }\n+\n+    static float strict_scalar_log10(float a) {\n+        return (float)StrictMath.log10((double)a);\n+    }\n+\n+    static float strict_scalar_expm1(float a) {\n+        return (float)StrictMath.expm1((double)a);\n+    }\n+\n+    static float strict_scalar_cos(float a) {\n+        return (float)StrictMath.cos((double)a);\n+    }\n+\n+    static float strict_scalar_tan(float a) {\n+        return (float)StrictMath.tan((double)a);\n+    }\n+\n+    static float strict_scalar_sinh(float a) {\n+        return (float)StrictMath.sinh((double)a);\n+    }\n+\n+    static float strict_scalar_cosh(float a) {\n+        return (float)StrictMath.cosh((double)a);\n+    }\n+\n+    static float strict_scalar_tanh(float a) {\n+        return (float)StrictMath.tanh((double)a);\n+    }\n+\n+    static float strict_scalar_asin(float a) {\n+        return (float)StrictMath.asin((double)a);\n+    }\n+\n+    static float strict_scalar_acos(float a) {\n+        return (float)StrictMath.acos((double)a);\n+    }\n+\n+    static float strict_scalar_atan(float a) {\n+        return (float)StrictMath.atan((double)a);\n+    }\n+\n+    static float strict_scalar_cbrt(float a) {\n+        return (float)StrictMath.cbrt((double)a);\n+    }\n+\n+    static float strict_scalar_sqrt(float a) {\n+        return (float)StrictMath.sqrt((double)a);\n+    }\n+\n+    static float strict_scalar_hypot(float a, float b) {\n+        return (float)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static float strict_scalar_pow(float a, float b) {\n+        return (float)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static float strict_scalar_atan2(float a, float b) {\n+        return (float)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static float additiveIdentity() {\n+        return (float)0;\n+    }\n+\n+\n+    static float zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static float maxValue() {\n+        return Float.POSITIVE_INFINITY;\n+    }\n+\n+    static float minValue() {\n+        return Float.NEGATIVE_INFINITY;\n+    }\n+\n+    static boolean isNaN(float a) {\n+        return Float.isNaN(a);\n+    }\n+    static boolean isFinite(float a) {\n+        return Float.isFinite(a);\n+    }\n+    static boolean isInfinite(float a) {\n+        return Float.isInfinite(a);\n+    }\n+\n@@ -1547,1 +1822,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1562,1 +1837,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1568,1 +1843,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1574,1 +1849,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1591,3 +1866,3 @@\n-        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n-        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n-        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+        AssertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        AssertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n@@ -1599,1 +1874,1 @@\n-        Assert.assertEquals(asFloating.species(), SPECIES);\n+        AssertEquals(asFloating.species(), SPECIES);\n@@ -1603,1 +1878,1 @@\n-        return (float)(a + b);\n+        return (float)(scalar_add(a, b));\n@@ -1624,1 +1899,1 @@\n-        return (float)(a + b);\n+        return (float)(scalar_add(a, b));\n@@ -1681,1 +1956,1 @@\n-        return (float)(a - b);\n+        return (float)(scalar_sub(a, b));\n@@ -1702,1 +1977,1 @@\n-        return (float)(a - b);\n+        return (float)(scalar_sub(a, b));\n@@ -1759,1 +2034,1 @@\n-        return (float)(a * b);\n+        return (float)(scalar_mul(a, b));\n@@ -1780,1 +2055,1 @@\n-        return (float)(a * b);\n+        return (float)(scalar_mul(a, b));\n@@ -1837,1 +2112,1 @@\n-        return (float)(a \/ b);\n+        return (float)(scalar_div(a, b));\n@@ -1858,1 +2133,1 @@\n-        return (float)(a \/ b);\n+        return (float)(scalar_div(a, b));\n@@ -1915,1 +2190,1 @@\n-        return (float)(Double.doubleToLongBits(a)!=0?a:b);\n+        return (float)(firstNonZero(a, b));\n@@ -2110,2 +2385,0 @@\n-    static FloatVector bv_MIN = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2120,1 +2393,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -2127,2 +2400,0 @@\n-    static FloatVector bv_min = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2137,1 +2408,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -2144,2 +2415,0 @@\n-    static FloatVector bv_MIN_M = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2156,1 +2425,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -2163,2 +2432,0 @@\n-    static FloatVector bv_MAX = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2173,1 +2440,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -2180,2 +2447,0 @@\n-    static FloatVector bv_max = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2190,1 +2455,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -2197,2 +2462,0 @@\n-    static FloatVector bv_MAX_M = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2209,1 +2472,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -2217,1 +2480,1 @@\n-        return (float)(Math.min(a, b));\n+        return (float)(scalar_min(a, b));\n@@ -2238,1 +2501,1 @@\n-        return (float)(Math.min(a, b));\n+        return (float)(scalar_min(a, b));\n@@ -2257,1 +2520,1 @@\n-        return (float)(Math.max(a, b));\n+        return (float)(scalar_max(a, b));\n@@ -2278,1 +2541,1 @@\n-        return (float)(Math.max(a, b));\n+        return (float)(scalar_max(a, b));\n@@ -2353,1 +2616,1 @@\n-        float res = 0;\n+        float res = additiveIdentity();\n@@ -2355,1 +2618,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -2362,1 +2625,1 @@\n-        float res = 0;\n+        float res = additiveIdentity();\n@@ -2364,1 +2627,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -2374,1 +2637,1 @@\n-        float ra = 0;\n+        float ra = additiveIdentity();\n@@ -2384,1 +2647,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -2387,1 +2650,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -2396,1 +2659,1 @@\n-        float res = 0;\n+        float res = additiveIdentity();\n@@ -2399,1 +2662,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -2406,1 +2669,1 @@\n-        float res = 0;\n+        float res = additiveIdentity();\n@@ -2408,1 +2671,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -2420,1 +2683,1 @@\n-        float ra = 0;\n+        float ra = additiveIdentity();\n@@ -2430,1 +2693,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -2433,1 +2696,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -2442,1 +2705,1 @@\n-        float res = 1;\n+        float res = multiplicativeIdentity();\n@@ -2444,1 +2707,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -2451,1 +2714,1 @@\n-        float res = 1;\n+        float res = multiplicativeIdentity();\n@@ -2453,1 +2716,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -2463,1 +2726,1 @@\n-        float ra = 1;\n+        float ra = multiplicativeIdentity();\n@@ -2473,1 +2736,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -2476,1 +2739,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -2485,1 +2748,1 @@\n-        float res = 1;\n+        float res = multiplicativeIdentity();\n@@ -2488,1 +2751,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -2495,1 +2758,1 @@\n-        float res = 1;\n+        float res = multiplicativeIdentity();\n@@ -2497,1 +2760,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -2509,1 +2772,1 @@\n-        float ra = 1;\n+        float ra = multiplicativeIdentity();\n@@ -2519,1 +2782,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -2522,1 +2785,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -2531,1 +2794,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = maxValue();\n@@ -2533,1 +2796,1 @@\n-            res = (float) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -2540,1 +2803,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = maxValue();\n@@ -2542,1 +2805,1 @@\n-            res = (float) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -2552,1 +2815,1 @@\n-        float ra = Float.POSITIVE_INFINITY;\n+        float ra = maxValue();\n@@ -2562,1 +2825,1 @@\n-            ra = Float.POSITIVE_INFINITY;\n+            ra = maxValue();\n@@ -2565,1 +2828,1 @@\n-                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -2574,1 +2837,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = maxValue();\n@@ -2577,1 +2840,1 @@\n-                res = (float) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -2584,1 +2847,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = maxValue();\n@@ -2586,1 +2849,1 @@\n-            res = (float) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -2598,1 +2861,1 @@\n-        float ra = Float.POSITIVE_INFINITY;\n+        float ra = maxValue();\n@@ -2608,1 +2871,1 @@\n-            ra = Float.POSITIVE_INFINITY;\n+            ra = maxValue();\n@@ -2611,1 +2874,1 @@\n-                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -2620,1 +2883,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = minValue();\n@@ -2622,1 +2885,1 @@\n-            res = (float) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -2629,1 +2892,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = minValue();\n@@ -2631,1 +2894,1 @@\n-            res = (float) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -2641,1 +2904,1 @@\n-        float ra = Float.NEGATIVE_INFINITY;\n+        float ra = minValue();\n@@ -2651,1 +2914,1 @@\n-            ra = Float.NEGATIVE_INFINITY;\n+            ra = minValue();\n@@ -2654,1 +2917,1 @@\n-                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -2663,1 +2926,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = minValue();\n@@ -2666,1 +2929,1 @@\n-                res = (float) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -2673,1 +2936,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = minValue();\n@@ -2675,1 +2938,1 @@\n-            res = (float) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -2687,1 +2950,1 @@\n-        float ra = Float.NEGATIVE_INFINITY;\n+        float ra = minValue();\n@@ -2697,1 +2960,1 @@\n-            ra = Float.NEGATIVE_INFINITY;\n+            ra = minValue();\n@@ -2700,1 +2963,1 @@\n-                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -2709,1 +2972,1 @@\n-        float res = (float) 0;\n+        float res = zeroValue();\n@@ -2718,1 +2981,1 @@\n-        float res = (float) 0;\n+        float res = zeroValue();\n@@ -2730,1 +2993,1 @@\n-        float ra = (float) 0;\n+        float ra = zeroValue();\n@@ -2740,1 +3003,1 @@\n-            ra = (float) 0;\n+            ra = zeroValue();\n@@ -2752,1 +3015,1 @@\n-        float res = (float) 0;\n+        float res = zeroValue();\n@@ -2762,1 +3025,1 @@\n-        float res = (float) 0;\n+        float res = zeroValue();\n@@ -2776,1 +3039,1 @@\n-        float ra = (float) 0;\n+        float ra = zeroValue();\n@@ -2786,1 +3049,1 @@\n-            ra = (float) 0;\n+            ra = zeroValue();\n@@ -2831,1 +3094,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -2851,1 +3114,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -2872,1 +3135,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -2892,1 +3155,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -2899,1 +3162,1 @@\n-        return Float.isFinite(a);\n+        return isFinite(a);\n@@ -2913,1 +3176,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_FINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_FINITE(a[i + j]));\n@@ -2933,1 +3196,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n@@ -2940,1 +3203,1 @@\n-        return Float.isNaN(a);\n+        return isNaN(a);\n@@ -2954,1 +3217,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NAN(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NAN(a[i + j]));\n@@ -2974,1 +3237,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n@@ -2981,1 +3244,1 @@\n-        return Float.isInfinite(a);\n+        return isInfinite(a);\n@@ -2995,1 +3258,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_INFINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_INFINITE(a[i + j]));\n@@ -3015,1 +3278,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n@@ -3034,1 +3297,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3053,1 +3316,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3076,1 +3339,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3095,1 +3358,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3118,1 +3381,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3137,1 +3400,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3156,1 +3419,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3179,1 +3442,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3198,1 +3461,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3221,1 +3484,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3240,1 +3503,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3263,1 +3526,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3282,1 +3545,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3305,1 +3568,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -3322,1 +3585,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -3342,1 +3605,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -3358,1 +3621,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < (float)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (float)((long)b[i])));\n@@ -3378,1 +3641,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < (float)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(float)((long)b[i]))));\n@@ -3394,1 +3657,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -3414,1 +3677,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -3430,1 +3693,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == (float)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (float)((long)b[i])));\n@@ -3450,1 +3713,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == (float)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(float)((long)b[i]))));\n@@ -3731,1 +3994,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -3950,1 +4213,1 @@\n-        return (float)(Math.sin((double)a));\n+        return (float)(scalar_sin(a));\n@@ -3954,1 +4217,1 @@\n-        return (float)(StrictMath.sin((double)a));\n+        return (float)(strict_scalar_sin(a));\n@@ -3973,1 +4236,1 @@\n-        return (float)(Math.exp((double)a));\n+        return (float)(scalar_exp(a));\n@@ -3977,1 +4240,1 @@\n-        return (float)(StrictMath.exp((double)a));\n+        return (float)(strict_scalar_exp(a));\n@@ -3996,1 +4259,1 @@\n-        return (float)(Math.log1p((double)a));\n+        return (float)(scalar_log1p(a));\n@@ -4000,1 +4263,1 @@\n-        return (float)(StrictMath.log1p((double)a));\n+        return (float)(strict_scalar_log1p(a));\n@@ -4019,1 +4282,1 @@\n-        return (float)(Math.log((double)a));\n+        return (float)(scalar_log(a));\n@@ -4023,1 +4286,1 @@\n-        return (float)(StrictMath.log((double)a));\n+        return (float)(strict_scalar_log(a));\n@@ -4042,1 +4305,1 @@\n-        return (float)(Math.log10((double)a));\n+        return (float)(scalar_log10(a));\n@@ -4046,1 +4309,1 @@\n-        return (float)(StrictMath.log10((double)a));\n+        return (float)(strict_scalar_log10(a));\n@@ -4065,1 +4328,1 @@\n-        return (float)(Math.expm1((double)a));\n+        return (float)(scalar_expm1(a));\n@@ -4069,1 +4332,1 @@\n-        return (float)(StrictMath.expm1((double)a));\n+        return (float)(strict_scalar_expm1(a));\n@@ -4088,1 +4351,1 @@\n-        return (float)(Math.cos((double)a));\n+        return (float)(scalar_cos(a));\n@@ -4092,1 +4355,1 @@\n-        return (float)(StrictMath.cos((double)a));\n+        return (float)(strict_scalar_cos(a));\n@@ -4111,1 +4374,1 @@\n-        return (float)(Math.tan((double)a));\n+        return (float)(scalar_tan(a));\n@@ -4115,1 +4378,1 @@\n-        return (float)(StrictMath.tan((double)a));\n+        return (float)(strict_scalar_tan(a));\n@@ -4134,1 +4397,1 @@\n-        return (float)(Math.sinh((double)a));\n+        return (float)(scalar_sinh(a));\n@@ -4138,1 +4401,1 @@\n-        return (float)(StrictMath.sinh((double)a));\n+        return (float)(strict_scalar_sinh(a));\n@@ -4157,1 +4420,1 @@\n-        return (float)(Math.cosh((double)a));\n+        return (float)(scalar_cosh(a));\n@@ -4161,1 +4424,1 @@\n-        return (float)(StrictMath.cosh((double)a));\n+        return (float)(strict_scalar_cosh(a));\n@@ -4180,1 +4443,1 @@\n-        return (float)(Math.tanh((double)a));\n+        return (float)(scalar_tanh(a));\n@@ -4184,1 +4447,1 @@\n-        return (float)(StrictMath.tanh((double)a));\n+        return (float)(strict_scalar_tanh(a));\n@@ -4203,1 +4466,1 @@\n-        return (float)(Math.asin((double)a));\n+        return (float)(scalar_asin(a));\n@@ -4207,1 +4470,1 @@\n-        return (float)(StrictMath.asin((double)a));\n+        return (float)(strict_scalar_asin(a));\n@@ -4226,1 +4489,1 @@\n-        return (float)(Math.acos((double)a));\n+        return (float)(scalar_acos(a));\n@@ -4230,1 +4493,1 @@\n-        return (float)(StrictMath.acos((double)a));\n+        return (float)(strict_scalar_acos(a));\n@@ -4249,1 +4512,1 @@\n-        return (float)(Math.atan((double)a));\n+        return (float)(scalar_atan(a));\n@@ -4253,1 +4516,1 @@\n-        return (float)(StrictMath.atan((double)a));\n+        return (float)(strict_scalar_atan(a));\n@@ -4272,1 +4535,1 @@\n-        return (float)(Math.cbrt((double)a));\n+        return (float)(scalar_cbrt(a));\n@@ -4276,1 +4539,1 @@\n-        return (float)(StrictMath.cbrt((double)a));\n+        return (float)(strict_scalar_cbrt(a));\n@@ -4295,1 +4558,1 @@\n-        return (float)(Math.hypot((double)a, (double)b));\n+        return (float)(scalar_hypot(a, b));\n@@ -4299,1 +4562,1 @@\n-        return (float)(StrictMath.hypot((double)a, (double)b));\n+        return (float)(strict_scalar_hypot(a, b));\n@@ -4321,1 +4584,1 @@\n-        return (float)(Math.pow((double)a, (double)b));\n+        return (float)(scalar_pow(a, b));\n@@ -4325,1 +4588,1 @@\n-        return (float)(StrictMath.pow((double)a, (double)b));\n+        return (float)(strict_scalar_pow(a, b));\n@@ -4347,1 +4610,1 @@\n-        return (float)(Math.pow((double)a, (double)b));\n+        return (float)(scalar_pow(a, b));\n@@ -4351,1 +4614,1 @@\n-        return (float)(StrictMath.pow((double)a, (double)b));\n+        return (float)(strict_scalar_pow(a, b));\n@@ -4373,1 +4636,1 @@\n-        return (float)(Math.atan2((double)a, (double)b));\n+        return (float)(scalar_atan2(a, b));\n@@ -4377,1 +4640,1 @@\n-        return (float)(StrictMath.atan2((double)a, (double)b));\n+        return (float)(strict_scalar_atan2(a, b));\n@@ -4429,1 +4692,1 @@\n-        return (float)(Math.fma(a, b, c));\n+        return (float)(scalar_fma(a, b, c));\n@@ -4433,1 +4696,1 @@\n-        return (float)(Math.fma(a, b, c));\n+        return (float)(scalar_fma(a, b, c));\n@@ -4611,1 +4874,1 @@\n-        return (float)(-((float)a));\n+        return (float)(scalar_neg((float)a));\n@@ -4615,1 +4878,1 @@\n-        return (float)(-((float)a));\n+        return (float)(scalar_neg((float)a));\n@@ -4667,1 +4930,1 @@\n-        return (float)(Math.abs((float)a));\n+        return (float)(scalar_abs((float)a));\n@@ -4671,1 +4934,1 @@\n-        return (float)(Math.abs((float)a));\n+        return (float)(scalar_abs((float)a));\n@@ -4723,1 +4986,1 @@\n-        return (float)(Math.sqrt((double)a));\n+        return (float)(scalar_sqrt(a));\n@@ -4727,1 +4990,1 @@\n-        return (float)(Math.sqrt((double)a));\n+        return (float)(scalar_sqrt(a));\n@@ -4789,1 +5052,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -4805,1 +5068,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -4901,1 +5164,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -4942,1 +5205,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -5045,1 +5308,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -5073,1 +5336,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -5087,1 +5350,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -5284,1 +5547,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -5304,1 +5567,1 @@\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5327,1 +5590,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -5341,1 +5604,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -5363,1 +5626,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -5371,1 +5634,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -5378,1 +5641,1 @@\n-        Assert.assertEquals(elsize, Float.SIZE);\n+        AssertEquals(elsize, Float.SIZE);\n@@ -5397,1 +5660,1 @@\n-    static void ElementTypeFloat256VectorTestsSmokeTest() {\n+    static void FloatFloat256VectorTestsSmokeTest() {\n@@ -5432,1 +5695,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":616,"deletions":353,"binary":false,"changes":969,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,45 @@\n+    static FloatVector bcast_vec = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    static void AssertEquals(float actual, float expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(float actual, float expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(float actual, float expected, float delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(float actual, float expected, float delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(float [] actual, float [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(float [] actual, float [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -92,1 +137,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -95,1 +140,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -107,1 +152,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -113,1 +158,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -123,1 +168,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -126,1 +171,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -148,1 +193,1 @@\n-            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);\n+            AssertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);\n@@ -150,1 +195,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);\n+                AssertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);\n@@ -153,2 +198,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, \"at index #\" + i);\n@@ -176,1 +221,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n+            AssertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -178,2 +223,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n-relativeError));\n+                AssertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError));\n@@ -182,2 +226,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -199,1 +243,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -201,1 +245,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -204,2 +248,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -221,1 +265,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -223,1 +267,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -226,2 +270,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -239,1 +283,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -242,1 +286,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -254,1 +298,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -257,1 +301,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -266,1 +310,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -271,1 +315,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -282,1 +326,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -287,1 +331,1 @@\n-                    Assert.assertEquals(r[i + k], (float)0);\n+                    AssertEquals(r[i + k], (float)0);\n@@ -293,1 +337,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -295,1 +339,1 @@\n-                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (float)0, \"at index #\" + idx);\n@@ -307,1 +351,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -310,1 +354,1 @@\n-                        Assert.assertEquals(r[i + j], (float)0);\n+                        AssertEquals(r[i + j], (float)0);\n@@ -317,1 +361,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -319,1 +363,1 @@\n-                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (float)0, \"at index #\" + idx);\n@@ -335,1 +379,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -339,1 +383,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -345,0 +389,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -348,1 +393,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -352,2 +399,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -363,1 +409,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -365,1 +411,1 @@\n-                         Assert.assertEquals(r[i+j], (float)0);\n+                         AssertEquals(r[i+j], (float)0);\n@@ -371,1 +417,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -373,1 +419,1 @@\n-                Assert.assertEquals(r[i+j], (float)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (float)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -379,0 +425,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -382,0 +429,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -383,1 +432,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -385,1 +434,1 @@\n-                         Assert.assertEquals(r[i+j], (float)0);\n+                         AssertEquals(r[i+j], (float)0);\n@@ -389,1 +438,0 @@\n-            int idx = i + j;\n@@ -391,1 +439,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -393,1 +441,1 @@\n-                Assert.assertEquals(r[i+j], (float)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (float)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -407,1 +455,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -410,1 +458,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -431,1 +479,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -434,1 +482,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -437,1 +485,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -440,3 +488,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -457,1 +505,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -460,1 +508,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -463,1 +511,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -466,3 +514,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -476,1 +524,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -479,1 +527,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -487,1 +535,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -490,1 +538,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -498,1 +546,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -501,1 +549,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -510,1 +558,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -513,1 +561,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -526,1 +574,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -529,1 +577,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -541,1 +589,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -544,1 +592,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -556,1 +604,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -559,1 +607,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -574,1 +622,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -577,1 +625,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -590,1 +638,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -594,1 +642,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -608,1 +656,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -612,1 +660,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -634,1 +682,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -638,1 +686,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -652,1 +700,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -656,1 +704,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -676,1 +724,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -679,1 +727,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -691,1 +739,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -694,1 +742,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -703,1 +751,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -706,1 +754,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -716,1 +764,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -719,1 +767,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -735,1 +783,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -739,1 +787,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -756,1 +804,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -760,1 +808,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -771,1 +819,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -775,1 +823,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -792,1 +840,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -796,1 +844,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -849,1 +897,1 @@\n-            Assert.assertTrue(Float.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(Float.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n@@ -888,1 +936,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -894,1 +942,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -915,1 +963,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -921,1 +969,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -936,1 +984,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -942,1 +990,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -963,1 +1011,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -969,1 +1017,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -983,1 +1031,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -989,1 +1037,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1004,1 +1052,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1010,1 +1058,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1025,1 +1073,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1031,1 +1079,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1047,1 +1095,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1053,1 +1101,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1061,0 +1109,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -1077,1 +1129,1 @@\n-            withToString(\"float[-i * 5]\", (int s) -> {\n+            withToString(\"Float[-i * 5]\", (int s) -> {\n@@ -1079,1 +1131,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1081,1 +1133,1 @@\n-            withToString(\"float[i * 5]\", (int s) -> {\n+            withToString(\"Float[i * 5]\", (int s) -> {\n@@ -1083,1 +1135,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1085,1 +1137,1 @@\n-            withToString(\"float[i + 1]\", (int s) -> {\n+            withToString(\"Float[i + 1]\", (int s) -> {\n@@ -1087,1 +1139,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1089,1 +1141,1 @@\n-            withToString(\"float[intCornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Float[intCornerCaseValue(i)]\", (int s) -> {\n@@ -1099,1 +1151,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -1102,1 +1154,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1121,0 +1173,4 @@\n+    static float genValue(long i) {\n+        return (float) i;\n+    }\n+\n@@ -1122,1 +1178,1 @@\n-            withToString(\"float[-i * 5]\", (int s) -> {\n+            withToString(\"Float[-i * 5]\", (int s) -> {\n@@ -1124,1 +1180,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1126,1 +1182,1 @@\n-            withToString(\"float[i * 5]\", (int s) -> {\n+            withToString(\"Float[i * 5]\", (int s) -> {\n@@ -1128,1 +1184,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1130,1 +1186,1 @@\n-            withToString(\"float[i + 1]\", (int s) -> {\n+            withToString(\"Float[i + 1]\", (int s) -> {\n@@ -1132,1 +1188,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1134,1 +1190,1 @@\n-            withToString(\"float[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Float[cornerCaseValue(i)]\", (int s) -> {\n@@ -1145,1 +1201,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -1148,1 +1204,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1156,1 +1212,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                AssertEquals(r[i], (double)(a[i+offs]));\n@@ -1159,1 +1215,1 @@\n-            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1164,1 +1220,1 @@\n-        return  Float.floatToIntBits(e);\n+        return Float.floatToIntBits(e);\n@@ -1168,1 +1224,1 @@\n-            withToString(\"float[-i * 5]\", (int s) -> {\n+            withToString(\"Float[-i * 5]\", (int s) -> {\n@@ -1170,1 +1226,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1172,1 +1228,1 @@\n-            withToString(\"float[i * 5]\", (int s) -> {\n+            withToString(\"Float[i * 5]\", (int s) -> {\n@@ -1174,1 +1230,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1176,1 +1232,1 @@\n-            withToString(\"float[i + 1]\", (int s) -> {\n+            withToString(\"Float[i + 1]\", (int s) -> {\n@@ -1178,1 +1234,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1182,1 +1238,1 @@\n-                            i -> (float)0.01 + ((float)i \/ (i + 1)));\n+                            i -> ((float)0.01 + ((float)i \/ (i + 1))));\n@@ -1186,1 +1242,1 @@\n-                            i -> i % 17 == 0 ? cornerCaseValue(i) : (float)0.01 + ((float)i \/ (i + 1)));\n+                            i -> (i % 17 == 0) ? cornerCaseValue(i) : ((float)0.01 + ((float)i \/ (i + 1))));\n@@ -1510,0 +1566,219 @@\n+    static float multiplicativeIdentity() {\n+        return (float)1;\n+    }\n+\n+\n+    static float scalar_add(float a, float b) {\n+        return (float)(a + b);\n+    }\n+\n+    static float scalar_sub(float a, float b) {\n+        return (float)(a - b);\n+    }\n+\n+    static float scalar_mul(float a, float b) {\n+        return (float)(a * b);\n+    }\n+\n+    static float scalar_min(float a, float b) {\n+        return (float)(Math.min(a, b));\n+    }\n+\n+    static float scalar_max(float a, float b) {\n+        return (float)(Math.max(a, b));\n+    }\n+\n+    static float scalar_div(float a, float b) {\n+        return (float)(a \/ b);\n+    }\n+\n+    static float scalar_fma(float a, float b, float c) {\n+        return (float)(Math.fma(a, b, c));\n+    }\n+\n+    static float scalar_abs(float a) {\n+        return (float)(Math.abs(a));\n+    }\n+\n+    static float scalar_neg(float a) {\n+        return ((float)-a);\n+    }\n+\n+    static float scalar_sin(float a) {\n+        return (float)Math.sin((double)a);\n+    }\n+\n+    static float scalar_exp(float a) {\n+        return (float)Math.exp((double)a);\n+    }\n+\n+    static float scalar_log1p(float a) {\n+        return (float)Math.log1p((double)a);\n+    }\n+\n+    static float scalar_log(float a) {\n+        return (float)Math.log((double)a);\n+    }\n+\n+    static float scalar_log10(float a) {\n+        return (float)Math.log10((double)a);\n+    }\n+\n+    static float scalar_expm1(float a) {\n+        return (float)Math.expm1((double)a);\n+    }\n+\n+    static float scalar_cos(float a) {\n+        return (float)Math.cos((double)a);\n+    }\n+\n+    static float scalar_tan(float a) {\n+        return (float)Math.tan((double)a);\n+    }\n+\n+    static float scalar_sinh(float a) {\n+        return (float)Math.sinh((double)a);\n+    }\n+\n+    static float scalar_cosh(float a) {\n+        return (float)Math.cosh((double)a);\n+    }\n+\n+    static float scalar_tanh(float a) {\n+        return (float)Math.tanh((double)a);\n+    }\n+\n+    static float scalar_asin(float a) {\n+        return (float)Math.asin((double)a);\n+    }\n+\n+    static float scalar_acos(float a) {\n+        return (float)Math.acos((double)a);\n+    }\n+\n+    static float scalar_atan(float a) {\n+        return (float)Math.atan((double)a);\n+    }\n+\n+    static float scalar_cbrt(float a) {\n+        return (float)Math.cbrt((double)a);\n+    }\n+\n+    static float scalar_sqrt(float a) {\n+        return (float)Math.sqrt((double)a);\n+    }\n+\n+    static float scalar_hypot(float a, float b) {\n+        return (float)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static float scalar_pow(float a, float b) {\n+        return (float)Math.pow((double)a, (double)b);\n+    }\n+\n+    static float scalar_atan2(float a, float b) {\n+        return (float)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static float strict_scalar_sin(float a) {\n+        return (float)StrictMath.sin((double)a);\n+    }\n+\n+    static float strict_scalar_exp(float a) {\n+        return (float)StrictMath.exp((double)a);\n+    }\n+\n+    static float strict_scalar_log1p(float a) {\n+        return (float)StrictMath.log1p((double)a);\n+    }\n+\n+    static float strict_scalar_log(float a) {\n+        return (float)StrictMath.log((double)a);\n+    }\n+\n+    static float strict_scalar_log10(float a) {\n+        return (float)StrictMath.log10((double)a);\n+    }\n+\n+    static float strict_scalar_expm1(float a) {\n+        return (float)StrictMath.expm1((double)a);\n+    }\n+\n+    static float strict_scalar_cos(float a) {\n+        return (float)StrictMath.cos((double)a);\n+    }\n+\n+    static float strict_scalar_tan(float a) {\n+        return (float)StrictMath.tan((double)a);\n+    }\n+\n+    static float strict_scalar_sinh(float a) {\n+        return (float)StrictMath.sinh((double)a);\n+    }\n+\n+    static float strict_scalar_cosh(float a) {\n+        return (float)StrictMath.cosh((double)a);\n+    }\n+\n+    static float strict_scalar_tanh(float a) {\n+        return (float)StrictMath.tanh((double)a);\n+    }\n+\n+    static float strict_scalar_asin(float a) {\n+        return (float)StrictMath.asin((double)a);\n+    }\n+\n+    static float strict_scalar_acos(float a) {\n+        return (float)StrictMath.acos((double)a);\n+    }\n+\n+    static float strict_scalar_atan(float a) {\n+        return (float)StrictMath.atan((double)a);\n+    }\n+\n+    static float strict_scalar_cbrt(float a) {\n+        return (float)StrictMath.cbrt((double)a);\n+    }\n+\n+    static float strict_scalar_sqrt(float a) {\n+        return (float)StrictMath.sqrt((double)a);\n+    }\n+\n+    static float strict_scalar_hypot(float a, float b) {\n+        return (float)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static float strict_scalar_pow(float a, float b) {\n+        return (float)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static float strict_scalar_atan2(float a, float b) {\n+        return (float)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static float additiveIdentity() {\n+        return (float)0;\n+    }\n+\n+\n+    static float zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static float maxValue() {\n+        return Float.POSITIVE_INFINITY;\n+    }\n+\n+    static float minValue() {\n+        return Float.NEGATIVE_INFINITY;\n+    }\n+\n+    static boolean isNaN(float a) {\n+        return Float.isNaN(a);\n+    }\n+    static boolean isFinite(float a) {\n+        return Float.isFinite(a);\n+    }\n+    static boolean isInfinite(float a) {\n+        return Float.isInfinite(a);\n+    }\n+\n@@ -1547,1 +1822,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1562,1 +1837,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1568,1 +1843,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1574,1 +1849,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1591,3 +1866,3 @@\n-        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n-        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n-        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+        AssertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        AssertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n@@ -1599,1 +1874,1 @@\n-        Assert.assertEquals(asFloating.species(), SPECIES);\n+        AssertEquals(asFloating.species(), SPECIES);\n@@ -1603,1 +1878,1 @@\n-        return (float)(a + b);\n+        return (float)(scalar_add(a, b));\n@@ -1624,1 +1899,1 @@\n-        return (float)(a + b);\n+        return (float)(scalar_add(a, b));\n@@ -1681,1 +1956,1 @@\n-        return (float)(a - b);\n+        return (float)(scalar_sub(a, b));\n@@ -1702,1 +1977,1 @@\n-        return (float)(a - b);\n+        return (float)(scalar_sub(a, b));\n@@ -1759,1 +2034,1 @@\n-        return (float)(a * b);\n+        return (float)(scalar_mul(a, b));\n@@ -1780,1 +2055,1 @@\n-        return (float)(a * b);\n+        return (float)(scalar_mul(a, b));\n@@ -1837,1 +2112,1 @@\n-        return (float)(a \/ b);\n+        return (float)(scalar_div(a, b));\n@@ -1858,1 +2133,1 @@\n-        return (float)(a \/ b);\n+        return (float)(scalar_div(a, b));\n@@ -1915,1 +2190,1 @@\n-        return (float)(Double.doubleToLongBits(a)!=0?a:b);\n+        return (float)(firstNonZero(a, b));\n@@ -2110,2 +2385,0 @@\n-    static FloatVector bv_MIN = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2120,1 +2393,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -2127,2 +2400,0 @@\n-    static FloatVector bv_min = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2137,1 +2408,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -2144,2 +2415,0 @@\n-    static FloatVector bv_MIN_M = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2156,1 +2425,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -2163,2 +2432,0 @@\n-    static FloatVector bv_MAX = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2173,1 +2440,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -2180,2 +2447,0 @@\n-    static FloatVector bv_max = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2190,1 +2455,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -2197,2 +2462,0 @@\n-    static FloatVector bv_MAX_M = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2209,1 +2472,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -2217,1 +2480,1 @@\n-        return (float)(Math.min(a, b));\n+        return (float)(scalar_min(a, b));\n@@ -2238,1 +2501,1 @@\n-        return (float)(Math.min(a, b));\n+        return (float)(scalar_min(a, b));\n@@ -2257,1 +2520,1 @@\n-        return (float)(Math.max(a, b));\n+        return (float)(scalar_max(a, b));\n@@ -2278,1 +2541,1 @@\n-        return (float)(Math.max(a, b));\n+        return (float)(scalar_max(a, b));\n@@ -2353,1 +2616,1 @@\n-        float res = 0;\n+        float res = additiveIdentity();\n@@ -2355,1 +2618,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -2362,1 +2625,1 @@\n-        float res = 0;\n+        float res = additiveIdentity();\n@@ -2364,1 +2627,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -2374,1 +2637,1 @@\n-        float ra = 0;\n+        float ra = additiveIdentity();\n@@ -2384,1 +2647,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -2387,1 +2650,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -2396,1 +2659,1 @@\n-        float res = 0;\n+        float res = additiveIdentity();\n@@ -2399,1 +2662,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -2406,1 +2669,1 @@\n-        float res = 0;\n+        float res = additiveIdentity();\n@@ -2408,1 +2671,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -2420,1 +2683,1 @@\n-        float ra = 0;\n+        float ra = additiveIdentity();\n@@ -2430,1 +2693,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -2433,1 +2696,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -2442,1 +2705,1 @@\n-        float res = 1;\n+        float res = multiplicativeIdentity();\n@@ -2444,1 +2707,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -2451,1 +2714,1 @@\n-        float res = 1;\n+        float res = multiplicativeIdentity();\n@@ -2453,1 +2716,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -2463,1 +2726,1 @@\n-        float ra = 1;\n+        float ra = multiplicativeIdentity();\n@@ -2473,1 +2736,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -2476,1 +2739,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -2485,1 +2748,1 @@\n-        float res = 1;\n+        float res = multiplicativeIdentity();\n@@ -2488,1 +2751,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -2495,1 +2758,1 @@\n-        float res = 1;\n+        float res = multiplicativeIdentity();\n@@ -2497,1 +2760,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -2509,1 +2772,1 @@\n-        float ra = 1;\n+        float ra = multiplicativeIdentity();\n@@ -2519,1 +2782,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -2522,1 +2785,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -2531,1 +2794,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = maxValue();\n@@ -2533,1 +2796,1 @@\n-            res = (float) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -2540,1 +2803,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = maxValue();\n@@ -2542,1 +2805,1 @@\n-            res = (float) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -2552,1 +2815,1 @@\n-        float ra = Float.POSITIVE_INFINITY;\n+        float ra = maxValue();\n@@ -2562,1 +2825,1 @@\n-            ra = Float.POSITIVE_INFINITY;\n+            ra = maxValue();\n@@ -2565,1 +2828,1 @@\n-                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -2574,1 +2837,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = maxValue();\n@@ -2577,1 +2840,1 @@\n-                res = (float) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -2584,1 +2847,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = maxValue();\n@@ -2586,1 +2849,1 @@\n-            res = (float) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -2598,1 +2861,1 @@\n-        float ra = Float.POSITIVE_INFINITY;\n+        float ra = maxValue();\n@@ -2608,1 +2871,1 @@\n-            ra = Float.POSITIVE_INFINITY;\n+            ra = maxValue();\n@@ -2611,1 +2874,1 @@\n-                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -2620,1 +2883,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = minValue();\n@@ -2622,1 +2885,1 @@\n-            res = (float) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -2629,1 +2892,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = minValue();\n@@ -2631,1 +2894,1 @@\n-            res = (float) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -2641,1 +2904,1 @@\n-        float ra = Float.NEGATIVE_INFINITY;\n+        float ra = minValue();\n@@ -2651,1 +2914,1 @@\n-            ra = Float.NEGATIVE_INFINITY;\n+            ra = minValue();\n@@ -2654,1 +2917,1 @@\n-                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -2663,1 +2926,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = minValue();\n@@ -2666,1 +2929,1 @@\n-                res = (float) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -2673,1 +2936,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = minValue();\n@@ -2675,1 +2938,1 @@\n-            res = (float) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -2687,1 +2950,1 @@\n-        float ra = Float.NEGATIVE_INFINITY;\n+        float ra = minValue();\n@@ -2697,1 +2960,1 @@\n-            ra = Float.NEGATIVE_INFINITY;\n+            ra = minValue();\n@@ -2700,1 +2963,1 @@\n-                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -2709,1 +2972,1 @@\n-        float res = (float) 0;\n+        float res = zeroValue();\n@@ -2718,1 +2981,1 @@\n-        float res = (float) 0;\n+        float res = zeroValue();\n@@ -2730,1 +2993,1 @@\n-        float ra = (float) 0;\n+        float ra = zeroValue();\n@@ -2740,1 +3003,1 @@\n-            ra = (float) 0;\n+            ra = zeroValue();\n@@ -2752,1 +3015,1 @@\n-        float res = (float) 0;\n+        float res = zeroValue();\n@@ -2762,1 +3025,1 @@\n-        float res = (float) 0;\n+        float res = zeroValue();\n@@ -2776,1 +3039,1 @@\n-        float ra = (float) 0;\n+        float ra = zeroValue();\n@@ -2786,1 +3049,1 @@\n-            ra = (float) 0;\n+            ra = zeroValue();\n@@ -2831,1 +3094,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -2851,1 +3114,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -2872,1 +3135,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -2892,1 +3155,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -2899,1 +3162,1 @@\n-        return Float.isFinite(a);\n+        return isFinite(a);\n@@ -2913,1 +3176,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_FINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_FINITE(a[i + j]));\n@@ -2933,1 +3196,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n@@ -2940,1 +3203,1 @@\n-        return Float.isNaN(a);\n+        return isNaN(a);\n@@ -2954,1 +3217,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NAN(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NAN(a[i + j]));\n@@ -2974,1 +3237,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n@@ -2981,1 +3244,1 @@\n-        return Float.isInfinite(a);\n+        return isInfinite(a);\n@@ -2995,1 +3258,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_INFINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_INFINITE(a[i + j]));\n@@ -3015,1 +3278,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n@@ -3034,1 +3297,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3053,1 +3316,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3076,1 +3339,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3095,1 +3358,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3118,1 +3381,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3137,1 +3400,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3156,1 +3419,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3179,1 +3442,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3198,1 +3461,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3221,1 +3484,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3240,1 +3503,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3263,1 +3526,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3282,1 +3545,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3305,1 +3568,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -3322,1 +3585,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -3342,1 +3605,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -3358,1 +3621,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < (float)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (float)((long)b[i])));\n@@ -3378,1 +3641,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < (float)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(float)((long)b[i]))));\n@@ -3394,1 +3657,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -3414,1 +3677,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -3430,1 +3693,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == (float)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (float)((long)b[i])));\n@@ -3450,1 +3713,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == (float)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(float)((long)b[i]))));\n@@ -3731,1 +3994,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -3950,1 +4213,1 @@\n-        return (float)(Math.sin((double)a));\n+        return (float)(scalar_sin(a));\n@@ -3954,1 +4217,1 @@\n-        return (float)(StrictMath.sin((double)a));\n+        return (float)(strict_scalar_sin(a));\n@@ -3973,1 +4236,1 @@\n-        return (float)(Math.exp((double)a));\n+        return (float)(scalar_exp(a));\n@@ -3977,1 +4240,1 @@\n-        return (float)(StrictMath.exp((double)a));\n+        return (float)(strict_scalar_exp(a));\n@@ -3996,1 +4259,1 @@\n-        return (float)(Math.log1p((double)a));\n+        return (float)(scalar_log1p(a));\n@@ -4000,1 +4263,1 @@\n-        return (float)(StrictMath.log1p((double)a));\n+        return (float)(strict_scalar_log1p(a));\n@@ -4019,1 +4282,1 @@\n-        return (float)(Math.log((double)a));\n+        return (float)(scalar_log(a));\n@@ -4023,1 +4286,1 @@\n-        return (float)(StrictMath.log((double)a));\n+        return (float)(strict_scalar_log(a));\n@@ -4042,1 +4305,1 @@\n-        return (float)(Math.log10((double)a));\n+        return (float)(scalar_log10(a));\n@@ -4046,1 +4309,1 @@\n-        return (float)(StrictMath.log10((double)a));\n+        return (float)(strict_scalar_log10(a));\n@@ -4065,1 +4328,1 @@\n-        return (float)(Math.expm1((double)a));\n+        return (float)(scalar_expm1(a));\n@@ -4069,1 +4332,1 @@\n-        return (float)(StrictMath.expm1((double)a));\n+        return (float)(strict_scalar_expm1(a));\n@@ -4088,1 +4351,1 @@\n-        return (float)(Math.cos((double)a));\n+        return (float)(scalar_cos(a));\n@@ -4092,1 +4355,1 @@\n-        return (float)(StrictMath.cos((double)a));\n+        return (float)(strict_scalar_cos(a));\n@@ -4111,1 +4374,1 @@\n-        return (float)(Math.tan((double)a));\n+        return (float)(scalar_tan(a));\n@@ -4115,1 +4378,1 @@\n-        return (float)(StrictMath.tan((double)a));\n+        return (float)(strict_scalar_tan(a));\n@@ -4134,1 +4397,1 @@\n-        return (float)(Math.sinh((double)a));\n+        return (float)(scalar_sinh(a));\n@@ -4138,1 +4401,1 @@\n-        return (float)(StrictMath.sinh((double)a));\n+        return (float)(strict_scalar_sinh(a));\n@@ -4157,1 +4420,1 @@\n-        return (float)(Math.cosh((double)a));\n+        return (float)(scalar_cosh(a));\n@@ -4161,1 +4424,1 @@\n-        return (float)(StrictMath.cosh((double)a));\n+        return (float)(strict_scalar_cosh(a));\n@@ -4180,1 +4443,1 @@\n-        return (float)(Math.tanh((double)a));\n+        return (float)(scalar_tanh(a));\n@@ -4184,1 +4447,1 @@\n-        return (float)(StrictMath.tanh((double)a));\n+        return (float)(strict_scalar_tanh(a));\n@@ -4203,1 +4466,1 @@\n-        return (float)(Math.asin((double)a));\n+        return (float)(scalar_asin(a));\n@@ -4207,1 +4470,1 @@\n-        return (float)(StrictMath.asin((double)a));\n+        return (float)(strict_scalar_asin(a));\n@@ -4226,1 +4489,1 @@\n-        return (float)(Math.acos((double)a));\n+        return (float)(scalar_acos(a));\n@@ -4230,1 +4493,1 @@\n-        return (float)(StrictMath.acos((double)a));\n+        return (float)(strict_scalar_acos(a));\n@@ -4249,1 +4512,1 @@\n-        return (float)(Math.atan((double)a));\n+        return (float)(scalar_atan(a));\n@@ -4253,1 +4516,1 @@\n-        return (float)(StrictMath.atan((double)a));\n+        return (float)(strict_scalar_atan(a));\n@@ -4272,1 +4535,1 @@\n-        return (float)(Math.cbrt((double)a));\n+        return (float)(scalar_cbrt(a));\n@@ -4276,1 +4539,1 @@\n-        return (float)(StrictMath.cbrt((double)a));\n+        return (float)(strict_scalar_cbrt(a));\n@@ -4295,1 +4558,1 @@\n-        return (float)(Math.hypot((double)a, (double)b));\n+        return (float)(scalar_hypot(a, b));\n@@ -4299,1 +4562,1 @@\n-        return (float)(StrictMath.hypot((double)a, (double)b));\n+        return (float)(strict_scalar_hypot(a, b));\n@@ -4321,1 +4584,1 @@\n-        return (float)(Math.pow((double)a, (double)b));\n+        return (float)(scalar_pow(a, b));\n@@ -4325,1 +4588,1 @@\n-        return (float)(StrictMath.pow((double)a, (double)b));\n+        return (float)(strict_scalar_pow(a, b));\n@@ -4347,1 +4610,1 @@\n-        return (float)(Math.pow((double)a, (double)b));\n+        return (float)(scalar_pow(a, b));\n@@ -4351,1 +4614,1 @@\n-        return (float)(StrictMath.pow((double)a, (double)b));\n+        return (float)(strict_scalar_pow(a, b));\n@@ -4373,1 +4636,1 @@\n-        return (float)(Math.atan2((double)a, (double)b));\n+        return (float)(scalar_atan2(a, b));\n@@ -4377,1 +4640,1 @@\n-        return (float)(StrictMath.atan2((double)a, (double)b));\n+        return (float)(strict_scalar_atan2(a, b));\n@@ -4429,1 +4692,1 @@\n-        return (float)(Math.fma(a, b, c));\n+        return (float)(scalar_fma(a, b, c));\n@@ -4433,1 +4696,1 @@\n-        return (float)(Math.fma(a, b, c));\n+        return (float)(scalar_fma(a, b, c));\n@@ -4611,1 +4874,1 @@\n-        return (float)(-((float)a));\n+        return (float)(scalar_neg((float)a));\n@@ -4615,1 +4878,1 @@\n-        return (float)(-((float)a));\n+        return (float)(scalar_neg((float)a));\n@@ -4667,1 +4930,1 @@\n-        return (float)(Math.abs((float)a));\n+        return (float)(scalar_abs((float)a));\n@@ -4671,1 +4934,1 @@\n-        return (float)(Math.abs((float)a));\n+        return (float)(scalar_abs((float)a));\n@@ -4723,1 +4986,1 @@\n-        return (float)(Math.sqrt((double)a));\n+        return (float)(scalar_sqrt(a));\n@@ -4727,1 +4990,1 @@\n-        return (float)(Math.sqrt((double)a));\n+        return (float)(scalar_sqrt(a));\n@@ -4789,1 +5052,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -4805,1 +5068,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -4901,1 +5164,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -4942,1 +5205,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -5045,1 +5308,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -5073,1 +5336,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -5087,1 +5350,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -5284,1 +5547,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -5304,1 +5567,1 @@\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5327,1 +5590,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -5341,1 +5604,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -5363,1 +5626,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -5371,1 +5634,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -5378,1 +5641,1 @@\n-        Assert.assertEquals(elsize, Float.SIZE);\n+        AssertEquals(elsize, Float.SIZE);\n@@ -5397,1 +5660,1 @@\n-    static void ElementTypeFloat512VectorTestsSmokeTest() {\n+    static void FloatFloat512VectorTestsSmokeTest() {\n@@ -5432,1 +5695,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":616,"deletions":353,"binary":false,"changes":969,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,45 @@\n+    static FloatVector bcast_vec = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    static void AssertEquals(float actual, float expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(float actual, float expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(float actual, float expected, float delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(float actual, float expected, float delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(float [] actual, float [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(float [] actual, float [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -92,1 +137,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -95,1 +140,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -107,1 +152,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -113,1 +158,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -123,1 +168,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -126,1 +171,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -148,1 +193,1 @@\n-            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);\n+            AssertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);\n@@ -150,1 +195,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);\n+                AssertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);\n@@ -153,2 +198,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, \"at index #\" + i);\n@@ -176,1 +221,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n+            AssertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -178,2 +223,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n-relativeError));\n+                AssertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError));\n@@ -182,2 +226,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -199,1 +243,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -201,1 +245,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -204,2 +248,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -221,1 +265,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -223,1 +267,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -226,2 +270,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -239,1 +283,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -242,1 +286,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -254,1 +298,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -257,1 +301,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -266,1 +310,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -271,1 +315,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -282,1 +326,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -287,1 +331,1 @@\n-                    Assert.assertEquals(r[i + k], (float)0);\n+                    AssertEquals(r[i + k], (float)0);\n@@ -293,1 +337,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -295,1 +339,1 @@\n-                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (float)0, \"at index #\" + idx);\n@@ -307,1 +351,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -310,1 +354,1 @@\n-                        Assert.assertEquals(r[i + j], (float)0);\n+                        AssertEquals(r[i + j], (float)0);\n@@ -317,1 +361,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -319,1 +363,1 @@\n-                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (float)0, \"at index #\" + idx);\n@@ -335,1 +379,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -339,1 +383,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -345,0 +389,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -348,1 +393,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -352,2 +399,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -363,1 +409,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -365,1 +411,1 @@\n-                         Assert.assertEquals(r[i+j], (float)0);\n+                         AssertEquals(r[i+j], (float)0);\n@@ -371,1 +417,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -373,1 +419,1 @@\n-                Assert.assertEquals(r[i+j], (float)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (float)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -379,0 +425,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -382,0 +429,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -383,1 +432,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -385,1 +434,1 @@\n-                         Assert.assertEquals(r[i+j], (float)0);\n+                         AssertEquals(r[i+j], (float)0);\n@@ -389,1 +438,0 @@\n-            int idx = i + j;\n@@ -391,1 +439,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -393,1 +441,1 @@\n-                Assert.assertEquals(r[i+j], (float)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (float)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -407,1 +455,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -410,1 +458,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -431,1 +479,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -434,1 +482,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -437,1 +485,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -440,3 +488,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -457,1 +505,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -460,1 +508,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -463,1 +511,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -466,3 +514,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -476,1 +524,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -479,1 +527,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -487,1 +535,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -490,1 +538,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -498,1 +546,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -501,1 +549,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -510,1 +558,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -513,1 +561,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -526,1 +574,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -529,1 +577,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -541,1 +589,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -544,1 +592,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -556,1 +604,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -559,1 +607,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -574,1 +622,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -577,1 +625,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -590,1 +638,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -594,1 +642,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -608,1 +656,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -612,1 +660,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -634,1 +682,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -638,1 +686,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -652,1 +700,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -656,1 +704,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -676,1 +724,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -679,1 +727,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -691,1 +739,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -694,1 +742,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -703,1 +751,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -706,1 +754,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -716,1 +764,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -719,1 +767,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -735,1 +783,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -739,1 +787,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -756,1 +804,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -760,1 +808,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -771,1 +819,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -775,1 +823,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -792,1 +840,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -796,1 +844,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -849,1 +897,1 @@\n-            Assert.assertTrue(Float.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(Float.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n@@ -888,1 +936,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -894,1 +942,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -915,1 +963,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -921,1 +969,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -936,1 +984,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -942,1 +990,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -963,1 +1011,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -969,1 +1017,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -983,1 +1031,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -989,1 +1037,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1004,1 +1052,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1010,1 +1058,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1025,1 +1073,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1031,1 +1079,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1047,1 +1095,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1053,1 +1101,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1061,0 +1109,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -1077,1 +1129,1 @@\n-            withToString(\"float[-i * 5]\", (int s) -> {\n+            withToString(\"Float[-i * 5]\", (int s) -> {\n@@ -1079,1 +1131,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1081,1 +1133,1 @@\n-            withToString(\"float[i * 5]\", (int s) -> {\n+            withToString(\"Float[i * 5]\", (int s) -> {\n@@ -1083,1 +1135,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1085,1 +1137,1 @@\n-            withToString(\"float[i + 1]\", (int s) -> {\n+            withToString(\"Float[i + 1]\", (int s) -> {\n@@ -1087,1 +1139,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1089,1 +1141,1 @@\n-            withToString(\"float[intCornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Float[intCornerCaseValue(i)]\", (int s) -> {\n@@ -1099,1 +1151,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -1102,1 +1154,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1121,0 +1173,4 @@\n+    static float genValue(long i) {\n+        return (float) i;\n+    }\n+\n@@ -1122,1 +1178,1 @@\n-            withToString(\"float[-i * 5]\", (int s) -> {\n+            withToString(\"Float[-i * 5]\", (int s) -> {\n@@ -1124,1 +1180,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1126,1 +1182,1 @@\n-            withToString(\"float[i * 5]\", (int s) -> {\n+            withToString(\"Float[i * 5]\", (int s) -> {\n@@ -1128,1 +1184,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1130,1 +1186,1 @@\n-            withToString(\"float[i + 1]\", (int s) -> {\n+            withToString(\"Float[i + 1]\", (int s) -> {\n@@ -1132,1 +1188,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1134,1 +1190,1 @@\n-            withToString(\"float[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Float[cornerCaseValue(i)]\", (int s) -> {\n@@ -1145,1 +1201,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -1148,1 +1204,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1156,1 +1212,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                AssertEquals(r[i], (double)(a[i+offs]));\n@@ -1159,1 +1215,1 @@\n-            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1164,1 +1220,1 @@\n-        return  Float.floatToIntBits(e);\n+        return Float.floatToIntBits(e);\n@@ -1168,1 +1224,1 @@\n-            withToString(\"float[-i * 5]\", (int s) -> {\n+            withToString(\"Float[-i * 5]\", (int s) -> {\n@@ -1170,1 +1226,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1172,1 +1228,1 @@\n-            withToString(\"float[i * 5]\", (int s) -> {\n+            withToString(\"Float[i * 5]\", (int s) -> {\n@@ -1174,1 +1230,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1176,1 +1232,1 @@\n-            withToString(\"float[i + 1]\", (int s) -> {\n+            withToString(\"Float[i + 1]\", (int s) -> {\n@@ -1178,1 +1234,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1182,1 +1238,1 @@\n-                            i -> (float)0.01 + ((float)i \/ (i + 1)));\n+                            i -> ((float)0.01 + ((float)i \/ (i + 1))));\n@@ -1186,1 +1242,1 @@\n-                            i -> i % 17 == 0 ? cornerCaseValue(i) : (float)0.01 + ((float)i \/ (i + 1)));\n+                            i -> (i % 17 == 0) ? cornerCaseValue(i) : ((float)0.01 + ((float)i \/ (i + 1))));\n@@ -1510,0 +1566,219 @@\n+    static float multiplicativeIdentity() {\n+        return (float)1;\n+    }\n+\n+\n+    static float scalar_add(float a, float b) {\n+        return (float)(a + b);\n+    }\n+\n+    static float scalar_sub(float a, float b) {\n+        return (float)(a - b);\n+    }\n+\n+    static float scalar_mul(float a, float b) {\n+        return (float)(a * b);\n+    }\n+\n+    static float scalar_min(float a, float b) {\n+        return (float)(Math.min(a, b));\n+    }\n+\n+    static float scalar_max(float a, float b) {\n+        return (float)(Math.max(a, b));\n+    }\n+\n+    static float scalar_div(float a, float b) {\n+        return (float)(a \/ b);\n+    }\n+\n+    static float scalar_fma(float a, float b, float c) {\n+        return (float)(Math.fma(a, b, c));\n+    }\n+\n+    static float scalar_abs(float a) {\n+        return (float)(Math.abs(a));\n+    }\n+\n+    static float scalar_neg(float a) {\n+        return ((float)-a);\n+    }\n+\n+    static float scalar_sin(float a) {\n+        return (float)Math.sin((double)a);\n+    }\n+\n+    static float scalar_exp(float a) {\n+        return (float)Math.exp((double)a);\n+    }\n+\n+    static float scalar_log1p(float a) {\n+        return (float)Math.log1p((double)a);\n+    }\n+\n+    static float scalar_log(float a) {\n+        return (float)Math.log((double)a);\n+    }\n+\n+    static float scalar_log10(float a) {\n+        return (float)Math.log10((double)a);\n+    }\n+\n+    static float scalar_expm1(float a) {\n+        return (float)Math.expm1((double)a);\n+    }\n+\n+    static float scalar_cos(float a) {\n+        return (float)Math.cos((double)a);\n+    }\n+\n+    static float scalar_tan(float a) {\n+        return (float)Math.tan((double)a);\n+    }\n+\n+    static float scalar_sinh(float a) {\n+        return (float)Math.sinh((double)a);\n+    }\n+\n+    static float scalar_cosh(float a) {\n+        return (float)Math.cosh((double)a);\n+    }\n+\n+    static float scalar_tanh(float a) {\n+        return (float)Math.tanh((double)a);\n+    }\n+\n+    static float scalar_asin(float a) {\n+        return (float)Math.asin((double)a);\n+    }\n+\n+    static float scalar_acos(float a) {\n+        return (float)Math.acos((double)a);\n+    }\n+\n+    static float scalar_atan(float a) {\n+        return (float)Math.atan((double)a);\n+    }\n+\n+    static float scalar_cbrt(float a) {\n+        return (float)Math.cbrt((double)a);\n+    }\n+\n+    static float scalar_sqrt(float a) {\n+        return (float)Math.sqrt((double)a);\n+    }\n+\n+    static float scalar_hypot(float a, float b) {\n+        return (float)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static float scalar_pow(float a, float b) {\n+        return (float)Math.pow((double)a, (double)b);\n+    }\n+\n+    static float scalar_atan2(float a, float b) {\n+        return (float)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static float strict_scalar_sin(float a) {\n+        return (float)StrictMath.sin((double)a);\n+    }\n+\n+    static float strict_scalar_exp(float a) {\n+        return (float)StrictMath.exp((double)a);\n+    }\n+\n+    static float strict_scalar_log1p(float a) {\n+        return (float)StrictMath.log1p((double)a);\n+    }\n+\n+    static float strict_scalar_log(float a) {\n+        return (float)StrictMath.log((double)a);\n+    }\n+\n+    static float strict_scalar_log10(float a) {\n+        return (float)StrictMath.log10((double)a);\n+    }\n+\n+    static float strict_scalar_expm1(float a) {\n+        return (float)StrictMath.expm1((double)a);\n+    }\n+\n+    static float strict_scalar_cos(float a) {\n+        return (float)StrictMath.cos((double)a);\n+    }\n+\n+    static float strict_scalar_tan(float a) {\n+        return (float)StrictMath.tan((double)a);\n+    }\n+\n+    static float strict_scalar_sinh(float a) {\n+        return (float)StrictMath.sinh((double)a);\n+    }\n+\n+    static float strict_scalar_cosh(float a) {\n+        return (float)StrictMath.cosh((double)a);\n+    }\n+\n+    static float strict_scalar_tanh(float a) {\n+        return (float)StrictMath.tanh((double)a);\n+    }\n+\n+    static float strict_scalar_asin(float a) {\n+        return (float)StrictMath.asin((double)a);\n+    }\n+\n+    static float strict_scalar_acos(float a) {\n+        return (float)StrictMath.acos((double)a);\n+    }\n+\n+    static float strict_scalar_atan(float a) {\n+        return (float)StrictMath.atan((double)a);\n+    }\n+\n+    static float strict_scalar_cbrt(float a) {\n+        return (float)StrictMath.cbrt((double)a);\n+    }\n+\n+    static float strict_scalar_sqrt(float a) {\n+        return (float)StrictMath.sqrt((double)a);\n+    }\n+\n+    static float strict_scalar_hypot(float a, float b) {\n+        return (float)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static float strict_scalar_pow(float a, float b) {\n+        return (float)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static float strict_scalar_atan2(float a, float b) {\n+        return (float)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static float additiveIdentity() {\n+        return (float)0;\n+    }\n+\n+\n+    static float zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static float maxValue() {\n+        return Float.POSITIVE_INFINITY;\n+    }\n+\n+    static float minValue() {\n+        return Float.NEGATIVE_INFINITY;\n+    }\n+\n+    static boolean isNaN(float a) {\n+        return Float.isNaN(a);\n+    }\n+    static boolean isFinite(float a) {\n+        return Float.isFinite(a);\n+    }\n+    static boolean isInfinite(float a) {\n+        return Float.isInfinite(a);\n+    }\n+\n@@ -1547,1 +1822,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1562,1 +1837,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1568,1 +1843,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1574,1 +1849,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1591,3 +1866,3 @@\n-        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n-        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n-        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+        AssertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        AssertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n@@ -1599,1 +1874,1 @@\n-        Assert.assertEquals(asFloating.species(), SPECIES);\n+        AssertEquals(asFloating.species(), SPECIES);\n@@ -1603,1 +1878,1 @@\n-        return (float)(a + b);\n+        return (float)(scalar_add(a, b));\n@@ -1624,1 +1899,1 @@\n-        return (float)(a + b);\n+        return (float)(scalar_add(a, b));\n@@ -1681,1 +1956,1 @@\n-        return (float)(a - b);\n+        return (float)(scalar_sub(a, b));\n@@ -1702,1 +1977,1 @@\n-        return (float)(a - b);\n+        return (float)(scalar_sub(a, b));\n@@ -1759,1 +2034,1 @@\n-        return (float)(a * b);\n+        return (float)(scalar_mul(a, b));\n@@ -1780,1 +2055,1 @@\n-        return (float)(a * b);\n+        return (float)(scalar_mul(a, b));\n@@ -1837,1 +2112,1 @@\n-        return (float)(a \/ b);\n+        return (float)(scalar_div(a, b));\n@@ -1858,1 +2133,1 @@\n-        return (float)(a \/ b);\n+        return (float)(scalar_div(a, b));\n@@ -1915,1 +2190,1 @@\n-        return (float)(Double.doubleToLongBits(a)!=0?a:b);\n+        return (float)(firstNonZero(a, b));\n@@ -2110,2 +2385,0 @@\n-    static FloatVector bv_MIN = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2120,1 +2393,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -2127,2 +2400,0 @@\n-    static FloatVector bv_min = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2137,1 +2408,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -2144,2 +2415,0 @@\n-    static FloatVector bv_MIN_M = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2156,1 +2425,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -2163,2 +2432,0 @@\n-    static FloatVector bv_MAX = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2173,1 +2440,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -2180,2 +2447,0 @@\n-    static FloatVector bv_max = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2190,1 +2455,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -2197,2 +2462,0 @@\n-    static FloatVector bv_MAX_M = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2209,1 +2472,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -2217,1 +2480,1 @@\n-        return (float)(Math.min(a, b));\n+        return (float)(scalar_min(a, b));\n@@ -2238,1 +2501,1 @@\n-        return (float)(Math.min(a, b));\n+        return (float)(scalar_min(a, b));\n@@ -2257,1 +2520,1 @@\n-        return (float)(Math.max(a, b));\n+        return (float)(scalar_max(a, b));\n@@ -2278,1 +2541,1 @@\n-        return (float)(Math.max(a, b));\n+        return (float)(scalar_max(a, b));\n@@ -2353,1 +2616,1 @@\n-        float res = 0;\n+        float res = additiveIdentity();\n@@ -2355,1 +2618,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -2362,1 +2625,1 @@\n-        float res = 0;\n+        float res = additiveIdentity();\n@@ -2364,1 +2627,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -2374,1 +2637,1 @@\n-        float ra = 0;\n+        float ra = additiveIdentity();\n@@ -2384,1 +2647,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -2387,1 +2650,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -2396,1 +2659,1 @@\n-        float res = 0;\n+        float res = additiveIdentity();\n@@ -2399,1 +2662,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -2406,1 +2669,1 @@\n-        float res = 0;\n+        float res = additiveIdentity();\n@@ -2408,1 +2671,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -2420,1 +2683,1 @@\n-        float ra = 0;\n+        float ra = additiveIdentity();\n@@ -2430,1 +2693,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -2433,1 +2696,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -2442,1 +2705,1 @@\n-        float res = 1;\n+        float res = multiplicativeIdentity();\n@@ -2444,1 +2707,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -2451,1 +2714,1 @@\n-        float res = 1;\n+        float res = multiplicativeIdentity();\n@@ -2453,1 +2716,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -2463,1 +2726,1 @@\n-        float ra = 1;\n+        float ra = multiplicativeIdentity();\n@@ -2473,1 +2736,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -2476,1 +2739,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -2485,1 +2748,1 @@\n-        float res = 1;\n+        float res = multiplicativeIdentity();\n@@ -2488,1 +2751,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -2495,1 +2758,1 @@\n-        float res = 1;\n+        float res = multiplicativeIdentity();\n@@ -2497,1 +2760,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -2509,1 +2772,1 @@\n-        float ra = 1;\n+        float ra = multiplicativeIdentity();\n@@ -2519,1 +2782,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -2522,1 +2785,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -2531,1 +2794,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = maxValue();\n@@ -2533,1 +2796,1 @@\n-            res = (float) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -2540,1 +2803,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = maxValue();\n@@ -2542,1 +2805,1 @@\n-            res = (float) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -2552,1 +2815,1 @@\n-        float ra = Float.POSITIVE_INFINITY;\n+        float ra = maxValue();\n@@ -2562,1 +2825,1 @@\n-            ra = Float.POSITIVE_INFINITY;\n+            ra = maxValue();\n@@ -2565,1 +2828,1 @@\n-                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -2574,1 +2837,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = maxValue();\n@@ -2577,1 +2840,1 @@\n-                res = (float) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -2584,1 +2847,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = maxValue();\n@@ -2586,1 +2849,1 @@\n-            res = (float) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -2598,1 +2861,1 @@\n-        float ra = Float.POSITIVE_INFINITY;\n+        float ra = maxValue();\n@@ -2608,1 +2871,1 @@\n-            ra = Float.POSITIVE_INFINITY;\n+            ra = maxValue();\n@@ -2611,1 +2874,1 @@\n-                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -2620,1 +2883,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = minValue();\n@@ -2622,1 +2885,1 @@\n-            res = (float) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -2629,1 +2892,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = minValue();\n@@ -2631,1 +2894,1 @@\n-            res = (float) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -2641,1 +2904,1 @@\n-        float ra = Float.NEGATIVE_INFINITY;\n+        float ra = minValue();\n@@ -2651,1 +2914,1 @@\n-            ra = Float.NEGATIVE_INFINITY;\n+            ra = minValue();\n@@ -2654,1 +2917,1 @@\n-                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -2663,1 +2926,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = minValue();\n@@ -2666,1 +2929,1 @@\n-                res = (float) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -2673,1 +2936,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = minValue();\n@@ -2675,1 +2938,1 @@\n-            res = (float) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -2687,1 +2950,1 @@\n-        float ra = Float.NEGATIVE_INFINITY;\n+        float ra = minValue();\n@@ -2697,1 +2960,1 @@\n-            ra = Float.NEGATIVE_INFINITY;\n+            ra = minValue();\n@@ -2700,1 +2963,1 @@\n-                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -2709,1 +2972,1 @@\n-        float res = (float) 0;\n+        float res = zeroValue();\n@@ -2718,1 +2981,1 @@\n-        float res = (float) 0;\n+        float res = zeroValue();\n@@ -2730,1 +2993,1 @@\n-        float ra = (float) 0;\n+        float ra = zeroValue();\n@@ -2740,1 +3003,1 @@\n-            ra = (float) 0;\n+            ra = zeroValue();\n@@ -2752,1 +3015,1 @@\n-        float res = (float) 0;\n+        float res = zeroValue();\n@@ -2762,1 +3025,1 @@\n-        float res = (float) 0;\n+        float res = zeroValue();\n@@ -2776,1 +3039,1 @@\n-        float ra = (float) 0;\n+        float ra = zeroValue();\n@@ -2786,1 +3049,1 @@\n-            ra = (float) 0;\n+            ra = zeroValue();\n@@ -2831,1 +3094,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -2851,1 +3114,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -2872,1 +3135,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -2892,1 +3155,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -2899,1 +3162,1 @@\n-        return Float.isFinite(a);\n+        return isFinite(a);\n@@ -2913,1 +3176,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_FINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_FINITE(a[i + j]));\n@@ -2933,1 +3196,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n@@ -2940,1 +3203,1 @@\n-        return Float.isNaN(a);\n+        return isNaN(a);\n@@ -2954,1 +3217,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NAN(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NAN(a[i + j]));\n@@ -2974,1 +3237,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n@@ -2981,1 +3244,1 @@\n-        return Float.isInfinite(a);\n+        return isInfinite(a);\n@@ -2995,1 +3258,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_INFINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_INFINITE(a[i + j]));\n@@ -3015,1 +3278,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n@@ -3034,1 +3297,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3053,1 +3316,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3076,1 +3339,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3095,1 +3358,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3118,1 +3381,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3137,1 +3400,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3156,1 +3419,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3179,1 +3442,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3198,1 +3461,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3221,1 +3484,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3240,1 +3503,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3263,1 +3526,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3282,1 +3545,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3305,1 +3568,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -3322,1 +3585,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -3342,1 +3605,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -3358,1 +3621,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < (float)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (float)((long)b[i])));\n@@ -3378,1 +3641,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < (float)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(float)((long)b[i]))));\n@@ -3394,1 +3657,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -3414,1 +3677,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -3430,1 +3693,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == (float)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (float)((long)b[i])));\n@@ -3450,1 +3713,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == (float)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(float)((long)b[i]))));\n@@ -3731,1 +3994,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -3950,1 +4213,1 @@\n-        return (float)(Math.sin((double)a));\n+        return (float)(scalar_sin(a));\n@@ -3954,1 +4217,1 @@\n-        return (float)(StrictMath.sin((double)a));\n+        return (float)(strict_scalar_sin(a));\n@@ -3973,1 +4236,1 @@\n-        return (float)(Math.exp((double)a));\n+        return (float)(scalar_exp(a));\n@@ -3977,1 +4240,1 @@\n-        return (float)(StrictMath.exp((double)a));\n+        return (float)(strict_scalar_exp(a));\n@@ -3996,1 +4259,1 @@\n-        return (float)(Math.log1p((double)a));\n+        return (float)(scalar_log1p(a));\n@@ -4000,1 +4263,1 @@\n-        return (float)(StrictMath.log1p((double)a));\n+        return (float)(strict_scalar_log1p(a));\n@@ -4019,1 +4282,1 @@\n-        return (float)(Math.log((double)a));\n+        return (float)(scalar_log(a));\n@@ -4023,1 +4286,1 @@\n-        return (float)(StrictMath.log((double)a));\n+        return (float)(strict_scalar_log(a));\n@@ -4042,1 +4305,1 @@\n-        return (float)(Math.log10((double)a));\n+        return (float)(scalar_log10(a));\n@@ -4046,1 +4309,1 @@\n-        return (float)(StrictMath.log10((double)a));\n+        return (float)(strict_scalar_log10(a));\n@@ -4065,1 +4328,1 @@\n-        return (float)(Math.expm1((double)a));\n+        return (float)(scalar_expm1(a));\n@@ -4069,1 +4332,1 @@\n-        return (float)(StrictMath.expm1((double)a));\n+        return (float)(strict_scalar_expm1(a));\n@@ -4088,1 +4351,1 @@\n-        return (float)(Math.cos((double)a));\n+        return (float)(scalar_cos(a));\n@@ -4092,1 +4355,1 @@\n-        return (float)(StrictMath.cos((double)a));\n+        return (float)(strict_scalar_cos(a));\n@@ -4111,1 +4374,1 @@\n-        return (float)(Math.tan((double)a));\n+        return (float)(scalar_tan(a));\n@@ -4115,1 +4378,1 @@\n-        return (float)(StrictMath.tan((double)a));\n+        return (float)(strict_scalar_tan(a));\n@@ -4134,1 +4397,1 @@\n-        return (float)(Math.sinh((double)a));\n+        return (float)(scalar_sinh(a));\n@@ -4138,1 +4401,1 @@\n-        return (float)(StrictMath.sinh((double)a));\n+        return (float)(strict_scalar_sinh(a));\n@@ -4157,1 +4420,1 @@\n-        return (float)(Math.cosh((double)a));\n+        return (float)(scalar_cosh(a));\n@@ -4161,1 +4424,1 @@\n-        return (float)(StrictMath.cosh((double)a));\n+        return (float)(strict_scalar_cosh(a));\n@@ -4180,1 +4443,1 @@\n-        return (float)(Math.tanh((double)a));\n+        return (float)(scalar_tanh(a));\n@@ -4184,1 +4447,1 @@\n-        return (float)(StrictMath.tanh((double)a));\n+        return (float)(strict_scalar_tanh(a));\n@@ -4203,1 +4466,1 @@\n-        return (float)(Math.asin((double)a));\n+        return (float)(scalar_asin(a));\n@@ -4207,1 +4470,1 @@\n-        return (float)(StrictMath.asin((double)a));\n+        return (float)(strict_scalar_asin(a));\n@@ -4226,1 +4489,1 @@\n-        return (float)(Math.acos((double)a));\n+        return (float)(scalar_acos(a));\n@@ -4230,1 +4493,1 @@\n-        return (float)(StrictMath.acos((double)a));\n+        return (float)(strict_scalar_acos(a));\n@@ -4249,1 +4512,1 @@\n-        return (float)(Math.atan((double)a));\n+        return (float)(scalar_atan(a));\n@@ -4253,1 +4516,1 @@\n-        return (float)(StrictMath.atan((double)a));\n+        return (float)(strict_scalar_atan(a));\n@@ -4272,1 +4535,1 @@\n-        return (float)(Math.cbrt((double)a));\n+        return (float)(scalar_cbrt(a));\n@@ -4276,1 +4539,1 @@\n-        return (float)(StrictMath.cbrt((double)a));\n+        return (float)(strict_scalar_cbrt(a));\n@@ -4295,1 +4558,1 @@\n-        return (float)(Math.hypot((double)a, (double)b));\n+        return (float)(scalar_hypot(a, b));\n@@ -4299,1 +4562,1 @@\n-        return (float)(StrictMath.hypot((double)a, (double)b));\n+        return (float)(strict_scalar_hypot(a, b));\n@@ -4321,1 +4584,1 @@\n-        return (float)(Math.pow((double)a, (double)b));\n+        return (float)(scalar_pow(a, b));\n@@ -4325,1 +4588,1 @@\n-        return (float)(StrictMath.pow((double)a, (double)b));\n+        return (float)(strict_scalar_pow(a, b));\n@@ -4347,1 +4610,1 @@\n-        return (float)(Math.pow((double)a, (double)b));\n+        return (float)(scalar_pow(a, b));\n@@ -4351,1 +4614,1 @@\n-        return (float)(StrictMath.pow((double)a, (double)b));\n+        return (float)(strict_scalar_pow(a, b));\n@@ -4373,1 +4636,1 @@\n-        return (float)(Math.atan2((double)a, (double)b));\n+        return (float)(scalar_atan2(a, b));\n@@ -4377,1 +4640,1 @@\n-        return (float)(StrictMath.atan2((double)a, (double)b));\n+        return (float)(strict_scalar_atan2(a, b));\n@@ -4429,1 +4692,1 @@\n-        return (float)(Math.fma(a, b, c));\n+        return (float)(scalar_fma(a, b, c));\n@@ -4433,1 +4696,1 @@\n-        return (float)(Math.fma(a, b, c));\n+        return (float)(scalar_fma(a, b, c));\n@@ -4611,1 +4874,1 @@\n-        return (float)(-((float)a));\n+        return (float)(scalar_neg((float)a));\n@@ -4615,1 +4878,1 @@\n-        return (float)(-((float)a));\n+        return (float)(scalar_neg((float)a));\n@@ -4667,1 +4930,1 @@\n-        return (float)(Math.abs((float)a));\n+        return (float)(scalar_abs((float)a));\n@@ -4671,1 +4934,1 @@\n-        return (float)(Math.abs((float)a));\n+        return (float)(scalar_abs((float)a));\n@@ -4723,1 +4986,1 @@\n-        return (float)(Math.sqrt((double)a));\n+        return (float)(scalar_sqrt(a));\n@@ -4727,1 +4990,1 @@\n-        return (float)(Math.sqrt((double)a));\n+        return (float)(scalar_sqrt(a));\n@@ -4789,1 +5052,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -4805,1 +5068,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -4901,1 +5164,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -4942,1 +5205,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -5045,1 +5308,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -5073,1 +5336,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -5087,1 +5350,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -5284,1 +5547,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -5304,1 +5567,1 @@\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5327,1 +5590,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -5341,1 +5604,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -5363,1 +5626,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -5371,1 +5634,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -5378,1 +5641,1 @@\n-        Assert.assertEquals(elsize, Float.SIZE);\n+        AssertEquals(elsize, Float.SIZE);\n@@ -5397,1 +5660,1 @@\n-    static void ElementTypeFloat64VectorTestsSmokeTest() {\n+    static void FloatFloat64VectorTestsSmokeTest() {\n@@ -5432,1 +5695,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":616,"deletions":353,"binary":false,"changes":969,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,45 @@\n+    static FloatVector bcast_vec = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    static void AssertEquals(float actual, float expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(float actual, float expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(float actual, float expected, float delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(float actual, float expected, float delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(float [] actual, float [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(float [] actual, float [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -97,1 +142,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -100,1 +145,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -112,1 +157,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -118,1 +163,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -128,1 +173,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -131,1 +176,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -153,1 +198,1 @@\n-            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);\n+            AssertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);\n@@ -155,1 +200,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);\n+                AssertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);\n@@ -158,2 +203,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, \"at index #\" + i);\n@@ -181,1 +226,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n+            AssertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -183,2 +228,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n-relativeError));\n+                AssertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError));\n@@ -187,2 +231,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -204,1 +248,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -206,1 +250,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -209,2 +253,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -226,1 +270,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -228,1 +272,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -231,2 +275,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -244,1 +288,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -247,1 +291,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -259,1 +303,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -262,1 +306,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -271,1 +315,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -276,1 +320,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -287,1 +331,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -292,1 +336,1 @@\n-                    Assert.assertEquals(r[i + k], (float)0);\n+                    AssertEquals(r[i + k], (float)0);\n@@ -298,1 +342,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -300,1 +344,1 @@\n-                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (float)0, \"at index #\" + idx);\n@@ -312,1 +356,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -315,1 +359,1 @@\n-                        Assert.assertEquals(r[i + j], (float)0);\n+                        AssertEquals(r[i + j], (float)0);\n@@ -322,1 +366,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -324,1 +368,1 @@\n-                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (float)0, \"at index #\" + idx);\n@@ -340,1 +384,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -344,1 +388,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -350,0 +394,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -353,1 +398,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -357,2 +404,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -368,1 +414,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -370,1 +416,1 @@\n-                         Assert.assertEquals(r[i+j], (float)0);\n+                         AssertEquals(r[i+j], (float)0);\n@@ -376,1 +422,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -378,1 +424,1 @@\n-                Assert.assertEquals(r[i+j], (float)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (float)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -384,0 +430,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -387,0 +434,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -388,1 +437,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -390,1 +439,1 @@\n-                         Assert.assertEquals(r[i+j], (float)0);\n+                         AssertEquals(r[i+j], (float)0);\n@@ -394,1 +443,0 @@\n-            int idx = i + j;\n@@ -396,1 +444,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -398,1 +446,1 @@\n-                Assert.assertEquals(r[i+j], (float)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (float)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -412,1 +460,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -415,1 +463,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -436,1 +484,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -439,1 +487,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -442,1 +490,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -445,3 +493,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -462,1 +510,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -465,1 +513,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -468,1 +516,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -471,3 +519,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -481,1 +529,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -484,1 +532,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -492,1 +540,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -495,1 +543,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -503,1 +551,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -506,1 +554,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -515,1 +563,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -518,1 +566,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -531,1 +579,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -534,1 +582,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -546,1 +594,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -549,1 +597,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -561,1 +609,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -564,1 +612,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -579,1 +627,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -582,1 +630,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (float)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -595,1 +643,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -599,1 +647,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -613,1 +661,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -617,1 +665,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -639,1 +687,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -643,1 +691,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -657,1 +705,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -661,1 +709,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -681,1 +729,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -684,1 +732,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -696,1 +744,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -699,1 +747,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -708,1 +756,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -711,1 +759,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -721,1 +769,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -724,1 +772,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -740,1 +788,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -744,1 +792,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -761,1 +809,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -765,1 +813,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -776,1 +824,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -780,1 +828,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -797,1 +845,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -801,1 +849,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -854,1 +902,1 @@\n-            Assert.assertTrue(Float.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(Float.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n@@ -893,1 +941,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -899,1 +947,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -920,1 +968,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -926,1 +974,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -941,1 +989,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -947,1 +995,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -968,1 +1016,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -974,1 +1022,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -988,1 +1036,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -994,1 +1042,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1009,1 +1057,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1015,1 +1063,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1030,1 +1078,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1036,1 +1084,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1052,1 +1100,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1058,1 +1106,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1066,0 +1114,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -1082,1 +1134,1 @@\n-            withToString(\"float[-i * 5]\", (int s) -> {\n+            withToString(\"Float[-i * 5]\", (int s) -> {\n@@ -1084,1 +1136,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1086,1 +1138,1 @@\n-            withToString(\"float[i * 5]\", (int s) -> {\n+            withToString(\"Float[i * 5]\", (int s) -> {\n@@ -1088,1 +1140,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1090,1 +1142,1 @@\n-            withToString(\"float[i + 1]\", (int s) -> {\n+            withToString(\"Float[i + 1]\", (int s) -> {\n@@ -1092,1 +1144,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1094,1 +1146,1 @@\n-            withToString(\"float[intCornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Float[intCornerCaseValue(i)]\", (int s) -> {\n@@ -1104,1 +1156,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -1107,1 +1159,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1126,0 +1178,4 @@\n+    static float genValue(long i) {\n+        return (float) i;\n+    }\n+\n@@ -1127,1 +1183,1 @@\n-            withToString(\"float[-i * 5]\", (int s) -> {\n+            withToString(\"Float[-i * 5]\", (int s) -> {\n@@ -1129,1 +1185,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1131,1 +1187,1 @@\n-            withToString(\"float[i * 5]\", (int s) -> {\n+            withToString(\"Float[i * 5]\", (int s) -> {\n@@ -1133,1 +1189,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1135,1 +1191,1 @@\n-            withToString(\"float[i + 1]\", (int s) -> {\n+            withToString(\"Float[i + 1]\", (int s) -> {\n@@ -1137,1 +1193,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1139,1 +1195,1 @@\n-            withToString(\"float[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Float[cornerCaseValue(i)]\", (int s) -> {\n@@ -1150,1 +1206,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -1153,1 +1209,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1161,1 +1217,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                AssertEquals(r[i], (double)(a[i+offs]));\n@@ -1164,1 +1220,1 @@\n-            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1169,1 +1225,1 @@\n-        return  Float.floatToIntBits(e);\n+        return Float.floatToIntBits(e);\n@@ -1173,1 +1229,1 @@\n-            withToString(\"float[-i * 5]\", (int s) -> {\n+            withToString(\"Float[-i * 5]\", (int s) -> {\n@@ -1175,1 +1231,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1177,1 +1233,1 @@\n-            withToString(\"float[i * 5]\", (int s) -> {\n+            withToString(\"Float[i * 5]\", (int s) -> {\n@@ -1179,1 +1235,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1181,1 +1237,1 @@\n-            withToString(\"float[i + 1]\", (int s) -> {\n+            withToString(\"Float[i + 1]\", (int s) -> {\n@@ -1183,1 +1239,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1187,1 +1243,1 @@\n-                            i -> (float)0.01 + ((float)i \/ (i + 1)));\n+                            i -> ((float)0.01 + ((float)i \/ (i + 1))));\n@@ -1191,1 +1247,1 @@\n-                            i -> i % 17 == 0 ? cornerCaseValue(i) : (float)0.01 + ((float)i \/ (i + 1)));\n+                            i -> (i % 17 == 0) ? cornerCaseValue(i) : ((float)0.01 + ((float)i \/ (i + 1))));\n@@ -1515,0 +1571,219 @@\n+    static float multiplicativeIdentity() {\n+        return (float)1;\n+    }\n+\n+\n+    static float scalar_add(float a, float b) {\n+        return (float)(a + b);\n+    }\n+\n+    static float scalar_sub(float a, float b) {\n+        return (float)(a - b);\n+    }\n+\n+    static float scalar_mul(float a, float b) {\n+        return (float)(a * b);\n+    }\n+\n+    static float scalar_min(float a, float b) {\n+        return (float)(Math.min(a, b));\n+    }\n+\n+    static float scalar_max(float a, float b) {\n+        return (float)(Math.max(a, b));\n+    }\n+\n+    static float scalar_div(float a, float b) {\n+        return (float)(a \/ b);\n+    }\n+\n+    static float scalar_fma(float a, float b, float c) {\n+        return (float)(Math.fma(a, b, c));\n+    }\n+\n+    static float scalar_abs(float a) {\n+        return (float)(Math.abs(a));\n+    }\n+\n+    static float scalar_neg(float a) {\n+        return ((float)-a);\n+    }\n+\n+    static float scalar_sin(float a) {\n+        return (float)Math.sin((double)a);\n+    }\n+\n+    static float scalar_exp(float a) {\n+        return (float)Math.exp((double)a);\n+    }\n+\n+    static float scalar_log1p(float a) {\n+        return (float)Math.log1p((double)a);\n+    }\n+\n+    static float scalar_log(float a) {\n+        return (float)Math.log((double)a);\n+    }\n+\n+    static float scalar_log10(float a) {\n+        return (float)Math.log10((double)a);\n+    }\n+\n+    static float scalar_expm1(float a) {\n+        return (float)Math.expm1((double)a);\n+    }\n+\n+    static float scalar_cos(float a) {\n+        return (float)Math.cos((double)a);\n+    }\n+\n+    static float scalar_tan(float a) {\n+        return (float)Math.tan((double)a);\n+    }\n+\n+    static float scalar_sinh(float a) {\n+        return (float)Math.sinh((double)a);\n+    }\n+\n+    static float scalar_cosh(float a) {\n+        return (float)Math.cosh((double)a);\n+    }\n+\n+    static float scalar_tanh(float a) {\n+        return (float)Math.tanh((double)a);\n+    }\n+\n+    static float scalar_asin(float a) {\n+        return (float)Math.asin((double)a);\n+    }\n+\n+    static float scalar_acos(float a) {\n+        return (float)Math.acos((double)a);\n+    }\n+\n+    static float scalar_atan(float a) {\n+        return (float)Math.atan((double)a);\n+    }\n+\n+    static float scalar_cbrt(float a) {\n+        return (float)Math.cbrt((double)a);\n+    }\n+\n+    static float scalar_sqrt(float a) {\n+        return (float)Math.sqrt((double)a);\n+    }\n+\n+    static float scalar_hypot(float a, float b) {\n+        return (float)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static float scalar_pow(float a, float b) {\n+        return (float)Math.pow((double)a, (double)b);\n+    }\n+\n+    static float scalar_atan2(float a, float b) {\n+        return (float)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static float strict_scalar_sin(float a) {\n+        return (float)StrictMath.sin((double)a);\n+    }\n+\n+    static float strict_scalar_exp(float a) {\n+        return (float)StrictMath.exp((double)a);\n+    }\n+\n+    static float strict_scalar_log1p(float a) {\n+        return (float)StrictMath.log1p((double)a);\n+    }\n+\n+    static float strict_scalar_log(float a) {\n+        return (float)StrictMath.log((double)a);\n+    }\n+\n+    static float strict_scalar_log10(float a) {\n+        return (float)StrictMath.log10((double)a);\n+    }\n+\n+    static float strict_scalar_expm1(float a) {\n+        return (float)StrictMath.expm1((double)a);\n+    }\n+\n+    static float strict_scalar_cos(float a) {\n+        return (float)StrictMath.cos((double)a);\n+    }\n+\n+    static float strict_scalar_tan(float a) {\n+        return (float)StrictMath.tan((double)a);\n+    }\n+\n+    static float strict_scalar_sinh(float a) {\n+        return (float)StrictMath.sinh((double)a);\n+    }\n+\n+    static float strict_scalar_cosh(float a) {\n+        return (float)StrictMath.cosh((double)a);\n+    }\n+\n+    static float strict_scalar_tanh(float a) {\n+        return (float)StrictMath.tanh((double)a);\n+    }\n+\n+    static float strict_scalar_asin(float a) {\n+        return (float)StrictMath.asin((double)a);\n+    }\n+\n+    static float strict_scalar_acos(float a) {\n+        return (float)StrictMath.acos((double)a);\n+    }\n+\n+    static float strict_scalar_atan(float a) {\n+        return (float)StrictMath.atan((double)a);\n+    }\n+\n+    static float strict_scalar_cbrt(float a) {\n+        return (float)StrictMath.cbrt((double)a);\n+    }\n+\n+    static float strict_scalar_sqrt(float a) {\n+        return (float)StrictMath.sqrt((double)a);\n+    }\n+\n+    static float strict_scalar_hypot(float a, float b) {\n+        return (float)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static float strict_scalar_pow(float a, float b) {\n+        return (float)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static float strict_scalar_atan2(float a, float b) {\n+        return (float)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static float additiveIdentity() {\n+        return (float)0;\n+    }\n+\n+\n+    static float zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static float maxValue() {\n+        return Float.POSITIVE_INFINITY;\n+    }\n+\n+    static float minValue() {\n+        return Float.NEGATIVE_INFINITY;\n+    }\n+\n+    static boolean isNaN(float a) {\n+        return Float.isNaN(a);\n+    }\n+    static boolean isFinite(float a) {\n+        return Float.isFinite(a);\n+    }\n+    static boolean isInfinite(float a) {\n+        return Float.isInfinite(a);\n+    }\n+\n@@ -1552,1 +1827,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1567,1 +1842,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1573,1 +1848,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1579,1 +1854,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1596,3 +1871,3 @@\n-        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n-        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n-        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+        AssertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        AssertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n@@ -1604,1 +1879,1 @@\n-        Assert.assertEquals(asFloating.species(), SPECIES);\n+        AssertEquals(asFloating.species(), SPECIES);\n@@ -1608,1 +1883,1 @@\n-        return (float)(a + b);\n+        return (float)(scalar_add(a, b));\n@@ -1629,1 +1904,1 @@\n-        return (float)(a + b);\n+        return (float)(scalar_add(a, b));\n@@ -1686,1 +1961,1 @@\n-        return (float)(a - b);\n+        return (float)(scalar_sub(a, b));\n@@ -1707,1 +1982,1 @@\n-        return (float)(a - b);\n+        return (float)(scalar_sub(a, b));\n@@ -1764,1 +2039,1 @@\n-        return (float)(a * b);\n+        return (float)(scalar_mul(a, b));\n@@ -1785,1 +2060,1 @@\n-        return (float)(a * b);\n+        return (float)(scalar_mul(a, b));\n@@ -1842,1 +2117,1 @@\n-        return (float)(a \/ b);\n+        return (float)(scalar_div(a, b));\n@@ -1863,1 +2138,1 @@\n-        return (float)(a \/ b);\n+        return (float)(scalar_div(a, b));\n@@ -1920,1 +2195,1 @@\n-        return (float)(Double.doubleToLongBits(a)!=0?a:b);\n+        return (float)(firstNonZero(a, b));\n@@ -2115,2 +2390,0 @@\n-    static FloatVector bv_MIN = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2125,1 +2398,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -2132,2 +2405,0 @@\n-    static FloatVector bv_min = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2142,1 +2413,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -2149,2 +2420,0 @@\n-    static FloatVector bv_MIN_M = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2161,1 +2430,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -2168,2 +2437,0 @@\n-    static FloatVector bv_MAX = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2178,1 +2445,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -2185,2 +2452,0 @@\n-    static FloatVector bv_max = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2195,1 +2460,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -2202,2 +2467,0 @@\n-    static FloatVector bv_MAX_M = FloatVector.broadcast(SPECIES, (float)10);\n-\n@@ -2214,1 +2477,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -2222,1 +2485,1 @@\n-        return (float)(Math.min(a, b));\n+        return (float)(scalar_min(a, b));\n@@ -2243,1 +2506,1 @@\n-        return (float)(Math.min(a, b));\n+        return (float)(scalar_min(a, b));\n@@ -2262,1 +2525,1 @@\n-        return (float)(Math.max(a, b));\n+        return (float)(scalar_max(a, b));\n@@ -2283,1 +2546,1 @@\n-        return (float)(Math.max(a, b));\n+        return (float)(scalar_max(a, b));\n@@ -2358,1 +2621,1 @@\n-        float res = 0;\n+        float res = additiveIdentity();\n@@ -2360,1 +2623,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -2367,1 +2630,1 @@\n-        float res = 0;\n+        float res = additiveIdentity();\n@@ -2369,1 +2632,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -2379,1 +2642,1 @@\n-        float ra = 0;\n+        float ra = additiveIdentity();\n@@ -2389,1 +2652,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -2392,1 +2655,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -2401,1 +2664,1 @@\n-        float res = 0;\n+        float res = additiveIdentity();\n@@ -2404,1 +2667,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -2411,1 +2674,1 @@\n-        float res = 0;\n+        float res = additiveIdentity();\n@@ -2413,1 +2676,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -2425,1 +2688,1 @@\n-        float ra = 0;\n+        float ra = additiveIdentity();\n@@ -2435,1 +2698,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -2438,1 +2701,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -2447,1 +2710,1 @@\n-        float res = 1;\n+        float res = multiplicativeIdentity();\n@@ -2449,1 +2712,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -2456,1 +2719,1 @@\n-        float res = 1;\n+        float res = multiplicativeIdentity();\n@@ -2458,1 +2721,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -2468,1 +2731,1 @@\n-        float ra = 1;\n+        float ra = multiplicativeIdentity();\n@@ -2478,1 +2741,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -2481,1 +2744,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -2490,1 +2753,1 @@\n-        float res = 1;\n+        float res = multiplicativeIdentity();\n@@ -2493,1 +2756,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -2500,1 +2763,1 @@\n-        float res = 1;\n+        float res = multiplicativeIdentity();\n@@ -2502,1 +2765,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -2514,1 +2777,1 @@\n-        float ra = 1;\n+        float ra = multiplicativeIdentity();\n@@ -2524,1 +2787,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -2527,1 +2790,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -2536,1 +2799,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = maxValue();\n@@ -2538,1 +2801,1 @@\n-            res = (float) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -2545,1 +2808,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = maxValue();\n@@ -2547,1 +2810,1 @@\n-            res = (float) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -2557,1 +2820,1 @@\n-        float ra = Float.POSITIVE_INFINITY;\n+        float ra = maxValue();\n@@ -2567,1 +2830,1 @@\n-            ra = Float.POSITIVE_INFINITY;\n+            ra = maxValue();\n@@ -2570,1 +2833,1 @@\n-                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -2579,1 +2842,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = maxValue();\n@@ -2582,1 +2845,1 @@\n-                res = (float) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -2589,1 +2852,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = maxValue();\n@@ -2591,1 +2854,1 @@\n-            res = (float) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -2603,1 +2866,1 @@\n-        float ra = Float.POSITIVE_INFINITY;\n+        float ra = maxValue();\n@@ -2613,1 +2876,1 @@\n-            ra = Float.POSITIVE_INFINITY;\n+            ra = maxValue();\n@@ -2616,1 +2879,1 @@\n-                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -2625,1 +2888,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = minValue();\n@@ -2627,1 +2890,1 @@\n-            res = (float) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -2634,1 +2897,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = minValue();\n@@ -2636,1 +2899,1 @@\n-            res = (float) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -2646,1 +2909,1 @@\n-        float ra = Float.NEGATIVE_INFINITY;\n+        float ra = minValue();\n@@ -2656,1 +2919,1 @@\n-            ra = Float.NEGATIVE_INFINITY;\n+            ra = minValue();\n@@ -2659,1 +2922,1 @@\n-                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -2668,1 +2931,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = minValue();\n@@ -2671,1 +2934,1 @@\n-                res = (float) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -2678,1 +2941,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = minValue();\n@@ -2680,1 +2943,1 @@\n-            res = (float) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -2692,1 +2955,1 @@\n-        float ra = Float.NEGATIVE_INFINITY;\n+        float ra = minValue();\n@@ -2702,1 +2965,1 @@\n-            ra = Float.NEGATIVE_INFINITY;\n+            ra = minValue();\n@@ -2705,1 +2968,1 @@\n-                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -2714,1 +2977,1 @@\n-        float res = (float) 0;\n+        float res = zeroValue();\n@@ -2723,1 +2986,1 @@\n-        float res = (float) 0;\n+        float res = zeroValue();\n@@ -2735,1 +2998,1 @@\n-        float ra = (float) 0;\n+        float ra = zeroValue();\n@@ -2745,1 +3008,1 @@\n-            ra = (float) 0;\n+            ra = zeroValue();\n@@ -2757,1 +3020,1 @@\n-        float res = (float) 0;\n+        float res = zeroValue();\n@@ -2767,1 +3030,1 @@\n-        float res = (float) 0;\n+        float res = zeroValue();\n@@ -2781,1 +3044,1 @@\n-        float ra = (float) 0;\n+        float ra = zeroValue();\n@@ -2791,1 +3054,1 @@\n-            ra = (float) 0;\n+            ra = zeroValue();\n@@ -2836,1 +3099,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -2856,1 +3119,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -2877,1 +3140,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -2897,1 +3160,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -2904,1 +3167,1 @@\n-        return Float.isFinite(a);\n+        return isFinite(a);\n@@ -2918,1 +3181,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_FINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_FINITE(a[i + j]));\n@@ -2938,1 +3201,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n@@ -2945,1 +3208,1 @@\n-        return Float.isNaN(a);\n+        return isNaN(a);\n@@ -2959,1 +3222,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NAN(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NAN(a[i + j]));\n@@ -2979,1 +3242,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n@@ -2986,1 +3249,1 @@\n-        return Float.isInfinite(a);\n+        return isInfinite(a);\n@@ -3000,1 +3263,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_INFINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_INFINITE(a[i + j]));\n@@ -3020,1 +3283,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n@@ -3039,1 +3302,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3058,1 +3321,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3081,1 +3344,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3100,1 +3363,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3123,1 +3386,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3142,1 +3405,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3161,1 +3424,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3184,1 +3447,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3203,1 +3466,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3226,1 +3489,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3245,1 +3508,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3268,1 +3531,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3287,1 +3550,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3310,1 +3573,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -3327,1 +3590,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -3347,1 +3610,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -3363,1 +3626,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < (float)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (float)((long)b[i])));\n@@ -3383,1 +3646,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < (float)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(float)((long)b[i]))));\n@@ -3399,1 +3662,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -3419,1 +3682,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -3435,1 +3698,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == (float)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (float)((long)b[i])));\n@@ -3455,1 +3718,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == (float)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(float)((long)b[i]))));\n@@ -3736,1 +3999,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -3955,1 +4218,1 @@\n-        return (float)(Math.sin((double)a));\n+        return (float)(scalar_sin(a));\n@@ -3959,1 +4222,1 @@\n-        return (float)(StrictMath.sin((double)a));\n+        return (float)(strict_scalar_sin(a));\n@@ -3978,1 +4241,1 @@\n-        return (float)(Math.exp((double)a));\n+        return (float)(scalar_exp(a));\n@@ -3982,1 +4245,1 @@\n-        return (float)(StrictMath.exp((double)a));\n+        return (float)(strict_scalar_exp(a));\n@@ -4001,1 +4264,1 @@\n-        return (float)(Math.log1p((double)a));\n+        return (float)(scalar_log1p(a));\n@@ -4005,1 +4268,1 @@\n-        return (float)(StrictMath.log1p((double)a));\n+        return (float)(strict_scalar_log1p(a));\n@@ -4024,1 +4287,1 @@\n-        return (float)(Math.log((double)a));\n+        return (float)(scalar_log(a));\n@@ -4028,1 +4291,1 @@\n-        return (float)(StrictMath.log((double)a));\n+        return (float)(strict_scalar_log(a));\n@@ -4047,1 +4310,1 @@\n-        return (float)(Math.log10((double)a));\n+        return (float)(scalar_log10(a));\n@@ -4051,1 +4314,1 @@\n-        return (float)(StrictMath.log10((double)a));\n+        return (float)(strict_scalar_log10(a));\n@@ -4070,1 +4333,1 @@\n-        return (float)(Math.expm1((double)a));\n+        return (float)(scalar_expm1(a));\n@@ -4074,1 +4337,1 @@\n-        return (float)(StrictMath.expm1((double)a));\n+        return (float)(strict_scalar_expm1(a));\n@@ -4093,1 +4356,1 @@\n-        return (float)(Math.cos((double)a));\n+        return (float)(scalar_cos(a));\n@@ -4097,1 +4360,1 @@\n-        return (float)(StrictMath.cos((double)a));\n+        return (float)(strict_scalar_cos(a));\n@@ -4116,1 +4379,1 @@\n-        return (float)(Math.tan((double)a));\n+        return (float)(scalar_tan(a));\n@@ -4120,1 +4383,1 @@\n-        return (float)(StrictMath.tan((double)a));\n+        return (float)(strict_scalar_tan(a));\n@@ -4139,1 +4402,1 @@\n-        return (float)(Math.sinh((double)a));\n+        return (float)(scalar_sinh(a));\n@@ -4143,1 +4406,1 @@\n-        return (float)(StrictMath.sinh((double)a));\n+        return (float)(strict_scalar_sinh(a));\n@@ -4162,1 +4425,1 @@\n-        return (float)(Math.cosh((double)a));\n+        return (float)(scalar_cosh(a));\n@@ -4166,1 +4429,1 @@\n-        return (float)(StrictMath.cosh((double)a));\n+        return (float)(strict_scalar_cosh(a));\n@@ -4185,1 +4448,1 @@\n-        return (float)(Math.tanh((double)a));\n+        return (float)(scalar_tanh(a));\n@@ -4189,1 +4452,1 @@\n-        return (float)(StrictMath.tanh((double)a));\n+        return (float)(strict_scalar_tanh(a));\n@@ -4208,1 +4471,1 @@\n-        return (float)(Math.asin((double)a));\n+        return (float)(scalar_asin(a));\n@@ -4212,1 +4475,1 @@\n-        return (float)(StrictMath.asin((double)a));\n+        return (float)(strict_scalar_asin(a));\n@@ -4231,1 +4494,1 @@\n-        return (float)(Math.acos((double)a));\n+        return (float)(scalar_acos(a));\n@@ -4235,1 +4498,1 @@\n-        return (float)(StrictMath.acos((double)a));\n+        return (float)(strict_scalar_acos(a));\n@@ -4254,1 +4517,1 @@\n-        return (float)(Math.atan((double)a));\n+        return (float)(scalar_atan(a));\n@@ -4258,1 +4521,1 @@\n-        return (float)(StrictMath.atan((double)a));\n+        return (float)(strict_scalar_atan(a));\n@@ -4277,1 +4540,1 @@\n-        return (float)(Math.cbrt((double)a));\n+        return (float)(scalar_cbrt(a));\n@@ -4281,1 +4544,1 @@\n-        return (float)(StrictMath.cbrt((double)a));\n+        return (float)(strict_scalar_cbrt(a));\n@@ -4300,1 +4563,1 @@\n-        return (float)(Math.hypot((double)a, (double)b));\n+        return (float)(scalar_hypot(a, b));\n@@ -4304,1 +4567,1 @@\n-        return (float)(StrictMath.hypot((double)a, (double)b));\n+        return (float)(strict_scalar_hypot(a, b));\n@@ -4326,1 +4589,1 @@\n-        return (float)(Math.pow((double)a, (double)b));\n+        return (float)(scalar_pow(a, b));\n@@ -4330,1 +4593,1 @@\n-        return (float)(StrictMath.pow((double)a, (double)b));\n+        return (float)(strict_scalar_pow(a, b));\n@@ -4352,1 +4615,1 @@\n-        return (float)(Math.pow((double)a, (double)b));\n+        return (float)(scalar_pow(a, b));\n@@ -4356,1 +4619,1 @@\n-        return (float)(StrictMath.pow((double)a, (double)b));\n+        return (float)(strict_scalar_pow(a, b));\n@@ -4378,1 +4641,1 @@\n-        return (float)(Math.atan2((double)a, (double)b));\n+        return (float)(scalar_atan2(a, b));\n@@ -4382,1 +4645,1 @@\n-        return (float)(StrictMath.atan2((double)a, (double)b));\n+        return (float)(strict_scalar_atan2(a, b));\n@@ -4434,1 +4697,1 @@\n-        return (float)(Math.fma(a, b, c));\n+        return (float)(scalar_fma(a, b, c));\n@@ -4438,1 +4701,1 @@\n-        return (float)(Math.fma(a, b, c));\n+        return (float)(scalar_fma(a, b, c));\n@@ -4616,1 +4879,1 @@\n-        return (float)(-((float)a));\n+        return (float)(scalar_neg((float)a));\n@@ -4620,1 +4883,1 @@\n-        return (float)(-((float)a));\n+        return (float)(scalar_neg((float)a));\n@@ -4672,1 +4935,1 @@\n-        return (float)(Math.abs((float)a));\n+        return (float)(scalar_abs((float)a));\n@@ -4676,1 +4939,1 @@\n-        return (float)(Math.abs((float)a));\n+        return (float)(scalar_abs((float)a));\n@@ -4728,1 +4991,1 @@\n-        return (float)(Math.sqrt((double)a));\n+        return (float)(scalar_sqrt(a));\n@@ -4732,1 +4995,1 @@\n-        return (float)(Math.sqrt((double)a));\n+        return (float)(scalar_sqrt(a));\n@@ -4794,1 +5057,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -4810,1 +5073,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -4906,1 +5169,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -4947,1 +5210,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -5050,1 +5313,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -5078,1 +5341,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -5092,1 +5355,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -5289,1 +5552,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -5316,1 +5579,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -5330,1 +5593,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -5352,1 +5615,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -5360,1 +5623,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -5367,1 +5630,1 @@\n-        Assert.assertEquals(elsize, Float.SIZE);\n+        AssertEquals(elsize, Float.SIZE);\n@@ -5386,1 +5649,1 @@\n-    static void ElementTypeFloatMaxVectorTestsSmokeTest() {\n+    static void FloatFloatMaxVectorTestsSmokeTest() {\n@@ -5421,1 +5684,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":615,"deletions":352,"binary":false,"changes":967,"status":"modified"},{"patch":"@@ -0,0 +1,1016 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @run testng\/othervm -XX:-TieredCompilation Halffloat128VectorLoadStoreTests\n+ *\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.ValueLayout;\n+import jdk.incubator.vector.Float16;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.internal.vm.annotation.DontInline;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.ByteOrder;\n+import java.util.List;\n+import java.util.function.*;\n+\n+@Test\n+public class Halffloat128VectorLoadStoreTests extends AbstractVectorLoadStoreTest {\n+    static final VectorSpecies<Float16> SPECIES =\n+                HalffloatVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n+\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 128);\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0, \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            })\n+    );\n+\n+    \/\/ Relative to array.length\n+    static final List<IntFunction<Integer>> INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl + 1\", (int l) -> {\n+                return l - SPECIES.length() + 1;\n+            }),\n+            withToString(\"l + speciesl - 1\", (int l) -> {\n+                return l + SPECIES.length() - 1;\n+            }),\n+            withToString(\"l + speciesl\", (int l) -> {\n+                return l + SPECIES.length();\n+            }),\n+            withToString(\"l + speciesl + 1\", (int l) -> {\n+                return l + SPECIES.length() + 1;\n+            })\n+    );\n+\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n+    static final List<IntFunction<Integer>> BYTE_INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl*ebsize + 1\", (int l) -> {\n+                return l - SPECIES.vectorByteSize() + 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize - 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() - 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize\", (int l) -> {\n+                return l + SPECIES.vectorByteSize();\n+            }),\n+            withToString(\"l + speciesl*ebsize + 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() + 1;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ELEMENT_LAYOUT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ELEMENT_LAYOUT);\n+    }\n+\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static VectorShuffle<Float16> shuffleFromArray(int[] a, int i) {\n+        return SPECIES.shuffleFromArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void shuffleIntoArray(VectorShuffle<Float16> s, int[] a, int i) {\n+        s.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static VectorShuffle<Float16> shuffleFromMemorySegment(MemorySegment mem, int i, ByteOrder bo) {\n+        return VectorShuffle.fromMemorySegment(SPECIES, mem, i, bo);\n+    }\n+\n+    @DontInline\n+    static void shuffleIntoMemorySegment(VectorShuffle<Float16> s, MemorySegment mem, int i, ByteOrder bo) {\n+        s.intoMemorySegment(mem, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i) {\n+        \/\/ Tests the species method and the equivalent vector method it defers to\n+        return (HalffloatVector) SPECIES.fromArray(a, i);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i, VectorMask<Float16> m) {\n+        return HalffloatVector.fromArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i) {\n+        v.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Float16> m) {\n+        v.intoArray(a, i, m);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        \/\/ Tests the species method and the equivalent vector method it defers to\n+        return (HalffloatVector) SPECIES.fromMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n+\n+    @Test(dataProvider = \"shortProvider\")\n+    static void loadStoreArray(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void loadArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void storeArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMaskArray(IntFunction<short[]> fa,\n+                                   IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void loadArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void storeArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMask(IntFunction<short[]> fa,\n+                              IntFunction<boolean[]> fm) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[mask.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, mask);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        short[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Float16> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Float16> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+\n+   @Test(dataProvider = \"shuffleIntProvider\")\n+   static void loadStoreShuffleArray(IntFunction<int[]> fa) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+               shuffle.intoArray(r, i);\n+           }\n+       }\n+\n+       for (int i = 0; i < a.length; i++) {\n+          Assert.assertEquals(testPartiallyWrapIndex(SPECIES, a[i]), r[i]);\n+       }\n+\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntProviderForIOOBE\")\n+   static void storeShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);\n+               shuffleIntoArray(shuffle, r, i);\n+           }\n+       }\n+\n+       int index = fi.apply(a.length);\n+       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+       try {\n+           VectorShuffle<Float16> shuffle = shuffleFromArray(a, index);\n+           shuffleIntoArray(shuffle, r, index);\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntProviderForIOOBE\")\n+   static void loadShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);\n+               shuffle.intoArray(r, i);\n+           }\n+       }\n+\n+       int index = fi.apply(a.length);\n+       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+       try {\n+           shuffleFromArray(a, index);\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntMemorySegmentProvider\")\n+   static void loadStoreShuffleMemorySegment(IntFunction<int[]> fa,\n+                                      IntFunction<MemorySegment> fb,\n+                                      ByteOrder bo) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), fb);\n+       MemorySegment r = fb.apply((int) a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4; \/\/An integer for every lane is read out. So 4 bytes per lane\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle = VectorShuffle.fromMemorySegment(SPECIES, a, i, bo);\n+               shuffle.intoMemorySegment(r, i, bo);\n+           }\n+       }\n+\n+       for (int i = 0; i < l \/ 4; i++) {\n+           int ai = a.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);\n+           int ri = r.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);\n+           Assert.assertEquals(testPartiallyWrapIndex(SPECIES, ai), ri);\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntByteProviderForIOOBE\")\n+   static void shuffleLoadMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));\n+       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4;\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle = shuffleFromMemorySegment(a, i, ByteOrder.nativeOrder());\n+               shuffle.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+           }\n+       }\n+\n+       int index = fi.apply((int) a.byteSize());\n+       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());\n+       try {\n+           shuffleFromMemorySegment(a, index, ByteOrder.nativeOrder());\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntByteProviderForIOOBE\")\n+   static void shuffleStoreMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));\n+       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4;\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle =\n+                       VectorShuffle.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+               shuffleIntoMemorySegment(shuffle, r, i, ByteOrder.nativeOrder());\n+           }\n+       }\n+\n+       int index = fi.apply((int) a.byteSize());\n+       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());\n+       try {\n+           VectorShuffle<Float16> shuffle =\n+                   VectorShuffle.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+           shuffleIntoMemorySegment(shuffle, r, index, ByteOrder.nativeOrder());\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat128VectorLoadStoreTests.java","additions":1016,"deletions":0,"binary":false,"changes":1016,"status":"added"},{"patch":"@@ -0,0 +1,5740 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.vector\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Halffloat128VectorTests\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.Vector;\n+\n+import jdk.incubator.vector.Float16;\n+import static jdk.incubator.vector.Float16.*;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.Integer;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Test\n+public class Halffloat128VectorTests extends AbstractVectorTest {\n+\n+    static final VectorSpecies<Float16> SPECIES =\n+                HalffloatVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+    static HalffloatVector bcast_vec = HalffloatVector.broadcast(SPECIES, (short)10);\n+\n+    static void AssertEquals(short actual, short expected) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected));\n+    }\n+    static void AssertEquals(short actual, short expected, String msg) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected), msg);\n+    }\n+    static void AssertEquals(short actual, short expected, short delta) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected), Float.float16ToFloat((short)delta));\n+    }\n+    static void AssertEquals(short actual, short expected, short delta, String msg) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected), Float.float16ToFloat((short)delta), msg);\n+    }\n+    static void AssertEquals(short [] actual, short [] expected) {\n+        Assert.assertEquals(actual.length, expected.length);\n+        for (int i = 0; i < actual.length; i++) {\n+            Assert.assertEquals(Float.float16ToFloat((short)actual[i]), Float.float16ToFloat((short)expected[i]));\n+        }\n+    }\n+    static void AssertEquals(short [] actual, short [] expected, String msg) {\n+        Assert.assertEquals(actual.length, expected.length);\n+        for (int i = 0; i < actual.length; i++) {\n+            Assert.assertEquals(Float.float16ToFloat((short)actual[i]), Float.float16ToFloat((short)expected[i]), msg);\n+        }\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected));\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected), msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n+\n+    \/\/ for floating point addition reduction ops that may introduce rounding errors\n+    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_ADD = (short)10.0;\n+\n+    \/\/ for floating point multiplication reduction ops that may introduce rounding errors\n+    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_MUL = (short)50.0;\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 128);\n+\n+    static void assertArraysStrictlyEquals(short[] r, short[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            short ir = r[i];\n+            short ia = a[i];\n+            if (ir != ia) {\n+                Assert.fail(String.format(\"at index #%d, expected = %016X, actual = %016X\", i, ia, ir));\n+            }\n+        }\n+    }\n+\n+    interface FUnOp {\n+        short apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FUnArrayOp {\n+        short[] apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a[i]);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    interface FReductionOp {\n+        short apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOp {\n+        short apply(short[] a);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa) {\n+        assertReductionArraysEquals(r, rc, a, f, fa, (short)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            short relativeErrorFactor) {\n+        int i = 0;\n+        try {\n+            AssertEquals(rc, fa.apply(a), float16ToShortBits(Float16.multiply(Float16.ulp(shortBitsToFloat16(rc)), shortBitsToFloat16(relativeErrorFactor))));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i), float16ToShortBits(Float16.multiply(Float16.ulp(shortBitsToFloat16(r[i])), shortBitsToFloat16(relativeErrorFactor))));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rc, fa.apply(a), float16ToShortBits(Float16.multiply(Float16.ulp(shortBitsToFloat16(rc)), shortBitsToFloat16(relativeErrorFactor))), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), float16ToShortBits(Float16.multiply(Float16.ulp(shortBitsToFloat16(r[i])), shortBitsToFloat16(relativeErrorFactor))), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOp {\n+        short apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOp {\n+        short apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa) {\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (short)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            short relativeError) {\n+        int i = 0;\n+        try {\n+            AssertEquals(rc, fa.apply(a, mask), float16ToShortBits(Float16.abs(Float16.multiply(shortBitsToFloat16(rc), shortBitsToFloat16(relativeError)))));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i, mask), float16ToShortBits(Float16.abs(Float16.multiply(shortBitsToFloat16(r[i]), shortBitsToFloat16(relativeError)))));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rc, fa.apply(a, mask), float16ToShortBits(Float16.abs(Float16.multiply(shortBitsToFloat16(rc), shortBitsToFloat16(relativeError)))), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), float16ToShortBits(Float16.abs(Float16.multiply(shortBitsToFloat16(r[i]), shortBitsToFloat16(relativeError)))), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionOpLong {\n+        long apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOpLong {\n+        long apply(short[] a);\n+    }\n+\n+    static void assertReductionLongArraysEquals(long[] r, long rc, short[] a,\n+                                            FReductionOpLong f, FReductionAllOpLong fa) {\n+        int i = 0;\n+        try {\n+            AssertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOpLong {\n+        long apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOpLong {\n+        long apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionLongArraysEqualsMasked(long[] r, long rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOpLong f, FReductionAllMaskedOpLong fa) {\n+        int i = 0;\n+        try {\n+            AssertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolReductionOp {\n+        boolean apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertReductionBoolArraysEquals(boolean[] r, boolean[] a, FBoolReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FMaskReductionOp {\n+        int apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertMaskReductionArraysEquals(int[] r, boolean[] a, FMaskReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        AssertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    AssertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                AssertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        AssertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        AssertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                AssertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod(shortBitsToFloat16(order[idx]).intValue(), 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        int idx = 0, wrapped_index = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = shortBitsToFloat16(order[i+j]).intValue();\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n+                    else\n+                         AssertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                AssertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        int idx = 0, wrapped_index = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = shortBitsToFloat16(order[i+j]).intValue();\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    if (mask[j % SPECIES.length()])\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n+                    else\n+                         AssertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            if (mask[j % SPECIES.length()])\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                AssertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a) {\n+        int i = 0;\n+        for (; i < a.length; i += SPECIES.length()) {\n+            int idx = i;\n+            for (int j = idx; j < (idx + SPECIES.length()); j++)\n+                a[j]=a[idx];\n+        }\n+\n+        try {\n+            for (i = 0; i < a.length; i++) {\n+                AssertEquals(r[i], a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FBinOp {\n+        short apply(short a, short b);\n+    }\n+\n+    interface FBinMaskOp {\n+        short apply(short a, short b, boolean m);\n+\n+        static FBinMaskOp lift(FBinOp f) {\n+            return (a, b, m) -> m ? f.apply(a, b) : a;\n+        }\n+    }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                AssertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                AssertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertShiftArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FBinConstOp {\n+        short apply(short a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        short apply(short a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FTernOp {\n+        short apply(short a, short b, short c);\n+    }\n+\n+    interface FTernMaskOp {\n+        short apply(short a, short b, short c, boolean m);\n+\n+        static FTernMaskOp lift(FTernOp f) {\n+            return (a, b, c, m) -> m ? f.apply(a, b, c) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernOp f) {\n+        assertArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+              + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[(i \/ SPECIES.length()) * SPECIES.length()] + \",  input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[i] + \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i]\n+                                + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernOp f) {\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]), \"at index #\"\n+                                + i + \", input1 = \" + a[i] + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+\n+    static boolean isWithin1Ulp(short actual, short expected) {\n+        Float16 act = shortBitsToFloat16(actual);\n+        Float16 exp = shortBitsToFloat16(expected);\n+        if (Float16.isNaN(exp) && !Float16.isNaN(act)) {\n+            return false;\n+        } else if (!Float16.isNaN(exp) && Float16.isNaN(act)) {\n+             return false;\n+        }\n+\n+        Float16 low = Float16.nextDown(exp);\n+        Float16 high = Float16.nextUp(exp);\n+\n+        if (Float16.compare(low, exp) > 0) {\n+            return false;\n+        }\n+\n+        if (Float16.compare(high, exp) < 0) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, FUnOp mathf, FUnOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]), shortBitsToFloat16(mathf.apply(a[i]))) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]), shortBitsToFloat16(mathf.apply(a[i]))) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i])), \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i]));\n+        }\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b, FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]), shortBitsToFloat16(mathf.apply(a[i], b[i]))) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]), shortBitsToFloat16(mathf.apply(a[i], b[i]))) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i], b[i]));\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b,\n+                                                        FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]),\n+                                  shortBitsToFloat16(mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]))) == 0 ||\n+                                  isWithin1Ulp(r[i],\n+                                  strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]),\n+                              shortBitsToFloat16(mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]))) == 0,\n+                              \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                              b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                              \", expected = \" + mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            Assert.assertTrue(isWithin1Ulp(r[i],\n+                              strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                             \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                             \", expected (within 1 ulp) = \" + strictmathf.apply(a[i],\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+        }\n+    }\n+\n+    interface FGatherScatterOp {\n+        short[] apply(short[] a, int ix, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, FGatherScatterOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherMaskedOp {\n+        short[] apply(short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    interface FScatterMaskedOp {\n+        short[] apply(short[] r, short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FGatherMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FScatterMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(r, a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(r, a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", r: \"\n+              + Arrays.toString(Arrays.copyOfRange(r, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneOp {\n+        short[] apply(short[] a, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int origin, FLaneOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneBop {\n+        short[] apply(short[] a, short[] b, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, FLaneBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLaneMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, boolean[] mask, FLaneMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLanePartBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, FLanePartBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    interface FLanePartMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, boolean[] mask, FLanePartMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    static short genValue(int i) {\n+        return float16ToShortBits(Float16.valueOf(i));\n+    }\n+\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> INT_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Float16[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(int[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                AssertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static short genValue(long i) {\n+        return float16ToShortBits(Float16.valueOf(i));\n+    }\n+\n+    static final List<IntFunction<short[]>> LONG_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Float16[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(long[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                AssertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(double[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                AssertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static short bits(short e) {\n+        return e;\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Float16[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> Float.floatToFloat16((0.01f + ((float)i \/ (i + 1)))));\n+            }),\n+            withToString(\"Float16[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01f + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (i % 17 == 0) ? cornerCaseValue(i) : Float.floatToFloat16((0.01f + ((float)i \/ (i + 1)))));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    \/\/ Create combinations of pairs\n+    \/\/ @@@ Might be sensitive to order e.g. div by 0\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_PAIRS =\n+        Stream.of(HALFFLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> HALFFLOAT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] boolUnaryOpProvider() {\n+        return BOOL_ARRAY_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> HALFFLOAT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"short[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortIndexedOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortSelectFromTwoVectorOpProvider() {\n+        return HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_TRIPLES.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoIntUnaryOpProvider() {\n+        return INT_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoLongUnaryOpProvider() {\n+        return LONG_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<BiFunction<Integer,Integer,short[]>> HALFFLOAT_SHUFFLE_GENERATORS = List.of(\n+            withToStringBi(\"shuffle[random]\", (Integer l, Integer m) -> {\n+                short[] a = new short[l];\n+                int upper = m;\n+                for (int i = 0; i < 1; i++) {\n+                    a[i] = (short)RAND.nextInt(upper);\n+                }\n+                return a;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromProvider() {\n+        return HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_COMPARE_GENERATORS = List.of(\n+            withToString(\"short[i]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)i);\n+            }),\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i + 1));\n+            }),\n+            withToString(\"short[i - 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - 2));\n+            }),\n+            withToString(\"short[zigZag(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i%3 == 0 ? (short)i : (i%3 == 1 ? (short)(i + 1) : (short)(i - 2)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_TEST_GENERATOR_ARGS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                map(fa -> List.of(fa)).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortTestOpProvider() {\n+        return HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_COMPARE_GENERATOR_PAIRS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                flatMap(fa -> HALFFLOAT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpProvider() {\n+        return HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    static short cornerCaseValue(int i) {\n+        return switch(i % 8) {\n+            case 0  -> float16ToShortBits(Float16.MAX_VALUE);\n+            case 1  -> float16ToShortBits(Float16.MIN_VALUE);\n+            case 2  -> float16ToShortBits(Float16.NEGATIVE_INFINITY);\n+            case 3  -> float16ToShortBits(Float16.POSITIVE_INFINITY);\n+            case 4  -> float16ToShortBits(Float16.NaN);\n+            case 5  -> float16ToShortBits(shortBitsToFloat16((short)0x7FFA));\n+            case 6  -> ((short)0.0);\n+            default -> ((short)-0.0);\n+        };\n+    }\n+\n+    static final IntFunction<short[]> fr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new short[length];\n+    };\n+\n+    static final IntFunction<boolean[]> fmr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new boolean[length];\n+    };\n+\n+    static final IntFunction<long[]> lfr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new long[length];\n+    };\n+\n+    static boolean eq(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() == bt.floatValue();\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() != bt.floatValue();\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() < bt.floatValue();\n+    }\n+\n+    static boolean le(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() <= bt.floatValue();\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() > bt.floatValue();\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() >= bt.floatValue();\n+    }\n+\n+    static short firstNonZero(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        Float16 zero = shortBitsToFloat16((short)0);\n+        return Float16.compare(at, zero) != 0 ? a : b;\n+    }\n+\n+    static short multiplicativeIdentity() {\n+        return (short)float16ToShortBits(Float16.valueOf(1.0f));\n+    }\n+\n+    static short scalar_add(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.add(at, bt));\n+    }\n+\n+    static short scalar_sub(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.subtract(at, bt));\n+    }\n+\n+    static short scalar_mul(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.multiply(at, bt));\n+\n+    }\n+    static short scalar_max(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.max(at, bt));\n+    }\n+\n+    static short scalar_min(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.min(at, bt));\n+    }\n+\n+    static short scalar_div(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.divide(at, bt));\n+    }\n+\n+    static short scalar_fma(short a, short b, short c) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        Float16 ct = shortBitsToFloat16(c);\n+        return float16ToShortBits(Float16.fma(at, bt, ct));\n+    }\n+\n+    static short scalar_abs(short a) {\n+        Float16 at = shortBitsToFloat16(a);\n+        return float16ToShortBits(Float16.abs(at));\n+    }\n+\n+    static short scalar_neg(short a) {\n+        Float16 at = shortBitsToFloat16(a);\n+        return float16ToShortBits(Float16.valueOf(-at.floatValue()));\n+    }\n+\n+    static short scalar_sin(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.sin(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_exp(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.exp(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_log1p(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.log1p(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_log(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.log(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_log10(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.log10(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_expm1(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.expm1(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_cos(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.cos(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_tan(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.tan(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_sinh(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.sinh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_cosh(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.cosh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_tanh(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.tanh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_asin(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.asin(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_acos(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.acos(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_atan(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.atan(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_cbrt(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.cbrt(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_sqrt(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.sqrt(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_hypot(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(Math.hypot(shortBitsToFloat16(a).doubleValue(),\n+                                                                     shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static short scalar_pow(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(Math.pow(shortBitsToFloat16(a).doubleValue(),\n+                                                                   shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static short scalar_atan2(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(Math.atan2(shortBitsToFloat16(a).doubleValue(),\n+                                                                     shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static short strict_scalar_sin(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.sin(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_exp(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.exp(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_log1p(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.log1p(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_log(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.log(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_log10(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.log10(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_expm1(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.expm1(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_cos(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.cos(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_tan(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.tan(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_sinh(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.sinh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_cosh(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.cosh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_tanh(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.tanh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_asin(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.asin(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_acos(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.acos(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_atan(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.atan(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_cbrt(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.cbrt(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_sqrt(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.sqrt(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_hypot(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.hypot(shortBitsToFloat16(a).doubleValue(),\n+                                                                     shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static short strict_scalar_pow(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.pow(shortBitsToFloat16(a).doubleValue(),\n+                                                                   shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static short strict_scalar_atan2(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.atan2(shortBitsToFloat16(a).doubleValue(),\n+                                                                     shortBitsToFloat16(b).doubleValue())));\n+    }\n+    static short additiveIdentity() {\n+        return (short)0;\n+    }\n+\n+\n+    static short zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static short maxValue() {\n+        return float16ToShortBits(Float16.POSITIVE_INFINITY);\n+    }\n+\n+    static short minValue() {\n+        return float16ToShortBits(Float16.NEGATIVE_INFINITY);\n+    }\n+\n+    static boolean isNaN(short a) {\n+        return Float16.isNaN(shortBitsToFloat16(a));\n+    }\n+    static boolean isFinite(short a) {\n+        return Float16.isFinite(shortBitsToFloat16(a));\n+    }\n+    static boolean isInfinite(short a) {\n+        return Float16.isInfinite(shortBitsToFloat16(a));\n+    }\n+\n+    @Test\n+    static void smokeTest1() {\n+        HalffloatVector three = HalffloatVector.broadcast(SPECIES, float16ToShortBits(Float16.valueOf(-3)));\n+        HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(float16ToShortBits(Float16.valueOf(-3)));\n+        assert(three.eq(three2).allTrue());\n+        HalffloatVector three3 = three2.broadcast(float16ToShortBits(Float16.valueOf(1))).broadcast(float16ToShortBits(Float16.valueOf(-3)));\n+        assert(three.eq(three3).allTrue());\n+        int scale = 2;\n+        HalffloatVector higher = three.addIndex(scale);\n+        VectorMask<Float16> m = three.compare(VectorOperators.LE, higher);\n+        assert(m.allTrue());\n+        m = higher.min((float16ToShortBits(Float16.valueOf(-1)))).test(VectorOperators.IS_NEGATIVE);\n+        assert(m.allTrue());\n+        m = higher.test(VectorOperators.IS_FINITE);\n+        assert(m.allTrue());\n+        short max = higher.reduceLanes(VectorOperators.MAX);\n+        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));\n+    }\n+\n+    private static short[]\n+    bothToArray(HalffloatVector a, HalffloatVector b) {\n+        short[] r = new short[a.length() + b.length()];\n+        a.intoArray(r, 0);\n+        b.intoArray(r, a.length());\n+        return r;\n+    }\n+\n+    @Test\n+    static void smokeTest2() {\n+        \/\/ Do some zipping and shuffling.\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES,0,1,false).toVector();\n+        AssertEquals(io, io2);\n+        HalffloatVector a = io.add((short)1); \/\/[1,2]\n+        HalffloatVector b = a.neg();  \/\/[-1,-2]\n+        short[] abValues = bothToArray(a,b); \/\/[1,2,-1,-2]\n+        VectorShuffle<Float16> zip0 = VectorShuffle.makeZip(SPECIES, 0);\n+        VectorShuffle<Float16> zip1 = VectorShuffle.makeZip(SPECIES, 1);\n+        HalffloatVector zab0 = a.rearrange(zip0,b); \/\/[1,-1]\n+        HalffloatVector zab1 = a.rearrange(zip1,b); \/\/[2,-2]\n+        short[] zabValues = bothToArray(zab0, zab1); \/\/[1,-1,2,-2]\n+        \/\/ manually zip\n+        short[] manual = new short[zabValues.length];\n+        for (int i = 0; i < manual.length; i += 2) {\n+            manual[i+0] = abValues[i\/2];\n+            manual[i+1] = abValues[a.length() + i\/2];\n+        }\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        VectorShuffle<Float16> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);\n+        VectorShuffle<Float16> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);\n+        HalffloatVector uab0 = zab0.rearrange(unz0,zab1);\n+        HalffloatVector uab1 = zab0.rearrange(unz1,zab1);\n+        short[] abValues1 = bothToArray(uab0, uab1);\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+    }\n+\n+    static void iotaShuffle() {\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES, 0 , 1, false).toVector();\n+        AssertEquals(io, io2);\n+    }\n+\n+    @Test\n+    \/\/ Test all shuffle related operations.\n+    static void shuffleTest() {\n+        \/\/ To test backend instructions, make sure that C2 is used.\n+        for (int loop = 0; loop < INVOC_COUNT * INVOC_COUNT; loop++) {\n+            iotaShuffle();\n+        }\n+    }\n+\n+    @Test\n+    void viewAsIntegeralLanesTest() {\n+        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();\n+        VectorSpecies<?> asIntegralSpecies = asIntegral.species();\n+        Assert.assertNotEquals(asIntegralSpecies.elementType(), SPECIES.elementType());\n+        AssertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        AssertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+    }\n+\n+    @Test\n+    void viewAsFloatingLanesTest() {\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        AssertEquals(asFloating.species(), SPECIES);\n+    }\n+\n+    static short ADD(short a, short b) {\n+        return (short)(scalar_add(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::ADD);\n+    }\n+\n+    static short add(short a, short b) {\n+        return (short)(scalar_add(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void addHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.add(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::add);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void addHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.add(bv, vmask).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::add);\n+    }\n+\n+    static short SUB(short a, short b) {\n+        return (short)(scalar_sub(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void SUBHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::SUB);\n+    }\n+\n+    static short sub(short a, short b) {\n+        return (short)(scalar_sub(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void subHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.sub(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::sub);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void SUBHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::SUB);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void subHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.sub(bv, vmask).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::sub);\n+    }\n+\n+    static short MUL(short a, short b) {\n+        return (short)(scalar_mul(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MULHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::MUL);\n+    }\n+\n+    static short mul(short a, short b) {\n+        return (short)(scalar_mul(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void mulHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.mul(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::mul);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MULHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::MUL);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void mulHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.mul(bv, vmask).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::mul);\n+    }\n+\n+    static short DIV(short a, short b) {\n+        return (short)(scalar_div(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void DIVHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::DIV);\n+    }\n+\n+    static short div(short a, short b) {\n+        return (short)(scalar_div(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void divHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.div(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::div);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void DIVHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::DIV);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void divHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.div(bv, vmask).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::div);\n+    }\n+\n+    static short FIRST_NONZERO(short a, short b) {\n+        return (short)(firstNonZero(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void FIRST_NONZEROHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::FIRST_NONZERO);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void FIRST_NONZEROHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::FIRST_NONZERO);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void addHalffloat128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.add(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat128VectorTests::add);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void addHalffloat128VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.add(b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, Halffloat128VectorTests::add);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void subHalffloat128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.sub(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat128VectorTests::sub);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void subHalffloat128VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.sub(b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, Halffloat128VectorTests::sub);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void mulHalffloat128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.mul(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat128VectorTests::mul);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void mulHalffloat128VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.mul(b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, Halffloat128VectorTests::mul);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void divHalffloat128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.div(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat128VectorTests::div);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void divHalffloat128VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.div(b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, Halffloat128VectorTests::div);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDHalffloat128VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(r, a, b, Halffloat128VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDHalffloat128VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(r, a, b, mask, Halffloat128VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINHalffloat128VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Halffloat128VectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void minHalffloat128VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.min(bcast_vec).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Halffloat128VectorTests::min);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MINHalffloat128VectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, Halffloat128VectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXHalffloat128VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Halffloat128VectorTests::MAX);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void maxHalffloat128VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.max(bcast_vec).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Halffloat128VectorTests::max);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MAXHalffloat128VectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, Halffloat128VectorTests::MAX);\n+    }\n+\n+    static short MIN(short a, short b) {\n+        return (short)(scalar_min(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MINHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::MIN);\n+    }\n+\n+    static short min(short a, short b) {\n+        return (short)(scalar_min(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void minHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.min(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::min);\n+    }\n+\n+    static short MAX(short a, short b) {\n+        return (short)(scalar_max(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MAXHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::MAX);\n+    }\n+\n+    static short max(short a, short b) {\n+        return (short)(scalar_max(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void maxHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.max(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::max);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MINHalffloat128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.MIN, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat128VectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void minHalffloat128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.min(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat128VectorTests::min);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MAXHalffloat128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.MAX, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat128VectorTests::MAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void maxHalffloat128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.max(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat128VectorTests::max);\n+    }\n+\n+    static short ADDReduce(short[] a, int idx) {\n+        short res = additiveIdentity();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = scalar_add(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short ADDReduceAll(short[] a) {\n+        short res = additiveIdentity();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_add(res, ADDReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = additiveIdentity();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = additiveIdentity();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Halffloat128VectorTests::ADDReduce, Halffloat128VectorTests::ADDReduceAll, RELATIVE_ROUNDING_ERROR_FACTOR_ADD);\n+    }\n+\n+    static short ADDReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = additiveIdentity();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = scalar_add(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short ADDReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = additiveIdentity();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ADDReduceHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = additiveIdentity();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = additiveIdentity();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat128VectorTests::ADDReduceMasked, Halffloat128VectorTests::ADDReduceAllMasked, RELATIVE_ROUNDING_ERROR_FACTOR_ADD);\n+    }\n+\n+    static short MULReduce(short[] a, int idx) {\n+        short res = multiplicativeIdentity();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = scalar_mul(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MULReduceAll(short[] a) {\n+        short res = multiplicativeIdentity();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_mul(res, MULReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MULReduceHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = multiplicativeIdentity();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = multiplicativeIdentity();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Halffloat128VectorTests::MULReduce, Halffloat128VectorTests::MULReduceAll, RELATIVE_ROUNDING_ERROR_FACTOR_MUL);\n+    }\n+\n+    static short MULReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = multiplicativeIdentity();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = scalar_mul(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MULReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = multiplicativeIdentity();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MULReduceHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = multiplicativeIdentity();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = multiplicativeIdentity();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat128VectorTests::MULReduceMasked, Halffloat128VectorTests::MULReduceAllMasked, RELATIVE_ROUNDING_ERROR_FACTOR_MUL);\n+    }\n+\n+    static short MINReduce(short[] a, int idx) {\n+        short res = maxValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = scalar_min(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MINReduceAll(short[] a) {\n+        short res = maxValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_min(res, MINReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINReduceHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = maxValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MIN);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = maxValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Halffloat128VectorTests::MINReduce, Halffloat128VectorTests::MINReduceAll);\n+    }\n+\n+    static short MINReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = maxValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = scalar_min(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MINReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = maxValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MINReduceHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = maxValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = maxValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat128VectorTests::MINReduceMasked, Halffloat128VectorTests::MINReduceAllMasked);\n+    }\n+\n+    static short MAXReduce(short[] a, int idx) {\n+        short res = minValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = scalar_max(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MAXReduceAll(short[] a) {\n+        short res = minValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_max(res, MAXReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXReduceHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = minValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MAX);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = minValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Halffloat128VectorTests::MAXReduce, Halffloat128VectorTests::MAXReduceAll);\n+    }\n+\n+    static short MAXReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = minValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = scalar_max(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MAXReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = minValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MAXReduceHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = minValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = minValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat128VectorTests::MAXReduceMasked, Halffloat128VectorTests::MAXReduceAllMasked);\n+    }\n+\n+    static short FIRST_NONZEROReduce(short[] a, int idx) {\n+        short res = zeroValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short FIRST_NONZEROReduceAll(short[] a) {\n+        short res = zeroValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = zeroValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = zeroValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Halffloat128VectorTests::FIRST_NONZEROReduce, Halffloat128VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+\n+    static short FIRST_NONZEROReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = zeroValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short FIRST_NONZEROReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = zeroValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = zeroValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = zeroValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat128VectorTests::FIRST_NONZEROReduceMasked, Halffloat128VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void withHalffloat128VectorTests(IntFunction<short []> fa, IntFunction<short []> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+\n+        assertArraysStrictlyEquals(r, a);\n+    }\n+\n+    static boolean testIS_DEFAULT(short a) {\n+        return bits(a)==0;\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpProvider\")\n+    static void IS_DEFAULTHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_DEFAULT);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedHalffloat128VectorTests(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    static boolean testIS_NEGATIVE(short a) {\n+        return bits(a)<0;\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpProvider\")\n+    static void IS_NEGATIVEHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_NEGATIVE);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedHalffloat128VectorTests(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    static boolean testIS_FINITE(short a) {\n+        return isFinite(a);\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpProvider\")\n+    static void IS_FINITEHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_FINITE);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), testIS_FINITE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_FINITEMaskedHalffloat128VectorTests(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    static boolean testIS_NAN(short a) {\n+        return isNaN(a);\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpProvider\")\n+    static void IS_NANHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_NAN);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), testIS_NAN(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_NANMaskedHalffloat128VectorTests(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_NAN, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    static boolean testIS_INFINITE(short a) {\n+        return isInfinite(a);\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpProvider\")\n+    static void IS_INFINITEHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_INFINITE);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), testIS_INFINITE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_INFINITEMaskedHalffloat128VectorTests(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void LTHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.lt(bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void LTHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void GTHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void GTHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void EQHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.EQ, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.eq(bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void EQHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.EQ, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void NEHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.NE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void NEHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.NE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void LEHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void LEHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void GEHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void GEHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void LTHalffloat128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.LT, b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void LTHalffloat128VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa,\n+                                IntFunction<short[]> fb, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.LT, b[i], vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void LTHalffloat128VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.LT, (long)b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (short)((long)b[i])));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void LTHalffloat128VectorTestsBroadcastLongMaskedSmokeTest(IntFunction<short[]> fa,\n+                                IntFunction<short[]> fb, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.LT, (long)b[i], vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(short)((long)b[i]))));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void EQHalffloat128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.EQ, b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void EQHalffloat128VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa,\n+                                IntFunction<short[]> fb, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.EQ, b[i], vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void EQHalffloat128VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.EQ, (long)b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (short)((long)b[i])));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void EQHalffloat128VectorTestsBroadcastLongMaskedSmokeTest(IntFunction<short[]> fa,\n+                                IntFunction<short[]> fb, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.EQ, (long)b[i], vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(short)((long)b[i]))));\n+            }\n+        }\n+    }\n+\n+    static short blend(short a, short b, boolean mask) {\n+        return mask ? b : a;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::blend);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpShuffleProvider\")\n+    static void RearrangeHalffloat128VectorTests(IntFunction<short[]> fa,\n+                                           BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        assertRearrangeArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpShuffleMaskProvider\")\n+    static void RearrangeHalffloat128VectorTestsMaskedSmokeTest(IntFunction<short[]> fa,\n+                                                          BiFunction<Integer,Integer,int[]> fs,\n+                                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.rearrange(VectorShuffle.fromArray(SPECIES, order, i), vmask).intoArray(r, i);\n+        }\n+\n+        assertRearrangeArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void compressHalffloat128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void expandHalffloat128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void getHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        assertArraysStrictlyEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void BroadcastHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ZeroHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        AssertEquals(a, r);\n+    }\n+\n+    static short[] sliceUnary(short[] a, int origin, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0; i < SPECIES.length(); i++){\n+            if(i+origin < SPECIES.length())\n+                res[i] = a[idx+i+origin];\n+            else\n+                res[i] = (short)0;\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void sliceUnaryHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, origin, Halffloat128VectorTests::sliceUnary);\n+    }\n+\n+    static short[] sliceBinary(short[] a, short[] b, int origin, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if(i+origin < SPECIES.length())\n+                res[i] = a[idx+i+origin];\n+            else {\n+                res[i] = b[idx+j];\n+                j++;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void sliceBinaryHalffloat128VectorTestsBinary(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, origin, Halffloat128VectorTests::sliceBinary);\n+    }\n+\n+    static short[] slice(short[] a, short[] b, int origin, boolean[] mask, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if(i+origin < SPECIES.length())\n+                res[i] = mask[i] ? a[idx+i+origin] : (short)0;\n+            else {\n+                res[i] = mask[i] ? b[idx+j] : (short)0;\n+                j++;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void sliceHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, origin, mask, Halffloat128VectorTests::slice);\n+    }\n+\n+    static short[] unsliceUnary(short[] a, int origin, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if(i < origin)\n+                res[i] = (short)0;\n+            else {\n+                res[i] = a[idx+j];\n+                j++;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void unsliceUnaryHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, origin, Halffloat128VectorTests::unsliceUnary);\n+    }\n+\n+    static short[] unsliceBinary(short[] a, short[] b, int origin, int part, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if (part == 0) {\n+                if (i < origin)\n+                    res[i] = b[idx+i];\n+                else {\n+                    res[i] = a[idx+j];\n+                    j++;\n+                }\n+            } else if (part == 1) {\n+                if (i < origin)\n+                    res[i] = a[idx+SPECIES.length()-origin+i];\n+                else {\n+                    res[i] = b[idx+origin+j];\n+                    j++;\n+                }\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void unsliceBinaryHalffloat128VectorTestsBinary(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, origin, part, Halffloat128VectorTests::unsliceBinary);\n+    }\n+\n+    static short[] unslice(short[] a, short[] b, int origin, int part, boolean[] mask, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if(i+origin < SPECIES.length())\n+                res[i] = b[idx+i+origin];\n+            else {\n+                res[i] = b[idx+j];\n+                j++;\n+            }\n+        }\n+        for (int i = 0; i < SPECIES.length(); i++){\n+            res[i] = mask[i] ? a[idx+i] : res[i];\n+        }\n+        short[] res1 = new short[SPECIES.length()];\n+        if (part == 0) {\n+            for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+                if (i < origin)\n+                    res1[i] = b[idx+i];\n+                else {\n+                   res1[i] = res[j];\n+                   j++;\n+                }\n+            }\n+        } else if (part == 1) {\n+            for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+                if (i < origin)\n+                    res1[i] = res[SPECIES.length()-origin+i];\n+                else {\n+                    res1[i] = b[idx+origin+j];\n+                    j++;\n+                }\n+            }\n+        }\n+        return res1;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void unsliceHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, origin, part, mask, Halffloat128VectorTests::unslice);\n+    }\n+\n+    static short SIN(short a) {\n+        return (short)(scalar_sin(a));\n+    }\n+\n+    static short strictSIN(short a) {\n+        return (short)(strict_scalar_sin(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::SIN, Halffloat128VectorTests::strictSIN);\n+    }\n+\n+    static short EXP(short a) {\n+        return (short)(scalar_exp(a));\n+    }\n+\n+    static short strictEXP(short a) {\n+        return (short)(strict_scalar_exp(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::EXP, Halffloat128VectorTests::strictEXP);\n+    }\n+\n+    static short LOG1P(short a) {\n+        return (short)(scalar_log1p(a));\n+    }\n+\n+    static short strictLOG1P(short a) {\n+        return (short)(strict_scalar_log1p(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG1PHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::LOG1P, Halffloat128VectorTests::strictLOG1P);\n+    }\n+\n+    static short LOG(short a) {\n+        return (short)(scalar_log(a));\n+    }\n+\n+    static short strictLOG(short a) {\n+        return (short)(strict_scalar_log(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOGHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::LOG, Halffloat128VectorTests::strictLOG);\n+    }\n+\n+    static short LOG10(short a) {\n+        return (short)(scalar_log10(a));\n+    }\n+\n+    static short strictLOG10(short a) {\n+        return (short)(strict_scalar_log10(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG10Halffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::LOG10, Halffloat128VectorTests::strictLOG10);\n+    }\n+\n+    static short EXPM1(short a) {\n+        return (short)(scalar_expm1(a));\n+    }\n+\n+    static short strictEXPM1(short a) {\n+        return (short)(strict_scalar_expm1(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPM1Halffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::EXPM1, Halffloat128VectorTests::strictEXPM1);\n+    }\n+\n+    static short COS(short a) {\n+        return (short)(scalar_cos(a));\n+    }\n+\n+    static short strictCOS(short a) {\n+        return (short)(strict_scalar_cos(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::COS, Halffloat128VectorTests::strictCOS);\n+    }\n+\n+    static short TAN(short a) {\n+        return (short)(scalar_tan(a));\n+    }\n+\n+    static short strictTAN(short a) {\n+        return (short)(strict_scalar_tan(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::TAN, Halffloat128VectorTests::strictTAN);\n+    }\n+\n+    static short SINH(short a) {\n+        return (short)(scalar_sinh(a));\n+    }\n+\n+    static short strictSINH(short a) {\n+        return (short)(strict_scalar_sinh(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::SINH, Halffloat128VectorTests::strictSINH);\n+    }\n+\n+    static short COSH(short a) {\n+        return (short)(scalar_cosh(a));\n+    }\n+\n+    static short strictCOSH(short a) {\n+        return (short)(strict_scalar_cosh(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::COSH, Halffloat128VectorTests::strictCOSH);\n+    }\n+\n+    static short TANH(short a) {\n+        return (short)(scalar_tanh(a));\n+    }\n+\n+    static short strictTANH(short a) {\n+        return (short)(strict_scalar_tanh(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::TANH, Halffloat128VectorTests::strictTANH);\n+    }\n+\n+    static short ASIN(short a) {\n+        return (short)(scalar_asin(a));\n+    }\n+\n+    static short strictASIN(short a) {\n+        return (short)(strict_scalar_asin(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ASINHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::ASIN, Halffloat128VectorTests::strictASIN);\n+    }\n+\n+    static short ACOS(short a) {\n+        return (short)(scalar_acos(a));\n+    }\n+\n+    static short strictACOS(short a) {\n+        return (short)(strict_scalar_acos(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ACOSHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::ACOS, Halffloat128VectorTests::strictACOS);\n+    }\n+\n+    static short ATAN(short a) {\n+        return (short)(scalar_atan(a));\n+    }\n+\n+    static short strictATAN(short a) {\n+        return (short)(strict_scalar_atan(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ATANHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::ATAN, Halffloat128VectorTests::strictATAN);\n+    }\n+\n+    static short CBRT(short a) {\n+        return (short)(scalar_cbrt(a));\n+    }\n+\n+    static short strictCBRT(short a) {\n+        return (short)(strict_scalar_cbrt(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CBRTHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::CBRT, Halffloat128VectorTests::strictCBRT);\n+    }\n+\n+    static short HYPOT(short a, short b) {\n+        return (short)(scalar_hypot(a, b));\n+    }\n+\n+    static short strictHYPOT(short a, short b) {\n+        return (short)(strict_scalar_hypot(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void HYPOTHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::HYPOT, Halffloat128VectorTests::strictHYPOT);\n+    }\n+\n+\n+    static short POW(short a, short b) {\n+        return (short)(scalar_pow(a, b));\n+    }\n+\n+    static short strictPOW(short a, short b) {\n+        return (short)(strict_scalar_pow(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::POW, Halffloat128VectorTests::strictPOW);\n+    }\n+\n+\n+    static short pow(short a, short b) {\n+        return (short)(scalar_pow(a, b));\n+    }\n+\n+    static short strictpow(short a, short b) {\n+        return (short)(strict_scalar_pow(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.pow(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::pow, Halffloat128VectorTests::strictpow);\n+    }\n+\n+\n+    static short ATAN2(short a, short b) {\n+        return (short)(scalar_atan2(a, b));\n+    }\n+\n+    static short strictATAN2(short a, short b) {\n+        return (short)(strict_scalar_atan2(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ATAN2Halffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::ATAN2, Halffloat128VectorTests::strictATAN2);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.POW, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::POW, Halffloat128VectorTests::strictPOW);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.pow(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::pow, Halffloat128VectorTests::strictpow);\n+    }\n+\n+\n+    static short FMA(short a, short b, short c) {\n+        return (short)(scalar_fma(a, b, c));\n+    }\n+\n+    static short fma(short a, short b, short c) {\n+        return (short)(scalar_fma(a, b, c));\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat128VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void fmaHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.fma(bv, cv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat128VectorTests::fma);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, mask, Halffloat128VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.lanewise(VectorOperators.FMA, bv, c[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a, b, c, Halffloat128VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat128VectorTestsAltBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.lanewise(VectorOperators.FMA, b[i], cv).intoArray(r, i);\n+        }\n+        assertAltBroadcastArraysEquals(r, a, b, c, Halffloat128VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat128VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.lanewise(VectorOperators.FMA, bv, c[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, c, mask, Halffloat128VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat128VectorTestsAltBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.lanewise(VectorOperators.FMA, b[i], cv, vmask).intoArray(r, i);\n+        }\n+\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, Halffloat128VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat128VectorTestsDoubleBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.FMA, b[i], c[i]).intoArray(r, i);\n+        }\n+\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, Halffloat128VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void fmaHalffloat128VectorTestsDoubleBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.fma(b[i], c[i]).intoArray(r, i);\n+        }\n+\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, Halffloat128VectorTests::fma);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat128VectorTestsDoubleBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.FMA, b[i], c[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, Halffloat128VectorTests::FMA);\n+    }\n+\n+    static short NEG(short a) {\n+        return (short)(scalar_neg((short)a));\n+    }\n+\n+    static short neg(short a) {\n+        return (short)(scalar_neg((short)a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void NEGHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat128VectorTests::NEG);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void negHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.neg().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat128VectorTests::neg);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void NEGMaskedHalffloat128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat128VectorTests::NEG);\n+    }\n+\n+    static short ABS(short a) {\n+        return (short)(scalar_abs((short)a));\n+    }\n+\n+    static short abs(short a) {\n+        return (short)(scalar_abs((short)a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ABSHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat128VectorTests::ABS);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void absHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.abs().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat128VectorTests::abs);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ABSMaskedHalffloat128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat128VectorTests::ABS);\n+    }\n+\n+    static short SQRT(short a) {\n+        return (short)(scalar_sqrt(a));\n+    }\n+\n+    static short sqrt(short a) {\n+        return (short)(scalar_sqrt(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SQRTHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat128VectorTests::SQRT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void sqrtHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.sqrt().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat128VectorTests::sqrt);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void SQRTMaskedHalffloat128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat128VectorTests::SQRT);\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltHalffloat128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqHalffloat128VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoIntUnaryOpProvider\")\n+    static void toIntArrayHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int[] r = av.toIntArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void toLongArrayHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            long[] r = av.toLongArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toDoubleArrayHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            double[] r = av.toDoubleArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toStringHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void hashCodeHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n+    static long ADDReduceLong(short[] a, int idx) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLong(short[] a) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = Float.floatToFloat16(Float.float16ToFloat((short)res) + Float.float16ToFloat((short)ADDReduceLong(a, i)));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceLongHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            ra = (long)(Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16((short)ra), Float16.shortBitsToFloat16((short)r[i]))));\n+        }\n+\n+        assertReductionLongArraysEquals(r, ra, a,\n+                Halffloat128VectorTests::ADDReduceLong, Halffloat128VectorTests::ADDReduceAllLong);\n+    }\n+\n+    static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if(mask[i % SPECIES.length()])\n+                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = Float.floatToFloat16(Float.float16ToFloat((short)res) + Float.float16ToFloat((short)ADDReduceLongMasked(a, i, mask)));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ADDReduceLongHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            ra = (long)(Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16((short)ra), Float16.shortBitsToFloat16((short)r[i]))));\n+        }\n+\n+        assertReductionLongArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat128VectorTests::ADDReduceLongMasked, Halffloat128VectorTests::ADDReduceAllLongMasked);\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void BroadcastLongHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat128VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(r, a, b, mask, Halffloat128VectorTests::blend);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromProvider\")\n+    static void SelectFromHalffloat128VectorTests(IntFunction<short[]> fa,\n+                                           BiFunction<Integer,Integer,short[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] idx = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector idxv = HalffloatVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromMaskProvider\")\n+    static void SelectFromHalffloat128VectorTestsMaskedSmokeTest(IntFunction<short[]> fa,\n+                                                           BiFunction<Integer,Integer,short[]> fs,\n+                                                           IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av, vmask).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousHalffloat128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            AssertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringHalffloat128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsHalffloat128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    static int maskTrueCount(boolean[] a, int idx) {\n+        int trueCount = 0;\n+        for (int i = idx; i < idx + SPECIES.length(); i++) {\n+            trueCount += a[i] ? 1 : 0;\n+        }\n+        return trueCount;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.trueCount();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat128VectorTests::maskTrueCount);\n+    }\n+\n+    static int maskLastTrue(boolean[] a, int idx) {\n+        int i = idx + SPECIES.length() - 1;\n+        for (; i >= idx; i--) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.lastTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat128VectorTests::maskLastTrue);\n+    }\n+\n+    static int maskFirstTrue(boolean[] a, int idx) {\n+        int i = idx;\n+        for (; i < idx + SPECIES.length(); i++) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskFirstTrueHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.firstTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat128VectorTests::maskFirstTrue);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongHalffloat128VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeHalffloat128VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongHalffloat128VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundHalffloat128VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongHalffloat128VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test\n+    static void ElementSizeHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        int elsize = av.elementSize();\n+        AssertEquals(elsize, Float16.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorShapeHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        assert(vsh.equals(VectorShape.S_128_BIT));\n+    }\n+\n+    @Test\n+    static void ShapeWithLanesHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(Float16.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void HalffloatHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementType() == Float16.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Float16.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(Float16.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void MaskAllTrueHalffloat128VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat128VectorTests.java","additions":5740,"deletions":0,"binary":false,"changes":5740,"status":"added"},{"patch":"@@ -0,0 +1,1016 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @run testng\/othervm -XX:-TieredCompilation Halffloat256VectorLoadStoreTests\n+ *\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.ValueLayout;\n+import jdk.incubator.vector.Float16;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.internal.vm.annotation.DontInline;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.ByteOrder;\n+import java.util.List;\n+import java.util.function.*;\n+\n+@Test\n+public class Halffloat256VectorLoadStoreTests extends AbstractVectorLoadStoreTest {\n+    static final VectorSpecies<Float16> SPECIES =\n+                HalffloatVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n+\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 256);\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0, \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            })\n+    );\n+\n+    \/\/ Relative to array.length\n+    static final List<IntFunction<Integer>> INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl + 1\", (int l) -> {\n+                return l - SPECIES.length() + 1;\n+            }),\n+            withToString(\"l + speciesl - 1\", (int l) -> {\n+                return l + SPECIES.length() - 1;\n+            }),\n+            withToString(\"l + speciesl\", (int l) -> {\n+                return l + SPECIES.length();\n+            }),\n+            withToString(\"l + speciesl + 1\", (int l) -> {\n+                return l + SPECIES.length() + 1;\n+            })\n+    );\n+\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n+    static final List<IntFunction<Integer>> BYTE_INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl*ebsize + 1\", (int l) -> {\n+                return l - SPECIES.vectorByteSize() + 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize - 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() - 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize\", (int l) -> {\n+                return l + SPECIES.vectorByteSize();\n+            }),\n+            withToString(\"l + speciesl*ebsize + 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() + 1;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ELEMENT_LAYOUT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ELEMENT_LAYOUT);\n+    }\n+\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static VectorShuffle<Float16> shuffleFromArray(int[] a, int i) {\n+        return SPECIES.shuffleFromArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void shuffleIntoArray(VectorShuffle<Float16> s, int[] a, int i) {\n+        s.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static VectorShuffle<Float16> shuffleFromMemorySegment(MemorySegment mem, int i, ByteOrder bo) {\n+        return VectorShuffle.fromMemorySegment(SPECIES, mem, i, bo);\n+    }\n+\n+    @DontInline\n+    static void shuffleIntoMemorySegment(VectorShuffle<Float16> s, MemorySegment mem, int i, ByteOrder bo) {\n+        s.intoMemorySegment(mem, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i) {\n+        \/\/ Tests the species method and the equivalent vector method it defers to\n+        return (HalffloatVector) SPECIES.fromArray(a, i);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i, VectorMask<Float16> m) {\n+        return HalffloatVector.fromArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i) {\n+        v.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Float16> m) {\n+        v.intoArray(a, i, m);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        \/\/ Tests the species method and the equivalent vector method it defers to\n+        return (HalffloatVector) SPECIES.fromMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n+\n+    @Test(dataProvider = \"shortProvider\")\n+    static void loadStoreArray(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void loadArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void storeArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMaskArray(IntFunction<short[]> fa,\n+                                   IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void loadArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void storeArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMask(IntFunction<short[]> fa,\n+                              IntFunction<boolean[]> fm) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[mask.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, mask);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        short[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Float16> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Float16> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+\n+   @Test(dataProvider = \"shuffleIntProvider\")\n+   static void loadStoreShuffleArray(IntFunction<int[]> fa) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+               shuffle.intoArray(r, i);\n+           }\n+       }\n+\n+       for (int i = 0; i < a.length; i++) {\n+          Assert.assertEquals(testPartiallyWrapIndex(SPECIES, a[i]), r[i]);\n+       }\n+\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntProviderForIOOBE\")\n+   static void storeShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);\n+               shuffleIntoArray(shuffle, r, i);\n+           }\n+       }\n+\n+       int index = fi.apply(a.length);\n+       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+       try {\n+           VectorShuffle<Float16> shuffle = shuffleFromArray(a, index);\n+           shuffleIntoArray(shuffle, r, index);\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntProviderForIOOBE\")\n+   static void loadShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);\n+               shuffle.intoArray(r, i);\n+           }\n+       }\n+\n+       int index = fi.apply(a.length);\n+       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+       try {\n+           shuffleFromArray(a, index);\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntMemorySegmentProvider\")\n+   static void loadStoreShuffleMemorySegment(IntFunction<int[]> fa,\n+                                      IntFunction<MemorySegment> fb,\n+                                      ByteOrder bo) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), fb);\n+       MemorySegment r = fb.apply((int) a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4; \/\/An integer for every lane is read out. So 4 bytes per lane\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle = VectorShuffle.fromMemorySegment(SPECIES, a, i, bo);\n+               shuffle.intoMemorySegment(r, i, bo);\n+           }\n+       }\n+\n+       for (int i = 0; i < l \/ 4; i++) {\n+           int ai = a.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);\n+           int ri = r.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);\n+           Assert.assertEquals(testPartiallyWrapIndex(SPECIES, ai), ri);\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntByteProviderForIOOBE\")\n+   static void shuffleLoadMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));\n+       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4;\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle = shuffleFromMemorySegment(a, i, ByteOrder.nativeOrder());\n+               shuffle.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+           }\n+       }\n+\n+       int index = fi.apply((int) a.byteSize());\n+       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());\n+       try {\n+           shuffleFromMemorySegment(a, index, ByteOrder.nativeOrder());\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntByteProviderForIOOBE\")\n+   static void shuffleStoreMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));\n+       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4;\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle =\n+                       VectorShuffle.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+               shuffleIntoMemorySegment(shuffle, r, i, ByteOrder.nativeOrder());\n+           }\n+       }\n+\n+       int index = fi.apply((int) a.byteSize());\n+       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());\n+       try {\n+           VectorShuffle<Float16> shuffle =\n+                   VectorShuffle.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+           shuffleIntoMemorySegment(shuffle, r, index, ByteOrder.nativeOrder());\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat256VectorLoadStoreTests.java","additions":1016,"deletions":0,"binary":false,"changes":1016,"status":"added"},{"patch":"@@ -0,0 +1,5740 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.vector\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Halffloat256VectorTests\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.Vector;\n+\n+import jdk.incubator.vector.Float16;\n+import static jdk.incubator.vector.Float16.*;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.Integer;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Test\n+public class Halffloat256VectorTests extends AbstractVectorTest {\n+\n+    static final VectorSpecies<Float16> SPECIES =\n+                HalffloatVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+    static HalffloatVector bcast_vec = HalffloatVector.broadcast(SPECIES, (short)10);\n+\n+    static void AssertEquals(short actual, short expected) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected));\n+    }\n+    static void AssertEquals(short actual, short expected, String msg) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected), msg);\n+    }\n+    static void AssertEquals(short actual, short expected, short delta) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected), Float.float16ToFloat((short)delta));\n+    }\n+    static void AssertEquals(short actual, short expected, short delta, String msg) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected), Float.float16ToFloat((short)delta), msg);\n+    }\n+    static void AssertEquals(short [] actual, short [] expected) {\n+        Assert.assertEquals(actual.length, expected.length);\n+        for (int i = 0; i < actual.length; i++) {\n+            Assert.assertEquals(Float.float16ToFloat((short)actual[i]), Float.float16ToFloat((short)expected[i]));\n+        }\n+    }\n+    static void AssertEquals(short [] actual, short [] expected, String msg) {\n+        Assert.assertEquals(actual.length, expected.length);\n+        for (int i = 0; i < actual.length; i++) {\n+            Assert.assertEquals(Float.float16ToFloat((short)actual[i]), Float.float16ToFloat((short)expected[i]), msg);\n+        }\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected));\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected), msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n+\n+    \/\/ for floating point addition reduction ops that may introduce rounding errors\n+    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_ADD = (short)10.0;\n+\n+    \/\/ for floating point multiplication reduction ops that may introduce rounding errors\n+    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_MUL = (short)50.0;\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 256);\n+\n+    static void assertArraysStrictlyEquals(short[] r, short[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            short ir = r[i];\n+            short ia = a[i];\n+            if (ir != ia) {\n+                Assert.fail(String.format(\"at index #%d, expected = %016X, actual = %016X\", i, ia, ir));\n+            }\n+        }\n+    }\n+\n+    interface FUnOp {\n+        short apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FUnArrayOp {\n+        short[] apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a[i]);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    interface FReductionOp {\n+        short apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOp {\n+        short apply(short[] a);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa) {\n+        assertReductionArraysEquals(r, rc, a, f, fa, (short)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            short relativeErrorFactor) {\n+        int i = 0;\n+        try {\n+            AssertEquals(rc, fa.apply(a), float16ToShortBits(Float16.multiply(Float16.ulp(shortBitsToFloat16(rc)), shortBitsToFloat16(relativeErrorFactor))));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i), float16ToShortBits(Float16.multiply(Float16.ulp(shortBitsToFloat16(r[i])), shortBitsToFloat16(relativeErrorFactor))));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rc, fa.apply(a), float16ToShortBits(Float16.multiply(Float16.ulp(shortBitsToFloat16(rc)), shortBitsToFloat16(relativeErrorFactor))), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), float16ToShortBits(Float16.multiply(Float16.ulp(shortBitsToFloat16(r[i])), shortBitsToFloat16(relativeErrorFactor))), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOp {\n+        short apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOp {\n+        short apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa) {\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (short)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            short relativeError) {\n+        int i = 0;\n+        try {\n+            AssertEquals(rc, fa.apply(a, mask), float16ToShortBits(Float16.abs(Float16.multiply(shortBitsToFloat16(rc), shortBitsToFloat16(relativeError)))));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i, mask), float16ToShortBits(Float16.abs(Float16.multiply(shortBitsToFloat16(r[i]), shortBitsToFloat16(relativeError)))));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rc, fa.apply(a, mask), float16ToShortBits(Float16.abs(Float16.multiply(shortBitsToFloat16(rc), shortBitsToFloat16(relativeError)))), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), float16ToShortBits(Float16.abs(Float16.multiply(shortBitsToFloat16(r[i]), shortBitsToFloat16(relativeError)))), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionOpLong {\n+        long apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOpLong {\n+        long apply(short[] a);\n+    }\n+\n+    static void assertReductionLongArraysEquals(long[] r, long rc, short[] a,\n+                                            FReductionOpLong f, FReductionAllOpLong fa) {\n+        int i = 0;\n+        try {\n+            AssertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOpLong {\n+        long apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOpLong {\n+        long apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionLongArraysEqualsMasked(long[] r, long rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOpLong f, FReductionAllMaskedOpLong fa) {\n+        int i = 0;\n+        try {\n+            AssertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolReductionOp {\n+        boolean apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertReductionBoolArraysEquals(boolean[] r, boolean[] a, FBoolReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FMaskReductionOp {\n+        int apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertMaskReductionArraysEquals(int[] r, boolean[] a, FMaskReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        AssertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    AssertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                AssertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        AssertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        AssertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                AssertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod(shortBitsToFloat16(order[idx]).intValue(), 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        int idx = 0, wrapped_index = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = shortBitsToFloat16(order[i+j]).intValue();\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n+                    else\n+                         AssertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                AssertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        int idx = 0, wrapped_index = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = shortBitsToFloat16(order[i+j]).intValue();\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    if (mask[j % SPECIES.length()])\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n+                    else\n+                         AssertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            if (mask[j % SPECIES.length()])\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                AssertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a) {\n+        int i = 0;\n+        for (; i < a.length; i += SPECIES.length()) {\n+            int idx = i;\n+            for (int j = idx; j < (idx + SPECIES.length()); j++)\n+                a[j]=a[idx];\n+        }\n+\n+        try {\n+            for (i = 0; i < a.length; i++) {\n+                AssertEquals(r[i], a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FBinOp {\n+        short apply(short a, short b);\n+    }\n+\n+    interface FBinMaskOp {\n+        short apply(short a, short b, boolean m);\n+\n+        static FBinMaskOp lift(FBinOp f) {\n+            return (a, b, m) -> m ? f.apply(a, b) : a;\n+        }\n+    }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                AssertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                AssertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertShiftArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FBinConstOp {\n+        short apply(short a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        short apply(short a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FTernOp {\n+        short apply(short a, short b, short c);\n+    }\n+\n+    interface FTernMaskOp {\n+        short apply(short a, short b, short c, boolean m);\n+\n+        static FTernMaskOp lift(FTernOp f) {\n+            return (a, b, c, m) -> m ? f.apply(a, b, c) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernOp f) {\n+        assertArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+              + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[(i \/ SPECIES.length()) * SPECIES.length()] + \",  input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[i] + \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i]\n+                                + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernOp f) {\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]), \"at index #\"\n+                                + i + \", input1 = \" + a[i] + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+\n+    static boolean isWithin1Ulp(short actual, short expected) {\n+        Float16 act = shortBitsToFloat16(actual);\n+        Float16 exp = shortBitsToFloat16(expected);\n+        if (Float16.isNaN(exp) && !Float16.isNaN(act)) {\n+            return false;\n+        } else if (!Float16.isNaN(exp) && Float16.isNaN(act)) {\n+             return false;\n+        }\n+\n+        Float16 low = Float16.nextDown(exp);\n+        Float16 high = Float16.nextUp(exp);\n+\n+        if (Float16.compare(low, exp) > 0) {\n+            return false;\n+        }\n+\n+        if (Float16.compare(high, exp) < 0) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, FUnOp mathf, FUnOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]), shortBitsToFloat16(mathf.apply(a[i]))) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]), shortBitsToFloat16(mathf.apply(a[i]))) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i])), \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i]));\n+        }\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b, FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]), shortBitsToFloat16(mathf.apply(a[i], b[i]))) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]), shortBitsToFloat16(mathf.apply(a[i], b[i]))) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i], b[i]));\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b,\n+                                                        FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]),\n+                                  shortBitsToFloat16(mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]))) == 0 ||\n+                                  isWithin1Ulp(r[i],\n+                                  strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]),\n+                              shortBitsToFloat16(mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]))) == 0,\n+                              \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                              b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                              \", expected = \" + mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            Assert.assertTrue(isWithin1Ulp(r[i],\n+                              strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                             \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                             \", expected (within 1 ulp) = \" + strictmathf.apply(a[i],\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+        }\n+    }\n+\n+    interface FGatherScatterOp {\n+        short[] apply(short[] a, int ix, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, FGatherScatterOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherMaskedOp {\n+        short[] apply(short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    interface FScatterMaskedOp {\n+        short[] apply(short[] r, short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FGatherMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FScatterMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(r, a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(r, a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", r: \"\n+              + Arrays.toString(Arrays.copyOfRange(r, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneOp {\n+        short[] apply(short[] a, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int origin, FLaneOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneBop {\n+        short[] apply(short[] a, short[] b, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, FLaneBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLaneMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, boolean[] mask, FLaneMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLanePartBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, FLanePartBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    interface FLanePartMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, boolean[] mask, FLanePartMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    static short genValue(int i) {\n+        return float16ToShortBits(Float16.valueOf(i));\n+    }\n+\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> INT_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Float16[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(int[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                AssertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static short genValue(long i) {\n+        return float16ToShortBits(Float16.valueOf(i));\n+    }\n+\n+    static final List<IntFunction<short[]>> LONG_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Float16[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(long[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                AssertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(double[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                AssertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static short bits(short e) {\n+        return e;\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Float16[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> Float.floatToFloat16((0.01f + ((float)i \/ (i + 1)))));\n+            }),\n+            withToString(\"Float16[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01f + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (i % 17 == 0) ? cornerCaseValue(i) : Float.floatToFloat16((0.01f + ((float)i \/ (i + 1)))));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    \/\/ Create combinations of pairs\n+    \/\/ @@@ Might be sensitive to order e.g. div by 0\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_PAIRS =\n+        Stream.of(HALFFLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> HALFFLOAT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] boolUnaryOpProvider() {\n+        return BOOL_ARRAY_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> HALFFLOAT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"short[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortIndexedOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortSelectFromTwoVectorOpProvider() {\n+        return HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_TRIPLES.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoIntUnaryOpProvider() {\n+        return INT_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoLongUnaryOpProvider() {\n+        return LONG_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<BiFunction<Integer,Integer,short[]>> HALFFLOAT_SHUFFLE_GENERATORS = List.of(\n+            withToStringBi(\"shuffle[random]\", (Integer l, Integer m) -> {\n+                short[] a = new short[l];\n+                int upper = m;\n+                for (int i = 0; i < 1; i++) {\n+                    a[i] = (short)RAND.nextInt(upper);\n+                }\n+                return a;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromProvider() {\n+        return HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_COMPARE_GENERATORS = List.of(\n+            withToString(\"short[i]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)i);\n+            }),\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i + 1));\n+            }),\n+            withToString(\"short[i - 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - 2));\n+            }),\n+            withToString(\"short[zigZag(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i%3 == 0 ? (short)i : (i%3 == 1 ? (short)(i + 1) : (short)(i - 2)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_TEST_GENERATOR_ARGS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                map(fa -> List.of(fa)).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortTestOpProvider() {\n+        return HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_COMPARE_GENERATOR_PAIRS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                flatMap(fa -> HALFFLOAT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpProvider() {\n+        return HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    static short cornerCaseValue(int i) {\n+        return switch(i % 8) {\n+            case 0  -> float16ToShortBits(Float16.MAX_VALUE);\n+            case 1  -> float16ToShortBits(Float16.MIN_VALUE);\n+            case 2  -> float16ToShortBits(Float16.NEGATIVE_INFINITY);\n+            case 3  -> float16ToShortBits(Float16.POSITIVE_INFINITY);\n+            case 4  -> float16ToShortBits(Float16.NaN);\n+            case 5  -> float16ToShortBits(shortBitsToFloat16((short)0x7FFA));\n+            case 6  -> ((short)0.0);\n+            default -> ((short)-0.0);\n+        };\n+    }\n+\n+    static final IntFunction<short[]> fr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new short[length];\n+    };\n+\n+    static final IntFunction<boolean[]> fmr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new boolean[length];\n+    };\n+\n+    static final IntFunction<long[]> lfr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new long[length];\n+    };\n+\n+    static boolean eq(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() == bt.floatValue();\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() != bt.floatValue();\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() < bt.floatValue();\n+    }\n+\n+    static boolean le(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() <= bt.floatValue();\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() > bt.floatValue();\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() >= bt.floatValue();\n+    }\n+\n+    static short firstNonZero(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        Float16 zero = shortBitsToFloat16((short)0);\n+        return Float16.compare(at, zero) != 0 ? a : b;\n+    }\n+\n+    static short multiplicativeIdentity() {\n+        return (short)float16ToShortBits(Float16.valueOf(1.0f));\n+    }\n+\n+    static short scalar_add(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.add(at, bt));\n+    }\n+\n+    static short scalar_sub(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.subtract(at, bt));\n+    }\n+\n+    static short scalar_mul(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.multiply(at, bt));\n+\n+    }\n+    static short scalar_max(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.max(at, bt));\n+    }\n+\n+    static short scalar_min(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.min(at, bt));\n+    }\n+\n+    static short scalar_div(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.divide(at, bt));\n+    }\n+\n+    static short scalar_fma(short a, short b, short c) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        Float16 ct = shortBitsToFloat16(c);\n+        return float16ToShortBits(Float16.fma(at, bt, ct));\n+    }\n+\n+    static short scalar_abs(short a) {\n+        Float16 at = shortBitsToFloat16(a);\n+        return float16ToShortBits(Float16.abs(at));\n+    }\n+\n+    static short scalar_neg(short a) {\n+        Float16 at = shortBitsToFloat16(a);\n+        return float16ToShortBits(Float16.valueOf(-at.floatValue()));\n+    }\n+\n+    static short scalar_sin(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.sin(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_exp(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.exp(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_log1p(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.log1p(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_log(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.log(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_log10(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.log10(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_expm1(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.expm1(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_cos(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.cos(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_tan(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.tan(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_sinh(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.sinh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_cosh(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.cosh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_tanh(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.tanh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_asin(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.asin(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_acos(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.acos(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_atan(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.atan(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_cbrt(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.cbrt(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_sqrt(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.sqrt(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_hypot(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(Math.hypot(shortBitsToFloat16(a).doubleValue(),\n+                                                                     shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static short scalar_pow(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(Math.pow(shortBitsToFloat16(a).doubleValue(),\n+                                                                   shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static short scalar_atan2(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(Math.atan2(shortBitsToFloat16(a).doubleValue(),\n+                                                                     shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static short strict_scalar_sin(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.sin(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_exp(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.exp(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_log1p(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.log1p(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_log(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.log(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_log10(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.log10(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_expm1(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.expm1(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_cos(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.cos(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_tan(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.tan(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_sinh(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.sinh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_cosh(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.cosh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_tanh(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.tanh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_asin(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.asin(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_acos(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.acos(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_atan(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.atan(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_cbrt(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.cbrt(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_sqrt(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.sqrt(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_hypot(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.hypot(shortBitsToFloat16(a).doubleValue(),\n+                                                                     shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static short strict_scalar_pow(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.pow(shortBitsToFloat16(a).doubleValue(),\n+                                                                   shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static short strict_scalar_atan2(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.atan2(shortBitsToFloat16(a).doubleValue(),\n+                                                                     shortBitsToFloat16(b).doubleValue())));\n+    }\n+    static short additiveIdentity() {\n+        return (short)0;\n+    }\n+\n+\n+    static short zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static short maxValue() {\n+        return float16ToShortBits(Float16.POSITIVE_INFINITY);\n+    }\n+\n+    static short minValue() {\n+        return float16ToShortBits(Float16.NEGATIVE_INFINITY);\n+    }\n+\n+    static boolean isNaN(short a) {\n+        return Float16.isNaN(shortBitsToFloat16(a));\n+    }\n+    static boolean isFinite(short a) {\n+        return Float16.isFinite(shortBitsToFloat16(a));\n+    }\n+    static boolean isInfinite(short a) {\n+        return Float16.isInfinite(shortBitsToFloat16(a));\n+    }\n+\n+    @Test\n+    static void smokeTest1() {\n+        HalffloatVector three = HalffloatVector.broadcast(SPECIES, float16ToShortBits(Float16.valueOf(-3)));\n+        HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(float16ToShortBits(Float16.valueOf(-3)));\n+        assert(three.eq(three2).allTrue());\n+        HalffloatVector three3 = three2.broadcast(float16ToShortBits(Float16.valueOf(1))).broadcast(float16ToShortBits(Float16.valueOf(-3)));\n+        assert(three.eq(three3).allTrue());\n+        int scale = 2;\n+        HalffloatVector higher = three.addIndex(scale);\n+        VectorMask<Float16> m = three.compare(VectorOperators.LE, higher);\n+        assert(m.allTrue());\n+        m = higher.min((float16ToShortBits(Float16.valueOf(-1)))).test(VectorOperators.IS_NEGATIVE);\n+        assert(m.allTrue());\n+        m = higher.test(VectorOperators.IS_FINITE);\n+        assert(m.allTrue());\n+        short max = higher.reduceLanes(VectorOperators.MAX);\n+        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));\n+    }\n+\n+    private static short[]\n+    bothToArray(HalffloatVector a, HalffloatVector b) {\n+        short[] r = new short[a.length() + b.length()];\n+        a.intoArray(r, 0);\n+        b.intoArray(r, a.length());\n+        return r;\n+    }\n+\n+    @Test\n+    static void smokeTest2() {\n+        \/\/ Do some zipping and shuffling.\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES,0,1,false).toVector();\n+        AssertEquals(io, io2);\n+        HalffloatVector a = io.add((short)1); \/\/[1,2]\n+        HalffloatVector b = a.neg();  \/\/[-1,-2]\n+        short[] abValues = bothToArray(a,b); \/\/[1,2,-1,-2]\n+        VectorShuffle<Float16> zip0 = VectorShuffle.makeZip(SPECIES, 0);\n+        VectorShuffle<Float16> zip1 = VectorShuffle.makeZip(SPECIES, 1);\n+        HalffloatVector zab0 = a.rearrange(zip0,b); \/\/[1,-1]\n+        HalffloatVector zab1 = a.rearrange(zip1,b); \/\/[2,-2]\n+        short[] zabValues = bothToArray(zab0, zab1); \/\/[1,-1,2,-2]\n+        \/\/ manually zip\n+        short[] manual = new short[zabValues.length];\n+        for (int i = 0; i < manual.length; i += 2) {\n+            manual[i+0] = abValues[i\/2];\n+            manual[i+1] = abValues[a.length() + i\/2];\n+        }\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        VectorShuffle<Float16> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);\n+        VectorShuffle<Float16> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);\n+        HalffloatVector uab0 = zab0.rearrange(unz0,zab1);\n+        HalffloatVector uab1 = zab0.rearrange(unz1,zab1);\n+        short[] abValues1 = bothToArray(uab0, uab1);\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+    }\n+\n+    static void iotaShuffle() {\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES, 0 , 1, false).toVector();\n+        AssertEquals(io, io2);\n+    }\n+\n+    @Test\n+    \/\/ Test all shuffle related operations.\n+    static void shuffleTest() {\n+        \/\/ To test backend instructions, make sure that C2 is used.\n+        for (int loop = 0; loop < INVOC_COUNT * INVOC_COUNT; loop++) {\n+            iotaShuffle();\n+        }\n+    }\n+\n+    @Test\n+    void viewAsIntegeralLanesTest() {\n+        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();\n+        VectorSpecies<?> asIntegralSpecies = asIntegral.species();\n+        Assert.assertNotEquals(asIntegralSpecies.elementType(), SPECIES.elementType());\n+        AssertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        AssertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+    }\n+\n+    @Test\n+    void viewAsFloatingLanesTest() {\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        AssertEquals(asFloating.species(), SPECIES);\n+    }\n+\n+    static short ADD(short a, short b) {\n+        return (short)(scalar_add(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::ADD);\n+    }\n+\n+    static short add(short a, short b) {\n+        return (short)(scalar_add(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void addHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.add(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::add);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void addHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.add(bv, vmask).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::add);\n+    }\n+\n+    static short SUB(short a, short b) {\n+        return (short)(scalar_sub(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void SUBHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::SUB);\n+    }\n+\n+    static short sub(short a, short b) {\n+        return (short)(scalar_sub(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void subHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.sub(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::sub);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void SUBHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::SUB);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void subHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.sub(bv, vmask).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::sub);\n+    }\n+\n+    static short MUL(short a, short b) {\n+        return (short)(scalar_mul(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MULHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::MUL);\n+    }\n+\n+    static short mul(short a, short b) {\n+        return (short)(scalar_mul(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void mulHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.mul(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::mul);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MULHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::MUL);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void mulHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.mul(bv, vmask).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::mul);\n+    }\n+\n+    static short DIV(short a, short b) {\n+        return (short)(scalar_div(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void DIVHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::DIV);\n+    }\n+\n+    static short div(short a, short b) {\n+        return (short)(scalar_div(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void divHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.div(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::div);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void DIVHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::DIV);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void divHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.div(bv, vmask).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::div);\n+    }\n+\n+    static short FIRST_NONZERO(short a, short b) {\n+        return (short)(firstNonZero(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void FIRST_NONZEROHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::FIRST_NONZERO);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void FIRST_NONZEROHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::FIRST_NONZERO);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void addHalffloat256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.add(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat256VectorTests::add);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void addHalffloat256VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.add(b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, Halffloat256VectorTests::add);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void subHalffloat256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.sub(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat256VectorTests::sub);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void subHalffloat256VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.sub(b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, Halffloat256VectorTests::sub);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void mulHalffloat256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.mul(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat256VectorTests::mul);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void mulHalffloat256VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.mul(b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, Halffloat256VectorTests::mul);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void divHalffloat256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.div(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat256VectorTests::div);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void divHalffloat256VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.div(b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, Halffloat256VectorTests::div);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDHalffloat256VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(r, a, b, Halffloat256VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDHalffloat256VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(r, a, b, mask, Halffloat256VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINHalffloat256VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Halffloat256VectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void minHalffloat256VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.min(bcast_vec).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Halffloat256VectorTests::min);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MINHalffloat256VectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, Halffloat256VectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXHalffloat256VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Halffloat256VectorTests::MAX);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void maxHalffloat256VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.max(bcast_vec).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Halffloat256VectorTests::max);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MAXHalffloat256VectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, Halffloat256VectorTests::MAX);\n+    }\n+\n+    static short MIN(short a, short b) {\n+        return (short)(scalar_min(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MINHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::MIN);\n+    }\n+\n+    static short min(short a, short b) {\n+        return (short)(scalar_min(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void minHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.min(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::min);\n+    }\n+\n+    static short MAX(short a, short b) {\n+        return (short)(scalar_max(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MAXHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::MAX);\n+    }\n+\n+    static short max(short a, short b) {\n+        return (short)(scalar_max(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void maxHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.max(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::max);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MINHalffloat256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.MIN, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat256VectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void minHalffloat256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.min(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat256VectorTests::min);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MAXHalffloat256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.MAX, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat256VectorTests::MAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void maxHalffloat256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.max(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat256VectorTests::max);\n+    }\n+\n+    static short ADDReduce(short[] a, int idx) {\n+        short res = additiveIdentity();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = scalar_add(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short ADDReduceAll(short[] a) {\n+        short res = additiveIdentity();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_add(res, ADDReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = additiveIdentity();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = additiveIdentity();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Halffloat256VectorTests::ADDReduce, Halffloat256VectorTests::ADDReduceAll, RELATIVE_ROUNDING_ERROR_FACTOR_ADD);\n+    }\n+\n+    static short ADDReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = additiveIdentity();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = scalar_add(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short ADDReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = additiveIdentity();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ADDReduceHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = additiveIdentity();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = additiveIdentity();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat256VectorTests::ADDReduceMasked, Halffloat256VectorTests::ADDReduceAllMasked, RELATIVE_ROUNDING_ERROR_FACTOR_ADD);\n+    }\n+\n+    static short MULReduce(short[] a, int idx) {\n+        short res = multiplicativeIdentity();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = scalar_mul(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MULReduceAll(short[] a) {\n+        short res = multiplicativeIdentity();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_mul(res, MULReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MULReduceHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = multiplicativeIdentity();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = multiplicativeIdentity();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Halffloat256VectorTests::MULReduce, Halffloat256VectorTests::MULReduceAll, RELATIVE_ROUNDING_ERROR_FACTOR_MUL);\n+    }\n+\n+    static short MULReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = multiplicativeIdentity();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = scalar_mul(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MULReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = multiplicativeIdentity();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MULReduceHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = multiplicativeIdentity();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = multiplicativeIdentity();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat256VectorTests::MULReduceMasked, Halffloat256VectorTests::MULReduceAllMasked, RELATIVE_ROUNDING_ERROR_FACTOR_MUL);\n+    }\n+\n+    static short MINReduce(short[] a, int idx) {\n+        short res = maxValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = scalar_min(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MINReduceAll(short[] a) {\n+        short res = maxValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_min(res, MINReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINReduceHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = maxValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MIN);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = maxValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Halffloat256VectorTests::MINReduce, Halffloat256VectorTests::MINReduceAll);\n+    }\n+\n+    static short MINReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = maxValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = scalar_min(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MINReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = maxValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MINReduceHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = maxValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = maxValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat256VectorTests::MINReduceMasked, Halffloat256VectorTests::MINReduceAllMasked);\n+    }\n+\n+    static short MAXReduce(short[] a, int idx) {\n+        short res = minValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = scalar_max(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MAXReduceAll(short[] a) {\n+        short res = minValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_max(res, MAXReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXReduceHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = minValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MAX);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = minValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Halffloat256VectorTests::MAXReduce, Halffloat256VectorTests::MAXReduceAll);\n+    }\n+\n+    static short MAXReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = minValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = scalar_max(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MAXReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = minValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MAXReduceHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = minValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = minValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat256VectorTests::MAXReduceMasked, Halffloat256VectorTests::MAXReduceAllMasked);\n+    }\n+\n+    static short FIRST_NONZEROReduce(short[] a, int idx) {\n+        short res = zeroValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short FIRST_NONZEROReduceAll(short[] a) {\n+        short res = zeroValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = zeroValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = zeroValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Halffloat256VectorTests::FIRST_NONZEROReduce, Halffloat256VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+\n+    static short FIRST_NONZEROReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = zeroValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short FIRST_NONZEROReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = zeroValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = zeroValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = zeroValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat256VectorTests::FIRST_NONZEROReduceMasked, Halffloat256VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void withHalffloat256VectorTests(IntFunction<short []> fa, IntFunction<short []> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+\n+        assertArraysStrictlyEquals(r, a);\n+    }\n+\n+    static boolean testIS_DEFAULT(short a) {\n+        return bits(a)==0;\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpProvider\")\n+    static void IS_DEFAULTHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_DEFAULT);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedHalffloat256VectorTests(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    static boolean testIS_NEGATIVE(short a) {\n+        return bits(a)<0;\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpProvider\")\n+    static void IS_NEGATIVEHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_NEGATIVE);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedHalffloat256VectorTests(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    static boolean testIS_FINITE(short a) {\n+        return isFinite(a);\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpProvider\")\n+    static void IS_FINITEHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_FINITE);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), testIS_FINITE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_FINITEMaskedHalffloat256VectorTests(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    static boolean testIS_NAN(short a) {\n+        return isNaN(a);\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpProvider\")\n+    static void IS_NANHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_NAN);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), testIS_NAN(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_NANMaskedHalffloat256VectorTests(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_NAN, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    static boolean testIS_INFINITE(short a) {\n+        return isInfinite(a);\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpProvider\")\n+    static void IS_INFINITEHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_INFINITE);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), testIS_INFINITE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_INFINITEMaskedHalffloat256VectorTests(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void LTHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.lt(bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void LTHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void GTHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void GTHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void EQHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.EQ, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.eq(bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void EQHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.EQ, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void NEHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.NE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void NEHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.NE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void LEHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void LEHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void GEHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void GEHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void LTHalffloat256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.LT, b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void LTHalffloat256VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa,\n+                                IntFunction<short[]> fb, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.LT, b[i], vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void LTHalffloat256VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.LT, (long)b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (short)((long)b[i])));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void LTHalffloat256VectorTestsBroadcastLongMaskedSmokeTest(IntFunction<short[]> fa,\n+                                IntFunction<short[]> fb, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.LT, (long)b[i], vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(short)((long)b[i]))));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void EQHalffloat256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.EQ, b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void EQHalffloat256VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa,\n+                                IntFunction<short[]> fb, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.EQ, b[i], vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void EQHalffloat256VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.EQ, (long)b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (short)((long)b[i])));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void EQHalffloat256VectorTestsBroadcastLongMaskedSmokeTest(IntFunction<short[]> fa,\n+                                IntFunction<short[]> fb, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.EQ, (long)b[i], vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(short)((long)b[i]))));\n+            }\n+        }\n+    }\n+\n+    static short blend(short a, short b, boolean mask) {\n+        return mask ? b : a;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::blend);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpShuffleProvider\")\n+    static void RearrangeHalffloat256VectorTests(IntFunction<short[]> fa,\n+                                           BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        assertRearrangeArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpShuffleMaskProvider\")\n+    static void RearrangeHalffloat256VectorTestsMaskedSmokeTest(IntFunction<short[]> fa,\n+                                                          BiFunction<Integer,Integer,int[]> fs,\n+                                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.rearrange(VectorShuffle.fromArray(SPECIES, order, i), vmask).intoArray(r, i);\n+        }\n+\n+        assertRearrangeArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void compressHalffloat256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void expandHalffloat256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void getHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        assertArraysStrictlyEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void BroadcastHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ZeroHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        AssertEquals(a, r);\n+    }\n+\n+    static short[] sliceUnary(short[] a, int origin, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0; i < SPECIES.length(); i++){\n+            if(i+origin < SPECIES.length())\n+                res[i] = a[idx+i+origin];\n+            else\n+                res[i] = (short)0;\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void sliceUnaryHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, origin, Halffloat256VectorTests::sliceUnary);\n+    }\n+\n+    static short[] sliceBinary(short[] a, short[] b, int origin, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if(i+origin < SPECIES.length())\n+                res[i] = a[idx+i+origin];\n+            else {\n+                res[i] = b[idx+j];\n+                j++;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void sliceBinaryHalffloat256VectorTestsBinary(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, origin, Halffloat256VectorTests::sliceBinary);\n+    }\n+\n+    static short[] slice(short[] a, short[] b, int origin, boolean[] mask, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if(i+origin < SPECIES.length())\n+                res[i] = mask[i] ? a[idx+i+origin] : (short)0;\n+            else {\n+                res[i] = mask[i] ? b[idx+j] : (short)0;\n+                j++;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void sliceHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, origin, mask, Halffloat256VectorTests::slice);\n+    }\n+\n+    static short[] unsliceUnary(short[] a, int origin, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if(i < origin)\n+                res[i] = (short)0;\n+            else {\n+                res[i] = a[idx+j];\n+                j++;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void unsliceUnaryHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, origin, Halffloat256VectorTests::unsliceUnary);\n+    }\n+\n+    static short[] unsliceBinary(short[] a, short[] b, int origin, int part, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if (part == 0) {\n+                if (i < origin)\n+                    res[i] = b[idx+i];\n+                else {\n+                    res[i] = a[idx+j];\n+                    j++;\n+                }\n+            } else if (part == 1) {\n+                if (i < origin)\n+                    res[i] = a[idx+SPECIES.length()-origin+i];\n+                else {\n+                    res[i] = b[idx+origin+j];\n+                    j++;\n+                }\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void unsliceBinaryHalffloat256VectorTestsBinary(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, origin, part, Halffloat256VectorTests::unsliceBinary);\n+    }\n+\n+    static short[] unslice(short[] a, short[] b, int origin, int part, boolean[] mask, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if(i+origin < SPECIES.length())\n+                res[i] = b[idx+i+origin];\n+            else {\n+                res[i] = b[idx+j];\n+                j++;\n+            }\n+        }\n+        for (int i = 0; i < SPECIES.length(); i++){\n+            res[i] = mask[i] ? a[idx+i] : res[i];\n+        }\n+        short[] res1 = new short[SPECIES.length()];\n+        if (part == 0) {\n+            for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+                if (i < origin)\n+                    res1[i] = b[idx+i];\n+                else {\n+                   res1[i] = res[j];\n+                   j++;\n+                }\n+            }\n+        } else if (part == 1) {\n+            for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+                if (i < origin)\n+                    res1[i] = res[SPECIES.length()-origin+i];\n+                else {\n+                    res1[i] = b[idx+origin+j];\n+                    j++;\n+                }\n+            }\n+        }\n+        return res1;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void unsliceHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, origin, part, mask, Halffloat256VectorTests::unslice);\n+    }\n+\n+    static short SIN(short a) {\n+        return (short)(scalar_sin(a));\n+    }\n+\n+    static short strictSIN(short a) {\n+        return (short)(strict_scalar_sin(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::SIN, Halffloat256VectorTests::strictSIN);\n+    }\n+\n+    static short EXP(short a) {\n+        return (short)(scalar_exp(a));\n+    }\n+\n+    static short strictEXP(short a) {\n+        return (short)(strict_scalar_exp(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::EXP, Halffloat256VectorTests::strictEXP);\n+    }\n+\n+    static short LOG1P(short a) {\n+        return (short)(scalar_log1p(a));\n+    }\n+\n+    static short strictLOG1P(short a) {\n+        return (short)(strict_scalar_log1p(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG1PHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::LOG1P, Halffloat256VectorTests::strictLOG1P);\n+    }\n+\n+    static short LOG(short a) {\n+        return (short)(scalar_log(a));\n+    }\n+\n+    static short strictLOG(short a) {\n+        return (short)(strict_scalar_log(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOGHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::LOG, Halffloat256VectorTests::strictLOG);\n+    }\n+\n+    static short LOG10(short a) {\n+        return (short)(scalar_log10(a));\n+    }\n+\n+    static short strictLOG10(short a) {\n+        return (short)(strict_scalar_log10(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG10Halffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::LOG10, Halffloat256VectorTests::strictLOG10);\n+    }\n+\n+    static short EXPM1(short a) {\n+        return (short)(scalar_expm1(a));\n+    }\n+\n+    static short strictEXPM1(short a) {\n+        return (short)(strict_scalar_expm1(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPM1Halffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::EXPM1, Halffloat256VectorTests::strictEXPM1);\n+    }\n+\n+    static short COS(short a) {\n+        return (short)(scalar_cos(a));\n+    }\n+\n+    static short strictCOS(short a) {\n+        return (short)(strict_scalar_cos(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::COS, Halffloat256VectorTests::strictCOS);\n+    }\n+\n+    static short TAN(short a) {\n+        return (short)(scalar_tan(a));\n+    }\n+\n+    static short strictTAN(short a) {\n+        return (short)(strict_scalar_tan(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::TAN, Halffloat256VectorTests::strictTAN);\n+    }\n+\n+    static short SINH(short a) {\n+        return (short)(scalar_sinh(a));\n+    }\n+\n+    static short strictSINH(short a) {\n+        return (short)(strict_scalar_sinh(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::SINH, Halffloat256VectorTests::strictSINH);\n+    }\n+\n+    static short COSH(short a) {\n+        return (short)(scalar_cosh(a));\n+    }\n+\n+    static short strictCOSH(short a) {\n+        return (short)(strict_scalar_cosh(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::COSH, Halffloat256VectorTests::strictCOSH);\n+    }\n+\n+    static short TANH(short a) {\n+        return (short)(scalar_tanh(a));\n+    }\n+\n+    static short strictTANH(short a) {\n+        return (short)(strict_scalar_tanh(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::TANH, Halffloat256VectorTests::strictTANH);\n+    }\n+\n+    static short ASIN(short a) {\n+        return (short)(scalar_asin(a));\n+    }\n+\n+    static short strictASIN(short a) {\n+        return (short)(strict_scalar_asin(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ASINHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::ASIN, Halffloat256VectorTests::strictASIN);\n+    }\n+\n+    static short ACOS(short a) {\n+        return (short)(scalar_acos(a));\n+    }\n+\n+    static short strictACOS(short a) {\n+        return (short)(strict_scalar_acos(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ACOSHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::ACOS, Halffloat256VectorTests::strictACOS);\n+    }\n+\n+    static short ATAN(short a) {\n+        return (short)(scalar_atan(a));\n+    }\n+\n+    static short strictATAN(short a) {\n+        return (short)(strict_scalar_atan(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ATANHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::ATAN, Halffloat256VectorTests::strictATAN);\n+    }\n+\n+    static short CBRT(short a) {\n+        return (short)(scalar_cbrt(a));\n+    }\n+\n+    static short strictCBRT(short a) {\n+        return (short)(strict_scalar_cbrt(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CBRTHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::CBRT, Halffloat256VectorTests::strictCBRT);\n+    }\n+\n+    static short HYPOT(short a, short b) {\n+        return (short)(scalar_hypot(a, b));\n+    }\n+\n+    static short strictHYPOT(short a, short b) {\n+        return (short)(strict_scalar_hypot(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void HYPOTHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::HYPOT, Halffloat256VectorTests::strictHYPOT);\n+    }\n+\n+\n+    static short POW(short a, short b) {\n+        return (short)(scalar_pow(a, b));\n+    }\n+\n+    static short strictPOW(short a, short b) {\n+        return (short)(strict_scalar_pow(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::POW, Halffloat256VectorTests::strictPOW);\n+    }\n+\n+\n+    static short pow(short a, short b) {\n+        return (short)(scalar_pow(a, b));\n+    }\n+\n+    static short strictpow(short a, short b) {\n+        return (short)(strict_scalar_pow(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.pow(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::pow, Halffloat256VectorTests::strictpow);\n+    }\n+\n+\n+    static short ATAN2(short a, short b) {\n+        return (short)(scalar_atan2(a, b));\n+    }\n+\n+    static short strictATAN2(short a, short b) {\n+        return (short)(strict_scalar_atan2(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ATAN2Halffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::ATAN2, Halffloat256VectorTests::strictATAN2);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.POW, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::POW, Halffloat256VectorTests::strictPOW);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.pow(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::pow, Halffloat256VectorTests::strictpow);\n+    }\n+\n+\n+    static short FMA(short a, short b, short c) {\n+        return (short)(scalar_fma(a, b, c));\n+    }\n+\n+    static short fma(short a, short b, short c) {\n+        return (short)(scalar_fma(a, b, c));\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat256VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void fmaHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.fma(bv, cv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat256VectorTests::fma);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, mask, Halffloat256VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.lanewise(VectorOperators.FMA, bv, c[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a, b, c, Halffloat256VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat256VectorTestsAltBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.lanewise(VectorOperators.FMA, b[i], cv).intoArray(r, i);\n+        }\n+        assertAltBroadcastArraysEquals(r, a, b, c, Halffloat256VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat256VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.lanewise(VectorOperators.FMA, bv, c[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, c, mask, Halffloat256VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat256VectorTestsAltBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.lanewise(VectorOperators.FMA, b[i], cv, vmask).intoArray(r, i);\n+        }\n+\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, Halffloat256VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat256VectorTestsDoubleBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.FMA, b[i], c[i]).intoArray(r, i);\n+        }\n+\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, Halffloat256VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void fmaHalffloat256VectorTestsDoubleBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.fma(b[i], c[i]).intoArray(r, i);\n+        }\n+\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, Halffloat256VectorTests::fma);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat256VectorTestsDoubleBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.FMA, b[i], c[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, Halffloat256VectorTests::FMA);\n+    }\n+\n+    static short NEG(short a) {\n+        return (short)(scalar_neg((short)a));\n+    }\n+\n+    static short neg(short a) {\n+        return (short)(scalar_neg((short)a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void NEGHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat256VectorTests::NEG);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void negHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.neg().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat256VectorTests::neg);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void NEGMaskedHalffloat256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat256VectorTests::NEG);\n+    }\n+\n+    static short ABS(short a) {\n+        return (short)(scalar_abs((short)a));\n+    }\n+\n+    static short abs(short a) {\n+        return (short)(scalar_abs((short)a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ABSHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat256VectorTests::ABS);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void absHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.abs().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat256VectorTests::abs);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ABSMaskedHalffloat256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat256VectorTests::ABS);\n+    }\n+\n+    static short SQRT(short a) {\n+        return (short)(scalar_sqrt(a));\n+    }\n+\n+    static short sqrt(short a) {\n+        return (short)(scalar_sqrt(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SQRTHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat256VectorTests::SQRT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void sqrtHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.sqrt().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat256VectorTests::sqrt);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void SQRTMaskedHalffloat256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat256VectorTests::SQRT);\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltHalffloat256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqHalffloat256VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoIntUnaryOpProvider\")\n+    static void toIntArrayHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int[] r = av.toIntArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void toLongArrayHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            long[] r = av.toLongArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toDoubleArrayHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            double[] r = av.toDoubleArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toStringHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void hashCodeHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n+    static long ADDReduceLong(short[] a, int idx) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLong(short[] a) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = Float.floatToFloat16(Float.float16ToFloat((short)res) + Float.float16ToFloat((short)ADDReduceLong(a, i)));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceLongHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            ra = (long)(Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16((short)ra), Float16.shortBitsToFloat16((short)r[i]))));\n+        }\n+\n+        assertReductionLongArraysEquals(r, ra, a,\n+                Halffloat256VectorTests::ADDReduceLong, Halffloat256VectorTests::ADDReduceAllLong);\n+    }\n+\n+    static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if(mask[i % SPECIES.length()])\n+                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = Float.floatToFloat16(Float.float16ToFloat((short)res) + Float.float16ToFloat((short)ADDReduceLongMasked(a, i, mask)));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ADDReduceLongHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            ra = (long)(Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16((short)ra), Float16.shortBitsToFloat16((short)r[i]))));\n+        }\n+\n+        assertReductionLongArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat256VectorTests::ADDReduceLongMasked, Halffloat256VectorTests::ADDReduceAllLongMasked);\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void BroadcastLongHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat256VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(r, a, b, mask, Halffloat256VectorTests::blend);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromProvider\")\n+    static void SelectFromHalffloat256VectorTests(IntFunction<short[]> fa,\n+                                           BiFunction<Integer,Integer,short[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] idx = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector idxv = HalffloatVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromMaskProvider\")\n+    static void SelectFromHalffloat256VectorTestsMaskedSmokeTest(IntFunction<short[]> fa,\n+                                                           BiFunction<Integer,Integer,short[]> fs,\n+                                                           IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av, vmask).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousHalffloat256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            AssertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringHalffloat256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsHalffloat256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    static int maskTrueCount(boolean[] a, int idx) {\n+        int trueCount = 0;\n+        for (int i = idx; i < idx + SPECIES.length(); i++) {\n+            trueCount += a[i] ? 1 : 0;\n+        }\n+        return trueCount;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.trueCount();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat256VectorTests::maskTrueCount);\n+    }\n+\n+    static int maskLastTrue(boolean[] a, int idx) {\n+        int i = idx + SPECIES.length() - 1;\n+        for (; i >= idx; i--) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.lastTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat256VectorTests::maskLastTrue);\n+    }\n+\n+    static int maskFirstTrue(boolean[] a, int idx) {\n+        int i = idx;\n+        for (; i < idx + SPECIES.length(); i++) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskFirstTrueHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.firstTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat256VectorTests::maskFirstTrue);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongHalffloat256VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeHalffloat256VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongHalffloat256VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundHalffloat256VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongHalffloat256VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test\n+    static void ElementSizeHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        int elsize = av.elementSize();\n+        AssertEquals(elsize, Float16.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorShapeHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        assert(vsh.equals(VectorShape.S_256_BIT));\n+    }\n+\n+    @Test\n+    static void ShapeWithLanesHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(Float16.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void HalffloatHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementType() == Float16.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Float16.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(Float16.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void MaskAllTrueHalffloat256VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat256VectorTests.java","additions":5740,"deletions":0,"binary":false,"changes":5740,"status":"added"},{"patch":"@@ -0,0 +1,1016 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @run testng\/othervm -XX:-TieredCompilation Halffloat512VectorLoadStoreTests\n+ *\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.ValueLayout;\n+import jdk.incubator.vector.Float16;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.internal.vm.annotation.DontInline;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.ByteOrder;\n+import java.util.List;\n+import java.util.function.*;\n+\n+@Test\n+public class Halffloat512VectorLoadStoreTests extends AbstractVectorLoadStoreTest {\n+    static final VectorSpecies<Float16> SPECIES =\n+                HalffloatVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n+\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 512);\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0, \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            })\n+    );\n+\n+    \/\/ Relative to array.length\n+    static final List<IntFunction<Integer>> INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl + 1\", (int l) -> {\n+                return l - SPECIES.length() + 1;\n+            }),\n+            withToString(\"l + speciesl - 1\", (int l) -> {\n+                return l + SPECIES.length() - 1;\n+            }),\n+            withToString(\"l + speciesl\", (int l) -> {\n+                return l + SPECIES.length();\n+            }),\n+            withToString(\"l + speciesl + 1\", (int l) -> {\n+                return l + SPECIES.length() + 1;\n+            })\n+    );\n+\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n+    static final List<IntFunction<Integer>> BYTE_INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl*ebsize + 1\", (int l) -> {\n+                return l - SPECIES.vectorByteSize() + 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize - 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() - 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize\", (int l) -> {\n+                return l + SPECIES.vectorByteSize();\n+            }),\n+            withToString(\"l + speciesl*ebsize + 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() + 1;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ELEMENT_LAYOUT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ELEMENT_LAYOUT);\n+    }\n+\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static VectorShuffle<Float16> shuffleFromArray(int[] a, int i) {\n+        return SPECIES.shuffleFromArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void shuffleIntoArray(VectorShuffle<Float16> s, int[] a, int i) {\n+        s.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static VectorShuffle<Float16> shuffleFromMemorySegment(MemorySegment mem, int i, ByteOrder bo) {\n+        return VectorShuffle.fromMemorySegment(SPECIES, mem, i, bo);\n+    }\n+\n+    @DontInline\n+    static void shuffleIntoMemorySegment(VectorShuffle<Float16> s, MemorySegment mem, int i, ByteOrder bo) {\n+        s.intoMemorySegment(mem, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i) {\n+        \/\/ Tests the species method and the equivalent vector method it defers to\n+        return (HalffloatVector) SPECIES.fromArray(a, i);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i, VectorMask<Float16> m) {\n+        return HalffloatVector.fromArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i) {\n+        v.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Float16> m) {\n+        v.intoArray(a, i, m);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        \/\/ Tests the species method and the equivalent vector method it defers to\n+        return (HalffloatVector) SPECIES.fromMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n+\n+    @Test(dataProvider = \"shortProvider\")\n+    static void loadStoreArray(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void loadArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void storeArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMaskArray(IntFunction<short[]> fa,\n+                                   IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void loadArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void storeArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMask(IntFunction<short[]> fa,\n+                              IntFunction<boolean[]> fm) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[mask.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, mask);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        short[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Float16> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Float16> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+\n+   @Test(dataProvider = \"shuffleIntProvider\")\n+   static void loadStoreShuffleArray(IntFunction<int[]> fa) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+               shuffle.intoArray(r, i);\n+           }\n+       }\n+\n+       for (int i = 0; i < a.length; i++) {\n+          Assert.assertEquals(testPartiallyWrapIndex(SPECIES, a[i]), r[i]);\n+       }\n+\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntProviderForIOOBE\")\n+   static void storeShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);\n+               shuffleIntoArray(shuffle, r, i);\n+           }\n+       }\n+\n+       int index = fi.apply(a.length);\n+       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+       try {\n+           VectorShuffle<Float16> shuffle = shuffleFromArray(a, index);\n+           shuffleIntoArray(shuffle, r, index);\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntProviderForIOOBE\")\n+   static void loadShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);\n+               shuffle.intoArray(r, i);\n+           }\n+       }\n+\n+       int index = fi.apply(a.length);\n+       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+       try {\n+           shuffleFromArray(a, index);\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntMemorySegmentProvider\")\n+   static void loadStoreShuffleMemorySegment(IntFunction<int[]> fa,\n+                                      IntFunction<MemorySegment> fb,\n+                                      ByteOrder bo) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), fb);\n+       MemorySegment r = fb.apply((int) a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4; \/\/An integer for every lane is read out. So 4 bytes per lane\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle = VectorShuffle.fromMemorySegment(SPECIES, a, i, bo);\n+               shuffle.intoMemorySegment(r, i, bo);\n+           }\n+       }\n+\n+       for (int i = 0; i < l \/ 4; i++) {\n+           int ai = a.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);\n+           int ri = r.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);\n+           Assert.assertEquals(testPartiallyWrapIndex(SPECIES, ai), ri);\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntByteProviderForIOOBE\")\n+   static void shuffleLoadMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));\n+       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4;\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle = shuffleFromMemorySegment(a, i, ByteOrder.nativeOrder());\n+               shuffle.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+           }\n+       }\n+\n+       int index = fi.apply((int) a.byteSize());\n+       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());\n+       try {\n+           shuffleFromMemorySegment(a, index, ByteOrder.nativeOrder());\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntByteProviderForIOOBE\")\n+   static void shuffleStoreMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));\n+       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4;\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle =\n+                       VectorShuffle.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+               shuffleIntoMemorySegment(shuffle, r, i, ByteOrder.nativeOrder());\n+           }\n+       }\n+\n+       int index = fi.apply((int) a.byteSize());\n+       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());\n+       try {\n+           VectorShuffle<Float16> shuffle =\n+                   VectorShuffle.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+           shuffleIntoMemorySegment(shuffle, r, index, ByteOrder.nativeOrder());\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat512VectorLoadStoreTests.java","additions":1016,"deletions":0,"binary":false,"changes":1016,"status":"added"},{"patch":"@@ -0,0 +1,5740 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.vector\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Halffloat512VectorTests\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.Vector;\n+\n+import jdk.incubator.vector.Float16;\n+import static jdk.incubator.vector.Float16.*;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.Integer;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Test\n+public class Halffloat512VectorTests extends AbstractVectorTest {\n+\n+    static final VectorSpecies<Float16> SPECIES =\n+                HalffloatVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+    static HalffloatVector bcast_vec = HalffloatVector.broadcast(SPECIES, (short)10);\n+\n+    static void AssertEquals(short actual, short expected) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected));\n+    }\n+    static void AssertEquals(short actual, short expected, String msg) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected), msg);\n+    }\n+    static void AssertEquals(short actual, short expected, short delta) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected), Float.float16ToFloat((short)delta));\n+    }\n+    static void AssertEquals(short actual, short expected, short delta, String msg) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected), Float.float16ToFloat((short)delta), msg);\n+    }\n+    static void AssertEquals(short [] actual, short [] expected) {\n+        Assert.assertEquals(actual.length, expected.length);\n+        for (int i = 0; i < actual.length; i++) {\n+            Assert.assertEquals(Float.float16ToFloat((short)actual[i]), Float.float16ToFloat((short)expected[i]));\n+        }\n+    }\n+    static void AssertEquals(short [] actual, short [] expected, String msg) {\n+        Assert.assertEquals(actual.length, expected.length);\n+        for (int i = 0; i < actual.length; i++) {\n+            Assert.assertEquals(Float.float16ToFloat((short)actual[i]), Float.float16ToFloat((short)expected[i]), msg);\n+        }\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected));\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected), msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n+\n+    \/\/ for floating point addition reduction ops that may introduce rounding errors\n+    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_ADD = (short)10.0;\n+\n+    \/\/ for floating point multiplication reduction ops that may introduce rounding errors\n+    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_MUL = (short)50.0;\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 512);\n+\n+    static void assertArraysStrictlyEquals(short[] r, short[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            short ir = r[i];\n+            short ia = a[i];\n+            if (ir != ia) {\n+                Assert.fail(String.format(\"at index #%d, expected = %016X, actual = %016X\", i, ia, ir));\n+            }\n+        }\n+    }\n+\n+    interface FUnOp {\n+        short apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FUnArrayOp {\n+        short[] apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a[i]);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    interface FReductionOp {\n+        short apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOp {\n+        short apply(short[] a);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa) {\n+        assertReductionArraysEquals(r, rc, a, f, fa, (short)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            short relativeErrorFactor) {\n+        int i = 0;\n+        try {\n+            AssertEquals(rc, fa.apply(a), float16ToShortBits(Float16.multiply(Float16.ulp(shortBitsToFloat16(rc)), shortBitsToFloat16(relativeErrorFactor))));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i), float16ToShortBits(Float16.multiply(Float16.ulp(shortBitsToFloat16(r[i])), shortBitsToFloat16(relativeErrorFactor))));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rc, fa.apply(a), float16ToShortBits(Float16.multiply(Float16.ulp(shortBitsToFloat16(rc)), shortBitsToFloat16(relativeErrorFactor))), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), float16ToShortBits(Float16.multiply(Float16.ulp(shortBitsToFloat16(r[i])), shortBitsToFloat16(relativeErrorFactor))), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOp {\n+        short apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOp {\n+        short apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa) {\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (short)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            short relativeError) {\n+        int i = 0;\n+        try {\n+            AssertEquals(rc, fa.apply(a, mask), float16ToShortBits(Float16.abs(Float16.multiply(shortBitsToFloat16(rc), shortBitsToFloat16(relativeError)))));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i, mask), float16ToShortBits(Float16.abs(Float16.multiply(shortBitsToFloat16(r[i]), shortBitsToFloat16(relativeError)))));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rc, fa.apply(a, mask), float16ToShortBits(Float16.abs(Float16.multiply(shortBitsToFloat16(rc), shortBitsToFloat16(relativeError)))), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), float16ToShortBits(Float16.abs(Float16.multiply(shortBitsToFloat16(r[i]), shortBitsToFloat16(relativeError)))), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionOpLong {\n+        long apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOpLong {\n+        long apply(short[] a);\n+    }\n+\n+    static void assertReductionLongArraysEquals(long[] r, long rc, short[] a,\n+                                            FReductionOpLong f, FReductionAllOpLong fa) {\n+        int i = 0;\n+        try {\n+            AssertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOpLong {\n+        long apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOpLong {\n+        long apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionLongArraysEqualsMasked(long[] r, long rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOpLong f, FReductionAllMaskedOpLong fa) {\n+        int i = 0;\n+        try {\n+            AssertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolReductionOp {\n+        boolean apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertReductionBoolArraysEquals(boolean[] r, boolean[] a, FBoolReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FMaskReductionOp {\n+        int apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertMaskReductionArraysEquals(int[] r, boolean[] a, FMaskReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        AssertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    AssertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                AssertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        AssertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        AssertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                AssertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod(shortBitsToFloat16(order[idx]).intValue(), 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        int idx = 0, wrapped_index = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = shortBitsToFloat16(order[i+j]).intValue();\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n+                    else\n+                         AssertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                AssertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        int idx = 0, wrapped_index = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = shortBitsToFloat16(order[i+j]).intValue();\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    if (mask[j % SPECIES.length()])\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n+                    else\n+                         AssertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            if (mask[j % SPECIES.length()])\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                AssertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a) {\n+        int i = 0;\n+        for (; i < a.length; i += SPECIES.length()) {\n+            int idx = i;\n+            for (int j = idx; j < (idx + SPECIES.length()); j++)\n+                a[j]=a[idx];\n+        }\n+\n+        try {\n+            for (i = 0; i < a.length; i++) {\n+                AssertEquals(r[i], a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FBinOp {\n+        short apply(short a, short b);\n+    }\n+\n+    interface FBinMaskOp {\n+        short apply(short a, short b, boolean m);\n+\n+        static FBinMaskOp lift(FBinOp f) {\n+            return (a, b, m) -> m ? f.apply(a, b) : a;\n+        }\n+    }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                AssertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                AssertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertShiftArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FBinConstOp {\n+        short apply(short a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        short apply(short a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FTernOp {\n+        short apply(short a, short b, short c);\n+    }\n+\n+    interface FTernMaskOp {\n+        short apply(short a, short b, short c, boolean m);\n+\n+        static FTernMaskOp lift(FTernOp f) {\n+            return (a, b, c, m) -> m ? f.apply(a, b, c) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernOp f) {\n+        assertArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+              + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[(i \/ SPECIES.length()) * SPECIES.length()] + \",  input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[i] + \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i]\n+                                + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernOp f) {\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]), \"at index #\"\n+                                + i + \", input1 = \" + a[i] + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+\n+    static boolean isWithin1Ulp(short actual, short expected) {\n+        Float16 act = shortBitsToFloat16(actual);\n+        Float16 exp = shortBitsToFloat16(expected);\n+        if (Float16.isNaN(exp) && !Float16.isNaN(act)) {\n+            return false;\n+        } else if (!Float16.isNaN(exp) && Float16.isNaN(act)) {\n+             return false;\n+        }\n+\n+        Float16 low = Float16.nextDown(exp);\n+        Float16 high = Float16.nextUp(exp);\n+\n+        if (Float16.compare(low, exp) > 0) {\n+            return false;\n+        }\n+\n+        if (Float16.compare(high, exp) < 0) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, FUnOp mathf, FUnOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]), shortBitsToFloat16(mathf.apply(a[i]))) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]), shortBitsToFloat16(mathf.apply(a[i]))) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i])), \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i]));\n+        }\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b, FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]), shortBitsToFloat16(mathf.apply(a[i], b[i]))) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]), shortBitsToFloat16(mathf.apply(a[i], b[i]))) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i], b[i]));\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b,\n+                                                        FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]),\n+                                  shortBitsToFloat16(mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]))) == 0 ||\n+                                  isWithin1Ulp(r[i],\n+                                  strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]),\n+                              shortBitsToFloat16(mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]))) == 0,\n+                              \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                              b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                              \", expected = \" + mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            Assert.assertTrue(isWithin1Ulp(r[i],\n+                              strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                             \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                             \", expected (within 1 ulp) = \" + strictmathf.apply(a[i],\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+        }\n+    }\n+\n+    interface FGatherScatterOp {\n+        short[] apply(short[] a, int ix, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, FGatherScatterOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherMaskedOp {\n+        short[] apply(short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    interface FScatterMaskedOp {\n+        short[] apply(short[] r, short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FGatherMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FScatterMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(r, a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(r, a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", r: \"\n+              + Arrays.toString(Arrays.copyOfRange(r, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneOp {\n+        short[] apply(short[] a, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int origin, FLaneOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneBop {\n+        short[] apply(short[] a, short[] b, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, FLaneBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLaneMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, boolean[] mask, FLaneMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLanePartBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, FLanePartBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    interface FLanePartMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, boolean[] mask, FLanePartMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    static short genValue(int i) {\n+        return float16ToShortBits(Float16.valueOf(i));\n+    }\n+\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> INT_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Float16[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(int[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                AssertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static short genValue(long i) {\n+        return float16ToShortBits(Float16.valueOf(i));\n+    }\n+\n+    static final List<IntFunction<short[]>> LONG_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Float16[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(long[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                AssertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(double[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                AssertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static short bits(short e) {\n+        return e;\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Float16[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> Float.floatToFloat16((0.01f + ((float)i \/ (i + 1)))));\n+            }),\n+            withToString(\"Float16[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01f + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (i % 17 == 0) ? cornerCaseValue(i) : Float.floatToFloat16((0.01f + ((float)i \/ (i + 1)))));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    \/\/ Create combinations of pairs\n+    \/\/ @@@ Might be sensitive to order e.g. div by 0\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_PAIRS =\n+        Stream.of(HALFFLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> HALFFLOAT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] boolUnaryOpProvider() {\n+        return BOOL_ARRAY_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> HALFFLOAT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"short[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortIndexedOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortSelectFromTwoVectorOpProvider() {\n+        return HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_TRIPLES.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoIntUnaryOpProvider() {\n+        return INT_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoLongUnaryOpProvider() {\n+        return LONG_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<BiFunction<Integer,Integer,short[]>> HALFFLOAT_SHUFFLE_GENERATORS = List.of(\n+            withToStringBi(\"shuffle[random]\", (Integer l, Integer m) -> {\n+                short[] a = new short[l];\n+                int upper = m;\n+                for (int i = 0; i < 1; i++) {\n+                    a[i] = (short)RAND.nextInt(upper);\n+                }\n+                return a;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromProvider() {\n+        return HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_COMPARE_GENERATORS = List.of(\n+            withToString(\"short[i]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)i);\n+            }),\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i + 1));\n+            }),\n+            withToString(\"short[i - 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - 2));\n+            }),\n+            withToString(\"short[zigZag(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i%3 == 0 ? (short)i : (i%3 == 1 ? (short)(i + 1) : (short)(i - 2)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_TEST_GENERATOR_ARGS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                map(fa -> List.of(fa)).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortTestOpProvider() {\n+        return HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_COMPARE_GENERATOR_PAIRS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                flatMap(fa -> HALFFLOAT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpProvider() {\n+        return HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    static short cornerCaseValue(int i) {\n+        return switch(i % 8) {\n+            case 0  -> float16ToShortBits(Float16.MAX_VALUE);\n+            case 1  -> float16ToShortBits(Float16.MIN_VALUE);\n+            case 2  -> float16ToShortBits(Float16.NEGATIVE_INFINITY);\n+            case 3  -> float16ToShortBits(Float16.POSITIVE_INFINITY);\n+            case 4  -> float16ToShortBits(Float16.NaN);\n+            case 5  -> float16ToShortBits(shortBitsToFloat16((short)0x7FFA));\n+            case 6  -> ((short)0.0);\n+            default -> ((short)-0.0);\n+        };\n+    }\n+\n+    static final IntFunction<short[]> fr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new short[length];\n+    };\n+\n+    static final IntFunction<boolean[]> fmr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new boolean[length];\n+    };\n+\n+    static final IntFunction<long[]> lfr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new long[length];\n+    };\n+\n+    static boolean eq(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() == bt.floatValue();\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() != bt.floatValue();\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() < bt.floatValue();\n+    }\n+\n+    static boolean le(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() <= bt.floatValue();\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() > bt.floatValue();\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() >= bt.floatValue();\n+    }\n+\n+    static short firstNonZero(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        Float16 zero = shortBitsToFloat16((short)0);\n+        return Float16.compare(at, zero) != 0 ? a : b;\n+    }\n+\n+    static short multiplicativeIdentity() {\n+        return (short)float16ToShortBits(Float16.valueOf(1.0f));\n+    }\n+\n+    static short scalar_add(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.add(at, bt));\n+    }\n+\n+    static short scalar_sub(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.subtract(at, bt));\n+    }\n+\n+    static short scalar_mul(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.multiply(at, bt));\n+\n+    }\n+    static short scalar_max(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.max(at, bt));\n+    }\n+\n+    static short scalar_min(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.min(at, bt));\n+    }\n+\n+    static short scalar_div(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.divide(at, bt));\n+    }\n+\n+    static short scalar_fma(short a, short b, short c) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        Float16 ct = shortBitsToFloat16(c);\n+        return float16ToShortBits(Float16.fma(at, bt, ct));\n+    }\n+\n+    static short scalar_abs(short a) {\n+        Float16 at = shortBitsToFloat16(a);\n+        return float16ToShortBits(Float16.abs(at));\n+    }\n+\n+    static short scalar_neg(short a) {\n+        Float16 at = shortBitsToFloat16(a);\n+        return float16ToShortBits(Float16.valueOf(-at.floatValue()));\n+    }\n+\n+    static short scalar_sin(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.sin(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_exp(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.exp(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_log1p(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.log1p(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_log(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.log(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_log10(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.log10(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_expm1(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.expm1(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_cos(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.cos(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_tan(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.tan(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_sinh(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.sinh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_cosh(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.cosh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_tanh(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.tanh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_asin(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.asin(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_acos(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.acos(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_atan(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.atan(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_cbrt(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.cbrt(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_sqrt(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.sqrt(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_hypot(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(Math.hypot(shortBitsToFloat16(a).doubleValue(),\n+                                                                     shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static short scalar_pow(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(Math.pow(shortBitsToFloat16(a).doubleValue(),\n+                                                                   shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static short scalar_atan2(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(Math.atan2(shortBitsToFloat16(a).doubleValue(),\n+                                                                     shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static short strict_scalar_sin(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.sin(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_exp(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.exp(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_log1p(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.log1p(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_log(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.log(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_log10(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.log10(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_expm1(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.expm1(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_cos(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.cos(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_tan(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.tan(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_sinh(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.sinh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_cosh(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.cosh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_tanh(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.tanh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_asin(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.asin(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_acos(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.acos(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_atan(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.atan(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_cbrt(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.cbrt(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_sqrt(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.sqrt(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_hypot(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.hypot(shortBitsToFloat16(a).doubleValue(),\n+                                                                     shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static short strict_scalar_pow(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.pow(shortBitsToFloat16(a).doubleValue(),\n+                                                                   shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static short strict_scalar_atan2(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.atan2(shortBitsToFloat16(a).doubleValue(),\n+                                                                     shortBitsToFloat16(b).doubleValue())));\n+    }\n+    static short additiveIdentity() {\n+        return (short)0;\n+    }\n+\n+\n+    static short zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static short maxValue() {\n+        return float16ToShortBits(Float16.POSITIVE_INFINITY);\n+    }\n+\n+    static short minValue() {\n+        return float16ToShortBits(Float16.NEGATIVE_INFINITY);\n+    }\n+\n+    static boolean isNaN(short a) {\n+        return Float16.isNaN(shortBitsToFloat16(a));\n+    }\n+    static boolean isFinite(short a) {\n+        return Float16.isFinite(shortBitsToFloat16(a));\n+    }\n+    static boolean isInfinite(short a) {\n+        return Float16.isInfinite(shortBitsToFloat16(a));\n+    }\n+\n+    @Test\n+    static void smokeTest1() {\n+        HalffloatVector three = HalffloatVector.broadcast(SPECIES, float16ToShortBits(Float16.valueOf(-3)));\n+        HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(float16ToShortBits(Float16.valueOf(-3)));\n+        assert(three.eq(three2).allTrue());\n+        HalffloatVector three3 = three2.broadcast(float16ToShortBits(Float16.valueOf(1))).broadcast(float16ToShortBits(Float16.valueOf(-3)));\n+        assert(three.eq(three3).allTrue());\n+        int scale = 2;\n+        HalffloatVector higher = three.addIndex(scale);\n+        VectorMask<Float16> m = three.compare(VectorOperators.LE, higher);\n+        assert(m.allTrue());\n+        m = higher.min((float16ToShortBits(Float16.valueOf(-1)))).test(VectorOperators.IS_NEGATIVE);\n+        assert(m.allTrue());\n+        m = higher.test(VectorOperators.IS_FINITE);\n+        assert(m.allTrue());\n+        short max = higher.reduceLanes(VectorOperators.MAX);\n+        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));\n+    }\n+\n+    private static short[]\n+    bothToArray(HalffloatVector a, HalffloatVector b) {\n+        short[] r = new short[a.length() + b.length()];\n+        a.intoArray(r, 0);\n+        b.intoArray(r, a.length());\n+        return r;\n+    }\n+\n+    @Test\n+    static void smokeTest2() {\n+        \/\/ Do some zipping and shuffling.\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES,0,1,false).toVector();\n+        AssertEquals(io, io2);\n+        HalffloatVector a = io.add((short)1); \/\/[1,2]\n+        HalffloatVector b = a.neg();  \/\/[-1,-2]\n+        short[] abValues = bothToArray(a,b); \/\/[1,2,-1,-2]\n+        VectorShuffle<Float16> zip0 = VectorShuffle.makeZip(SPECIES, 0);\n+        VectorShuffle<Float16> zip1 = VectorShuffle.makeZip(SPECIES, 1);\n+        HalffloatVector zab0 = a.rearrange(zip0,b); \/\/[1,-1]\n+        HalffloatVector zab1 = a.rearrange(zip1,b); \/\/[2,-2]\n+        short[] zabValues = bothToArray(zab0, zab1); \/\/[1,-1,2,-2]\n+        \/\/ manually zip\n+        short[] manual = new short[zabValues.length];\n+        for (int i = 0; i < manual.length; i += 2) {\n+            manual[i+0] = abValues[i\/2];\n+            manual[i+1] = abValues[a.length() + i\/2];\n+        }\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        VectorShuffle<Float16> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);\n+        VectorShuffle<Float16> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);\n+        HalffloatVector uab0 = zab0.rearrange(unz0,zab1);\n+        HalffloatVector uab1 = zab0.rearrange(unz1,zab1);\n+        short[] abValues1 = bothToArray(uab0, uab1);\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+    }\n+\n+    static void iotaShuffle() {\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES, 0 , 1, false).toVector();\n+        AssertEquals(io, io2);\n+    }\n+\n+    @Test\n+    \/\/ Test all shuffle related operations.\n+    static void shuffleTest() {\n+        \/\/ To test backend instructions, make sure that C2 is used.\n+        for (int loop = 0; loop < INVOC_COUNT * INVOC_COUNT; loop++) {\n+            iotaShuffle();\n+        }\n+    }\n+\n+    @Test\n+    void viewAsIntegeralLanesTest() {\n+        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();\n+        VectorSpecies<?> asIntegralSpecies = asIntegral.species();\n+        Assert.assertNotEquals(asIntegralSpecies.elementType(), SPECIES.elementType());\n+        AssertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        AssertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+    }\n+\n+    @Test\n+    void viewAsFloatingLanesTest() {\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        AssertEquals(asFloating.species(), SPECIES);\n+    }\n+\n+    static short ADD(short a, short b) {\n+        return (short)(scalar_add(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::ADD);\n+    }\n+\n+    static short add(short a, short b) {\n+        return (short)(scalar_add(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void addHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.add(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::add);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void addHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.add(bv, vmask).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::add);\n+    }\n+\n+    static short SUB(short a, short b) {\n+        return (short)(scalar_sub(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void SUBHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::SUB);\n+    }\n+\n+    static short sub(short a, short b) {\n+        return (short)(scalar_sub(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void subHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.sub(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::sub);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void SUBHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::SUB);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void subHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.sub(bv, vmask).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::sub);\n+    }\n+\n+    static short MUL(short a, short b) {\n+        return (short)(scalar_mul(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MULHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::MUL);\n+    }\n+\n+    static short mul(short a, short b) {\n+        return (short)(scalar_mul(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void mulHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.mul(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::mul);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MULHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::MUL);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void mulHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.mul(bv, vmask).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::mul);\n+    }\n+\n+    static short DIV(short a, short b) {\n+        return (short)(scalar_div(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void DIVHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::DIV);\n+    }\n+\n+    static short div(short a, short b) {\n+        return (short)(scalar_div(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void divHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.div(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::div);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void DIVHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::DIV);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void divHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.div(bv, vmask).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::div);\n+    }\n+\n+    static short FIRST_NONZERO(short a, short b) {\n+        return (short)(firstNonZero(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void FIRST_NONZEROHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::FIRST_NONZERO);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void FIRST_NONZEROHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::FIRST_NONZERO);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void addHalffloat512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.add(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat512VectorTests::add);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void addHalffloat512VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.add(b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, Halffloat512VectorTests::add);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void subHalffloat512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.sub(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat512VectorTests::sub);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void subHalffloat512VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.sub(b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, Halffloat512VectorTests::sub);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void mulHalffloat512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.mul(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat512VectorTests::mul);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void mulHalffloat512VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.mul(b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, Halffloat512VectorTests::mul);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void divHalffloat512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.div(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat512VectorTests::div);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void divHalffloat512VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.div(b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, Halffloat512VectorTests::div);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDHalffloat512VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(r, a, b, Halffloat512VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDHalffloat512VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(r, a, b, mask, Halffloat512VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINHalffloat512VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Halffloat512VectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void minHalffloat512VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.min(bcast_vec).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Halffloat512VectorTests::min);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MINHalffloat512VectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, Halffloat512VectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXHalffloat512VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Halffloat512VectorTests::MAX);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void maxHalffloat512VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.max(bcast_vec).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Halffloat512VectorTests::max);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MAXHalffloat512VectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, Halffloat512VectorTests::MAX);\n+    }\n+\n+    static short MIN(short a, short b) {\n+        return (short)(scalar_min(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MINHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::MIN);\n+    }\n+\n+    static short min(short a, short b) {\n+        return (short)(scalar_min(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void minHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.min(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::min);\n+    }\n+\n+    static short MAX(short a, short b) {\n+        return (short)(scalar_max(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MAXHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::MAX);\n+    }\n+\n+    static short max(short a, short b) {\n+        return (short)(scalar_max(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void maxHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.max(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::max);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MINHalffloat512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.MIN, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat512VectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void minHalffloat512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.min(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat512VectorTests::min);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MAXHalffloat512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.MAX, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat512VectorTests::MAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void maxHalffloat512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.max(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat512VectorTests::max);\n+    }\n+\n+    static short ADDReduce(short[] a, int idx) {\n+        short res = additiveIdentity();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = scalar_add(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short ADDReduceAll(short[] a) {\n+        short res = additiveIdentity();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_add(res, ADDReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = additiveIdentity();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = additiveIdentity();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Halffloat512VectorTests::ADDReduce, Halffloat512VectorTests::ADDReduceAll, RELATIVE_ROUNDING_ERROR_FACTOR_ADD);\n+    }\n+\n+    static short ADDReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = additiveIdentity();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = scalar_add(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short ADDReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = additiveIdentity();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ADDReduceHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = additiveIdentity();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = additiveIdentity();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat512VectorTests::ADDReduceMasked, Halffloat512VectorTests::ADDReduceAllMasked, RELATIVE_ROUNDING_ERROR_FACTOR_ADD);\n+    }\n+\n+    static short MULReduce(short[] a, int idx) {\n+        short res = multiplicativeIdentity();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = scalar_mul(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MULReduceAll(short[] a) {\n+        short res = multiplicativeIdentity();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_mul(res, MULReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MULReduceHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = multiplicativeIdentity();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = multiplicativeIdentity();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Halffloat512VectorTests::MULReduce, Halffloat512VectorTests::MULReduceAll, RELATIVE_ROUNDING_ERROR_FACTOR_MUL);\n+    }\n+\n+    static short MULReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = multiplicativeIdentity();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = scalar_mul(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MULReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = multiplicativeIdentity();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MULReduceHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = multiplicativeIdentity();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = multiplicativeIdentity();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat512VectorTests::MULReduceMasked, Halffloat512VectorTests::MULReduceAllMasked, RELATIVE_ROUNDING_ERROR_FACTOR_MUL);\n+    }\n+\n+    static short MINReduce(short[] a, int idx) {\n+        short res = maxValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = scalar_min(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MINReduceAll(short[] a) {\n+        short res = maxValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_min(res, MINReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINReduceHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = maxValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MIN);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = maxValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Halffloat512VectorTests::MINReduce, Halffloat512VectorTests::MINReduceAll);\n+    }\n+\n+    static short MINReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = maxValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = scalar_min(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MINReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = maxValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MINReduceHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = maxValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = maxValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat512VectorTests::MINReduceMasked, Halffloat512VectorTests::MINReduceAllMasked);\n+    }\n+\n+    static short MAXReduce(short[] a, int idx) {\n+        short res = minValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = scalar_max(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MAXReduceAll(short[] a) {\n+        short res = minValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_max(res, MAXReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXReduceHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = minValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MAX);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = minValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Halffloat512VectorTests::MAXReduce, Halffloat512VectorTests::MAXReduceAll);\n+    }\n+\n+    static short MAXReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = minValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = scalar_max(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MAXReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = minValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MAXReduceHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = minValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = minValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat512VectorTests::MAXReduceMasked, Halffloat512VectorTests::MAXReduceAllMasked);\n+    }\n+\n+    static short FIRST_NONZEROReduce(short[] a, int idx) {\n+        short res = zeroValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short FIRST_NONZEROReduceAll(short[] a) {\n+        short res = zeroValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = zeroValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = zeroValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Halffloat512VectorTests::FIRST_NONZEROReduce, Halffloat512VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+\n+    static short FIRST_NONZEROReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = zeroValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short FIRST_NONZEROReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = zeroValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = zeroValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = zeroValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat512VectorTests::FIRST_NONZEROReduceMasked, Halffloat512VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void withHalffloat512VectorTests(IntFunction<short []> fa, IntFunction<short []> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+\n+        assertArraysStrictlyEquals(r, a);\n+    }\n+\n+    static boolean testIS_DEFAULT(short a) {\n+        return bits(a)==0;\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpProvider\")\n+    static void IS_DEFAULTHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_DEFAULT);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedHalffloat512VectorTests(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    static boolean testIS_NEGATIVE(short a) {\n+        return bits(a)<0;\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpProvider\")\n+    static void IS_NEGATIVEHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_NEGATIVE);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedHalffloat512VectorTests(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    static boolean testIS_FINITE(short a) {\n+        return isFinite(a);\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpProvider\")\n+    static void IS_FINITEHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_FINITE);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), testIS_FINITE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_FINITEMaskedHalffloat512VectorTests(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    static boolean testIS_NAN(short a) {\n+        return isNaN(a);\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpProvider\")\n+    static void IS_NANHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_NAN);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), testIS_NAN(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_NANMaskedHalffloat512VectorTests(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_NAN, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    static boolean testIS_INFINITE(short a) {\n+        return isInfinite(a);\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpProvider\")\n+    static void IS_INFINITEHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_INFINITE);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), testIS_INFINITE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_INFINITEMaskedHalffloat512VectorTests(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void LTHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.lt(bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void LTHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void GTHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void GTHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void EQHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.EQ, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.eq(bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void EQHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.EQ, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void NEHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.NE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void NEHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.NE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void LEHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void LEHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void GEHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void GEHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void LTHalffloat512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.LT, b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void LTHalffloat512VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa,\n+                                IntFunction<short[]> fb, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.LT, b[i], vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void LTHalffloat512VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.LT, (long)b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (short)((long)b[i])));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void LTHalffloat512VectorTestsBroadcastLongMaskedSmokeTest(IntFunction<short[]> fa,\n+                                IntFunction<short[]> fb, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.LT, (long)b[i], vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(short)((long)b[i]))));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void EQHalffloat512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.EQ, b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void EQHalffloat512VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa,\n+                                IntFunction<short[]> fb, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.EQ, b[i], vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void EQHalffloat512VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.EQ, (long)b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (short)((long)b[i])));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void EQHalffloat512VectorTestsBroadcastLongMaskedSmokeTest(IntFunction<short[]> fa,\n+                                IntFunction<short[]> fb, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.EQ, (long)b[i], vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(short)((long)b[i]))));\n+            }\n+        }\n+    }\n+\n+    static short blend(short a, short b, boolean mask) {\n+        return mask ? b : a;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::blend);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpShuffleProvider\")\n+    static void RearrangeHalffloat512VectorTests(IntFunction<short[]> fa,\n+                                           BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        assertRearrangeArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpShuffleMaskProvider\")\n+    static void RearrangeHalffloat512VectorTestsMaskedSmokeTest(IntFunction<short[]> fa,\n+                                                          BiFunction<Integer,Integer,int[]> fs,\n+                                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.rearrange(VectorShuffle.fromArray(SPECIES, order, i), vmask).intoArray(r, i);\n+        }\n+\n+        assertRearrangeArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void compressHalffloat512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void expandHalffloat512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void getHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        assertArraysStrictlyEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void BroadcastHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ZeroHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        AssertEquals(a, r);\n+    }\n+\n+    static short[] sliceUnary(short[] a, int origin, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0; i < SPECIES.length(); i++){\n+            if(i+origin < SPECIES.length())\n+                res[i] = a[idx+i+origin];\n+            else\n+                res[i] = (short)0;\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void sliceUnaryHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, origin, Halffloat512VectorTests::sliceUnary);\n+    }\n+\n+    static short[] sliceBinary(short[] a, short[] b, int origin, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if(i+origin < SPECIES.length())\n+                res[i] = a[idx+i+origin];\n+            else {\n+                res[i] = b[idx+j];\n+                j++;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void sliceBinaryHalffloat512VectorTestsBinary(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, origin, Halffloat512VectorTests::sliceBinary);\n+    }\n+\n+    static short[] slice(short[] a, short[] b, int origin, boolean[] mask, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if(i+origin < SPECIES.length())\n+                res[i] = mask[i] ? a[idx+i+origin] : (short)0;\n+            else {\n+                res[i] = mask[i] ? b[idx+j] : (short)0;\n+                j++;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void sliceHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, origin, mask, Halffloat512VectorTests::slice);\n+    }\n+\n+    static short[] unsliceUnary(short[] a, int origin, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if(i < origin)\n+                res[i] = (short)0;\n+            else {\n+                res[i] = a[idx+j];\n+                j++;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void unsliceUnaryHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, origin, Halffloat512VectorTests::unsliceUnary);\n+    }\n+\n+    static short[] unsliceBinary(short[] a, short[] b, int origin, int part, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if (part == 0) {\n+                if (i < origin)\n+                    res[i] = b[idx+i];\n+                else {\n+                    res[i] = a[idx+j];\n+                    j++;\n+                }\n+            } else if (part == 1) {\n+                if (i < origin)\n+                    res[i] = a[idx+SPECIES.length()-origin+i];\n+                else {\n+                    res[i] = b[idx+origin+j];\n+                    j++;\n+                }\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void unsliceBinaryHalffloat512VectorTestsBinary(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, origin, part, Halffloat512VectorTests::unsliceBinary);\n+    }\n+\n+    static short[] unslice(short[] a, short[] b, int origin, int part, boolean[] mask, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if(i+origin < SPECIES.length())\n+                res[i] = b[idx+i+origin];\n+            else {\n+                res[i] = b[idx+j];\n+                j++;\n+            }\n+        }\n+        for (int i = 0; i < SPECIES.length(); i++){\n+            res[i] = mask[i] ? a[idx+i] : res[i];\n+        }\n+        short[] res1 = new short[SPECIES.length()];\n+        if (part == 0) {\n+            for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+                if (i < origin)\n+                    res1[i] = b[idx+i];\n+                else {\n+                   res1[i] = res[j];\n+                   j++;\n+                }\n+            }\n+        } else if (part == 1) {\n+            for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+                if (i < origin)\n+                    res1[i] = res[SPECIES.length()-origin+i];\n+                else {\n+                    res1[i] = b[idx+origin+j];\n+                    j++;\n+                }\n+            }\n+        }\n+        return res1;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void unsliceHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, origin, part, mask, Halffloat512VectorTests::unslice);\n+    }\n+\n+    static short SIN(short a) {\n+        return (short)(scalar_sin(a));\n+    }\n+\n+    static short strictSIN(short a) {\n+        return (short)(strict_scalar_sin(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::SIN, Halffloat512VectorTests::strictSIN);\n+    }\n+\n+    static short EXP(short a) {\n+        return (short)(scalar_exp(a));\n+    }\n+\n+    static short strictEXP(short a) {\n+        return (short)(strict_scalar_exp(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::EXP, Halffloat512VectorTests::strictEXP);\n+    }\n+\n+    static short LOG1P(short a) {\n+        return (short)(scalar_log1p(a));\n+    }\n+\n+    static short strictLOG1P(short a) {\n+        return (short)(strict_scalar_log1p(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG1PHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::LOG1P, Halffloat512VectorTests::strictLOG1P);\n+    }\n+\n+    static short LOG(short a) {\n+        return (short)(scalar_log(a));\n+    }\n+\n+    static short strictLOG(short a) {\n+        return (short)(strict_scalar_log(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOGHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::LOG, Halffloat512VectorTests::strictLOG);\n+    }\n+\n+    static short LOG10(short a) {\n+        return (short)(scalar_log10(a));\n+    }\n+\n+    static short strictLOG10(short a) {\n+        return (short)(strict_scalar_log10(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG10Halffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::LOG10, Halffloat512VectorTests::strictLOG10);\n+    }\n+\n+    static short EXPM1(short a) {\n+        return (short)(scalar_expm1(a));\n+    }\n+\n+    static short strictEXPM1(short a) {\n+        return (short)(strict_scalar_expm1(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPM1Halffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::EXPM1, Halffloat512VectorTests::strictEXPM1);\n+    }\n+\n+    static short COS(short a) {\n+        return (short)(scalar_cos(a));\n+    }\n+\n+    static short strictCOS(short a) {\n+        return (short)(strict_scalar_cos(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::COS, Halffloat512VectorTests::strictCOS);\n+    }\n+\n+    static short TAN(short a) {\n+        return (short)(scalar_tan(a));\n+    }\n+\n+    static short strictTAN(short a) {\n+        return (short)(strict_scalar_tan(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::TAN, Halffloat512VectorTests::strictTAN);\n+    }\n+\n+    static short SINH(short a) {\n+        return (short)(scalar_sinh(a));\n+    }\n+\n+    static short strictSINH(short a) {\n+        return (short)(strict_scalar_sinh(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::SINH, Halffloat512VectorTests::strictSINH);\n+    }\n+\n+    static short COSH(short a) {\n+        return (short)(scalar_cosh(a));\n+    }\n+\n+    static short strictCOSH(short a) {\n+        return (short)(strict_scalar_cosh(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::COSH, Halffloat512VectorTests::strictCOSH);\n+    }\n+\n+    static short TANH(short a) {\n+        return (short)(scalar_tanh(a));\n+    }\n+\n+    static short strictTANH(short a) {\n+        return (short)(strict_scalar_tanh(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::TANH, Halffloat512VectorTests::strictTANH);\n+    }\n+\n+    static short ASIN(short a) {\n+        return (short)(scalar_asin(a));\n+    }\n+\n+    static short strictASIN(short a) {\n+        return (short)(strict_scalar_asin(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ASINHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::ASIN, Halffloat512VectorTests::strictASIN);\n+    }\n+\n+    static short ACOS(short a) {\n+        return (short)(scalar_acos(a));\n+    }\n+\n+    static short strictACOS(short a) {\n+        return (short)(strict_scalar_acos(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ACOSHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::ACOS, Halffloat512VectorTests::strictACOS);\n+    }\n+\n+    static short ATAN(short a) {\n+        return (short)(scalar_atan(a));\n+    }\n+\n+    static short strictATAN(short a) {\n+        return (short)(strict_scalar_atan(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ATANHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::ATAN, Halffloat512VectorTests::strictATAN);\n+    }\n+\n+    static short CBRT(short a) {\n+        return (short)(scalar_cbrt(a));\n+    }\n+\n+    static short strictCBRT(short a) {\n+        return (short)(strict_scalar_cbrt(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CBRTHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::CBRT, Halffloat512VectorTests::strictCBRT);\n+    }\n+\n+    static short HYPOT(short a, short b) {\n+        return (short)(scalar_hypot(a, b));\n+    }\n+\n+    static short strictHYPOT(short a, short b) {\n+        return (short)(strict_scalar_hypot(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void HYPOTHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::HYPOT, Halffloat512VectorTests::strictHYPOT);\n+    }\n+\n+\n+    static short POW(short a, short b) {\n+        return (short)(scalar_pow(a, b));\n+    }\n+\n+    static short strictPOW(short a, short b) {\n+        return (short)(strict_scalar_pow(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::POW, Halffloat512VectorTests::strictPOW);\n+    }\n+\n+\n+    static short pow(short a, short b) {\n+        return (short)(scalar_pow(a, b));\n+    }\n+\n+    static short strictpow(short a, short b) {\n+        return (short)(strict_scalar_pow(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.pow(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::pow, Halffloat512VectorTests::strictpow);\n+    }\n+\n+\n+    static short ATAN2(short a, short b) {\n+        return (short)(scalar_atan2(a, b));\n+    }\n+\n+    static short strictATAN2(short a, short b) {\n+        return (short)(strict_scalar_atan2(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ATAN2Halffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::ATAN2, Halffloat512VectorTests::strictATAN2);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.POW, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::POW, Halffloat512VectorTests::strictPOW);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.pow(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::pow, Halffloat512VectorTests::strictpow);\n+    }\n+\n+\n+    static short FMA(short a, short b, short c) {\n+        return (short)(scalar_fma(a, b, c));\n+    }\n+\n+    static short fma(short a, short b, short c) {\n+        return (short)(scalar_fma(a, b, c));\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat512VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void fmaHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.fma(bv, cv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat512VectorTests::fma);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, mask, Halffloat512VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.lanewise(VectorOperators.FMA, bv, c[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a, b, c, Halffloat512VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat512VectorTestsAltBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.lanewise(VectorOperators.FMA, b[i], cv).intoArray(r, i);\n+        }\n+        assertAltBroadcastArraysEquals(r, a, b, c, Halffloat512VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat512VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.lanewise(VectorOperators.FMA, bv, c[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, c, mask, Halffloat512VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat512VectorTestsAltBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.lanewise(VectorOperators.FMA, b[i], cv, vmask).intoArray(r, i);\n+        }\n+\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, Halffloat512VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat512VectorTestsDoubleBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.FMA, b[i], c[i]).intoArray(r, i);\n+        }\n+\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, Halffloat512VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void fmaHalffloat512VectorTestsDoubleBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.fma(b[i], c[i]).intoArray(r, i);\n+        }\n+\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, Halffloat512VectorTests::fma);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat512VectorTestsDoubleBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.FMA, b[i], c[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, Halffloat512VectorTests::FMA);\n+    }\n+\n+    static short NEG(short a) {\n+        return (short)(scalar_neg((short)a));\n+    }\n+\n+    static short neg(short a) {\n+        return (short)(scalar_neg((short)a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void NEGHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat512VectorTests::NEG);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void negHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.neg().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat512VectorTests::neg);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void NEGMaskedHalffloat512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat512VectorTests::NEG);\n+    }\n+\n+    static short ABS(short a) {\n+        return (short)(scalar_abs((short)a));\n+    }\n+\n+    static short abs(short a) {\n+        return (short)(scalar_abs((short)a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ABSHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat512VectorTests::ABS);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void absHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.abs().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat512VectorTests::abs);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ABSMaskedHalffloat512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat512VectorTests::ABS);\n+    }\n+\n+    static short SQRT(short a) {\n+        return (short)(scalar_sqrt(a));\n+    }\n+\n+    static short sqrt(short a) {\n+        return (short)(scalar_sqrt(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SQRTHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat512VectorTests::SQRT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void sqrtHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.sqrt().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat512VectorTests::sqrt);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void SQRTMaskedHalffloat512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat512VectorTests::SQRT);\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltHalffloat512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqHalffloat512VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoIntUnaryOpProvider\")\n+    static void toIntArrayHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int[] r = av.toIntArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void toLongArrayHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            long[] r = av.toLongArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toDoubleArrayHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            double[] r = av.toDoubleArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toStringHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void hashCodeHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n+    static long ADDReduceLong(short[] a, int idx) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLong(short[] a) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = Float.floatToFloat16(Float.float16ToFloat((short)res) + Float.float16ToFloat((short)ADDReduceLong(a, i)));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceLongHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            ra = (long)(Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16((short)ra), Float16.shortBitsToFloat16((short)r[i]))));\n+        }\n+\n+        assertReductionLongArraysEquals(r, ra, a,\n+                Halffloat512VectorTests::ADDReduceLong, Halffloat512VectorTests::ADDReduceAllLong);\n+    }\n+\n+    static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if(mask[i % SPECIES.length()])\n+                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = Float.floatToFloat16(Float.float16ToFloat((short)res) + Float.float16ToFloat((short)ADDReduceLongMasked(a, i, mask)));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ADDReduceLongHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            ra = (long)(Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16((short)ra), Float16.shortBitsToFloat16((short)r[i]))));\n+        }\n+\n+        assertReductionLongArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat512VectorTests::ADDReduceLongMasked, Halffloat512VectorTests::ADDReduceAllLongMasked);\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void BroadcastLongHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat512VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(r, a, b, mask, Halffloat512VectorTests::blend);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromProvider\")\n+    static void SelectFromHalffloat512VectorTests(IntFunction<short[]> fa,\n+                                           BiFunction<Integer,Integer,short[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] idx = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector idxv = HalffloatVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromMaskProvider\")\n+    static void SelectFromHalffloat512VectorTestsMaskedSmokeTest(IntFunction<short[]> fa,\n+                                                           BiFunction<Integer,Integer,short[]> fs,\n+                                                           IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av, vmask).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousHalffloat512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            AssertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringHalffloat512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsHalffloat512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    static int maskTrueCount(boolean[] a, int idx) {\n+        int trueCount = 0;\n+        for (int i = idx; i < idx + SPECIES.length(); i++) {\n+            trueCount += a[i] ? 1 : 0;\n+        }\n+        return trueCount;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.trueCount();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat512VectorTests::maskTrueCount);\n+    }\n+\n+    static int maskLastTrue(boolean[] a, int idx) {\n+        int i = idx + SPECIES.length() - 1;\n+        for (; i >= idx; i--) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.lastTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat512VectorTests::maskLastTrue);\n+    }\n+\n+    static int maskFirstTrue(boolean[] a, int idx) {\n+        int i = idx;\n+        for (; i < idx + SPECIES.length(); i++) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskFirstTrueHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.firstTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat512VectorTests::maskFirstTrue);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongHalffloat512VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeHalffloat512VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongHalffloat512VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundHalffloat512VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongHalffloat512VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test\n+    static void ElementSizeHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        int elsize = av.elementSize();\n+        AssertEquals(elsize, Float16.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorShapeHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        assert(vsh.equals(VectorShape.S_512_BIT));\n+    }\n+\n+    @Test\n+    static void ShapeWithLanesHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(Float16.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void HalffloatHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementType() == Float16.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Float16.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(Float16.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void MaskAllTrueHalffloat512VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat512VectorTests.java","additions":5740,"deletions":0,"binary":false,"changes":5740,"status":"added"},{"patch":"@@ -0,0 +1,1016 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @run testng\/othervm -XX:-TieredCompilation Halffloat64VectorLoadStoreTests\n+ *\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.ValueLayout;\n+import jdk.incubator.vector.Float16;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.internal.vm.annotation.DontInline;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.ByteOrder;\n+import java.util.List;\n+import java.util.function.*;\n+\n+@Test\n+public class Halffloat64VectorLoadStoreTests extends AbstractVectorLoadStoreTest {\n+    static final VectorSpecies<Float16> SPECIES =\n+                HalffloatVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n+\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 64);\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0, \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            })\n+    );\n+\n+    \/\/ Relative to array.length\n+    static final List<IntFunction<Integer>> INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl + 1\", (int l) -> {\n+                return l - SPECIES.length() + 1;\n+            }),\n+            withToString(\"l + speciesl - 1\", (int l) -> {\n+                return l + SPECIES.length() - 1;\n+            }),\n+            withToString(\"l + speciesl\", (int l) -> {\n+                return l + SPECIES.length();\n+            }),\n+            withToString(\"l + speciesl + 1\", (int l) -> {\n+                return l + SPECIES.length() + 1;\n+            })\n+    );\n+\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n+    static final List<IntFunction<Integer>> BYTE_INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl*ebsize + 1\", (int l) -> {\n+                return l - SPECIES.vectorByteSize() + 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize - 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() - 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize\", (int l) -> {\n+                return l + SPECIES.vectorByteSize();\n+            }),\n+            withToString(\"l + speciesl*ebsize + 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() + 1;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ELEMENT_LAYOUT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ELEMENT_LAYOUT);\n+    }\n+\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static VectorShuffle<Float16> shuffleFromArray(int[] a, int i) {\n+        return SPECIES.shuffleFromArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void shuffleIntoArray(VectorShuffle<Float16> s, int[] a, int i) {\n+        s.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static VectorShuffle<Float16> shuffleFromMemorySegment(MemorySegment mem, int i, ByteOrder bo) {\n+        return VectorShuffle.fromMemorySegment(SPECIES, mem, i, bo);\n+    }\n+\n+    @DontInline\n+    static void shuffleIntoMemorySegment(VectorShuffle<Float16> s, MemorySegment mem, int i, ByteOrder bo) {\n+        s.intoMemorySegment(mem, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i) {\n+        \/\/ Tests the species method and the equivalent vector method it defers to\n+        return (HalffloatVector) SPECIES.fromArray(a, i);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i, VectorMask<Float16> m) {\n+        return HalffloatVector.fromArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i) {\n+        v.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Float16> m) {\n+        v.intoArray(a, i, m);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        \/\/ Tests the species method and the equivalent vector method it defers to\n+        return (HalffloatVector) SPECIES.fromMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n+\n+    @Test(dataProvider = \"shortProvider\")\n+    static void loadStoreArray(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void loadArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void storeArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMaskArray(IntFunction<short[]> fa,\n+                                   IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void loadArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void storeArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMask(IntFunction<short[]> fa,\n+                              IntFunction<boolean[]> fm) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[mask.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, mask);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        short[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Float16> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Float16> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+\n+   @Test(dataProvider = \"shuffleIntProvider\")\n+   static void loadStoreShuffleArray(IntFunction<int[]> fa) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+               shuffle.intoArray(r, i);\n+           }\n+       }\n+\n+       for (int i = 0; i < a.length; i++) {\n+          Assert.assertEquals(testPartiallyWrapIndex(SPECIES, a[i]), r[i]);\n+       }\n+\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntProviderForIOOBE\")\n+   static void storeShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);\n+               shuffleIntoArray(shuffle, r, i);\n+           }\n+       }\n+\n+       int index = fi.apply(a.length);\n+       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+       try {\n+           VectorShuffle<Float16> shuffle = shuffleFromArray(a, index);\n+           shuffleIntoArray(shuffle, r, index);\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntProviderForIOOBE\")\n+   static void loadShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);\n+               shuffle.intoArray(r, i);\n+           }\n+       }\n+\n+       int index = fi.apply(a.length);\n+       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+       try {\n+           shuffleFromArray(a, index);\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntMemorySegmentProvider\")\n+   static void loadStoreShuffleMemorySegment(IntFunction<int[]> fa,\n+                                      IntFunction<MemorySegment> fb,\n+                                      ByteOrder bo) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), fb);\n+       MemorySegment r = fb.apply((int) a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4; \/\/An integer for every lane is read out. So 4 bytes per lane\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle = VectorShuffle.fromMemorySegment(SPECIES, a, i, bo);\n+               shuffle.intoMemorySegment(r, i, bo);\n+           }\n+       }\n+\n+       for (int i = 0; i < l \/ 4; i++) {\n+           int ai = a.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);\n+           int ri = r.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);\n+           Assert.assertEquals(testPartiallyWrapIndex(SPECIES, ai), ri);\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntByteProviderForIOOBE\")\n+   static void shuffleLoadMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));\n+       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4;\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle = shuffleFromMemorySegment(a, i, ByteOrder.nativeOrder());\n+               shuffle.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+           }\n+       }\n+\n+       int index = fi.apply((int) a.byteSize());\n+       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());\n+       try {\n+           shuffleFromMemorySegment(a, index, ByteOrder.nativeOrder());\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntByteProviderForIOOBE\")\n+   static void shuffleStoreMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));\n+       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4;\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle =\n+                       VectorShuffle.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+               shuffleIntoMemorySegment(shuffle, r, i, ByteOrder.nativeOrder());\n+           }\n+       }\n+\n+       int index = fi.apply((int) a.byteSize());\n+       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());\n+       try {\n+           VectorShuffle<Float16> shuffle =\n+                   VectorShuffle.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+           shuffleIntoMemorySegment(shuffle, r, index, ByteOrder.nativeOrder());\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat64VectorLoadStoreTests.java","additions":1016,"deletions":0,"binary":false,"changes":1016,"status":"added"},{"patch":"@@ -0,0 +1,5740 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.vector\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Halffloat64VectorTests\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.Vector;\n+\n+import jdk.incubator.vector.Float16;\n+import static jdk.incubator.vector.Float16.*;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.Integer;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Test\n+public class Halffloat64VectorTests extends AbstractVectorTest {\n+\n+    static final VectorSpecies<Float16> SPECIES =\n+                HalffloatVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+    static HalffloatVector bcast_vec = HalffloatVector.broadcast(SPECIES, (short)10);\n+\n+    static void AssertEquals(short actual, short expected) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected));\n+    }\n+    static void AssertEquals(short actual, short expected, String msg) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected), msg);\n+    }\n+    static void AssertEquals(short actual, short expected, short delta) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected), Float.float16ToFloat((short)delta));\n+    }\n+    static void AssertEquals(short actual, short expected, short delta, String msg) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected), Float.float16ToFloat((short)delta), msg);\n+    }\n+    static void AssertEquals(short [] actual, short [] expected) {\n+        Assert.assertEquals(actual.length, expected.length);\n+        for (int i = 0; i < actual.length; i++) {\n+            Assert.assertEquals(Float.float16ToFloat((short)actual[i]), Float.float16ToFloat((short)expected[i]));\n+        }\n+    }\n+    static void AssertEquals(short [] actual, short [] expected, String msg) {\n+        Assert.assertEquals(actual.length, expected.length);\n+        for (int i = 0; i < actual.length; i++) {\n+            Assert.assertEquals(Float.float16ToFloat((short)actual[i]), Float.float16ToFloat((short)expected[i]), msg);\n+        }\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected));\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected), msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n+\n+    \/\/ for floating point addition reduction ops that may introduce rounding errors\n+    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_ADD = (short)10.0;\n+\n+    \/\/ for floating point multiplication reduction ops that may introduce rounding errors\n+    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_MUL = (short)50.0;\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 64);\n+\n+    static void assertArraysStrictlyEquals(short[] r, short[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            short ir = r[i];\n+            short ia = a[i];\n+            if (ir != ia) {\n+                Assert.fail(String.format(\"at index #%d, expected = %016X, actual = %016X\", i, ia, ir));\n+            }\n+        }\n+    }\n+\n+    interface FUnOp {\n+        short apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FUnArrayOp {\n+        short[] apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a[i]);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    interface FReductionOp {\n+        short apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOp {\n+        short apply(short[] a);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa) {\n+        assertReductionArraysEquals(r, rc, a, f, fa, (short)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            short relativeErrorFactor) {\n+        int i = 0;\n+        try {\n+            AssertEquals(rc, fa.apply(a), float16ToShortBits(Float16.multiply(Float16.ulp(shortBitsToFloat16(rc)), shortBitsToFloat16(relativeErrorFactor))));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i), float16ToShortBits(Float16.multiply(Float16.ulp(shortBitsToFloat16(r[i])), shortBitsToFloat16(relativeErrorFactor))));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rc, fa.apply(a), float16ToShortBits(Float16.multiply(Float16.ulp(shortBitsToFloat16(rc)), shortBitsToFloat16(relativeErrorFactor))), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), float16ToShortBits(Float16.multiply(Float16.ulp(shortBitsToFloat16(r[i])), shortBitsToFloat16(relativeErrorFactor))), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOp {\n+        short apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOp {\n+        short apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa) {\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (short)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            short relativeError) {\n+        int i = 0;\n+        try {\n+            AssertEquals(rc, fa.apply(a, mask), float16ToShortBits(Float16.abs(Float16.multiply(shortBitsToFloat16(rc), shortBitsToFloat16(relativeError)))));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i, mask), float16ToShortBits(Float16.abs(Float16.multiply(shortBitsToFloat16(r[i]), shortBitsToFloat16(relativeError)))));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rc, fa.apply(a, mask), float16ToShortBits(Float16.abs(Float16.multiply(shortBitsToFloat16(rc), shortBitsToFloat16(relativeError)))), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), float16ToShortBits(Float16.abs(Float16.multiply(shortBitsToFloat16(r[i]), shortBitsToFloat16(relativeError)))), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionOpLong {\n+        long apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOpLong {\n+        long apply(short[] a);\n+    }\n+\n+    static void assertReductionLongArraysEquals(long[] r, long rc, short[] a,\n+                                            FReductionOpLong f, FReductionAllOpLong fa) {\n+        int i = 0;\n+        try {\n+            AssertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOpLong {\n+        long apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOpLong {\n+        long apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionLongArraysEqualsMasked(long[] r, long rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOpLong f, FReductionAllMaskedOpLong fa) {\n+        int i = 0;\n+        try {\n+            AssertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolReductionOp {\n+        boolean apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertReductionBoolArraysEquals(boolean[] r, boolean[] a, FBoolReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FMaskReductionOp {\n+        int apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertMaskReductionArraysEquals(int[] r, boolean[] a, FMaskReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        AssertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    AssertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                AssertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        AssertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        AssertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                AssertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod(shortBitsToFloat16(order[idx]).intValue(), 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        int idx = 0, wrapped_index = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = shortBitsToFloat16(order[i+j]).intValue();\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n+                    else\n+                         AssertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                AssertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        int idx = 0, wrapped_index = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = shortBitsToFloat16(order[i+j]).intValue();\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    if (mask[j % SPECIES.length()])\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n+                    else\n+                         AssertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            if (mask[j % SPECIES.length()])\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                AssertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a) {\n+        int i = 0;\n+        for (; i < a.length; i += SPECIES.length()) {\n+            int idx = i;\n+            for (int j = idx; j < (idx + SPECIES.length()); j++)\n+                a[j]=a[idx];\n+        }\n+\n+        try {\n+            for (i = 0; i < a.length; i++) {\n+                AssertEquals(r[i], a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FBinOp {\n+        short apply(short a, short b);\n+    }\n+\n+    interface FBinMaskOp {\n+        short apply(short a, short b, boolean m);\n+\n+        static FBinMaskOp lift(FBinOp f) {\n+            return (a, b, m) -> m ? f.apply(a, b) : a;\n+        }\n+    }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                AssertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                AssertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertShiftArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FBinConstOp {\n+        short apply(short a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        short apply(short a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FTernOp {\n+        short apply(short a, short b, short c);\n+    }\n+\n+    interface FTernMaskOp {\n+        short apply(short a, short b, short c, boolean m);\n+\n+        static FTernMaskOp lift(FTernOp f) {\n+            return (a, b, c, m) -> m ? f.apply(a, b, c) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernOp f) {\n+        assertArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+              + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[(i \/ SPECIES.length()) * SPECIES.length()] + \",  input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[i] + \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i]\n+                                + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernOp f) {\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]), \"at index #\"\n+                                + i + \", input1 = \" + a[i] + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+\n+    static boolean isWithin1Ulp(short actual, short expected) {\n+        Float16 act = shortBitsToFloat16(actual);\n+        Float16 exp = shortBitsToFloat16(expected);\n+        if (Float16.isNaN(exp) && !Float16.isNaN(act)) {\n+            return false;\n+        } else if (!Float16.isNaN(exp) && Float16.isNaN(act)) {\n+             return false;\n+        }\n+\n+        Float16 low = Float16.nextDown(exp);\n+        Float16 high = Float16.nextUp(exp);\n+\n+        if (Float16.compare(low, exp) > 0) {\n+            return false;\n+        }\n+\n+        if (Float16.compare(high, exp) < 0) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, FUnOp mathf, FUnOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]), shortBitsToFloat16(mathf.apply(a[i]))) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]), shortBitsToFloat16(mathf.apply(a[i]))) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i])), \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i]));\n+        }\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b, FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]), shortBitsToFloat16(mathf.apply(a[i], b[i]))) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]), shortBitsToFloat16(mathf.apply(a[i], b[i]))) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i], b[i]));\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b,\n+                                                        FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]),\n+                                  shortBitsToFloat16(mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]))) == 0 ||\n+                                  isWithin1Ulp(r[i],\n+                                  strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]),\n+                              shortBitsToFloat16(mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]))) == 0,\n+                              \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                              b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                              \", expected = \" + mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            Assert.assertTrue(isWithin1Ulp(r[i],\n+                              strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                             \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                             \", expected (within 1 ulp) = \" + strictmathf.apply(a[i],\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+        }\n+    }\n+\n+    interface FGatherScatterOp {\n+        short[] apply(short[] a, int ix, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, FGatherScatterOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherMaskedOp {\n+        short[] apply(short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    interface FScatterMaskedOp {\n+        short[] apply(short[] r, short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FGatherMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FScatterMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(r, a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(r, a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", r: \"\n+              + Arrays.toString(Arrays.copyOfRange(r, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneOp {\n+        short[] apply(short[] a, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int origin, FLaneOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneBop {\n+        short[] apply(short[] a, short[] b, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, FLaneBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLaneMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, boolean[] mask, FLaneMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLanePartBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, FLanePartBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    interface FLanePartMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, boolean[] mask, FLanePartMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    static short genValue(int i) {\n+        return float16ToShortBits(Float16.valueOf(i));\n+    }\n+\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> INT_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Float16[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(int[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                AssertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static short genValue(long i) {\n+        return float16ToShortBits(Float16.valueOf(i));\n+    }\n+\n+    static final List<IntFunction<short[]>> LONG_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Float16[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(long[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                AssertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(double[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                AssertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static short bits(short e) {\n+        return e;\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Float16[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> Float.floatToFloat16((0.01f + ((float)i \/ (i + 1)))));\n+            }),\n+            withToString(\"Float16[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01f + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (i % 17 == 0) ? cornerCaseValue(i) : Float.floatToFloat16((0.01f + ((float)i \/ (i + 1)))));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    \/\/ Create combinations of pairs\n+    \/\/ @@@ Might be sensitive to order e.g. div by 0\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_PAIRS =\n+        Stream.of(HALFFLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> HALFFLOAT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] boolUnaryOpProvider() {\n+        return BOOL_ARRAY_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> HALFFLOAT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"short[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortIndexedOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortSelectFromTwoVectorOpProvider() {\n+        return HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_TRIPLES.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoIntUnaryOpProvider() {\n+        return INT_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoLongUnaryOpProvider() {\n+        return LONG_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<BiFunction<Integer,Integer,short[]>> HALFFLOAT_SHUFFLE_GENERATORS = List.of(\n+            withToStringBi(\"shuffle[random]\", (Integer l, Integer m) -> {\n+                short[] a = new short[l];\n+                int upper = m;\n+                for (int i = 0; i < 1; i++) {\n+                    a[i] = (short)RAND.nextInt(upper);\n+                }\n+                return a;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromProvider() {\n+        return HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_COMPARE_GENERATORS = List.of(\n+            withToString(\"short[i]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)i);\n+            }),\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i + 1));\n+            }),\n+            withToString(\"short[i - 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - 2));\n+            }),\n+            withToString(\"short[zigZag(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i%3 == 0 ? (short)i : (i%3 == 1 ? (short)(i + 1) : (short)(i - 2)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_TEST_GENERATOR_ARGS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                map(fa -> List.of(fa)).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortTestOpProvider() {\n+        return HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_COMPARE_GENERATOR_PAIRS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                flatMap(fa -> HALFFLOAT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpProvider() {\n+        return HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    static short cornerCaseValue(int i) {\n+        return switch(i % 8) {\n+            case 0  -> float16ToShortBits(Float16.MAX_VALUE);\n+            case 1  -> float16ToShortBits(Float16.MIN_VALUE);\n+            case 2  -> float16ToShortBits(Float16.NEGATIVE_INFINITY);\n+            case 3  -> float16ToShortBits(Float16.POSITIVE_INFINITY);\n+            case 4  -> float16ToShortBits(Float16.NaN);\n+            case 5  -> float16ToShortBits(shortBitsToFloat16((short)0x7FFA));\n+            case 6  -> ((short)0.0);\n+            default -> ((short)-0.0);\n+        };\n+    }\n+\n+    static final IntFunction<short[]> fr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new short[length];\n+    };\n+\n+    static final IntFunction<boolean[]> fmr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new boolean[length];\n+    };\n+\n+    static final IntFunction<long[]> lfr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new long[length];\n+    };\n+\n+    static boolean eq(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() == bt.floatValue();\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() != bt.floatValue();\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() < bt.floatValue();\n+    }\n+\n+    static boolean le(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() <= bt.floatValue();\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() > bt.floatValue();\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() >= bt.floatValue();\n+    }\n+\n+    static short firstNonZero(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        Float16 zero = shortBitsToFloat16((short)0);\n+        return Float16.compare(at, zero) != 0 ? a : b;\n+    }\n+\n+    static short multiplicativeIdentity() {\n+        return (short)float16ToShortBits(Float16.valueOf(1.0f));\n+    }\n+\n+    static short scalar_add(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.add(at, bt));\n+    }\n+\n+    static short scalar_sub(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.subtract(at, bt));\n+    }\n+\n+    static short scalar_mul(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.multiply(at, bt));\n+\n+    }\n+    static short scalar_max(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.max(at, bt));\n+    }\n+\n+    static short scalar_min(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.min(at, bt));\n+    }\n+\n+    static short scalar_div(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.divide(at, bt));\n+    }\n+\n+    static short scalar_fma(short a, short b, short c) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        Float16 ct = shortBitsToFloat16(c);\n+        return float16ToShortBits(Float16.fma(at, bt, ct));\n+    }\n+\n+    static short scalar_abs(short a) {\n+        Float16 at = shortBitsToFloat16(a);\n+        return float16ToShortBits(Float16.abs(at));\n+    }\n+\n+    static short scalar_neg(short a) {\n+        Float16 at = shortBitsToFloat16(a);\n+        return float16ToShortBits(Float16.valueOf(-at.floatValue()));\n+    }\n+\n+    static short scalar_sin(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.sin(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_exp(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.exp(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_log1p(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.log1p(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_log(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.log(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_log10(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.log10(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_expm1(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.expm1(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_cos(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.cos(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_tan(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.tan(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_sinh(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.sinh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_cosh(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.cosh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_tanh(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.tanh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_asin(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.asin(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_acos(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.acos(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_atan(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.atan(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_cbrt(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.cbrt(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_sqrt(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.sqrt(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_hypot(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(Math.hypot(shortBitsToFloat16(a).doubleValue(),\n+                                                                     shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static short scalar_pow(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(Math.pow(shortBitsToFloat16(a).doubleValue(),\n+                                                                   shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static short scalar_atan2(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(Math.atan2(shortBitsToFloat16(a).doubleValue(),\n+                                                                     shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static short strict_scalar_sin(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.sin(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_exp(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.exp(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_log1p(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.log1p(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_log(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.log(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_log10(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.log10(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_expm1(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.expm1(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_cos(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.cos(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_tan(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.tan(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_sinh(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.sinh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_cosh(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.cosh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_tanh(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.tanh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_asin(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.asin(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_acos(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.acos(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_atan(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.atan(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_cbrt(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.cbrt(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_sqrt(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.sqrt(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_hypot(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.hypot(shortBitsToFloat16(a).doubleValue(),\n+                                                                     shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static short strict_scalar_pow(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.pow(shortBitsToFloat16(a).doubleValue(),\n+                                                                   shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static short strict_scalar_atan2(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.atan2(shortBitsToFloat16(a).doubleValue(),\n+                                                                     shortBitsToFloat16(b).doubleValue())));\n+    }\n+    static short additiveIdentity() {\n+        return (short)0;\n+    }\n+\n+\n+    static short zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static short maxValue() {\n+        return float16ToShortBits(Float16.POSITIVE_INFINITY);\n+    }\n+\n+    static short minValue() {\n+        return float16ToShortBits(Float16.NEGATIVE_INFINITY);\n+    }\n+\n+    static boolean isNaN(short a) {\n+        return Float16.isNaN(shortBitsToFloat16(a));\n+    }\n+    static boolean isFinite(short a) {\n+        return Float16.isFinite(shortBitsToFloat16(a));\n+    }\n+    static boolean isInfinite(short a) {\n+        return Float16.isInfinite(shortBitsToFloat16(a));\n+    }\n+\n+    @Test\n+    static void smokeTest1() {\n+        HalffloatVector three = HalffloatVector.broadcast(SPECIES, float16ToShortBits(Float16.valueOf(-3)));\n+        HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(float16ToShortBits(Float16.valueOf(-3)));\n+        assert(three.eq(three2).allTrue());\n+        HalffloatVector three3 = three2.broadcast(float16ToShortBits(Float16.valueOf(1))).broadcast(float16ToShortBits(Float16.valueOf(-3)));\n+        assert(three.eq(three3).allTrue());\n+        int scale = 2;\n+        HalffloatVector higher = three.addIndex(scale);\n+        VectorMask<Float16> m = three.compare(VectorOperators.LE, higher);\n+        assert(m.allTrue());\n+        m = higher.min((float16ToShortBits(Float16.valueOf(-1)))).test(VectorOperators.IS_NEGATIVE);\n+        assert(m.allTrue());\n+        m = higher.test(VectorOperators.IS_FINITE);\n+        assert(m.allTrue());\n+        short max = higher.reduceLanes(VectorOperators.MAX);\n+        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));\n+    }\n+\n+    private static short[]\n+    bothToArray(HalffloatVector a, HalffloatVector b) {\n+        short[] r = new short[a.length() + b.length()];\n+        a.intoArray(r, 0);\n+        b.intoArray(r, a.length());\n+        return r;\n+    }\n+\n+    @Test\n+    static void smokeTest2() {\n+        \/\/ Do some zipping and shuffling.\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES,0,1,false).toVector();\n+        AssertEquals(io, io2);\n+        HalffloatVector a = io.add((short)1); \/\/[1,2]\n+        HalffloatVector b = a.neg();  \/\/[-1,-2]\n+        short[] abValues = bothToArray(a,b); \/\/[1,2,-1,-2]\n+        VectorShuffle<Float16> zip0 = VectorShuffle.makeZip(SPECIES, 0);\n+        VectorShuffle<Float16> zip1 = VectorShuffle.makeZip(SPECIES, 1);\n+        HalffloatVector zab0 = a.rearrange(zip0,b); \/\/[1,-1]\n+        HalffloatVector zab1 = a.rearrange(zip1,b); \/\/[2,-2]\n+        short[] zabValues = bothToArray(zab0, zab1); \/\/[1,-1,2,-2]\n+        \/\/ manually zip\n+        short[] manual = new short[zabValues.length];\n+        for (int i = 0; i < manual.length; i += 2) {\n+            manual[i+0] = abValues[i\/2];\n+            manual[i+1] = abValues[a.length() + i\/2];\n+        }\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        VectorShuffle<Float16> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);\n+        VectorShuffle<Float16> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);\n+        HalffloatVector uab0 = zab0.rearrange(unz0,zab1);\n+        HalffloatVector uab1 = zab0.rearrange(unz1,zab1);\n+        short[] abValues1 = bothToArray(uab0, uab1);\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+    }\n+\n+    static void iotaShuffle() {\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES, 0 , 1, false).toVector();\n+        AssertEquals(io, io2);\n+    }\n+\n+    @Test\n+    \/\/ Test all shuffle related operations.\n+    static void shuffleTest() {\n+        \/\/ To test backend instructions, make sure that C2 is used.\n+        for (int loop = 0; loop < INVOC_COUNT * INVOC_COUNT; loop++) {\n+            iotaShuffle();\n+        }\n+    }\n+\n+    @Test\n+    void viewAsIntegeralLanesTest() {\n+        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();\n+        VectorSpecies<?> asIntegralSpecies = asIntegral.species();\n+        Assert.assertNotEquals(asIntegralSpecies.elementType(), SPECIES.elementType());\n+        AssertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        AssertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+    }\n+\n+    @Test\n+    void viewAsFloatingLanesTest() {\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        AssertEquals(asFloating.species(), SPECIES);\n+    }\n+\n+    static short ADD(short a, short b) {\n+        return (short)(scalar_add(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::ADD);\n+    }\n+\n+    static short add(short a, short b) {\n+        return (short)(scalar_add(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void addHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.add(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::add);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void addHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.add(bv, vmask).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::add);\n+    }\n+\n+    static short SUB(short a, short b) {\n+        return (short)(scalar_sub(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void SUBHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::SUB);\n+    }\n+\n+    static short sub(short a, short b) {\n+        return (short)(scalar_sub(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void subHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.sub(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::sub);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void SUBHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::SUB);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void subHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.sub(bv, vmask).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::sub);\n+    }\n+\n+    static short MUL(short a, short b) {\n+        return (short)(scalar_mul(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MULHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::MUL);\n+    }\n+\n+    static short mul(short a, short b) {\n+        return (short)(scalar_mul(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void mulHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.mul(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::mul);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MULHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::MUL);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void mulHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.mul(bv, vmask).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::mul);\n+    }\n+\n+    static short DIV(short a, short b) {\n+        return (short)(scalar_div(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void DIVHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::DIV);\n+    }\n+\n+    static short div(short a, short b) {\n+        return (short)(scalar_div(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void divHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.div(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::div);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void DIVHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::DIV);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void divHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.div(bv, vmask).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::div);\n+    }\n+\n+    static short FIRST_NONZERO(short a, short b) {\n+        return (short)(firstNonZero(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void FIRST_NONZEROHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::FIRST_NONZERO);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void FIRST_NONZEROHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::FIRST_NONZERO);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void addHalffloat64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.add(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat64VectorTests::add);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void addHalffloat64VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.add(b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, Halffloat64VectorTests::add);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void subHalffloat64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.sub(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat64VectorTests::sub);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void subHalffloat64VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.sub(b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, Halffloat64VectorTests::sub);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void mulHalffloat64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.mul(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat64VectorTests::mul);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void mulHalffloat64VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.mul(b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, Halffloat64VectorTests::mul);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void divHalffloat64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.div(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat64VectorTests::div);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void divHalffloat64VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.div(b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, Halffloat64VectorTests::div);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDHalffloat64VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(r, a, b, Halffloat64VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDHalffloat64VectorTestsBroadcastMaskedLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(r, a, b, mask, Halffloat64VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINHalffloat64VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Halffloat64VectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void minHalffloat64VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.min(bcast_vec).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Halffloat64VectorTests::min);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MINHalffloat64VectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, Halffloat64VectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXHalffloat64VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Halffloat64VectorTests::MAX);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void maxHalffloat64VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.max(bcast_vec).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Halffloat64VectorTests::max);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MAXHalffloat64VectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, Halffloat64VectorTests::MAX);\n+    }\n+\n+    static short MIN(short a, short b) {\n+        return (short)(scalar_min(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MINHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::MIN);\n+    }\n+\n+    static short min(short a, short b) {\n+        return (short)(scalar_min(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void minHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.min(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::min);\n+    }\n+\n+    static short MAX(short a, short b) {\n+        return (short)(scalar_max(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MAXHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::MAX);\n+    }\n+\n+    static short max(short a, short b) {\n+        return (short)(scalar_max(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void maxHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.max(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::max);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MINHalffloat64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.MIN, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat64VectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void minHalffloat64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.min(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat64VectorTests::min);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MAXHalffloat64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.MAX, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat64VectorTests::MAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void maxHalffloat64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.max(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, Halffloat64VectorTests::max);\n+    }\n+\n+    static short ADDReduce(short[] a, int idx) {\n+        short res = additiveIdentity();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = scalar_add(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short ADDReduceAll(short[] a) {\n+        short res = additiveIdentity();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_add(res, ADDReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = additiveIdentity();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = additiveIdentity();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Halffloat64VectorTests::ADDReduce, Halffloat64VectorTests::ADDReduceAll, RELATIVE_ROUNDING_ERROR_FACTOR_ADD);\n+    }\n+\n+    static short ADDReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = additiveIdentity();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = scalar_add(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short ADDReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = additiveIdentity();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ADDReduceHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = additiveIdentity();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = additiveIdentity();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat64VectorTests::ADDReduceMasked, Halffloat64VectorTests::ADDReduceAllMasked, RELATIVE_ROUNDING_ERROR_FACTOR_ADD);\n+    }\n+\n+    static short MULReduce(short[] a, int idx) {\n+        short res = multiplicativeIdentity();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = scalar_mul(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MULReduceAll(short[] a) {\n+        short res = multiplicativeIdentity();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_mul(res, MULReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MULReduceHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = multiplicativeIdentity();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = multiplicativeIdentity();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Halffloat64VectorTests::MULReduce, Halffloat64VectorTests::MULReduceAll, RELATIVE_ROUNDING_ERROR_FACTOR_MUL);\n+    }\n+\n+    static short MULReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = multiplicativeIdentity();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = scalar_mul(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MULReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = multiplicativeIdentity();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MULReduceHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = multiplicativeIdentity();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = multiplicativeIdentity();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat64VectorTests::MULReduceMasked, Halffloat64VectorTests::MULReduceAllMasked, RELATIVE_ROUNDING_ERROR_FACTOR_MUL);\n+    }\n+\n+    static short MINReduce(short[] a, int idx) {\n+        short res = maxValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = scalar_min(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MINReduceAll(short[] a) {\n+        short res = maxValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_min(res, MINReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINReduceHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = maxValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MIN);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = maxValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Halffloat64VectorTests::MINReduce, Halffloat64VectorTests::MINReduceAll);\n+    }\n+\n+    static short MINReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = maxValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = scalar_min(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MINReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = maxValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MINReduceHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = maxValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = maxValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat64VectorTests::MINReduceMasked, Halffloat64VectorTests::MINReduceAllMasked);\n+    }\n+\n+    static short MAXReduce(short[] a, int idx) {\n+        short res = minValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = scalar_max(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MAXReduceAll(short[] a) {\n+        short res = minValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_max(res, MAXReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXReduceHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = minValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MAX);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = minValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Halffloat64VectorTests::MAXReduce, Halffloat64VectorTests::MAXReduceAll);\n+    }\n+\n+    static short MAXReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = minValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = scalar_max(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MAXReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = minValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MAXReduceHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = minValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = minValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat64VectorTests::MAXReduceMasked, Halffloat64VectorTests::MAXReduceAllMasked);\n+    }\n+\n+    static short FIRST_NONZEROReduce(short[] a, int idx) {\n+        short res = zeroValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short FIRST_NONZEROReduceAll(short[] a) {\n+        short res = zeroValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = zeroValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = zeroValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Halffloat64VectorTests::FIRST_NONZEROReduce, Halffloat64VectorTests::FIRST_NONZEROReduceAll);\n+    }\n+\n+    static short FIRST_NONZEROReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = zeroValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short FIRST_NONZEROReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = zeroValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = zeroValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = zeroValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat64VectorTests::FIRST_NONZEROReduceMasked, Halffloat64VectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void withHalffloat64VectorTests(IntFunction<short []> fa, IntFunction<short []> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+\n+        assertArraysStrictlyEquals(r, a);\n+    }\n+\n+    static boolean testIS_DEFAULT(short a) {\n+        return bits(a)==0;\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpProvider\")\n+    static void IS_DEFAULTHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_DEFAULT);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedHalffloat64VectorTests(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    static boolean testIS_NEGATIVE(short a) {\n+        return bits(a)<0;\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpProvider\")\n+    static void IS_NEGATIVEHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_NEGATIVE);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedHalffloat64VectorTests(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    static boolean testIS_FINITE(short a) {\n+        return isFinite(a);\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpProvider\")\n+    static void IS_FINITEHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_FINITE);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), testIS_FINITE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_FINITEMaskedHalffloat64VectorTests(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    static boolean testIS_NAN(short a) {\n+        return isNaN(a);\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpProvider\")\n+    static void IS_NANHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_NAN);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), testIS_NAN(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_NANMaskedHalffloat64VectorTests(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_NAN, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    static boolean testIS_INFINITE(short a) {\n+        return isInfinite(a);\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpProvider\")\n+    static void IS_INFINITEHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_INFINITE);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), testIS_INFINITE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_INFINITEMaskedHalffloat64VectorTests(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void LTHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.lt(bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void LTHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void GTHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void GTHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void EQHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.EQ, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.eq(bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void EQHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.EQ, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void NEHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.NE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void NEHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.NE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void LEHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void LEHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void GEHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void GEHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void LTHalffloat64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.LT, b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void LTHalffloat64VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa,\n+                                IntFunction<short[]> fb, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.LT, b[i], vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void LTHalffloat64VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.LT, (long)b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (short)((long)b[i])));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void LTHalffloat64VectorTestsBroadcastLongMaskedSmokeTest(IntFunction<short[]> fa,\n+                                IntFunction<short[]> fb, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.LT, (long)b[i], vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(short)((long)b[i]))));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void EQHalffloat64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.EQ, b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void EQHalffloat64VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa,\n+                                IntFunction<short[]> fb, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.EQ, b[i], vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void EQHalffloat64VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.EQ, (long)b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (short)((long)b[i])));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void EQHalffloat64VectorTestsBroadcastLongMaskedSmokeTest(IntFunction<short[]> fa,\n+                                IntFunction<short[]> fb, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.EQ, (long)b[i], vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(short)((long)b[i]))));\n+            }\n+        }\n+    }\n+\n+    static short blend(short a, short b, boolean mask) {\n+        return mask ? b : a;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::blend);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpShuffleProvider\")\n+    static void RearrangeHalffloat64VectorTests(IntFunction<short[]> fa,\n+                                           BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        assertRearrangeArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpShuffleMaskProvider\")\n+    static void RearrangeHalffloat64VectorTestsMaskedSmokeTest(IntFunction<short[]> fa,\n+                                                          BiFunction<Integer,Integer,int[]> fs,\n+                                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.rearrange(VectorShuffle.fromArray(SPECIES, order, i), vmask).intoArray(r, i);\n+        }\n+\n+        assertRearrangeArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void compressHalffloat64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void expandHalffloat64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void getHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        assertArraysStrictlyEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void BroadcastHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ZeroHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        AssertEquals(a, r);\n+    }\n+\n+    static short[] sliceUnary(short[] a, int origin, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0; i < SPECIES.length(); i++){\n+            if(i+origin < SPECIES.length())\n+                res[i] = a[idx+i+origin];\n+            else\n+                res[i] = (short)0;\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void sliceUnaryHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, origin, Halffloat64VectorTests::sliceUnary);\n+    }\n+\n+    static short[] sliceBinary(short[] a, short[] b, int origin, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if(i+origin < SPECIES.length())\n+                res[i] = a[idx+i+origin];\n+            else {\n+                res[i] = b[idx+j];\n+                j++;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void sliceBinaryHalffloat64VectorTestsBinary(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, origin, Halffloat64VectorTests::sliceBinary);\n+    }\n+\n+    static short[] slice(short[] a, short[] b, int origin, boolean[] mask, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if(i+origin < SPECIES.length())\n+                res[i] = mask[i] ? a[idx+i+origin] : (short)0;\n+            else {\n+                res[i] = mask[i] ? b[idx+j] : (short)0;\n+                j++;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void sliceHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, origin, mask, Halffloat64VectorTests::slice);\n+    }\n+\n+    static short[] unsliceUnary(short[] a, int origin, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if(i < origin)\n+                res[i] = (short)0;\n+            else {\n+                res[i] = a[idx+j];\n+                j++;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void unsliceUnaryHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, origin, Halffloat64VectorTests::unsliceUnary);\n+    }\n+\n+    static short[] unsliceBinary(short[] a, short[] b, int origin, int part, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if (part == 0) {\n+                if (i < origin)\n+                    res[i] = b[idx+i];\n+                else {\n+                    res[i] = a[idx+j];\n+                    j++;\n+                }\n+            } else if (part == 1) {\n+                if (i < origin)\n+                    res[i] = a[idx+SPECIES.length()-origin+i];\n+                else {\n+                    res[i] = b[idx+origin+j];\n+                    j++;\n+                }\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void unsliceBinaryHalffloat64VectorTestsBinary(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, origin, part, Halffloat64VectorTests::unsliceBinary);\n+    }\n+\n+    static short[] unslice(short[] a, short[] b, int origin, int part, boolean[] mask, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if(i+origin < SPECIES.length())\n+                res[i] = b[idx+i+origin];\n+            else {\n+                res[i] = b[idx+j];\n+                j++;\n+            }\n+        }\n+        for (int i = 0; i < SPECIES.length(); i++){\n+            res[i] = mask[i] ? a[idx+i] : res[i];\n+        }\n+        short[] res1 = new short[SPECIES.length()];\n+        if (part == 0) {\n+            for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+                if (i < origin)\n+                    res1[i] = b[idx+i];\n+                else {\n+                   res1[i] = res[j];\n+                   j++;\n+                }\n+            }\n+        } else if (part == 1) {\n+            for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+                if (i < origin)\n+                    res1[i] = res[SPECIES.length()-origin+i];\n+                else {\n+                    res1[i] = b[idx+origin+j];\n+                    j++;\n+                }\n+            }\n+        }\n+        return res1;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void unsliceHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, origin, part, mask, Halffloat64VectorTests::unslice);\n+    }\n+\n+    static short SIN(short a) {\n+        return (short)(scalar_sin(a));\n+    }\n+\n+    static short strictSIN(short a) {\n+        return (short)(strict_scalar_sin(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::SIN, Halffloat64VectorTests::strictSIN);\n+    }\n+\n+    static short EXP(short a) {\n+        return (short)(scalar_exp(a));\n+    }\n+\n+    static short strictEXP(short a) {\n+        return (short)(strict_scalar_exp(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::EXP, Halffloat64VectorTests::strictEXP);\n+    }\n+\n+    static short LOG1P(short a) {\n+        return (short)(scalar_log1p(a));\n+    }\n+\n+    static short strictLOG1P(short a) {\n+        return (short)(strict_scalar_log1p(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG1PHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::LOG1P, Halffloat64VectorTests::strictLOG1P);\n+    }\n+\n+    static short LOG(short a) {\n+        return (short)(scalar_log(a));\n+    }\n+\n+    static short strictLOG(short a) {\n+        return (short)(strict_scalar_log(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOGHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::LOG, Halffloat64VectorTests::strictLOG);\n+    }\n+\n+    static short LOG10(short a) {\n+        return (short)(scalar_log10(a));\n+    }\n+\n+    static short strictLOG10(short a) {\n+        return (short)(strict_scalar_log10(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG10Halffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::LOG10, Halffloat64VectorTests::strictLOG10);\n+    }\n+\n+    static short EXPM1(short a) {\n+        return (short)(scalar_expm1(a));\n+    }\n+\n+    static short strictEXPM1(short a) {\n+        return (short)(strict_scalar_expm1(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPM1Halffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::EXPM1, Halffloat64VectorTests::strictEXPM1);\n+    }\n+\n+    static short COS(short a) {\n+        return (short)(scalar_cos(a));\n+    }\n+\n+    static short strictCOS(short a) {\n+        return (short)(strict_scalar_cos(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::COS, Halffloat64VectorTests::strictCOS);\n+    }\n+\n+    static short TAN(short a) {\n+        return (short)(scalar_tan(a));\n+    }\n+\n+    static short strictTAN(short a) {\n+        return (short)(strict_scalar_tan(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::TAN, Halffloat64VectorTests::strictTAN);\n+    }\n+\n+    static short SINH(short a) {\n+        return (short)(scalar_sinh(a));\n+    }\n+\n+    static short strictSINH(short a) {\n+        return (short)(strict_scalar_sinh(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::SINH, Halffloat64VectorTests::strictSINH);\n+    }\n+\n+    static short COSH(short a) {\n+        return (short)(scalar_cosh(a));\n+    }\n+\n+    static short strictCOSH(short a) {\n+        return (short)(strict_scalar_cosh(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::COSH, Halffloat64VectorTests::strictCOSH);\n+    }\n+\n+    static short TANH(short a) {\n+        return (short)(scalar_tanh(a));\n+    }\n+\n+    static short strictTANH(short a) {\n+        return (short)(strict_scalar_tanh(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::TANH, Halffloat64VectorTests::strictTANH);\n+    }\n+\n+    static short ASIN(short a) {\n+        return (short)(scalar_asin(a));\n+    }\n+\n+    static short strictASIN(short a) {\n+        return (short)(strict_scalar_asin(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ASINHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::ASIN, Halffloat64VectorTests::strictASIN);\n+    }\n+\n+    static short ACOS(short a) {\n+        return (short)(scalar_acos(a));\n+    }\n+\n+    static short strictACOS(short a) {\n+        return (short)(strict_scalar_acos(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ACOSHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::ACOS, Halffloat64VectorTests::strictACOS);\n+    }\n+\n+    static short ATAN(short a) {\n+        return (short)(scalar_atan(a));\n+    }\n+\n+    static short strictATAN(short a) {\n+        return (short)(strict_scalar_atan(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ATANHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::ATAN, Halffloat64VectorTests::strictATAN);\n+    }\n+\n+    static short CBRT(short a) {\n+        return (short)(scalar_cbrt(a));\n+    }\n+\n+    static short strictCBRT(short a) {\n+        return (short)(strict_scalar_cbrt(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CBRTHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::CBRT, Halffloat64VectorTests::strictCBRT);\n+    }\n+\n+    static short HYPOT(short a, short b) {\n+        return (short)(scalar_hypot(a, b));\n+    }\n+\n+    static short strictHYPOT(short a, short b) {\n+        return (short)(strict_scalar_hypot(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void HYPOTHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::HYPOT, Halffloat64VectorTests::strictHYPOT);\n+    }\n+\n+\n+    static short POW(short a, short b) {\n+        return (short)(scalar_pow(a, b));\n+    }\n+\n+    static short strictPOW(short a, short b) {\n+        return (short)(strict_scalar_pow(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::POW, Halffloat64VectorTests::strictPOW);\n+    }\n+\n+\n+    static short pow(short a, short b) {\n+        return (short)(scalar_pow(a, b));\n+    }\n+\n+    static short strictpow(short a, short b) {\n+        return (short)(strict_scalar_pow(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.pow(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::pow, Halffloat64VectorTests::strictpow);\n+    }\n+\n+\n+    static short ATAN2(short a, short b) {\n+        return (short)(scalar_atan2(a, b));\n+    }\n+\n+    static short strictATAN2(short a, short b) {\n+        return (short)(strict_scalar_atan2(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ATAN2Halffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::ATAN2, Halffloat64VectorTests::strictATAN2);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.POW, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::POW, Halffloat64VectorTests::strictPOW);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.pow(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::pow, Halffloat64VectorTests::strictpow);\n+    }\n+\n+\n+    static short FMA(short a, short b, short c) {\n+        return (short)(scalar_fma(a, b, c));\n+    }\n+\n+    static short fma(short a, short b, short c) {\n+        return (short)(scalar_fma(a, b, c));\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat64VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void fmaHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.fma(bv, cv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat64VectorTests::fma);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, mask, Halffloat64VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.lanewise(VectorOperators.FMA, bv, c[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a, b, c, Halffloat64VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat64VectorTestsAltBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.lanewise(VectorOperators.FMA, b[i], cv).intoArray(r, i);\n+        }\n+        assertAltBroadcastArraysEquals(r, a, b, c, Halffloat64VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat64VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.lanewise(VectorOperators.FMA, bv, c[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, c, mask, Halffloat64VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat64VectorTestsAltBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.lanewise(VectorOperators.FMA, b[i], cv, vmask).intoArray(r, i);\n+        }\n+\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, Halffloat64VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat64VectorTestsDoubleBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.FMA, b[i], c[i]).intoArray(r, i);\n+        }\n+\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, Halffloat64VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void fmaHalffloat64VectorTestsDoubleBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.fma(b[i], c[i]).intoArray(r, i);\n+        }\n+\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, Halffloat64VectorTests::fma);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat64VectorTestsDoubleBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.FMA, b[i], c[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, Halffloat64VectorTests::FMA);\n+    }\n+\n+    static short NEG(short a) {\n+        return (short)(scalar_neg((short)a));\n+    }\n+\n+    static short neg(short a) {\n+        return (short)(scalar_neg((short)a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void NEGHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat64VectorTests::NEG);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void negHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.neg().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat64VectorTests::neg);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void NEGMaskedHalffloat64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat64VectorTests::NEG);\n+    }\n+\n+    static short ABS(short a) {\n+        return (short)(scalar_abs((short)a));\n+    }\n+\n+    static short abs(short a) {\n+        return (short)(scalar_abs((short)a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ABSHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat64VectorTests::ABS);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void absHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.abs().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat64VectorTests::abs);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ABSMaskedHalffloat64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat64VectorTests::ABS);\n+    }\n+\n+    static short SQRT(short a) {\n+        return (short)(scalar_sqrt(a));\n+    }\n+\n+    static short sqrt(short a) {\n+        return (short)(scalar_sqrt(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SQRTHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat64VectorTests::SQRT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void sqrtHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.sqrt().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat64VectorTests::sqrt);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void SQRTMaskedHalffloat64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat64VectorTests::SQRT);\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltHalffloat64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqHalffloat64VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoIntUnaryOpProvider\")\n+    static void toIntArrayHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int[] r = av.toIntArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void toLongArrayHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            long[] r = av.toLongArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toDoubleArrayHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            double[] r = av.toDoubleArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toStringHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void hashCodeHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n+    static long ADDReduceLong(short[] a, int idx) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLong(short[] a) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = Float.floatToFloat16(Float.float16ToFloat((short)res) + Float.float16ToFloat((short)ADDReduceLong(a, i)));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceLongHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            ra = (long)(Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16((short)ra), Float16.shortBitsToFloat16((short)r[i]))));\n+        }\n+\n+        assertReductionLongArraysEquals(r, ra, a,\n+                Halffloat64VectorTests::ADDReduceLong, Halffloat64VectorTests::ADDReduceAllLong);\n+    }\n+\n+    static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if(mask[i % SPECIES.length()])\n+                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = Float.floatToFloat16(Float.float16ToFloat((short)res) + Float.float16ToFloat((short)ADDReduceLongMasked(a, i, mask)));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ADDReduceLongHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            ra = (long)(Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16((short)ra), Float16.shortBitsToFloat16((short)r[i]))));\n+        }\n+\n+        assertReductionLongArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat64VectorTests::ADDReduceLongMasked, Halffloat64VectorTests::ADDReduceAllLongMasked);\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void BroadcastLongHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat64VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(r, a, b, mask, Halffloat64VectorTests::blend);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromProvider\")\n+    static void SelectFromHalffloat64VectorTests(IntFunction<short[]> fa,\n+                                           BiFunction<Integer,Integer,short[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] idx = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector idxv = HalffloatVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromMaskProvider\")\n+    static void SelectFromHalffloat64VectorTestsMaskedSmokeTest(IntFunction<short[]> fa,\n+                                                           BiFunction<Integer,Integer,short[]> fs,\n+                                                           IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av, vmask).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousHalffloat64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            AssertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringHalffloat64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsHalffloat64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    static int maskTrueCount(boolean[] a, int idx) {\n+        int trueCount = 0;\n+        for (int i = idx; i < idx + SPECIES.length(); i++) {\n+            trueCount += a[i] ? 1 : 0;\n+        }\n+        return trueCount;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.trueCount();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat64VectorTests::maskTrueCount);\n+    }\n+\n+    static int maskLastTrue(boolean[] a, int idx) {\n+        int i = idx + SPECIES.length() - 1;\n+        for (; i >= idx; i--) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.lastTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat64VectorTests::maskLastTrue);\n+    }\n+\n+    static int maskFirstTrue(boolean[] a, int idx) {\n+        int i = idx;\n+        for (; i < idx + SPECIES.length(); i++) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskFirstTrueHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.firstTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat64VectorTests::maskFirstTrue);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongHalffloat64VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeHalffloat64VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongHalffloat64VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundHalffloat64VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongHalffloat64VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test\n+    static void ElementSizeHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        int elsize = av.elementSize();\n+        AssertEquals(elsize, Float16.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorShapeHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        assert(vsh.equals(VectorShape.S_64_BIT));\n+    }\n+\n+    @Test\n+    static void ShapeWithLanesHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(Float16.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void HalffloatHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementType() == Float16.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Float16.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(Float16.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void MaskAllTrueHalffloat64VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat64VectorTests.java","additions":5740,"deletions":0,"binary":false,"changes":5740,"status":"added"},{"patch":"@@ -0,0 +1,1023 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @run testng\/othervm --add-opens jdk.incubator.vector\/jdk.incubator.vector=ALL-UNNAMED\n+ *      -XX:-TieredCompilation HalffloatMaxVectorLoadStoreTests\n+ *\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.ValueLayout;\n+import jdk.incubator.vector.Float16;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.internal.vm.annotation.DontInline;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.ByteOrder;\n+import java.util.List;\n+import java.util.function.*;\n+\n+@Test\n+public class HalffloatMaxVectorLoadStoreTests extends AbstractVectorLoadStoreTest {\n+    static final VectorSpecies<Float16> SPECIES =\n+                HalffloatVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n+\n+    static VectorShape getMaxBit() {\n+        return VectorShape.S_Max_BIT;\n+    }\n+\n+    private static final int Max = 256;  \/\/ juts so we can do N\/Max\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ Max);\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0, \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            })\n+    );\n+\n+    \/\/ Relative to array.length\n+    static final List<IntFunction<Integer>> INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl + 1\", (int l) -> {\n+                return l - SPECIES.length() + 1;\n+            }),\n+            withToString(\"l + speciesl - 1\", (int l) -> {\n+                return l + SPECIES.length() - 1;\n+            }),\n+            withToString(\"l + speciesl\", (int l) -> {\n+                return l + SPECIES.length();\n+            }),\n+            withToString(\"l + speciesl + 1\", (int l) -> {\n+                return l + SPECIES.length() + 1;\n+            })\n+    );\n+\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n+    static final List<IntFunction<Integer>> BYTE_INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl*ebsize + 1\", (int l) -> {\n+                return l - SPECIES.vectorByteSize() + 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize - 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() - 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize\", (int l) -> {\n+                return l + SPECIES.vectorByteSize();\n+            }),\n+            withToString(\"l + speciesl*ebsize + 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() + 1;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ELEMENT_LAYOUT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ELEMENT_LAYOUT);\n+    }\n+\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static VectorShuffle<Float16> shuffleFromArray(int[] a, int i) {\n+        return SPECIES.shuffleFromArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void shuffleIntoArray(VectorShuffle<Float16> s, int[] a, int i) {\n+        s.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static VectorShuffle<Float16> shuffleFromMemorySegment(MemorySegment mem, int i, ByteOrder bo) {\n+        return VectorShuffle.fromMemorySegment(SPECIES, mem, i, bo);\n+    }\n+\n+    @DontInline\n+    static void shuffleIntoMemorySegment(VectorShuffle<Float16> s, MemorySegment mem, int i, ByteOrder bo) {\n+        s.intoMemorySegment(mem, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i) {\n+        \/\/ Tests the species method and the equivalent vector method it defers to\n+        return (HalffloatVector) SPECIES.fromArray(a, i);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i, VectorMask<Float16> m) {\n+        return HalffloatVector.fromArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i) {\n+        v.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Float16> m) {\n+        v.intoArray(a, i, m);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        \/\/ Tests the species method and the equivalent vector method it defers to\n+        return (HalffloatVector) SPECIES.fromMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n+\n+    @Test(dataProvider = \"shortProvider\")\n+    static void loadStoreArray(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void loadArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void storeArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMaskArray(IntFunction<short[]> fa,\n+                                   IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void loadArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void storeArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMask(IntFunction<short[]> fa,\n+                              IntFunction<boolean[]> fm) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[mask.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, mask);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        short[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Float16> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Float16> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+\n+   @Test(dataProvider = \"shuffleIntProvider\")\n+   static void loadStoreShuffleArray(IntFunction<int[]> fa) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+               shuffle.intoArray(r, i);\n+           }\n+       }\n+\n+       for (int i = 0; i < a.length; i++) {\n+          Assert.assertEquals(testPartiallyWrapIndex(SPECIES, a[i]), r[i]);\n+       }\n+\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntProviderForIOOBE\")\n+   static void storeShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);\n+               shuffleIntoArray(shuffle, r, i);\n+           }\n+       }\n+\n+       int index = fi.apply(a.length);\n+       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+       try {\n+           VectorShuffle<Float16> shuffle = shuffleFromArray(a, index);\n+           shuffleIntoArray(shuffle, r, index);\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntProviderForIOOBE\")\n+   static void loadShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);\n+               shuffle.intoArray(r, i);\n+           }\n+       }\n+\n+       int index = fi.apply(a.length);\n+       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+       try {\n+           shuffleFromArray(a, index);\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntMemorySegmentProvider\")\n+   static void loadStoreShuffleMemorySegment(IntFunction<int[]> fa,\n+                                      IntFunction<MemorySegment> fb,\n+                                      ByteOrder bo) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), fb);\n+       MemorySegment r = fb.apply((int) a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4; \/\/An integer for every lane is read out. So 4 bytes per lane\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle = VectorShuffle.fromMemorySegment(SPECIES, a, i, bo);\n+               shuffle.intoMemorySegment(r, i, bo);\n+           }\n+       }\n+\n+       for (int i = 0; i < l \/ 4; i++) {\n+           int ai = a.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);\n+           int ri = r.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);\n+           Assert.assertEquals(testPartiallyWrapIndex(SPECIES, ai), ri);\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntByteProviderForIOOBE\")\n+   static void shuffleLoadMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));\n+       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4;\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle = shuffleFromMemorySegment(a, i, ByteOrder.nativeOrder());\n+               shuffle.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+           }\n+       }\n+\n+       int index = fi.apply((int) a.byteSize());\n+       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());\n+       try {\n+           shuffleFromMemorySegment(a, index, ByteOrder.nativeOrder());\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntByteProviderForIOOBE\")\n+   static void shuffleStoreMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));\n+       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4;\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle =\n+                       VectorShuffle.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+               shuffleIntoMemorySegment(shuffle, r, i, ByteOrder.nativeOrder());\n+           }\n+       }\n+\n+       int index = fi.apply((int) a.byteSize());\n+       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());\n+       try {\n+           VectorShuffle<Float16> shuffle =\n+                   VectorShuffle.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+           shuffleIntoMemorySegment(shuffle, r, index, ByteOrder.nativeOrder());\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/HalffloatMaxVectorLoadStoreTests.java","additions":1023,"deletions":0,"binary":false,"changes":1023,"status":"added"},{"patch":"@@ -0,0 +1,5729 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.vector\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation HalffloatMaxVectorTests\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.Vector;\n+\n+import jdk.incubator.vector.Float16;\n+import static jdk.incubator.vector.Float16.*;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.Integer;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Test\n+public class HalffloatMaxVectorTests extends AbstractVectorTest {\n+\n+    static final VectorSpecies<Float16> SPECIES =\n+                HalffloatVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+    static HalffloatVector bcast_vec = HalffloatVector.broadcast(SPECIES, (short)10);\n+\n+    static void AssertEquals(short actual, short expected) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected));\n+    }\n+    static void AssertEquals(short actual, short expected, String msg) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected), msg);\n+    }\n+    static void AssertEquals(short actual, short expected, short delta) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected), Float.float16ToFloat((short)delta));\n+    }\n+    static void AssertEquals(short actual, short expected, short delta, String msg) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected), Float.float16ToFloat((short)delta), msg);\n+    }\n+    static void AssertEquals(short [] actual, short [] expected) {\n+        Assert.assertEquals(actual.length, expected.length);\n+        for (int i = 0; i < actual.length; i++) {\n+            Assert.assertEquals(Float.float16ToFloat((short)actual[i]), Float.float16ToFloat((short)expected[i]));\n+        }\n+    }\n+    static void AssertEquals(short [] actual, short [] expected, String msg) {\n+        Assert.assertEquals(actual.length, expected.length);\n+        for (int i = 0; i < actual.length; i++) {\n+            Assert.assertEquals(Float.float16ToFloat((short)actual[i]), Float.float16ToFloat((short)expected[i]), msg);\n+        }\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected));\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected), msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n+    static VectorShape getMaxBit() {\n+        return VectorShape.S_Max_BIT;\n+    }\n+\n+    private static final int Max = 256;  \/\/ juts so we can do N\/Max\n+\n+    \/\/ for floating point addition reduction ops that may introduce rounding errors\n+    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_ADD = (short)10.0;\n+\n+    \/\/ for floating point multiplication reduction ops that may introduce rounding errors\n+    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_MUL = (short)50.0;\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ Max);\n+\n+    static void assertArraysStrictlyEquals(short[] r, short[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            short ir = r[i];\n+            short ia = a[i];\n+            if (ir != ia) {\n+                Assert.fail(String.format(\"at index #%d, expected = %016X, actual = %016X\", i, ia, ir));\n+            }\n+        }\n+    }\n+\n+    interface FUnOp {\n+        short apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FUnArrayOp {\n+        short[] apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a[i]);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    interface FReductionOp {\n+        short apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOp {\n+        short apply(short[] a);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa) {\n+        assertReductionArraysEquals(r, rc, a, f, fa, (short)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            short relativeErrorFactor) {\n+        int i = 0;\n+        try {\n+            AssertEquals(rc, fa.apply(a), float16ToShortBits(Float16.multiply(Float16.ulp(shortBitsToFloat16(rc)), shortBitsToFloat16(relativeErrorFactor))));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i), float16ToShortBits(Float16.multiply(Float16.ulp(shortBitsToFloat16(r[i])), shortBitsToFloat16(relativeErrorFactor))));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rc, fa.apply(a), float16ToShortBits(Float16.multiply(Float16.ulp(shortBitsToFloat16(rc)), shortBitsToFloat16(relativeErrorFactor))), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), float16ToShortBits(Float16.multiply(Float16.ulp(shortBitsToFloat16(r[i])), shortBitsToFloat16(relativeErrorFactor))), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOp {\n+        short apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOp {\n+        short apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa) {\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (short)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            short relativeError) {\n+        int i = 0;\n+        try {\n+            AssertEquals(rc, fa.apply(a, mask), float16ToShortBits(Float16.abs(Float16.multiply(shortBitsToFloat16(rc), shortBitsToFloat16(relativeError)))));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i, mask), float16ToShortBits(Float16.abs(Float16.multiply(shortBitsToFloat16(r[i]), shortBitsToFloat16(relativeError)))));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rc, fa.apply(a, mask), float16ToShortBits(Float16.abs(Float16.multiply(shortBitsToFloat16(rc), shortBitsToFloat16(relativeError)))), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), float16ToShortBits(Float16.abs(Float16.multiply(shortBitsToFloat16(r[i]), shortBitsToFloat16(relativeError)))), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionOpLong {\n+        long apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOpLong {\n+        long apply(short[] a);\n+    }\n+\n+    static void assertReductionLongArraysEquals(long[] r, long rc, short[] a,\n+                                            FReductionOpLong f, FReductionAllOpLong fa) {\n+        int i = 0;\n+        try {\n+            AssertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOpLong {\n+        long apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOpLong {\n+        long apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionLongArraysEqualsMasked(long[] r, long rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOpLong f, FReductionAllMaskedOpLong fa) {\n+        int i = 0;\n+        try {\n+            AssertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolReductionOp {\n+        boolean apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertReductionBoolArraysEquals(boolean[] r, boolean[] a, FBoolReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FMaskReductionOp {\n+        int apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertMaskReductionArraysEquals(int[] r, boolean[] a, FMaskReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        AssertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    AssertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                AssertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        AssertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        AssertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                AssertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod(shortBitsToFloat16(order[idx]).intValue(), 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        int idx = 0, wrapped_index = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = shortBitsToFloat16(order[i+j]).intValue();\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n+                    else\n+                         AssertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                AssertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        int idx = 0, wrapped_index = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = shortBitsToFloat16(order[i+j]).intValue();\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    if (mask[j % SPECIES.length()])\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n+                    else\n+                         AssertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            if (mask[j % SPECIES.length()])\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                AssertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a) {\n+        int i = 0;\n+        for (; i < a.length; i += SPECIES.length()) {\n+            int idx = i;\n+            for (int j = idx; j < (idx + SPECIES.length()); j++)\n+                a[j]=a[idx];\n+        }\n+\n+        try {\n+            for (i = 0; i < a.length; i++) {\n+                AssertEquals(r[i], a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FBinOp {\n+        short apply(short a, short b);\n+    }\n+\n+    interface FBinMaskOp {\n+        short apply(short a, short b, boolean m);\n+\n+        static FBinMaskOp lift(FBinOp f) {\n+            return (a, b, m) -> m ? f.apply(a, b) : a;\n+        }\n+    }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                AssertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                AssertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertShiftArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FBinConstOp {\n+        short apply(short a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        short apply(short a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FTernOp {\n+        short apply(short a, short b, short c);\n+    }\n+\n+    interface FTernMaskOp {\n+        short apply(short a, short b, short c, boolean m);\n+\n+        static FTernMaskOp lift(FTernOp f) {\n+            return (a, b, c, m) -> m ? f.apply(a, b, c) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernOp f) {\n+        assertArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+              + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[(i \/ SPECIES.length()) * SPECIES.length()] + \",  input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[i] + \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i]\n+                                + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernOp f) {\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]), \"at index #\"\n+                                + i + \", input1 = \" + a[i] + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+\n+    static boolean isWithin1Ulp(short actual, short expected) {\n+        Float16 act = shortBitsToFloat16(actual);\n+        Float16 exp = shortBitsToFloat16(expected);\n+        if (Float16.isNaN(exp) && !Float16.isNaN(act)) {\n+            return false;\n+        } else if (!Float16.isNaN(exp) && Float16.isNaN(act)) {\n+             return false;\n+        }\n+\n+        Float16 low = Float16.nextDown(exp);\n+        Float16 high = Float16.nextUp(exp);\n+\n+        if (Float16.compare(low, exp) > 0) {\n+            return false;\n+        }\n+\n+        if (Float16.compare(high, exp) < 0) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, FUnOp mathf, FUnOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]), shortBitsToFloat16(mathf.apply(a[i]))) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]), shortBitsToFloat16(mathf.apply(a[i]))) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i])), \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i]));\n+        }\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b, FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]), shortBitsToFloat16(mathf.apply(a[i], b[i]))) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]), shortBitsToFloat16(mathf.apply(a[i], b[i]))) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i], b[i]));\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b,\n+                                                        FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]),\n+                                  shortBitsToFloat16(mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]))) == 0 ||\n+                                  isWithin1Ulp(r[i],\n+                                  strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(shortBitsToFloat16(r[i]),\n+                              shortBitsToFloat16(mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]))) == 0,\n+                              \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                              b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                              \", expected = \" + mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            Assert.assertTrue(isWithin1Ulp(r[i],\n+                              strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                             \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                             \", expected (within 1 ulp) = \" + strictmathf.apply(a[i],\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+        }\n+    }\n+\n+    interface FGatherScatterOp {\n+        short[] apply(short[] a, int ix, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, FGatherScatterOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherMaskedOp {\n+        short[] apply(short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    interface FScatterMaskedOp {\n+        short[] apply(short[] r, short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FGatherMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FScatterMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(r, a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(r, a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", r: \"\n+              + Arrays.toString(Arrays.copyOfRange(r, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneOp {\n+        short[] apply(short[] a, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int origin, FLaneOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneBop {\n+        short[] apply(short[] a, short[] b, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, FLaneBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLaneMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, boolean[] mask, FLaneMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLanePartBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, FLanePartBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    interface FLanePartMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, boolean[] mask, FLanePartMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    static short genValue(int i) {\n+        return float16ToShortBits(Float16.valueOf(i));\n+    }\n+\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> INT_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Float16[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(int[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                AssertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static short genValue(long i) {\n+        return float16ToShortBits(Float16.valueOf(i));\n+    }\n+\n+    static final List<IntFunction<short[]>> LONG_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Float16[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(long[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                AssertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(double[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                AssertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static short bits(short e) {\n+        return e;\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Float16[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> Float.floatToFloat16((0.01f + ((float)i \/ (i + 1)))));\n+            }),\n+            withToString(\"Float16[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01f + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (i % 17 == 0) ? cornerCaseValue(i) : Float.floatToFloat16((0.01f + ((float)i \/ (i + 1)))));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    \/\/ Create combinations of pairs\n+    \/\/ @@@ Might be sensitive to order e.g. div by 0\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_PAIRS =\n+        Stream.of(HALFFLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> HALFFLOAT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] boolUnaryOpProvider() {\n+        return BOOL_ARRAY_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> HALFFLOAT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"short[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortIndexedOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortSelectFromTwoVectorOpProvider() {\n+        return HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_TRIPLES.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoIntUnaryOpProvider() {\n+        return INT_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoLongUnaryOpProvider() {\n+        return LONG_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<BiFunction<Integer,Integer,short[]>> HALFFLOAT_SHUFFLE_GENERATORS = List.of(\n+            withToStringBi(\"shuffle[random]\", (Integer l, Integer m) -> {\n+                short[] a = new short[l];\n+                int upper = m;\n+                for (int i = 0; i < 1; i++) {\n+                    a[i] = (short)RAND.nextInt(upper);\n+                }\n+                return a;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromProvider() {\n+        return HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_COMPARE_GENERATORS = List.of(\n+            withToString(\"short[i]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)i);\n+            }),\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i + 1));\n+            }),\n+            withToString(\"short[i - 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - 2));\n+            }),\n+            withToString(\"short[zigZag(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i%3 == 0 ? (short)i : (i%3 == 1 ? (short)(i + 1) : (short)(i - 2)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_TEST_GENERATOR_ARGS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                map(fa -> List.of(fa)).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortTestOpProvider() {\n+        return HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_COMPARE_GENERATOR_PAIRS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                flatMap(fa -> HALFFLOAT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpProvider() {\n+        return HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    static short cornerCaseValue(int i) {\n+        return switch(i % 8) {\n+            case 0  -> float16ToShortBits(Float16.MAX_VALUE);\n+            case 1  -> float16ToShortBits(Float16.MIN_VALUE);\n+            case 2  -> float16ToShortBits(Float16.NEGATIVE_INFINITY);\n+            case 3  -> float16ToShortBits(Float16.POSITIVE_INFINITY);\n+            case 4  -> float16ToShortBits(Float16.NaN);\n+            case 5  -> float16ToShortBits(shortBitsToFloat16((short)0x7FFA));\n+            case 6  -> ((short)0.0);\n+            default -> ((short)-0.0);\n+        };\n+    }\n+\n+    static final IntFunction<short[]> fr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new short[length];\n+    };\n+\n+    static final IntFunction<boolean[]> fmr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new boolean[length];\n+    };\n+\n+    static final IntFunction<long[]> lfr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new long[length];\n+    };\n+\n+    static boolean eq(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() == bt.floatValue();\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() != bt.floatValue();\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() < bt.floatValue();\n+    }\n+\n+    static boolean le(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() <= bt.floatValue();\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() > bt.floatValue();\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() >= bt.floatValue();\n+    }\n+\n+    static short firstNonZero(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        Float16 zero = shortBitsToFloat16((short)0);\n+        return Float16.compare(at, zero) != 0 ? a : b;\n+    }\n+\n+    static short multiplicativeIdentity() {\n+        return (short)float16ToShortBits(Float16.valueOf(1.0f));\n+    }\n+\n+    static short scalar_add(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.add(at, bt));\n+    }\n+\n+    static short scalar_sub(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.subtract(at, bt));\n+    }\n+\n+    static short scalar_mul(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.multiply(at, bt));\n+\n+    }\n+    static short scalar_max(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.max(at, bt));\n+    }\n+\n+    static short scalar_min(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.min(at, bt));\n+    }\n+\n+    static short scalar_div(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.divide(at, bt));\n+    }\n+\n+    static short scalar_fma(short a, short b, short c) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        Float16 ct = shortBitsToFloat16(c);\n+        return float16ToShortBits(Float16.fma(at, bt, ct));\n+    }\n+\n+    static short scalar_abs(short a) {\n+        Float16 at = shortBitsToFloat16(a);\n+        return float16ToShortBits(Float16.abs(at));\n+    }\n+\n+    static short scalar_neg(short a) {\n+        Float16 at = shortBitsToFloat16(a);\n+        return float16ToShortBits(Float16.valueOf(-at.floatValue()));\n+    }\n+\n+    static short scalar_sin(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.sin(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_exp(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.exp(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_log1p(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.log1p(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_log(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.log(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_log10(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.log10(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_expm1(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.expm1(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_cos(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.cos(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_tan(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.tan(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_sinh(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.sinh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_cosh(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.cosh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_tanh(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.tanh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_asin(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.asin(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_acos(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.acos(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_atan(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.atan(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_cbrt(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.cbrt(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_sqrt(short a) {\n+        return float16ToShortBits(Float16.valueOf(Math.sqrt(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short scalar_hypot(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(Math.hypot(shortBitsToFloat16(a).doubleValue(),\n+                                                                     shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static short scalar_pow(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(Math.pow(shortBitsToFloat16(a).doubleValue(),\n+                                                                   shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static short scalar_atan2(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(Math.atan2(shortBitsToFloat16(a).doubleValue(),\n+                                                                     shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static short strict_scalar_sin(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.sin(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_exp(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.exp(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_log1p(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.log1p(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_log(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.log(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_log10(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.log10(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_expm1(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.expm1(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_cos(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.cos(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_tan(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.tan(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_sinh(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.sinh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_cosh(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.cosh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_tanh(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.tanh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_asin(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.asin(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_acos(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.acos(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_atan(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.atan(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_cbrt(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.cbrt(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_sqrt(short a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.sqrt(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static short strict_scalar_hypot(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.hypot(shortBitsToFloat16(a).doubleValue(),\n+                                                                     shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static short strict_scalar_pow(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.pow(shortBitsToFloat16(a).doubleValue(),\n+                                                                   shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static short strict_scalar_atan2(short a, short b) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.atan2(shortBitsToFloat16(a).doubleValue(),\n+                                                                     shortBitsToFloat16(b).doubleValue())));\n+    }\n+    static short additiveIdentity() {\n+        return (short)0;\n+    }\n+\n+\n+    static short zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static short maxValue() {\n+        return float16ToShortBits(Float16.POSITIVE_INFINITY);\n+    }\n+\n+    static short minValue() {\n+        return float16ToShortBits(Float16.NEGATIVE_INFINITY);\n+    }\n+\n+    static boolean isNaN(short a) {\n+        return Float16.isNaN(shortBitsToFloat16(a));\n+    }\n+    static boolean isFinite(short a) {\n+        return Float16.isFinite(shortBitsToFloat16(a));\n+    }\n+    static boolean isInfinite(short a) {\n+        return Float16.isInfinite(shortBitsToFloat16(a));\n+    }\n+\n+    @Test\n+    static void smokeTest1() {\n+        HalffloatVector three = HalffloatVector.broadcast(SPECIES, float16ToShortBits(Float16.valueOf(-3)));\n+        HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(float16ToShortBits(Float16.valueOf(-3)));\n+        assert(three.eq(three2).allTrue());\n+        HalffloatVector three3 = three2.broadcast(float16ToShortBits(Float16.valueOf(1))).broadcast(float16ToShortBits(Float16.valueOf(-3)));\n+        assert(three.eq(three3).allTrue());\n+        int scale = 2;\n+        HalffloatVector higher = three.addIndex(scale);\n+        VectorMask<Float16> m = three.compare(VectorOperators.LE, higher);\n+        assert(m.allTrue());\n+        m = higher.min((float16ToShortBits(Float16.valueOf(-1)))).test(VectorOperators.IS_NEGATIVE);\n+        assert(m.allTrue());\n+        m = higher.test(VectorOperators.IS_FINITE);\n+        assert(m.allTrue());\n+        short max = higher.reduceLanes(VectorOperators.MAX);\n+        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));\n+    }\n+\n+    private static short[]\n+    bothToArray(HalffloatVector a, HalffloatVector b) {\n+        short[] r = new short[a.length() + b.length()];\n+        a.intoArray(r, 0);\n+        b.intoArray(r, a.length());\n+        return r;\n+    }\n+\n+    @Test\n+    static void smokeTest2() {\n+        \/\/ Do some zipping and shuffling.\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES,0,1,false).toVector();\n+        AssertEquals(io, io2);\n+        HalffloatVector a = io.add((short)1); \/\/[1,2]\n+        HalffloatVector b = a.neg();  \/\/[-1,-2]\n+        short[] abValues = bothToArray(a,b); \/\/[1,2,-1,-2]\n+        VectorShuffle<Float16> zip0 = VectorShuffle.makeZip(SPECIES, 0);\n+        VectorShuffle<Float16> zip1 = VectorShuffle.makeZip(SPECIES, 1);\n+        HalffloatVector zab0 = a.rearrange(zip0,b); \/\/[1,-1]\n+        HalffloatVector zab1 = a.rearrange(zip1,b); \/\/[2,-2]\n+        short[] zabValues = bothToArray(zab0, zab1); \/\/[1,-1,2,-2]\n+        \/\/ manually zip\n+        short[] manual = new short[zabValues.length];\n+        for (int i = 0; i < manual.length; i += 2) {\n+            manual[i+0] = abValues[i\/2];\n+            manual[i+1] = abValues[a.length() + i\/2];\n+        }\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        VectorShuffle<Float16> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);\n+        VectorShuffle<Float16> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);\n+        HalffloatVector uab0 = zab0.rearrange(unz0,zab1);\n+        HalffloatVector uab1 = zab0.rearrange(unz1,zab1);\n+        short[] abValues1 = bothToArray(uab0, uab1);\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+    }\n+\n+    static void iotaShuffle() {\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES, 0 , 1, false).toVector();\n+        AssertEquals(io, io2);\n+    }\n+\n+    @Test\n+    \/\/ Test all shuffle related operations.\n+    static void shuffleTest() {\n+        \/\/ To test backend instructions, make sure that C2 is used.\n+        for (int loop = 0; loop < INVOC_COUNT * INVOC_COUNT; loop++) {\n+            iotaShuffle();\n+        }\n+    }\n+\n+    @Test\n+    void viewAsIntegeralLanesTest() {\n+        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();\n+        VectorSpecies<?> asIntegralSpecies = asIntegral.species();\n+        Assert.assertNotEquals(asIntegralSpecies.elementType(), SPECIES.elementType());\n+        AssertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        AssertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+    }\n+\n+    @Test\n+    void viewAsFloatingLanesTest() {\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        AssertEquals(asFloating.species(), SPECIES);\n+    }\n+\n+    static short ADD(short a, short b) {\n+        return (short)(scalar_add(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::ADD);\n+    }\n+\n+    static short add(short a, short b) {\n+        return (short)(scalar_add(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void addHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.add(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::add);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void addHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.add(bv, vmask).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::add);\n+    }\n+\n+    static short SUB(short a, short b) {\n+        return (short)(scalar_sub(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void SUBHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::SUB);\n+    }\n+\n+    static short sub(short a, short b) {\n+        return (short)(scalar_sub(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void subHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.sub(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::sub);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void SUBHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::SUB);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void subHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.sub(bv, vmask).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::sub);\n+    }\n+\n+    static short MUL(short a, short b) {\n+        return (short)(scalar_mul(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MULHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::MUL);\n+    }\n+\n+    static short mul(short a, short b) {\n+        return (short)(scalar_mul(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void mulHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.mul(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::mul);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MULHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::MUL);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void mulHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.mul(bv, vmask).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::mul);\n+    }\n+\n+    static short DIV(short a, short b) {\n+        return (short)(scalar_div(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void DIVHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::DIV);\n+    }\n+\n+    static short div(short a, short b) {\n+        return (short)(scalar_div(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void divHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.div(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::div);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void DIVHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::DIV);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void divHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.div(bv, vmask).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::div);\n+    }\n+\n+    static short FIRST_NONZERO(short a, short b) {\n+        return (short)(firstNonZero(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void FIRST_NONZEROHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::FIRST_NONZERO);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void FIRST_NONZEROHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::FIRST_NONZERO);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void addHalffloatMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.add(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, HalffloatMaxVectorTests::add);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void addHalffloatMaxVectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.add(b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::add);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void subHalffloatMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.sub(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, HalffloatMaxVectorTests::sub);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void subHalffloatMaxVectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.sub(b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::sub);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void mulHalffloatMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.mul(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, HalffloatMaxVectorTests::mul);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void mulHalffloatMaxVectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.mul(b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::mul);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void divHalffloatMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.div(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, HalffloatMaxVectorTests::div);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void divHalffloatMaxVectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.div(b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::div);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDHalffloatMaxVectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(r, a, b, HalffloatMaxVectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDHalffloatMaxVectorTestsBroadcastMaskedLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINHalffloatMaxVectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, HalffloatMaxVectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void minHalffloatMaxVectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.min(bcast_vec).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, HalffloatMaxVectorTests::min);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MINHalffloatMaxVectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, HalffloatMaxVectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXHalffloatMaxVectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, HalffloatMaxVectorTests::MAX);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void maxHalffloatMaxVectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.max(bcast_vec).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, HalffloatMaxVectorTests::max);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MAXHalffloatMaxVectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, HalffloatMaxVectorTests::MAX);\n+    }\n+\n+    static short MIN(short a, short b) {\n+        return (short)(scalar_min(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MINHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::MIN);\n+    }\n+\n+    static short min(short a, short b) {\n+        return (short)(scalar_min(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void minHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.min(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::min);\n+    }\n+\n+    static short MAX(short a, short b) {\n+        return (short)(scalar_max(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MAXHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::MAX);\n+    }\n+\n+    static short max(short a, short b) {\n+        return (short)(scalar_max(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void maxHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.max(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::max);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MINHalffloatMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.MIN, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, HalffloatMaxVectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void minHalffloatMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.min(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, HalffloatMaxVectorTests::min);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MAXHalffloatMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.MAX, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, HalffloatMaxVectorTests::MAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void maxHalffloatMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.max(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, HalffloatMaxVectorTests::max);\n+    }\n+\n+    static short ADDReduce(short[] a, int idx) {\n+        short res = additiveIdentity();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = scalar_add(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short ADDReduceAll(short[] a) {\n+        short res = additiveIdentity();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_add(res, ADDReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = additiveIdentity();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = additiveIdentity();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                HalffloatMaxVectorTests::ADDReduce, HalffloatMaxVectorTests::ADDReduceAll, RELATIVE_ROUNDING_ERROR_FACTOR_ADD);\n+    }\n+\n+    static short ADDReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = additiveIdentity();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = scalar_add(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short ADDReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = additiveIdentity();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ADDReduceHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = additiveIdentity();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = additiveIdentity();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                HalffloatMaxVectorTests::ADDReduceMasked, HalffloatMaxVectorTests::ADDReduceAllMasked, RELATIVE_ROUNDING_ERROR_FACTOR_ADD);\n+    }\n+\n+    static short MULReduce(short[] a, int idx) {\n+        short res = multiplicativeIdentity();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = scalar_mul(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MULReduceAll(short[] a) {\n+        short res = multiplicativeIdentity();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_mul(res, MULReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MULReduceHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = multiplicativeIdentity();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = multiplicativeIdentity();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                HalffloatMaxVectorTests::MULReduce, HalffloatMaxVectorTests::MULReduceAll, RELATIVE_ROUNDING_ERROR_FACTOR_MUL);\n+    }\n+\n+    static short MULReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = multiplicativeIdentity();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = scalar_mul(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MULReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = multiplicativeIdentity();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MULReduceHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = multiplicativeIdentity();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = multiplicativeIdentity();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                HalffloatMaxVectorTests::MULReduceMasked, HalffloatMaxVectorTests::MULReduceAllMasked, RELATIVE_ROUNDING_ERROR_FACTOR_MUL);\n+    }\n+\n+    static short MINReduce(short[] a, int idx) {\n+        short res = maxValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = scalar_min(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MINReduceAll(short[] a) {\n+        short res = maxValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_min(res, MINReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINReduceHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = maxValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MIN);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = maxValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                HalffloatMaxVectorTests::MINReduce, HalffloatMaxVectorTests::MINReduceAll);\n+    }\n+\n+    static short MINReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = maxValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = scalar_min(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MINReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = maxValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MINReduceHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = maxValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = maxValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                HalffloatMaxVectorTests::MINReduceMasked, HalffloatMaxVectorTests::MINReduceAllMasked);\n+    }\n+\n+    static short MAXReduce(short[] a, int idx) {\n+        short res = minValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = scalar_max(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MAXReduceAll(short[] a) {\n+        short res = minValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_max(res, MAXReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXReduceHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = minValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MAX);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = minValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                HalffloatMaxVectorTests::MAXReduce, HalffloatMaxVectorTests::MAXReduceAll);\n+    }\n+\n+    static short MAXReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = minValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = scalar_max(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short MAXReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = minValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MAXReduceHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = minValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = minValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                HalffloatMaxVectorTests::MAXReduceMasked, HalffloatMaxVectorTests::MAXReduceAllMasked);\n+    }\n+\n+    static short FIRST_NONZEROReduce(short[] a, int idx) {\n+        short res = zeroValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short FIRST_NONZEROReduceAll(short[] a) {\n+        short res = zeroValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = zeroValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = zeroValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                HalffloatMaxVectorTests::FIRST_NONZEROReduce, HalffloatMaxVectorTests::FIRST_NONZEROReduceAll);\n+    }\n+\n+    static short FIRST_NONZEROReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = zeroValue();\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short FIRST_NONZEROReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = zeroValue();\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduceHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = zeroValue();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = zeroValue();\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                HalffloatMaxVectorTests::FIRST_NONZEROReduceMasked, HalffloatMaxVectorTests::FIRST_NONZEROReduceAllMasked);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void withHalffloatMaxVectorTests(IntFunction<short []> fa, IntFunction<short []> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+\n+        assertArraysStrictlyEquals(r, a);\n+    }\n+\n+    static boolean testIS_DEFAULT(short a) {\n+        return bits(a)==0;\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpProvider\")\n+    static void IS_DEFAULTHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_DEFAULT);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_DEFAULTMaskedHalffloatMaxVectorTests(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    static boolean testIS_NEGATIVE(short a) {\n+        return bits(a)<0;\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpProvider\")\n+    static void IS_NEGATIVEHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_NEGATIVE);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_NEGATIVEMaskedHalffloatMaxVectorTests(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    static boolean testIS_FINITE(short a) {\n+        return isFinite(a);\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpProvider\")\n+    static void IS_FINITEHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_FINITE);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), testIS_FINITE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_FINITEMaskedHalffloatMaxVectorTests(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    static boolean testIS_NAN(short a) {\n+        return isNaN(a);\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpProvider\")\n+    static void IS_NANHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_NAN);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), testIS_NAN(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_NANMaskedHalffloatMaxVectorTests(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_NAN, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    static boolean testIS_INFINITE(short a) {\n+        return isInfinite(a);\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpProvider\")\n+    static void IS_INFINITEHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_INFINITE);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), testIS_INFINITE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortTestOpMaskProvider\")\n+    static void IS_INFINITEMaskedHalffloatMaxVectorTests(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float16> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void LTHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.lt(bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void LTHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void GTHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void GTHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void EQHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.EQ, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.eq(bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void EQHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.EQ, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void NEHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.NE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void NEHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.NE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void LEHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void LEHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void GEHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void GEHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                VectorMask<Float16> mv = av.compare(VectorOperators.GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void LTHalffloatMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.LT, b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void LTHalffloatMaxVectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa,\n+                                IntFunction<short[]> fb, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.LT, b[i], vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void LTHalffloatMaxVectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.LT, (long)b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (short)((long)b[i])));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void LTHalffloatMaxVectorTestsBroadcastLongMaskedSmokeTest(IntFunction<short[]> fa,\n+                                IntFunction<short[]> fb, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.LT, (long)b[i], vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(short)((long)b[i]))));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void EQHalffloatMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.EQ, b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void EQHalffloatMaxVectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa,\n+                                IntFunction<short[]> fb, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.EQ, b[i], vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void EQHalffloatMaxVectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.EQ, (long)b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (short)((long)b[i])));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void EQHalffloatMaxVectorTestsBroadcastLongMaskedSmokeTest(IntFunction<short[]> fa,\n+                                IntFunction<short[]> fb, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.compare(VectorOperators.EQ, (long)b[i], vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(short)((long)b[i]))));\n+            }\n+        }\n+    }\n+\n+    static short blend(short a, short b, boolean mask) {\n+        return mask ? b : a;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::blend);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpShuffleProvider\")\n+    static void RearrangeHalffloatMaxVectorTests(IntFunction<short[]> fa,\n+                                           BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        assertRearrangeArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpShuffleMaskProvider\")\n+    static void RearrangeHalffloatMaxVectorTestsMaskedSmokeTest(IntFunction<short[]> fa,\n+                                                          BiFunction<Integer,Integer,int[]> fs,\n+                                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.rearrange(VectorShuffle.fromArray(SPECIES, order, i), vmask).intoArray(r, i);\n+        }\n+\n+        assertRearrangeArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void compressHalffloatMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void expandHalffloatMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void getHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        assertArraysStrictlyEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void BroadcastHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ZeroHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        AssertEquals(a, r);\n+    }\n+\n+    static short[] sliceUnary(short[] a, int origin, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0; i < SPECIES.length(); i++){\n+            if(i+origin < SPECIES.length())\n+                res[i] = a[idx+i+origin];\n+            else\n+                res[i] = (short)0;\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void sliceUnaryHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, origin, HalffloatMaxVectorTests::sliceUnary);\n+    }\n+\n+    static short[] sliceBinary(short[] a, short[] b, int origin, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if(i+origin < SPECIES.length())\n+                res[i] = a[idx+i+origin];\n+            else {\n+                res[i] = b[idx+j];\n+                j++;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void sliceBinaryHalffloatMaxVectorTestsBinary(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, origin, HalffloatMaxVectorTests::sliceBinary);\n+    }\n+\n+    static short[] slice(short[] a, short[] b, int origin, boolean[] mask, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if(i+origin < SPECIES.length())\n+                res[i] = mask[i] ? a[idx+i+origin] : (short)0;\n+            else {\n+                res[i] = mask[i] ? b[idx+j] : (short)0;\n+                j++;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void sliceHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, origin, mask, HalffloatMaxVectorTests::slice);\n+    }\n+\n+    static short[] unsliceUnary(short[] a, int origin, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if(i < origin)\n+                res[i] = (short)0;\n+            else {\n+                res[i] = a[idx+j];\n+                j++;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void unsliceUnaryHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, origin, HalffloatMaxVectorTests::unsliceUnary);\n+    }\n+\n+    static short[] unsliceBinary(short[] a, short[] b, int origin, int part, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if (part == 0) {\n+                if (i < origin)\n+                    res[i] = b[idx+i];\n+                else {\n+                    res[i] = a[idx+j];\n+                    j++;\n+                }\n+            } else if (part == 1) {\n+                if (i < origin)\n+                    res[i] = a[idx+SPECIES.length()-origin+i];\n+                else {\n+                    res[i] = b[idx+origin+j];\n+                    j++;\n+                }\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void unsliceBinaryHalffloatMaxVectorTestsBinary(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, origin, part, HalffloatMaxVectorTests::unsliceBinary);\n+    }\n+\n+    static short[] unslice(short[] a, short[] b, int origin, int part, boolean[] mask, int idx) {\n+        short[] res = new short[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if(i+origin < SPECIES.length())\n+                res[i] = b[idx+i+origin];\n+            else {\n+                res[i] = b[idx+j];\n+                j++;\n+            }\n+        }\n+        for (int i = 0; i < SPECIES.length(); i++){\n+            res[i] = mask[i] ? a[idx+i] : res[i];\n+        }\n+        short[] res1 = new short[SPECIES.length()];\n+        if (part == 0) {\n+            for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+                if (i < origin)\n+                    res1[i] = b[idx+i];\n+                else {\n+                   res1[i] = res[j];\n+                   j++;\n+                }\n+            }\n+        } else if (part == 1) {\n+            for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+                if (i < origin)\n+                    res1[i] = res[SPECIES.length()-origin+i];\n+                else {\n+                    res1[i] = b[idx+origin+j];\n+                    j++;\n+                }\n+            }\n+        }\n+        return res1;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void unsliceHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, origin, part, mask, HalffloatMaxVectorTests::unslice);\n+    }\n+\n+    static short SIN(short a) {\n+        return (short)(scalar_sin(a));\n+    }\n+\n+    static short strictSIN(short a) {\n+        return (short)(strict_scalar_sin(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::SIN, HalffloatMaxVectorTests::strictSIN);\n+    }\n+\n+    static short EXP(short a) {\n+        return (short)(scalar_exp(a));\n+    }\n+\n+    static short strictEXP(short a) {\n+        return (short)(strict_scalar_exp(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::EXP, HalffloatMaxVectorTests::strictEXP);\n+    }\n+\n+    static short LOG1P(short a) {\n+        return (short)(scalar_log1p(a));\n+    }\n+\n+    static short strictLOG1P(short a) {\n+        return (short)(strict_scalar_log1p(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG1PHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::LOG1P, HalffloatMaxVectorTests::strictLOG1P);\n+    }\n+\n+    static short LOG(short a) {\n+        return (short)(scalar_log(a));\n+    }\n+\n+    static short strictLOG(short a) {\n+        return (short)(strict_scalar_log(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOGHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::LOG, HalffloatMaxVectorTests::strictLOG);\n+    }\n+\n+    static short LOG10(short a) {\n+        return (short)(scalar_log10(a));\n+    }\n+\n+    static short strictLOG10(short a) {\n+        return (short)(strict_scalar_log10(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG10HalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::LOG10, HalffloatMaxVectorTests::strictLOG10);\n+    }\n+\n+    static short EXPM1(short a) {\n+        return (short)(scalar_expm1(a));\n+    }\n+\n+    static short strictEXPM1(short a) {\n+        return (short)(strict_scalar_expm1(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPM1HalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::EXPM1, HalffloatMaxVectorTests::strictEXPM1);\n+    }\n+\n+    static short COS(short a) {\n+        return (short)(scalar_cos(a));\n+    }\n+\n+    static short strictCOS(short a) {\n+        return (short)(strict_scalar_cos(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::COS, HalffloatMaxVectorTests::strictCOS);\n+    }\n+\n+    static short TAN(short a) {\n+        return (short)(scalar_tan(a));\n+    }\n+\n+    static short strictTAN(short a) {\n+        return (short)(strict_scalar_tan(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::TAN, HalffloatMaxVectorTests::strictTAN);\n+    }\n+\n+    static short SINH(short a) {\n+        return (short)(scalar_sinh(a));\n+    }\n+\n+    static short strictSINH(short a) {\n+        return (short)(strict_scalar_sinh(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::SINH, HalffloatMaxVectorTests::strictSINH);\n+    }\n+\n+    static short COSH(short a) {\n+        return (short)(scalar_cosh(a));\n+    }\n+\n+    static short strictCOSH(short a) {\n+        return (short)(strict_scalar_cosh(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::COSH, HalffloatMaxVectorTests::strictCOSH);\n+    }\n+\n+    static short TANH(short a) {\n+        return (short)(scalar_tanh(a));\n+    }\n+\n+    static short strictTANH(short a) {\n+        return (short)(strict_scalar_tanh(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::TANH, HalffloatMaxVectorTests::strictTANH);\n+    }\n+\n+    static short ASIN(short a) {\n+        return (short)(scalar_asin(a));\n+    }\n+\n+    static short strictASIN(short a) {\n+        return (short)(strict_scalar_asin(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ASINHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::ASIN, HalffloatMaxVectorTests::strictASIN);\n+    }\n+\n+    static short ACOS(short a) {\n+        return (short)(scalar_acos(a));\n+    }\n+\n+    static short strictACOS(short a) {\n+        return (short)(strict_scalar_acos(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ACOSHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::ACOS, HalffloatMaxVectorTests::strictACOS);\n+    }\n+\n+    static short ATAN(short a) {\n+        return (short)(scalar_atan(a));\n+    }\n+\n+    static short strictATAN(short a) {\n+        return (short)(strict_scalar_atan(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ATANHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::ATAN, HalffloatMaxVectorTests::strictATAN);\n+    }\n+\n+    static short CBRT(short a) {\n+        return (short)(scalar_cbrt(a));\n+    }\n+\n+    static short strictCBRT(short a) {\n+        return (short)(strict_scalar_cbrt(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CBRTHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::CBRT, HalffloatMaxVectorTests::strictCBRT);\n+    }\n+\n+    static short HYPOT(short a, short b) {\n+        return (short)(scalar_hypot(a, b));\n+    }\n+\n+    static short strictHYPOT(short a, short b) {\n+        return (short)(strict_scalar_hypot(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void HYPOTHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::HYPOT, HalffloatMaxVectorTests::strictHYPOT);\n+    }\n+\n+\n+    static short POW(short a, short b) {\n+        return (short)(scalar_pow(a, b));\n+    }\n+\n+    static short strictPOW(short a, short b) {\n+        return (short)(strict_scalar_pow(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::POW, HalffloatMaxVectorTests::strictPOW);\n+    }\n+\n+\n+    static short pow(short a, short b) {\n+        return (short)(scalar_pow(a, b));\n+    }\n+\n+    static short strictpow(short a, short b) {\n+        return (short)(strict_scalar_pow(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.pow(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::pow, HalffloatMaxVectorTests::strictpow);\n+    }\n+\n+\n+    static short ATAN2(short a, short b) {\n+        return (short)(scalar_atan2(a, b));\n+    }\n+\n+    static short strictATAN2(short a, short b) {\n+        return (short)(strict_scalar_atan2(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ATAN2HalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::ATAN2, HalffloatMaxVectorTests::strictATAN2);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloatMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.POW, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::POW, HalffloatMaxVectorTests::strictPOW);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloatMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.pow(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::pow, HalffloatMaxVectorTests::strictpow);\n+    }\n+\n+\n+    static short FMA(short a, short b, short c) {\n+        return (short)(scalar_fma(a, b, c));\n+    }\n+\n+    static short fma(short a, short b, short c) {\n+        return (short)(scalar_fma(a, b, c));\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, HalffloatMaxVectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void fmaHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.fma(bv, cv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, c, HalffloatMaxVectorTests::fma);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, mask, HalffloatMaxVectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloatMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.lanewise(VectorOperators.FMA, bv, c[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a, b, c, HalffloatMaxVectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloatMaxVectorTestsAltBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.lanewise(VectorOperators.FMA, b[i], cv).intoArray(r, i);\n+        }\n+        assertAltBroadcastArraysEquals(r, a, b, c, HalffloatMaxVectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloatMaxVectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            av.lanewise(VectorOperators.FMA, bv, c[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, c, mask, HalffloatMaxVectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloatMaxVectorTestsAltBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.lanewise(VectorOperators.FMA, b[i], cv, vmask).intoArray(r, i);\n+        }\n+\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, HalffloatMaxVectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloatMaxVectorTestsDoubleBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.FMA, b[i], c[i]).intoArray(r, i);\n+        }\n+\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, HalffloatMaxVectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void fmaHalffloatMaxVectorTestsDoubleBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.fma(b[i], c[i]).intoArray(r, i);\n+        }\n+\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, HalffloatMaxVectorTests::fma);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloatMaxVectorTestsDoubleBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.FMA, b[i], c[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, HalffloatMaxVectorTests::FMA);\n+    }\n+\n+    static short NEG(short a) {\n+        return (short)(scalar_neg((short)a));\n+    }\n+\n+    static short neg(short a) {\n+        return (short)(scalar_neg((short)a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void NEGHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, HalffloatMaxVectorTests::NEG);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void negHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.neg().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, HalffloatMaxVectorTests::neg);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void NEGMaskedHalffloatMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, HalffloatMaxVectorTests::NEG);\n+    }\n+\n+    static short ABS(short a) {\n+        return (short)(scalar_abs((short)a));\n+    }\n+\n+    static short abs(short a) {\n+        return (short)(scalar_abs((short)a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ABSHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, HalffloatMaxVectorTests::ABS);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void absHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.abs().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, HalffloatMaxVectorTests::abs);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ABSMaskedHalffloatMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, HalffloatMaxVectorTests::ABS);\n+    }\n+\n+    static short SQRT(short a) {\n+        return (short)(scalar_sqrt(a));\n+    }\n+\n+    static short sqrt(short a) {\n+        return (short)(scalar_sqrt(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SQRTHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, HalffloatMaxVectorTests::SQRT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void sqrtHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.sqrt().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, HalffloatMaxVectorTests::sqrt);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void SQRTMaskedHalffloatMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, HalffloatMaxVectorTests::SQRT);\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltHalffloatMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqHalffloatMaxVectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoIntUnaryOpProvider\")\n+    static void toIntArrayHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int[] r = av.toIntArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void toLongArrayHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            long[] r = av.toLongArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toDoubleArrayHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            double[] r = av.toDoubleArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toStringHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void hashCodeHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n+    static long ADDReduceLong(short[] a, int idx) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLong(short[] a) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = Float.floatToFloat16(Float.float16ToFloat((short)res) + Float.float16ToFloat((short)ADDReduceLong(a, i)));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceLongHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            ra = (long)(Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16((short)ra), Float16.shortBitsToFloat16((short)r[i]))));\n+        }\n+\n+        assertReductionLongArraysEquals(r, ra, a,\n+                HalffloatMaxVectorTests::ADDReduceLong, HalffloatMaxVectorTests::ADDReduceAllLong);\n+    }\n+\n+    static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if(mask[i % SPECIES.length()])\n+                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = Float.floatToFloat16(Float.float16ToFloat((short)res) + Float.float16ToFloat((short)ADDReduceLongMasked(a, i, mask)));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ADDReduceLongHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            ra = (long)(Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16((short)ra), Float16.shortBitsToFloat16((short)r[i]))));\n+        }\n+\n+        assertReductionLongArraysEqualsMasked(r, ra, a, mask,\n+                HalffloatMaxVectorTests::ADDReduceLongMasked, HalffloatMaxVectorTests::ADDReduceAllLongMasked);\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void BroadcastLongHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloatMaxVectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::blend);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromProvider\")\n+    static void SelectFromHalffloatMaxVectorTests(IntFunction<short[]> fa,\n+                                           BiFunction<Integer,Integer,short[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] idx = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector idxv = HalffloatVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromMaskProvider\")\n+    static void SelectFromHalffloatMaxVectorTestsMaskedSmokeTest(IntFunction<short[]> fa,\n+                                                           BiFunction<Integer,Integer,short[]> fs,\n+                                                           IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av, vmask).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousHalffloatMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            AssertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringHalffloatMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsHalffloatMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    static int maskTrueCount(boolean[] a, int idx) {\n+        int trueCount = 0;\n+        for (int i = idx; i < idx + SPECIES.length(); i++) {\n+            trueCount += a[i] ? 1 : 0;\n+        }\n+        return trueCount;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.trueCount();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, HalffloatMaxVectorTests::maskTrueCount);\n+    }\n+\n+    static int maskLastTrue(boolean[] a, int idx) {\n+        int i = idx + SPECIES.length() - 1;\n+        for (; i >= idx; i--) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.lastTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, HalffloatMaxVectorTests::maskLastTrue);\n+    }\n+\n+    static int maskFirstTrue(boolean[] a, int idx) {\n+        int i = idx;\n+        for (; i < idx + SPECIES.length(); i++) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskFirstTrueHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.firstTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, HalffloatMaxVectorTests::maskFirstTrue);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeHalffloatMaxVectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongHalffloatMaxVectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundHalffloatMaxVectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongHalffloatMaxVectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test\n+    static void ElementSizeHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        int elsize = av.elementSize();\n+        AssertEquals(elsize, Float16.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorShapeHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        assert(vsh.equals(VectorShape.S_Max_BIT));\n+    }\n+\n+    @Test\n+    static void ShapeWithLanesHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(Float16.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void HalffloatHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementType() == Float16.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Float16.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(Float16.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void MaskAllTrueHalffloatMaxVectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/HalffloatMaxVectorTests.java","additions":5729,"deletions":0,"binary":false,"changes":5729,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,45 @@\n+    static IntVector bcast_vec = IntVector.broadcast(SPECIES, (int)10);\n+\n+    static void AssertEquals(int actual, int expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(int actual, int expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(int actual, int expected, int delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(int actual, int expected, int delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(int [] actual, int [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(int [] actual, int [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -87,1 +132,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -90,1 +135,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -102,1 +147,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -108,1 +153,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -118,1 +163,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -121,1 +166,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -137,1 +182,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -139,1 +184,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -142,2 +187,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -159,1 +204,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -161,1 +206,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -164,2 +209,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -181,1 +226,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -183,1 +228,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -186,2 +231,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -203,1 +248,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -205,1 +250,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -208,2 +253,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -221,1 +266,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -224,1 +269,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -236,1 +281,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -239,1 +284,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -248,1 +293,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -253,1 +298,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -264,1 +309,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -269,1 +314,1 @@\n-                    Assert.assertEquals(r[i + k], (int)0);\n+                    AssertEquals(r[i + k], (int)0);\n@@ -275,1 +320,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -277,1 +322,1 @@\n-                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (int)0, \"at index #\" + idx);\n@@ -289,1 +334,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -292,1 +337,1 @@\n-                        Assert.assertEquals(r[i + j], (int)0);\n+                        AssertEquals(r[i + j], (int)0);\n@@ -299,1 +344,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -301,1 +346,1 @@\n-                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (int)0, \"at index #\" + idx);\n@@ -317,1 +362,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -321,1 +366,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -327,0 +372,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -330,1 +376,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -334,2 +382,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -345,1 +392,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -347,1 +394,1 @@\n-                         Assert.assertEquals(r[i+j], (int)0);\n+                         AssertEquals(r[i+j], (int)0);\n@@ -353,1 +400,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -355,1 +402,1 @@\n-                Assert.assertEquals(r[i+j], (int)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (int)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -361,0 +408,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -364,0 +412,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -365,1 +415,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -367,1 +417,1 @@\n-                         Assert.assertEquals(r[i+j], (int)0);\n+                         AssertEquals(r[i+j], (int)0);\n@@ -371,1 +421,0 @@\n-            int idx = i + j;\n@@ -373,1 +422,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -375,1 +424,1 @@\n-                Assert.assertEquals(r[i+j], (int)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (int)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -389,1 +438,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -392,1 +441,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -413,1 +462,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -416,1 +465,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -419,1 +468,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -422,3 +471,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -439,1 +488,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -442,1 +491,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -445,1 +494,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -448,3 +497,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -458,1 +507,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -461,1 +510,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -469,1 +518,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -472,1 +521,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -480,1 +529,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -483,1 +532,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -492,1 +541,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -495,1 +544,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -508,1 +557,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -511,1 +560,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -523,1 +572,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -526,1 +575,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -538,1 +587,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -541,1 +590,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -556,1 +605,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -559,1 +608,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -572,1 +621,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -576,1 +625,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -590,1 +639,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -594,1 +643,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -616,1 +665,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -620,1 +669,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -634,1 +683,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -638,1 +687,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -658,1 +707,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -661,1 +710,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -673,1 +722,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -676,1 +725,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -685,1 +734,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -688,1 +737,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -698,1 +747,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -701,1 +750,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -717,1 +766,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -721,1 +770,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -738,1 +787,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -742,1 +791,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -753,1 +802,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -757,1 +806,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -774,1 +823,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -778,1 +827,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -796,1 +845,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -802,1 +851,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -823,1 +872,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -829,1 +878,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -844,1 +893,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -850,1 +899,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -871,1 +920,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -877,1 +926,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -891,1 +940,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -897,1 +946,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -912,1 +961,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -918,1 +967,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -933,1 +982,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -939,1 +988,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -955,1 +1004,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -961,1 +1010,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -969,0 +1018,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -974,1 +1027,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -977,1 +1030,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -987,1 +1040,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -990,1 +1043,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -998,1 +1051,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                AssertEquals(r[i], (double)(a[i+offs]));\n@@ -1001,1 +1054,1 @@\n-            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1010,1 +1063,1 @@\n-            withToString(\"int[-i * 5]\", (int s) -> {\n+            withToString(\"Integer[-i * 5]\", (int s) -> {\n@@ -1012,1 +1065,1 @@\n-                            i -> (int)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1014,1 +1067,1 @@\n-            withToString(\"int[i * 5]\", (int s) -> {\n+            withToString(\"Integer[i * 5]\", (int s) -> {\n@@ -1016,1 +1069,1 @@\n-                            i -> (int)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1018,1 +1071,1 @@\n-            withToString(\"int[i + 1]\", (int s) -> {\n+            withToString(\"Integer[i + 1]\", (int s) -> {\n@@ -1020,1 +1073,1 @@\n-                            i -> (((int)(i + 1) == 0) ? 1 : (int)(i + 1)));\n+                            i -> (((int)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1434,0 +1487,212 @@\n+    static int firstNonZero(int a, int b) {\n+        return Integer.compare(a, (int) 0) != 0 ? a : b;\n+    }\n+\n+    static int multiplicativeIdentity() {\n+        return (int)1;\n+    }\n+\n+    static int scalar_or(int a, int b) {\n+        return (int)(a | b);\n+    }\n+\n+    static int scalar_and(int a, int b) {\n+        return (int)(a & b);\n+    }\n+\n+    static int scalar_xor(int a, int b) {\n+        return (int)(a ^ b);\n+    }\n+\n+    static int scalar_add(int a, int b) {\n+        return (int)(a + b);\n+    }\n+\n+    static int scalar_sub(int a, int b) {\n+        return (int)(a - b);\n+    }\n+\n+    static int scalar_mul(int a, int b) {\n+        return (int)(a * b);\n+    }\n+\n+    static int scalar_min(int a, int b) {\n+        return (int)(Math.min(a, b));\n+    }\n+\n+    static int scalar_max(int a, int b) {\n+        return (int)(Math.max(a, b));\n+    }\n+\n+    static int scalar_div(int a, int b) {\n+        return (int)(a \/ b);\n+    }\n+\n+    static int scalar_fma(int a, int b, int c) {\n+        return (int)(Math.fma(a, b, c));\n+    }\n+\n+    static int scalar_abs(int a) {\n+        return (int)(Math.abs(a));\n+    }\n+\n+    static int scalar_neg(int a) {\n+        return ((int)-a);\n+    }\n+\n+    static int scalar_sin(int a) {\n+        return (int)Math.sin((double)a);\n+    }\n+\n+    static int scalar_exp(int a) {\n+        return (int)Math.exp((double)a);\n+    }\n+\n+    static int scalar_log1p(int a) {\n+        return (int)Math.log1p((double)a);\n+    }\n+\n+    static int scalar_log(int a) {\n+        return (int)Math.log((double)a);\n+    }\n+\n+    static int scalar_log10(int a) {\n+        return (int)Math.log10((double)a);\n+    }\n+\n+    static int scalar_expm1(int a) {\n+        return (int)Math.expm1((double)a);\n+    }\n+\n+    static int scalar_cos(int a) {\n+        return (int)Math.cos((double)a);\n+    }\n+\n+    static int scalar_tan(int a) {\n+        return (int)Math.tan((double)a);\n+    }\n+\n+    static int scalar_sinh(int a) {\n+        return (int)Math.sinh((double)a);\n+    }\n+\n+    static int scalar_cosh(int a) {\n+        return (int)Math.cosh((double)a);\n+    }\n+\n+    static int scalar_tanh(int a) {\n+        return (int)Math.tanh((double)a);\n+    }\n+\n+    static int scalar_asin(int a) {\n+        return (int)Math.asin((double)a);\n+    }\n+\n+    static int scalar_acos(int a) {\n+        return (int)Math.acos((double)a);\n+    }\n+\n+    static int scalar_atan(int a) {\n+        return (int)Math.atan((double)a);\n+    }\n+\n+    static int scalar_cbrt(int a) {\n+        return (int)Math.cbrt((double)a);\n+    }\n+\n+    static int scalar_sqrt(int a) {\n+        return (int)Math.sqrt((double)a);\n+    }\n+\n+    static int scalar_hypot(int a, int b) {\n+        return (int)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static int scalar_pow(int a, int b) {\n+        return (int)Math.pow((double)a, (double)b);\n+    }\n+\n+    static int scalar_atan2(int a, int b) {\n+        return (int)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static int strict_scalar_sin(int a) {\n+        return (int)StrictMath.sin((double)a);\n+    }\n+\n+    static int strict_scalar_exp(int a) {\n+        return (int)StrictMath.exp((double)a);\n+    }\n+\n+    static int strict_scalar_log1p(int a) {\n+        return (int)StrictMath.log1p((double)a);\n+    }\n+\n+    static int strict_scalar_log(int a) {\n+        return (int)StrictMath.log((double)a);\n+    }\n+\n+    static int strict_scalar_log10(int a) {\n+        return (int)StrictMath.log10((double)a);\n+    }\n+\n+    static int strict_scalar_expm1(int a) {\n+        return (int)StrictMath.expm1((double)a);\n+    }\n+\n+    static int strict_scalar_cos(int a) {\n+        return (int)StrictMath.cos((double)a);\n+    }\n+\n+    static int strict_scalar_tan(int a) {\n+        return (int)StrictMath.tan((double)a);\n+    }\n+\n+    static int strict_scalar_sinh(int a) {\n+        return (int)StrictMath.sinh((double)a);\n+    }\n+\n+    static int strict_scalar_cosh(int a) {\n+        return (int)StrictMath.cosh((double)a);\n+    }\n+\n+    static int strict_scalar_tanh(int a) {\n+        return (int)StrictMath.tanh((double)a);\n+    }\n+\n+    static int strict_scalar_asin(int a) {\n+        return (int)StrictMath.asin((double)a);\n+    }\n+\n+    static int strict_scalar_acos(int a) {\n+        return (int)StrictMath.acos((double)a);\n+    }\n+\n+    static int strict_scalar_atan(int a) {\n+        return (int)StrictMath.atan((double)a);\n+    }\n+\n+    static int strict_scalar_cbrt(int a) {\n+        return (int)StrictMath.cbrt((double)a);\n+    }\n+\n+    static int strict_scalar_sqrt(int a) {\n+        return (int)StrictMath.sqrt((double)a);\n+    }\n+\n+    static int strict_scalar_hypot(int a, int b) {\n+        return (int)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static int strict_scalar_pow(int a, int b) {\n+        return (int)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static int strict_scalar_atan2(int a, int b) {\n+        return (int)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static int additiveIdentity() {\n+        return (int)0;\n+    }\n+\n+\n@@ -1450,2 +1715,10 @@\n-    static int firstNonZero(int a, int b) {\n-        return Integer.compare(a, (int) 0) != 0 ? a : b;\n+    static int zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static int maxValue() {\n+        return Integer.MAX_VALUE;\n+    }\n+\n+    static int minValue() {\n+        return Integer.MIN_VALUE;\n@@ -1454,0 +1727,1 @@\n+\n@@ -1489,1 +1763,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1504,1 +1778,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1510,1 +1784,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1516,1 +1790,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1531,1 +1805,1 @@\n-        Assert.assertEquals(asIntegral.species(), SPECIES);\n+        AssertEquals(asIntegral.species(), SPECIES);\n@@ -1539,3 +1813,3 @@\n-        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n-        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n-        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n+        AssertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        AssertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n@@ -1566,1 +1840,1 @@\n-        return (int)(a + b);\n+        return (int)(scalar_add(a, b));\n@@ -1587,1 +1861,1 @@\n-        return (int)(a + b);\n+        return (int)(scalar_add(a, b));\n@@ -1644,1 +1918,1 @@\n-        return (int)(a - b);\n+        return (int)(scalar_sub(a, b));\n@@ -1665,1 +1939,1 @@\n-        return (int)(a - b);\n+        return (int)(scalar_sub(a, b));\n@@ -1722,1 +1996,1 @@\n-        return (int)(a * b);\n+        return (int)(scalar_mul(a, b));\n@@ -1743,1 +2017,1 @@\n-        return (int)(a * b);\n+        return (int)(scalar_mul(a, b));\n@@ -1890,1 +2164,1 @@\n-        return (int)((a)!=0?a:b);\n+        return (int)(firstNonZero(a, b));\n@@ -3079,2 +3353,0 @@\n-    static IntVector bv_MIN = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3089,1 +3361,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -3096,2 +3368,0 @@\n-    static IntVector bv_min = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3106,1 +3376,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -3113,2 +3383,0 @@\n-    static IntVector bv_MIN_M = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3125,1 +3393,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -3132,2 +3400,0 @@\n-    static IntVector bv_MAX = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3142,1 +3408,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -3149,2 +3415,0 @@\n-    static IntVector bv_max = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3159,1 +3423,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -3166,2 +3430,0 @@\n-    static IntVector bv_MAX_M = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3178,1 +3440,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -3186,1 +3448,1 @@\n-        return (int)(Math.min(a, b));\n+        return (int)(scalar_min(a, b));\n@@ -3207,1 +3469,1 @@\n-        return (int)(Math.min(a, b));\n+        return (int)(scalar_min(a, b));\n@@ -3226,1 +3488,1 @@\n-        return (int)(Math.max(a, b));\n+        return (int)(scalar_max(a, b));\n@@ -3247,1 +3509,1 @@\n-        return (int)(Math.max(a, b));\n+        return (int)(scalar_max(a, b));\n@@ -3615,1 +3877,1 @@\n-            res &= a[i];\n+            res = scalar_and(res, a[i]);\n@@ -3624,1 +3886,1 @@\n-            res &= ANDReduce(a, i);\n+            res = scalar_and(res, ANDReduce(a, i));\n@@ -3647,1 +3909,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND));\n@@ -3659,1 +3921,1 @@\n-                res &= a[i];\n+                res = scalar_and(res, a[i]);\n@@ -3668,1 +3930,1 @@\n-            res &= ANDReduceMasked(a, i, mask);\n+            res = scalar_and(res, ANDReduceMasked(a, i, mask));\n@@ -3693,1 +3955,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND, vmask));\n@@ -3704,1 +3966,1 @@\n-            res |= a[i];\n+            res = scalar_or(res, a[i]);\n@@ -3713,1 +3975,1 @@\n-            res |= ORReduce(a, i);\n+            res = scalar_or(res, ORReduce(a, i));\n@@ -3736,1 +3998,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR));\n@@ -3748,1 +4010,1 @@\n-                res |= a[i];\n+                res = scalar_or(res, a[i]);\n@@ -3757,1 +4019,1 @@\n-            res |= ORReduceMasked(a, i, mask);\n+            res = scalar_or(res, ORReduceMasked(a, i, mask));\n@@ -3782,1 +4044,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR, vmask));\n@@ -3793,1 +4055,1 @@\n-            res ^= a[i];\n+            res = scalar_xor(res, a[i]);\n@@ -3802,1 +4064,1 @@\n-            res ^= XORReduce(a, i);\n+            res = scalar_xor(res, XORReduce(a, i));\n@@ -3825,1 +4087,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR));\n@@ -3837,1 +4099,1 @@\n-                res ^= a[i];\n+                res = scalar_xor(res, a[i]);\n@@ -3846,1 +4108,1 @@\n-            res ^= XORReduceMasked(a, i, mask);\n+            res = scalar_xor(res, XORReduceMasked(a, i, mask));\n@@ -3871,1 +4133,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR, vmask));\n@@ -3880,1 +4142,1 @@\n-        int res = 0;\n+        int res = additiveIdentity();\n@@ -3882,1 +4144,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -3889,1 +4151,1 @@\n-        int res = 0;\n+        int res = additiveIdentity();\n@@ -3891,1 +4153,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -3901,1 +4163,1 @@\n-        int ra = 0;\n+        int ra = additiveIdentity();\n@@ -3911,1 +4173,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3914,1 +4176,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -3923,1 +4185,1 @@\n-        int res = 0;\n+        int res = additiveIdentity();\n@@ -3926,1 +4188,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -3933,1 +4195,1 @@\n-        int res = 0;\n+        int res = additiveIdentity();\n@@ -3935,1 +4197,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -3947,1 +4209,1 @@\n-        int ra = 0;\n+        int ra = additiveIdentity();\n@@ -3957,1 +4219,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3960,1 +4222,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -3969,1 +4231,1 @@\n-        int res = 1;\n+        int res = multiplicativeIdentity();\n@@ -3971,1 +4233,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -3978,1 +4240,1 @@\n-        int res = 1;\n+        int res = multiplicativeIdentity();\n@@ -3980,1 +4242,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -3990,1 +4252,1 @@\n-        int ra = 1;\n+        int ra = multiplicativeIdentity();\n@@ -4000,1 +4262,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -4003,1 +4265,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -4012,1 +4274,1 @@\n-        int res = 1;\n+        int res = multiplicativeIdentity();\n@@ -4015,1 +4277,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -4022,1 +4284,1 @@\n-        int res = 1;\n+        int res = multiplicativeIdentity();\n@@ -4024,1 +4286,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -4036,1 +4298,1 @@\n-        int ra = 1;\n+        int ra = multiplicativeIdentity();\n@@ -4046,1 +4308,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -4049,1 +4311,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -4058,1 +4320,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4060,1 +4322,1 @@\n-            res = (int) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -4067,1 +4329,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4069,1 +4331,1 @@\n-            res = (int) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -4079,1 +4341,1 @@\n-        int ra = Integer.MAX_VALUE;\n+        int ra = maxValue();\n@@ -4089,1 +4351,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = maxValue();\n@@ -4092,1 +4354,1 @@\n-                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -4101,1 +4363,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4104,1 +4366,1 @@\n-                res = (int) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -4111,1 +4373,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4113,1 +4375,1 @@\n-            res = (int) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -4125,1 +4387,1 @@\n-        int ra = Integer.MAX_VALUE;\n+        int ra = maxValue();\n@@ -4135,1 +4397,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = maxValue();\n@@ -4138,1 +4400,1 @@\n-                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -4147,1 +4409,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4149,1 +4411,1 @@\n-            res = (int) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -4156,1 +4418,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4158,1 +4420,1 @@\n-            res = (int) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -4168,1 +4430,1 @@\n-        int ra = Integer.MIN_VALUE;\n+        int ra = minValue();\n@@ -4178,1 +4440,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = minValue();\n@@ -4181,1 +4443,1 @@\n-                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -4190,1 +4452,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4193,1 +4455,1 @@\n-                res = (int) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -4200,1 +4462,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4202,1 +4464,1 @@\n-            res = (int) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -4214,1 +4476,1 @@\n-        int ra = Integer.MIN_VALUE;\n+        int ra = minValue();\n@@ -4224,1 +4486,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = minValue();\n@@ -4227,1 +4489,1 @@\n-                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -4236,1 +4498,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4245,1 +4507,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4257,1 +4519,1 @@\n-        int ra = Integer.MAX_VALUE;\n+        int ra = maxValue();\n@@ -4267,1 +4529,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = maxValue();\n@@ -4279,1 +4541,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4289,1 +4551,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4303,1 +4565,1 @@\n-        int ra = Integer.MAX_VALUE;\n+        int ra = maxValue();\n@@ -4313,1 +4575,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = maxValue();\n@@ -4325,1 +4587,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4334,1 +4596,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4346,1 +4608,1 @@\n-        int ra = Integer.MIN_VALUE;\n+        int ra = minValue();\n@@ -4356,1 +4618,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = minValue();\n@@ -4368,1 +4630,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4378,1 +4640,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4392,1 +4654,1 @@\n-        int ra = Integer.MIN_VALUE;\n+        int ra = minValue();\n@@ -4402,1 +4664,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = minValue();\n@@ -4414,1 +4676,1 @@\n-        int res = (int) 0;\n+        int res = zeroValue();\n@@ -4423,1 +4685,1 @@\n-        int res = (int) 0;\n+        int res = zeroValue();\n@@ -4435,1 +4697,1 @@\n-        int ra = (int) 0;\n+        int ra = zeroValue();\n@@ -4445,1 +4707,1 @@\n-            ra = (int) 0;\n+            ra = zeroValue();\n@@ -4457,1 +4719,1 @@\n-        int res = (int) 0;\n+        int res = zeroValue();\n@@ -4467,1 +4729,1 @@\n-        int res = (int) 0;\n+        int res = zeroValue();\n@@ -4481,1 +4743,1 @@\n-        int ra = (int) 0;\n+        int ra = zeroValue();\n@@ -4491,1 +4753,1 @@\n-            ra = (int) 0;\n+            ra = zeroValue();\n@@ -4551,1 +4813,1 @@\n-        int res = 0;\n+        int res = zeroValue();\n@@ -4560,1 +4822,1 @@\n-        int res = 0;\n+        int res = zeroValue();\n@@ -4572,1 +4834,1 @@\n-        int ra = 0;\n+        int ra = zeroValue();\n@@ -4582,1 +4844,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4594,1 +4856,1 @@\n-        int res = 0;\n+        int res = zeroValue();\n@@ -4604,1 +4866,1 @@\n-        int res = 0;\n+        int res = zeroValue();\n@@ -4617,1 +4879,1 @@\n-        int ra = 0;\n+        int ra = zeroValue();\n@@ -4627,1 +4889,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4672,1 +4934,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -4692,1 +4954,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -4713,1 +4975,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -4733,1 +4995,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -4752,1 +5014,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4771,1 +5033,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4794,1 +5056,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -4813,1 +5075,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -4836,1 +5098,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -4855,1 +5117,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4874,1 +5136,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4897,1 +5159,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -4916,1 +5178,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -4939,1 +5201,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -4958,1 +5220,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -4981,1 +5243,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -5000,1 +5262,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -5023,1 +5285,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -5042,1 +5304,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n@@ -5065,1 +5327,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n@@ -5084,1 +5346,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n@@ -5107,1 +5369,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -5126,1 +5388,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n@@ -5149,1 +5411,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n@@ -5168,1 +5430,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n@@ -5191,1 +5453,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n@@ -5208,1 +5470,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -5228,1 +5490,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -5244,1 +5506,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < (int)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (int)((long)b[i])));\n@@ -5264,1 +5526,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < (int)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(int)((long)b[i]))));\n@@ -5280,1 +5542,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -5300,1 +5562,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -5316,1 +5578,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == (int)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (int)((long)b[i])));\n@@ -5336,1 +5598,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == (int)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(int)((long)b[i]))));\n@@ -5617,1 +5879,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -6048,1 +6310,1 @@\n-        return (int)(-((int)a));\n+        return (int)(scalar_neg((int)a));\n@@ -6052,1 +6314,1 @@\n-        return (int)(-((int)a));\n+        return (int)(scalar_neg((int)a));\n@@ -6104,1 +6366,1 @@\n-        return (int)(Math.abs((int)a));\n+        return (int)(scalar_abs((int)a));\n@@ -6108,1 +6370,1 @@\n-        return (int)(Math.abs((int)a));\n+        return (int)(scalar_abs((int)a));\n@@ -6448,1 +6710,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -6464,1 +6726,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -6560,1 +6822,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6601,1 +6863,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6704,1 +6966,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -6732,1 +6994,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -6746,1 +7008,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -6943,1 +7205,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -6963,1 +7225,1 @@\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -6986,1 +7248,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -7000,1 +7262,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -7022,1 +7284,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -7030,1 +7292,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -7037,1 +7299,1 @@\n-        Assert.assertEquals(elsize, Integer.SIZE);\n+        AssertEquals(elsize, Integer.SIZE);\n@@ -7056,1 +7318,1 @@\n-    static void ElementTypeInt128VectorTestsSmokeTest() {\n+    static void IntInt128VectorTestsSmokeTest() {\n@@ -7091,1 +7353,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":595,"deletions":333,"binary":false,"changes":928,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,45 @@\n+    static IntVector bcast_vec = IntVector.broadcast(SPECIES, (int)10);\n+\n+    static void AssertEquals(int actual, int expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(int actual, int expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(int actual, int expected, int delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(int actual, int expected, int delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(int [] actual, int [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(int [] actual, int [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -87,1 +132,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -90,1 +135,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -102,1 +147,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -108,1 +153,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -118,1 +163,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -121,1 +166,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -137,1 +182,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -139,1 +184,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -142,2 +187,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -159,1 +204,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -161,1 +206,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -164,2 +209,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -181,1 +226,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -183,1 +228,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -186,2 +231,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -203,1 +248,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -205,1 +250,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -208,2 +253,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -221,1 +266,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -224,1 +269,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -236,1 +281,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -239,1 +284,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -248,1 +293,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -253,1 +298,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -264,1 +309,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -269,1 +314,1 @@\n-                    Assert.assertEquals(r[i + k], (int)0);\n+                    AssertEquals(r[i + k], (int)0);\n@@ -275,1 +320,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -277,1 +322,1 @@\n-                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (int)0, \"at index #\" + idx);\n@@ -289,1 +334,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -292,1 +337,1 @@\n-                        Assert.assertEquals(r[i + j], (int)0);\n+                        AssertEquals(r[i + j], (int)0);\n@@ -299,1 +344,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -301,1 +346,1 @@\n-                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (int)0, \"at index #\" + idx);\n@@ -317,1 +362,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -321,1 +366,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -327,0 +372,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -330,1 +376,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -334,2 +382,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -345,1 +392,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -347,1 +394,1 @@\n-                         Assert.assertEquals(r[i+j], (int)0);\n+                         AssertEquals(r[i+j], (int)0);\n@@ -353,1 +400,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -355,1 +402,1 @@\n-                Assert.assertEquals(r[i+j], (int)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (int)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -361,0 +408,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -364,0 +412,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -365,1 +415,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -367,1 +417,1 @@\n-                         Assert.assertEquals(r[i+j], (int)0);\n+                         AssertEquals(r[i+j], (int)0);\n@@ -371,1 +421,0 @@\n-            int idx = i + j;\n@@ -373,1 +422,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -375,1 +424,1 @@\n-                Assert.assertEquals(r[i+j], (int)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (int)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -389,1 +438,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -392,1 +441,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -413,1 +462,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -416,1 +465,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -419,1 +468,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -422,3 +471,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -439,1 +488,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -442,1 +491,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -445,1 +494,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -448,3 +497,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -458,1 +507,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -461,1 +510,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -469,1 +518,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -472,1 +521,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -480,1 +529,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -483,1 +532,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -492,1 +541,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -495,1 +544,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -508,1 +557,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -511,1 +560,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -523,1 +572,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -526,1 +575,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -538,1 +587,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -541,1 +590,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -556,1 +605,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -559,1 +608,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -572,1 +621,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -576,1 +625,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -590,1 +639,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -594,1 +643,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -616,1 +665,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -620,1 +669,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -634,1 +683,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -638,1 +687,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -658,1 +707,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -661,1 +710,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -673,1 +722,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -676,1 +725,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -685,1 +734,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -688,1 +737,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -698,1 +747,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -701,1 +750,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -717,1 +766,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -721,1 +770,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -738,1 +787,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -742,1 +791,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -753,1 +802,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -757,1 +806,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -774,1 +823,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -778,1 +827,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -796,1 +845,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -802,1 +851,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -823,1 +872,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -829,1 +878,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -844,1 +893,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -850,1 +899,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -871,1 +920,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -877,1 +926,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -891,1 +940,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -897,1 +946,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -912,1 +961,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -918,1 +967,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -933,1 +982,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -939,1 +988,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -955,1 +1004,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -961,1 +1010,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -969,0 +1018,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -974,1 +1027,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -977,1 +1030,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -987,1 +1040,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -990,1 +1043,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -998,1 +1051,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                AssertEquals(r[i], (double)(a[i+offs]));\n@@ -1001,1 +1054,1 @@\n-            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1010,1 +1063,1 @@\n-            withToString(\"int[-i * 5]\", (int s) -> {\n+            withToString(\"Integer[-i * 5]\", (int s) -> {\n@@ -1012,1 +1065,1 @@\n-                            i -> (int)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1014,1 +1067,1 @@\n-            withToString(\"int[i * 5]\", (int s) -> {\n+            withToString(\"Integer[i * 5]\", (int s) -> {\n@@ -1016,1 +1069,1 @@\n-                            i -> (int)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1018,1 +1071,1 @@\n-            withToString(\"int[i + 1]\", (int s) -> {\n+            withToString(\"Integer[i + 1]\", (int s) -> {\n@@ -1020,1 +1073,1 @@\n-                            i -> (((int)(i + 1) == 0) ? 1 : (int)(i + 1)));\n+                            i -> (((int)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1434,0 +1487,212 @@\n+    static int firstNonZero(int a, int b) {\n+        return Integer.compare(a, (int) 0) != 0 ? a : b;\n+    }\n+\n+    static int multiplicativeIdentity() {\n+        return (int)1;\n+    }\n+\n+    static int scalar_or(int a, int b) {\n+        return (int)(a | b);\n+    }\n+\n+    static int scalar_and(int a, int b) {\n+        return (int)(a & b);\n+    }\n+\n+    static int scalar_xor(int a, int b) {\n+        return (int)(a ^ b);\n+    }\n+\n+    static int scalar_add(int a, int b) {\n+        return (int)(a + b);\n+    }\n+\n+    static int scalar_sub(int a, int b) {\n+        return (int)(a - b);\n+    }\n+\n+    static int scalar_mul(int a, int b) {\n+        return (int)(a * b);\n+    }\n+\n+    static int scalar_min(int a, int b) {\n+        return (int)(Math.min(a, b));\n+    }\n+\n+    static int scalar_max(int a, int b) {\n+        return (int)(Math.max(a, b));\n+    }\n+\n+    static int scalar_div(int a, int b) {\n+        return (int)(a \/ b);\n+    }\n+\n+    static int scalar_fma(int a, int b, int c) {\n+        return (int)(Math.fma(a, b, c));\n+    }\n+\n+    static int scalar_abs(int a) {\n+        return (int)(Math.abs(a));\n+    }\n+\n+    static int scalar_neg(int a) {\n+        return ((int)-a);\n+    }\n+\n+    static int scalar_sin(int a) {\n+        return (int)Math.sin((double)a);\n+    }\n+\n+    static int scalar_exp(int a) {\n+        return (int)Math.exp((double)a);\n+    }\n+\n+    static int scalar_log1p(int a) {\n+        return (int)Math.log1p((double)a);\n+    }\n+\n+    static int scalar_log(int a) {\n+        return (int)Math.log((double)a);\n+    }\n+\n+    static int scalar_log10(int a) {\n+        return (int)Math.log10((double)a);\n+    }\n+\n+    static int scalar_expm1(int a) {\n+        return (int)Math.expm1((double)a);\n+    }\n+\n+    static int scalar_cos(int a) {\n+        return (int)Math.cos((double)a);\n+    }\n+\n+    static int scalar_tan(int a) {\n+        return (int)Math.tan((double)a);\n+    }\n+\n+    static int scalar_sinh(int a) {\n+        return (int)Math.sinh((double)a);\n+    }\n+\n+    static int scalar_cosh(int a) {\n+        return (int)Math.cosh((double)a);\n+    }\n+\n+    static int scalar_tanh(int a) {\n+        return (int)Math.tanh((double)a);\n+    }\n+\n+    static int scalar_asin(int a) {\n+        return (int)Math.asin((double)a);\n+    }\n+\n+    static int scalar_acos(int a) {\n+        return (int)Math.acos((double)a);\n+    }\n+\n+    static int scalar_atan(int a) {\n+        return (int)Math.atan((double)a);\n+    }\n+\n+    static int scalar_cbrt(int a) {\n+        return (int)Math.cbrt((double)a);\n+    }\n+\n+    static int scalar_sqrt(int a) {\n+        return (int)Math.sqrt((double)a);\n+    }\n+\n+    static int scalar_hypot(int a, int b) {\n+        return (int)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static int scalar_pow(int a, int b) {\n+        return (int)Math.pow((double)a, (double)b);\n+    }\n+\n+    static int scalar_atan2(int a, int b) {\n+        return (int)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static int strict_scalar_sin(int a) {\n+        return (int)StrictMath.sin((double)a);\n+    }\n+\n+    static int strict_scalar_exp(int a) {\n+        return (int)StrictMath.exp((double)a);\n+    }\n+\n+    static int strict_scalar_log1p(int a) {\n+        return (int)StrictMath.log1p((double)a);\n+    }\n+\n+    static int strict_scalar_log(int a) {\n+        return (int)StrictMath.log((double)a);\n+    }\n+\n+    static int strict_scalar_log10(int a) {\n+        return (int)StrictMath.log10((double)a);\n+    }\n+\n+    static int strict_scalar_expm1(int a) {\n+        return (int)StrictMath.expm1((double)a);\n+    }\n+\n+    static int strict_scalar_cos(int a) {\n+        return (int)StrictMath.cos((double)a);\n+    }\n+\n+    static int strict_scalar_tan(int a) {\n+        return (int)StrictMath.tan((double)a);\n+    }\n+\n+    static int strict_scalar_sinh(int a) {\n+        return (int)StrictMath.sinh((double)a);\n+    }\n+\n+    static int strict_scalar_cosh(int a) {\n+        return (int)StrictMath.cosh((double)a);\n+    }\n+\n+    static int strict_scalar_tanh(int a) {\n+        return (int)StrictMath.tanh((double)a);\n+    }\n+\n+    static int strict_scalar_asin(int a) {\n+        return (int)StrictMath.asin((double)a);\n+    }\n+\n+    static int strict_scalar_acos(int a) {\n+        return (int)StrictMath.acos((double)a);\n+    }\n+\n+    static int strict_scalar_atan(int a) {\n+        return (int)StrictMath.atan((double)a);\n+    }\n+\n+    static int strict_scalar_cbrt(int a) {\n+        return (int)StrictMath.cbrt((double)a);\n+    }\n+\n+    static int strict_scalar_sqrt(int a) {\n+        return (int)StrictMath.sqrt((double)a);\n+    }\n+\n+    static int strict_scalar_hypot(int a, int b) {\n+        return (int)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static int strict_scalar_pow(int a, int b) {\n+        return (int)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static int strict_scalar_atan2(int a, int b) {\n+        return (int)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static int additiveIdentity() {\n+        return (int)0;\n+    }\n+\n+\n@@ -1450,2 +1715,10 @@\n-    static int firstNonZero(int a, int b) {\n-        return Integer.compare(a, (int) 0) != 0 ? a : b;\n+    static int zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static int maxValue() {\n+        return Integer.MAX_VALUE;\n+    }\n+\n+    static int minValue() {\n+        return Integer.MIN_VALUE;\n@@ -1454,0 +1727,1 @@\n+\n@@ -1489,1 +1763,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1504,1 +1778,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1510,1 +1784,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1516,1 +1790,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1531,1 +1805,1 @@\n-        Assert.assertEquals(asIntegral.species(), SPECIES);\n+        AssertEquals(asIntegral.species(), SPECIES);\n@@ -1539,3 +1813,3 @@\n-        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n-        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n-        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n+        AssertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        AssertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n@@ -1566,1 +1840,1 @@\n-        return (int)(a + b);\n+        return (int)(scalar_add(a, b));\n@@ -1587,1 +1861,1 @@\n-        return (int)(a + b);\n+        return (int)(scalar_add(a, b));\n@@ -1644,1 +1918,1 @@\n-        return (int)(a - b);\n+        return (int)(scalar_sub(a, b));\n@@ -1665,1 +1939,1 @@\n-        return (int)(a - b);\n+        return (int)(scalar_sub(a, b));\n@@ -1722,1 +1996,1 @@\n-        return (int)(a * b);\n+        return (int)(scalar_mul(a, b));\n@@ -1743,1 +2017,1 @@\n-        return (int)(a * b);\n+        return (int)(scalar_mul(a, b));\n@@ -1890,1 +2164,1 @@\n-        return (int)((a)!=0?a:b);\n+        return (int)(firstNonZero(a, b));\n@@ -3079,2 +3353,0 @@\n-    static IntVector bv_MIN = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3089,1 +3361,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -3096,2 +3368,0 @@\n-    static IntVector bv_min = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3106,1 +3376,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -3113,2 +3383,0 @@\n-    static IntVector bv_MIN_M = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3125,1 +3393,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -3132,2 +3400,0 @@\n-    static IntVector bv_MAX = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3142,1 +3408,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -3149,2 +3415,0 @@\n-    static IntVector bv_max = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3159,1 +3423,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -3166,2 +3430,0 @@\n-    static IntVector bv_MAX_M = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3178,1 +3440,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -3186,1 +3448,1 @@\n-        return (int)(Math.min(a, b));\n+        return (int)(scalar_min(a, b));\n@@ -3207,1 +3469,1 @@\n-        return (int)(Math.min(a, b));\n+        return (int)(scalar_min(a, b));\n@@ -3226,1 +3488,1 @@\n-        return (int)(Math.max(a, b));\n+        return (int)(scalar_max(a, b));\n@@ -3247,1 +3509,1 @@\n-        return (int)(Math.max(a, b));\n+        return (int)(scalar_max(a, b));\n@@ -3615,1 +3877,1 @@\n-            res &= a[i];\n+            res = scalar_and(res, a[i]);\n@@ -3624,1 +3886,1 @@\n-            res &= ANDReduce(a, i);\n+            res = scalar_and(res, ANDReduce(a, i));\n@@ -3647,1 +3909,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND));\n@@ -3659,1 +3921,1 @@\n-                res &= a[i];\n+                res = scalar_and(res, a[i]);\n@@ -3668,1 +3930,1 @@\n-            res &= ANDReduceMasked(a, i, mask);\n+            res = scalar_and(res, ANDReduceMasked(a, i, mask));\n@@ -3693,1 +3955,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND, vmask));\n@@ -3704,1 +3966,1 @@\n-            res |= a[i];\n+            res = scalar_or(res, a[i]);\n@@ -3713,1 +3975,1 @@\n-            res |= ORReduce(a, i);\n+            res = scalar_or(res, ORReduce(a, i));\n@@ -3736,1 +3998,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR));\n@@ -3748,1 +4010,1 @@\n-                res |= a[i];\n+                res = scalar_or(res, a[i]);\n@@ -3757,1 +4019,1 @@\n-            res |= ORReduceMasked(a, i, mask);\n+            res = scalar_or(res, ORReduceMasked(a, i, mask));\n@@ -3782,1 +4044,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR, vmask));\n@@ -3793,1 +4055,1 @@\n-            res ^= a[i];\n+            res = scalar_xor(res, a[i]);\n@@ -3802,1 +4064,1 @@\n-            res ^= XORReduce(a, i);\n+            res = scalar_xor(res, XORReduce(a, i));\n@@ -3825,1 +4087,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR));\n@@ -3837,1 +4099,1 @@\n-                res ^= a[i];\n+                res = scalar_xor(res, a[i]);\n@@ -3846,1 +4108,1 @@\n-            res ^= XORReduceMasked(a, i, mask);\n+            res = scalar_xor(res, XORReduceMasked(a, i, mask));\n@@ -3871,1 +4133,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR, vmask));\n@@ -3880,1 +4142,1 @@\n-        int res = 0;\n+        int res = additiveIdentity();\n@@ -3882,1 +4144,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -3889,1 +4151,1 @@\n-        int res = 0;\n+        int res = additiveIdentity();\n@@ -3891,1 +4153,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -3901,1 +4163,1 @@\n-        int ra = 0;\n+        int ra = additiveIdentity();\n@@ -3911,1 +4173,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3914,1 +4176,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -3923,1 +4185,1 @@\n-        int res = 0;\n+        int res = additiveIdentity();\n@@ -3926,1 +4188,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -3933,1 +4195,1 @@\n-        int res = 0;\n+        int res = additiveIdentity();\n@@ -3935,1 +4197,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -3947,1 +4209,1 @@\n-        int ra = 0;\n+        int ra = additiveIdentity();\n@@ -3957,1 +4219,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3960,1 +4222,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -3969,1 +4231,1 @@\n-        int res = 1;\n+        int res = multiplicativeIdentity();\n@@ -3971,1 +4233,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -3978,1 +4240,1 @@\n-        int res = 1;\n+        int res = multiplicativeIdentity();\n@@ -3980,1 +4242,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -3990,1 +4252,1 @@\n-        int ra = 1;\n+        int ra = multiplicativeIdentity();\n@@ -4000,1 +4262,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -4003,1 +4265,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -4012,1 +4274,1 @@\n-        int res = 1;\n+        int res = multiplicativeIdentity();\n@@ -4015,1 +4277,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -4022,1 +4284,1 @@\n-        int res = 1;\n+        int res = multiplicativeIdentity();\n@@ -4024,1 +4286,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -4036,1 +4298,1 @@\n-        int ra = 1;\n+        int ra = multiplicativeIdentity();\n@@ -4046,1 +4308,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -4049,1 +4311,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -4058,1 +4320,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4060,1 +4322,1 @@\n-            res = (int) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -4067,1 +4329,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4069,1 +4331,1 @@\n-            res = (int) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -4079,1 +4341,1 @@\n-        int ra = Integer.MAX_VALUE;\n+        int ra = maxValue();\n@@ -4089,1 +4351,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = maxValue();\n@@ -4092,1 +4354,1 @@\n-                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -4101,1 +4363,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4104,1 +4366,1 @@\n-                res = (int) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -4111,1 +4373,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4113,1 +4375,1 @@\n-            res = (int) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -4125,1 +4387,1 @@\n-        int ra = Integer.MAX_VALUE;\n+        int ra = maxValue();\n@@ -4135,1 +4397,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = maxValue();\n@@ -4138,1 +4400,1 @@\n-                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -4147,1 +4409,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4149,1 +4411,1 @@\n-            res = (int) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -4156,1 +4418,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4158,1 +4420,1 @@\n-            res = (int) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -4168,1 +4430,1 @@\n-        int ra = Integer.MIN_VALUE;\n+        int ra = minValue();\n@@ -4178,1 +4440,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = minValue();\n@@ -4181,1 +4443,1 @@\n-                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -4190,1 +4452,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4193,1 +4455,1 @@\n-                res = (int) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -4200,1 +4462,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4202,1 +4464,1 @@\n-            res = (int) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -4214,1 +4476,1 @@\n-        int ra = Integer.MIN_VALUE;\n+        int ra = minValue();\n@@ -4224,1 +4486,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = minValue();\n@@ -4227,1 +4489,1 @@\n-                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -4236,1 +4498,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4245,1 +4507,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4257,1 +4519,1 @@\n-        int ra = Integer.MAX_VALUE;\n+        int ra = maxValue();\n@@ -4267,1 +4529,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = maxValue();\n@@ -4279,1 +4541,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4289,1 +4551,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4303,1 +4565,1 @@\n-        int ra = Integer.MAX_VALUE;\n+        int ra = maxValue();\n@@ -4313,1 +4575,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = maxValue();\n@@ -4325,1 +4587,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4334,1 +4596,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4346,1 +4608,1 @@\n-        int ra = Integer.MIN_VALUE;\n+        int ra = minValue();\n@@ -4356,1 +4618,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = minValue();\n@@ -4368,1 +4630,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4378,1 +4640,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4392,1 +4654,1 @@\n-        int ra = Integer.MIN_VALUE;\n+        int ra = minValue();\n@@ -4402,1 +4664,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = minValue();\n@@ -4414,1 +4676,1 @@\n-        int res = (int) 0;\n+        int res = zeroValue();\n@@ -4423,1 +4685,1 @@\n-        int res = (int) 0;\n+        int res = zeroValue();\n@@ -4435,1 +4697,1 @@\n-        int ra = (int) 0;\n+        int ra = zeroValue();\n@@ -4445,1 +4707,1 @@\n-            ra = (int) 0;\n+            ra = zeroValue();\n@@ -4457,1 +4719,1 @@\n-        int res = (int) 0;\n+        int res = zeroValue();\n@@ -4467,1 +4729,1 @@\n-        int res = (int) 0;\n+        int res = zeroValue();\n@@ -4481,1 +4743,1 @@\n-        int ra = (int) 0;\n+        int ra = zeroValue();\n@@ -4491,1 +4753,1 @@\n-            ra = (int) 0;\n+            ra = zeroValue();\n@@ -4551,1 +4813,1 @@\n-        int res = 0;\n+        int res = zeroValue();\n@@ -4560,1 +4822,1 @@\n-        int res = 0;\n+        int res = zeroValue();\n@@ -4572,1 +4834,1 @@\n-        int ra = 0;\n+        int ra = zeroValue();\n@@ -4582,1 +4844,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4594,1 +4856,1 @@\n-        int res = 0;\n+        int res = zeroValue();\n@@ -4604,1 +4866,1 @@\n-        int res = 0;\n+        int res = zeroValue();\n@@ -4617,1 +4879,1 @@\n-        int ra = 0;\n+        int ra = zeroValue();\n@@ -4627,1 +4889,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4672,1 +4934,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -4692,1 +4954,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -4713,1 +4975,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -4733,1 +4995,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -4752,1 +5014,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4771,1 +5033,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4794,1 +5056,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -4813,1 +5075,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -4836,1 +5098,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -4855,1 +5117,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4874,1 +5136,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4897,1 +5159,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -4916,1 +5178,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -4939,1 +5201,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -4958,1 +5220,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -4981,1 +5243,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -5000,1 +5262,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -5023,1 +5285,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -5042,1 +5304,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n@@ -5065,1 +5327,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n@@ -5084,1 +5346,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n@@ -5107,1 +5369,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -5126,1 +5388,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n@@ -5149,1 +5411,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n@@ -5168,1 +5430,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n@@ -5191,1 +5453,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n@@ -5208,1 +5470,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -5228,1 +5490,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -5244,1 +5506,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < (int)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (int)((long)b[i])));\n@@ -5264,1 +5526,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < (int)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(int)((long)b[i]))));\n@@ -5280,1 +5542,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -5300,1 +5562,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -5316,1 +5578,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == (int)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (int)((long)b[i])));\n@@ -5336,1 +5598,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == (int)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(int)((long)b[i]))));\n@@ -5617,1 +5879,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -6048,1 +6310,1 @@\n-        return (int)(-((int)a));\n+        return (int)(scalar_neg((int)a));\n@@ -6052,1 +6314,1 @@\n-        return (int)(-((int)a));\n+        return (int)(scalar_neg((int)a));\n@@ -6104,1 +6366,1 @@\n-        return (int)(Math.abs((int)a));\n+        return (int)(scalar_abs((int)a));\n@@ -6108,1 +6370,1 @@\n-        return (int)(Math.abs((int)a));\n+        return (int)(scalar_abs((int)a));\n@@ -6448,1 +6710,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -6464,1 +6726,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -6560,1 +6822,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6601,1 +6863,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6704,1 +6966,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -6732,1 +6994,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -6746,1 +7008,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -6943,1 +7205,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -6963,1 +7225,1 @@\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -6986,1 +7248,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -7000,1 +7262,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -7022,1 +7284,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -7030,1 +7292,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -7037,1 +7299,1 @@\n-        Assert.assertEquals(elsize, Integer.SIZE);\n+        AssertEquals(elsize, Integer.SIZE);\n@@ -7056,1 +7318,1 @@\n-    static void ElementTypeInt256VectorTestsSmokeTest() {\n+    static void IntInt256VectorTestsSmokeTest() {\n@@ -7091,1 +7353,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":595,"deletions":333,"binary":false,"changes":928,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,45 @@\n+    static IntVector bcast_vec = IntVector.broadcast(SPECIES, (int)10);\n+\n+    static void AssertEquals(int actual, int expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(int actual, int expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(int actual, int expected, int delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(int actual, int expected, int delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(int [] actual, int [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(int [] actual, int [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -87,1 +132,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -90,1 +135,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -102,1 +147,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -108,1 +153,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -118,1 +163,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -121,1 +166,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -137,1 +182,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -139,1 +184,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -142,2 +187,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -159,1 +204,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -161,1 +206,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -164,2 +209,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -181,1 +226,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -183,1 +228,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -186,2 +231,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -203,1 +248,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -205,1 +250,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -208,2 +253,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -221,1 +266,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -224,1 +269,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -236,1 +281,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -239,1 +284,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -248,1 +293,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -253,1 +298,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -264,1 +309,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -269,1 +314,1 @@\n-                    Assert.assertEquals(r[i + k], (int)0);\n+                    AssertEquals(r[i + k], (int)0);\n@@ -275,1 +320,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -277,1 +322,1 @@\n-                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (int)0, \"at index #\" + idx);\n@@ -289,1 +334,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -292,1 +337,1 @@\n-                        Assert.assertEquals(r[i + j], (int)0);\n+                        AssertEquals(r[i + j], (int)0);\n@@ -299,1 +344,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -301,1 +346,1 @@\n-                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (int)0, \"at index #\" + idx);\n@@ -317,1 +362,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -321,1 +366,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -327,0 +372,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -330,1 +376,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -334,2 +382,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -345,1 +392,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -347,1 +394,1 @@\n-                         Assert.assertEquals(r[i+j], (int)0);\n+                         AssertEquals(r[i+j], (int)0);\n@@ -353,1 +400,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -355,1 +402,1 @@\n-                Assert.assertEquals(r[i+j], (int)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (int)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -361,0 +408,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -364,0 +412,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -365,1 +415,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -367,1 +417,1 @@\n-                         Assert.assertEquals(r[i+j], (int)0);\n+                         AssertEquals(r[i+j], (int)0);\n@@ -371,1 +421,0 @@\n-            int idx = i + j;\n@@ -373,1 +422,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -375,1 +424,1 @@\n-                Assert.assertEquals(r[i+j], (int)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (int)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -389,1 +438,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -392,1 +441,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -413,1 +462,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -416,1 +465,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -419,1 +468,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -422,3 +471,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -439,1 +488,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -442,1 +491,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -445,1 +494,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -448,3 +497,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -458,1 +507,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -461,1 +510,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -469,1 +518,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -472,1 +521,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -480,1 +529,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -483,1 +532,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -492,1 +541,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -495,1 +544,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -508,1 +557,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -511,1 +560,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -523,1 +572,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -526,1 +575,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -538,1 +587,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -541,1 +590,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -556,1 +605,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -559,1 +608,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -572,1 +621,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -576,1 +625,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -590,1 +639,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -594,1 +643,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -616,1 +665,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -620,1 +669,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -634,1 +683,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -638,1 +687,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -658,1 +707,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -661,1 +710,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -673,1 +722,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -676,1 +725,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -685,1 +734,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -688,1 +737,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -698,1 +747,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -701,1 +750,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -717,1 +766,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -721,1 +770,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -738,1 +787,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -742,1 +791,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -753,1 +802,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -757,1 +806,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -774,1 +823,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -778,1 +827,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -796,1 +845,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -802,1 +851,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -823,1 +872,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -829,1 +878,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -844,1 +893,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -850,1 +899,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -871,1 +920,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -877,1 +926,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -891,1 +940,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -897,1 +946,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -912,1 +961,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -918,1 +967,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -933,1 +982,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -939,1 +988,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -955,1 +1004,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -961,1 +1010,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -969,0 +1018,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -974,1 +1027,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -977,1 +1030,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -987,1 +1040,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -990,1 +1043,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -998,1 +1051,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                AssertEquals(r[i], (double)(a[i+offs]));\n@@ -1001,1 +1054,1 @@\n-            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1010,1 +1063,1 @@\n-            withToString(\"int[-i * 5]\", (int s) -> {\n+            withToString(\"Integer[-i * 5]\", (int s) -> {\n@@ -1012,1 +1065,1 @@\n-                            i -> (int)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1014,1 +1067,1 @@\n-            withToString(\"int[i * 5]\", (int s) -> {\n+            withToString(\"Integer[i * 5]\", (int s) -> {\n@@ -1016,1 +1069,1 @@\n-                            i -> (int)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1018,1 +1071,1 @@\n-            withToString(\"int[i + 1]\", (int s) -> {\n+            withToString(\"Integer[i + 1]\", (int s) -> {\n@@ -1020,1 +1073,1 @@\n-                            i -> (((int)(i + 1) == 0) ? 1 : (int)(i + 1)));\n+                            i -> (((int)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1434,0 +1487,212 @@\n+    static int firstNonZero(int a, int b) {\n+        return Integer.compare(a, (int) 0) != 0 ? a : b;\n+    }\n+\n+    static int multiplicativeIdentity() {\n+        return (int)1;\n+    }\n+\n+    static int scalar_or(int a, int b) {\n+        return (int)(a | b);\n+    }\n+\n+    static int scalar_and(int a, int b) {\n+        return (int)(a & b);\n+    }\n+\n+    static int scalar_xor(int a, int b) {\n+        return (int)(a ^ b);\n+    }\n+\n+    static int scalar_add(int a, int b) {\n+        return (int)(a + b);\n+    }\n+\n+    static int scalar_sub(int a, int b) {\n+        return (int)(a - b);\n+    }\n+\n+    static int scalar_mul(int a, int b) {\n+        return (int)(a * b);\n+    }\n+\n+    static int scalar_min(int a, int b) {\n+        return (int)(Math.min(a, b));\n+    }\n+\n+    static int scalar_max(int a, int b) {\n+        return (int)(Math.max(a, b));\n+    }\n+\n+    static int scalar_div(int a, int b) {\n+        return (int)(a \/ b);\n+    }\n+\n+    static int scalar_fma(int a, int b, int c) {\n+        return (int)(Math.fma(a, b, c));\n+    }\n+\n+    static int scalar_abs(int a) {\n+        return (int)(Math.abs(a));\n+    }\n+\n+    static int scalar_neg(int a) {\n+        return ((int)-a);\n+    }\n+\n+    static int scalar_sin(int a) {\n+        return (int)Math.sin((double)a);\n+    }\n+\n+    static int scalar_exp(int a) {\n+        return (int)Math.exp((double)a);\n+    }\n+\n+    static int scalar_log1p(int a) {\n+        return (int)Math.log1p((double)a);\n+    }\n+\n+    static int scalar_log(int a) {\n+        return (int)Math.log((double)a);\n+    }\n+\n+    static int scalar_log10(int a) {\n+        return (int)Math.log10((double)a);\n+    }\n+\n+    static int scalar_expm1(int a) {\n+        return (int)Math.expm1((double)a);\n+    }\n+\n+    static int scalar_cos(int a) {\n+        return (int)Math.cos((double)a);\n+    }\n+\n+    static int scalar_tan(int a) {\n+        return (int)Math.tan((double)a);\n+    }\n+\n+    static int scalar_sinh(int a) {\n+        return (int)Math.sinh((double)a);\n+    }\n+\n+    static int scalar_cosh(int a) {\n+        return (int)Math.cosh((double)a);\n+    }\n+\n+    static int scalar_tanh(int a) {\n+        return (int)Math.tanh((double)a);\n+    }\n+\n+    static int scalar_asin(int a) {\n+        return (int)Math.asin((double)a);\n+    }\n+\n+    static int scalar_acos(int a) {\n+        return (int)Math.acos((double)a);\n+    }\n+\n+    static int scalar_atan(int a) {\n+        return (int)Math.atan((double)a);\n+    }\n+\n+    static int scalar_cbrt(int a) {\n+        return (int)Math.cbrt((double)a);\n+    }\n+\n+    static int scalar_sqrt(int a) {\n+        return (int)Math.sqrt((double)a);\n+    }\n+\n+    static int scalar_hypot(int a, int b) {\n+        return (int)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static int scalar_pow(int a, int b) {\n+        return (int)Math.pow((double)a, (double)b);\n+    }\n+\n+    static int scalar_atan2(int a, int b) {\n+        return (int)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static int strict_scalar_sin(int a) {\n+        return (int)StrictMath.sin((double)a);\n+    }\n+\n+    static int strict_scalar_exp(int a) {\n+        return (int)StrictMath.exp((double)a);\n+    }\n+\n+    static int strict_scalar_log1p(int a) {\n+        return (int)StrictMath.log1p((double)a);\n+    }\n+\n+    static int strict_scalar_log(int a) {\n+        return (int)StrictMath.log((double)a);\n+    }\n+\n+    static int strict_scalar_log10(int a) {\n+        return (int)StrictMath.log10((double)a);\n+    }\n+\n+    static int strict_scalar_expm1(int a) {\n+        return (int)StrictMath.expm1((double)a);\n+    }\n+\n+    static int strict_scalar_cos(int a) {\n+        return (int)StrictMath.cos((double)a);\n+    }\n+\n+    static int strict_scalar_tan(int a) {\n+        return (int)StrictMath.tan((double)a);\n+    }\n+\n+    static int strict_scalar_sinh(int a) {\n+        return (int)StrictMath.sinh((double)a);\n+    }\n+\n+    static int strict_scalar_cosh(int a) {\n+        return (int)StrictMath.cosh((double)a);\n+    }\n+\n+    static int strict_scalar_tanh(int a) {\n+        return (int)StrictMath.tanh((double)a);\n+    }\n+\n+    static int strict_scalar_asin(int a) {\n+        return (int)StrictMath.asin((double)a);\n+    }\n+\n+    static int strict_scalar_acos(int a) {\n+        return (int)StrictMath.acos((double)a);\n+    }\n+\n+    static int strict_scalar_atan(int a) {\n+        return (int)StrictMath.atan((double)a);\n+    }\n+\n+    static int strict_scalar_cbrt(int a) {\n+        return (int)StrictMath.cbrt((double)a);\n+    }\n+\n+    static int strict_scalar_sqrt(int a) {\n+        return (int)StrictMath.sqrt((double)a);\n+    }\n+\n+    static int strict_scalar_hypot(int a, int b) {\n+        return (int)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static int strict_scalar_pow(int a, int b) {\n+        return (int)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static int strict_scalar_atan2(int a, int b) {\n+        return (int)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static int additiveIdentity() {\n+        return (int)0;\n+    }\n+\n+\n@@ -1450,2 +1715,10 @@\n-    static int firstNonZero(int a, int b) {\n-        return Integer.compare(a, (int) 0) != 0 ? a : b;\n+    static int zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static int maxValue() {\n+        return Integer.MAX_VALUE;\n+    }\n+\n+    static int minValue() {\n+        return Integer.MIN_VALUE;\n@@ -1454,0 +1727,1 @@\n+\n@@ -1489,1 +1763,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1504,1 +1778,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1510,1 +1784,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1516,1 +1790,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1531,1 +1805,1 @@\n-        Assert.assertEquals(asIntegral.species(), SPECIES);\n+        AssertEquals(asIntegral.species(), SPECIES);\n@@ -1539,3 +1813,3 @@\n-        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n-        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n-        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n+        AssertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        AssertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n@@ -1566,1 +1840,1 @@\n-        return (int)(a + b);\n+        return (int)(scalar_add(a, b));\n@@ -1587,1 +1861,1 @@\n-        return (int)(a + b);\n+        return (int)(scalar_add(a, b));\n@@ -1644,1 +1918,1 @@\n-        return (int)(a - b);\n+        return (int)(scalar_sub(a, b));\n@@ -1665,1 +1939,1 @@\n-        return (int)(a - b);\n+        return (int)(scalar_sub(a, b));\n@@ -1722,1 +1996,1 @@\n-        return (int)(a * b);\n+        return (int)(scalar_mul(a, b));\n@@ -1743,1 +2017,1 @@\n-        return (int)(a * b);\n+        return (int)(scalar_mul(a, b));\n@@ -1890,1 +2164,1 @@\n-        return (int)((a)!=0?a:b);\n+        return (int)(firstNonZero(a, b));\n@@ -3079,2 +3353,0 @@\n-    static IntVector bv_MIN = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3089,1 +3361,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -3096,2 +3368,0 @@\n-    static IntVector bv_min = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3106,1 +3376,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -3113,2 +3383,0 @@\n-    static IntVector bv_MIN_M = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3125,1 +3393,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -3132,2 +3400,0 @@\n-    static IntVector bv_MAX = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3142,1 +3408,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -3149,2 +3415,0 @@\n-    static IntVector bv_max = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3159,1 +3423,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -3166,2 +3430,0 @@\n-    static IntVector bv_MAX_M = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3178,1 +3440,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -3186,1 +3448,1 @@\n-        return (int)(Math.min(a, b));\n+        return (int)(scalar_min(a, b));\n@@ -3207,1 +3469,1 @@\n-        return (int)(Math.min(a, b));\n+        return (int)(scalar_min(a, b));\n@@ -3226,1 +3488,1 @@\n-        return (int)(Math.max(a, b));\n+        return (int)(scalar_max(a, b));\n@@ -3247,1 +3509,1 @@\n-        return (int)(Math.max(a, b));\n+        return (int)(scalar_max(a, b));\n@@ -3615,1 +3877,1 @@\n-            res &= a[i];\n+            res = scalar_and(res, a[i]);\n@@ -3624,1 +3886,1 @@\n-            res &= ANDReduce(a, i);\n+            res = scalar_and(res, ANDReduce(a, i));\n@@ -3647,1 +3909,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND));\n@@ -3659,1 +3921,1 @@\n-                res &= a[i];\n+                res = scalar_and(res, a[i]);\n@@ -3668,1 +3930,1 @@\n-            res &= ANDReduceMasked(a, i, mask);\n+            res = scalar_and(res, ANDReduceMasked(a, i, mask));\n@@ -3693,1 +3955,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND, vmask));\n@@ -3704,1 +3966,1 @@\n-            res |= a[i];\n+            res = scalar_or(res, a[i]);\n@@ -3713,1 +3975,1 @@\n-            res |= ORReduce(a, i);\n+            res = scalar_or(res, ORReduce(a, i));\n@@ -3736,1 +3998,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR));\n@@ -3748,1 +4010,1 @@\n-                res |= a[i];\n+                res = scalar_or(res, a[i]);\n@@ -3757,1 +4019,1 @@\n-            res |= ORReduceMasked(a, i, mask);\n+            res = scalar_or(res, ORReduceMasked(a, i, mask));\n@@ -3782,1 +4044,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR, vmask));\n@@ -3793,1 +4055,1 @@\n-            res ^= a[i];\n+            res = scalar_xor(res, a[i]);\n@@ -3802,1 +4064,1 @@\n-            res ^= XORReduce(a, i);\n+            res = scalar_xor(res, XORReduce(a, i));\n@@ -3825,1 +4087,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR));\n@@ -3837,1 +4099,1 @@\n-                res ^= a[i];\n+                res = scalar_xor(res, a[i]);\n@@ -3846,1 +4108,1 @@\n-            res ^= XORReduceMasked(a, i, mask);\n+            res = scalar_xor(res, XORReduceMasked(a, i, mask));\n@@ -3871,1 +4133,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR, vmask));\n@@ -3880,1 +4142,1 @@\n-        int res = 0;\n+        int res = additiveIdentity();\n@@ -3882,1 +4144,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -3889,1 +4151,1 @@\n-        int res = 0;\n+        int res = additiveIdentity();\n@@ -3891,1 +4153,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -3901,1 +4163,1 @@\n-        int ra = 0;\n+        int ra = additiveIdentity();\n@@ -3911,1 +4173,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3914,1 +4176,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -3923,1 +4185,1 @@\n-        int res = 0;\n+        int res = additiveIdentity();\n@@ -3926,1 +4188,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -3933,1 +4195,1 @@\n-        int res = 0;\n+        int res = additiveIdentity();\n@@ -3935,1 +4197,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -3947,1 +4209,1 @@\n-        int ra = 0;\n+        int ra = additiveIdentity();\n@@ -3957,1 +4219,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3960,1 +4222,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -3969,1 +4231,1 @@\n-        int res = 1;\n+        int res = multiplicativeIdentity();\n@@ -3971,1 +4233,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -3978,1 +4240,1 @@\n-        int res = 1;\n+        int res = multiplicativeIdentity();\n@@ -3980,1 +4242,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -3990,1 +4252,1 @@\n-        int ra = 1;\n+        int ra = multiplicativeIdentity();\n@@ -4000,1 +4262,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -4003,1 +4265,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -4012,1 +4274,1 @@\n-        int res = 1;\n+        int res = multiplicativeIdentity();\n@@ -4015,1 +4277,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -4022,1 +4284,1 @@\n-        int res = 1;\n+        int res = multiplicativeIdentity();\n@@ -4024,1 +4286,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -4036,1 +4298,1 @@\n-        int ra = 1;\n+        int ra = multiplicativeIdentity();\n@@ -4046,1 +4308,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -4049,1 +4311,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -4058,1 +4320,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4060,1 +4322,1 @@\n-            res = (int) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -4067,1 +4329,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4069,1 +4331,1 @@\n-            res = (int) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -4079,1 +4341,1 @@\n-        int ra = Integer.MAX_VALUE;\n+        int ra = maxValue();\n@@ -4089,1 +4351,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = maxValue();\n@@ -4092,1 +4354,1 @@\n-                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -4101,1 +4363,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4104,1 +4366,1 @@\n-                res = (int) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -4111,1 +4373,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4113,1 +4375,1 @@\n-            res = (int) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -4125,1 +4387,1 @@\n-        int ra = Integer.MAX_VALUE;\n+        int ra = maxValue();\n@@ -4135,1 +4397,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = maxValue();\n@@ -4138,1 +4400,1 @@\n-                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -4147,1 +4409,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4149,1 +4411,1 @@\n-            res = (int) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -4156,1 +4418,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4158,1 +4420,1 @@\n-            res = (int) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -4168,1 +4430,1 @@\n-        int ra = Integer.MIN_VALUE;\n+        int ra = minValue();\n@@ -4178,1 +4440,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = minValue();\n@@ -4181,1 +4443,1 @@\n-                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -4190,1 +4452,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4193,1 +4455,1 @@\n-                res = (int) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -4200,1 +4462,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4202,1 +4464,1 @@\n-            res = (int) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -4214,1 +4476,1 @@\n-        int ra = Integer.MIN_VALUE;\n+        int ra = minValue();\n@@ -4224,1 +4486,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = minValue();\n@@ -4227,1 +4489,1 @@\n-                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -4236,1 +4498,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4245,1 +4507,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4257,1 +4519,1 @@\n-        int ra = Integer.MAX_VALUE;\n+        int ra = maxValue();\n@@ -4267,1 +4529,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = maxValue();\n@@ -4279,1 +4541,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4289,1 +4551,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4303,1 +4565,1 @@\n-        int ra = Integer.MAX_VALUE;\n+        int ra = maxValue();\n@@ -4313,1 +4575,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = maxValue();\n@@ -4325,1 +4587,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4334,1 +4596,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4346,1 +4608,1 @@\n-        int ra = Integer.MIN_VALUE;\n+        int ra = minValue();\n@@ -4356,1 +4618,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = minValue();\n@@ -4368,1 +4630,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4378,1 +4640,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4392,1 +4654,1 @@\n-        int ra = Integer.MIN_VALUE;\n+        int ra = minValue();\n@@ -4402,1 +4664,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = minValue();\n@@ -4414,1 +4676,1 @@\n-        int res = (int) 0;\n+        int res = zeroValue();\n@@ -4423,1 +4685,1 @@\n-        int res = (int) 0;\n+        int res = zeroValue();\n@@ -4435,1 +4697,1 @@\n-        int ra = (int) 0;\n+        int ra = zeroValue();\n@@ -4445,1 +4707,1 @@\n-            ra = (int) 0;\n+            ra = zeroValue();\n@@ -4457,1 +4719,1 @@\n-        int res = (int) 0;\n+        int res = zeroValue();\n@@ -4467,1 +4729,1 @@\n-        int res = (int) 0;\n+        int res = zeroValue();\n@@ -4481,1 +4743,1 @@\n-        int ra = (int) 0;\n+        int ra = zeroValue();\n@@ -4491,1 +4753,1 @@\n-            ra = (int) 0;\n+            ra = zeroValue();\n@@ -4551,1 +4813,1 @@\n-        int res = 0;\n+        int res = zeroValue();\n@@ -4560,1 +4822,1 @@\n-        int res = 0;\n+        int res = zeroValue();\n@@ -4572,1 +4834,1 @@\n-        int ra = 0;\n+        int ra = zeroValue();\n@@ -4582,1 +4844,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4594,1 +4856,1 @@\n-        int res = 0;\n+        int res = zeroValue();\n@@ -4604,1 +4866,1 @@\n-        int res = 0;\n+        int res = zeroValue();\n@@ -4617,1 +4879,1 @@\n-        int ra = 0;\n+        int ra = zeroValue();\n@@ -4627,1 +4889,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4672,1 +4934,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -4692,1 +4954,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -4713,1 +4975,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -4733,1 +4995,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -4752,1 +5014,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4771,1 +5033,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4794,1 +5056,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -4813,1 +5075,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -4836,1 +5098,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -4855,1 +5117,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4874,1 +5136,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4897,1 +5159,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -4916,1 +5178,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -4939,1 +5201,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -4958,1 +5220,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -4981,1 +5243,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -5000,1 +5262,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -5023,1 +5285,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -5042,1 +5304,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n@@ -5065,1 +5327,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n@@ -5084,1 +5346,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n@@ -5107,1 +5369,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -5126,1 +5388,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n@@ -5149,1 +5411,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n@@ -5168,1 +5430,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n@@ -5191,1 +5453,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n@@ -5208,1 +5470,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -5228,1 +5490,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -5244,1 +5506,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < (int)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (int)((long)b[i])));\n@@ -5264,1 +5526,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < (int)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(int)((long)b[i]))));\n@@ -5280,1 +5542,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -5300,1 +5562,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -5316,1 +5578,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == (int)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (int)((long)b[i])));\n@@ -5336,1 +5598,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == (int)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(int)((long)b[i]))));\n@@ -5617,1 +5879,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -6048,1 +6310,1 @@\n-        return (int)(-((int)a));\n+        return (int)(scalar_neg((int)a));\n@@ -6052,1 +6314,1 @@\n-        return (int)(-((int)a));\n+        return (int)(scalar_neg((int)a));\n@@ -6104,1 +6366,1 @@\n-        return (int)(Math.abs((int)a));\n+        return (int)(scalar_abs((int)a));\n@@ -6108,1 +6370,1 @@\n-        return (int)(Math.abs((int)a));\n+        return (int)(scalar_abs((int)a));\n@@ -6448,1 +6710,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -6464,1 +6726,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -6560,1 +6822,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6601,1 +6863,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6704,1 +6966,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -6732,1 +6994,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -6746,1 +7008,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -6943,1 +7205,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -6963,1 +7225,1 @@\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -6986,1 +7248,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -7000,1 +7262,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -7022,1 +7284,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -7030,1 +7292,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -7037,1 +7299,1 @@\n-        Assert.assertEquals(elsize, Integer.SIZE);\n+        AssertEquals(elsize, Integer.SIZE);\n@@ -7056,1 +7318,1 @@\n-    static void ElementTypeInt512VectorTestsSmokeTest() {\n+    static void IntInt512VectorTestsSmokeTest() {\n@@ -7091,1 +7353,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":595,"deletions":333,"binary":false,"changes":928,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,45 @@\n+    static IntVector bcast_vec = IntVector.broadcast(SPECIES, (int)10);\n+\n+    static void AssertEquals(int actual, int expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(int actual, int expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(int actual, int expected, int delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(int actual, int expected, int delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(int [] actual, int [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(int [] actual, int [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -87,1 +132,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -90,1 +135,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -102,1 +147,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -108,1 +153,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -118,1 +163,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -121,1 +166,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -137,1 +182,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -139,1 +184,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -142,2 +187,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -159,1 +204,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -161,1 +206,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -164,2 +209,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -181,1 +226,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -183,1 +228,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -186,2 +231,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -203,1 +248,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -205,1 +250,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -208,2 +253,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -221,1 +266,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -224,1 +269,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -236,1 +281,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -239,1 +284,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -248,1 +293,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -253,1 +298,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -264,1 +309,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -269,1 +314,1 @@\n-                    Assert.assertEquals(r[i + k], (int)0);\n+                    AssertEquals(r[i + k], (int)0);\n@@ -275,1 +320,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -277,1 +322,1 @@\n-                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (int)0, \"at index #\" + idx);\n@@ -289,1 +334,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -292,1 +337,1 @@\n-                        Assert.assertEquals(r[i + j], (int)0);\n+                        AssertEquals(r[i + j], (int)0);\n@@ -299,1 +344,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -301,1 +346,1 @@\n-                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (int)0, \"at index #\" + idx);\n@@ -317,1 +362,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -321,1 +366,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -327,0 +372,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -330,1 +376,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -334,2 +382,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -345,1 +392,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -347,1 +394,1 @@\n-                         Assert.assertEquals(r[i+j], (int)0);\n+                         AssertEquals(r[i+j], (int)0);\n@@ -353,1 +400,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -355,1 +402,1 @@\n-                Assert.assertEquals(r[i+j], (int)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (int)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -361,0 +408,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -364,0 +412,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -365,1 +415,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -367,1 +417,1 @@\n-                         Assert.assertEquals(r[i+j], (int)0);\n+                         AssertEquals(r[i+j], (int)0);\n@@ -371,1 +421,0 @@\n-            int idx = i + j;\n@@ -373,1 +422,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -375,1 +424,1 @@\n-                Assert.assertEquals(r[i+j], (int)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (int)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -389,1 +438,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -392,1 +441,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -413,1 +462,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -416,1 +465,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -419,1 +468,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -422,3 +471,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -439,1 +488,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -442,1 +491,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -445,1 +494,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -448,3 +497,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -458,1 +507,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -461,1 +510,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -469,1 +518,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -472,1 +521,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -480,1 +529,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -483,1 +532,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -492,1 +541,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -495,1 +544,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -508,1 +557,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -511,1 +560,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -523,1 +572,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -526,1 +575,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -538,1 +587,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -541,1 +590,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -556,1 +605,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -559,1 +608,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -572,1 +621,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -576,1 +625,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -590,1 +639,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -594,1 +643,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -616,1 +665,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -620,1 +669,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -634,1 +683,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -638,1 +687,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -658,1 +707,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -661,1 +710,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -673,1 +722,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -676,1 +725,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -685,1 +734,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -688,1 +737,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -698,1 +747,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -701,1 +750,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -717,1 +766,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -721,1 +770,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -738,1 +787,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -742,1 +791,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -753,1 +802,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -757,1 +806,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -774,1 +823,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -778,1 +827,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -796,1 +845,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -802,1 +851,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -823,1 +872,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -829,1 +878,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -844,1 +893,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -850,1 +899,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -871,1 +920,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -877,1 +926,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -891,1 +940,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -897,1 +946,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -912,1 +961,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -918,1 +967,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -933,1 +982,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -939,1 +988,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -955,1 +1004,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -961,1 +1010,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -969,0 +1018,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -974,1 +1027,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -977,1 +1030,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -987,1 +1040,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -990,1 +1043,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -998,1 +1051,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                AssertEquals(r[i], (double)(a[i+offs]));\n@@ -1001,1 +1054,1 @@\n-            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1010,1 +1063,1 @@\n-            withToString(\"int[-i * 5]\", (int s) -> {\n+            withToString(\"Integer[-i * 5]\", (int s) -> {\n@@ -1012,1 +1065,1 @@\n-                            i -> (int)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1014,1 +1067,1 @@\n-            withToString(\"int[i * 5]\", (int s) -> {\n+            withToString(\"Integer[i * 5]\", (int s) -> {\n@@ -1016,1 +1069,1 @@\n-                            i -> (int)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1018,1 +1071,1 @@\n-            withToString(\"int[i + 1]\", (int s) -> {\n+            withToString(\"Integer[i + 1]\", (int s) -> {\n@@ -1020,1 +1073,1 @@\n-                            i -> (((int)(i + 1) == 0) ? 1 : (int)(i + 1)));\n+                            i -> (((int)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1434,0 +1487,212 @@\n+    static int firstNonZero(int a, int b) {\n+        return Integer.compare(a, (int) 0) != 0 ? a : b;\n+    }\n+\n+    static int multiplicativeIdentity() {\n+        return (int)1;\n+    }\n+\n+    static int scalar_or(int a, int b) {\n+        return (int)(a | b);\n+    }\n+\n+    static int scalar_and(int a, int b) {\n+        return (int)(a & b);\n+    }\n+\n+    static int scalar_xor(int a, int b) {\n+        return (int)(a ^ b);\n+    }\n+\n+    static int scalar_add(int a, int b) {\n+        return (int)(a + b);\n+    }\n+\n+    static int scalar_sub(int a, int b) {\n+        return (int)(a - b);\n+    }\n+\n+    static int scalar_mul(int a, int b) {\n+        return (int)(a * b);\n+    }\n+\n+    static int scalar_min(int a, int b) {\n+        return (int)(Math.min(a, b));\n+    }\n+\n+    static int scalar_max(int a, int b) {\n+        return (int)(Math.max(a, b));\n+    }\n+\n+    static int scalar_div(int a, int b) {\n+        return (int)(a \/ b);\n+    }\n+\n+    static int scalar_fma(int a, int b, int c) {\n+        return (int)(Math.fma(a, b, c));\n+    }\n+\n+    static int scalar_abs(int a) {\n+        return (int)(Math.abs(a));\n+    }\n+\n+    static int scalar_neg(int a) {\n+        return ((int)-a);\n+    }\n+\n+    static int scalar_sin(int a) {\n+        return (int)Math.sin((double)a);\n+    }\n+\n+    static int scalar_exp(int a) {\n+        return (int)Math.exp((double)a);\n+    }\n+\n+    static int scalar_log1p(int a) {\n+        return (int)Math.log1p((double)a);\n+    }\n+\n+    static int scalar_log(int a) {\n+        return (int)Math.log((double)a);\n+    }\n+\n+    static int scalar_log10(int a) {\n+        return (int)Math.log10((double)a);\n+    }\n+\n+    static int scalar_expm1(int a) {\n+        return (int)Math.expm1((double)a);\n+    }\n+\n+    static int scalar_cos(int a) {\n+        return (int)Math.cos((double)a);\n+    }\n+\n+    static int scalar_tan(int a) {\n+        return (int)Math.tan((double)a);\n+    }\n+\n+    static int scalar_sinh(int a) {\n+        return (int)Math.sinh((double)a);\n+    }\n+\n+    static int scalar_cosh(int a) {\n+        return (int)Math.cosh((double)a);\n+    }\n+\n+    static int scalar_tanh(int a) {\n+        return (int)Math.tanh((double)a);\n+    }\n+\n+    static int scalar_asin(int a) {\n+        return (int)Math.asin((double)a);\n+    }\n+\n+    static int scalar_acos(int a) {\n+        return (int)Math.acos((double)a);\n+    }\n+\n+    static int scalar_atan(int a) {\n+        return (int)Math.atan((double)a);\n+    }\n+\n+    static int scalar_cbrt(int a) {\n+        return (int)Math.cbrt((double)a);\n+    }\n+\n+    static int scalar_sqrt(int a) {\n+        return (int)Math.sqrt((double)a);\n+    }\n+\n+    static int scalar_hypot(int a, int b) {\n+        return (int)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static int scalar_pow(int a, int b) {\n+        return (int)Math.pow((double)a, (double)b);\n+    }\n+\n+    static int scalar_atan2(int a, int b) {\n+        return (int)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static int strict_scalar_sin(int a) {\n+        return (int)StrictMath.sin((double)a);\n+    }\n+\n+    static int strict_scalar_exp(int a) {\n+        return (int)StrictMath.exp((double)a);\n+    }\n+\n+    static int strict_scalar_log1p(int a) {\n+        return (int)StrictMath.log1p((double)a);\n+    }\n+\n+    static int strict_scalar_log(int a) {\n+        return (int)StrictMath.log((double)a);\n+    }\n+\n+    static int strict_scalar_log10(int a) {\n+        return (int)StrictMath.log10((double)a);\n+    }\n+\n+    static int strict_scalar_expm1(int a) {\n+        return (int)StrictMath.expm1((double)a);\n+    }\n+\n+    static int strict_scalar_cos(int a) {\n+        return (int)StrictMath.cos((double)a);\n+    }\n+\n+    static int strict_scalar_tan(int a) {\n+        return (int)StrictMath.tan((double)a);\n+    }\n+\n+    static int strict_scalar_sinh(int a) {\n+        return (int)StrictMath.sinh((double)a);\n+    }\n+\n+    static int strict_scalar_cosh(int a) {\n+        return (int)StrictMath.cosh((double)a);\n+    }\n+\n+    static int strict_scalar_tanh(int a) {\n+        return (int)StrictMath.tanh((double)a);\n+    }\n+\n+    static int strict_scalar_asin(int a) {\n+        return (int)StrictMath.asin((double)a);\n+    }\n+\n+    static int strict_scalar_acos(int a) {\n+        return (int)StrictMath.acos((double)a);\n+    }\n+\n+    static int strict_scalar_atan(int a) {\n+        return (int)StrictMath.atan((double)a);\n+    }\n+\n+    static int strict_scalar_cbrt(int a) {\n+        return (int)StrictMath.cbrt((double)a);\n+    }\n+\n+    static int strict_scalar_sqrt(int a) {\n+        return (int)StrictMath.sqrt((double)a);\n+    }\n+\n+    static int strict_scalar_hypot(int a, int b) {\n+        return (int)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static int strict_scalar_pow(int a, int b) {\n+        return (int)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static int strict_scalar_atan2(int a, int b) {\n+        return (int)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static int additiveIdentity() {\n+        return (int)0;\n+    }\n+\n+\n@@ -1450,2 +1715,10 @@\n-    static int firstNonZero(int a, int b) {\n-        return Integer.compare(a, (int) 0) != 0 ? a : b;\n+    static int zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static int maxValue() {\n+        return Integer.MAX_VALUE;\n+    }\n+\n+    static int minValue() {\n+        return Integer.MIN_VALUE;\n@@ -1454,0 +1727,1 @@\n+\n@@ -1489,1 +1763,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1504,1 +1778,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1510,1 +1784,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1516,1 +1790,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1531,1 +1805,1 @@\n-        Assert.assertEquals(asIntegral.species(), SPECIES);\n+        AssertEquals(asIntegral.species(), SPECIES);\n@@ -1539,3 +1813,3 @@\n-        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n-        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n-        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n+        AssertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        AssertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n@@ -1566,1 +1840,1 @@\n-        return (int)(a + b);\n+        return (int)(scalar_add(a, b));\n@@ -1587,1 +1861,1 @@\n-        return (int)(a + b);\n+        return (int)(scalar_add(a, b));\n@@ -1644,1 +1918,1 @@\n-        return (int)(a - b);\n+        return (int)(scalar_sub(a, b));\n@@ -1665,1 +1939,1 @@\n-        return (int)(a - b);\n+        return (int)(scalar_sub(a, b));\n@@ -1722,1 +1996,1 @@\n-        return (int)(a * b);\n+        return (int)(scalar_mul(a, b));\n@@ -1743,1 +2017,1 @@\n-        return (int)(a * b);\n+        return (int)(scalar_mul(a, b));\n@@ -1890,1 +2164,1 @@\n-        return (int)((a)!=0?a:b);\n+        return (int)(firstNonZero(a, b));\n@@ -3079,2 +3353,0 @@\n-    static IntVector bv_MIN = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3089,1 +3361,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -3096,2 +3368,0 @@\n-    static IntVector bv_min = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3106,1 +3376,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -3113,2 +3383,0 @@\n-    static IntVector bv_MIN_M = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3125,1 +3393,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -3132,2 +3400,0 @@\n-    static IntVector bv_MAX = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3142,1 +3408,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -3149,2 +3415,0 @@\n-    static IntVector bv_max = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3159,1 +3423,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -3166,2 +3430,0 @@\n-    static IntVector bv_MAX_M = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3178,1 +3440,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -3186,1 +3448,1 @@\n-        return (int)(Math.min(a, b));\n+        return (int)(scalar_min(a, b));\n@@ -3207,1 +3469,1 @@\n-        return (int)(Math.min(a, b));\n+        return (int)(scalar_min(a, b));\n@@ -3226,1 +3488,1 @@\n-        return (int)(Math.max(a, b));\n+        return (int)(scalar_max(a, b));\n@@ -3247,1 +3509,1 @@\n-        return (int)(Math.max(a, b));\n+        return (int)(scalar_max(a, b));\n@@ -3615,1 +3877,1 @@\n-            res &= a[i];\n+            res = scalar_and(res, a[i]);\n@@ -3624,1 +3886,1 @@\n-            res &= ANDReduce(a, i);\n+            res = scalar_and(res, ANDReduce(a, i));\n@@ -3647,1 +3909,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND));\n@@ -3659,1 +3921,1 @@\n-                res &= a[i];\n+                res = scalar_and(res, a[i]);\n@@ -3668,1 +3930,1 @@\n-            res &= ANDReduceMasked(a, i, mask);\n+            res = scalar_and(res, ANDReduceMasked(a, i, mask));\n@@ -3693,1 +3955,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND, vmask));\n@@ -3704,1 +3966,1 @@\n-            res |= a[i];\n+            res = scalar_or(res, a[i]);\n@@ -3713,1 +3975,1 @@\n-            res |= ORReduce(a, i);\n+            res = scalar_or(res, ORReduce(a, i));\n@@ -3736,1 +3998,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR));\n@@ -3748,1 +4010,1 @@\n-                res |= a[i];\n+                res = scalar_or(res, a[i]);\n@@ -3757,1 +4019,1 @@\n-            res |= ORReduceMasked(a, i, mask);\n+            res = scalar_or(res, ORReduceMasked(a, i, mask));\n@@ -3782,1 +4044,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR, vmask));\n@@ -3793,1 +4055,1 @@\n-            res ^= a[i];\n+            res = scalar_xor(res, a[i]);\n@@ -3802,1 +4064,1 @@\n-            res ^= XORReduce(a, i);\n+            res = scalar_xor(res, XORReduce(a, i));\n@@ -3825,1 +4087,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR));\n@@ -3837,1 +4099,1 @@\n-                res ^= a[i];\n+                res = scalar_xor(res, a[i]);\n@@ -3846,1 +4108,1 @@\n-            res ^= XORReduceMasked(a, i, mask);\n+            res = scalar_xor(res, XORReduceMasked(a, i, mask));\n@@ -3871,1 +4133,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR, vmask));\n@@ -3880,1 +4142,1 @@\n-        int res = 0;\n+        int res = additiveIdentity();\n@@ -3882,1 +4144,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -3889,1 +4151,1 @@\n-        int res = 0;\n+        int res = additiveIdentity();\n@@ -3891,1 +4153,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -3901,1 +4163,1 @@\n-        int ra = 0;\n+        int ra = additiveIdentity();\n@@ -3911,1 +4173,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3914,1 +4176,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -3923,1 +4185,1 @@\n-        int res = 0;\n+        int res = additiveIdentity();\n@@ -3926,1 +4188,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -3933,1 +4195,1 @@\n-        int res = 0;\n+        int res = additiveIdentity();\n@@ -3935,1 +4197,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -3947,1 +4209,1 @@\n-        int ra = 0;\n+        int ra = additiveIdentity();\n@@ -3957,1 +4219,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3960,1 +4222,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -3969,1 +4231,1 @@\n-        int res = 1;\n+        int res = multiplicativeIdentity();\n@@ -3971,1 +4233,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -3978,1 +4240,1 @@\n-        int res = 1;\n+        int res = multiplicativeIdentity();\n@@ -3980,1 +4242,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -3990,1 +4252,1 @@\n-        int ra = 1;\n+        int ra = multiplicativeIdentity();\n@@ -4000,1 +4262,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -4003,1 +4265,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -4012,1 +4274,1 @@\n-        int res = 1;\n+        int res = multiplicativeIdentity();\n@@ -4015,1 +4277,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -4022,1 +4284,1 @@\n-        int res = 1;\n+        int res = multiplicativeIdentity();\n@@ -4024,1 +4286,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -4036,1 +4298,1 @@\n-        int ra = 1;\n+        int ra = multiplicativeIdentity();\n@@ -4046,1 +4308,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -4049,1 +4311,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -4058,1 +4320,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4060,1 +4322,1 @@\n-            res = (int) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -4067,1 +4329,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4069,1 +4331,1 @@\n-            res = (int) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -4079,1 +4341,1 @@\n-        int ra = Integer.MAX_VALUE;\n+        int ra = maxValue();\n@@ -4089,1 +4351,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = maxValue();\n@@ -4092,1 +4354,1 @@\n-                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -4101,1 +4363,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4104,1 +4366,1 @@\n-                res = (int) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -4111,1 +4373,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4113,1 +4375,1 @@\n-            res = (int) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -4125,1 +4387,1 @@\n-        int ra = Integer.MAX_VALUE;\n+        int ra = maxValue();\n@@ -4135,1 +4397,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = maxValue();\n@@ -4138,1 +4400,1 @@\n-                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -4147,1 +4409,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4149,1 +4411,1 @@\n-            res = (int) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -4156,1 +4418,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4158,1 +4420,1 @@\n-            res = (int) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -4168,1 +4430,1 @@\n-        int ra = Integer.MIN_VALUE;\n+        int ra = minValue();\n@@ -4178,1 +4440,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = minValue();\n@@ -4181,1 +4443,1 @@\n-                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -4190,1 +4452,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4193,1 +4455,1 @@\n-                res = (int) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -4200,1 +4462,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4202,1 +4464,1 @@\n-            res = (int) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -4214,1 +4476,1 @@\n-        int ra = Integer.MIN_VALUE;\n+        int ra = minValue();\n@@ -4224,1 +4486,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = minValue();\n@@ -4227,1 +4489,1 @@\n-                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -4236,1 +4498,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4245,1 +4507,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4257,1 +4519,1 @@\n-        int ra = Integer.MAX_VALUE;\n+        int ra = maxValue();\n@@ -4267,1 +4529,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = maxValue();\n@@ -4279,1 +4541,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4289,1 +4551,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4303,1 +4565,1 @@\n-        int ra = Integer.MAX_VALUE;\n+        int ra = maxValue();\n@@ -4313,1 +4575,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = maxValue();\n@@ -4325,1 +4587,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4334,1 +4596,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4346,1 +4608,1 @@\n-        int ra = Integer.MIN_VALUE;\n+        int ra = minValue();\n@@ -4356,1 +4618,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = minValue();\n@@ -4368,1 +4630,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4378,1 +4640,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4392,1 +4654,1 @@\n-        int ra = Integer.MIN_VALUE;\n+        int ra = minValue();\n@@ -4402,1 +4664,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = minValue();\n@@ -4414,1 +4676,1 @@\n-        int res = (int) 0;\n+        int res = zeroValue();\n@@ -4423,1 +4685,1 @@\n-        int res = (int) 0;\n+        int res = zeroValue();\n@@ -4435,1 +4697,1 @@\n-        int ra = (int) 0;\n+        int ra = zeroValue();\n@@ -4445,1 +4707,1 @@\n-            ra = (int) 0;\n+            ra = zeroValue();\n@@ -4457,1 +4719,1 @@\n-        int res = (int) 0;\n+        int res = zeroValue();\n@@ -4467,1 +4729,1 @@\n-        int res = (int) 0;\n+        int res = zeroValue();\n@@ -4481,1 +4743,1 @@\n-        int ra = (int) 0;\n+        int ra = zeroValue();\n@@ -4491,1 +4753,1 @@\n-            ra = (int) 0;\n+            ra = zeroValue();\n@@ -4551,1 +4813,1 @@\n-        int res = 0;\n+        int res = zeroValue();\n@@ -4560,1 +4822,1 @@\n-        int res = 0;\n+        int res = zeroValue();\n@@ -4572,1 +4834,1 @@\n-        int ra = 0;\n+        int ra = zeroValue();\n@@ -4582,1 +4844,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4594,1 +4856,1 @@\n-        int res = 0;\n+        int res = zeroValue();\n@@ -4604,1 +4866,1 @@\n-        int res = 0;\n+        int res = zeroValue();\n@@ -4617,1 +4879,1 @@\n-        int ra = 0;\n+        int ra = zeroValue();\n@@ -4627,1 +4889,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4672,1 +4934,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -4692,1 +4954,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -4713,1 +4975,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -4733,1 +4995,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -4752,1 +5014,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4771,1 +5033,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4794,1 +5056,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -4813,1 +5075,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -4836,1 +5098,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -4855,1 +5117,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4874,1 +5136,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4897,1 +5159,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -4916,1 +5178,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -4939,1 +5201,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -4958,1 +5220,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -4981,1 +5243,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -5000,1 +5262,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -5023,1 +5285,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -5042,1 +5304,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n@@ -5065,1 +5327,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n@@ -5084,1 +5346,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n@@ -5107,1 +5369,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -5126,1 +5388,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n@@ -5149,1 +5411,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n@@ -5168,1 +5430,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n@@ -5191,1 +5453,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n@@ -5208,1 +5470,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -5228,1 +5490,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -5244,1 +5506,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < (int)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (int)((long)b[i])));\n@@ -5264,1 +5526,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < (int)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(int)((long)b[i]))));\n@@ -5280,1 +5542,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -5300,1 +5562,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -5316,1 +5578,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == (int)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (int)((long)b[i])));\n@@ -5336,1 +5598,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == (int)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(int)((long)b[i]))));\n@@ -5617,1 +5879,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -6048,1 +6310,1 @@\n-        return (int)(-((int)a));\n+        return (int)(scalar_neg((int)a));\n@@ -6052,1 +6314,1 @@\n-        return (int)(-((int)a));\n+        return (int)(scalar_neg((int)a));\n@@ -6104,1 +6366,1 @@\n-        return (int)(Math.abs((int)a));\n+        return (int)(scalar_abs((int)a));\n@@ -6108,1 +6370,1 @@\n-        return (int)(Math.abs((int)a));\n+        return (int)(scalar_abs((int)a));\n@@ -6448,1 +6710,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -6464,1 +6726,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -6560,1 +6822,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6601,1 +6863,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6704,1 +6966,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -6732,1 +6994,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -6746,1 +7008,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -6943,1 +7205,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -6963,1 +7225,1 @@\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -6986,1 +7248,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -7000,1 +7262,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -7022,1 +7284,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -7030,1 +7292,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -7037,1 +7299,1 @@\n-        Assert.assertEquals(elsize, Integer.SIZE);\n+        AssertEquals(elsize, Integer.SIZE);\n@@ -7056,1 +7318,1 @@\n-    static void ElementTypeInt64VectorTestsSmokeTest() {\n+    static void IntInt64VectorTestsSmokeTest() {\n@@ -7091,1 +7353,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":595,"deletions":333,"binary":false,"changes":928,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,45 @@\n+    static IntVector bcast_vec = IntVector.broadcast(SPECIES, (int)10);\n+\n+    static void AssertEquals(int actual, int expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(int actual, int expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(int actual, int expected, int delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(int actual, int expected, int delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(int [] actual, int [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(int [] actual, int [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -92,1 +137,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -95,1 +140,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -107,1 +152,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -113,1 +158,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -123,1 +168,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -126,1 +171,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -142,1 +187,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -144,1 +189,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -147,2 +192,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -164,1 +209,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -166,1 +211,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -169,2 +214,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -186,1 +231,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -188,1 +233,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -191,2 +236,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -208,1 +253,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -210,1 +255,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -213,2 +258,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -226,1 +271,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -229,1 +274,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -241,1 +286,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -244,1 +289,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -253,1 +298,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -258,1 +303,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -269,1 +314,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -274,1 +319,1 @@\n-                    Assert.assertEquals(r[i + k], (int)0);\n+                    AssertEquals(r[i + k], (int)0);\n@@ -280,1 +325,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -282,1 +327,1 @@\n-                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (int)0, \"at index #\" + idx);\n@@ -294,1 +339,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -297,1 +342,1 @@\n-                        Assert.assertEquals(r[i + j], (int)0);\n+                        AssertEquals(r[i + j], (int)0);\n@@ -304,1 +349,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -306,1 +351,1 @@\n-                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (int)0, \"at index #\" + idx);\n@@ -322,1 +367,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -326,1 +371,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -332,0 +377,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -335,1 +381,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -339,2 +387,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -350,1 +397,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -352,1 +399,1 @@\n-                         Assert.assertEquals(r[i+j], (int)0);\n+                         AssertEquals(r[i+j], (int)0);\n@@ -358,1 +405,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -360,1 +407,1 @@\n-                Assert.assertEquals(r[i+j], (int)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (int)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -366,0 +413,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -369,0 +417,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -370,1 +420,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -372,1 +422,1 @@\n-                         Assert.assertEquals(r[i+j], (int)0);\n+                         AssertEquals(r[i+j], (int)0);\n@@ -376,1 +426,0 @@\n-            int idx = i + j;\n@@ -378,1 +427,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -380,1 +429,1 @@\n-                Assert.assertEquals(r[i+j], (int)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (int)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -394,1 +443,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -397,1 +446,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -418,1 +467,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -421,1 +470,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -424,1 +473,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -427,3 +476,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -444,1 +493,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -447,1 +496,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -450,1 +499,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -453,3 +502,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -463,1 +512,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -466,1 +515,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -474,1 +523,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -477,1 +526,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -485,1 +534,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -488,1 +537,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -497,1 +546,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -500,1 +549,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -513,1 +562,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -516,1 +565,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -528,1 +577,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -531,1 +580,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -543,1 +592,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -546,1 +595,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -561,1 +610,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -564,1 +613,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (int)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -577,1 +626,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -581,1 +630,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -595,1 +644,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -599,1 +648,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -621,1 +670,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -625,1 +674,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -639,1 +688,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -643,1 +692,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -663,1 +712,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -666,1 +715,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -678,1 +727,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -681,1 +730,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -690,1 +739,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -693,1 +742,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -703,1 +752,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -706,1 +755,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -722,1 +771,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -726,1 +775,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -743,1 +792,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -747,1 +796,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -758,1 +807,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -762,1 +811,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -779,1 +828,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -783,1 +832,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -801,1 +850,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -807,1 +856,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -828,1 +877,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -834,1 +883,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -849,1 +898,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -855,1 +904,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -876,1 +925,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -882,1 +931,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -896,1 +945,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -902,1 +951,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -917,1 +966,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -923,1 +972,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -938,1 +987,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -944,1 +993,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -960,1 +1009,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -966,1 +1015,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -974,0 +1023,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -979,1 +1032,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -982,1 +1035,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -992,1 +1045,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -995,1 +1048,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1003,1 +1056,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                AssertEquals(r[i], (double)(a[i+offs]));\n@@ -1006,1 +1059,1 @@\n-            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1015,1 +1068,1 @@\n-            withToString(\"int[-i * 5]\", (int s) -> {\n+            withToString(\"Integer[-i * 5]\", (int s) -> {\n@@ -1017,1 +1070,1 @@\n-                            i -> (int)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1019,1 +1072,1 @@\n-            withToString(\"int[i * 5]\", (int s) -> {\n+            withToString(\"Integer[i * 5]\", (int s) -> {\n@@ -1021,1 +1074,1 @@\n-                            i -> (int)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1023,1 +1076,1 @@\n-            withToString(\"int[i + 1]\", (int s) -> {\n+            withToString(\"Integer[i + 1]\", (int s) -> {\n@@ -1025,1 +1078,1 @@\n-                            i -> (((int)(i + 1) == 0) ? 1 : (int)(i + 1)));\n+                            i -> (((int)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1439,0 +1492,212 @@\n+    static int firstNonZero(int a, int b) {\n+        return Integer.compare(a, (int) 0) != 0 ? a : b;\n+    }\n+\n+    static int multiplicativeIdentity() {\n+        return (int)1;\n+    }\n+\n+    static int scalar_or(int a, int b) {\n+        return (int)(a | b);\n+    }\n+\n+    static int scalar_and(int a, int b) {\n+        return (int)(a & b);\n+    }\n+\n+    static int scalar_xor(int a, int b) {\n+        return (int)(a ^ b);\n+    }\n+\n+    static int scalar_add(int a, int b) {\n+        return (int)(a + b);\n+    }\n+\n+    static int scalar_sub(int a, int b) {\n+        return (int)(a - b);\n+    }\n+\n+    static int scalar_mul(int a, int b) {\n+        return (int)(a * b);\n+    }\n+\n+    static int scalar_min(int a, int b) {\n+        return (int)(Math.min(a, b));\n+    }\n+\n+    static int scalar_max(int a, int b) {\n+        return (int)(Math.max(a, b));\n+    }\n+\n+    static int scalar_div(int a, int b) {\n+        return (int)(a \/ b);\n+    }\n+\n+    static int scalar_fma(int a, int b, int c) {\n+        return (int)(Math.fma(a, b, c));\n+    }\n+\n+    static int scalar_abs(int a) {\n+        return (int)(Math.abs(a));\n+    }\n+\n+    static int scalar_neg(int a) {\n+        return ((int)-a);\n+    }\n+\n+    static int scalar_sin(int a) {\n+        return (int)Math.sin((double)a);\n+    }\n+\n+    static int scalar_exp(int a) {\n+        return (int)Math.exp((double)a);\n+    }\n+\n+    static int scalar_log1p(int a) {\n+        return (int)Math.log1p((double)a);\n+    }\n+\n+    static int scalar_log(int a) {\n+        return (int)Math.log((double)a);\n+    }\n+\n+    static int scalar_log10(int a) {\n+        return (int)Math.log10((double)a);\n+    }\n+\n+    static int scalar_expm1(int a) {\n+        return (int)Math.expm1((double)a);\n+    }\n+\n+    static int scalar_cos(int a) {\n+        return (int)Math.cos((double)a);\n+    }\n+\n+    static int scalar_tan(int a) {\n+        return (int)Math.tan((double)a);\n+    }\n+\n+    static int scalar_sinh(int a) {\n+        return (int)Math.sinh((double)a);\n+    }\n+\n+    static int scalar_cosh(int a) {\n+        return (int)Math.cosh((double)a);\n+    }\n+\n+    static int scalar_tanh(int a) {\n+        return (int)Math.tanh((double)a);\n+    }\n+\n+    static int scalar_asin(int a) {\n+        return (int)Math.asin((double)a);\n+    }\n+\n+    static int scalar_acos(int a) {\n+        return (int)Math.acos((double)a);\n+    }\n+\n+    static int scalar_atan(int a) {\n+        return (int)Math.atan((double)a);\n+    }\n+\n+    static int scalar_cbrt(int a) {\n+        return (int)Math.cbrt((double)a);\n+    }\n+\n+    static int scalar_sqrt(int a) {\n+        return (int)Math.sqrt((double)a);\n+    }\n+\n+    static int scalar_hypot(int a, int b) {\n+        return (int)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static int scalar_pow(int a, int b) {\n+        return (int)Math.pow((double)a, (double)b);\n+    }\n+\n+    static int scalar_atan2(int a, int b) {\n+        return (int)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static int strict_scalar_sin(int a) {\n+        return (int)StrictMath.sin((double)a);\n+    }\n+\n+    static int strict_scalar_exp(int a) {\n+        return (int)StrictMath.exp((double)a);\n+    }\n+\n+    static int strict_scalar_log1p(int a) {\n+        return (int)StrictMath.log1p((double)a);\n+    }\n+\n+    static int strict_scalar_log(int a) {\n+        return (int)StrictMath.log((double)a);\n+    }\n+\n+    static int strict_scalar_log10(int a) {\n+        return (int)StrictMath.log10((double)a);\n+    }\n+\n+    static int strict_scalar_expm1(int a) {\n+        return (int)StrictMath.expm1((double)a);\n+    }\n+\n+    static int strict_scalar_cos(int a) {\n+        return (int)StrictMath.cos((double)a);\n+    }\n+\n+    static int strict_scalar_tan(int a) {\n+        return (int)StrictMath.tan((double)a);\n+    }\n+\n+    static int strict_scalar_sinh(int a) {\n+        return (int)StrictMath.sinh((double)a);\n+    }\n+\n+    static int strict_scalar_cosh(int a) {\n+        return (int)StrictMath.cosh((double)a);\n+    }\n+\n+    static int strict_scalar_tanh(int a) {\n+        return (int)StrictMath.tanh((double)a);\n+    }\n+\n+    static int strict_scalar_asin(int a) {\n+        return (int)StrictMath.asin((double)a);\n+    }\n+\n+    static int strict_scalar_acos(int a) {\n+        return (int)StrictMath.acos((double)a);\n+    }\n+\n+    static int strict_scalar_atan(int a) {\n+        return (int)StrictMath.atan((double)a);\n+    }\n+\n+    static int strict_scalar_cbrt(int a) {\n+        return (int)StrictMath.cbrt((double)a);\n+    }\n+\n+    static int strict_scalar_sqrt(int a) {\n+        return (int)StrictMath.sqrt((double)a);\n+    }\n+\n+    static int strict_scalar_hypot(int a, int b) {\n+        return (int)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static int strict_scalar_pow(int a, int b) {\n+        return (int)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static int strict_scalar_atan2(int a, int b) {\n+        return (int)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static int additiveIdentity() {\n+        return (int)0;\n+    }\n+\n+\n@@ -1455,2 +1720,10 @@\n-    static int firstNonZero(int a, int b) {\n-        return Integer.compare(a, (int) 0) != 0 ? a : b;\n+    static int zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static int maxValue() {\n+        return Integer.MAX_VALUE;\n+    }\n+\n+    static int minValue() {\n+        return Integer.MIN_VALUE;\n@@ -1459,0 +1732,1 @@\n+\n@@ -1494,1 +1768,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1509,1 +1783,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1515,1 +1789,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1521,1 +1795,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1536,1 +1810,1 @@\n-        Assert.assertEquals(asIntegral.species(), SPECIES);\n+        AssertEquals(asIntegral.species(), SPECIES);\n@@ -1544,3 +1818,3 @@\n-        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n-        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n-        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n+        AssertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        AssertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n@@ -1571,1 +1845,1 @@\n-        return (int)(a + b);\n+        return (int)(scalar_add(a, b));\n@@ -1592,1 +1866,1 @@\n-        return (int)(a + b);\n+        return (int)(scalar_add(a, b));\n@@ -1649,1 +1923,1 @@\n-        return (int)(a - b);\n+        return (int)(scalar_sub(a, b));\n@@ -1670,1 +1944,1 @@\n-        return (int)(a - b);\n+        return (int)(scalar_sub(a, b));\n@@ -1727,1 +2001,1 @@\n-        return (int)(a * b);\n+        return (int)(scalar_mul(a, b));\n@@ -1748,1 +2022,1 @@\n-        return (int)(a * b);\n+        return (int)(scalar_mul(a, b));\n@@ -1895,1 +2169,1 @@\n-        return (int)((a)!=0?a:b);\n+        return (int)(firstNonZero(a, b));\n@@ -3084,2 +3358,0 @@\n-    static IntVector bv_MIN = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3094,1 +3366,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -3101,2 +3373,0 @@\n-    static IntVector bv_min = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3111,1 +3381,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -3118,2 +3388,0 @@\n-    static IntVector bv_MIN_M = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3130,1 +3398,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -3137,2 +3405,0 @@\n-    static IntVector bv_MAX = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3147,1 +3413,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -3154,2 +3420,0 @@\n-    static IntVector bv_max = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3164,1 +3428,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -3171,2 +3435,0 @@\n-    static IntVector bv_MAX_M = IntVector.broadcast(SPECIES, (int)10);\n-\n@@ -3183,1 +3445,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -3191,1 +3453,1 @@\n-        return (int)(Math.min(a, b));\n+        return (int)(scalar_min(a, b));\n@@ -3212,1 +3474,1 @@\n-        return (int)(Math.min(a, b));\n+        return (int)(scalar_min(a, b));\n@@ -3231,1 +3493,1 @@\n-        return (int)(Math.max(a, b));\n+        return (int)(scalar_max(a, b));\n@@ -3252,1 +3514,1 @@\n-        return (int)(Math.max(a, b));\n+        return (int)(scalar_max(a, b));\n@@ -3620,1 +3882,1 @@\n-            res &= a[i];\n+            res = scalar_and(res, a[i]);\n@@ -3629,1 +3891,1 @@\n-            res &= ANDReduce(a, i);\n+            res = scalar_and(res, ANDReduce(a, i));\n@@ -3652,1 +3914,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND));\n@@ -3664,1 +3926,1 @@\n-                res &= a[i];\n+                res = scalar_and(res, a[i]);\n@@ -3673,1 +3935,1 @@\n-            res &= ANDReduceMasked(a, i, mask);\n+            res = scalar_and(res, ANDReduceMasked(a, i, mask));\n@@ -3698,1 +3960,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND, vmask));\n@@ -3709,1 +3971,1 @@\n-            res |= a[i];\n+            res = scalar_or(res, a[i]);\n@@ -3718,1 +3980,1 @@\n-            res |= ORReduce(a, i);\n+            res = scalar_or(res, ORReduce(a, i));\n@@ -3741,1 +4003,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR));\n@@ -3753,1 +4015,1 @@\n-                res |= a[i];\n+                res = scalar_or(res, a[i]);\n@@ -3762,1 +4024,1 @@\n-            res |= ORReduceMasked(a, i, mask);\n+            res = scalar_or(res, ORReduceMasked(a, i, mask));\n@@ -3787,1 +4049,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR, vmask));\n@@ -3798,1 +4060,1 @@\n-            res ^= a[i];\n+            res = scalar_xor(res, a[i]);\n@@ -3807,1 +4069,1 @@\n-            res ^= XORReduce(a, i);\n+            res = scalar_xor(res, XORReduce(a, i));\n@@ -3830,1 +4092,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR));\n@@ -3842,1 +4104,1 @@\n-                res ^= a[i];\n+                res = scalar_xor(res, a[i]);\n@@ -3851,1 +4113,1 @@\n-            res ^= XORReduceMasked(a, i, mask);\n+            res = scalar_xor(res, XORReduceMasked(a, i, mask));\n@@ -3876,1 +4138,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR, vmask));\n@@ -3885,1 +4147,1 @@\n-        int res = 0;\n+        int res = additiveIdentity();\n@@ -3887,1 +4149,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -3894,1 +4156,1 @@\n-        int res = 0;\n+        int res = additiveIdentity();\n@@ -3896,1 +4158,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -3906,1 +4168,1 @@\n-        int ra = 0;\n+        int ra = additiveIdentity();\n@@ -3916,1 +4178,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3919,1 +4181,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -3928,1 +4190,1 @@\n-        int res = 0;\n+        int res = additiveIdentity();\n@@ -3931,1 +4193,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -3938,1 +4200,1 @@\n-        int res = 0;\n+        int res = additiveIdentity();\n@@ -3940,1 +4202,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -3952,1 +4214,1 @@\n-        int ra = 0;\n+        int ra = additiveIdentity();\n@@ -3962,1 +4224,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3965,1 +4227,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -3974,1 +4236,1 @@\n-        int res = 1;\n+        int res = multiplicativeIdentity();\n@@ -3976,1 +4238,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -3983,1 +4245,1 @@\n-        int res = 1;\n+        int res = multiplicativeIdentity();\n@@ -3985,1 +4247,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -3995,1 +4257,1 @@\n-        int ra = 1;\n+        int ra = multiplicativeIdentity();\n@@ -4005,1 +4267,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -4008,1 +4270,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -4017,1 +4279,1 @@\n-        int res = 1;\n+        int res = multiplicativeIdentity();\n@@ -4020,1 +4282,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -4027,1 +4289,1 @@\n-        int res = 1;\n+        int res = multiplicativeIdentity();\n@@ -4029,1 +4291,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -4041,1 +4303,1 @@\n-        int ra = 1;\n+        int ra = multiplicativeIdentity();\n@@ -4051,1 +4313,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -4054,1 +4316,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -4063,1 +4325,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4065,1 +4327,1 @@\n-            res = (int) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -4072,1 +4334,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4074,1 +4336,1 @@\n-            res = (int) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -4084,1 +4346,1 @@\n-        int ra = Integer.MAX_VALUE;\n+        int ra = maxValue();\n@@ -4094,1 +4356,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = maxValue();\n@@ -4097,1 +4359,1 @@\n-                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -4106,1 +4368,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4109,1 +4371,1 @@\n-                res = (int) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -4116,1 +4378,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4118,1 +4380,1 @@\n-            res = (int) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -4130,1 +4392,1 @@\n-        int ra = Integer.MAX_VALUE;\n+        int ra = maxValue();\n@@ -4140,1 +4402,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = maxValue();\n@@ -4143,1 +4405,1 @@\n-                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -4152,1 +4414,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4154,1 +4416,1 @@\n-            res = (int) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -4161,1 +4423,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4163,1 +4425,1 @@\n-            res = (int) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -4173,1 +4435,1 @@\n-        int ra = Integer.MIN_VALUE;\n+        int ra = minValue();\n@@ -4183,1 +4445,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = minValue();\n@@ -4186,1 +4448,1 @@\n-                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -4195,1 +4457,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4198,1 +4460,1 @@\n-                res = (int) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -4205,1 +4467,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4207,1 +4469,1 @@\n-            res = (int) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -4219,1 +4481,1 @@\n-        int ra = Integer.MIN_VALUE;\n+        int ra = minValue();\n@@ -4229,1 +4491,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = minValue();\n@@ -4232,1 +4494,1 @@\n-                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -4241,1 +4503,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4250,1 +4512,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4262,1 +4524,1 @@\n-        int ra = Integer.MAX_VALUE;\n+        int ra = maxValue();\n@@ -4272,1 +4534,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = maxValue();\n@@ -4284,1 +4546,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4294,1 +4556,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = maxValue();\n@@ -4308,1 +4570,1 @@\n-        int ra = Integer.MAX_VALUE;\n+        int ra = maxValue();\n@@ -4318,1 +4580,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = maxValue();\n@@ -4330,1 +4592,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4339,1 +4601,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4351,1 +4613,1 @@\n-        int ra = Integer.MIN_VALUE;\n+        int ra = minValue();\n@@ -4361,1 +4623,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = minValue();\n@@ -4373,1 +4635,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4383,1 +4645,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = minValue();\n@@ -4397,1 +4659,1 @@\n-        int ra = Integer.MIN_VALUE;\n+        int ra = minValue();\n@@ -4407,1 +4669,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = minValue();\n@@ -4419,1 +4681,1 @@\n-        int res = (int) 0;\n+        int res = zeroValue();\n@@ -4428,1 +4690,1 @@\n-        int res = (int) 0;\n+        int res = zeroValue();\n@@ -4440,1 +4702,1 @@\n-        int ra = (int) 0;\n+        int ra = zeroValue();\n@@ -4450,1 +4712,1 @@\n-            ra = (int) 0;\n+            ra = zeroValue();\n@@ -4462,1 +4724,1 @@\n-        int res = (int) 0;\n+        int res = zeroValue();\n@@ -4472,1 +4734,1 @@\n-        int res = (int) 0;\n+        int res = zeroValue();\n@@ -4486,1 +4748,1 @@\n-        int ra = (int) 0;\n+        int ra = zeroValue();\n@@ -4496,1 +4758,1 @@\n-            ra = (int) 0;\n+            ra = zeroValue();\n@@ -4556,1 +4818,1 @@\n-        int res = 0;\n+        int res = zeroValue();\n@@ -4565,1 +4827,1 @@\n-        int res = 0;\n+        int res = zeroValue();\n@@ -4577,1 +4839,1 @@\n-        int ra = 0;\n+        int ra = zeroValue();\n@@ -4587,1 +4849,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4599,1 +4861,1 @@\n-        int res = 0;\n+        int res = zeroValue();\n@@ -4609,1 +4871,1 @@\n-        int res = 0;\n+        int res = zeroValue();\n@@ -4622,1 +4884,1 @@\n-        int ra = 0;\n+        int ra = zeroValue();\n@@ -4632,1 +4894,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4677,1 +4939,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -4697,1 +4959,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -4718,1 +4980,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -4738,1 +5000,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -4757,1 +5019,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4776,1 +5038,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4799,1 +5061,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -4818,1 +5080,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -4841,1 +5103,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -4860,1 +5122,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4879,1 +5141,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4902,1 +5164,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -4921,1 +5183,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -4944,1 +5206,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -4963,1 +5225,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -4986,1 +5248,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -5005,1 +5267,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -5028,1 +5290,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -5047,1 +5309,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n@@ -5070,1 +5332,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n@@ -5089,1 +5351,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n@@ -5112,1 +5374,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -5131,1 +5393,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n@@ -5154,1 +5416,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n@@ -5173,1 +5435,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n@@ -5196,1 +5458,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n@@ -5213,1 +5475,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -5233,1 +5495,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -5249,1 +5511,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < (int)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (int)((long)b[i])));\n@@ -5269,1 +5531,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < (int)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(int)((long)b[i]))));\n@@ -5285,1 +5547,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -5305,1 +5567,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -5321,1 +5583,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == (int)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (int)((long)b[i])));\n@@ -5341,1 +5603,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == (int)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(int)((long)b[i]))));\n@@ -5622,1 +5884,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -6053,1 +6315,1 @@\n-        return (int)(-((int)a));\n+        return (int)(scalar_neg((int)a));\n@@ -6057,1 +6319,1 @@\n-        return (int)(-((int)a));\n+        return (int)(scalar_neg((int)a));\n@@ -6109,1 +6371,1 @@\n-        return (int)(Math.abs((int)a));\n+        return (int)(scalar_abs((int)a));\n@@ -6113,1 +6375,1 @@\n-        return (int)(Math.abs((int)a));\n+        return (int)(scalar_abs((int)a));\n@@ -6453,1 +6715,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -6469,1 +6731,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -6565,1 +6827,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6606,1 +6868,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6709,1 +6971,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -6737,1 +6999,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -6751,1 +7013,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -6948,1 +7210,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -6975,1 +7237,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6989,1 +7251,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -7011,1 +7273,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -7019,1 +7281,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -7026,1 +7288,1 @@\n-        Assert.assertEquals(elsize, Integer.SIZE);\n+        AssertEquals(elsize, Integer.SIZE);\n@@ -7045,1 +7307,1 @@\n-    static void ElementTypeIntMaxVectorTestsSmokeTest() {\n+    static void IntIntMaxVectorTestsSmokeTest() {\n@@ -7080,1 +7342,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":594,"deletions":332,"binary":false,"changes":926,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,39 @@\n+    static LongVector bcast_vec = LongVector.broadcast(SPECIES, (long)10);\n+\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected, long delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(long actual, long expected, long delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(long [] actual, long [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long [] actual, long [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -87,1 +126,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -90,1 +129,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -102,1 +141,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -108,1 +147,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -118,1 +157,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -121,1 +160,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -137,1 +176,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -139,1 +178,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -142,2 +181,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -159,1 +198,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -161,1 +200,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -164,2 +203,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -178,1 +217,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -181,1 +220,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -193,1 +232,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -196,1 +235,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -205,1 +244,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -210,1 +249,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -221,1 +260,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -226,1 +265,1 @@\n-                    Assert.assertEquals(r[i + k], (long)0);\n+                    AssertEquals(r[i + k], (long)0);\n@@ -232,1 +271,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -234,1 +273,1 @@\n-                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (long)0, \"at index #\" + idx);\n@@ -246,1 +285,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -249,1 +288,1 @@\n-                        Assert.assertEquals(r[i + j], (long)0);\n+                        AssertEquals(r[i + j], (long)0);\n@@ -256,1 +295,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -258,1 +297,1 @@\n-                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (long)0, \"at index #\" + idx);\n@@ -274,1 +313,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -278,1 +317,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -284,0 +323,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -287,1 +327,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -291,2 +333,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -302,1 +343,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -304,1 +345,1 @@\n-                         Assert.assertEquals(r[i+j], (long)0);\n+                         AssertEquals(r[i+j], (long)0);\n@@ -310,1 +351,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -312,1 +353,1 @@\n-                Assert.assertEquals(r[i+j], (long)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (long)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -318,0 +359,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -321,0 +363,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -322,1 +366,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -324,1 +368,1 @@\n-                         Assert.assertEquals(r[i+j], (long)0);\n+                         AssertEquals(r[i+j], (long)0);\n@@ -328,1 +372,0 @@\n-            int idx = i + j;\n@@ -330,1 +373,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -332,1 +375,1 @@\n-                Assert.assertEquals(r[i+j], (long)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (long)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -346,1 +389,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -349,1 +392,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -370,1 +413,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -373,1 +416,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -376,1 +419,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -379,3 +422,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -396,1 +439,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -399,1 +442,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -402,1 +445,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -405,3 +448,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -415,1 +458,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -418,1 +461,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -426,1 +469,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -429,1 +472,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -437,1 +480,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -440,1 +483,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -449,1 +492,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -452,1 +495,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -465,1 +508,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -468,1 +511,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -480,1 +523,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -483,1 +526,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -495,1 +538,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -498,1 +541,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -513,1 +556,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -516,1 +559,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -529,1 +572,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -533,1 +576,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -547,1 +590,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -551,1 +594,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -573,1 +616,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -577,1 +620,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -591,1 +634,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -595,1 +638,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -615,1 +658,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -618,1 +661,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -630,1 +673,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -633,1 +676,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -642,1 +685,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -645,1 +688,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -655,1 +698,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -658,1 +701,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -674,1 +717,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -678,1 +721,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -695,1 +738,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -699,1 +742,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -710,1 +753,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -714,1 +757,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -731,1 +774,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -735,1 +778,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -753,1 +796,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -759,1 +802,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -780,1 +823,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -786,1 +829,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -801,1 +844,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -807,1 +850,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -828,1 +871,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -834,1 +877,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -848,1 +891,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -854,1 +897,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -869,1 +912,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -875,1 +918,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -890,1 +933,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -896,1 +939,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -912,1 +955,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -918,1 +961,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -926,0 +969,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -942,1 +989,1 @@\n-            withToString(\"long[-i * 5]\", (int s) -> {\n+            withToString(\"Long[-i * 5]\", (int s) -> {\n@@ -944,1 +991,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -946,1 +993,1 @@\n-            withToString(\"long[i * 5]\", (int s) -> {\n+            withToString(\"Long[i * 5]\", (int s) -> {\n@@ -948,1 +995,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -950,1 +997,1 @@\n-            withToString(\"long[i + 1]\", (int s) -> {\n+            withToString(\"Long[i + 1]\", (int s) -> {\n@@ -952,1 +999,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -954,1 +1001,1 @@\n-            withToString(\"long[intCornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Long[intCornerCaseValue(i)]\", (int s) -> {\n@@ -964,1 +1011,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -967,1 +1014,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -977,1 +1024,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -980,1 +1027,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -988,1 +1035,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                AssertEquals(r[i], (double)(a[i+offs]));\n@@ -991,1 +1038,1 @@\n-            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1000,1 +1047,1 @@\n-            withToString(\"long[-i * 5]\", (int s) -> {\n+            withToString(\"Long[-i * 5]\", (int s) -> {\n@@ -1002,1 +1049,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1004,1 +1051,1 @@\n-            withToString(\"long[i * 5]\", (int s) -> {\n+            withToString(\"Long[i * 5]\", (int s) -> {\n@@ -1006,1 +1053,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1008,1 +1055,1 @@\n-            withToString(\"long[i + 1]\", (int s) -> {\n+            withToString(\"Long[i + 1]\", (int s) -> {\n@@ -1010,1 +1057,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1456,0 +1503,212 @@\n+    static long firstNonZero(long a, long b) {\n+        return Long.compare(a, (long) 0) != 0 ? a : b;\n+    }\n+\n+    static long multiplicativeIdentity() {\n+        return (long)1;\n+    }\n+\n+    static long scalar_or(long a, long b) {\n+        return (long)(a | b);\n+    }\n+\n+    static long scalar_and(long a, long b) {\n+        return (long)(a & b);\n+    }\n+\n+    static long scalar_xor(long a, long b) {\n+        return (long)(a ^ b);\n+    }\n+\n+    static long scalar_add(long a, long b) {\n+        return (long)(a + b);\n+    }\n+\n+    static long scalar_sub(long a, long b) {\n+        return (long)(a - b);\n+    }\n+\n+    static long scalar_mul(long a, long b) {\n+        return (long)(a * b);\n+    }\n+\n+    static long scalar_min(long a, long b) {\n+        return (long)(Math.min(a, b));\n+    }\n+\n+    static long scalar_max(long a, long b) {\n+        return (long)(Math.max(a, b));\n+    }\n+\n+    static long scalar_div(long a, long b) {\n+        return (long)(a \/ b);\n+    }\n+\n+    static long scalar_fma(long a, long b, long c) {\n+        return (long)(Math.fma(a, b, c));\n+    }\n+\n+    static long scalar_abs(long a) {\n+        return (long)(Math.abs(a));\n+    }\n+\n+    static long scalar_neg(long a) {\n+        return ((long)-a);\n+    }\n+\n+    static long scalar_sin(long a) {\n+        return (long)Math.sin((double)a);\n+    }\n+\n+    static long scalar_exp(long a) {\n+        return (long)Math.exp((double)a);\n+    }\n+\n+    static long scalar_log1p(long a) {\n+        return (long)Math.log1p((double)a);\n+    }\n+\n+    static long scalar_log(long a) {\n+        return (long)Math.log((double)a);\n+    }\n+\n+    static long scalar_log10(long a) {\n+        return (long)Math.log10((double)a);\n+    }\n+\n+    static long scalar_expm1(long a) {\n+        return (long)Math.expm1((double)a);\n+    }\n+\n+    static long scalar_cos(long a) {\n+        return (long)Math.cos((double)a);\n+    }\n+\n+    static long scalar_tan(long a) {\n+        return (long)Math.tan((double)a);\n+    }\n+\n+    static long scalar_sinh(long a) {\n+        return (long)Math.sinh((double)a);\n+    }\n+\n+    static long scalar_cosh(long a) {\n+        return (long)Math.cosh((double)a);\n+    }\n+\n+    static long scalar_tanh(long a) {\n+        return (long)Math.tanh((double)a);\n+    }\n+\n+    static long scalar_asin(long a) {\n+        return (long)Math.asin((double)a);\n+    }\n+\n+    static long scalar_acos(long a) {\n+        return (long)Math.acos((double)a);\n+    }\n+\n+    static long scalar_atan(long a) {\n+        return (long)Math.atan((double)a);\n+    }\n+\n+    static long scalar_cbrt(long a) {\n+        return (long)Math.cbrt((double)a);\n+    }\n+\n+    static long scalar_sqrt(long a) {\n+        return (long)Math.sqrt((double)a);\n+    }\n+\n+    static long scalar_hypot(long a, long b) {\n+        return (long)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static long scalar_pow(long a, long b) {\n+        return (long)Math.pow((double)a, (double)b);\n+    }\n+\n+    static long scalar_atan2(long a, long b) {\n+        return (long)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static long strict_scalar_sin(long a) {\n+        return (long)StrictMath.sin((double)a);\n+    }\n+\n+    static long strict_scalar_exp(long a) {\n+        return (long)StrictMath.exp((double)a);\n+    }\n+\n+    static long strict_scalar_log1p(long a) {\n+        return (long)StrictMath.log1p((double)a);\n+    }\n+\n+    static long strict_scalar_log(long a) {\n+        return (long)StrictMath.log((double)a);\n+    }\n+\n+    static long strict_scalar_log10(long a) {\n+        return (long)StrictMath.log10((double)a);\n+    }\n+\n+    static long strict_scalar_expm1(long a) {\n+        return (long)StrictMath.expm1((double)a);\n+    }\n+\n+    static long strict_scalar_cos(long a) {\n+        return (long)StrictMath.cos((double)a);\n+    }\n+\n+    static long strict_scalar_tan(long a) {\n+        return (long)StrictMath.tan((double)a);\n+    }\n+\n+    static long strict_scalar_sinh(long a) {\n+        return (long)StrictMath.sinh((double)a);\n+    }\n+\n+    static long strict_scalar_cosh(long a) {\n+        return (long)StrictMath.cosh((double)a);\n+    }\n+\n+    static long strict_scalar_tanh(long a) {\n+        return (long)StrictMath.tanh((double)a);\n+    }\n+\n+    static long strict_scalar_asin(long a) {\n+        return (long)StrictMath.asin((double)a);\n+    }\n+\n+    static long strict_scalar_acos(long a) {\n+        return (long)StrictMath.acos((double)a);\n+    }\n+\n+    static long strict_scalar_atan(long a) {\n+        return (long)StrictMath.atan((double)a);\n+    }\n+\n+    static long strict_scalar_cbrt(long a) {\n+        return (long)StrictMath.cbrt((double)a);\n+    }\n+\n+    static long strict_scalar_sqrt(long a) {\n+        return (long)StrictMath.sqrt((double)a);\n+    }\n+\n+    static long strict_scalar_hypot(long a, long b) {\n+        return (long)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static long strict_scalar_pow(long a, long b) {\n+        return (long)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static long strict_scalar_atan2(long a, long b) {\n+        return (long)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static long additiveIdentity() {\n+        return (long)0;\n+    }\n+\n+\n@@ -1472,2 +1731,6 @@\n-    static long firstNonZero(long a, long b) {\n-        return Long.compare(a, (long) 0) != 0 ? a : b;\n+    static long zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static long maxValue() {\n+        return Long.MAX_VALUE;\n@@ -1476,0 +1739,5 @@\n+    static long minValue() {\n+        return Long.MIN_VALUE;\n+    }\n+\n+\n@@ -1511,1 +1779,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1526,1 +1794,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1532,1 +1800,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1538,1 +1806,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1553,1 +1821,1 @@\n-        Assert.assertEquals(asIntegral.species(), SPECIES);\n+        AssertEquals(asIntegral.species(), SPECIES);\n@@ -1561,3 +1829,3 @@\n-        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n-        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n-        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n+        AssertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        AssertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n@@ -1588,1 +1856,1 @@\n-        return (long)(a + b);\n+        return (long)(scalar_add(a, b));\n@@ -1609,1 +1877,1 @@\n-        return (long)(a + b);\n+        return (long)(scalar_add(a, b));\n@@ -1666,1 +1934,1 @@\n-        return (long)(a - b);\n+        return (long)(scalar_sub(a, b));\n@@ -1687,1 +1955,1 @@\n-        return (long)(a - b);\n+        return (long)(scalar_sub(a, b));\n@@ -1744,1 +2012,1 @@\n-        return (long)(a * b);\n+        return (long)(scalar_mul(a, b));\n@@ -1765,1 +2033,1 @@\n-        return (long)(a * b);\n+        return (long)(scalar_mul(a, b));\n@@ -1912,1 +2180,1 @@\n-        return (long)((a)!=0?a:b);\n+        return (long)(firstNonZero(a, b));\n@@ -3101,2 +3369,0 @@\n-    static LongVector bv_MIN = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3111,1 +3377,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -3118,2 +3384,0 @@\n-    static LongVector bv_min = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3128,1 +3392,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -3135,2 +3399,0 @@\n-    static LongVector bv_MIN_M = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3147,1 +3409,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -3154,2 +3416,0 @@\n-    static LongVector bv_MAX = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3164,1 +3424,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -3171,2 +3431,0 @@\n-    static LongVector bv_max = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3181,1 +3439,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -3188,2 +3446,0 @@\n-    static LongVector bv_MAX_M = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3200,1 +3456,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -3208,1 +3464,1 @@\n-        return (long)(Math.min(a, b));\n+        return (long)(scalar_min(a, b));\n@@ -3229,1 +3485,1 @@\n-        return (long)(Math.min(a, b));\n+        return (long)(scalar_min(a, b));\n@@ -3248,1 +3504,1 @@\n-        return (long)(Math.max(a, b));\n+        return (long)(scalar_max(a, b));\n@@ -3269,1 +3525,1 @@\n-        return (long)(Math.max(a, b));\n+        return (long)(scalar_max(a, b));\n@@ -3637,1 +3893,1 @@\n-            res &= a[i];\n+            res = scalar_and(res, a[i]);\n@@ -3646,1 +3902,1 @@\n-            res &= ANDReduce(a, i);\n+            res = scalar_and(res, ANDReduce(a, i));\n@@ -3669,1 +3925,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND));\n@@ -3681,1 +3937,1 @@\n-                res &= a[i];\n+                res = scalar_and(res, a[i]);\n@@ -3690,1 +3946,1 @@\n-            res &= ANDReduceMasked(a, i, mask);\n+            res = scalar_and(res, ANDReduceMasked(a, i, mask));\n@@ -3715,1 +3971,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND, vmask));\n@@ -3726,1 +3982,1 @@\n-            res |= a[i];\n+            res = scalar_or(res, a[i]);\n@@ -3735,1 +3991,1 @@\n-            res |= ORReduce(a, i);\n+            res = scalar_or(res, ORReduce(a, i));\n@@ -3758,1 +4014,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR));\n@@ -3770,1 +4026,1 @@\n-                res |= a[i];\n+                res = scalar_or(res, a[i]);\n@@ -3779,1 +4035,1 @@\n-            res |= ORReduceMasked(a, i, mask);\n+            res = scalar_or(res, ORReduceMasked(a, i, mask));\n@@ -3804,1 +4060,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR, vmask));\n@@ -3815,1 +4071,1 @@\n-            res ^= a[i];\n+            res = scalar_xor(res, a[i]);\n@@ -3824,1 +4080,1 @@\n-            res ^= XORReduce(a, i);\n+            res = scalar_xor(res, XORReduce(a, i));\n@@ -3847,1 +4103,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR));\n@@ -3859,1 +4115,1 @@\n-                res ^= a[i];\n+                res = scalar_xor(res, a[i]);\n@@ -3868,1 +4124,1 @@\n-            res ^= XORReduceMasked(a, i, mask);\n+            res = scalar_xor(res, XORReduceMasked(a, i, mask));\n@@ -3893,1 +4149,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR, vmask));\n@@ -3902,1 +4158,1 @@\n-        long res = 0;\n+        long res = additiveIdentity();\n@@ -3904,1 +4160,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -3911,1 +4167,1 @@\n-        long res = 0;\n+        long res = additiveIdentity();\n@@ -3913,1 +4169,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -3923,1 +4179,1 @@\n-        long ra = 0;\n+        long ra = additiveIdentity();\n@@ -3933,1 +4189,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3936,1 +4192,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -3945,1 +4201,1 @@\n-        long res = 0;\n+        long res = additiveIdentity();\n@@ -3948,1 +4204,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -3955,1 +4211,1 @@\n-        long res = 0;\n+        long res = additiveIdentity();\n@@ -3957,1 +4213,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -3969,1 +4225,1 @@\n-        long ra = 0;\n+        long ra = additiveIdentity();\n@@ -3979,1 +4235,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3982,1 +4238,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -3991,1 +4247,1 @@\n-        long res = 1;\n+        long res = multiplicativeIdentity();\n@@ -3993,1 +4249,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -4000,1 +4256,1 @@\n-        long res = 1;\n+        long res = multiplicativeIdentity();\n@@ -4002,1 +4258,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -4012,1 +4268,1 @@\n-        long ra = 1;\n+        long ra = multiplicativeIdentity();\n@@ -4022,1 +4278,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -4025,1 +4281,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -4034,1 +4290,1 @@\n-        long res = 1;\n+        long res = multiplicativeIdentity();\n@@ -4037,1 +4293,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -4044,1 +4300,1 @@\n-        long res = 1;\n+        long res = multiplicativeIdentity();\n@@ -4046,1 +4302,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -4058,1 +4314,1 @@\n-        long ra = 1;\n+        long ra = multiplicativeIdentity();\n@@ -4068,1 +4324,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -4071,1 +4327,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -4080,1 +4336,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4082,1 +4338,1 @@\n-            res = (long) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -4089,1 +4345,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4091,1 +4347,1 @@\n-            res = (long) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -4101,1 +4357,1 @@\n-        long ra = Long.MAX_VALUE;\n+        long ra = maxValue();\n@@ -4111,1 +4367,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = maxValue();\n@@ -4114,1 +4370,1 @@\n-                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -4123,1 +4379,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4126,1 +4382,1 @@\n-                res = (long) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -4133,1 +4389,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4135,1 +4391,1 @@\n-            res = (long) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -4147,1 +4403,1 @@\n-        long ra = Long.MAX_VALUE;\n+        long ra = maxValue();\n@@ -4157,1 +4413,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = maxValue();\n@@ -4160,1 +4416,1 @@\n-                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -4169,1 +4425,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4171,1 +4427,1 @@\n-            res = (long) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -4178,1 +4434,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4180,1 +4436,1 @@\n-            res = (long) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -4190,1 +4446,1 @@\n-        long ra = Long.MIN_VALUE;\n+        long ra = minValue();\n@@ -4200,1 +4456,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = minValue();\n@@ -4203,1 +4459,1 @@\n-                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -4212,1 +4468,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4215,1 +4471,1 @@\n-                res = (long) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -4222,1 +4478,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4224,1 +4480,1 @@\n-            res = (long) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -4236,1 +4492,1 @@\n-        long ra = Long.MIN_VALUE;\n+        long ra = minValue();\n@@ -4246,1 +4502,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = minValue();\n@@ -4249,1 +4505,1 @@\n-                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -4258,1 +4514,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4267,1 +4523,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4279,1 +4535,1 @@\n-        long ra = Long.MAX_VALUE;\n+        long ra = maxValue();\n@@ -4289,1 +4545,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = maxValue();\n@@ -4301,1 +4557,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4311,1 +4567,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4325,1 +4581,1 @@\n-        long ra = Long.MAX_VALUE;\n+        long ra = maxValue();\n@@ -4335,1 +4591,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = maxValue();\n@@ -4347,1 +4603,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4356,1 +4612,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4368,1 +4624,1 @@\n-        long ra = Long.MIN_VALUE;\n+        long ra = minValue();\n@@ -4378,1 +4634,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = minValue();\n@@ -4390,1 +4646,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4400,1 +4656,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4414,1 +4670,1 @@\n-        long ra = Long.MIN_VALUE;\n+        long ra = minValue();\n@@ -4424,1 +4680,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = minValue();\n@@ -4436,1 +4692,1 @@\n-        long res = (long) 0;\n+        long res = zeroValue();\n@@ -4445,1 +4701,1 @@\n-        long res = (long) 0;\n+        long res = zeroValue();\n@@ -4457,1 +4713,1 @@\n-        long ra = (long) 0;\n+        long ra = zeroValue();\n@@ -4467,1 +4723,1 @@\n-            ra = (long) 0;\n+            ra = zeroValue();\n@@ -4479,1 +4735,1 @@\n-        long res = (long) 0;\n+        long res = zeroValue();\n@@ -4489,1 +4745,1 @@\n-        long res = (long) 0;\n+        long res = zeroValue();\n@@ -4503,1 +4759,1 @@\n-        long ra = (long) 0;\n+        long ra = zeroValue();\n@@ -4513,1 +4769,1 @@\n-            ra = (long) 0;\n+            ra = zeroValue();\n@@ -4573,1 +4829,1 @@\n-        long res = 0;\n+        long res = zeroValue();\n@@ -4582,1 +4838,1 @@\n-        long res = 0;\n+        long res = zeroValue();\n@@ -4594,1 +4850,1 @@\n-        long ra = 0;\n+        long ra = zeroValue();\n@@ -4604,1 +4860,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4616,1 +4872,1 @@\n-        long res = 0;\n+        long res = zeroValue();\n@@ -4626,1 +4882,1 @@\n-        long res = 0;\n+        long res = zeroValue();\n@@ -4639,1 +4895,1 @@\n-        long ra = 0;\n+        long ra = zeroValue();\n@@ -4649,1 +4905,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4694,1 +4950,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -4714,1 +4970,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -4735,1 +4991,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -4755,1 +5011,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -4774,1 +5030,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4793,1 +5049,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4816,1 +5072,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -4835,1 +5091,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -4858,1 +5114,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -4877,1 +5133,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4896,1 +5152,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4919,1 +5175,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -4938,1 +5194,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -4961,1 +5217,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -4980,1 +5236,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -5003,1 +5259,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -5022,1 +5278,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -5045,1 +5301,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -5064,1 +5320,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n@@ -5087,1 +5343,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n@@ -5106,1 +5362,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n@@ -5129,1 +5385,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -5148,1 +5404,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n@@ -5171,1 +5427,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n@@ -5190,1 +5446,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n@@ -5213,1 +5469,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n@@ -5230,1 +5486,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -5250,1 +5506,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -5267,1 +5523,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -5287,1 +5543,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -5569,1 +5825,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -6000,1 +6256,1 @@\n-        return (long)(-((long)a));\n+        return (long)(scalar_neg((long)a));\n@@ -6004,1 +6260,1 @@\n-        return (long)(-((long)a));\n+        return (long)(scalar_neg((long)a));\n@@ -6056,1 +6312,1 @@\n-        return (long)(Math.abs((long)a));\n+        return (long)(scalar_abs((long)a));\n@@ -6060,1 +6316,1 @@\n-        return (long)(Math.abs((long)a));\n+        return (long)(scalar_abs((long)a));\n@@ -6400,1 +6656,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -6416,1 +6672,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -6590,1 +6846,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -6618,1 +6874,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -6632,1 +6888,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -6829,1 +7085,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -6849,1 +7105,1 @@\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -6872,1 +7128,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6886,1 +7142,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6908,1 +7164,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -6916,1 +7172,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -6923,1 +7179,1 @@\n-        Assert.assertEquals(elsize, Long.SIZE);\n+        AssertEquals(elsize, Long.SIZE);\n@@ -6942,1 +7198,1 @@\n-    static void ElementTypeLong128VectorTestsSmokeTest() {\n+    static void LongLong128VectorTestsSmokeTest() {\n@@ -6977,1 +7233,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":582,"deletions":326,"binary":false,"changes":908,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,39 @@\n+    static LongVector bcast_vec = LongVector.broadcast(SPECIES, (long)10);\n+\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected, long delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(long actual, long expected, long delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(long [] actual, long [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long [] actual, long [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -87,1 +126,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -90,1 +129,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -102,1 +141,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -108,1 +147,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -118,1 +157,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -121,1 +160,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -137,1 +176,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -139,1 +178,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -142,2 +181,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -159,1 +198,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -161,1 +200,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -164,2 +203,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -178,1 +217,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -181,1 +220,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -193,1 +232,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -196,1 +235,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -205,1 +244,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -210,1 +249,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -221,1 +260,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -226,1 +265,1 @@\n-                    Assert.assertEquals(r[i + k], (long)0);\n+                    AssertEquals(r[i + k], (long)0);\n@@ -232,1 +271,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -234,1 +273,1 @@\n-                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (long)0, \"at index #\" + idx);\n@@ -246,1 +285,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -249,1 +288,1 @@\n-                        Assert.assertEquals(r[i + j], (long)0);\n+                        AssertEquals(r[i + j], (long)0);\n@@ -256,1 +295,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -258,1 +297,1 @@\n-                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (long)0, \"at index #\" + idx);\n@@ -274,1 +313,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -278,1 +317,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -284,0 +323,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -287,1 +327,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -291,2 +333,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -302,1 +343,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -304,1 +345,1 @@\n-                         Assert.assertEquals(r[i+j], (long)0);\n+                         AssertEquals(r[i+j], (long)0);\n@@ -310,1 +351,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -312,1 +353,1 @@\n-                Assert.assertEquals(r[i+j], (long)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (long)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -318,0 +359,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -321,0 +363,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -322,1 +366,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -324,1 +368,1 @@\n-                         Assert.assertEquals(r[i+j], (long)0);\n+                         AssertEquals(r[i+j], (long)0);\n@@ -328,1 +372,0 @@\n-            int idx = i + j;\n@@ -330,1 +373,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -332,1 +375,1 @@\n-                Assert.assertEquals(r[i+j], (long)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (long)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -346,1 +389,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -349,1 +392,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -370,1 +413,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -373,1 +416,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -376,1 +419,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -379,3 +422,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -396,1 +439,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -399,1 +442,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -402,1 +445,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -405,3 +448,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -415,1 +458,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -418,1 +461,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -426,1 +469,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -429,1 +472,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -437,1 +480,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -440,1 +483,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -449,1 +492,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -452,1 +495,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -465,1 +508,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -468,1 +511,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -480,1 +523,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -483,1 +526,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -495,1 +538,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -498,1 +541,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -513,1 +556,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -516,1 +559,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -529,1 +572,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -533,1 +576,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -547,1 +590,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -551,1 +594,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -573,1 +616,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -577,1 +620,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -591,1 +634,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -595,1 +638,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -615,1 +658,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -618,1 +661,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -630,1 +673,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -633,1 +676,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -642,1 +685,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -645,1 +688,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -655,1 +698,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -658,1 +701,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -674,1 +717,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -678,1 +721,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -695,1 +738,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -699,1 +742,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -710,1 +753,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -714,1 +757,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -731,1 +774,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -735,1 +778,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -753,1 +796,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -759,1 +802,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -780,1 +823,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -786,1 +829,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -801,1 +844,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -807,1 +850,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -828,1 +871,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -834,1 +877,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -848,1 +891,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -854,1 +897,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -869,1 +912,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -875,1 +918,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -890,1 +933,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -896,1 +939,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -912,1 +955,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -918,1 +961,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -926,0 +969,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -942,1 +989,1 @@\n-            withToString(\"long[-i * 5]\", (int s) -> {\n+            withToString(\"Long[-i * 5]\", (int s) -> {\n@@ -944,1 +991,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -946,1 +993,1 @@\n-            withToString(\"long[i * 5]\", (int s) -> {\n+            withToString(\"Long[i * 5]\", (int s) -> {\n@@ -948,1 +995,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -950,1 +997,1 @@\n-            withToString(\"long[i + 1]\", (int s) -> {\n+            withToString(\"Long[i + 1]\", (int s) -> {\n@@ -952,1 +999,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -954,1 +1001,1 @@\n-            withToString(\"long[intCornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Long[intCornerCaseValue(i)]\", (int s) -> {\n@@ -964,1 +1011,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -967,1 +1014,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -977,1 +1024,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -980,1 +1027,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -988,1 +1035,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                AssertEquals(r[i], (double)(a[i+offs]));\n@@ -991,1 +1038,1 @@\n-            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1000,1 +1047,1 @@\n-            withToString(\"long[-i * 5]\", (int s) -> {\n+            withToString(\"Long[-i * 5]\", (int s) -> {\n@@ -1002,1 +1049,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1004,1 +1051,1 @@\n-            withToString(\"long[i * 5]\", (int s) -> {\n+            withToString(\"Long[i * 5]\", (int s) -> {\n@@ -1006,1 +1053,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1008,1 +1055,1 @@\n-            withToString(\"long[i + 1]\", (int s) -> {\n+            withToString(\"Long[i + 1]\", (int s) -> {\n@@ -1010,1 +1057,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1456,0 +1503,212 @@\n+    static long firstNonZero(long a, long b) {\n+        return Long.compare(a, (long) 0) != 0 ? a : b;\n+    }\n+\n+    static long multiplicativeIdentity() {\n+        return (long)1;\n+    }\n+\n+    static long scalar_or(long a, long b) {\n+        return (long)(a | b);\n+    }\n+\n+    static long scalar_and(long a, long b) {\n+        return (long)(a & b);\n+    }\n+\n+    static long scalar_xor(long a, long b) {\n+        return (long)(a ^ b);\n+    }\n+\n+    static long scalar_add(long a, long b) {\n+        return (long)(a + b);\n+    }\n+\n+    static long scalar_sub(long a, long b) {\n+        return (long)(a - b);\n+    }\n+\n+    static long scalar_mul(long a, long b) {\n+        return (long)(a * b);\n+    }\n+\n+    static long scalar_min(long a, long b) {\n+        return (long)(Math.min(a, b));\n+    }\n+\n+    static long scalar_max(long a, long b) {\n+        return (long)(Math.max(a, b));\n+    }\n+\n+    static long scalar_div(long a, long b) {\n+        return (long)(a \/ b);\n+    }\n+\n+    static long scalar_fma(long a, long b, long c) {\n+        return (long)(Math.fma(a, b, c));\n+    }\n+\n+    static long scalar_abs(long a) {\n+        return (long)(Math.abs(a));\n+    }\n+\n+    static long scalar_neg(long a) {\n+        return ((long)-a);\n+    }\n+\n+    static long scalar_sin(long a) {\n+        return (long)Math.sin((double)a);\n+    }\n+\n+    static long scalar_exp(long a) {\n+        return (long)Math.exp((double)a);\n+    }\n+\n+    static long scalar_log1p(long a) {\n+        return (long)Math.log1p((double)a);\n+    }\n+\n+    static long scalar_log(long a) {\n+        return (long)Math.log((double)a);\n+    }\n+\n+    static long scalar_log10(long a) {\n+        return (long)Math.log10((double)a);\n+    }\n+\n+    static long scalar_expm1(long a) {\n+        return (long)Math.expm1((double)a);\n+    }\n+\n+    static long scalar_cos(long a) {\n+        return (long)Math.cos((double)a);\n+    }\n+\n+    static long scalar_tan(long a) {\n+        return (long)Math.tan((double)a);\n+    }\n+\n+    static long scalar_sinh(long a) {\n+        return (long)Math.sinh((double)a);\n+    }\n+\n+    static long scalar_cosh(long a) {\n+        return (long)Math.cosh((double)a);\n+    }\n+\n+    static long scalar_tanh(long a) {\n+        return (long)Math.tanh((double)a);\n+    }\n+\n+    static long scalar_asin(long a) {\n+        return (long)Math.asin((double)a);\n+    }\n+\n+    static long scalar_acos(long a) {\n+        return (long)Math.acos((double)a);\n+    }\n+\n+    static long scalar_atan(long a) {\n+        return (long)Math.atan((double)a);\n+    }\n+\n+    static long scalar_cbrt(long a) {\n+        return (long)Math.cbrt((double)a);\n+    }\n+\n+    static long scalar_sqrt(long a) {\n+        return (long)Math.sqrt((double)a);\n+    }\n+\n+    static long scalar_hypot(long a, long b) {\n+        return (long)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static long scalar_pow(long a, long b) {\n+        return (long)Math.pow((double)a, (double)b);\n+    }\n+\n+    static long scalar_atan2(long a, long b) {\n+        return (long)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static long strict_scalar_sin(long a) {\n+        return (long)StrictMath.sin((double)a);\n+    }\n+\n+    static long strict_scalar_exp(long a) {\n+        return (long)StrictMath.exp((double)a);\n+    }\n+\n+    static long strict_scalar_log1p(long a) {\n+        return (long)StrictMath.log1p((double)a);\n+    }\n+\n+    static long strict_scalar_log(long a) {\n+        return (long)StrictMath.log((double)a);\n+    }\n+\n+    static long strict_scalar_log10(long a) {\n+        return (long)StrictMath.log10((double)a);\n+    }\n+\n+    static long strict_scalar_expm1(long a) {\n+        return (long)StrictMath.expm1((double)a);\n+    }\n+\n+    static long strict_scalar_cos(long a) {\n+        return (long)StrictMath.cos((double)a);\n+    }\n+\n+    static long strict_scalar_tan(long a) {\n+        return (long)StrictMath.tan((double)a);\n+    }\n+\n+    static long strict_scalar_sinh(long a) {\n+        return (long)StrictMath.sinh((double)a);\n+    }\n+\n+    static long strict_scalar_cosh(long a) {\n+        return (long)StrictMath.cosh((double)a);\n+    }\n+\n+    static long strict_scalar_tanh(long a) {\n+        return (long)StrictMath.tanh((double)a);\n+    }\n+\n+    static long strict_scalar_asin(long a) {\n+        return (long)StrictMath.asin((double)a);\n+    }\n+\n+    static long strict_scalar_acos(long a) {\n+        return (long)StrictMath.acos((double)a);\n+    }\n+\n+    static long strict_scalar_atan(long a) {\n+        return (long)StrictMath.atan((double)a);\n+    }\n+\n+    static long strict_scalar_cbrt(long a) {\n+        return (long)StrictMath.cbrt((double)a);\n+    }\n+\n+    static long strict_scalar_sqrt(long a) {\n+        return (long)StrictMath.sqrt((double)a);\n+    }\n+\n+    static long strict_scalar_hypot(long a, long b) {\n+        return (long)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static long strict_scalar_pow(long a, long b) {\n+        return (long)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static long strict_scalar_atan2(long a, long b) {\n+        return (long)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static long additiveIdentity() {\n+        return (long)0;\n+    }\n+\n+\n@@ -1472,2 +1731,6 @@\n-    static long firstNonZero(long a, long b) {\n-        return Long.compare(a, (long) 0) != 0 ? a : b;\n+    static long zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static long maxValue() {\n+        return Long.MAX_VALUE;\n@@ -1476,0 +1739,5 @@\n+    static long minValue() {\n+        return Long.MIN_VALUE;\n+    }\n+\n+\n@@ -1511,1 +1779,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1526,1 +1794,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1532,1 +1800,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1538,1 +1806,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1553,1 +1821,1 @@\n-        Assert.assertEquals(asIntegral.species(), SPECIES);\n+        AssertEquals(asIntegral.species(), SPECIES);\n@@ -1561,3 +1829,3 @@\n-        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n-        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n-        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n+        AssertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        AssertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n@@ -1588,1 +1856,1 @@\n-        return (long)(a + b);\n+        return (long)(scalar_add(a, b));\n@@ -1609,1 +1877,1 @@\n-        return (long)(a + b);\n+        return (long)(scalar_add(a, b));\n@@ -1666,1 +1934,1 @@\n-        return (long)(a - b);\n+        return (long)(scalar_sub(a, b));\n@@ -1687,1 +1955,1 @@\n-        return (long)(a - b);\n+        return (long)(scalar_sub(a, b));\n@@ -1744,1 +2012,1 @@\n-        return (long)(a * b);\n+        return (long)(scalar_mul(a, b));\n@@ -1765,1 +2033,1 @@\n-        return (long)(a * b);\n+        return (long)(scalar_mul(a, b));\n@@ -1912,1 +2180,1 @@\n-        return (long)((a)!=0?a:b);\n+        return (long)(firstNonZero(a, b));\n@@ -3101,2 +3369,0 @@\n-    static LongVector bv_MIN = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3111,1 +3377,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -3118,2 +3384,0 @@\n-    static LongVector bv_min = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3128,1 +3392,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -3135,2 +3399,0 @@\n-    static LongVector bv_MIN_M = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3147,1 +3409,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -3154,2 +3416,0 @@\n-    static LongVector bv_MAX = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3164,1 +3424,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -3171,2 +3431,0 @@\n-    static LongVector bv_max = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3181,1 +3439,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -3188,2 +3446,0 @@\n-    static LongVector bv_MAX_M = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3200,1 +3456,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -3208,1 +3464,1 @@\n-        return (long)(Math.min(a, b));\n+        return (long)(scalar_min(a, b));\n@@ -3229,1 +3485,1 @@\n-        return (long)(Math.min(a, b));\n+        return (long)(scalar_min(a, b));\n@@ -3248,1 +3504,1 @@\n-        return (long)(Math.max(a, b));\n+        return (long)(scalar_max(a, b));\n@@ -3269,1 +3525,1 @@\n-        return (long)(Math.max(a, b));\n+        return (long)(scalar_max(a, b));\n@@ -3637,1 +3893,1 @@\n-            res &= a[i];\n+            res = scalar_and(res, a[i]);\n@@ -3646,1 +3902,1 @@\n-            res &= ANDReduce(a, i);\n+            res = scalar_and(res, ANDReduce(a, i));\n@@ -3669,1 +3925,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND));\n@@ -3681,1 +3937,1 @@\n-                res &= a[i];\n+                res = scalar_and(res, a[i]);\n@@ -3690,1 +3946,1 @@\n-            res &= ANDReduceMasked(a, i, mask);\n+            res = scalar_and(res, ANDReduceMasked(a, i, mask));\n@@ -3715,1 +3971,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND, vmask));\n@@ -3726,1 +3982,1 @@\n-            res |= a[i];\n+            res = scalar_or(res, a[i]);\n@@ -3735,1 +3991,1 @@\n-            res |= ORReduce(a, i);\n+            res = scalar_or(res, ORReduce(a, i));\n@@ -3758,1 +4014,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR));\n@@ -3770,1 +4026,1 @@\n-                res |= a[i];\n+                res = scalar_or(res, a[i]);\n@@ -3779,1 +4035,1 @@\n-            res |= ORReduceMasked(a, i, mask);\n+            res = scalar_or(res, ORReduceMasked(a, i, mask));\n@@ -3804,1 +4060,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR, vmask));\n@@ -3815,1 +4071,1 @@\n-            res ^= a[i];\n+            res = scalar_xor(res, a[i]);\n@@ -3824,1 +4080,1 @@\n-            res ^= XORReduce(a, i);\n+            res = scalar_xor(res, XORReduce(a, i));\n@@ -3847,1 +4103,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR));\n@@ -3859,1 +4115,1 @@\n-                res ^= a[i];\n+                res = scalar_xor(res, a[i]);\n@@ -3868,1 +4124,1 @@\n-            res ^= XORReduceMasked(a, i, mask);\n+            res = scalar_xor(res, XORReduceMasked(a, i, mask));\n@@ -3893,1 +4149,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR, vmask));\n@@ -3902,1 +4158,1 @@\n-        long res = 0;\n+        long res = additiveIdentity();\n@@ -3904,1 +4160,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -3911,1 +4167,1 @@\n-        long res = 0;\n+        long res = additiveIdentity();\n@@ -3913,1 +4169,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -3923,1 +4179,1 @@\n-        long ra = 0;\n+        long ra = additiveIdentity();\n@@ -3933,1 +4189,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3936,1 +4192,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -3945,1 +4201,1 @@\n-        long res = 0;\n+        long res = additiveIdentity();\n@@ -3948,1 +4204,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -3955,1 +4211,1 @@\n-        long res = 0;\n+        long res = additiveIdentity();\n@@ -3957,1 +4213,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -3969,1 +4225,1 @@\n-        long ra = 0;\n+        long ra = additiveIdentity();\n@@ -3979,1 +4235,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3982,1 +4238,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -3991,1 +4247,1 @@\n-        long res = 1;\n+        long res = multiplicativeIdentity();\n@@ -3993,1 +4249,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -4000,1 +4256,1 @@\n-        long res = 1;\n+        long res = multiplicativeIdentity();\n@@ -4002,1 +4258,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -4012,1 +4268,1 @@\n-        long ra = 1;\n+        long ra = multiplicativeIdentity();\n@@ -4022,1 +4278,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -4025,1 +4281,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -4034,1 +4290,1 @@\n-        long res = 1;\n+        long res = multiplicativeIdentity();\n@@ -4037,1 +4293,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -4044,1 +4300,1 @@\n-        long res = 1;\n+        long res = multiplicativeIdentity();\n@@ -4046,1 +4302,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -4058,1 +4314,1 @@\n-        long ra = 1;\n+        long ra = multiplicativeIdentity();\n@@ -4068,1 +4324,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -4071,1 +4327,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -4080,1 +4336,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4082,1 +4338,1 @@\n-            res = (long) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -4089,1 +4345,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4091,1 +4347,1 @@\n-            res = (long) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -4101,1 +4357,1 @@\n-        long ra = Long.MAX_VALUE;\n+        long ra = maxValue();\n@@ -4111,1 +4367,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = maxValue();\n@@ -4114,1 +4370,1 @@\n-                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -4123,1 +4379,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4126,1 +4382,1 @@\n-                res = (long) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -4133,1 +4389,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4135,1 +4391,1 @@\n-            res = (long) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -4147,1 +4403,1 @@\n-        long ra = Long.MAX_VALUE;\n+        long ra = maxValue();\n@@ -4157,1 +4413,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = maxValue();\n@@ -4160,1 +4416,1 @@\n-                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -4169,1 +4425,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4171,1 +4427,1 @@\n-            res = (long) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -4178,1 +4434,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4180,1 +4436,1 @@\n-            res = (long) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -4190,1 +4446,1 @@\n-        long ra = Long.MIN_VALUE;\n+        long ra = minValue();\n@@ -4200,1 +4456,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = minValue();\n@@ -4203,1 +4459,1 @@\n-                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -4212,1 +4468,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4215,1 +4471,1 @@\n-                res = (long) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -4222,1 +4478,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4224,1 +4480,1 @@\n-            res = (long) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -4236,1 +4492,1 @@\n-        long ra = Long.MIN_VALUE;\n+        long ra = minValue();\n@@ -4246,1 +4502,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = minValue();\n@@ -4249,1 +4505,1 @@\n-                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -4258,1 +4514,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4267,1 +4523,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4279,1 +4535,1 @@\n-        long ra = Long.MAX_VALUE;\n+        long ra = maxValue();\n@@ -4289,1 +4545,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = maxValue();\n@@ -4301,1 +4557,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4311,1 +4567,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4325,1 +4581,1 @@\n-        long ra = Long.MAX_VALUE;\n+        long ra = maxValue();\n@@ -4335,1 +4591,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = maxValue();\n@@ -4347,1 +4603,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4356,1 +4612,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4368,1 +4624,1 @@\n-        long ra = Long.MIN_VALUE;\n+        long ra = minValue();\n@@ -4378,1 +4634,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = minValue();\n@@ -4390,1 +4646,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4400,1 +4656,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4414,1 +4670,1 @@\n-        long ra = Long.MIN_VALUE;\n+        long ra = minValue();\n@@ -4424,1 +4680,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = minValue();\n@@ -4436,1 +4692,1 @@\n-        long res = (long) 0;\n+        long res = zeroValue();\n@@ -4445,1 +4701,1 @@\n-        long res = (long) 0;\n+        long res = zeroValue();\n@@ -4457,1 +4713,1 @@\n-        long ra = (long) 0;\n+        long ra = zeroValue();\n@@ -4467,1 +4723,1 @@\n-            ra = (long) 0;\n+            ra = zeroValue();\n@@ -4479,1 +4735,1 @@\n-        long res = (long) 0;\n+        long res = zeroValue();\n@@ -4489,1 +4745,1 @@\n-        long res = (long) 0;\n+        long res = zeroValue();\n@@ -4503,1 +4759,1 @@\n-        long ra = (long) 0;\n+        long ra = zeroValue();\n@@ -4513,1 +4769,1 @@\n-            ra = (long) 0;\n+            ra = zeroValue();\n@@ -4573,1 +4829,1 @@\n-        long res = 0;\n+        long res = zeroValue();\n@@ -4582,1 +4838,1 @@\n-        long res = 0;\n+        long res = zeroValue();\n@@ -4594,1 +4850,1 @@\n-        long ra = 0;\n+        long ra = zeroValue();\n@@ -4604,1 +4860,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4616,1 +4872,1 @@\n-        long res = 0;\n+        long res = zeroValue();\n@@ -4626,1 +4882,1 @@\n-        long res = 0;\n+        long res = zeroValue();\n@@ -4639,1 +4895,1 @@\n-        long ra = 0;\n+        long ra = zeroValue();\n@@ -4649,1 +4905,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4694,1 +4950,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -4714,1 +4970,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -4735,1 +4991,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -4755,1 +5011,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -4774,1 +5030,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4793,1 +5049,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4816,1 +5072,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -4835,1 +5091,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -4858,1 +5114,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -4877,1 +5133,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4896,1 +5152,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4919,1 +5175,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -4938,1 +5194,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -4961,1 +5217,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -4980,1 +5236,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -5003,1 +5259,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -5022,1 +5278,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -5045,1 +5301,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -5064,1 +5320,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n@@ -5087,1 +5343,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n@@ -5106,1 +5362,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n@@ -5129,1 +5385,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -5148,1 +5404,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n@@ -5171,1 +5427,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n@@ -5190,1 +5446,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n@@ -5213,1 +5469,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n@@ -5230,1 +5486,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -5250,1 +5506,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -5267,1 +5523,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -5287,1 +5543,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -5569,1 +5825,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -6000,1 +6256,1 @@\n-        return (long)(-((long)a));\n+        return (long)(scalar_neg((long)a));\n@@ -6004,1 +6260,1 @@\n-        return (long)(-((long)a));\n+        return (long)(scalar_neg((long)a));\n@@ -6056,1 +6312,1 @@\n-        return (long)(Math.abs((long)a));\n+        return (long)(scalar_abs((long)a));\n@@ -6060,1 +6316,1 @@\n-        return (long)(Math.abs((long)a));\n+        return (long)(scalar_abs((long)a));\n@@ -6400,1 +6656,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -6416,1 +6672,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -6590,1 +6846,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -6618,1 +6874,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -6632,1 +6888,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -6829,1 +7085,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -6849,1 +7105,1 @@\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -6872,1 +7128,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6886,1 +7142,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6908,1 +7164,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -6916,1 +7172,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -6923,1 +7179,1 @@\n-        Assert.assertEquals(elsize, Long.SIZE);\n+        AssertEquals(elsize, Long.SIZE);\n@@ -6942,1 +7198,1 @@\n-    static void ElementTypeLong256VectorTestsSmokeTest() {\n+    static void LongLong256VectorTestsSmokeTest() {\n@@ -6977,1 +7233,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":582,"deletions":326,"binary":false,"changes":908,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,39 @@\n+    static LongVector bcast_vec = LongVector.broadcast(SPECIES, (long)10);\n+\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected, long delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(long actual, long expected, long delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(long [] actual, long [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long [] actual, long [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -87,1 +126,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -90,1 +129,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -102,1 +141,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -108,1 +147,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -118,1 +157,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -121,1 +160,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -137,1 +176,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -139,1 +178,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -142,2 +181,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -159,1 +198,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -161,1 +200,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -164,2 +203,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -178,1 +217,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -181,1 +220,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -193,1 +232,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -196,1 +235,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -205,1 +244,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -210,1 +249,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -221,1 +260,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -226,1 +265,1 @@\n-                    Assert.assertEquals(r[i + k], (long)0);\n+                    AssertEquals(r[i + k], (long)0);\n@@ -232,1 +271,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -234,1 +273,1 @@\n-                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (long)0, \"at index #\" + idx);\n@@ -246,1 +285,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -249,1 +288,1 @@\n-                        Assert.assertEquals(r[i + j], (long)0);\n+                        AssertEquals(r[i + j], (long)0);\n@@ -256,1 +295,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -258,1 +297,1 @@\n-                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (long)0, \"at index #\" + idx);\n@@ -274,1 +313,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -278,1 +317,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -284,0 +323,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -287,1 +327,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -291,2 +333,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -302,1 +343,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -304,1 +345,1 @@\n-                         Assert.assertEquals(r[i+j], (long)0);\n+                         AssertEquals(r[i+j], (long)0);\n@@ -310,1 +351,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -312,1 +353,1 @@\n-                Assert.assertEquals(r[i+j], (long)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (long)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -318,0 +359,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -321,0 +363,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -322,1 +366,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -324,1 +368,1 @@\n-                         Assert.assertEquals(r[i+j], (long)0);\n+                         AssertEquals(r[i+j], (long)0);\n@@ -328,1 +372,0 @@\n-            int idx = i + j;\n@@ -330,1 +373,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -332,1 +375,1 @@\n-                Assert.assertEquals(r[i+j], (long)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (long)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -346,1 +389,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -349,1 +392,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -370,1 +413,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -373,1 +416,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -376,1 +419,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -379,3 +422,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -396,1 +439,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -399,1 +442,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -402,1 +445,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -405,3 +448,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -415,1 +458,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -418,1 +461,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -426,1 +469,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -429,1 +472,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -437,1 +480,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -440,1 +483,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -449,1 +492,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -452,1 +495,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -465,1 +508,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -468,1 +511,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -480,1 +523,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -483,1 +526,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -495,1 +538,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -498,1 +541,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -513,1 +556,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -516,1 +559,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -529,1 +572,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -533,1 +576,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -547,1 +590,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -551,1 +594,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -573,1 +616,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -577,1 +620,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -591,1 +634,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -595,1 +638,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -615,1 +658,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -618,1 +661,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -630,1 +673,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -633,1 +676,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -642,1 +685,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -645,1 +688,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -655,1 +698,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -658,1 +701,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -674,1 +717,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -678,1 +721,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -695,1 +738,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -699,1 +742,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -710,1 +753,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -714,1 +757,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -731,1 +774,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -735,1 +778,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -753,1 +796,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -759,1 +802,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -780,1 +823,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -786,1 +829,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -801,1 +844,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -807,1 +850,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -828,1 +871,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -834,1 +877,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -848,1 +891,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -854,1 +897,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -869,1 +912,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -875,1 +918,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -890,1 +933,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -896,1 +939,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -912,1 +955,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -918,1 +961,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -926,0 +969,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -942,1 +989,1 @@\n-            withToString(\"long[-i * 5]\", (int s) -> {\n+            withToString(\"Long[-i * 5]\", (int s) -> {\n@@ -944,1 +991,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -946,1 +993,1 @@\n-            withToString(\"long[i * 5]\", (int s) -> {\n+            withToString(\"Long[i * 5]\", (int s) -> {\n@@ -948,1 +995,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -950,1 +997,1 @@\n-            withToString(\"long[i + 1]\", (int s) -> {\n+            withToString(\"Long[i + 1]\", (int s) -> {\n@@ -952,1 +999,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -954,1 +1001,1 @@\n-            withToString(\"long[intCornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Long[intCornerCaseValue(i)]\", (int s) -> {\n@@ -964,1 +1011,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -967,1 +1014,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -977,1 +1024,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -980,1 +1027,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -988,1 +1035,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                AssertEquals(r[i], (double)(a[i+offs]));\n@@ -991,1 +1038,1 @@\n-            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1000,1 +1047,1 @@\n-            withToString(\"long[-i * 5]\", (int s) -> {\n+            withToString(\"Long[-i * 5]\", (int s) -> {\n@@ -1002,1 +1049,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1004,1 +1051,1 @@\n-            withToString(\"long[i * 5]\", (int s) -> {\n+            withToString(\"Long[i * 5]\", (int s) -> {\n@@ -1006,1 +1053,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1008,1 +1055,1 @@\n-            withToString(\"long[i + 1]\", (int s) -> {\n+            withToString(\"Long[i + 1]\", (int s) -> {\n@@ -1010,1 +1057,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1456,0 +1503,212 @@\n+    static long firstNonZero(long a, long b) {\n+        return Long.compare(a, (long) 0) != 0 ? a : b;\n+    }\n+\n+    static long multiplicativeIdentity() {\n+        return (long)1;\n+    }\n+\n+    static long scalar_or(long a, long b) {\n+        return (long)(a | b);\n+    }\n+\n+    static long scalar_and(long a, long b) {\n+        return (long)(a & b);\n+    }\n+\n+    static long scalar_xor(long a, long b) {\n+        return (long)(a ^ b);\n+    }\n+\n+    static long scalar_add(long a, long b) {\n+        return (long)(a + b);\n+    }\n+\n+    static long scalar_sub(long a, long b) {\n+        return (long)(a - b);\n+    }\n+\n+    static long scalar_mul(long a, long b) {\n+        return (long)(a * b);\n+    }\n+\n+    static long scalar_min(long a, long b) {\n+        return (long)(Math.min(a, b));\n+    }\n+\n+    static long scalar_max(long a, long b) {\n+        return (long)(Math.max(a, b));\n+    }\n+\n+    static long scalar_div(long a, long b) {\n+        return (long)(a \/ b);\n+    }\n+\n+    static long scalar_fma(long a, long b, long c) {\n+        return (long)(Math.fma(a, b, c));\n+    }\n+\n+    static long scalar_abs(long a) {\n+        return (long)(Math.abs(a));\n+    }\n+\n+    static long scalar_neg(long a) {\n+        return ((long)-a);\n+    }\n+\n+    static long scalar_sin(long a) {\n+        return (long)Math.sin((double)a);\n+    }\n+\n+    static long scalar_exp(long a) {\n+        return (long)Math.exp((double)a);\n+    }\n+\n+    static long scalar_log1p(long a) {\n+        return (long)Math.log1p((double)a);\n+    }\n+\n+    static long scalar_log(long a) {\n+        return (long)Math.log((double)a);\n+    }\n+\n+    static long scalar_log10(long a) {\n+        return (long)Math.log10((double)a);\n+    }\n+\n+    static long scalar_expm1(long a) {\n+        return (long)Math.expm1((double)a);\n+    }\n+\n+    static long scalar_cos(long a) {\n+        return (long)Math.cos((double)a);\n+    }\n+\n+    static long scalar_tan(long a) {\n+        return (long)Math.tan((double)a);\n+    }\n+\n+    static long scalar_sinh(long a) {\n+        return (long)Math.sinh((double)a);\n+    }\n+\n+    static long scalar_cosh(long a) {\n+        return (long)Math.cosh((double)a);\n+    }\n+\n+    static long scalar_tanh(long a) {\n+        return (long)Math.tanh((double)a);\n+    }\n+\n+    static long scalar_asin(long a) {\n+        return (long)Math.asin((double)a);\n+    }\n+\n+    static long scalar_acos(long a) {\n+        return (long)Math.acos((double)a);\n+    }\n+\n+    static long scalar_atan(long a) {\n+        return (long)Math.atan((double)a);\n+    }\n+\n+    static long scalar_cbrt(long a) {\n+        return (long)Math.cbrt((double)a);\n+    }\n+\n+    static long scalar_sqrt(long a) {\n+        return (long)Math.sqrt((double)a);\n+    }\n+\n+    static long scalar_hypot(long a, long b) {\n+        return (long)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static long scalar_pow(long a, long b) {\n+        return (long)Math.pow((double)a, (double)b);\n+    }\n+\n+    static long scalar_atan2(long a, long b) {\n+        return (long)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static long strict_scalar_sin(long a) {\n+        return (long)StrictMath.sin((double)a);\n+    }\n+\n+    static long strict_scalar_exp(long a) {\n+        return (long)StrictMath.exp((double)a);\n+    }\n+\n+    static long strict_scalar_log1p(long a) {\n+        return (long)StrictMath.log1p((double)a);\n+    }\n+\n+    static long strict_scalar_log(long a) {\n+        return (long)StrictMath.log((double)a);\n+    }\n+\n+    static long strict_scalar_log10(long a) {\n+        return (long)StrictMath.log10((double)a);\n+    }\n+\n+    static long strict_scalar_expm1(long a) {\n+        return (long)StrictMath.expm1((double)a);\n+    }\n+\n+    static long strict_scalar_cos(long a) {\n+        return (long)StrictMath.cos((double)a);\n+    }\n+\n+    static long strict_scalar_tan(long a) {\n+        return (long)StrictMath.tan((double)a);\n+    }\n+\n+    static long strict_scalar_sinh(long a) {\n+        return (long)StrictMath.sinh((double)a);\n+    }\n+\n+    static long strict_scalar_cosh(long a) {\n+        return (long)StrictMath.cosh((double)a);\n+    }\n+\n+    static long strict_scalar_tanh(long a) {\n+        return (long)StrictMath.tanh((double)a);\n+    }\n+\n+    static long strict_scalar_asin(long a) {\n+        return (long)StrictMath.asin((double)a);\n+    }\n+\n+    static long strict_scalar_acos(long a) {\n+        return (long)StrictMath.acos((double)a);\n+    }\n+\n+    static long strict_scalar_atan(long a) {\n+        return (long)StrictMath.atan((double)a);\n+    }\n+\n+    static long strict_scalar_cbrt(long a) {\n+        return (long)StrictMath.cbrt((double)a);\n+    }\n+\n+    static long strict_scalar_sqrt(long a) {\n+        return (long)StrictMath.sqrt((double)a);\n+    }\n+\n+    static long strict_scalar_hypot(long a, long b) {\n+        return (long)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static long strict_scalar_pow(long a, long b) {\n+        return (long)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static long strict_scalar_atan2(long a, long b) {\n+        return (long)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static long additiveIdentity() {\n+        return (long)0;\n+    }\n+\n+\n@@ -1472,2 +1731,6 @@\n-    static long firstNonZero(long a, long b) {\n-        return Long.compare(a, (long) 0) != 0 ? a : b;\n+    static long zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static long maxValue() {\n+        return Long.MAX_VALUE;\n@@ -1476,0 +1739,5 @@\n+    static long minValue() {\n+        return Long.MIN_VALUE;\n+    }\n+\n+\n@@ -1511,1 +1779,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1526,1 +1794,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1532,1 +1800,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1538,1 +1806,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1553,1 +1821,1 @@\n-        Assert.assertEquals(asIntegral.species(), SPECIES);\n+        AssertEquals(asIntegral.species(), SPECIES);\n@@ -1561,3 +1829,3 @@\n-        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n-        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n-        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n+        AssertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        AssertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n@@ -1588,1 +1856,1 @@\n-        return (long)(a + b);\n+        return (long)(scalar_add(a, b));\n@@ -1609,1 +1877,1 @@\n-        return (long)(a + b);\n+        return (long)(scalar_add(a, b));\n@@ -1666,1 +1934,1 @@\n-        return (long)(a - b);\n+        return (long)(scalar_sub(a, b));\n@@ -1687,1 +1955,1 @@\n-        return (long)(a - b);\n+        return (long)(scalar_sub(a, b));\n@@ -1744,1 +2012,1 @@\n-        return (long)(a * b);\n+        return (long)(scalar_mul(a, b));\n@@ -1765,1 +2033,1 @@\n-        return (long)(a * b);\n+        return (long)(scalar_mul(a, b));\n@@ -1912,1 +2180,1 @@\n-        return (long)((a)!=0?a:b);\n+        return (long)(firstNonZero(a, b));\n@@ -3101,2 +3369,0 @@\n-    static LongVector bv_MIN = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3111,1 +3377,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -3118,2 +3384,0 @@\n-    static LongVector bv_min = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3128,1 +3392,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -3135,2 +3399,0 @@\n-    static LongVector bv_MIN_M = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3147,1 +3409,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -3154,2 +3416,0 @@\n-    static LongVector bv_MAX = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3164,1 +3424,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -3171,2 +3431,0 @@\n-    static LongVector bv_max = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3181,1 +3439,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -3188,2 +3446,0 @@\n-    static LongVector bv_MAX_M = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3200,1 +3456,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -3208,1 +3464,1 @@\n-        return (long)(Math.min(a, b));\n+        return (long)(scalar_min(a, b));\n@@ -3229,1 +3485,1 @@\n-        return (long)(Math.min(a, b));\n+        return (long)(scalar_min(a, b));\n@@ -3248,1 +3504,1 @@\n-        return (long)(Math.max(a, b));\n+        return (long)(scalar_max(a, b));\n@@ -3269,1 +3525,1 @@\n-        return (long)(Math.max(a, b));\n+        return (long)(scalar_max(a, b));\n@@ -3637,1 +3893,1 @@\n-            res &= a[i];\n+            res = scalar_and(res, a[i]);\n@@ -3646,1 +3902,1 @@\n-            res &= ANDReduce(a, i);\n+            res = scalar_and(res, ANDReduce(a, i));\n@@ -3669,1 +3925,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND));\n@@ -3681,1 +3937,1 @@\n-                res &= a[i];\n+                res = scalar_and(res, a[i]);\n@@ -3690,1 +3946,1 @@\n-            res &= ANDReduceMasked(a, i, mask);\n+            res = scalar_and(res, ANDReduceMasked(a, i, mask));\n@@ -3715,1 +3971,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND, vmask));\n@@ -3726,1 +3982,1 @@\n-            res |= a[i];\n+            res = scalar_or(res, a[i]);\n@@ -3735,1 +3991,1 @@\n-            res |= ORReduce(a, i);\n+            res = scalar_or(res, ORReduce(a, i));\n@@ -3758,1 +4014,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR));\n@@ -3770,1 +4026,1 @@\n-                res |= a[i];\n+                res = scalar_or(res, a[i]);\n@@ -3779,1 +4035,1 @@\n-            res |= ORReduceMasked(a, i, mask);\n+            res = scalar_or(res, ORReduceMasked(a, i, mask));\n@@ -3804,1 +4060,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR, vmask));\n@@ -3815,1 +4071,1 @@\n-            res ^= a[i];\n+            res = scalar_xor(res, a[i]);\n@@ -3824,1 +4080,1 @@\n-            res ^= XORReduce(a, i);\n+            res = scalar_xor(res, XORReduce(a, i));\n@@ -3847,1 +4103,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR));\n@@ -3859,1 +4115,1 @@\n-                res ^= a[i];\n+                res = scalar_xor(res, a[i]);\n@@ -3868,1 +4124,1 @@\n-            res ^= XORReduceMasked(a, i, mask);\n+            res = scalar_xor(res, XORReduceMasked(a, i, mask));\n@@ -3893,1 +4149,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR, vmask));\n@@ -3902,1 +4158,1 @@\n-        long res = 0;\n+        long res = additiveIdentity();\n@@ -3904,1 +4160,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -3911,1 +4167,1 @@\n-        long res = 0;\n+        long res = additiveIdentity();\n@@ -3913,1 +4169,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -3923,1 +4179,1 @@\n-        long ra = 0;\n+        long ra = additiveIdentity();\n@@ -3933,1 +4189,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3936,1 +4192,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -3945,1 +4201,1 @@\n-        long res = 0;\n+        long res = additiveIdentity();\n@@ -3948,1 +4204,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -3955,1 +4211,1 @@\n-        long res = 0;\n+        long res = additiveIdentity();\n@@ -3957,1 +4213,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -3969,1 +4225,1 @@\n-        long ra = 0;\n+        long ra = additiveIdentity();\n@@ -3979,1 +4235,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3982,1 +4238,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -3991,1 +4247,1 @@\n-        long res = 1;\n+        long res = multiplicativeIdentity();\n@@ -3993,1 +4249,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -4000,1 +4256,1 @@\n-        long res = 1;\n+        long res = multiplicativeIdentity();\n@@ -4002,1 +4258,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -4012,1 +4268,1 @@\n-        long ra = 1;\n+        long ra = multiplicativeIdentity();\n@@ -4022,1 +4278,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -4025,1 +4281,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -4034,1 +4290,1 @@\n-        long res = 1;\n+        long res = multiplicativeIdentity();\n@@ -4037,1 +4293,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -4044,1 +4300,1 @@\n-        long res = 1;\n+        long res = multiplicativeIdentity();\n@@ -4046,1 +4302,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -4058,1 +4314,1 @@\n-        long ra = 1;\n+        long ra = multiplicativeIdentity();\n@@ -4068,1 +4324,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -4071,1 +4327,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -4080,1 +4336,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4082,1 +4338,1 @@\n-            res = (long) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -4089,1 +4345,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4091,1 +4347,1 @@\n-            res = (long) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -4101,1 +4357,1 @@\n-        long ra = Long.MAX_VALUE;\n+        long ra = maxValue();\n@@ -4111,1 +4367,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = maxValue();\n@@ -4114,1 +4370,1 @@\n-                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -4123,1 +4379,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4126,1 +4382,1 @@\n-                res = (long) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -4133,1 +4389,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4135,1 +4391,1 @@\n-            res = (long) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -4147,1 +4403,1 @@\n-        long ra = Long.MAX_VALUE;\n+        long ra = maxValue();\n@@ -4157,1 +4413,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = maxValue();\n@@ -4160,1 +4416,1 @@\n-                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -4169,1 +4425,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4171,1 +4427,1 @@\n-            res = (long) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -4178,1 +4434,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4180,1 +4436,1 @@\n-            res = (long) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -4190,1 +4446,1 @@\n-        long ra = Long.MIN_VALUE;\n+        long ra = minValue();\n@@ -4200,1 +4456,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = minValue();\n@@ -4203,1 +4459,1 @@\n-                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -4212,1 +4468,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4215,1 +4471,1 @@\n-                res = (long) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -4222,1 +4478,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4224,1 +4480,1 @@\n-            res = (long) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -4236,1 +4492,1 @@\n-        long ra = Long.MIN_VALUE;\n+        long ra = minValue();\n@@ -4246,1 +4502,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = minValue();\n@@ -4249,1 +4505,1 @@\n-                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -4258,1 +4514,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4267,1 +4523,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4279,1 +4535,1 @@\n-        long ra = Long.MAX_VALUE;\n+        long ra = maxValue();\n@@ -4289,1 +4545,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = maxValue();\n@@ -4301,1 +4557,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4311,1 +4567,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4325,1 +4581,1 @@\n-        long ra = Long.MAX_VALUE;\n+        long ra = maxValue();\n@@ -4335,1 +4591,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = maxValue();\n@@ -4347,1 +4603,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4356,1 +4612,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4368,1 +4624,1 @@\n-        long ra = Long.MIN_VALUE;\n+        long ra = minValue();\n@@ -4378,1 +4634,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = minValue();\n@@ -4390,1 +4646,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4400,1 +4656,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4414,1 +4670,1 @@\n-        long ra = Long.MIN_VALUE;\n+        long ra = minValue();\n@@ -4424,1 +4680,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = minValue();\n@@ -4436,1 +4692,1 @@\n-        long res = (long) 0;\n+        long res = zeroValue();\n@@ -4445,1 +4701,1 @@\n-        long res = (long) 0;\n+        long res = zeroValue();\n@@ -4457,1 +4713,1 @@\n-        long ra = (long) 0;\n+        long ra = zeroValue();\n@@ -4467,1 +4723,1 @@\n-            ra = (long) 0;\n+            ra = zeroValue();\n@@ -4479,1 +4735,1 @@\n-        long res = (long) 0;\n+        long res = zeroValue();\n@@ -4489,1 +4745,1 @@\n-        long res = (long) 0;\n+        long res = zeroValue();\n@@ -4503,1 +4759,1 @@\n-        long ra = (long) 0;\n+        long ra = zeroValue();\n@@ -4513,1 +4769,1 @@\n-            ra = (long) 0;\n+            ra = zeroValue();\n@@ -4573,1 +4829,1 @@\n-        long res = 0;\n+        long res = zeroValue();\n@@ -4582,1 +4838,1 @@\n-        long res = 0;\n+        long res = zeroValue();\n@@ -4594,1 +4850,1 @@\n-        long ra = 0;\n+        long ra = zeroValue();\n@@ -4604,1 +4860,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4616,1 +4872,1 @@\n-        long res = 0;\n+        long res = zeroValue();\n@@ -4626,1 +4882,1 @@\n-        long res = 0;\n+        long res = zeroValue();\n@@ -4639,1 +4895,1 @@\n-        long ra = 0;\n+        long ra = zeroValue();\n@@ -4649,1 +4905,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4694,1 +4950,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -4714,1 +4970,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -4735,1 +4991,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -4755,1 +5011,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -4774,1 +5030,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4793,1 +5049,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4816,1 +5072,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -4835,1 +5091,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -4858,1 +5114,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -4877,1 +5133,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4896,1 +5152,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4919,1 +5175,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -4938,1 +5194,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -4961,1 +5217,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -4980,1 +5236,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -5003,1 +5259,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -5022,1 +5278,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -5045,1 +5301,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -5064,1 +5320,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n@@ -5087,1 +5343,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n@@ -5106,1 +5362,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n@@ -5129,1 +5385,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -5148,1 +5404,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n@@ -5171,1 +5427,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n@@ -5190,1 +5446,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n@@ -5213,1 +5469,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n@@ -5230,1 +5486,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -5250,1 +5506,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -5267,1 +5523,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -5287,1 +5543,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -5569,1 +5825,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -6000,1 +6256,1 @@\n-        return (long)(-((long)a));\n+        return (long)(scalar_neg((long)a));\n@@ -6004,1 +6260,1 @@\n-        return (long)(-((long)a));\n+        return (long)(scalar_neg((long)a));\n@@ -6056,1 +6312,1 @@\n-        return (long)(Math.abs((long)a));\n+        return (long)(scalar_abs((long)a));\n@@ -6060,1 +6316,1 @@\n-        return (long)(Math.abs((long)a));\n+        return (long)(scalar_abs((long)a));\n@@ -6400,1 +6656,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -6416,1 +6672,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -6590,1 +6846,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -6618,1 +6874,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -6632,1 +6888,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -6829,1 +7085,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -6849,1 +7105,1 @@\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -6872,1 +7128,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6886,1 +7142,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6908,1 +7164,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -6916,1 +7172,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -6923,1 +7179,1 @@\n-        Assert.assertEquals(elsize, Long.SIZE);\n+        AssertEquals(elsize, Long.SIZE);\n@@ -6942,1 +7198,1 @@\n-    static void ElementTypeLong512VectorTestsSmokeTest() {\n+    static void LongLong512VectorTestsSmokeTest() {\n@@ -6977,1 +7233,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":582,"deletions":326,"binary":false,"changes":908,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,39 @@\n+    static LongVector bcast_vec = LongVector.broadcast(SPECIES, (long)10);\n+\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected, long delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(long actual, long expected, long delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(long [] actual, long [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long [] actual, long [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -87,1 +126,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -90,1 +129,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -102,1 +141,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -108,1 +147,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -118,1 +157,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -121,1 +160,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -137,1 +176,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -139,1 +178,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -142,2 +181,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -159,1 +198,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -161,1 +200,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -164,2 +203,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -178,1 +217,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -181,1 +220,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -193,1 +232,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -196,1 +235,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -205,1 +244,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -210,1 +249,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -221,1 +260,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -226,1 +265,1 @@\n-                    Assert.assertEquals(r[i + k], (long)0);\n+                    AssertEquals(r[i + k], (long)0);\n@@ -232,1 +271,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -234,1 +273,1 @@\n-                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (long)0, \"at index #\" + idx);\n@@ -246,1 +285,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -249,1 +288,1 @@\n-                        Assert.assertEquals(r[i + j], (long)0);\n+                        AssertEquals(r[i + j], (long)0);\n@@ -256,1 +295,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -258,1 +297,1 @@\n-                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (long)0, \"at index #\" + idx);\n@@ -274,1 +313,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -278,1 +317,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -284,0 +323,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -287,1 +327,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -291,2 +333,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -302,1 +343,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -304,1 +345,1 @@\n-                         Assert.assertEquals(r[i+j], (long)0);\n+                         AssertEquals(r[i+j], (long)0);\n@@ -310,1 +351,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -312,1 +353,1 @@\n-                Assert.assertEquals(r[i+j], (long)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (long)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -318,0 +359,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -321,0 +363,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -322,1 +366,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -324,1 +368,1 @@\n-                         Assert.assertEquals(r[i+j], (long)0);\n+                         AssertEquals(r[i+j], (long)0);\n@@ -328,1 +372,0 @@\n-            int idx = i + j;\n@@ -330,1 +373,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -332,1 +375,1 @@\n-                Assert.assertEquals(r[i+j], (long)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (long)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -346,1 +389,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -349,1 +392,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -370,1 +413,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -373,1 +416,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -376,1 +419,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -379,3 +422,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -396,1 +439,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -399,1 +442,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -402,1 +445,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -405,3 +448,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -415,1 +458,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -418,1 +461,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -426,1 +469,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -429,1 +472,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -437,1 +480,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -440,1 +483,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -449,1 +492,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -452,1 +495,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -465,1 +508,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -468,1 +511,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -480,1 +523,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -483,1 +526,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -495,1 +538,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -498,1 +541,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -513,1 +556,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -516,1 +559,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -529,1 +572,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -533,1 +576,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -547,1 +590,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -551,1 +594,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -573,1 +616,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -577,1 +620,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -591,1 +634,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -595,1 +638,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -615,1 +658,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -618,1 +661,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -630,1 +673,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -633,1 +676,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -642,1 +685,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -645,1 +688,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -655,1 +698,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -658,1 +701,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -674,1 +717,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -678,1 +721,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -695,1 +738,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -699,1 +742,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -710,1 +753,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -714,1 +757,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -731,1 +774,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -735,1 +778,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -753,1 +796,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -759,1 +802,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -780,1 +823,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -786,1 +829,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -801,1 +844,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -807,1 +850,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -828,1 +871,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -834,1 +877,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -848,1 +891,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -854,1 +897,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -869,1 +912,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -875,1 +918,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -890,1 +933,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -896,1 +939,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -912,1 +955,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -918,1 +961,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -926,0 +969,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -942,1 +989,1 @@\n-            withToString(\"long[-i * 5]\", (int s) -> {\n+            withToString(\"Long[-i * 5]\", (int s) -> {\n@@ -944,1 +991,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -946,1 +993,1 @@\n-            withToString(\"long[i * 5]\", (int s) -> {\n+            withToString(\"Long[i * 5]\", (int s) -> {\n@@ -948,1 +995,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -950,1 +997,1 @@\n-            withToString(\"long[i + 1]\", (int s) -> {\n+            withToString(\"Long[i + 1]\", (int s) -> {\n@@ -952,1 +999,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -954,1 +1001,1 @@\n-            withToString(\"long[intCornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Long[intCornerCaseValue(i)]\", (int s) -> {\n@@ -964,1 +1011,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -967,1 +1014,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -977,1 +1024,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -980,1 +1027,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -988,1 +1035,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                AssertEquals(r[i], (double)(a[i+offs]));\n@@ -991,1 +1038,1 @@\n-            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1000,1 +1047,1 @@\n-            withToString(\"long[-i * 5]\", (int s) -> {\n+            withToString(\"Long[-i * 5]\", (int s) -> {\n@@ -1002,1 +1049,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1004,1 +1051,1 @@\n-            withToString(\"long[i * 5]\", (int s) -> {\n+            withToString(\"Long[i * 5]\", (int s) -> {\n@@ -1006,1 +1053,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1008,1 +1055,1 @@\n-            withToString(\"long[i + 1]\", (int s) -> {\n+            withToString(\"Long[i + 1]\", (int s) -> {\n@@ -1010,1 +1057,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1456,0 +1503,212 @@\n+    static long firstNonZero(long a, long b) {\n+        return Long.compare(a, (long) 0) != 0 ? a : b;\n+    }\n+\n+    static long multiplicativeIdentity() {\n+        return (long)1;\n+    }\n+\n+    static long scalar_or(long a, long b) {\n+        return (long)(a | b);\n+    }\n+\n+    static long scalar_and(long a, long b) {\n+        return (long)(a & b);\n+    }\n+\n+    static long scalar_xor(long a, long b) {\n+        return (long)(a ^ b);\n+    }\n+\n+    static long scalar_add(long a, long b) {\n+        return (long)(a + b);\n+    }\n+\n+    static long scalar_sub(long a, long b) {\n+        return (long)(a - b);\n+    }\n+\n+    static long scalar_mul(long a, long b) {\n+        return (long)(a * b);\n+    }\n+\n+    static long scalar_min(long a, long b) {\n+        return (long)(Math.min(a, b));\n+    }\n+\n+    static long scalar_max(long a, long b) {\n+        return (long)(Math.max(a, b));\n+    }\n+\n+    static long scalar_div(long a, long b) {\n+        return (long)(a \/ b);\n+    }\n+\n+    static long scalar_fma(long a, long b, long c) {\n+        return (long)(Math.fma(a, b, c));\n+    }\n+\n+    static long scalar_abs(long a) {\n+        return (long)(Math.abs(a));\n+    }\n+\n+    static long scalar_neg(long a) {\n+        return ((long)-a);\n+    }\n+\n+    static long scalar_sin(long a) {\n+        return (long)Math.sin((double)a);\n+    }\n+\n+    static long scalar_exp(long a) {\n+        return (long)Math.exp((double)a);\n+    }\n+\n+    static long scalar_log1p(long a) {\n+        return (long)Math.log1p((double)a);\n+    }\n+\n+    static long scalar_log(long a) {\n+        return (long)Math.log((double)a);\n+    }\n+\n+    static long scalar_log10(long a) {\n+        return (long)Math.log10((double)a);\n+    }\n+\n+    static long scalar_expm1(long a) {\n+        return (long)Math.expm1((double)a);\n+    }\n+\n+    static long scalar_cos(long a) {\n+        return (long)Math.cos((double)a);\n+    }\n+\n+    static long scalar_tan(long a) {\n+        return (long)Math.tan((double)a);\n+    }\n+\n+    static long scalar_sinh(long a) {\n+        return (long)Math.sinh((double)a);\n+    }\n+\n+    static long scalar_cosh(long a) {\n+        return (long)Math.cosh((double)a);\n+    }\n+\n+    static long scalar_tanh(long a) {\n+        return (long)Math.tanh((double)a);\n+    }\n+\n+    static long scalar_asin(long a) {\n+        return (long)Math.asin((double)a);\n+    }\n+\n+    static long scalar_acos(long a) {\n+        return (long)Math.acos((double)a);\n+    }\n+\n+    static long scalar_atan(long a) {\n+        return (long)Math.atan((double)a);\n+    }\n+\n+    static long scalar_cbrt(long a) {\n+        return (long)Math.cbrt((double)a);\n+    }\n+\n+    static long scalar_sqrt(long a) {\n+        return (long)Math.sqrt((double)a);\n+    }\n+\n+    static long scalar_hypot(long a, long b) {\n+        return (long)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static long scalar_pow(long a, long b) {\n+        return (long)Math.pow((double)a, (double)b);\n+    }\n+\n+    static long scalar_atan2(long a, long b) {\n+        return (long)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static long strict_scalar_sin(long a) {\n+        return (long)StrictMath.sin((double)a);\n+    }\n+\n+    static long strict_scalar_exp(long a) {\n+        return (long)StrictMath.exp((double)a);\n+    }\n+\n+    static long strict_scalar_log1p(long a) {\n+        return (long)StrictMath.log1p((double)a);\n+    }\n+\n+    static long strict_scalar_log(long a) {\n+        return (long)StrictMath.log((double)a);\n+    }\n+\n+    static long strict_scalar_log10(long a) {\n+        return (long)StrictMath.log10((double)a);\n+    }\n+\n+    static long strict_scalar_expm1(long a) {\n+        return (long)StrictMath.expm1((double)a);\n+    }\n+\n+    static long strict_scalar_cos(long a) {\n+        return (long)StrictMath.cos((double)a);\n+    }\n+\n+    static long strict_scalar_tan(long a) {\n+        return (long)StrictMath.tan((double)a);\n+    }\n+\n+    static long strict_scalar_sinh(long a) {\n+        return (long)StrictMath.sinh((double)a);\n+    }\n+\n+    static long strict_scalar_cosh(long a) {\n+        return (long)StrictMath.cosh((double)a);\n+    }\n+\n+    static long strict_scalar_tanh(long a) {\n+        return (long)StrictMath.tanh((double)a);\n+    }\n+\n+    static long strict_scalar_asin(long a) {\n+        return (long)StrictMath.asin((double)a);\n+    }\n+\n+    static long strict_scalar_acos(long a) {\n+        return (long)StrictMath.acos((double)a);\n+    }\n+\n+    static long strict_scalar_atan(long a) {\n+        return (long)StrictMath.atan((double)a);\n+    }\n+\n+    static long strict_scalar_cbrt(long a) {\n+        return (long)StrictMath.cbrt((double)a);\n+    }\n+\n+    static long strict_scalar_sqrt(long a) {\n+        return (long)StrictMath.sqrt((double)a);\n+    }\n+\n+    static long strict_scalar_hypot(long a, long b) {\n+        return (long)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static long strict_scalar_pow(long a, long b) {\n+        return (long)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static long strict_scalar_atan2(long a, long b) {\n+        return (long)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static long additiveIdentity() {\n+        return (long)0;\n+    }\n+\n+\n@@ -1472,2 +1731,6 @@\n-    static long firstNonZero(long a, long b) {\n-        return Long.compare(a, (long) 0) != 0 ? a : b;\n+    static long zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static long maxValue() {\n+        return Long.MAX_VALUE;\n@@ -1476,0 +1739,5 @@\n+    static long minValue() {\n+        return Long.MIN_VALUE;\n+    }\n+\n+\n@@ -1511,1 +1779,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1526,1 +1794,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1532,1 +1800,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1538,1 +1806,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1553,1 +1821,1 @@\n-        Assert.assertEquals(asIntegral.species(), SPECIES);\n+        AssertEquals(asIntegral.species(), SPECIES);\n@@ -1561,3 +1829,3 @@\n-        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n-        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n-        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n+        AssertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        AssertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n@@ -1588,1 +1856,1 @@\n-        return (long)(a + b);\n+        return (long)(scalar_add(a, b));\n@@ -1609,1 +1877,1 @@\n-        return (long)(a + b);\n+        return (long)(scalar_add(a, b));\n@@ -1666,1 +1934,1 @@\n-        return (long)(a - b);\n+        return (long)(scalar_sub(a, b));\n@@ -1687,1 +1955,1 @@\n-        return (long)(a - b);\n+        return (long)(scalar_sub(a, b));\n@@ -1744,1 +2012,1 @@\n-        return (long)(a * b);\n+        return (long)(scalar_mul(a, b));\n@@ -1765,1 +2033,1 @@\n-        return (long)(a * b);\n+        return (long)(scalar_mul(a, b));\n@@ -1912,1 +2180,1 @@\n-        return (long)((a)!=0?a:b);\n+        return (long)(firstNonZero(a, b));\n@@ -3101,2 +3369,0 @@\n-    static LongVector bv_MIN = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3111,1 +3377,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -3118,2 +3384,0 @@\n-    static LongVector bv_min = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3128,1 +3392,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -3135,2 +3399,0 @@\n-    static LongVector bv_MIN_M = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3147,1 +3409,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -3154,2 +3416,0 @@\n-    static LongVector bv_MAX = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3164,1 +3424,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -3171,2 +3431,0 @@\n-    static LongVector bv_max = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3181,1 +3439,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -3188,2 +3446,0 @@\n-    static LongVector bv_MAX_M = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3200,1 +3456,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -3208,1 +3464,1 @@\n-        return (long)(Math.min(a, b));\n+        return (long)(scalar_min(a, b));\n@@ -3229,1 +3485,1 @@\n-        return (long)(Math.min(a, b));\n+        return (long)(scalar_min(a, b));\n@@ -3248,1 +3504,1 @@\n-        return (long)(Math.max(a, b));\n+        return (long)(scalar_max(a, b));\n@@ -3269,1 +3525,1 @@\n-        return (long)(Math.max(a, b));\n+        return (long)(scalar_max(a, b));\n@@ -3637,1 +3893,1 @@\n-            res &= a[i];\n+            res = scalar_and(res, a[i]);\n@@ -3646,1 +3902,1 @@\n-            res &= ANDReduce(a, i);\n+            res = scalar_and(res, ANDReduce(a, i));\n@@ -3669,1 +3925,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND));\n@@ -3681,1 +3937,1 @@\n-                res &= a[i];\n+                res = scalar_and(res, a[i]);\n@@ -3690,1 +3946,1 @@\n-            res &= ANDReduceMasked(a, i, mask);\n+            res = scalar_and(res, ANDReduceMasked(a, i, mask));\n@@ -3715,1 +3971,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND, vmask));\n@@ -3726,1 +3982,1 @@\n-            res |= a[i];\n+            res = scalar_or(res, a[i]);\n@@ -3735,1 +3991,1 @@\n-            res |= ORReduce(a, i);\n+            res = scalar_or(res, ORReduce(a, i));\n@@ -3758,1 +4014,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR));\n@@ -3770,1 +4026,1 @@\n-                res |= a[i];\n+                res = scalar_or(res, a[i]);\n@@ -3779,1 +4035,1 @@\n-            res |= ORReduceMasked(a, i, mask);\n+            res = scalar_or(res, ORReduceMasked(a, i, mask));\n@@ -3804,1 +4060,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR, vmask));\n@@ -3815,1 +4071,1 @@\n-            res ^= a[i];\n+            res = scalar_xor(res, a[i]);\n@@ -3824,1 +4080,1 @@\n-            res ^= XORReduce(a, i);\n+            res = scalar_xor(res, XORReduce(a, i));\n@@ -3847,1 +4103,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR));\n@@ -3859,1 +4115,1 @@\n-                res ^= a[i];\n+                res = scalar_xor(res, a[i]);\n@@ -3868,1 +4124,1 @@\n-            res ^= XORReduceMasked(a, i, mask);\n+            res = scalar_xor(res, XORReduceMasked(a, i, mask));\n@@ -3893,1 +4149,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR, vmask));\n@@ -3902,1 +4158,1 @@\n-        long res = 0;\n+        long res = additiveIdentity();\n@@ -3904,1 +4160,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -3911,1 +4167,1 @@\n-        long res = 0;\n+        long res = additiveIdentity();\n@@ -3913,1 +4169,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -3923,1 +4179,1 @@\n-        long ra = 0;\n+        long ra = additiveIdentity();\n@@ -3933,1 +4189,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3936,1 +4192,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -3945,1 +4201,1 @@\n-        long res = 0;\n+        long res = additiveIdentity();\n@@ -3948,1 +4204,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -3955,1 +4211,1 @@\n-        long res = 0;\n+        long res = additiveIdentity();\n@@ -3957,1 +4213,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -3969,1 +4225,1 @@\n-        long ra = 0;\n+        long ra = additiveIdentity();\n@@ -3979,1 +4235,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3982,1 +4238,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -3991,1 +4247,1 @@\n-        long res = 1;\n+        long res = multiplicativeIdentity();\n@@ -3993,1 +4249,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -4000,1 +4256,1 @@\n-        long res = 1;\n+        long res = multiplicativeIdentity();\n@@ -4002,1 +4258,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -4012,1 +4268,1 @@\n-        long ra = 1;\n+        long ra = multiplicativeIdentity();\n@@ -4022,1 +4278,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -4025,1 +4281,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -4034,1 +4290,1 @@\n-        long res = 1;\n+        long res = multiplicativeIdentity();\n@@ -4037,1 +4293,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -4044,1 +4300,1 @@\n-        long res = 1;\n+        long res = multiplicativeIdentity();\n@@ -4046,1 +4302,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -4058,1 +4314,1 @@\n-        long ra = 1;\n+        long ra = multiplicativeIdentity();\n@@ -4068,1 +4324,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -4071,1 +4327,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -4080,1 +4336,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4082,1 +4338,1 @@\n-            res = (long) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -4089,1 +4345,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4091,1 +4347,1 @@\n-            res = (long) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -4101,1 +4357,1 @@\n-        long ra = Long.MAX_VALUE;\n+        long ra = maxValue();\n@@ -4111,1 +4367,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = maxValue();\n@@ -4114,1 +4370,1 @@\n-                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -4123,1 +4379,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4126,1 +4382,1 @@\n-                res = (long) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -4133,1 +4389,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4135,1 +4391,1 @@\n-            res = (long) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -4147,1 +4403,1 @@\n-        long ra = Long.MAX_VALUE;\n+        long ra = maxValue();\n@@ -4157,1 +4413,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = maxValue();\n@@ -4160,1 +4416,1 @@\n-                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -4169,1 +4425,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4171,1 +4427,1 @@\n-            res = (long) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -4178,1 +4434,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4180,1 +4436,1 @@\n-            res = (long) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -4190,1 +4446,1 @@\n-        long ra = Long.MIN_VALUE;\n+        long ra = minValue();\n@@ -4200,1 +4456,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = minValue();\n@@ -4203,1 +4459,1 @@\n-                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -4212,1 +4468,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4215,1 +4471,1 @@\n-                res = (long) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -4222,1 +4478,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4224,1 +4480,1 @@\n-            res = (long) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -4236,1 +4492,1 @@\n-        long ra = Long.MIN_VALUE;\n+        long ra = minValue();\n@@ -4246,1 +4502,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = minValue();\n@@ -4249,1 +4505,1 @@\n-                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -4258,1 +4514,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4267,1 +4523,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4279,1 +4535,1 @@\n-        long ra = Long.MAX_VALUE;\n+        long ra = maxValue();\n@@ -4289,1 +4545,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = maxValue();\n@@ -4301,1 +4557,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4311,1 +4567,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4325,1 +4581,1 @@\n-        long ra = Long.MAX_VALUE;\n+        long ra = maxValue();\n@@ -4335,1 +4591,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = maxValue();\n@@ -4347,1 +4603,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4356,1 +4612,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4368,1 +4624,1 @@\n-        long ra = Long.MIN_VALUE;\n+        long ra = minValue();\n@@ -4378,1 +4634,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = minValue();\n@@ -4390,1 +4646,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4400,1 +4656,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4414,1 +4670,1 @@\n-        long ra = Long.MIN_VALUE;\n+        long ra = minValue();\n@@ -4424,1 +4680,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = minValue();\n@@ -4436,1 +4692,1 @@\n-        long res = (long) 0;\n+        long res = zeroValue();\n@@ -4445,1 +4701,1 @@\n-        long res = (long) 0;\n+        long res = zeroValue();\n@@ -4457,1 +4713,1 @@\n-        long ra = (long) 0;\n+        long ra = zeroValue();\n@@ -4467,1 +4723,1 @@\n-            ra = (long) 0;\n+            ra = zeroValue();\n@@ -4479,1 +4735,1 @@\n-        long res = (long) 0;\n+        long res = zeroValue();\n@@ -4489,1 +4745,1 @@\n-        long res = (long) 0;\n+        long res = zeroValue();\n@@ -4503,1 +4759,1 @@\n-        long ra = (long) 0;\n+        long ra = zeroValue();\n@@ -4513,1 +4769,1 @@\n-            ra = (long) 0;\n+            ra = zeroValue();\n@@ -4573,1 +4829,1 @@\n-        long res = 0;\n+        long res = zeroValue();\n@@ -4582,1 +4838,1 @@\n-        long res = 0;\n+        long res = zeroValue();\n@@ -4594,1 +4850,1 @@\n-        long ra = 0;\n+        long ra = zeroValue();\n@@ -4604,1 +4860,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4616,1 +4872,1 @@\n-        long res = 0;\n+        long res = zeroValue();\n@@ -4626,1 +4882,1 @@\n-        long res = 0;\n+        long res = zeroValue();\n@@ -4639,1 +4895,1 @@\n-        long ra = 0;\n+        long ra = zeroValue();\n@@ -4649,1 +4905,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4694,1 +4950,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -4714,1 +4970,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -4735,1 +4991,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -4755,1 +5011,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -4774,1 +5030,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4793,1 +5049,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4816,1 +5072,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -4835,1 +5091,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -4858,1 +5114,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -4877,1 +5133,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4896,1 +5152,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4919,1 +5175,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -4938,1 +5194,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -4961,1 +5217,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -4980,1 +5236,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -5003,1 +5259,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -5022,1 +5278,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -5045,1 +5301,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -5064,1 +5320,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n@@ -5087,1 +5343,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n@@ -5106,1 +5362,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n@@ -5129,1 +5385,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -5148,1 +5404,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n@@ -5171,1 +5427,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n@@ -5190,1 +5446,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n@@ -5213,1 +5469,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n@@ -5230,1 +5486,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -5250,1 +5506,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -5267,1 +5523,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -5287,1 +5543,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -5569,1 +5825,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -6000,1 +6256,1 @@\n-        return (long)(-((long)a));\n+        return (long)(scalar_neg((long)a));\n@@ -6004,1 +6260,1 @@\n-        return (long)(-((long)a));\n+        return (long)(scalar_neg((long)a));\n@@ -6056,1 +6312,1 @@\n-        return (long)(Math.abs((long)a));\n+        return (long)(scalar_abs((long)a));\n@@ -6060,1 +6316,1 @@\n-        return (long)(Math.abs((long)a));\n+        return (long)(scalar_abs((long)a));\n@@ -6400,1 +6656,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -6416,1 +6672,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -6590,1 +6846,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -6618,1 +6874,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -6632,1 +6888,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -6829,1 +7085,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -6849,1 +7105,1 @@\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -6872,1 +7128,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6886,1 +7142,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6908,1 +7164,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -6916,1 +7172,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -6923,1 +7179,1 @@\n-        Assert.assertEquals(elsize, Long.SIZE);\n+        AssertEquals(elsize, Long.SIZE);\n@@ -6942,1 +7198,1 @@\n-    static void ElementTypeLong64VectorTestsSmokeTest() {\n+    static void LongLong64VectorTestsSmokeTest() {\n@@ -6977,1 +7233,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":582,"deletions":326,"binary":false,"changes":908,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,39 @@\n+    static LongVector bcast_vec = LongVector.broadcast(SPECIES, (long)10);\n+\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected, long delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(long actual, long expected, long delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(long [] actual, long [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long [] actual, long [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -92,1 +131,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -95,1 +134,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -107,1 +146,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -113,1 +152,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -123,1 +162,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -126,1 +165,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -142,1 +181,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -144,1 +183,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -147,2 +186,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -164,1 +203,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -166,1 +205,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -169,2 +208,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -183,1 +222,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -186,1 +225,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -198,1 +237,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -201,1 +240,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -210,1 +249,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -215,1 +254,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -226,1 +265,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -231,1 +270,1 @@\n-                    Assert.assertEquals(r[i + k], (long)0);\n+                    AssertEquals(r[i + k], (long)0);\n@@ -237,1 +276,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -239,1 +278,1 @@\n-                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (long)0, \"at index #\" + idx);\n@@ -251,1 +290,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -254,1 +293,1 @@\n-                        Assert.assertEquals(r[i + j], (long)0);\n+                        AssertEquals(r[i + j], (long)0);\n@@ -261,1 +300,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -263,1 +302,1 @@\n-                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (long)0, \"at index #\" + idx);\n@@ -279,1 +318,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -283,1 +322,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -289,0 +328,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -292,1 +332,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -296,2 +338,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -307,1 +348,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -309,1 +350,1 @@\n-                         Assert.assertEquals(r[i+j], (long)0);\n+                         AssertEquals(r[i+j], (long)0);\n@@ -315,1 +356,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -317,1 +358,1 @@\n-                Assert.assertEquals(r[i+j], (long)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (long)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -323,0 +364,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -326,0 +368,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -327,1 +371,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -329,1 +373,1 @@\n-                         Assert.assertEquals(r[i+j], (long)0);\n+                         AssertEquals(r[i+j], (long)0);\n@@ -333,1 +377,0 @@\n-            int idx = i + j;\n@@ -335,1 +378,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -337,1 +380,1 @@\n-                Assert.assertEquals(r[i+j], (long)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (long)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -351,1 +394,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -354,1 +397,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -375,1 +418,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -378,1 +421,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -381,1 +424,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -384,3 +427,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -401,1 +444,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -404,1 +447,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -407,1 +450,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -410,3 +453,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -420,1 +463,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -423,1 +466,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -431,1 +474,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -434,1 +477,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -442,1 +485,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -445,1 +488,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -454,1 +497,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -457,1 +500,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -470,1 +513,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -473,1 +516,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -485,1 +528,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -488,1 +531,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -500,1 +543,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -503,1 +546,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -518,1 +561,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -521,1 +564,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (long)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -534,1 +577,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -538,1 +581,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -552,1 +595,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -556,1 +599,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -578,1 +621,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -582,1 +625,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -596,1 +639,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -600,1 +643,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -620,1 +663,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -623,1 +666,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -635,1 +678,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -638,1 +681,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -647,1 +690,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -650,1 +693,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -660,1 +703,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -663,1 +706,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -679,1 +722,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -683,1 +726,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -700,1 +743,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -704,1 +747,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -715,1 +758,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -719,1 +762,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -736,1 +779,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -740,1 +783,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -758,1 +801,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -764,1 +807,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -785,1 +828,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -791,1 +834,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -806,1 +849,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -812,1 +855,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -833,1 +876,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -839,1 +882,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -853,1 +896,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -859,1 +902,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -874,1 +917,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -880,1 +923,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -895,1 +938,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -901,1 +944,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -917,1 +960,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -923,1 +966,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -931,0 +974,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -947,1 +994,1 @@\n-            withToString(\"long[-i * 5]\", (int s) -> {\n+            withToString(\"Long[-i * 5]\", (int s) -> {\n@@ -949,1 +996,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -951,1 +998,1 @@\n-            withToString(\"long[i * 5]\", (int s) -> {\n+            withToString(\"Long[i * 5]\", (int s) -> {\n@@ -953,1 +1000,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -955,1 +1002,1 @@\n-            withToString(\"long[i + 1]\", (int s) -> {\n+            withToString(\"Long[i + 1]\", (int s) -> {\n@@ -957,1 +1004,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -959,1 +1006,1 @@\n-            withToString(\"long[intCornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Long[intCornerCaseValue(i)]\", (int s) -> {\n@@ -969,1 +1016,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -972,1 +1019,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -982,1 +1029,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -985,1 +1032,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -993,1 +1040,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                AssertEquals(r[i], (double)(a[i+offs]));\n@@ -996,1 +1043,1 @@\n-            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1005,1 +1052,1 @@\n-            withToString(\"long[-i * 5]\", (int s) -> {\n+            withToString(\"Long[-i * 5]\", (int s) -> {\n@@ -1007,1 +1054,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1009,1 +1056,1 @@\n-            withToString(\"long[i * 5]\", (int s) -> {\n+            withToString(\"Long[i * 5]\", (int s) -> {\n@@ -1011,1 +1058,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1013,1 +1060,1 @@\n-            withToString(\"long[i + 1]\", (int s) -> {\n+            withToString(\"Long[i + 1]\", (int s) -> {\n@@ -1015,1 +1062,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1461,0 +1508,212 @@\n+    static long firstNonZero(long a, long b) {\n+        return Long.compare(a, (long) 0) != 0 ? a : b;\n+    }\n+\n+    static long multiplicativeIdentity() {\n+        return (long)1;\n+    }\n+\n+    static long scalar_or(long a, long b) {\n+        return (long)(a | b);\n+    }\n+\n+    static long scalar_and(long a, long b) {\n+        return (long)(a & b);\n+    }\n+\n+    static long scalar_xor(long a, long b) {\n+        return (long)(a ^ b);\n+    }\n+\n+    static long scalar_add(long a, long b) {\n+        return (long)(a + b);\n+    }\n+\n+    static long scalar_sub(long a, long b) {\n+        return (long)(a - b);\n+    }\n+\n+    static long scalar_mul(long a, long b) {\n+        return (long)(a * b);\n+    }\n+\n+    static long scalar_min(long a, long b) {\n+        return (long)(Math.min(a, b));\n+    }\n+\n+    static long scalar_max(long a, long b) {\n+        return (long)(Math.max(a, b));\n+    }\n+\n+    static long scalar_div(long a, long b) {\n+        return (long)(a \/ b);\n+    }\n+\n+    static long scalar_fma(long a, long b, long c) {\n+        return (long)(Math.fma(a, b, c));\n+    }\n+\n+    static long scalar_abs(long a) {\n+        return (long)(Math.abs(a));\n+    }\n+\n+    static long scalar_neg(long a) {\n+        return ((long)-a);\n+    }\n+\n+    static long scalar_sin(long a) {\n+        return (long)Math.sin((double)a);\n+    }\n+\n+    static long scalar_exp(long a) {\n+        return (long)Math.exp((double)a);\n+    }\n+\n+    static long scalar_log1p(long a) {\n+        return (long)Math.log1p((double)a);\n+    }\n+\n+    static long scalar_log(long a) {\n+        return (long)Math.log((double)a);\n+    }\n+\n+    static long scalar_log10(long a) {\n+        return (long)Math.log10((double)a);\n+    }\n+\n+    static long scalar_expm1(long a) {\n+        return (long)Math.expm1((double)a);\n+    }\n+\n+    static long scalar_cos(long a) {\n+        return (long)Math.cos((double)a);\n+    }\n+\n+    static long scalar_tan(long a) {\n+        return (long)Math.tan((double)a);\n+    }\n+\n+    static long scalar_sinh(long a) {\n+        return (long)Math.sinh((double)a);\n+    }\n+\n+    static long scalar_cosh(long a) {\n+        return (long)Math.cosh((double)a);\n+    }\n+\n+    static long scalar_tanh(long a) {\n+        return (long)Math.tanh((double)a);\n+    }\n+\n+    static long scalar_asin(long a) {\n+        return (long)Math.asin((double)a);\n+    }\n+\n+    static long scalar_acos(long a) {\n+        return (long)Math.acos((double)a);\n+    }\n+\n+    static long scalar_atan(long a) {\n+        return (long)Math.atan((double)a);\n+    }\n+\n+    static long scalar_cbrt(long a) {\n+        return (long)Math.cbrt((double)a);\n+    }\n+\n+    static long scalar_sqrt(long a) {\n+        return (long)Math.sqrt((double)a);\n+    }\n+\n+    static long scalar_hypot(long a, long b) {\n+        return (long)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static long scalar_pow(long a, long b) {\n+        return (long)Math.pow((double)a, (double)b);\n+    }\n+\n+    static long scalar_atan2(long a, long b) {\n+        return (long)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static long strict_scalar_sin(long a) {\n+        return (long)StrictMath.sin((double)a);\n+    }\n+\n+    static long strict_scalar_exp(long a) {\n+        return (long)StrictMath.exp((double)a);\n+    }\n+\n+    static long strict_scalar_log1p(long a) {\n+        return (long)StrictMath.log1p((double)a);\n+    }\n+\n+    static long strict_scalar_log(long a) {\n+        return (long)StrictMath.log((double)a);\n+    }\n+\n+    static long strict_scalar_log10(long a) {\n+        return (long)StrictMath.log10((double)a);\n+    }\n+\n+    static long strict_scalar_expm1(long a) {\n+        return (long)StrictMath.expm1((double)a);\n+    }\n+\n+    static long strict_scalar_cos(long a) {\n+        return (long)StrictMath.cos((double)a);\n+    }\n+\n+    static long strict_scalar_tan(long a) {\n+        return (long)StrictMath.tan((double)a);\n+    }\n+\n+    static long strict_scalar_sinh(long a) {\n+        return (long)StrictMath.sinh((double)a);\n+    }\n+\n+    static long strict_scalar_cosh(long a) {\n+        return (long)StrictMath.cosh((double)a);\n+    }\n+\n+    static long strict_scalar_tanh(long a) {\n+        return (long)StrictMath.tanh((double)a);\n+    }\n+\n+    static long strict_scalar_asin(long a) {\n+        return (long)StrictMath.asin((double)a);\n+    }\n+\n+    static long strict_scalar_acos(long a) {\n+        return (long)StrictMath.acos((double)a);\n+    }\n+\n+    static long strict_scalar_atan(long a) {\n+        return (long)StrictMath.atan((double)a);\n+    }\n+\n+    static long strict_scalar_cbrt(long a) {\n+        return (long)StrictMath.cbrt((double)a);\n+    }\n+\n+    static long strict_scalar_sqrt(long a) {\n+        return (long)StrictMath.sqrt((double)a);\n+    }\n+\n+    static long strict_scalar_hypot(long a, long b) {\n+        return (long)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static long strict_scalar_pow(long a, long b) {\n+        return (long)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static long strict_scalar_atan2(long a, long b) {\n+        return (long)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static long additiveIdentity() {\n+        return (long)0;\n+    }\n+\n+\n@@ -1477,2 +1736,6 @@\n-    static long firstNonZero(long a, long b) {\n-        return Long.compare(a, (long) 0) != 0 ? a : b;\n+    static long zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static long maxValue() {\n+        return Long.MAX_VALUE;\n@@ -1481,0 +1744,5 @@\n+    static long minValue() {\n+        return Long.MIN_VALUE;\n+    }\n+\n+\n@@ -1516,1 +1784,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1531,1 +1799,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1537,1 +1805,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1543,1 +1811,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1558,1 +1826,1 @@\n-        Assert.assertEquals(asIntegral.species(), SPECIES);\n+        AssertEquals(asIntegral.species(), SPECIES);\n@@ -1566,3 +1834,3 @@\n-        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n-        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n-        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n+        AssertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        AssertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n@@ -1593,1 +1861,1 @@\n-        return (long)(a + b);\n+        return (long)(scalar_add(a, b));\n@@ -1614,1 +1882,1 @@\n-        return (long)(a + b);\n+        return (long)(scalar_add(a, b));\n@@ -1671,1 +1939,1 @@\n-        return (long)(a - b);\n+        return (long)(scalar_sub(a, b));\n@@ -1692,1 +1960,1 @@\n-        return (long)(a - b);\n+        return (long)(scalar_sub(a, b));\n@@ -1749,1 +2017,1 @@\n-        return (long)(a * b);\n+        return (long)(scalar_mul(a, b));\n@@ -1770,1 +2038,1 @@\n-        return (long)(a * b);\n+        return (long)(scalar_mul(a, b));\n@@ -1917,1 +2185,1 @@\n-        return (long)((a)!=0?a:b);\n+        return (long)(firstNonZero(a, b));\n@@ -3106,2 +3374,0 @@\n-    static LongVector bv_MIN = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3116,1 +3382,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -3123,2 +3389,0 @@\n-    static LongVector bv_min = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3133,1 +3397,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -3140,2 +3404,0 @@\n-    static LongVector bv_MIN_M = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3152,1 +3414,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -3159,2 +3421,0 @@\n-    static LongVector bv_MAX = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3169,1 +3429,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -3176,2 +3436,0 @@\n-    static LongVector bv_max = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3186,1 +3444,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -3193,2 +3451,0 @@\n-    static LongVector bv_MAX_M = LongVector.broadcast(SPECIES, (long)10);\n-\n@@ -3205,1 +3461,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -3213,1 +3469,1 @@\n-        return (long)(Math.min(a, b));\n+        return (long)(scalar_min(a, b));\n@@ -3234,1 +3490,1 @@\n-        return (long)(Math.min(a, b));\n+        return (long)(scalar_min(a, b));\n@@ -3253,1 +3509,1 @@\n-        return (long)(Math.max(a, b));\n+        return (long)(scalar_max(a, b));\n@@ -3274,1 +3530,1 @@\n-        return (long)(Math.max(a, b));\n+        return (long)(scalar_max(a, b));\n@@ -3642,1 +3898,1 @@\n-            res &= a[i];\n+            res = scalar_and(res, a[i]);\n@@ -3651,1 +3907,1 @@\n-            res &= ANDReduce(a, i);\n+            res = scalar_and(res, ANDReduce(a, i));\n@@ -3674,1 +3930,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND));\n@@ -3686,1 +3942,1 @@\n-                res &= a[i];\n+                res = scalar_and(res, a[i]);\n@@ -3695,1 +3951,1 @@\n-            res &= ANDReduceMasked(a, i, mask);\n+            res = scalar_and(res, ANDReduceMasked(a, i, mask));\n@@ -3720,1 +3976,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND, vmask));\n@@ -3731,1 +3987,1 @@\n-            res |= a[i];\n+            res = scalar_or(res, a[i]);\n@@ -3740,1 +3996,1 @@\n-            res |= ORReduce(a, i);\n+            res = scalar_or(res, ORReduce(a, i));\n@@ -3763,1 +4019,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR));\n@@ -3775,1 +4031,1 @@\n-                res |= a[i];\n+                res = scalar_or(res, a[i]);\n@@ -3784,1 +4040,1 @@\n-            res |= ORReduceMasked(a, i, mask);\n+            res = scalar_or(res, ORReduceMasked(a, i, mask));\n@@ -3809,1 +4065,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR, vmask));\n@@ -3820,1 +4076,1 @@\n-            res ^= a[i];\n+            res = scalar_xor(res, a[i]);\n@@ -3829,1 +4085,1 @@\n-            res ^= XORReduce(a, i);\n+            res = scalar_xor(res, XORReduce(a, i));\n@@ -3852,1 +4108,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR));\n@@ -3864,1 +4120,1 @@\n-                res ^= a[i];\n+                res = scalar_xor(res, a[i]);\n@@ -3873,1 +4129,1 @@\n-            res ^= XORReduceMasked(a, i, mask);\n+            res = scalar_xor(res, XORReduceMasked(a, i, mask));\n@@ -3898,1 +4154,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR, vmask));\n@@ -3907,1 +4163,1 @@\n-        long res = 0;\n+        long res = additiveIdentity();\n@@ -3909,1 +4165,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -3916,1 +4172,1 @@\n-        long res = 0;\n+        long res = additiveIdentity();\n@@ -3918,1 +4174,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -3928,1 +4184,1 @@\n-        long ra = 0;\n+        long ra = additiveIdentity();\n@@ -3938,1 +4194,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3941,1 +4197,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -3950,1 +4206,1 @@\n-        long res = 0;\n+        long res = additiveIdentity();\n@@ -3953,1 +4209,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -3960,1 +4216,1 @@\n-        long res = 0;\n+        long res = additiveIdentity();\n@@ -3962,1 +4218,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -3974,1 +4230,1 @@\n-        long ra = 0;\n+        long ra = additiveIdentity();\n@@ -3984,1 +4240,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3987,1 +4243,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -3996,1 +4252,1 @@\n-        long res = 1;\n+        long res = multiplicativeIdentity();\n@@ -3998,1 +4254,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -4005,1 +4261,1 @@\n-        long res = 1;\n+        long res = multiplicativeIdentity();\n@@ -4007,1 +4263,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -4017,1 +4273,1 @@\n-        long ra = 1;\n+        long ra = multiplicativeIdentity();\n@@ -4027,1 +4283,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -4030,1 +4286,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -4039,1 +4295,1 @@\n-        long res = 1;\n+        long res = multiplicativeIdentity();\n@@ -4042,1 +4298,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -4049,1 +4305,1 @@\n-        long res = 1;\n+        long res = multiplicativeIdentity();\n@@ -4051,1 +4307,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -4063,1 +4319,1 @@\n-        long ra = 1;\n+        long ra = multiplicativeIdentity();\n@@ -4073,1 +4329,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -4076,1 +4332,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -4085,1 +4341,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4087,1 +4343,1 @@\n-            res = (long) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -4094,1 +4350,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4096,1 +4352,1 @@\n-            res = (long) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -4106,1 +4362,1 @@\n-        long ra = Long.MAX_VALUE;\n+        long ra = maxValue();\n@@ -4116,1 +4372,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = maxValue();\n@@ -4119,1 +4375,1 @@\n-                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -4128,1 +4384,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4131,1 +4387,1 @@\n-                res = (long) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -4138,1 +4394,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4140,1 +4396,1 @@\n-            res = (long) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -4152,1 +4408,1 @@\n-        long ra = Long.MAX_VALUE;\n+        long ra = maxValue();\n@@ -4162,1 +4418,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = maxValue();\n@@ -4165,1 +4421,1 @@\n-                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -4174,1 +4430,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4176,1 +4432,1 @@\n-            res = (long) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -4183,1 +4439,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4185,1 +4441,1 @@\n-            res = (long) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -4195,1 +4451,1 @@\n-        long ra = Long.MIN_VALUE;\n+        long ra = minValue();\n@@ -4205,1 +4461,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = minValue();\n@@ -4208,1 +4464,1 @@\n-                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -4217,1 +4473,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4220,1 +4476,1 @@\n-                res = (long) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -4227,1 +4483,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4229,1 +4485,1 @@\n-            res = (long) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -4241,1 +4497,1 @@\n-        long ra = Long.MIN_VALUE;\n+        long ra = minValue();\n@@ -4251,1 +4507,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = minValue();\n@@ -4254,1 +4510,1 @@\n-                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -4263,1 +4519,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4272,1 +4528,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4284,1 +4540,1 @@\n-        long ra = Long.MAX_VALUE;\n+        long ra = maxValue();\n@@ -4294,1 +4550,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = maxValue();\n@@ -4306,1 +4562,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4316,1 +4572,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = maxValue();\n@@ -4330,1 +4586,1 @@\n-        long ra = Long.MAX_VALUE;\n+        long ra = maxValue();\n@@ -4340,1 +4596,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = maxValue();\n@@ -4352,1 +4608,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4361,1 +4617,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4373,1 +4629,1 @@\n-        long ra = Long.MIN_VALUE;\n+        long ra = minValue();\n@@ -4383,1 +4639,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = minValue();\n@@ -4395,1 +4651,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4405,1 +4661,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = minValue();\n@@ -4419,1 +4675,1 @@\n-        long ra = Long.MIN_VALUE;\n+        long ra = minValue();\n@@ -4429,1 +4685,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = minValue();\n@@ -4441,1 +4697,1 @@\n-        long res = (long) 0;\n+        long res = zeroValue();\n@@ -4450,1 +4706,1 @@\n-        long res = (long) 0;\n+        long res = zeroValue();\n@@ -4462,1 +4718,1 @@\n-        long ra = (long) 0;\n+        long ra = zeroValue();\n@@ -4472,1 +4728,1 @@\n-            ra = (long) 0;\n+            ra = zeroValue();\n@@ -4484,1 +4740,1 @@\n-        long res = (long) 0;\n+        long res = zeroValue();\n@@ -4494,1 +4750,1 @@\n-        long res = (long) 0;\n+        long res = zeroValue();\n@@ -4508,1 +4764,1 @@\n-        long ra = (long) 0;\n+        long ra = zeroValue();\n@@ -4518,1 +4774,1 @@\n-            ra = (long) 0;\n+            ra = zeroValue();\n@@ -4578,1 +4834,1 @@\n-        long res = 0;\n+        long res = zeroValue();\n@@ -4587,1 +4843,1 @@\n-        long res = 0;\n+        long res = zeroValue();\n@@ -4599,1 +4855,1 @@\n-        long ra = 0;\n+        long ra = zeroValue();\n@@ -4609,1 +4865,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4621,1 +4877,1 @@\n-        long res = 0;\n+        long res = zeroValue();\n@@ -4631,1 +4887,1 @@\n-        long res = 0;\n+        long res = zeroValue();\n@@ -4644,1 +4900,1 @@\n-        long ra = 0;\n+        long ra = zeroValue();\n@@ -4654,1 +4910,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4699,1 +4955,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -4719,1 +4975,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -4740,1 +4996,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -4760,1 +5016,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -4779,1 +5035,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4798,1 +5054,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4821,1 +5077,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -4840,1 +5096,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -4863,1 +5119,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -4882,1 +5138,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4901,1 +5157,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4924,1 +5180,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -4943,1 +5199,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -4966,1 +5222,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -4985,1 +5241,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -5008,1 +5264,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -5027,1 +5283,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -5050,1 +5306,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -5069,1 +5325,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n@@ -5092,1 +5348,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n@@ -5111,1 +5367,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n@@ -5134,1 +5390,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -5153,1 +5409,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n@@ -5176,1 +5432,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n@@ -5195,1 +5451,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n@@ -5218,1 +5474,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n@@ -5235,1 +5491,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -5255,1 +5511,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -5272,1 +5528,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -5292,1 +5548,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -5574,1 +5830,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -6005,1 +6261,1 @@\n-        return (long)(-((long)a));\n+        return (long)(scalar_neg((long)a));\n@@ -6009,1 +6265,1 @@\n-        return (long)(-((long)a));\n+        return (long)(scalar_neg((long)a));\n@@ -6061,1 +6317,1 @@\n-        return (long)(Math.abs((long)a));\n+        return (long)(scalar_abs((long)a));\n@@ -6065,1 +6321,1 @@\n-        return (long)(Math.abs((long)a));\n+        return (long)(scalar_abs((long)a));\n@@ -6405,1 +6661,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -6421,1 +6677,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -6595,1 +6851,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -6623,1 +6879,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -6637,1 +6893,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -6834,1 +7090,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -6861,1 +7117,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6875,1 +7131,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6897,1 +7153,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -6905,1 +7161,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -6912,1 +7168,1 @@\n-        Assert.assertEquals(elsize, Long.SIZE);\n+        AssertEquals(elsize, Long.SIZE);\n@@ -6931,1 +7187,1 @@\n-    static void ElementTypeLongMaxVectorTestsSmokeTest() {\n+    static void LongLongMaxVectorTestsSmokeTest() {\n@@ -6966,1 +7222,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":581,"deletions":325,"binary":false,"changes":906,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,45 @@\n+    static ShortVector bcast_vec = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    static void AssertEquals(short actual, short expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(short actual, short expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(short actual, short expected, short delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(short actual, short expected, short delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(short [] actual, short [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(short [] actual, short [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -87,1 +132,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -90,1 +135,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -102,1 +147,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -108,1 +153,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -118,1 +163,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -121,1 +166,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -137,1 +182,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -139,1 +184,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -142,2 +187,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -159,1 +204,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -161,1 +206,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -164,2 +209,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -181,1 +226,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -183,1 +228,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -186,2 +231,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -203,1 +248,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -205,1 +250,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -208,2 +253,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -221,1 +266,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -224,1 +269,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -236,1 +281,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -239,1 +284,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -248,1 +293,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -253,1 +298,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -264,1 +309,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -269,1 +314,1 @@\n-                    Assert.assertEquals(r[i + k], (short)0);\n+                    AssertEquals(r[i + k], (short)0);\n@@ -275,1 +320,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -277,1 +322,1 @@\n-                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (short)0, \"at index #\" + idx);\n@@ -289,1 +334,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -292,1 +337,1 @@\n-                        Assert.assertEquals(r[i + j], (short)0);\n+                        AssertEquals(r[i + j], (short)0);\n@@ -299,1 +344,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -301,1 +346,1 @@\n-                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (short)0, \"at index #\" + idx);\n@@ -317,1 +362,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -321,1 +366,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -327,0 +372,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -330,1 +376,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -334,2 +382,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -345,1 +392,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -347,1 +394,1 @@\n-                         Assert.assertEquals(r[i+j], (short)0);\n+                         AssertEquals(r[i+j], (short)0);\n@@ -353,1 +400,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -355,1 +402,1 @@\n-                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -361,0 +408,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -364,0 +412,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -365,1 +415,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -367,1 +417,1 @@\n-                         Assert.assertEquals(r[i+j], (short)0);\n+                         AssertEquals(r[i+j], (short)0);\n@@ -371,1 +421,0 @@\n-            int idx = i + j;\n@@ -373,1 +422,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -375,1 +424,1 @@\n-                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -389,1 +438,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -392,1 +441,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -413,1 +462,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -416,1 +465,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -419,1 +468,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -422,3 +471,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -439,1 +488,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -442,1 +491,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -445,1 +494,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -448,3 +497,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -458,1 +507,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -461,1 +510,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -469,1 +518,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -472,1 +521,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -480,1 +529,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -483,1 +532,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -492,1 +541,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -495,1 +544,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -508,1 +557,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -511,1 +560,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -523,1 +572,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -526,1 +575,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -538,1 +587,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -541,1 +590,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -556,1 +605,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -559,1 +608,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -572,1 +621,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -576,1 +625,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -590,1 +639,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -594,1 +643,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -616,1 +665,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -620,1 +669,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -634,1 +683,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -638,1 +687,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -658,1 +707,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -661,1 +710,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -673,1 +722,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -676,1 +725,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -685,1 +734,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -688,1 +737,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -698,1 +747,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -701,1 +750,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -717,1 +766,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -721,1 +770,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -738,1 +787,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -742,1 +791,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -753,1 +802,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -757,1 +806,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -774,1 +823,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -778,1 +827,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -796,1 +845,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -802,1 +851,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -823,1 +872,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -829,1 +878,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -844,1 +893,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -850,1 +899,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -871,1 +920,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -877,1 +926,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -891,1 +940,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -897,1 +946,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -912,1 +961,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -918,1 +967,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -933,1 +982,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -939,1 +988,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -955,1 +1004,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -961,1 +1010,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -969,0 +1018,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -974,1 +1027,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -977,1 +1030,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -987,1 +1040,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -990,1 +1043,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -998,1 +1051,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                AssertEquals(r[i], (double)(a[i+offs]));\n@@ -1001,1 +1054,1 @@\n-            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1010,1 +1063,1 @@\n-            withToString(\"short[-i * 5]\", (int s) -> {\n+            withToString(\"Short[-i * 5]\", (int s) -> {\n@@ -1012,1 +1065,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1014,1 +1067,1 @@\n-            withToString(\"short[i * 5]\", (int s) -> {\n+            withToString(\"Short[i * 5]\", (int s) -> {\n@@ -1016,1 +1069,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1018,1 +1071,1 @@\n-            withToString(\"short[i + 1]\", (int s) -> {\n+            withToString(\"Short[i + 1]\", (int s) -> {\n@@ -1020,1 +1073,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1468,0 +1521,212 @@\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+    static short multiplicativeIdentity() {\n+        return (short)1;\n+    }\n+\n+    static short scalar_or(short a, short b) {\n+        return (short)(a | b);\n+    }\n+\n+    static short scalar_and(short a, short b) {\n+        return (short)(a & b);\n+    }\n+\n+    static short scalar_xor(short a, short b) {\n+        return (short)(a ^ b);\n+    }\n+\n+    static short scalar_add(short a, short b) {\n+        return (short)(a + b);\n+    }\n+\n+    static short scalar_sub(short a, short b) {\n+        return (short)(a - b);\n+    }\n+\n+    static short scalar_mul(short a, short b) {\n+        return (short)(a * b);\n+    }\n+\n+    static short scalar_min(short a, short b) {\n+        return (short)(Math.min(a, b));\n+    }\n+\n+    static short scalar_max(short a, short b) {\n+        return (short)(Math.max(a, b));\n+    }\n+\n+    static short scalar_div(short a, short b) {\n+        return (short)(a \/ b);\n+    }\n+\n+    static short scalar_fma(short a, short b, short c) {\n+        return (short)(Math.fma(a, b, c));\n+    }\n+\n+    static short scalar_abs(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    static short scalar_neg(short a) {\n+        return ((short)-a);\n+    }\n+\n+    static short scalar_sin(short a) {\n+        return (short)Math.sin((double)a);\n+    }\n+\n+    static short scalar_exp(short a) {\n+        return (short)Math.exp((double)a);\n+    }\n+\n+    static short scalar_log1p(short a) {\n+        return (short)Math.log1p((double)a);\n+    }\n+\n+    static short scalar_log(short a) {\n+        return (short)Math.log((double)a);\n+    }\n+\n+    static short scalar_log10(short a) {\n+        return (short)Math.log10((double)a);\n+    }\n+\n+    static short scalar_expm1(short a) {\n+        return (short)Math.expm1((double)a);\n+    }\n+\n+    static short scalar_cos(short a) {\n+        return (short)Math.cos((double)a);\n+    }\n+\n+    static short scalar_tan(short a) {\n+        return (short)Math.tan((double)a);\n+    }\n+\n+    static short scalar_sinh(short a) {\n+        return (short)Math.sinh((double)a);\n+    }\n+\n+    static short scalar_cosh(short a) {\n+        return (short)Math.cosh((double)a);\n+    }\n+\n+    static short scalar_tanh(short a) {\n+        return (short)Math.tanh((double)a);\n+    }\n+\n+    static short scalar_asin(short a) {\n+        return (short)Math.asin((double)a);\n+    }\n+\n+    static short scalar_acos(short a) {\n+        return (short)Math.acos((double)a);\n+    }\n+\n+    static short scalar_atan(short a) {\n+        return (short)Math.atan((double)a);\n+    }\n+\n+    static short scalar_cbrt(short a) {\n+        return (short)Math.cbrt((double)a);\n+    }\n+\n+    static short scalar_sqrt(short a) {\n+        return (short)Math.sqrt((double)a);\n+    }\n+\n+    static short scalar_hypot(short a, short b) {\n+        return (short)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static short scalar_pow(short a, short b) {\n+        return (short)Math.pow((double)a, (double)b);\n+    }\n+\n+    static short scalar_atan2(short a, short b) {\n+        return (short)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static short strict_scalar_sin(short a) {\n+        return (short)StrictMath.sin((double)a);\n+    }\n+\n+    static short strict_scalar_exp(short a) {\n+        return (short)StrictMath.exp((double)a);\n+    }\n+\n+    static short strict_scalar_log1p(short a) {\n+        return (short)StrictMath.log1p((double)a);\n+    }\n+\n+    static short strict_scalar_log(short a) {\n+        return (short)StrictMath.log((double)a);\n+    }\n+\n+    static short strict_scalar_log10(short a) {\n+        return (short)StrictMath.log10((double)a);\n+    }\n+\n+    static short strict_scalar_expm1(short a) {\n+        return (short)StrictMath.expm1((double)a);\n+    }\n+\n+    static short strict_scalar_cos(short a) {\n+        return (short)StrictMath.cos((double)a);\n+    }\n+\n+    static short strict_scalar_tan(short a) {\n+        return (short)StrictMath.tan((double)a);\n+    }\n+\n+    static short strict_scalar_sinh(short a) {\n+        return (short)StrictMath.sinh((double)a);\n+    }\n+\n+    static short strict_scalar_cosh(short a) {\n+        return (short)StrictMath.cosh((double)a);\n+    }\n+\n+    static short strict_scalar_tanh(short a) {\n+        return (short)StrictMath.tanh((double)a);\n+    }\n+\n+    static short strict_scalar_asin(short a) {\n+        return (short)StrictMath.asin((double)a);\n+    }\n+\n+    static short strict_scalar_acos(short a) {\n+        return (short)StrictMath.acos((double)a);\n+    }\n+\n+    static short strict_scalar_atan(short a) {\n+        return (short)StrictMath.atan((double)a);\n+    }\n+\n+    static short strict_scalar_cbrt(short a) {\n+        return (short)StrictMath.cbrt((double)a);\n+    }\n+\n+    static short strict_scalar_sqrt(short a) {\n+        return (short)StrictMath.sqrt((double)a);\n+    }\n+\n+    static short strict_scalar_hypot(short a, short b) {\n+        return (short)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static short strict_scalar_pow(short a, short b) {\n+        return (short)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static short strict_scalar_atan2(short a, short b) {\n+        return (short)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static short additiveIdentity() {\n+        return (short)0;\n+    }\n+\n+\n@@ -1484,2 +1749,10 @@\n-    static short firstNonZero(short a, short b) {\n-        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    static short zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static short maxValue() {\n+        return Short.MAX_VALUE;\n+    }\n+\n+    static short minValue() {\n+        return Short.MIN_VALUE;\n@@ -1488,0 +1761,1 @@\n+\n@@ -1523,1 +1797,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1538,1 +1812,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1544,1 +1818,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1550,1 +1824,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1565,1 +1839,1 @@\n-        Assert.assertEquals(asIntegral.species(), SPECIES);\n+        AssertEquals(asIntegral.species(), SPECIES);\n@@ -1568,1 +1842,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test\n@@ -1570,1 +1844,6 @@\n-        SPECIES.zero().viewAsFloatingLanes();\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        VectorSpecies<?> asFloatingSpecies = asFloating.species();\n+        Assert.assertNotEquals(asFloatingSpecies.elementType(), SPECIES.elementType());\n+        AssertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        AssertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n@@ -1595,1 +1874,1 @@\n-        return (short)(a + b);\n+        return (short)(scalar_add(a, b));\n@@ -1616,1 +1895,1 @@\n-        return (short)(a + b);\n+        return (short)(scalar_add(a, b));\n@@ -1673,1 +1952,1 @@\n-        return (short)(a - b);\n+        return (short)(scalar_sub(a, b));\n@@ -1694,1 +1973,1 @@\n-        return (short)(a - b);\n+        return (short)(scalar_sub(a, b));\n@@ -1751,1 +2030,1 @@\n-        return (short)(a * b);\n+        return (short)(scalar_mul(a, b));\n@@ -1772,1 +2051,1 @@\n-        return (short)(a * b);\n+        return (short)(scalar_mul(a, b));\n@@ -1919,1 +2198,1 @@\n-        return (short)((a)!=0?a:b);\n+        return (short)(firstNonZero(a, b));\n@@ -3026,2 +3305,0 @@\n-    static ShortVector bv_MIN = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3036,1 +3313,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -3043,2 +3320,0 @@\n-    static ShortVector bv_min = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3053,1 +3328,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -3060,2 +3335,0 @@\n-    static ShortVector bv_MIN_M = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3072,1 +3345,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -3079,2 +3352,0 @@\n-    static ShortVector bv_MAX = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3089,1 +3360,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -3096,2 +3367,0 @@\n-    static ShortVector bv_max = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3106,1 +3375,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -3113,2 +3382,0 @@\n-    static ShortVector bv_MAX_M = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3125,1 +3392,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -3133,1 +3400,1 @@\n-        return (short)(Math.min(a, b));\n+        return (short)(scalar_min(a, b));\n@@ -3154,1 +3421,1 @@\n-        return (short)(Math.min(a, b));\n+        return (short)(scalar_min(a, b));\n@@ -3173,1 +3440,1 @@\n-        return (short)(Math.max(a, b));\n+        return (short)(scalar_max(a, b));\n@@ -3194,1 +3461,1 @@\n-        return (short)(Math.max(a, b));\n+        return (short)(scalar_max(a, b));\n@@ -3562,1 +3829,1 @@\n-            res &= a[i];\n+            res = scalar_and(res, a[i]);\n@@ -3571,1 +3838,1 @@\n-            res &= ANDReduce(a, i);\n+            res = scalar_and(res, ANDReduce(a, i));\n@@ -3594,1 +3861,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND));\n@@ -3606,1 +3873,1 @@\n-                res &= a[i];\n+                res = scalar_and(res, a[i]);\n@@ -3615,1 +3882,1 @@\n-            res &= ANDReduceMasked(a, i, mask);\n+            res = scalar_and(res, ANDReduceMasked(a, i, mask));\n@@ -3640,1 +3907,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND, vmask));\n@@ -3651,1 +3918,1 @@\n-            res |= a[i];\n+            res = scalar_or(res, a[i]);\n@@ -3660,1 +3927,1 @@\n-            res |= ORReduce(a, i);\n+            res = scalar_or(res, ORReduce(a, i));\n@@ -3683,1 +3950,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR));\n@@ -3695,1 +3962,1 @@\n-                res |= a[i];\n+                res = scalar_or(res, a[i]);\n@@ -3704,1 +3971,1 @@\n-            res |= ORReduceMasked(a, i, mask);\n+            res = scalar_or(res, ORReduceMasked(a, i, mask));\n@@ -3729,1 +3996,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR, vmask));\n@@ -3740,1 +4007,1 @@\n-            res ^= a[i];\n+            res = scalar_xor(res, a[i]);\n@@ -3749,1 +4016,1 @@\n-            res ^= XORReduce(a, i);\n+            res = scalar_xor(res, XORReduce(a, i));\n@@ -3772,1 +4039,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR));\n@@ -3784,1 +4051,1 @@\n-                res ^= a[i];\n+                res = scalar_xor(res, a[i]);\n@@ -3793,1 +4060,1 @@\n-            res ^= XORReduceMasked(a, i, mask);\n+            res = scalar_xor(res, XORReduceMasked(a, i, mask));\n@@ -3818,1 +4085,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR, vmask));\n@@ -3827,1 +4094,1 @@\n-        short res = 0;\n+        short res = additiveIdentity();\n@@ -3829,1 +4096,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -3836,1 +4103,1 @@\n-        short res = 0;\n+        short res = additiveIdentity();\n@@ -3838,1 +4105,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -3848,1 +4115,1 @@\n-        short ra = 0;\n+        short ra = additiveIdentity();\n@@ -3858,1 +4125,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3861,1 +4128,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -3870,1 +4137,1 @@\n-        short res = 0;\n+        short res = additiveIdentity();\n@@ -3873,1 +4140,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -3880,1 +4147,1 @@\n-        short res = 0;\n+        short res = additiveIdentity();\n@@ -3882,1 +4149,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -3894,1 +4161,1 @@\n-        short ra = 0;\n+        short ra = additiveIdentity();\n@@ -3904,1 +4171,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3907,1 +4174,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -3916,1 +4183,1 @@\n-        short res = 1;\n+        short res = multiplicativeIdentity();\n@@ -3918,1 +4185,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -3925,1 +4192,1 @@\n-        short res = 1;\n+        short res = multiplicativeIdentity();\n@@ -3927,1 +4194,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -3937,1 +4204,1 @@\n-        short ra = 1;\n+        short ra = multiplicativeIdentity();\n@@ -3947,1 +4214,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -3950,1 +4217,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -3959,1 +4226,1 @@\n-        short res = 1;\n+        short res = multiplicativeIdentity();\n@@ -3962,1 +4229,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -3969,1 +4236,1 @@\n-        short res = 1;\n+        short res = multiplicativeIdentity();\n@@ -3971,1 +4238,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -3983,1 +4250,1 @@\n-        short ra = 1;\n+        short ra = multiplicativeIdentity();\n@@ -3993,1 +4260,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -3996,1 +4263,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -4005,1 +4272,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4007,1 +4274,1 @@\n-            res = (short) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -4014,1 +4281,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4016,1 +4283,1 @@\n-            res = (short) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -4026,1 +4293,1 @@\n-        short ra = Short.MAX_VALUE;\n+        short ra = maxValue();\n@@ -4036,1 +4303,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = maxValue();\n@@ -4039,1 +4306,1 @@\n-                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -4048,1 +4315,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4051,1 +4318,1 @@\n-                res = (short) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -4058,1 +4325,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4060,1 +4327,1 @@\n-            res = (short) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -4072,1 +4339,1 @@\n-        short ra = Short.MAX_VALUE;\n+        short ra = maxValue();\n@@ -4082,1 +4349,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = maxValue();\n@@ -4085,1 +4352,1 @@\n-                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -4094,1 +4361,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4096,1 +4363,1 @@\n-            res = (short) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -4103,1 +4370,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4105,1 +4372,1 @@\n-            res = (short) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -4115,1 +4382,1 @@\n-        short ra = Short.MIN_VALUE;\n+        short ra = minValue();\n@@ -4125,1 +4392,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = minValue();\n@@ -4128,1 +4395,1 @@\n-                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -4137,1 +4404,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4140,1 +4407,1 @@\n-                res = (short) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -4147,1 +4414,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4149,1 +4416,1 @@\n-            res = (short) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -4161,1 +4428,1 @@\n-        short ra = Short.MIN_VALUE;\n+        short ra = minValue();\n@@ -4171,1 +4438,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = minValue();\n@@ -4174,1 +4441,1 @@\n-                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -4183,1 +4450,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4192,1 +4459,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4204,1 +4471,1 @@\n-        short ra = Short.MAX_VALUE;\n+        short ra = maxValue();\n@@ -4214,1 +4481,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = maxValue();\n@@ -4226,1 +4493,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4236,1 +4503,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4250,1 +4517,1 @@\n-        short ra = Short.MAX_VALUE;\n+        short ra = maxValue();\n@@ -4260,1 +4527,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = maxValue();\n@@ -4272,1 +4539,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4281,1 +4548,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4293,1 +4560,1 @@\n-        short ra = Short.MIN_VALUE;\n+        short ra = minValue();\n@@ -4303,1 +4570,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = minValue();\n@@ -4315,1 +4582,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4325,1 +4592,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4339,1 +4606,1 @@\n-        short ra = Short.MIN_VALUE;\n+        short ra = minValue();\n@@ -4349,1 +4616,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = minValue();\n@@ -4361,1 +4628,1 @@\n-        short res = (short) 0;\n+        short res = zeroValue();\n@@ -4370,1 +4637,1 @@\n-        short res = (short) 0;\n+        short res = zeroValue();\n@@ -4382,1 +4649,1 @@\n-        short ra = (short) 0;\n+        short ra = zeroValue();\n@@ -4392,1 +4659,1 @@\n-            ra = (short) 0;\n+            ra = zeroValue();\n@@ -4404,1 +4671,1 @@\n-        short res = (short) 0;\n+        short res = zeroValue();\n@@ -4414,1 +4681,1 @@\n-        short res = (short) 0;\n+        short res = zeroValue();\n@@ -4428,1 +4695,1 @@\n-        short ra = (short) 0;\n+        short ra = zeroValue();\n@@ -4438,1 +4705,1 @@\n-            ra = (short) 0;\n+            ra = zeroValue();\n@@ -4498,1 +4765,1 @@\n-        short res = 0;\n+        short res = zeroValue();\n@@ -4507,1 +4774,1 @@\n-        short res = 0;\n+        short res = zeroValue();\n@@ -4519,1 +4786,1 @@\n-        short ra = 0;\n+        short ra = zeroValue();\n@@ -4529,1 +4796,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4541,1 +4808,1 @@\n-        short res = 0;\n+        short res = zeroValue();\n@@ -4551,1 +4818,1 @@\n-        short res = 0;\n+        short res = zeroValue();\n@@ -4564,1 +4831,1 @@\n-        short ra = 0;\n+        short ra = zeroValue();\n@@ -4574,1 +4841,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4619,1 +4886,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -4639,1 +4906,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -4660,1 +4927,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -4680,1 +4947,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -4699,1 +4966,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4718,1 +4985,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4741,1 +5008,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -4760,1 +5027,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -4783,1 +5050,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -4802,1 +5069,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4821,1 +5088,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4844,1 +5111,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -4863,1 +5130,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -4886,1 +5153,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -4905,1 +5172,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -4928,1 +5195,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -4947,1 +5214,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -4970,1 +5237,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -4989,1 +5256,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n@@ -5012,1 +5279,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n@@ -5031,1 +5298,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n@@ -5054,1 +5321,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -5073,1 +5340,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n@@ -5096,1 +5363,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n@@ -5115,1 +5382,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n@@ -5138,1 +5405,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n@@ -5155,1 +5422,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -5175,1 +5442,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -5191,1 +5458,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < (short)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (short)((long)b[i])));\n@@ -5211,1 +5478,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < (short)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(short)((long)b[i]))));\n@@ -5227,1 +5494,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -5247,1 +5514,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -5263,1 +5530,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == (short)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (short)((long)b[i])));\n@@ -5283,1 +5550,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == (short)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(short)((long)b[i]))));\n@@ -5564,1 +5831,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -5995,1 +6262,1 @@\n-        return (short)(-((short)a));\n+        return (short)(scalar_neg((short)a));\n@@ -5999,1 +6266,1 @@\n-        return (short)(-((short)a));\n+        return (short)(scalar_neg((short)a));\n@@ -6051,1 +6318,1 @@\n-        return (short)(Math.abs((short)a));\n+        return (short)(scalar_abs((short)a));\n@@ -6055,1 +6322,1 @@\n-        return (short)(Math.abs((short)a));\n+        return (short)(scalar_abs((short)a));\n@@ -6395,1 +6662,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -6411,1 +6678,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -6507,1 +6774,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6548,1 +6815,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6651,1 +6918,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -6679,1 +6946,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -6693,1 +6960,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -6890,1 +7157,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -6910,1 +7177,1 @@\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -6933,1 +7200,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6947,1 +7214,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6969,1 +7236,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -6977,1 +7244,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -6984,1 +7251,1 @@\n-        Assert.assertEquals(elsize, Short.SIZE);\n+        AssertEquals(elsize, Short.SIZE);\n@@ -7003,1 +7270,1 @@\n-    static void ElementTypeShort128VectorTestsSmokeTest() {\n+    static void ShortShort128VectorTestsSmokeTest() {\n@@ -7038,1 +7305,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":599,"deletions":332,"binary":false,"changes":931,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,45 @@\n+    static ShortVector bcast_vec = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    static void AssertEquals(short actual, short expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(short actual, short expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(short actual, short expected, short delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(short actual, short expected, short delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(short [] actual, short [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(short [] actual, short [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -87,1 +132,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -90,1 +135,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -102,1 +147,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -108,1 +153,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -118,1 +163,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -121,1 +166,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -137,1 +182,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -139,1 +184,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -142,2 +187,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -159,1 +204,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -161,1 +206,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -164,2 +209,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -181,1 +226,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -183,1 +228,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -186,2 +231,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -203,1 +248,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -205,1 +250,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -208,2 +253,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -221,1 +266,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -224,1 +269,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -236,1 +281,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -239,1 +284,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -248,1 +293,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -253,1 +298,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -264,1 +309,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -269,1 +314,1 @@\n-                    Assert.assertEquals(r[i + k], (short)0);\n+                    AssertEquals(r[i + k], (short)0);\n@@ -275,1 +320,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -277,1 +322,1 @@\n-                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (short)0, \"at index #\" + idx);\n@@ -289,1 +334,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -292,1 +337,1 @@\n-                        Assert.assertEquals(r[i + j], (short)0);\n+                        AssertEquals(r[i + j], (short)0);\n@@ -299,1 +344,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -301,1 +346,1 @@\n-                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (short)0, \"at index #\" + idx);\n@@ -317,1 +362,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -321,1 +366,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -327,0 +372,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -330,1 +376,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -334,2 +382,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -345,1 +392,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -347,1 +394,1 @@\n-                         Assert.assertEquals(r[i+j], (short)0);\n+                         AssertEquals(r[i+j], (short)0);\n@@ -353,1 +400,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -355,1 +402,1 @@\n-                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -361,0 +408,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -364,0 +412,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -365,1 +415,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -367,1 +417,1 @@\n-                         Assert.assertEquals(r[i+j], (short)0);\n+                         AssertEquals(r[i+j], (short)0);\n@@ -371,1 +421,0 @@\n-            int idx = i + j;\n@@ -373,1 +422,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -375,1 +424,1 @@\n-                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -389,1 +438,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -392,1 +441,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -413,1 +462,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -416,1 +465,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -419,1 +468,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -422,3 +471,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -439,1 +488,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -442,1 +491,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -445,1 +494,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -448,3 +497,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -458,1 +507,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -461,1 +510,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -469,1 +518,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -472,1 +521,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -480,1 +529,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -483,1 +532,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -492,1 +541,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -495,1 +544,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -508,1 +557,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -511,1 +560,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -523,1 +572,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -526,1 +575,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -538,1 +587,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -541,1 +590,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -556,1 +605,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -559,1 +608,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -572,1 +621,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -576,1 +625,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -590,1 +639,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -594,1 +643,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -616,1 +665,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -620,1 +669,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -634,1 +683,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -638,1 +687,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -658,1 +707,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -661,1 +710,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -673,1 +722,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -676,1 +725,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -685,1 +734,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -688,1 +737,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -698,1 +747,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -701,1 +750,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -717,1 +766,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -721,1 +770,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -738,1 +787,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -742,1 +791,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -753,1 +802,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -757,1 +806,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -774,1 +823,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -778,1 +827,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -796,1 +845,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -802,1 +851,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -823,1 +872,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -829,1 +878,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -844,1 +893,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -850,1 +899,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -871,1 +920,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -877,1 +926,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -891,1 +940,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -897,1 +946,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -912,1 +961,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -918,1 +967,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -933,1 +982,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -939,1 +988,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -955,1 +1004,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -961,1 +1010,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -969,0 +1018,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -974,1 +1027,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -977,1 +1030,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -987,1 +1040,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -990,1 +1043,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -998,1 +1051,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                AssertEquals(r[i], (double)(a[i+offs]));\n@@ -1001,1 +1054,1 @@\n-            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1010,1 +1063,1 @@\n-            withToString(\"short[-i * 5]\", (int s) -> {\n+            withToString(\"Short[-i * 5]\", (int s) -> {\n@@ -1012,1 +1065,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1014,1 +1067,1 @@\n-            withToString(\"short[i * 5]\", (int s) -> {\n+            withToString(\"Short[i * 5]\", (int s) -> {\n@@ -1016,1 +1069,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1018,1 +1071,1 @@\n-            withToString(\"short[i + 1]\", (int s) -> {\n+            withToString(\"Short[i + 1]\", (int s) -> {\n@@ -1020,1 +1073,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1468,0 +1521,212 @@\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+    static short multiplicativeIdentity() {\n+        return (short)1;\n+    }\n+\n+    static short scalar_or(short a, short b) {\n+        return (short)(a | b);\n+    }\n+\n+    static short scalar_and(short a, short b) {\n+        return (short)(a & b);\n+    }\n+\n+    static short scalar_xor(short a, short b) {\n+        return (short)(a ^ b);\n+    }\n+\n+    static short scalar_add(short a, short b) {\n+        return (short)(a + b);\n+    }\n+\n+    static short scalar_sub(short a, short b) {\n+        return (short)(a - b);\n+    }\n+\n+    static short scalar_mul(short a, short b) {\n+        return (short)(a * b);\n+    }\n+\n+    static short scalar_min(short a, short b) {\n+        return (short)(Math.min(a, b));\n+    }\n+\n+    static short scalar_max(short a, short b) {\n+        return (short)(Math.max(a, b));\n+    }\n+\n+    static short scalar_div(short a, short b) {\n+        return (short)(a \/ b);\n+    }\n+\n+    static short scalar_fma(short a, short b, short c) {\n+        return (short)(Math.fma(a, b, c));\n+    }\n+\n+    static short scalar_abs(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    static short scalar_neg(short a) {\n+        return ((short)-a);\n+    }\n+\n+    static short scalar_sin(short a) {\n+        return (short)Math.sin((double)a);\n+    }\n+\n+    static short scalar_exp(short a) {\n+        return (short)Math.exp((double)a);\n+    }\n+\n+    static short scalar_log1p(short a) {\n+        return (short)Math.log1p((double)a);\n+    }\n+\n+    static short scalar_log(short a) {\n+        return (short)Math.log((double)a);\n+    }\n+\n+    static short scalar_log10(short a) {\n+        return (short)Math.log10((double)a);\n+    }\n+\n+    static short scalar_expm1(short a) {\n+        return (short)Math.expm1((double)a);\n+    }\n+\n+    static short scalar_cos(short a) {\n+        return (short)Math.cos((double)a);\n+    }\n+\n+    static short scalar_tan(short a) {\n+        return (short)Math.tan((double)a);\n+    }\n+\n+    static short scalar_sinh(short a) {\n+        return (short)Math.sinh((double)a);\n+    }\n+\n+    static short scalar_cosh(short a) {\n+        return (short)Math.cosh((double)a);\n+    }\n+\n+    static short scalar_tanh(short a) {\n+        return (short)Math.tanh((double)a);\n+    }\n+\n+    static short scalar_asin(short a) {\n+        return (short)Math.asin((double)a);\n+    }\n+\n+    static short scalar_acos(short a) {\n+        return (short)Math.acos((double)a);\n+    }\n+\n+    static short scalar_atan(short a) {\n+        return (short)Math.atan((double)a);\n+    }\n+\n+    static short scalar_cbrt(short a) {\n+        return (short)Math.cbrt((double)a);\n+    }\n+\n+    static short scalar_sqrt(short a) {\n+        return (short)Math.sqrt((double)a);\n+    }\n+\n+    static short scalar_hypot(short a, short b) {\n+        return (short)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static short scalar_pow(short a, short b) {\n+        return (short)Math.pow((double)a, (double)b);\n+    }\n+\n+    static short scalar_atan2(short a, short b) {\n+        return (short)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static short strict_scalar_sin(short a) {\n+        return (short)StrictMath.sin((double)a);\n+    }\n+\n+    static short strict_scalar_exp(short a) {\n+        return (short)StrictMath.exp((double)a);\n+    }\n+\n+    static short strict_scalar_log1p(short a) {\n+        return (short)StrictMath.log1p((double)a);\n+    }\n+\n+    static short strict_scalar_log(short a) {\n+        return (short)StrictMath.log((double)a);\n+    }\n+\n+    static short strict_scalar_log10(short a) {\n+        return (short)StrictMath.log10((double)a);\n+    }\n+\n+    static short strict_scalar_expm1(short a) {\n+        return (short)StrictMath.expm1((double)a);\n+    }\n+\n+    static short strict_scalar_cos(short a) {\n+        return (short)StrictMath.cos((double)a);\n+    }\n+\n+    static short strict_scalar_tan(short a) {\n+        return (short)StrictMath.tan((double)a);\n+    }\n+\n+    static short strict_scalar_sinh(short a) {\n+        return (short)StrictMath.sinh((double)a);\n+    }\n+\n+    static short strict_scalar_cosh(short a) {\n+        return (short)StrictMath.cosh((double)a);\n+    }\n+\n+    static short strict_scalar_tanh(short a) {\n+        return (short)StrictMath.tanh((double)a);\n+    }\n+\n+    static short strict_scalar_asin(short a) {\n+        return (short)StrictMath.asin((double)a);\n+    }\n+\n+    static short strict_scalar_acos(short a) {\n+        return (short)StrictMath.acos((double)a);\n+    }\n+\n+    static short strict_scalar_atan(short a) {\n+        return (short)StrictMath.atan((double)a);\n+    }\n+\n+    static short strict_scalar_cbrt(short a) {\n+        return (short)StrictMath.cbrt((double)a);\n+    }\n+\n+    static short strict_scalar_sqrt(short a) {\n+        return (short)StrictMath.sqrt((double)a);\n+    }\n+\n+    static short strict_scalar_hypot(short a, short b) {\n+        return (short)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static short strict_scalar_pow(short a, short b) {\n+        return (short)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static short strict_scalar_atan2(short a, short b) {\n+        return (short)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static short additiveIdentity() {\n+        return (short)0;\n+    }\n+\n+\n@@ -1484,2 +1749,10 @@\n-    static short firstNonZero(short a, short b) {\n-        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    static short zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static short maxValue() {\n+        return Short.MAX_VALUE;\n+    }\n+\n+    static short minValue() {\n+        return Short.MIN_VALUE;\n@@ -1488,0 +1761,1 @@\n+\n@@ -1523,1 +1797,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1538,1 +1812,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1544,1 +1818,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1550,1 +1824,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1565,1 +1839,1 @@\n-        Assert.assertEquals(asIntegral.species(), SPECIES);\n+        AssertEquals(asIntegral.species(), SPECIES);\n@@ -1568,1 +1842,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test\n@@ -1570,1 +1844,6 @@\n-        SPECIES.zero().viewAsFloatingLanes();\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        VectorSpecies<?> asFloatingSpecies = asFloating.species();\n+        Assert.assertNotEquals(asFloatingSpecies.elementType(), SPECIES.elementType());\n+        AssertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        AssertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n@@ -1595,1 +1874,1 @@\n-        return (short)(a + b);\n+        return (short)(scalar_add(a, b));\n@@ -1616,1 +1895,1 @@\n-        return (short)(a + b);\n+        return (short)(scalar_add(a, b));\n@@ -1673,1 +1952,1 @@\n-        return (short)(a - b);\n+        return (short)(scalar_sub(a, b));\n@@ -1694,1 +1973,1 @@\n-        return (short)(a - b);\n+        return (short)(scalar_sub(a, b));\n@@ -1751,1 +2030,1 @@\n-        return (short)(a * b);\n+        return (short)(scalar_mul(a, b));\n@@ -1772,1 +2051,1 @@\n-        return (short)(a * b);\n+        return (short)(scalar_mul(a, b));\n@@ -1919,1 +2198,1 @@\n-        return (short)((a)!=0?a:b);\n+        return (short)(firstNonZero(a, b));\n@@ -3026,2 +3305,0 @@\n-    static ShortVector bv_MIN = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3036,1 +3313,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -3043,2 +3320,0 @@\n-    static ShortVector bv_min = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3053,1 +3328,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -3060,2 +3335,0 @@\n-    static ShortVector bv_MIN_M = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3072,1 +3345,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -3079,2 +3352,0 @@\n-    static ShortVector bv_MAX = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3089,1 +3360,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -3096,2 +3367,0 @@\n-    static ShortVector bv_max = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3106,1 +3375,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -3113,2 +3382,0 @@\n-    static ShortVector bv_MAX_M = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3125,1 +3392,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -3133,1 +3400,1 @@\n-        return (short)(Math.min(a, b));\n+        return (short)(scalar_min(a, b));\n@@ -3154,1 +3421,1 @@\n-        return (short)(Math.min(a, b));\n+        return (short)(scalar_min(a, b));\n@@ -3173,1 +3440,1 @@\n-        return (short)(Math.max(a, b));\n+        return (short)(scalar_max(a, b));\n@@ -3194,1 +3461,1 @@\n-        return (short)(Math.max(a, b));\n+        return (short)(scalar_max(a, b));\n@@ -3562,1 +3829,1 @@\n-            res &= a[i];\n+            res = scalar_and(res, a[i]);\n@@ -3571,1 +3838,1 @@\n-            res &= ANDReduce(a, i);\n+            res = scalar_and(res, ANDReduce(a, i));\n@@ -3594,1 +3861,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND));\n@@ -3606,1 +3873,1 @@\n-                res &= a[i];\n+                res = scalar_and(res, a[i]);\n@@ -3615,1 +3882,1 @@\n-            res &= ANDReduceMasked(a, i, mask);\n+            res = scalar_and(res, ANDReduceMasked(a, i, mask));\n@@ -3640,1 +3907,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND, vmask));\n@@ -3651,1 +3918,1 @@\n-            res |= a[i];\n+            res = scalar_or(res, a[i]);\n@@ -3660,1 +3927,1 @@\n-            res |= ORReduce(a, i);\n+            res = scalar_or(res, ORReduce(a, i));\n@@ -3683,1 +3950,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR));\n@@ -3695,1 +3962,1 @@\n-                res |= a[i];\n+                res = scalar_or(res, a[i]);\n@@ -3704,1 +3971,1 @@\n-            res |= ORReduceMasked(a, i, mask);\n+            res = scalar_or(res, ORReduceMasked(a, i, mask));\n@@ -3729,1 +3996,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR, vmask));\n@@ -3740,1 +4007,1 @@\n-            res ^= a[i];\n+            res = scalar_xor(res, a[i]);\n@@ -3749,1 +4016,1 @@\n-            res ^= XORReduce(a, i);\n+            res = scalar_xor(res, XORReduce(a, i));\n@@ -3772,1 +4039,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR));\n@@ -3784,1 +4051,1 @@\n-                res ^= a[i];\n+                res = scalar_xor(res, a[i]);\n@@ -3793,1 +4060,1 @@\n-            res ^= XORReduceMasked(a, i, mask);\n+            res = scalar_xor(res, XORReduceMasked(a, i, mask));\n@@ -3818,1 +4085,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR, vmask));\n@@ -3827,1 +4094,1 @@\n-        short res = 0;\n+        short res = additiveIdentity();\n@@ -3829,1 +4096,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -3836,1 +4103,1 @@\n-        short res = 0;\n+        short res = additiveIdentity();\n@@ -3838,1 +4105,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -3848,1 +4115,1 @@\n-        short ra = 0;\n+        short ra = additiveIdentity();\n@@ -3858,1 +4125,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3861,1 +4128,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -3870,1 +4137,1 @@\n-        short res = 0;\n+        short res = additiveIdentity();\n@@ -3873,1 +4140,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -3880,1 +4147,1 @@\n-        short res = 0;\n+        short res = additiveIdentity();\n@@ -3882,1 +4149,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -3894,1 +4161,1 @@\n-        short ra = 0;\n+        short ra = additiveIdentity();\n@@ -3904,1 +4171,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3907,1 +4174,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -3916,1 +4183,1 @@\n-        short res = 1;\n+        short res = multiplicativeIdentity();\n@@ -3918,1 +4185,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -3925,1 +4192,1 @@\n-        short res = 1;\n+        short res = multiplicativeIdentity();\n@@ -3927,1 +4194,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -3937,1 +4204,1 @@\n-        short ra = 1;\n+        short ra = multiplicativeIdentity();\n@@ -3947,1 +4214,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -3950,1 +4217,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -3959,1 +4226,1 @@\n-        short res = 1;\n+        short res = multiplicativeIdentity();\n@@ -3962,1 +4229,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -3969,1 +4236,1 @@\n-        short res = 1;\n+        short res = multiplicativeIdentity();\n@@ -3971,1 +4238,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -3983,1 +4250,1 @@\n-        short ra = 1;\n+        short ra = multiplicativeIdentity();\n@@ -3993,1 +4260,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -3996,1 +4263,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -4005,1 +4272,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4007,1 +4274,1 @@\n-            res = (short) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -4014,1 +4281,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4016,1 +4283,1 @@\n-            res = (short) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -4026,1 +4293,1 @@\n-        short ra = Short.MAX_VALUE;\n+        short ra = maxValue();\n@@ -4036,1 +4303,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = maxValue();\n@@ -4039,1 +4306,1 @@\n-                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -4048,1 +4315,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4051,1 +4318,1 @@\n-                res = (short) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -4058,1 +4325,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4060,1 +4327,1 @@\n-            res = (short) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -4072,1 +4339,1 @@\n-        short ra = Short.MAX_VALUE;\n+        short ra = maxValue();\n@@ -4082,1 +4349,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = maxValue();\n@@ -4085,1 +4352,1 @@\n-                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -4094,1 +4361,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4096,1 +4363,1 @@\n-            res = (short) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -4103,1 +4370,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4105,1 +4372,1 @@\n-            res = (short) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -4115,1 +4382,1 @@\n-        short ra = Short.MIN_VALUE;\n+        short ra = minValue();\n@@ -4125,1 +4392,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = minValue();\n@@ -4128,1 +4395,1 @@\n-                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -4137,1 +4404,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4140,1 +4407,1 @@\n-                res = (short) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -4147,1 +4414,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4149,1 +4416,1 @@\n-            res = (short) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -4161,1 +4428,1 @@\n-        short ra = Short.MIN_VALUE;\n+        short ra = minValue();\n@@ -4171,1 +4438,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = minValue();\n@@ -4174,1 +4441,1 @@\n-                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -4183,1 +4450,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4192,1 +4459,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4204,1 +4471,1 @@\n-        short ra = Short.MAX_VALUE;\n+        short ra = maxValue();\n@@ -4214,1 +4481,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = maxValue();\n@@ -4226,1 +4493,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4236,1 +4503,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4250,1 +4517,1 @@\n-        short ra = Short.MAX_VALUE;\n+        short ra = maxValue();\n@@ -4260,1 +4527,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = maxValue();\n@@ -4272,1 +4539,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4281,1 +4548,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4293,1 +4560,1 @@\n-        short ra = Short.MIN_VALUE;\n+        short ra = minValue();\n@@ -4303,1 +4570,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = minValue();\n@@ -4315,1 +4582,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4325,1 +4592,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4339,1 +4606,1 @@\n-        short ra = Short.MIN_VALUE;\n+        short ra = minValue();\n@@ -4349,1 +4616,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = minValue();\n@@ -4361,1 +4628,1 @@\n-        short res = (short) 0;\n+        short res = zeroValue();\n@@ -4370,1 +4637,1 @@\n-        short res = (short) 0;\n+        short res = zeroValue();\n@@ -4382,1 +4649,1 @@\n-        short ra = (short) 0;\n+        short ra = zeroValue();\n@@ -4392,1 +4659,1 @@\n-            ra = (short) 0;\n+            ra = zeroValue();\n@@ -4404,1 +4671,1 @@\n-        short res = (short) 0;\n+        short res = zeroValue();\n@@ -4414,1 +4681,1 @@\n-        short res = (short) 0;\n+        short res = zeroValue();\n@@ -4428,1 +4695,1 @@\n-        short ra = (short) 0;\n+        short ra = zeroValue();\n@@ -4438,1 +4705,1 @@\n-            ra = (short) 0;\n+            ra = zeroValue();\n@@ -4498,1 +4765,1 @@\n-        short res = 0;\n+        short res = zeroValue();\n@@ -4507,1 +4774,1 @@\n-        short res = 0;\n+        short res = zeroValue();\n@@ -4519,1 +4786,1 @@\n-        short ra = 0;\n+        short ra = zeroValue();\n@@ -4529,1 +4796,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4541,1 +4808,1 @@\n-        short res = 0;\n+        short res = zeroValue();\n@@ -4551,1 +4818,1 @@\n-        short res = 0;\n+        short res = zeroValue();\n@@ -4564,1 +4831,1 @@\n-        short ra = 0;\n+        short ra = zeroValue();\n@@ -4574,1 +4841,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4619,1 +4886,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -4639,1 +4906,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -4660,1 +4927,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -4680,1 +4947,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -4699,1 +4966,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4718,1 +4985,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4741,1 +5008,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -4760,1 +5027,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -4783,1 +5050,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -4802,1 +5069,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4821,1 +5088,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4844,1 +5111,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -4863,1 +5130,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -4886,1 +5153,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -4905,1 +5172,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -4928,1 +5195,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -4947,1 +5214,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -4970,1 +5237,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -4989,1 +5256,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n@@ -5012,1 +5279,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n@@ -5031,1 +5298,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n@@ -5054,1 +5321,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -5073,1 +5340,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n@@ -5096,1 +5363,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n@@ -5115,1 +5382,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n@@ -5138,1 +5405,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n@@ -5155,1 +5422,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -5175,1 +5442,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -5191,1 +5458,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < (short)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (short)((long)b[i])));\n@@ -5211,1 +5478,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < (short)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(short)((long)b[i]))));\n@@ -5227,1 +5494,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -5247,1 +5514,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -5263,1 +5530,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == (short)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (short)((long)b[i])));\n@@ -5283,1 +5550,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == (short)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(short)((long)b[i]))));\n@@ -5564,1 +5831,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -5995,1 +6262,1 @@\n-        return (short)(-((short)a));\n+        return (short)(scalar_neg((short)a));\n@@ -5999,1 +6266,1 @@\n-        return (short)(-((short)a));\n+        return (short)(scalar_neg((short)a));\n@@ -6051,1 +6318,1 @@\n-        return (short)(Math.abs((short)a));\n+        return (short)(scalar_abs((short)a));\n@@ -6055,1 +6322,1 @@\n-        return (short)(Math.abs((short)a));\n+        return (short)(scalar_abs((short)a));\n@@ -6395,1 +6662,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -6411,1 +6678,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -6507,1 +6774,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6548,1 +6815,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6651,1 +6918,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -6679,1 +6946,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -6693,1 +6960,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -6890,1 +7157,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -6910,1 +7177,1 @@\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -6933,1 +7200,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6947,1 +7214,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6969,1 +7236,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -6977,1 +7244,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -6984,1 +7251,1 @@\n-        Assert.assertEquals(elsize, Short.SIZE);\n+        AssertEquals(elsize, Short.SIZE);\n@@ -7003,1 +7270,1 @@\n-    static void ElementTypeShort256VectorTestsSmokeTest() {\n+    static void ShortShort256VectorTestsSmokeTest() {\n@@ -7038,1 +7305,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":599,"deletions":332,"binary":false,"changes":931,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,45 @@\n+    static ShortVector bcast_vec = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    static void AssertEquals(short actual, short expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(short actual, short expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(short actual, short expected, short delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(short actual, short expected, short delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(short [] actual, short [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(short [] actual, short [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -87,1 +132,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -90,1 +135,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -102,1 +147,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -108,1 +153,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -118,1 +163,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -121,1 +166,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -137,1 +182,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -139,1 +184,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -142,2 +187,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -159,1 +204,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -161,1 +206,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -164,2 +209,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -181,1 +226,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -183,1 +228,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -186,2 +231,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -203,1 +248,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -205,1 +250,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -208,2 +253,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -221,1 +266,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -224,1 +269,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -236,1 +281,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -239,1 +284,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -248,1 +293,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -253,1 +298,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -264,1 +309,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -269,1 +314,1 @@\n-                    Assert.assertEquals(r[i + k], (short)0);\n+                    AssertEquals(r[i + k], (short)0);\n@@ -275,1 +320,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -277,1 +322,1 @@\n-                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (short)0, \"at index #\" + idx);\n@@ -289,1 +334,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -292,1 +337,1 @@\n-                        Assert.assertEquals(r[i + j], (short)0);\n+                        AssertEquals(r[i + j], (short)0);\n@@ -299,1 +344,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -301,1 +346,1 @@\n-                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (short)0, \"at index #\" + idx);\n@@ -317,1 +362,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -321,1 +366,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -327,0 +372,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -330,1 +376,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -334,2 +382,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -345,1 +392,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -347,1 +394,1 @@\n-                         Assert.assertEquals(r[i+j], (short)0);\n+                         AssertEquals(r[i+j], (short)0);\n@@ -353,1 +400,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -355,1 +402,1 @@\n-                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -361,0 +408,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -364,0 +412,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -365,1 +415,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -367,1 +417,1 @@\n-                         Assert.assertEquals(r[i+j], (short)0);\n+                         AssertEquals(r[i+j], (short)0);\n@@ -371,1 +421,0 @@\n-            int idx = i + j;\n@@ -373,1 +422,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -375,1 +424,1 @@\n-                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -389,1 +438,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -392,1 +441,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -413,1 +462,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -416,1 +465,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -419,1 +468,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -422,3 +471,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -439,1 +488,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -442,1 +491,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -445,1 +494,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -448,3 +497,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -458,1 +507,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -461,1 +510,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -469,1 +518,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -472,1 +521,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -480,1 +529,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -483,1 +532,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -492,1 +541,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -495,1 +544,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -508,1 +557,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -511,1 +560,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -523,1 +572,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -526,1 +575,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -538,1 +587,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -541,1 +590,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -556,1 +605,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -559,1 +608,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -572,1 +621,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -576,1 +625,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -590,1 +639,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -594,1 +643,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -616,1 +665,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -620,1 +669,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -634,1 +683,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -638,1 +687,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -658,1 +707,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -661,1 +710,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -673,1 +722,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -676,1 +725,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -685,1 +734,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -688,1 +737,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -698,1 +747,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -701,1 +750,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -717,1 +766,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -721,1 +770,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -738,1 +787,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -742,1 +791,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -753,1 +802,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -757,1 +806,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -774,1 +823,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -778,1 +827,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -796,1 +845,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -802,1 +851,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -823,1 +872,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -829,1 +878,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -844,1 +893,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -850,1 +899,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -871,1 +920,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -877,1 +926,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -891,1 +940,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -897,1 +946,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -912,1 +961,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -918,1 +967,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -933,1 +982,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -939,1 +988,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -955,1 +1004,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -961,1 +1010,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -969,0 +1018,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -974,1 +1027,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -977,1 +1030,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -987,1 +1040,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -990,1 +1043,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -998,1 +1051,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                AssertEquals(r[i], (double)(a[i+offs]));\n@@ -1001,1 +1054,1 @@\n-            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1010,1 +1063,1 @@\n-            withToString(\"short[-i * 5]\", (int s) -> {\n+            withToString(\"Short[-i * 5]\", (int s) -> {\n@@ -1012,1 +1065,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1014,1 +1067,1 @@\n-            withToString(\"short[i * 5]\", (int s) -> {\n+            withToString(\"Short[i * 5]\", (int s) -> {\n@@ -1016,1 +1069,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1018,1 +1071,1 @@\n-            withToString(\"short[i + 1]\", (int s) -> {\n+            withToString(\"Short[i + 1]\", (int s) -> {\n@@ -1020,1 +1073,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1468,0 +1521,212 @@\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+    static short multiplicativeIdentity() {\n+        return (short)1;\n+    }\n+\n+    static short scalar_or(short a, short b) {\n+        return (short)(a | b);\n+    }\n+\n+    static short scalar_and(short a, short b) {\n+        return (short)(a & b);\n+    }\n+\n+    static short scalar_xor(short a, short b) {\n+        return (short)(a ^ b);\n+    }\n+\n+    static short scalar_add(short a, short b) {\n+        return (short)(a + b);\n+    }\n+\n+    static short scalar_sub(short a, short b) {\n+        return (short)(a - b);\n+    }\n+\n+    static short scalar_mul(short a, short b) {\n+        return (short)(a * b);\n+    }\n+\n+    static short scalar_min(short a, short b) {\n+        return (short)(Math.min(a, b));\n+    }\n+\n+    static short scalar_max(short a, short b) {\n+        return (short)(Math.max(a, b));\n+    }\n+\n+    static short scalar_div(short a, short b) {\n+        return (short)(a \/ b);\n+    }\n+\n+    static short scalar_fma(short a, short b, short c) {\n+        return (short)(Math.fma(a, b, c));\n+    }\n+\n+    static short scalar_abs(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    static short scalar_neg(short a) {\n+        return ((short)-a);\n+    }\n+\n+    static short scalar_sin(short a) {\n+        return (short)Math.sin((double)a);\n+    }\n+\n+    static short scalar_exp(short a) {\n+        return (short)Math.exp((double)a);\n+    }\n+\n+    static short scalar_log1p(short a) {\n+        return (short)Math.log1p((double)a);\n+    }\n+\n+    static short scalar_log(short a) {\n+        return (short)Math.log((double)a);\n+    }\n+\n+    static short scalar_log10(short a) {\n+        return (short)Math.log10((double)a);\n+    }\n+\n+    static short scalar_expm1(short a) {\n+        return (short)Math.expm1((double)a);\n+    }\n+\n+    static short scalar_cos(short a) {\n+        return (short)Math.cos((double)a);\n+    }\n+\n+    static short scalar_tan(short a) {\n+        return (short)Math.tan((double)a);\n+    }\n+\n+    static short scalar_sinh(short a) {\n+        return (short)Math.sinh((double)a);\n+    }\n+\n+    static short scalar_cosh(short a) {\n+        return (short)Math.cosh((double)a);\n+    }\n+\n+    static short scalar_tanh(short a) {\n+        return (short)Math.tanh((double)a);\n+    }\n+\n+    static short scalar_asin(short a) {\n+        return (short)Math.asin((double)a);\n+    }\n+\n+    static short scalar_acos(short a) {\n+        return (short)Math.acos((double)a);\n+    }\n+\n+    static short scalar_atan(short a) {\n+        return (short)Math.atan((double)a);\n+    }\n+\n+    static short scalar_cbrt(short a) {\n+        return (short)Math.cbrt((double)a);\n+    }\n+\n+    static short scalar_sqrt(short a) {\n+        return (short)Math.sqrt((double)a);\n+    }\n+\n+    static short scalar_hypot(short a, short b) {\n+        return (short)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static short scalar_pow(short a, short b) {\n+        return (short)Math.pow((double)a, (double)b);\n+    }\n+\n+    static short scalar_atan2(short a, short b) {\n+        return (short)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static short strict_scalar_sin(short a) {\n+        return (short)StrictMath.sin((double)a);\n+    }\n+\n+    static short strict_scalar_exp(short a) {\n+        return (short)StrictMath.exp((double)a);\n+    }\n+\n+    static short strict_scalar_log1p(short a) {\n+        return (short)StrictMath.log1p((double)a);\n+    }\n+\n+    static short strict_scalar_log(short a) {\n+        return (short)StrictMath.log((double)a);\n+    }\n+\n+    static short strict_scalar_log10(short a) {\n+        return (short)StrictMath.log10((double)a);\n+    }\n+\n+    static short strict_scalar_expm1(short a) {\n+        return (short)StrictMath.expm1((double)a);\n+    }\n+\n+    static short strict_scalar_cos(short a) {\n+        return (short)StrictMath.cos((double)a);\n+    }\n+\n+    static short strict_scalar_tan(short a) {\n+        return (short)StrictMath.tan((double)a);\n+    }\n+\n+    static short strict_scalar_sinh(short a) {\n+        return (short)StrictMath.sinh((double)a);\n+    }\n+\n+    static short strict_scalar_cosh(short a) {\n+        return (short)StrictMath.cosh((double)a);\n+    }\n+\n+    static short strict_scalar_tanh(short a) {\n+        return (short)StrictMath.tanh((double)a);\n+    }\n+\n+    static short strict_scalar_asin(short a) {\n+        return (short)StrictMath.asin((double)a);\n+    }\n+\n+    static short strict_scalar_acos(short a) {\n+        return (short)StrictMath.acos((double)a);\n+    }\n+\n+    static short strict_scalar_atan(short a) {\n+        return (short)StrictMath.atan((double)a);\n+    }\n+\n+    static short strict_scalar_cbrt(short a) {\n+        return (short)StrictMath.cbrt((double)a);\n+    }\n+\n+    static short strict_scalar_sqrt(short a) {\n+        return (short)StrictMath.sqrt((double)a);\n+    }\n+\n+    static short strict_scalar_hypot(short a, short b) {\n+        return (short)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static short strict_scalar_pow(short a, short b) {\n+        return (short)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static short strict_scalar_atan2(short a, short b) {\n+        return (short)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static short additiveIdentity() {\n+        return (short)0;\n+    }\n+\n+\n@@ -1484,2 +1749,10 @@\n-    static short firstNonZero(short a, short b) {\n-        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    static short zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static short maxValue() {\n+        return Short.MAX_VALUE;\n+    }\n+\n+    static short minValue() {\n+        return Short.MIN_VALUE;\n@@ -1488,0 +1761,1 @@\n+\n@@ -1523,1 +1797,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1538,1 +1812,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1544,1 +1818,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1550,1 +1824,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1565,1 +1839,1 @@\n-        Assert.assertEquals(asIntegral.species(), SPECIES);\n+        AssertEquals(asIntegral.species(), SPECIES);\n@@ -1568,1 +1842,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test\n@@ -1570,1 +1844,6 @@\n-        SPECIES.zero().viewAsFloatingLanes();\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        VectorSpecies<?> asFloatingSpecies = asFloating.species();\n+        Assert.assertNotEquals(asFloatingSpecies.elementType(), SPECIES.elementType());\n+        AssertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        AssertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n@@ -1595,1 +1874,1 @@\n-        return (short)(a + b);\n+        return (short)(scalar_add(a, b));\n@@ -1616,1 +1895,1 @@\n-        return (short)(a + b);\n+        return (short)(scalar_add(a, b));\n@@ -1673,1 +1952,1 @@\n-        return (short)(a - b);\n+        return (short)(scalar_sub(a, b));\n@@ -1694,1 +1973,1 @@\n-        return (short)(a - b);\n+        return (short)(scalar_sub(a, b));\n@@ -1751,1 +2030,1 @@\n-        return (short)(a * b);\n+        return (short)(scalar_mul(a, b));\n@@ -1772,1 +2051,1 @@\n-        return (short)(a * b);\n+        return (short)(scalar_mul(a, b));\n@@ -1919,1 +2198,1 @@\n-        return (short)((a)!=0?a:b);\n+        return (short)(firstNonZero(a, b));\n@@ -3026,2 +3305,0 @@\n-    static ShortVector bv_MIN = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3036,1 +3313,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -3043,2 +3320,0 @@\n-    static ShortVector bv_min = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3053,1 +3328,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -3060,2 +3335,0 @@\n-    static ShortVector bv_MIN_M = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3072,1 +3345,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -3079,2 +3352,0 @@\n-    static ShortVector bv_MAX = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3089,1 +3360,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -3096,2 +3367,0 @@\n-    static ShortVector bv_max = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3106,1 +3375,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -3113,2 +3382,0 @@\n-    static ShortVector bv_MAX_M = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3125,1 +3392,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -3133,1 +3400,1 @@\n-        return (short)(Math.min(a, b));\n+        return (short)(scalar_min(a, b));\n@@ -3154,1 +3421,1 @@\n-        return (short)(Math.min(a, b));\n+        return (short)(scalar_min(a, b));\n@@ -3173,1 +3440,1 @@\n-        return (short)(Math.max(a, b));\n+        return (short)(scalar_max(a, b));\n@@ -3194,1 +3461,1 @@\n-        return (short)(Math.max(a, b));\n+        return (short)(scalar_max(a, b));\n@@ -3562,1 +3829,1 @@\n-            res &= a[i];\n+            res = scalar_and(res, a[i]);\n@@ -3571,1 +3838,1 @@\n-            res &= ANDReduce(a, i);\n+            res = scalar_and(res, ANDReduce(a, i));\n@@ -3594,1 +3861,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND));\n@@ -3606,1 +3873,1 @@\n-                res &= a[i];\n+                res = scalar_and(res, a[i]);\n@@ -3615,1 +3882,1 @@\n-            res &= ANDReduceMasked(a, i, mask);\n+            res = scalar_and(res, ANDReduceMasked(a, i, mask));\n@@ -3640,1 +3907,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND, vmask));\n@@ -3651,1 +3918,1 @@\n-            res |= a[i];\n+            res = scalar_or(res, a[i]);\n@@ -3660,1 +3927,1 @@\n-            res |= ORReduce(a, i);\n+            res = scalar_or(res, ORReduce(a, i));\n@@ -3683,1 +3950,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR));\n@@ -3695,1 +3962,1 @@\n-                res |= a[i];\n+                res = scalar_or(res, a[i]);\n@@ -3704,1 +3971,1 @@\n-            res |= ORReduceMasked(a, i, mask);\n+            res = scalar_or(res, ORReduceMasked(a, i, mask));\n@@ -3729,1 +3996,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR, vmask));\n@@ -3740,1 +4007,1 @@\n-            res ^= a[i];\n+            res = scalar_xor(res, a[i]);\n@@ -3749,1 +4016,1 @@\n-            res ^= XORReduce(a, i);\n+            res = scalar_xor(res, XORReduce(a, i));\n@@ -3772,1 +4039,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR));\n@@ -3784,1 +4051,1 @@\n-                res ^= a[i];\n+                res = scalar_xor(res, a[i]);\n@@ -3793,1 +4060,1 @@\n-            res ^= XORReduceMasked(a, i, mask);\n+            res = scalar_xor(res, XORReduceMasked(a, i, mask));\n@@ -3818,1 +4085,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR, vmask));\n@@ -3827,1 +4094,1 @@\n-        short res = 0;\n+        short res = additiveIdentity();\n@@ -3829,1 +4096,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -3836,1 +4103,1 @@\n-        short res = 0;\n+        short res = additiveIdentity();\n@@ -3838,1 +4105,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -3848,1 +4115,1 @@\n-        short ra = 0;\n+        short ra = additiveIdentity();\n@@ -3858,1 +4125,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3861,1 +4128,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -3870,1 +4137,1 @@\n-        short res = 0;\n+        short res = additiveIdentity();\n@@ -3873,1 +4140,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -3880,1 +4147,1 @@\n-        short res = 0;\n+        short res = additiveIdentity();\n@@ -3882,1 +4149,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -3894,1 +4161,1 @@\n-        short ra = 0;\n+        short ra = additiveIdentity();\n@@ -3904,1 +4171,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3907,1 +4174,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -3916,1 +4183,1 @@\n-        short res = 1;\n+        short res = multiplicativeIdentity();\n@@ -3918,1 +4185,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -3925,1 +4192,1 @@\n-        short res = 1;\n+        short res = multiplicativeIdentity();\n@@ -3927,1 +4194,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -3937,1 +4204,1 @@\n-        short ra = 1;\n+        short ra = multiplicativeIdentity();\n@@ -3947,1 +4214,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -3950,1 +4217,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -3959,1 +4226,1 @@\n-        short res = 1;\n+        short res = multiplicativeIdentity();\n@@ -3962,1 +4229,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -3969,1 +4236,1 @@\n-        short res = 1;\n+        short res = multiplicativeIdentity();\n@@ -3971,1 +4238,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -3983,1 +4250,1 @@\n-        short ra = 1;\n+        short ra = multiplicativeIdentity();\n@@ -3993,1 +4260,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -3996,1 +4263,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -4005,1 +4272,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4007,1 +4274,1 @@\n-            res = (short) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -4014,1 +4281,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4016,1 +4283,1 @@\n-            res = (short) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -4026,1 +4293,1 @@\n-        short ra = Short.MAX_VALUE;\n+        short ra = maxValue();\n@@ -4036,1 +4303,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = maxValue();\n@@ -4039,1 +4306,1 @@\n-                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -4048,1 +4315,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4051,1 +4318,1 @@\n-                res = (short) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -4058,1 +4325,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4060,1 +4327,1 @@\n-            res = (short) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -4072,1 +4339,1 @@\n-        short ra = Short.MAX_VALUE;\n+        short ra = maxValue();\n@@ -4082,1 +4349,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = maxValue();\n@@ -4085,1 +4352,1 @@\n-                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -4094,1 +4361,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4096,1 +4363,1 @@\n-            res = (short) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -4103,1 +4370,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4105,1 +4372,1 @@\n-            res = (short) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -4115,1 +4382,1 @@\n-        short ra = Short.MIN_VALUE;\n+        short ra = minValue();\n@@ -4125,1 +4392,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = minValue();\n@@ -4128,1 +4395,1 @@\n-                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -4137,1 +4404,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4140,1 +4407,1 @@\n-                res = (short) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -4147,1 +4414,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4149,1 +4416,1 @@\n-            res = (short) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -4161,1 +4428,1 @@\n-        short ra = Short.MIN_VALUE;\n+        short ra = minValue();\n@@ -4171,1 +4438,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = minValue();\n@@ -4174,1 +4441,1 @@\n-                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -4183,1 +4450,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4192,1 +4459,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4204,1 +4471,1 @@\n-        short ra = Short.MAX_VALUE;\n+        short ra = maxValue();\n@@ -4214,1 +4481,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = maxValue();\n@@ -4226,1 +4493,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4236,1 +4503,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4250,1 +4517,1 @@\n-        short ra = Short.MAX_VALUE;\n+        short ra = maxValue();\n@@ -4260,1 +4527,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = maxValue();\n@@ -4272,1 +4539,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4281,1 +4548,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4293,1 +4560,1 @@\n-        short ra = Short.MIN_VALUE;\n+        short ra = minValue();\n@@ -4303,1 +4570,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = minValue();\n@@ -4315,1 +4582,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4325,1 +4592,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4339,1 +4606,1 @@\n-        short ra = Short.MIN_VALUE;\n+        short ra = minValue();\n@@ -4349,1 +4616,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = minValue();\n@@ -4361,1 +4628,1 @@\n-        short res = (short) 0;\n+        short res = zeroValue();\n@@ -4370,1 +4637,1 @@\n-        short res = (short) 0;\n+        short res = zeroValue();\n@@ -4382,1 +4649,1 @@\n-        short ra = (short) 0;\n+        short ra = zeroValue();\n@@ -4392,1 +4659,1 @@\n-            ra = (short) 0;\n+            ra = zeroValue();\n@@ -4404,1 +4671,1 @@\n-        short res = (short) 0;\n+        short res = zeroValue();\n@@ -4414,1 +4681,1 @@\n-        short res = (short) 0;\n+        short res = zeroValue();\n@@ -4428,1 +4695,1 @@\n-        short ra = (short) 0;\n+        short ra = zeroValue();\n@@ -4438,1 +4705,1 @@\n-            ra = (short) 0;\n+            ra = zeroValue();\n@@ -4498,1 +4765,1 @@\n-        short res = 0;\n+        short res = zeroValue();\n@@ -4507,1 +4774,1 @@\n-        short res = 0;\n+        short res = zeroValue();\n@@ -4519,1 +4786,1 @@\n-        short ra = 0;\n+        short ra = zeroValue();\n@@ -4529,1 +4796,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4541,1 +4808,1 @@\n-        short res = 0;\n+        short res = zeroValue();\n@@ -4551,1 +4818,1 @@\n-        short res = 0;\n+        short res = zeroValue();\n@@ -4564,1 +4831,1 @@\n-        short ra = 0;\n+        short ra = zeroValue();\n@@ -4574,1 +4841,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4619,1 +4886,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -4639,1 +4906,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -4660,1 +4927,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -4680,1 +4947,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -4699,1 +4966,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4718,1 +4985,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4741,1 +5008,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -4760,1 +5027,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -4783,1 +5050,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -4802,1 +5069,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4821,1 +5088,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4844,1 +5111,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -4863,1 +5130,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -4886,1 +5153,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -4905,1 +5172,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -4928,1 +5195,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -4947,1 +5214,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -4970,1 +5237,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -4989,1 +5256,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n@@ -5012,1 +5279,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n@@ -5031,1 +5298,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n@@ -5054,1 +5321,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -5073,1 +5340,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n@@ -5096,1 +5363,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n@@ -5115,1 +5382,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n@@ -5138,1 +5405,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n@@ -5155,1 +5422,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -5175,1 +5442,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -5191,1 +5458,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < (short)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (short)((long)b[i])));\n@@ -5211,1 +5478,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < (short)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(short)((long)b[i]))));\n@@ -5227,1 +5494,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -5247,1 +5514,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -5263,1 +5530,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == (short)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (short)((long)b[i])));\n@@ -5283,1 +5550,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == (short)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(short)((long)b[i]))));\n@@ -5564,1 +5831,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -5995,1 +6262,1 @@\n-        return (short)(-((short)a));\n+        return (short)(scalar_neg((short)a));\n@@ -5999,1 +6266,1 @@\n-        return (short)(-((short)a));\n+        return (short)(scalar_neg((short)a));\n@@ -6051,1 +6318,1 @@\n-        return (short)(Math.abs((short)a));\n+        return (short)(scalar_abs((short)a));\n@@ -6055,1 +6322,1 @@\n-        return (short)(Math.abs((short)a));\n+        return (short)(scalar_abs((short)a));\n@@ -6395,1 +6662,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -6411,1 +6678,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -6507,1 +6774,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6548,1 +6815,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6651,1 +6918,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -6679,1 +6946,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -6693,1 +6960,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -6890,1 +7157,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -6910,1 +7177,1 @@\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -6933,1 +7200,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6947,1 +7214,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6969,1 +7236,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -6977,1 +7244,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -6984,1 +7251,1 @@\n-        Assert.assertEquals(elsize, Short.SIZE);\n+        AssertEquals(elsize, Short.SIZE);\n@@ -7003,1 +7270,1 @@\n-    static void ElementTypeShort512VectorTestsSmokeTest() {\n+    static void ShortShort512VectorTestsSmokeTest() {\n@@ -7038,1 +7305,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":599,"deletions":332,"binary":false,"changes":931,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,45 @@\n+    static ShortVector bcast_vec = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    static void AssertEquals(short actual, short expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(short actual, short expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(short actual, short expected, short delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(short actual, short expected, short delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(short [] actual, short [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(short [] actual, short [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -87,1 +132,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -90,1 +135,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -102,1 +147,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -108,1 +153,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -118,1 +163,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -121,1 +166,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -137,1 +182,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -139,1 +184,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -142,2 +187,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -159,1 +204,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -161,1 +206,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -164,2 +209,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -181,1 +226,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -183,1 +228,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -186,2 +231,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -203,1 +248,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -205,1 +250,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -208,2 +253,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -221,1 +266,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -224,1 +269,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -236,1 +281,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -239,1 +284,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -248,1 +293,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -253,1 +298,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -264,1 +309,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -269,1 +314,1 @@\n-                    Assert.assertEquals(r[i + k], (short)0);\n+                    AssertEquals(r[i + k], (short)0);\n@@ -275,1 +320,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -277,1 +322,1 @@\n-                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (short)0, \"at index #\" + idx);\n@@ -289,1 +334,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -292,1 +337,1 @@\n-                        Assert.assertEquals(r[i + j], (short)0);\n+                        AssertEquals(r[i + j], (short)0);\n@@ -299,1 +344,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -301,1 +346,1 @@\n-                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (short)0, \"at index #\" + idx);\n@@ -317,1 +362,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -321,1 +366,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -327,0 +372,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -330,1 +376,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -334,2 +382,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -345,1 +392,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -347,1 +394,1 @@\n-                         Assert.assertEquals(r[i+j], (short)0);\n+                         AssertEquals(r[i+j], (short)0);\n@@ -353,1 +400,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -355,1 +402,1 @@\n-                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -361,0 +408,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -364,0 +412,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -365,1 +415,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -367,1 +417,1 @@\n-                         Assert.assertEquals(r[i+j], (short)0);\n+                         AssertEquals(r[i+j], (short)0);\n@@ -371,1 +421,0 @@\n-            int idx = i + j;\n@@ -373,1 +422,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -375,1 +424,1 @@\n-                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -389,1 +438,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -392,1 +441,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -413,1 +462,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -416,1 +465,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -419,1 +468,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -422,3 +471,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -439,1 +488,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -442,1 +491,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -445,1 +494,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -448,3 +497,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -458,1 +507,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -461,1 +510,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -469,1 +518,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -472,1 +521,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -480,1 +529,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -483,1 +532,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -492,1 +541,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -495,1 +544,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -508,1 +557,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -511,1 +560,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -523,1 +572,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -526,1 +575,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -538,1 +587,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -541,1 +590,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -556,1 +605,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -559,1 +608,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -572,1 +621,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -576,1 +625,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -590,1 +639,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -594,1 +643,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -616,1 +665,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -620,1 +669,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -634,1 +683,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -638,1 +687,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -658,1 +707,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -661,1 +710,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -673,1 +722,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -676,1 +725,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -685,1 +734,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -688,1 +737,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -698,1 +747,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -701,1 +750,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -717,1 +766,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -721,1 +770,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -738,1 +787,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -742,1 +791,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -753,1 +802,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -757,1 +806,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -774,1 +823,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -778,1 +827,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -796,1 +845,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -802,1 +851,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -823,1 +872,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -829,1 +878,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -844,1 +893,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -850,1 +899,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -871,1 +920,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -877,1 +926,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -891,1 +940,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -897,1 +946,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -912,1 +961,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -918,1 +967,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -933,1 +982,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -939,1 +988,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -955,1 +1004,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -961,1 +1010,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -969,0 +1018,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -974,1 +1027,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -977,1 +1030,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -987,1 +1040,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -990,1 +1043,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -998,1 +1051,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                AssertEquals(r[i], (double)(a[i+offs]));\n@@ -1001,1 +1054,1 @@\n-            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1010,1 +1063,1 @@\n-            withToString(\"short[-i * 5]\", (int s) -> {\n+            withToString(\"Short[-i * 5]\", (int s) -> {\n@@ -1012,1 +1065,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1014,1 +1067,1 @@\n-            withToString(\"short[i * 5]\", (int s) -> {\n+            withToString(\"Short[i * 5]\", (int s) -> {\n@@ -1016,1 +1069,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1018,1 +1071,1 @@\n-            withToString(\"short[i + 1]\", (int s) -> {\n+            withToString(\"Short[i + 1]\", (int s) -> {\n@@ -1020,1 +1073,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1468,0 +1521,212 @@\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+    static short multiplicativeIdentity() {\n+        return (short)1;\n+    }\n+\n+    static short scalar_or(short a, short b) {\n+        return (short)(a | b);\n+    }\n+\n+    static short scalar_and(short a, short b) {\n+        return (short)(a & b);\n+    }\n+\n+    static short scalar_xor(short a, short b) {\n+        return (short)(a ^ b);\n+    }\n+\n+    static short scalar_add(short a, short b) {\n+        return (short)(a + b);\n+    }\n+\n+    static short scalar_sub(short a, short b) {\n+        return (short)(a - b);\n+    }\n+\n+    static short scalar_mul(short a, short b) {\n+        return (short)(a * b);\n+    }\n+\n+    static short scalar_min(short a, short b) {\n+        return (short)(Math.min(a, b));\n+    }\n+\n+    static short scalar_max(short a, short b) {\n+        return (short)(Math.max(a, b));\n+    }\n+\n+    static short scalar_div(short a, short b) {\n+        return (short)(a \/ b);\n+    }\n+\n+    static short scalar_fma(short a, short b, short c) {\n+        return (short)(Math.fma(a, b, c));\n+    }\n+\n+    static short scalar_abs(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    static short scalar_neg(short a) {\n+        return ((short)-a);\n+    }\n+\n+    static short scalar_sin(short a) {\n+        return (short)Math.sin((double)a);\n+    }\n+\n+    static short scalar_exp(short a) {\n+        return (short)Math.exp((double)a);\n+    }\n+\n+    static short scalar_log1p(short a) {\n+        return (short)Math.log1p((double)a);\n+    }\n+\n+    static short scalar_log(short a) {\n+        return (short)Math.log((double)a);\n+    }\n+\n+    static short scalar_log10(short a) {\n+        return (short)Math.log10((double)a);\n+    }\n+\n+    static short scalar_expm1(short a) {\n+        return (short)Math.expm1((double)a);\n+    }\n+\n+    static short scalar_cos(short a) {\n+        return (short)Math.cos((double)a);\n+    }\n+\n+    static short scalar_tan(short a) {\n+        return (short)Math.tan((double)a);\n+    }\n+\n+    static short scalar_sinh(short a) {\n+        return (short)Math.sinh((double)a);\n+    }\n+\n+    static short scalar_cosh(short a) {\n+        return (short)Math.cosh((double)a);\n+    }\n+\n+    static short scalar_tanh(short a) {\n+        return (short)Math.tanh((double)a);\n+    }\n+\n+    static short scalar_asin(short a) {\n+        return (short)Math.asin((double)a);\n+    }\n+\n+    static short scalar_acos(short a) {\n+        return (short)Math.acos((double)a);\n+    }\n+\n+    static short scalar_atan(short a) {\n+        return (short)Math.atan((double)a);\n+    }\n+\n+    static short scalar_cbrt(short a) {\n+        return (short)Math.cbrt((double)a);\n+    }\n+\n+    static short scalar_sqrt(short a) {\n+        return (short)Math.sqrt((double)a);\n+    }\n+\n+    static short scalar_hypot(short a, short b) {\n+        return (short)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static short scalar_pow(short a, short b) {\n+        return (short)Math.pow((double)a, (double)b);\n+    }\n+\n+    static short scalar_atan2(short a, short b) {\n+        return (short)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static short strict_scalar_sin(short a) {\n+        return (short)StrictMath.sin((double)a);\n+    }\n+\n+    static short strict_scalar_exp(short a) {\n+        return (short)StrictMath.exp((double)a);\n+    }\n+\n+    static short strict_scalar_log1p(short a) {\n+        return (short)StrictMath.log1p((double)a);\n+    }\n+\n+    static short strict_scalar_log(short a) {\n+        return (short)StrictMath.log((double)a);\n+    }\n+\n+    static short strict_scalar_log10(short a) {\n+        return (short)StrictMath.log10((double)a);\n+    }\n+\n+    static short strict_scalar_expm1(short a) {\n+        return (short)StrictMath.expm1((double)a);\n+    }\n+\n+    static short strict_scalar_cos(short a) {\n+        return (short)StrictMath.cos((double)a);\n+    }\n+\n+    static short strict_scalar_tan(short a) {\n+        return (short)StrictMath.tan((double)a);\n+    }\n+\n+    static short strict_scalar_sinh(short a) {\n+        return (short)StrictMath.sinh((double)a);\n+    }\n+\n+    static short strict_scalar_cosh(short a) {\n+        return (short)StrictMath.cosh((double)a);\n+    }\n+\n+    static short strict_scalar_tanh(short a) {\n+        return (short)StrictMath.tanh((double)a);\n+    }\n+\n+    static short strict_scalar_asin(short a) {\n+        return (short)StrictMath.asin((double)a);\n+    }\n+\n+    static short strict_scalar_acos(short a) {\n+        return (short)StrictMath.acos((double)a);\n+    }\n+\n+    static short strict_scalar_atan(short a) {\n+        return (short)StrictMath.atan((double)a);\n+    }\n+\n+    static short strict_scalar_cbrt(short a) {\n+        return (short)StrictMath.cbrt((double)a);\n+    }\n+\n+    static short strict_scalar_sqrt(short a) {\n+        return (short)StrictMath.sqrt((double)a);\n+    }\n+\n+    static short strict_scalar_hypot(short a, short b) {\n+        return (short)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static short strict_scalar_pow(short a, short b) {\n+        return (short)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static short strict_scalar_atan2(short a, short b) {\n+        return (short)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static short additiveIdentity() {\n+        return (short)0;\n+    }\n+\n+\n@@ -1484,2 +1749,10 @@\n-    static short firstNonZero(short a, short b) {\n-        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    static short zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static short maxValue() {\n+        return Short.MAX_VALUE;\n+    }\n+\n+    static short minValue() {\n+        return Short.MIN_VALUE;\n@@ -1488,0 +1761,1 @@\n+\n@@ -1523,1 +1797,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1538,1 +1812,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1544,1 +1818,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1550,1 +1824,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1565,1 +1839,1 @@\n-        Assert.assertEquals(asIntegral.species(), SPECIES);\n+        AssertEquals(asIntegral.species(), SPECIES);\n@@ -1568,1 +1842,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test\n@@ -1570,1 +1844,6 @@\n-        SPECIES.zero().viewAsFloatingLanes();\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        VectorSpecies<?> asFloatingSpecies = asFloating.species();\n+        Assert.assertNotEquals(asFloatingSpecies.elementType(), SPECIES.elementType());\n+        AssertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        AssertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n@@ -1595,1 +1874,1 @@\n-        return (short)(a + b);\n+        return (short)(scalar_add(a, b));\n@@ -1616,1 +1895,1 @@\n-        return (short)(a + b);\n+        return (short)(scalar_add(a, b));\n@@ -1673,1 +1952,1 @@\n-        return (short)(a - b);\n+        return (short)(scalar_sub(a, b));\n@@ -1694,1 +1973,1 @@\n-        return (short)(a - b);\n+        return (short)(scalar_sub(a, b));\n@@ -1751,1 +2030,1 @@\n-        return (short)(a * b);\n+        return (short)(scalar_mul(a, b));\n@@ -1772,1 +2051,1 @@\n-        return (short)(a * b);\n+        return (short)(scalar_mul(a, b));\n@@ -1919,1 +2198,1 @@\n-        return (short)((a)!=0?a:b);\n+        return (short)(firstNonZero(a, b));\n@@ -3026,2 +3305,0 @@\n-    static ShortVector bv_MIN = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3036,1 +3313,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -3043,2 +3320,0 @@\n-    static ShortVector bv_min = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3053,1 +3328,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -3060,2 +3335,0 @@\n-    static ShortVector bv_MIN_M = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3072,1 +3345,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -3079,2 +3352,0 @@\n-    static ShortVector bv_MAX = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3089,1 +3360,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -3096,2 +3367,0 @@\n-    static ShortVector bv_max = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3106,1 +3375,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -3113,2 +3382,0 @@\n-    static ShortVector bv_MAX_M = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3125,1 +3392,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -3133,1 +3400,1 @@\n-        return (short)(Math.min(a, b));\n+        return (short)(scalar_min(a, b));\n@@ -3154,1 +3421,1 @@\n-        return (short)(Math.min(a, b));\n+        return (short)(scalar_min(a, b));\n@@ -3173,1 +3440,1 @@\n-        return (short)(Math.max(a, b));\n+        return (short)(scalar_max(a, b));\n@@ -3194,1 +3461,1 @@\n-        return (short)(Math.max(a, b));\n+        return (short)(scalar_max(a, b));\n@@ -3562,1 +3829,1 @@\n-            res &= a[i];\n+            res = scalar_and(res, a[i]);\n@@ -3571,1 +3838,1 @@\n-            res &= ANDReduce(a, i);\n+            res = scalar_and(res, ANDReduce(a, i));\n@@ -3594,1 +3861,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND));\n@@ -3606,1 +3873,1 @@\n-                res &= a[i];\n+                res = scalar_and(res, a[i]);\n@@ -3615,1 +3882,1 @@\n-            res &= ANDReduceMasked(a, i, mask);\n+            res = scalar_and(res, ANDReduceMasked(a, i, mask));\n@@ -3640,1 +3907,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND, vmask));\n@@ -3651,1 +3918,1 @@\n-            res |= a[i];\n+            res = scalar_or(res, a[i]);\n@@ -3660,1 +3927,1 @@\n-            res |= ORReduce(a, i);\n+            res = scalar_or(res, ORReduce(a, i));\n@@ -3683,1 +3950,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR));\n@@ -3695,1 +3962,1 @@\n-                res |= a[i];\n+                res = scalar_or(res, a[i]);\n@@ -3704,1 +3971,1 @@\n-            res |= ORReduceMasked(a, i, mask);\n+            res = scalar_or(res, ORReduceMasked(a, i, mask));\n@@ -3729,1 +3996,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR, vmask));\n@@ -3740,1 +4007,1 @@\n-            res ^= a[i];\n+            res = scalar_xor(res, a[i]);\n@@ -3749,1 +4016,1 @@\n-            res ^= XORReduce(a, i);\n+            res = scalar_xor(res, XORReduce(a, i));\n@@ -3772,1 +4039,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR));\n@@ -3784,1 +4051,1 @@\n-                res ^= a[i];\n+                res = scalar_xor(res, a[i]);\n@@ -3793,1 +4060,1 @@\n-            res ^= XORReduceMasked(a, i, mask);\n+            res = scalar_xor(res, XORReduceMasked(a, i, mask));\n@@ -3818,1 +4085,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR, vmask));\n@@ -3827,1 +4094,1 @@\n-        short res = 0;\n+        short res = additiveIdentity();\n@@ -3829,1 +4096,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -3836,1 +4103,1 @@\n-        short res = 0;\n+        short res = additiveIdentity();\n@@ -3838,1 +4105,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -3848,1 +4115,1 @@\n-        short ra = 0;\n+        short ra = additiveIdentity();\n@@ -3858,1 +4125,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3861,1 +4128,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -3870,1 +4137,1 @@\n-        short res = 0;\n+        short res = additiveIdentity();\n@@ -3873,1 +4140,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -3880,1 +4147,1 @@\n-        short res = 0;\n+        short res = additiveIdentity();\n@@ -3882,1 +4149,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -3894,1 +4161,1 @@\n-        short ra = 0;\n+        short ra = additiveIdentity();\n@@ -3904,1 +4171,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3907,1 +4174,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -3916,1 +4183,1 @@\n-        short res = 1;\n+        short res = multiplicativeIdentity();\n@@ -3918,1 +4185,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -3925,1 +4192,1 @@\n-        short res = 1;\n+        short res = multiplicativeIdentity();\n@@ -3927,1 +4194,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -3937,1 +4204,1 @@\n-        short ra = 1;\n+        short ra = multiplicativeIdentity();\n@@ -3947,1 +4214,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -3950,1 +4217,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -3959,1 +4226,1 @@\n-        short res = 1;\n+        short res = multiplicativeIdentity();\n@@ -3962,1 +4229,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -3969,1 +4236,1 @@\n-        short res = 1;\n+        short res = multiplicativeIdentity();\n@@ -3971,1 +4238,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -3983,1 +4250,1 @@\n-        short ra = 1;\n+        short ra = multiplicativeIdentity();\n@@ -3993,1 +4260,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -3996,1 +4263,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -4005,1 +4272,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4007,1 +4274,1 @@\n-            res = (short) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -4014,1 +4281,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4016,1 +4283,1 @@\n-            res = (short) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -4026,1 +4293,1 @@\n-        short ra = Short.MAX_VALUE;\n+        short ra = maxValue();\n@@ -4036,1 +4303,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = maxValue();\n@@ -4039,1 +4306,1 @@\n-                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -4048,1 +4315,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4051,1 +4318,1 @@\n-                res = (short) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -4058,1 +4325,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4060,1 +4327,1 @@\n-            res = (short) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -4072,1 +4339,1 @@\n-        short ra = Short.MAX_VALUE;\n+        short ra = maxValue();\n@@ -4082,1 +4349,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = maxValue();\n@@ -4085,1 +4352,1 @@\n-                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -4094,1 +4361,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4096,1 +4363,1 @@\n-            res = (short) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -4103,1 +4370,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4105,1 +4372,1 @@\n-            res = (short) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -4115,1 +4382,1 @@\n-        short ra = Short.MIN_VALUE;\n+        short ra = minValue();\n@@ -4125,1 +4392,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = minValue();\n@@ -4128,1 +4395,1 @@\n-                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -4137,1 +4404,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4140,1 +4407,1 @@\n-                res = (short) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -4147,1 +4414,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4149,1 +4416,1 @@\n-            res = (short) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -4161,1 +4428,1 @@\n-        short ra = Short.MIN_VALUE;\n+        short ra = minValue();\n@@ -4171,1 +4438,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = minValue();\n@@ -4174,1 +4441,1 @@\n-                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -4183,1 +4450,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4192,1 +4459,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4204,1 +4471,1 @@\n-        short ra = Short.MAX_VALUE;\n+        short ra = maxValue();\n@@ -4214,1 +4481,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = maxValue();\n@@ -4226,1 +4493,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4236,1 +4503,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4250,1 +4517,1 @@\n-        short ra = Short.MAX_VALUE;\n+        short ra = maxValue();\n@@ -4260,1 +4527,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = maxValue();\n@@ -4272,1 +4539,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4281,1 +4548,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4293,1 +4560,1 @@\n-        short ra = Short.MIN_VALUE;\n+        short ra = minValue();\n@@ -4303,1 +4570,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = minValue();\n@@ -4315,1 +4582,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4325,1 +4592,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4339,1 +4606,1 @@\n-        short ra = Short.MIN_VALUE;\n+        short ra = minValue();\n@@ -4349,1 +4616,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = minValue();\n@@ -4361,1 +4628,1 @@\n-        short res = (short) 0;\n+        short res = zeroValue();\n@@ -4370,1 +4637,1 @@\n-        short res = (short) 0;\n+        short res = zeroValue();\n@@ -4382,1 +4649,1 @@\n-        short ra = (short) 0;\n+        short ra = zeroValue();\n@@ -4392,1 +4659,1 @@\n-            ra = (short) 0;\n+            ra = zeroValue();\n@@ -4404,1 +4671,1 @@\n-        short res = (short) 0;\n+        short res = zeroValue();\n@@ -4414,1 +4681,1 @@\n-        short res = (short) 0;\n+        short res = zeroValue();\n@@ -4428,1 +4695,1 @@\n-        short ra = (short) 0;\n+        short ra = zeroValue();\n@@ -4438,1 +4705,1 @@\n-            ra = (short) 0;\n+            ra = zeroValue();\n@@ -4498,1 +4765,1 @@\n-        short res = 0;\n+        short res = zeroValue();\n@@ -4507,1 +4774,1 @@\n-        short res = 0;\n+        short res = zeroValue();\n@@ -4519,1 +4786,1 @@\n-        short ra = 0;\n+        short ra = zeroValue();\n@@ -4529,1 +4796,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4541,1 +4808,1 @@\n-        short res = 0;\n+        short res = zeroValue();\n@@ -4551,1 +4818,1 @@\n-        short res = 0;\n+        short res = zeroValue();\n@@ -4564,1 +4831,1 @@\n-        short ra = 0;\n+        short ra = zeroValue();\n@@ -4574,1 +4841,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4619,1 +4886,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -4639,1 +4906,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -4660,1 +4927,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -4680,1 +4947,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -4699,1 +4966,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4718,1 +4985,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4741,1 +5008,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -4760,1 +5027,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -4783,1 +5050,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -4802,1 +5069,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4821,1 +5088,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4844,1 +5111,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -4863,1 +5130,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -4886,1 +5153,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -4905,1 +5172,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -4928,1 +5195,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -4947,1 +5214,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -4970,1 +5237,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -4989,1 +5256,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n@@ -5012,1 +5279,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n@@ -5031,1 +5298,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n@@ -5054,1 +5321,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -5073,1 +5340,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n@@ -5096,1 +5363,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n@@ -5115,1 +5382,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n@@ -5138,1 +5405,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n@@ -5155,1 +5422,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -5175,1 +5442,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -5191,1 +5458,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < (short)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (short)((long)b[i])));\n@@ -5211,1 +5478,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < (short)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(short)((long)b[i]))));\n@@ -5227,1 +5494,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -5247,1 +5514,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -5263,1 +5530,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == (short)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (short)((long)b[i])));\n@@ -5283,1 +5550,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == (short)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(short)((long)b[i]))));\n@@ -5564,1 +5831,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -5995,1 +6262,1 @@\n-        return (short)(-((short)a));\n+        return (short)(scalar_neg((short)a));\n@@ -5999,1 +6266,1 @@\n-        return (short)(-((short)a));\n+        return (short)(scalar_neg((short)a));\n@@ -6051,1 +6318,1 @@\n-        return (short)(Math.abs((short)a));\n+        return (short)(scalar_abs((short)a));\n@@ -6055,1 +6322,1 @@\n-        return (short)(Math.abs((short)a));\n+        return (short)(scalar_abs((short)a));\n@@ -6395,1 +6662,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -6411,1 +6678,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -6507,1 +6774,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6548,1 +6815,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6651,1 +6918,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -6679,1 +6946,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -6693,1 +6960,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -6890,1 +7157,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -6910,1 +7177,1 @@\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -6933,1 +7200,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6947,1 +7214,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6969,1 +7236,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -6977,1 +7244,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -6984,1 +7251,1 @@\n-        Assert.assertEquals(elsize, Short.SIZE);\n+        AssertEquals(elsize, Short.SIZE);\n@@ -7003,1 +7270,1 @@\n-    static void ElementTypeShort64VectorTestsSmokeTest() {\n+    static void ShortShort64VectorTestsSmokeTest() {\n@@ -7038,1 +7305,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":599,"deletions":332,"binary":false,"changes":931,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,45 @@\n+    static ShortVector bcast_vec = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    static void AssertEquals(short actual, short expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(short actual, short expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(short actual, short expected, short delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals(short actual, short expected, short delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals(short [] actual, short [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(short [] actual, short [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -92,1 +137,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -95,1 +140,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -107,1 +152,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -113,1 +158,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -123,1 +168,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -126,1 +171,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -142,1 +187,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -144,1 +189,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -147,2 +192,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -164,1 +209,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -166,1 +211,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -169,2 +214,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -186,1 +231,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -188,1 +233,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -191,2 +236,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -208,1 +253,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -210,1 +255,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -213,2 +258,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -226,1 +271,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -229,1 +274,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -241,1 +286,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -244,1 +289,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -253,1 +298,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -258,1 +303,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -269,1 +314,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -274,1 +319,1 @@\n-                    Assert.assertEquals(r[i + k], (short)0);\n+                    AssertEquals(r[i + k], (short)0);\n@@ -280,1 +325,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -282,1 +327,1 @@\n-                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (short)0, \"at index #\" + idx);\n@@ -294,1 +339,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -297,1 +342,1 @@\n-                        Assert.assertEquals(r[i + j], (short)0);\n+                        AssertEquals(r[i + j], (short)0);\n@@ -304,1 +349,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -306,1 +351,1 @@\n-                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], (short)0, \"at index #\" + idx);\n@@ -322,1 +367,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -326,1 +371,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -332,0 +377,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -335,1 +381,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -339,2 +387,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -350,1 +397,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -352,1 +399,1 @@\n-                         Assert.assertEquals(r[i+j], (short)0);\n+                         AssertEquals(r[i+j], (short)0);\n@@ -358,1 +405,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -360,1 +407,1 @@\n-                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -366,0 +413,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -369,0 +417,2 @@\n+                    idx = (int)order[i+j];\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -370,1 +420,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -372,1 +422,1 @@\n-                         Assert.assertEquals(r[i+j], (short)0);\n+                         AssertEquals(r[i+j], (short)0);\n@@ -376,1 +426,0 @@\n-            int idx = i + j;\n@@ -378,1 +427,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -380,1 +429,1 @@\n-                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -394,1 +443,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -397,1 +446,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -418,1 +467,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -421,1 +470,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -424,1 +473,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -427,3 +476,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -444,1 +493,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -447,1 +496,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -450,1 +499,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -453,3 +502,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -463,1 +512,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -466,1 +515,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -474,1 +523,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -477,1 +526,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -485,1 +534,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -488,1 +537,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -497,1 +546,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -500,1 +549,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -513,1 +562,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -516,1 +565,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -528,1 +577,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -531,1 +580,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -543,1 +592,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -546,1 +595,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -561,1 +610,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -564,1 +613,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -577,1 +626,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -581,1 +630,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -595,1 +644,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -599,1 +648,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -621,1 +670,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -625,1 +674,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -639,1 +688,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -643,1 +692,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -663,1 +712,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -666,1 +715,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -678,1 +727,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -681,1 +730,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -690,1 +739,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -693,1 +742,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -703,1 +752,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -706,1 +755,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -722,1 +771,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -726,1 +775,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -743,1 +792,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -747,1 +796,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -758,1 +807,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -762,1 +811,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -779,1 +828,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -783,1 +832,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -801,1 +850,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -807,1 +856,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -828,1 +877,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -834,1 +883,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -849,1 +898,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -855,1 +904,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -876,1 +925,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -882,1 +931,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -896,1 +945,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -902,1 +951,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -917,1 +966,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -923,1 +972,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -938,1 +987,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -944,1 +993,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -960,1 +1009,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -966,1 +1015,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -974,0 +1023,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -979,1 +1032,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                AssertEquals(r[i], (int)(a[i+offs]));\n@@ -982,1 +1035,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -992,1 +1045,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -995,1 +1048,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1003,1 +1056,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                AssertEquals(r[i], (double)(a[i+offs]));\n@@ -1006,1 +1059,1 @@\n-            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1015,1 +1068,1 @@\n-            withToString(\"short[-i * 5]\", (int s) -> {\n+            withToString(\"Short[-i * 5]\", (int s) -> {\n@@ -1017,1 +1070,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1019,1 +1072,1 @@\n-            withToString(\"short[i * 5]\", (int s) -> {\n+            withToString(\"Short[i * 5]\", (int s) -> {\n@@ -1021,1 +1074,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1023,1 +1076,1 @@\n-            withToString(\"short[i + 1]\", (int s) -> {\n+            withToString(\"Short[i + 1]\", (int s) -> {\n@@ -1025,1 +1078,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1473,0 +1526,212 @@\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+    static short multiplicativeIdentity() {\n+        return (short)1;\n+    }\n+\n+    static short scalar_or(short a, short b) {\n+        return (short)(a | b);\n+    }\n+\n+    static short scalar_and(short a, short b) {\n+        return (short)(a & b);\n+    }\n+\n+    static short scalar_xor(short a, short b) {\n+        return (short)(a ^ b);\n+    }\n+\n+    static short scalar_add(short a, short b) {\n+        return (short)(a + b);\n+    }\n+\n+    static short scalar_sub(short a, short b) {\n+        return (short)(a - b);\n+    }\n+\n+    static short scalar_mul(short a, short b) {\n+        return (short)(a * b);\n+    }\n+\n+    static short scalar_min(short a, short b) {\n+        return (short)(Math.min(a, b));\n+    }\n+\n+    static short scalar_max(short a, short b) {\n+        return (short)(Math.max(a, b));\n+    }\n+\n+    static short scalar_div(short a, short b) {\n+        return (short)(a \/ b);\n+    }\n+\n+    static short scalar_fma(short a, short b, short c) {\n+        return (short)(Math.fma(a, b, c));\n+    }\n+\n+    static short scalar_abs(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    static short scalar_neg(short a) {\n+        return ((short)-a);\n+    }\n+\n+    static short scalar_sin(short a) {\n+        return (short)Math.sin((double)a);\n+    }\n+\n+    static short scalar_exp(short a) {\n+        return (short)Math.exp((double)a);\n+    }\n+\n+    static short scalar_log1p(short a) {\n+        return (short)Math.log1p((double)a);\n+    }\n+\n+    static short scalar_log(short a) {\n+        return (short)Math.log((double)a);\n+    }\n+\n+    static short scalar_log10(short a) {\n+        return (short)Math.log10((double)a);\n+    }\n+\n+    static short scalar_expm1(short a) {\n+        return (short)Math.expm1((double)a);\n+    }\n+\n+    static short scalar_cos(short a) {\n+        return (short)Math.cos((double)a);\n+    }\n+\n+    static short scalar_tan(short a) {\n+        return (short)Math.tan((double)a);\n+    }\n+\n+    static short scalar_sinh(short a) {\n+        return (short)Math.sinh((double)a);\n+    }\n+\n+    static short scalar_cosh(short a) {\n+        return (short)Math.cosh((double)a);\n+    }\n+\n+    static short scalar_tanh(short a) {\n+        return (short)Math.tanh((double)a);\n+    }\n+\n+    static short scalar_asin(short a) {\n+        return (short)Math.asin((double)a);\n+    }\n+\n+    static short scalar_acos(short a) {\n+        return (short)Math.acos((double)a);\n+    }\n+\n+    static short scalar_atan(short a) {\n+        return (short)Math.atan((double)a);\n+    }\n+\n+    static short scalar_cbrt(short a) {\n+        return (short)Math.cbrt((double)a);\n+    }\n+\n+    static short scalar_sqrt(short a) {\n+        return (short)Math.sqrt((double)a);\n+    }\n+\n+    static short scalar_hypot(short a, short b) {\n+        return (short)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static short scalar_pow(short a, short b) {\n+        return (short)Math.pow((double)a, (double)b);\n+    }\n+\n+    static short scalar_atan2(short a, short b) {\n+        return (short)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static short strict_scalar_sin(short a) {\n+        return (short)StrictMath.sin((double)a);\n+    }\n+\n+    static short strict_scalar_exp(short a) {\n+        return (short)StrictMath.exp((double)a);\n+    }\n+\n+    static short strict_scalar_log1p(short a) {\n+        return (short)StrictMath.log1p((double)a);\n+    }\n+\n+    static short strict_scalar_log(short a) {\n+        return (short)StrictMath.log((double)a);\n+    }\n+\n+    static short strict_scalar_log10(short a) {\n+        return (short)StrictMath.log10((double)a);\n+    }\n+\n+    static short strict_scalar_expm1(short a) {\n+        return (short)StrictMath.expm1((double)a);\n+    }\n+\n+    static short strict_scalar_cos(short a) {\n+        return (short)StrictMath.cos((double)a);\n+    }\n+\n+    static short strict_scalar_tan(short a) {\n+        return (short)StrictMath.tan((double)a);\n+    }\n+\n+    static short strict_scalar_sinh(short a) {\n+        return (short)StrictMath.sinh((double)a);\n+    }\n+\n+    static short strict_scalar_cosh(short a) {\n+        return (short)StrictMath.cosh((double)a);\n+    }\n+\n+    static short strict_scalar_tanh(short a) {\n+        return (short)StrictMath.tanh((double)a);\n+    }\n+\n+    static short strict_scalar_asin(short a) {\n+        return (short)StrictMath.asin((double)a);\n+    }\n+\n+    static short strict_scalar_acos(short a) {\n+        return (short)StrictMath.acos((double)a);\n+    }\n+\n+    static short strict_scalar_atan(short a) {\n+        return (short)StrictMath.atan((double)a);\n+    }\n+\n+    static short strict_scalar_cbrt(short a) {\n+        return (short)StrictMath.cbrt((double)a);\n+    }\n+\n+    static short strict_scalar_sqrt(short a) {\n+        return (short)StrictMath.sqrt((double)a);\n+    }\n+\n+    static short strict_scalar_hypot(short a, short b) {\n+        return (short)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static short strict_scalar_pow(short a, short b) {\n+        return (short)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static short strict_scalar_atan2(short a, short b) {\n+        return (short)StrictMath.atan2((double)a, (double)b);\n+    }\n+    static short additiveIdentity() {\n+        return (short)0;\n+    }\n+\n+\n@@ -1489,2 +1754,10 @@\n-    static short firstNonZero(short a, short b) {\n-        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    static short zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static short maxValue() {\n+        return Short.MAX_VALUE;\n+    }\n+\n+    static short minValue() {\n+        return Short.MIN_VALUE;\n@@ -1493,0 +1766,1 @@\n+\n@@ -1528,1 +1802,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1543,1 +1817,1 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n@@ -1549,1 +1823,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1555,1 +1829,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1570,1 +1844,1 @@\n-        Assert.assertEquals(asIntegral.species(), SPECIES);\n+        AssertEquals(asIntegral.species(), SPECIES);\n@@ -1573,1 +1847,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test\n@@ -1575,1 +1849,6 @@\n-        SPECIES.zero().viewAsFloatingLanes();\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        VectorSpecies<?> asFloatingSpecies = asFloating.species();\n+        Assert.assertNotEquals(asFloatingSpecies.elementType(), SPECIES.elementType());\n+        AssertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        AssertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n@@ -1600,1 +1879,1 @@\n-        return (short)(a + b);\n+        return (short)(scalar_add(a, b));\n@@ -1621,1 +1900,1 @@\n-        return (short)(a + b);\n+        return (short)(scalar_add(a, b));\n@@ -1678,1 +1957,1 @@\n-        return (short)(a - b);\n+        return (short)(scalar_sub(a, b));\n@@ -1699,1 +1978,1 @@\n-        return (short)(a - b);\n+        return (short)(scalar_sub(a, b));\n@@ -1756,1 +2035,1 @@\n-        return (short)(a * b);\n+        return (short)(scalar_mul(a, b));\n@@ -1777,1 +2056,1 @@\n-        return (short)(a * b);\n+        return (short)(scalar_mul(a, b));\n@@ -1924,1 +2203,1 @@\n-        return (short)((a)!=0?a:b);\n+        return (short)(firstNonZero(a, b));\n@@ -3031,2 +3310,0 @@\n-    static ShortVector bv_MIN = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3041,1 +3318,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec).intoArray(r, i);\n@@ -3048,2 +3325,0 @@\n-    static ShortVector bv_min = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3058,1 +3333,1 @@\n-                av.min(bv_min).intoArray(r, i);\n+                av.min(bcast_vec).intoArray(r, i);\n@@ -3065,2 +3340,0 @@\n-    static ShortVector bv_MIN_M = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3077,1 +3350,1 @@\n-                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MIN, bcast_vec, vmask).intoArray(r, i);\n@@ -3084,2 +3357,0 @@\n-    static ShortVector bv_MAX = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3094,1 +3365,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec).intoArray(r, i);\n@@ -3101,2 +3372,0 @@\n-    static ShortVector bv_max = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3111,1 +3380,1 @@\n-                av.max(bv_max).intoArray(r, i);\n+                av.max(bcast_vec).intoArray(r, i);\n@@ -3118,2 +3387,0 @@\n-    static ShortVector bv_MAX_M = ShortVector.broadcast(SPECIES, (short)10);\n-\n@@ -3130,1 +3397,1 @@\n-                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.MAX, bcast_vec, vmask).intoArray(r, i);\n@@ -3138,1 +3405,1 @@\n-        return (short)(Math.min(a, b));\n+        return (short)(scalar_min(a, b));\n@@ -3159,1 +3426,1 @@\n-        return (short)(Math.min(a, b));\n+        return (short)(scalar_min(a, b));\n@@ -3178,1 +3445,1 @@\n-        return (short)(Math.max(a, b));\n+        return (short)(scalar_max(a, b));\n@@ -3199,1 +3466,1 @@\n-        return (short)(Math.max(a, b));\n+        return (short)(scalar_max(a, b));\n@@ -3567,1 +3834,1 @@\n-            res &= a[i];\n+            res = scalar_and(res, a[i]);\n@@ -3576,1 +3843,1 @@\n-            res &= ANDReduce(a, i);\n+            res = scalar_and(res, ANDReduce(a, i));\n@@ -3599,1 +3866,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND));\n@@ -3611,1 +3878,1 @@\n-                res &= a[i];\n+                res = scalar_and(res, a[i]);\n@@ -3620,1 +3887,1 @@\n-            res &= ANDReduceMasked(a, i, mask);\n+            res = scalar_and(res, ANDReduceMasked(a, i, mask));\n@@ -3645,1 +3912,1 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                ra = scalar_and(ra, av.reduceLanes(VectorOperators.AND, vmask));\n@@ -3656,1 +3923,1 @@\n-            res |= a[i];\n+            res = scalar_or(res, a[i]);\n@@ -3665,1 +3932,1 @@\n-            res |= ORReduce(a, i);\n+            res = scalar_or(res, ORReduce(a, i));\n@@ -3688,1 +3955,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR));\n@@ -3700,1 +3967,1 @@\n-                res |= a[i];\n+                res = scalar_or(res, a[i]);\n@@ -3709,1 +3976,1 @@\n-            res |= ORReduceMasked(a, i, mask);\n+            res = scalar_or(res, ORReduceMasked(a, i, mask));\n@@ -3734,1 +4001,1 @@\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                ra = scalar_or(ra, av.reduceLanes(VectorOperators.OR, vmask));\n@@ -3745,1 +4012,1 @@\n-            res ^= a[i];\n+            res = scalar_xor(res, a[i]);\n@@ -3754,1 +4021,1 @@\n-            res ^= XORReduce(a, i);\n+            res = scalar_xor(res, XORReduce(a, i));\n@@ -3777,1 +4044,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR));\n@@ -3789,1 +4056,1 @@\n-                res ^= a[i];\n+                res = scalar_xor(res, a[i]);\n@@ -3798,1 +4065,1 @@\n-            res ^= XORReduceMasked(a, i, mask);\n+            res = scalar_xor(res, XORReduceMasked(a, i, mask));\n@@ -3823,1 +4090,1 @@\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                ra = scalar_xor(ra, av.reduceLanes(VectorOperators.XOR, vmask));\n@@ -3832,1 +4099,1 @@\n-        short res = 0;\n+        short res = additiveIdentity();\n@@ -3834,1 +4101,1 @@\n-            res += a[i];\n+            res = scalar_add(res, a[i]);\n@@ -3841,1 +4108,1 @@\n-        short res = 0;\n+        short res = additiveIdentity();\n@@ -3843,1 +4110,1 @@\n-            res += ADDReduce(a, i);\n+            res = scalar_add(res, ADDReduce(a, i));\n@@ -3853,1 +4120,1 @@\n-        short ra = 0;\n+        short ra = additiveIdentity();\n@@ -3863,1 +4130,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3866,1 +4133,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD));\n@@ -3875,1 +4142,1 @@\n-        short res = 0;\n+        short res = additiveIdentity();\n@@ -3878,1 +4145,1 @@\n-                res += a[i];\n+                res = scalar_add(res, a[i]);\n@@ -3885,1 +4152,1 @@\n-        short res = 0;\n+        short res = additiveIdentity();\n@@ -3887,1 +4154,1 @@\n-            res += ADDReduceMasked(a, i, mask);\n+            res = scalar_add(res, ADDReduceMasked(a, i, mask));\n@@ -3899,1 +4166,1 @@\n-        short ra = 0;\n+        short ra = additiveIdentity();\n@@ -3909,1 +4176,1 @@\n-            ra = 0;\n+            ra = additiveIdentity();\n@@ -3912,1 +4179,1 @@\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                ra = scalar_add(ra, av.reduceLanes(VectorOperators.ADD, vmask));\n@@ -3921,1 +4188,1 @@\n-        short res = 1;\n+        short res = multiplicativeIdentity();\n@@ -3923,1 +4190,1 @@\n-            res *= a[i];\n+            res = scalar_mul(res, a[i]);\n@@ -3930,1 +4197,1 @@\n-        short res = 1;\n+        short res = multiplicativeIdentity();\n@@ -3932,1 +4199,1 @@\n-            res *= MULReduce(a, i);\n+            res = scalar_mul(res, MULReduce(a, i));\n@@ -3942,1 +4209,1 @@\n-        short ra = 1;\n+        short ra = multiplicativeIdentity();\n@@ -3952,1 +4219,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -3955,1 +4222,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL));\n@@ -3964,1 +4231,1 @@\n-        short res = 1;\n+        short res = multiplicativeIdentity();\n@@ -3967,1 +4234,1 @@\n-                res *= a[i];\n+                res = scalar_mul(res, a[i]);\n@@ -3974,1 +4241,1 @@\n-        short res = 1;\n+        short res = multiplicativeIdentity();\n@@ -3976,1 +4243,1 @@\n-            res *= MULReduceMasked(a, i, mask);\n+            res = scalar_mul(res, MULReduceMasked(a, i, mask));\n@@ -3988,1 +4255,1 @@\n-        short ra = 1;\n+        short ra = multiplicativeIdentity();\n@@ -3998,1 +4265,1 @@\n-            ra = 1;\n+            ra = multiplicativeIdentity();\n@@ -4001,1 +4268,1 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                ra = scalar_mul(ra, av.reduceLanes(VectorOperators.MUL, vmask));\n@@ -4010,1 +4277,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4012,1 +4279,1 @@\n-            res = (short) Math.min(res, a[i]);\n+            res = scalar_min(res, a[i]);\n@@ -4019,1 +4286,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4021,1 +4288,1 @@\n-            res = (short) Math.min(res, MINReduce(a, i));\n+            res = scalar_min(res, MINReduce(a, i));\n@@ -4031,1 +4298,1 @@\n-        short ra = Short.MAX_VALUE;\n+        short ra = maxValue();\n@@ -4041,1 +4308,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = maxValue();\n@@ -4044,1 +4311,1 @@\n-                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN));\n@@ -4053,1 +4320,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4056,1 +4323,1 @@\n-                res = (short) Math.min(res, a[i]);\n+                res = scalar_min(res, a[i]);\n@@ -4063,1 +4330,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4065,1 +4332,1 @@\n-            res = (short) Math.min(res, MINReduceMasked(a, i, mask));\n+            res = scalar_min(res, MINReduceMasked(a, i, mask));\n@@ -4077,1 +4344,1 @@\n-        short ra = Short.MAX_VALUE;\n+        short ra = maxValue();\n@@ -4087,1 +4354,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = maxValue();\n@@ -4090,1 +4357,1 @@\n-                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                ra = scalar_min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n@@ -4099,1 +4366,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4101,1 +4368,1 @@\n-            res = (short) Math.max(res, a[i]);\n+            res = scalar_max(res, a[i]);\n@@ -4108,1 +4375,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4110,1 +4377,1 @@\n-            res = (short) Math.max(res, MAXReduce(a, i));\n+            res = scalar_max(res, MAXReduce(a, i));\n@@ -4120,1 +4387,1 @@\n-        short ra = Short.MIN_VALUE;\n+        short ra = minValue();\n@@ -4130,1 +4397,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = minValue();\n@@ -4133,1 +4400,1 @@\n-                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX));\n@@ -4142,1 +4409,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4145,1 +4412,1 @@\n-                res = (short) Math.max(res, a[i]);\n+                res = scalar_max(res, a[i]);\n@@ -4152,1 +4419,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4154,1 +4421,1 @@\n-            res = (short) Math.max(res, MAXReduceMasked(a, i, mask));\n+            res = scalar_max(res, MAXReduceMasked(a, i, mask));\n@@ -4166,1 +4433,1 @@\n-        short ra = Short.MIN_VALUE;\n+        short ra = minValue();\n@@ -4176,1 +4443,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = minValue();\n@@ -4179,1 +4446,1 @@\n-                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                ra = scalar_max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n@@ -4188,1 +4455,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4197,1 +4464,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4209,1 +4476,1 @@\n-        short ra = Short.MAX_VALUE;\n+        short ra = maxValue();\n@@ -4219,1 +4486,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = maxValue();\n@@ -4231,1 +4498,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4241,1 +4508,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = maxValue();\n@@ -4255,1 +4522,1 @@\n-        short ra = Short.MAX_VALUE;\n+        short ra = maxValue();\n@@ -4265,1 +4532,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = maxValue();\n@@ -4277,1 +4544,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4286,1 +4553,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4298,1 +4565,1 @@\n-        short ra = Short.MIN_VALUE;\n+        short ra = minValue();\n@@ -4308,1 +4575,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = minValue();\n@@ -4320,1 +4587,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4330,1 +4597,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = minValue();\n@@ -4344,1 +4611,1 @@\n-        short ra = Short.MIN_VALUE;\n+        short ra = minValue();\n@@ -4354,1 +4621,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = minValue();\n@@ -4366,1 +4633,1 @@\n-        short res = (short) 0;\n+        short res = zeroValue();\n@@ -4375,1 +4642,1 @@\n-        short res = (short) 0;\n+        short res = zeroValue();\n@@ -4387,1 +4654,1 @@\n-        short ra = (short) 0;\n+        short ra = zeroValue();\n@@ -4397,1 +4664,1 @@\n-            ra = (short) 0;\n+            ra = zeroValue();\n@@ -4409,1 +4676,1 @@\n-        short res = (short) 0;\n+        short res = zeroValue();\n@@ -4419,1 +4686,1 @@\n-        short res = (short) 0;\n+        short res = zeroValue();\n@@ -4433,1 +4700,1 @@\n-        short ra = (short) 0;\n+        short ra = zeroValue();\n@@ -4443,1 +4710,1 @@\n-            ra = (short) 0;\n+            ra = zeroValue();\n@@ -4503,1 +4770,1 @@\n-        short res = 0;\n+        short res = zeroValue();\n@@ -4512,1 +4779,1 @@\n-        short res = 0;\n+        short res = zeroValue();\n@@ -4524,1 +4791,1 @@\n-        short ra = 0;\n+        short ra = zeroValue();\n@@ -4534,1 +4801,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4546,1 +4813,1 @@\n-        short res = 0;\n+        short res = zeroValue();\n@@ -4556,1 +4823,1 @@\n-        short res = 0;\n+        short res = zeroValue();\n@@ -4569,1 +4836,1 @@\n-        short ra = 0;\n+        short ra = zeroValue();\n@@ -4579,1 +4846,1 @@\n-            ra = 0;\n+            ra = zeroValue();\n@@ -4624,1 +4891,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n@@ -4644,1 +4911,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n@@ -4665,1 +4932,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n@@ -4685,1 +4952,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n@@ -4704,1 +4971,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4723,1 +4990,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -4746,1 +5013,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -4765,1 +5032,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -4788,1 +5055,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -4807,1 +5074,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4826,1 +5093,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -4849,1 +5116,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -4868,1 +5135,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -4891,1 +5158,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -4910,1 +5177,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -4933,1 +5200,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -4952,1 +5219,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -4975,1 +5242,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -4994,1 +5261,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n@@ -5017,1 +5284,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n@@ -5036,1 +5303,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n@@ -5059,1 +5326,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -5078,1 +5345,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n@@ -5101,1 +5368,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n@@ -5120,1 +5387,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n@@ -5143,1 +5410,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n@@ -5160,1 +5427,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n@@ -5180,1 +5447,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j], b[i])));\n@@ -5196,1 +5463,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < (short)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], (short)((long)b[i])));\n@@ -5216,1 +5483,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < (short)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (lt(a[i + j],(short)((long)b[i]))));\n@@ -5232,1 +5499,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n@@ -5252,1 +5519,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j], b[i])));\n@@ -5268,1 +5535,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == (short)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], (short)((long)b[i])));\n@@ -5288,1 +5555,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == (short)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && (eq(a[i + j],(short)((long)b[i]))));\n@@ -5569,1 +5836,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n@@ -6000,1 +6267,1 @@\n-        return (short)(-((short)a));\n+        return (short)(scalar_neg((short)a));\n@@ -6004,1 +6271,1 @@\n-        return (short)(-((short)a));\n+        return (short)(scalar_neg((short)a));\n@@ -6056,1 +6323,1 @@\n-        return (short)(Math.abs((short)a));\n+        return (short)(scalar_abs((short)a));\n@@ -6060,1 +6327,1 @@\n-        return (short)(Math.abs((short)a));\n+        return (short)(scalar_abs((short)a));\n@@ -6400,1 +6667,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n@@ -6416,1 +6683,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n@@ -6512,1 +6779,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6553,1 +6820,1 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n@@ -6656,1 +6923,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -6684,1 +6951,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -6698,1 +6965,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -6895,1 +7162,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -6922,1 +7189,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6936,1 +7203,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -6958,1 +7225,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -6966,1 +7233,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -6973,1 +7240,1 @@\n-        Assert.assertEquals(elsize, Short.SIZE);\n+        AssertEquals(elsize, Short.SIZE);\n@@ -6992,1 +7259,1 @@\n-    static void ElementTypeShortMaxVectorTestsSmokeTest() {\n+    static void ShortShortMaxVectorTestsSmokeTest() {\n@@ -7027,1 +7294,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":598,"deletions":331,"binary":false,"changes":929,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Vector128ConversionTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Vector256ConversionTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Vector512ConversionTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Vector64ConversionTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -382,0 +382,1 @@\n+\n@@ -383,1 +384,1 @@\n-  echo \"Generating saturating reduction op $1 ($2)...\"\n+  echo \"Generating saturating reduction op $1 ($2) ($4)...\"\n@@ -433,4 +434,4 @@\n-gen_binary_alu_op \"ADD+add+withMask\" \"a + b\"\n-gen_binary_alu_op \"SUB+sub+withMask\" \"a - b\"\n-gen_binary_alu_op \"MUL+mul+withMask\" \"a \\* b\"\n-gen_binary_alu_op \"DIV+div+withMask\" \"a \\\/ b\" \"FP\"\n+gen_binary_alu_op \"ADD+add+withMask\" \"scalar_add(a, b)\"\n+gen_binary_alu_op \"SUB+sub+withMask\" \"scalar_sub(a, b)\"\n+gen_binary_alu_op \"MUL+mul+withMask\" \"scalar_mul(a, b)\"\n+gen_binary_alu_op \"DIV+div+withMask\" \"scalar_div(a, b)\" \"FP\"\n@@ -439,1 +440,1 @@\n-gen_binary_alu_op \"FIRST_NONZERO\" \"{#if[FP]?Double.doubleToLongBits}(a)!=0?a:b\"\n+gen_binary_alu_op \"FIRST_NONZERO\" \"firstNonZero(a, b)\"\n@@ -448,4 +449,4 @@\n-gen_binary_alu_bcst_op \"add+withMask\" \"a + b\"\n-gen_binary_alu_bcst_op \"sub+withMask\" \"a - b\"\n-gen_binary_alu_bcst_op \"mul+withMask\" \"a \\* b\"\n-gen_binary_alu_bcst_op \"div+withMask\" \"a \\\/ b\" \"FP\"\n+gen_binary_alu_bcst_op \"add+withMask\" \"scalar_add(a, b)\"\n+gen_binary_alu_bcst_op \"sub+withMask\" \"scalar_sub(a, b)\"\n+gen_binary_alu_bcst_op \"mul+withMask\" \"scalar_mul(a, b)\"\n+gen_binary_alu_bcst_op \"div+withMask\" \"scalar_div(a, b)\" \"FP\"\n@@ -457,1 +458,1 @@\n-gen_binary_alu_bcst_long_op \"ADD\"    \"a + b\"\n+gen_binary_alu_bcst_long_op \"ADD\"    \"scalar_add(a, b)\"\n@@ -493,2 +494,2 @@\n-gen_binary_alu_mem_op \"MIN+min+withMask\", \"Math.min(a, b)\"\n-gen_binary_alu_mem_op \"MAX+max+withMask\", \"Math.max(a, b)\"\n+gen_binary_alu_mem_op \"MIN+min+withMask\", \"scalar_max(a, b)\"\n+gen_binary_alu_mem_op \"MAX+max+withMask\", \"scalar_min(a, b)\"\n@@ -497,2 +498,2 @@\n-gen_binary_op_no_masked \"MIN+min\" \"Math.min(a, b)\"\n-gen_binary_op_no_masked \"MAX+max\" \"Math.max(a, b)\"\n+gen_binary_op_no_masked \"MIN+min\" \"scalar_min(a, b)\"\n+gen_binary_op_no_masked \"MAX+max\" \"scalar_max(a, b)\"\n@@ -505,2 +506,2 @@\n-gen_binary_bcst_op_no_masked \"MIN+min\" \"Math.min(a, b)\"\n-gen_binary_bcst_op_no_masked \"MAX+max\" \"Math.max(a, b)\"\n+gen_binary_bcst_op_no_masked \"MIN+min\" \"scalar_min(a, b)\"\n+gen_binary_bcst_op_no_masked \"MAX+max\" \"scalar_max(a, b)\"\n@@ -510,10 +511,10 @@\n-gen_reduction_op \"AND\" \"\\&\" \"BITWISE\" \"-1\"\n-gen_reduction_op \"OR\" \"|\" \"BITWISE\" \"0\"\n-gen_reduction_op \"XOR\" \"^\" \"BITWISE\" \"0\"\n-gen_reduction_op \"ADD\" \"+\" \"\" \"0\"\n-gen_reduction_op \"MUL\" \"*\" \"\" \"1\"\n-gen_reduction_op_func \"MIN\" \"(\\$type\\$) Math.min\" \"\" \"\\$Wideboxtype\\$.\\$MaxValue\\$\"\n-gen_reduction_op_func \"MAX\" \"(\\$type\\$) Math.max\" \"\" \"\\$Wideboxtype\\$.\\$MinValue\\$\"\n-gen_reduction_op_func \"UMIN\" \"(\\$type\\$) VectorMath.minUnsigned\" \"BITWISE\" \"\\$Wideboxtype\\$.\\$MaxValue\\$\"\n-gen_reduction_op_func \"UMAX\" \"(\\$type\\$) VectorMath.maxUnsigned\" \"BITWISE\" \"\\$Wideboxtype\\$.\\$MinValue\\$\"\n-gen_reduction_op_func \"FIRST_NONZERO\" \"firstNonZero\" \"\" \"(\\$type\\$) 0\"\n+gen_reduction_op \"AND\" \"scalar_and\" \"BITWISE\" \"-1\"\n+gen_reduction_op \"OR\" \"scalar_or\" \"BITWISE\" \"0\"\n+gen_reduction_op \"XOR\" \"scalar_xor\" \"BITWISE\" \"0\"\n+gen_reduction_op \"ADD\" \"scalar_add\" \"\" \"additiveIdentity()\"\n+gen_reduction_op \"MUL\" \"scalar_mul\" \"\" \"multiplicativeIdentity()\"\n+gen_reduction_op_func \"MIN\" \"scalar_min\" \"\" \"maxValue\"\n+gen_reduction_op_func \"MAX\" \"scalar_max\" \"\" \"minValue\"\n+gen_reduction_op_func \"UMIN\" \"(\\$type\\$) VectorMath.minUnsigned\" \"BITWISE\" \"maxValue\"\n+gen_reduction_op_func \"UMAX\" \"(\\$type\\$) VectorMath.maxUnsigned\" \"BITWISE\" \"minValue\"\n+gen_reduction_op_func \"FIRST_NONZERO\" \"firstNonZero\" \"\" \"zeroValue\"\n@@ -526,1 +527,1 @@\n-gen_saturating_reduction_op \"SUADD\" \"(\\$type\\$) VectorMath.addSaturatingUnsigned\" \"BITWISE\" \"0\"\n+gen_saturating_reduction_op \"SUADD\" \"(\\$type\\$) VectorMath.addSaturatingUnsigned\" \"BITWISE\" \"zeroValue\"\n@@ -534,3 +535,3 @@\n-gen_op_tmpl $test_template \"IS_FINITE\" \"\\$Boxtype\\$.isFinite(a)\" \"FP\"\n-gen_op_tmpl $test_template \"IS_NAN\" \"\\$Boxtype\\$.isNaN(a)\" \"FP\"\n-gen_op_tmpl $test_template \"IS_INFINITE\" \"\\$Boxtype\\$.isInfinite(a)\" \"FP\"\n+gen_op_tmpl $test_template \"IS_FINITE\" \"isFinite(a)\" \"FP\"\n+gen_op_tmpl $test_template \"IS_NAN\" \"isNaN(a)\" \"FP\"\n+gen_op_tmpl $test_template \"IS_INFINITE\" \"isInfinite(a)\" \"FP\"\n@@ -552,2 +553,2 @@\n-gen_compare_bcst_op \"LT\" \"<\"\n-gen_compare_bcst_op \"EQ\" \"==\"\n+gen_compare_bcst_op \"LT\" \"lt\"\n+gen_compare_bcst_op \"EQ\" \"eq\"\n@@ -584,19 +585,19 @@\n-gen_op_tmpl $unary_math_template \"SIN\" \"Math.sin((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"EXP\" \"Math.exp((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"LOG1P\" \"Math.log1p((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"LOG\" \"Math.log((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"LOG10\" \"Math.log10((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"EXPM1\" \"Math.expm1((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"COS\" \"Math.cos((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"TAN\" \"Math.tan((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"SINH\" \"Math.sinh((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"COSH\" \"Math.cosh((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"TANH\" \"Math.tanh((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"ASIN\" \"Math.asin((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"ACOS\" \"Math.acos((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"ATAN\" \"Math.atan((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"CBRT\" \"Math.cbrt((double)a)\" \"FP\"\n-gen_op_tmpl $binary_math_template \"HYPOT\" \"Math.hypot((double)a, (double)b)\" \"FP\"\n-gen_op_tmpl $binary_math_template \"POW+pow\" \"Math.pow((double)a, (double)b)\" \"FP\"\n-gen_op_tmpl $binary_math_template \"ATAN2\" \"Math.atan2((double)a, (double)b)\" \"FP\"\n-gen_op_tmpl $binary_math_broadcast_template \"POW+pow\" \"Math.pow((double)a, (double)b)\" \"FP\"\n+gen_op_tmpl $unary_math_template \"SIN\" \"scalar_sin(a)\" \"FP\"\n+gen_op_tmpl $unary_math_template \"EXP\" \"scalar_exp(a)\" \"FP\"\n+gen_op_tmpl $unary_math_template \"LOG1P\" \"scalar_log1p(a)\" \"FP\"\n+gen_op_tmpl $unary_math_template \"LOG\" \"scalar_log(a)\" \"FP\"\n+gen_op_tmpl $unary_math_template \"LOG10\" \"scalar_log10(a)\" \"FP\"\n+gen_op_tmpl $unary_math_template \"EXPM1\" \"scalar_expm1(a)\" \"FP\"\n+gen_op_tmpl $unary_math_template \"COS\" \"scalar_cos(a)\" \"FP\"\n+gen_op_tmpl $unary_math_template \"TAN\" \"scalar_tan(a)\" \"FP\"\n+gen_op_tmpl $unary_math_template \"SINH\" \"scalar_sinh(a)\" \"FP\"\n+gen_op_tmpl $unary_math_template \"COSH\" \"scalar_cosh(a)\" \"FP\"\n+gen_op_tmpl $unary_math_template \"TANH\" \"scalar_tanh(a)\" \"FP\"\n+gen_op_tmpl $unary_math_template \"ASIN\" \"scalar_asin(a)\" \"FP\"\n+gen_op_tmpl $unary_math_template \"ACOS\" \"scalar_acos(a)\" \"FP\"\n+gen_op_tmpl $unary_math_template \"ATAN\" \"scalar_atan(a)\" \"FP\"\n+gen_op_tmpl $unary_math_template \"CBRT\" \"scalar_cbrt(a)\" \"FP\"\n+gen_op_tmpl $binary_math_template \"HYPOT\" \"scalar_hypot(a, b)\" \"FP\"\n+gen_op_tmpl $binary_math_template \"POW+pow\" \"scalar_pow(a, b)\" \"FP\"\n+gen_op_tmpl $binary_math_template \"ATAN2\" \"scalar_atan2(a, b)\" \"FP\"\n+gen_op_tmpl $binary_math_broadcast_template \"POW+pow\" \"scalar_pow(a, b)\" \"FP\"\n@@ -605,1 +606,1 @@\n-gen_ternary_alu_op \"FMA+fma\" \"Math.fma(a, b, c)\" \"FP\"\n+gen_ternary_alu_op \"FMA+fma\" \"scalar_fma(a, b, c)\" \"FP\"\n@@ -613,2 +614,2 @@\n-gen_unary_alu_op \"NEG+neg\" \"-((\\$type\\$)a)\"\n-gen_unary_alu_op \"ABS+abs\" \"Math.abs((\\$type\\$)a)\"\n+gen_unary_alu_op \"NEG+neg\" \"scalar_neg((\\$type\\$)a)\"\n+gen_unary_alu_op \"ABS+abs\" \"scalar_abs((\\$type\\$)a)\"\n@@ -617,1 +618,1 @@\n-gen_unary_alu_op \"SQRT+sqrt\" \"Math.sqrt((double)a)\" \"FP\"\n+gen_unary_alu_op \"SQRT+sqrt\" \"scalar_sqrt(a)\" \"FP\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":58,"deletions":57,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,3 @@\n+# Nomenclature \n+#  - type : refers to vector primitive lane type or carrier type.\n+#  - Type : refers to vector box lane type.\n@@ -55,1 +58,1 @@\n-for type in byte short int long float double\n+for type in byte short int long float double halffloat\n@@ -59,1 +62,1 @@\n-  args=\"-K$type -Dtype=$type -DType=$Type -DTYPE=$TYPE\"\n+  args=\"-K$type -DType=$Type -DTYPE=$TYPE\"\n@@ -61,0 +64,1 @@\n+  VectorPrefix=$Type\n@@ -67,0 +71,1 @@\n+  fpkind=BITWISE\n@@ -102,0 +107,1 @@\n+      fpkind=FP32\n@@ -111,0 +117,1 @@\n+      fpkind=FP64\n@@ -118,0 +125,12 @@\n+    halffloat)\n+      kind=FP\n+      fpkind=FP16\n+      bitstype=short\n+      type=short\n+      Bitstype=Short\n+      Boxbitstype=Short\n+      Wideboxtype=Float16\n+      MaxValue=POSITIVE_INFINITY\n+      MinValue=NEGATIVE_INFINITY\n+      Type=Float16\n+      ;;\n@@ -120,1 +139,1 @@\n-  args=\"$args -K$kind -K$Type -DBoxtype=$Boxtype -DWideboxtype=$Wideboxtype -DMaxValue=$MaxValue -DMinValue=$MinValue\"\n+  args=\"$args -Dtype=$type -K$kind -K$fpkind -K$Type -DBoxtype=$Boxtype -DWideboxtype=$Wideboxtype -DMaxValue=$MaxValue -DMinValue=$MinValue\"\n@@ -124,3 +143,3 @@\n-  abstractvectortype=${typeprefix}${Type}Vector\n-  abstractvectorteststype=${typeprefix}${Type}VectorTests\n-  abstractbitsvectortype=${typeprefix}${Bitstype}Vector\n+  abstractvectortype=${typeprefix}${VectorPrefix}Vector\n+  abstractvectorteststype=${typeprefix}${VectorPrefix}VectorTests\n+  abstractbitsvectortype=${typeprefix}${VectorPrefixe}Vector\n@@ -136,3 +155,3 @@\n-    vectortype=${typeprefix}${Type}${bits}Vector\n-    vectorteststype=${typeprefix}${Type}${bits}VectorTests\n-    vectorbenchtype=${typeprefix}${Type}${bits}Vector\n+    vectortype=${typeprefix}${VectorPrefix}${bits}Vector\n+    vectorteststype=${typeprefix}${VectorPrefix}${bits}VectorTests\n+    vectorbenchtype=${typeprefix}${VectorPrefix}${bits}Vector\n@@ -211,3 +230,3 @@\n-    vectortype=${typeprefix}${Type}${bits}Vector\n-    vectorteststype=${typeprefix}${Type}${bits}VectorLoadStoreTests\n-    vectorbenchtype=${typeprefix}${Type}${bits}VectorLoadStore\n+    vectortype=${typeprefix}${VectorPrefix}${bits}Vector\n+    vectorteststype=${typeprefix}${VectorPrefix}${bits}VectorLoadStoreTests\n+    vectorbenchtype=${typeprefix}${VectorPrefix}${bits}VectorLoadStore\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-tests.sh","additions":32,"deletions":13,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-                av.lanewise(VectorOperators.[[TEST]], bv_[[TEST]]_M, vmask).intoArray(r, i);\n+                av.lanewise(VectorOperators.[[TEST]], bcast_vec, vmask).intoArray(r, i);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Binary-Masked-mem-op.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n-                av.lanewise(VectorOperators.[[TEST]], bv_[[TEST]]).intoArray(r, i);\n+                av.lanewise(VectorOperators.[[TEST]], bcast_vec).intoArray(r, i);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Binary-mem-op.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-        $type$ ra = [[TEST_INIT]];\n+        $type$ ra = [[TEST_INIT]]();\n@@ -15,1 +15,1 @@\n-            ra = [[TEST_INIT]];\n+            ra = [[TEST_INIT]]();\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Reduction-Masked-op-func.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -18,1 +18,1 @@\n-                ra [[TEST_OP]]= av.reduceLanes(VectorOperators.[[TEST]], vmask);\n+                ra = [[TEST_OP]](ra, av.reduceLanes(VectorOperators.[[TEST]], vmask));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Reduction-Masked-op.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-        $type$ ra = [[TEST_INIT]];\n+        $type$ ra = [[TEST_INIT]]();\n@@ -13,1 +13,1 @@\n-            ra = [[TEST_INIT]];\n+            ra = [[TEST_INIT]]();\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Reduction-op-func.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -16,1 +16,1 @@\n-                ra [[TEST_OP]]= av.reduceLanes(VectorOperators.[[TEST]]);\n+                ra = [[TEST_OP]](ra, av.reduceLanes(VectorOperators.[[TEST]]));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Reduction-op.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-        $type$ ra = [[TEST_INIT]];\n+        $type$ ra = [[TEST_INIT]]();\n@@ -15,1 +15,1 @@\n-            ra = [[TEST_INIT]];\n+            ra = [[TEST_INIT]]();\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-SaturatingReduction-Masked-op.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-        $type$ ra = [[TEST_INIT]];\n+        $type$ ra = [[TEST_INIT]]();\n@@ -13,1 +13,1 @@\n-            ra = [[TEST_INIT]];\n+            ra = [[TEST_INIT]]();\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-SaturatingReduction-op.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,2 +2,0 @@\n-    static $abstractvectortype$ bv_[[TEST]]_M = $abstractvectortype$.broadcast(SPECIES, ($type$)10);\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Binary-Masked-mem-op.template","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,2 +2,0 @@\n-    static $abstractvectortype$ bv_[[TEST]] = $abstractvectortype$.broadcast(SPECIES, ($type$)10);\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Binary-mem-op.template","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n-        return ($type$)(Strict[[TEST_OP]]);\n+        return ($type$)(strict_[[TEST_OP]]);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Binary-op-math.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -13,1 +13,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] [[TEST_OP]] b[i]);\n+                AssertEquals(mv.laneIsSet(j), [[TEST_OP]](a[i + j], b[i]));\n@@ -33,1 +33,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] [[TEST_OP]] b[i]));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && ([[TEST_OP]](a[i + j], b[i])));\n@@ -50,1 +50,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] [[TEST_OP]] ($type$)((long)b[i]));\n+                AssertEquals(mv.laneIsSet(j), [[TEST_OP]](a[i + j], ($type$)((long)b[i])));\n@@ -70,1 +70,1 @@\n-                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] [[TEST_OP]] ($type$)((long)b[i])));\n+                AssertEquals(mv.laneIsSet(j), mask[j] && ([[TEST_OP]](a[i + j],($type$)((long)b[i]))));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Compare-Broadcast.template","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -19,1 +19,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && [[TEST_OP]](a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), mask[j] && [[TEST_OP]](a[i + j], b[i + j]));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Compare-Masked.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), [[TEST_OP]](a[i + j], b[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), [[TEST_OP]](a[i + j], b[i + j]));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Compare.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -13,1 +13,5 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+#if[FP16]\n+                AssertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+#else[FP16]\n+                AssertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+#end[FP16]\n@@ -29,1 +33,5 @@\n-                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+#if[FP16]\n+                AssertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+#else[FP16]\n+                AssertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+#end[FP16]\n@@ -126,0 +134,3 @@\n+#if[FP16]\n+            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+#else[FP16]\n@@ -127,0 +138,1 @@\n+#end[FP16]\n@@ -135,0 +147,3 @@\n+#if[FP16]\n+            res = Float.floatToFloat16(Float.float16ToFloat((short)res) + Float.float16ToFloat((short)ADDReduceLong(a, i)));\n+#else[FP16]\n@@ -136,0 +151,1 @@\n+#end[FP16]\n@@ -153,1 +169,4 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n+#if[FP16]\n+            ra = (long)(Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16((short)ra), Float16.shortBitsToFloat16((short)r[i]))));\n+#else[FP16]\n@@ -155,0 +174,1 @@\n+#end[FP16]\n@@ -165,0 +185,3 @@\n+#if[FP16]\n+                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+#else[FP16]\n@@ -166,0 +189,1 @@\n+#end[FP16]\n@@ -174,0 +198,3 @@\n+#if[FP16]\n+            res = Float.floatToFloat16(Float.float16ToFloat((short)res) + Float.float16ToFloat((short)ADDReduceLongMasked(a, i, mask)));\n+#else[FP16]\n@@ -175,0 +202,1 @@\n+#end[FP16]\n@@ -194,1 +222,4 @@\n-        for (int i = 0; i < a.length; i ++) {\n+        for (int i = 0; i < a.length; i++) {\n+#if[FP16]\n+            ra = (long)(Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16((short)ra), Float16.shortBitsToFloat16((short)r[i]))));\n+#else[FP16]\n@@ -196,0 +227,1 @@\n+#end[FP16]\n@@ -353,1 +385,1 @@\n-            Assert.assertEquals(length, SPECIES.length());\n+            AssertEquals(length, SPECIES.length());\n@@ -381,1 +413,1 @@\n-            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n@@ -395,1 +427,1 @@\n-            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+            AssertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n@@ -592,1 +624,1 @@\n-                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                    AssertEquals(rmask.laneIsSet(j), j < trueCount);\n@@ -613,1 +645,1 @@\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        AssertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -637,1 +669,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -651,1 +683,1 @@\n-                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+                AssertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n@@ -673,1 +705,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -681,1 +713,1 @@\n-        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+        AssertEquals(actualLoopBound, expectedLoopBound);\n@@ -688,1 +720,1 @@\n-        Assert.assertEquals(elsize, $Wideboxtype$.SIZE);\n+        AssertEquals(elsize, $Wideboxtype$.SIZE);\n@@ -702,1 +734,1 @@\n-        VectorSpecies species = vsh.withLanes($type$.class);\n+        VectorSpecies species = vsh.withLanes({#if[FP16]?Float16.class:$type$.class});\n@@ -707,1 +739,1 @@\n-    static void ElementType$vectorteststype$SmokeTest() {\n+    static void $Type$$vectorteststype$SmokeTest() {\n@@ -709,1 +741,1 @@\n-        assert(av.species().elementType() == $type$.class);\n+        assert(av.species().elementType() == {#if[FP16]?Float16.class:$type$.class});\n@@ -727,1 +759,1 @@\n-        VectorSpecies species = av.species().withLanes($type$.class);\n+        VectorSpecies species = av.species().withLanes({#if[FP16]?Float16.class:$type$.class});\n@@ -742,1 +774,1 @@\n-          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+          AssertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Miscellaneous.template","additions":51,"deletions":19,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-        $type$ res = [[TEST_INIT]];\n+        $type$ res = [[TEST_INIT]]();\n@@ -13,1 +13,1 @@\n-        $type$ res = [[TEST_INIT]];\n+        $type$ res = [[TEST_INIT]]();\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Reduction-Scalar-Masked-op-func.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n-                res [[TEST_OP]]= a[i];\n+                res = [[TEST_OP]](res, a[i]);\n@@ -15,1 +15,1 @@\n-            res [[TEST_OP]]= [[TEST]]ReduceMasked(a, i, mask);\n+            res = [[TEST_OP]](res, [[TEST]]ReduceMasked(a, i, mask));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Reduction-Scalar-Masked-op.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-        $type$ res = [[TEST_INIT]];\n+        $type$ res = [[TEST_INIT]]();\n@@ -12,1 +12,1 @@\n-        $type$ res = [[TEST_INIT]];\n+        $type$ res = [[TEST_INIT]]();\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Reduction-Scalar-op-func.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-            res [[TEST_OP]]= a[i];\n+            res = [[TEST_OP]](res, a[i]);\n@@ -14,1 +14,1 @@\n-            res [[TEST_OP]]= [[TEST]]Reduce(a, i);\n+            res = [[TEST_OP]](res, [[TEST]]Reduce(a, i));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Reduction-Scalar-op.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -17,1 +17,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), test[[TEST]](a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j), test[[TEST]](a[i + j]));\n@@ -37,1 +37,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && test[[TEST]](a[i + j]));\n+                    AssertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && test[[TEST]](a[i + j]));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Test.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n-        return ($type$)(Strict[[TEST_OP]]);\n+        return ($type$)(strict_[[TEST_OP]]);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Unary-op-math.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-        Assert.assertEquals(a, r);\n+        AssertEquals(a, r);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Zero.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,5 @@\n+#if[FP16]\n+import jdk.incubator.vector.Float16;\n+import static jdk.incubator.vector.Float16.*;\n+import jdk.incubator.vector.HalffloatVector;\n+#end[FP16]\n@@ -90,0 +95,82 @@\n+    static $abstractvectortype$ bcast_vec = $abstractvectortype$.broadcast(SPECIES, ($type$)10);\n+\n+#if[FP16]\n+    static void AssertEquals($type$ actual, $type$ expected) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected));\n+    }\n+    static void AssertEquals($type$ actual, $type$ expected, String msg) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected), msg);\n+    }\n+    static void AssertEquals($type$ actual, $type$ expected, $type$ delta) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected), Float.float16ToFloat((short)delta));\n+    }\n+    static void AssertEquals($type$ actual, $type$ expected, $type$ delta, String msg) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected), Float.float16ToFloat((short)delta), msg);\n+    }\n+    static void AssertEquals($type$ [] actual, $type$ [] expected) {\n+        Assert.assertEquals(actual.length, expected.length);\n+        for (int i = 0; i < actual.length; i++) {\n+            Assert.assertEquals(Float.float16ToFloat((short)actual[i]), Float.float16ToFloat((short)expected[i]));\n+        }\n+    }\n+    static void AssertEquals($type$ [] actual, $type$ [] expected, String msg) {\n+        Assert.assertEquals(actual.length, expected.length);\n+        for (int i = 0; i < actual.length; i++) {\n+            Assert.assertEquals(Float.float16ToFloat((short)actual[i]), Float.float16ToFloat((short)expected[i]), msg);\n+        }\n+    }\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected));\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(Float.float16ToFloat((short)actual), Float.float16ToFloat((short)expected), msg);\n+    }\n+#else[FP16]\n+    static void AssertEquals($type$ actual, $type$ expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals($type$ actual, $type$ expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+    static void AssertEquals($type$ actual, $type$ expected, $type$ delta) {\n+        Assert.assertEquals(actual, expected, delta);\n+    }\n+    static void AssertEquals($type$ actual, $type$ expected, $type$ delta, String msg) {\n+        Assert.assertEquals(actual, expected, delta, msg);\n+    }\n+    static void AssertEquals($type$ [] actual, $type$ [] expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals($type$ [] actual, $type$ [] expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+#if[!long]\n+    static void AssertEquals(long actual, long expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(long actual, long expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+#end[!long]\n+#end[FP16]\n+    static void AssertEquals(String actual, String expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(Object actual, Object expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+#if[!FP64]\n+    static void AssertEquals(double actual, double expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(double actual, double expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+#end[!FP64]\n+    static void AssertEquals(boolean actual, boolean expected) {\n+        Assert.assertEquals(actual, expected);\n+    }\n+    static void AssertEquals(boolean actual, boolean expected, String msg) {\n+        Assert.assertEquals(actual, expected, msg);\n+    }\n+\n@@ -114,2 +201,2 @@\n-            $bitstype$ ir = $Wideboxtype$.$type$ToRaw$Bitstype$Bits(r[i]);\n-            $bitstype$ ia = $Wideboxtype$.$type$ToRaw$Bitstype$Bits(a[i]);\n+            $bitstype$ ir = {#if[FP16]?r[i]:$Wideboxtype$.$type$ToRaw$Bitstype$Bits(r[i])};\n+            $bitstype$ ia = {#if[FP16]?a[i]:$Wideboxtype$.$type$ToRaw$Bitstype$Bits(a[i])};\n@@ -139,1 +226,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i]));\n+                AssertEquals(r[i], f.apply(a[i]));\n@@ -142,1 +229,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n@@ -154,1 +241,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -160,1 +247,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -170,1 +257,1 @@\n-                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+                AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n@@ -173,1 +260,1 @@\n-            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -192,1 +279,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -194,1 +281,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -197,2 +284,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -209,1 +296,1 @@\n-            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);\n+            AssertEquals(rc, fa.apply(a), {#if[FP16]?float16ToShortBits(Float16.multiply(Float16.ulp(shortBitsToFloat16(rc)), shortBitsToFloat16(relativeErrorFactor))):Math.ulp(rc) * relativeErrorFactor});\n@@ -211,1 +298,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);\n+                AssertEquals(r[i], f.apply(a, i), {#if[FP16]?float16ToShortBits(Float16.multiply(Float16.ulp(shortBitsToFloat16(r[i])), shortBitsToFloat16(relativeErrorFactor))):Math.ulp(r[i]) * relativeErrorFactor});\n@@ -214,2 +301,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), {#if[FP16]?float16ToShortBits(Float16.multiply(Float16.ulp(shortBitsToFloat16(rc)), shortBitsToFloat16(relativeErrorFactor))):Math.ulp(rc) * relativeErrorFactor}, \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), {#if[FP16]?float16ToShortBits(Float16.multiply(Float16.ulp(shortBitsToFloat16(r[i])), shortBitsToFloat16(relativeErrorFactor))):Math.ulp(r[i]) * relativeErrorFactor}, \"at index #\" + i);\n@@ -235,1 +322,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -237,1 +324,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -240,2 +327,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -252,1 +339,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n+            AssertEquals(rc, fa.apply(a, mask), {#if[FP16]?float16ToShortBits(Float16.abs(Float16.multiply(shortBitsToFloat16(rc), shortBitsToFloat16(relativeError)))):Math.abs(rc * relativeError)});\n@@ -254,2 +341,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n-relativeError));\n+                AssertEquals(r[i], f.apply(a, i, mask), {#if[FP16]?float16ToShortBits(Float16.abs(Float16.multiply(shortBitsToFloat16(r[i]), shortBitsToFloat16(relativeError)))):Math.abs(r[i] * relativeError)});\n@@ -258,2 +344,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), {#if[FP16]?float16ToShortBits(Float16.abs(Float16.multiply(shortBitsToFloat16(rc), shortBitsToFloat16(relativeError)))):Math.abs(rc * relativeError)}, \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), {#if[FP16]?float16ToShortBits(Float16.abs(Float16.multiply(shortBitsToFloat16(r[i]), shortBitsToFloat16(relativeError)))):Math.abs(r[i] * relativeError)}, \"at index #\" + i);\n@@ -277,1 +363,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            AssertEquals(rc, fa.apply(a));\n@@ -279,1 +365,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -282,2 +368,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -299,1 +385,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            AssertEquals(rc, fa.apply(a, mask));\n@@ -301,1 +387,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                AssertEquals(r[i], f.apply(a, i, mask));\n@@ -304,2 +390,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            AssertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            AssertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n@@ -318,1 +404,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -321,1 +407,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -333,1 +419,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                AssertEquals(r[i], f.apply(a, i));\n@@ -336,1 +422,1 @@\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            AssertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n@@ -345,1 +431,1 @@\n-                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -350,1 +436,1 @@\n-            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+            AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n@@ -361,1 +447,1 @@\n-                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        AssertEquals(r[i + k], a[i + j]);\n@@ -366,1 +452,1 @@\n-                    Assert.assertEquals(r[i + k], ($type$)0);\n+                    AssertEquals(r[i + k], ($type$)0);\n@@ -372,1 +458,1 @@\n-                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + j], \"at index #\" + idx);\n@@ -374,1 +460,1 @@\n-                Assert.assertEquals(r[idx], ($type$)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], ($type$)0, \"at index #\" + idx);\n@@ -386,1 +472,1 @@\n-                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        AssertEquals(r[i + j], a[i + k]);\n@@ -389,1 +475,1 @@\n-                        Assert.assertEquals(r[i + j], ($type$)0);\n+                        AssertEquals(r[i + j], ($type$)0);\n@@ -396,1 +482,1 @@\n-                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+                AssertEquals(r[idx], a[i + k], \"at index #\" + idx);\n@@ -398,1 +484,1 @@\n-                Assert.assertEquals(r[idx], ($type$)0, \"at index #\" + idx);\n+                AssertEquals(r[idx], ($type$)0, \"at index #\" + idx);\n@@ -411,1 +497,1 @@\n-                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    wrapped_index = Math.floorMod({#if[FP16]?shortBitsToFloat16(order[idx]).intValue():(int)order[idx]}, 2 * vector_len);\n@@ -414,1 +500,1 @@\n-                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                    AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n@@ -418,1 +504,1 @@\n-            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+            AssertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n@@ -424,0 +510,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -427,1 +514,3 @@\n-                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    idx = {#if[FP16]?shortBitsToFloat16(order[i+j]).intValue():(int)order[i+j]};\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n+                    AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -431,2 +520,1 @@\n-            int idx = i + j;\n-            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+            AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index]);\n@@ -442,1 +530,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+order[i+j]]);\n@@ -444,1 +532,1 @@\n-                         Assert.assertEquals(r[i+j], ($type$)0);\n+                         AssertEquals(r[i+j], ($type$)0);\n@@ -450,1 +538,1 @@\n-                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -452,1 +540,1 @@\n-                Assert.assertEquals(r[i+j], ($type$)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], ($type$)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -458,0 +546,1 @@\n+        int idx = 0, wrapped_index = 0;\n@@ -461,0 +550,2 @@\n+                    idx = {#if[FP16]?shortBitsToFloat16(order[i+j]).intValue():(int)order[i+j]};\n+                    wrapped_index = Integer.remainderUnsigned(idx, vector_len);\n@@ -462,1 +553,1 @@\n-                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                         AssertEquals(r[i+j], a[i+wrapped_index]);\n@@ -464,1 +555,1 @@\n-                         Assert.assertEquals(r[i+j], ($type$)0);\n+                         AssertEquals(r[i+j], ($type$)0);\n@@ -468,1 +559,0 @@\n-            int idx = i + j;\n@@ -470,1 +560,1 @@\n-                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], a[i+wrapped_index], \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -472,1 +562,1 @@\n-                Assert.assertEquals(r[i+j], ($type$)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+                AssertEquals(r[i+j], ($type$)0, \"at index #\" + idx + \", input = \" + a[i+wrapped_index] + \", mask = \" + mask[j % SPECIES.length()]);\n@@ -486,1 +576,1 @@\n-                Assert.assertEquals(r[i], a[i]);\n+                AssertEquals(r[i], a[i]);\n@@ -489,1 +579,1 @@\n-            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+            AssertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n@@ -510,1 +600,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n@@ -513,1 +603,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n@@ -516,1 +606,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -519,3 +609,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -536,1 +626,1 @@\n-                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+                AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n@@ -539,1 +629,1 @@\n-                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+                AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n@@ -542,1 +632,1 @@\n-                Assert.assertEquals(rl[i], rr[i]);\n+                AssertEquals(rl[i], rr[i]);\n@@ -545,3 +635,3 @@\n-            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n-            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+            AssertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            AssertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n@@ -555,1 +645,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i]));\n@@ -558,1 +648,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n@@ -566,1 +656,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b));\n+                AssertEquals(r[i], f.apply(a[i], b));\n@@ -569,1 +659,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+            AssertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n@@ -577,1 +667,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -580,1 +670,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -589,1 +679,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], ($type$)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+                AssertEquals(r[i], f.apply(a[i], ($type$)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n@@ -592,1 +682,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], ($type$)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+            AssertEquals(r[i], f.apply(a[i], ($type$)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n@@ -605,1 +695,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n@@ -608,1 +698,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -620,1 +710,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n@@ -623,1 +713,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+            AssertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n@@ -635,1 +725,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n@@ -638,1 +728,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -653,1 +743,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], ($type$)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], ($type$)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n@@ -656,1 +746,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], ($type$)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+            AssertEquals(r[i], f.apply(a[i], ($type$)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n@@ -669,1 +759,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j]));\n@@ -673,1 +763,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n@@ -687,1 +777,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n@@ -691,1 +781,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n@@ -713,1 +803,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j]));\n@@ -717,1 +807,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+            AssertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n@@ -731,1 +821,1 @@\n-                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                    AssertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n@@ -735,1 +825,1 @@\n-            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+            AssertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n@@ -755,1 +845,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i]));\n@@ -758,1 +848,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n@@ -770,1 +860,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n@@ -773,1 +863,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n@@ -782,1 +872,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n@@ -785,1 +875,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n@@ -795,1 +885,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n@@ -798,1 +888,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n@@ -814,1 +904,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -818,1 +908,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -835,1 +925,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -839,1 +929,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n@@ -850,1 +940,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -854,1 +944,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -871,1 +961,1 @@\n-                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -875,1 +965,1 @@\n-            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+            AssertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n@@ -886,0 +976,20 @@\n+#if[FP16]\n+        Float16 act = shortBitsToFloat16(actual);\n+        Float16 exp = shortBitsToFloat16(expected);\n+        if (Float16.isNaN(exp) && !Float16.isNaN(act)) {\n+            return false;\n+        } else if (!Float16.isNaN(exp) && Float16.isNaN(act)) {\n+             return false;\n+        }\n+\n+        Float16 low = Float16.nextDown(exp);\n+        Float16 high = Float16.nextUp(exp);\n+\n+        if (Float16.compare(low, exp) > 0) {\n+            return false;\n+        }\n+\n+        if (Float16.compare(high, exp) < 0) {\n+            return false;\n+        }\n+#else[FP16]\n@@ -902,0 +1012,1 @@\n+#end[FP16]\n@@ -911,1 +1022,1 @@\n-                Assert.assertTrue($Type$.compare(r[i], mathf.apply(a[i])) == 0 ||\n+                Assert.assertTrue($Wideboxtype$.compare({#if[FP16]?shortBitsToFloat16(r[i]):r[i]}, {#if[FP16]?shortBitsToFloat16(mathf.apply(a[i])):mathf.apply(a[i])}) == 0 ||\n@@ -915,1 +1026,1 @@\n-            Assert.assertTrue($Type$.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue($Wideboxtype$.compare({#if[FP16]?shortBitsToFloat16(r[i]):r[i]}, {#if[FP16]?shortBitsToFloat16(mathf.apply(a[i])):mathf.apply(a[i])}) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n@@ -925,1 +1036,1 @@\n-                Assert.assertTrue($Type$.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n+                Assert.assertTrue($Wideboxtype$.compare({#if[FP16]?shortBitsToFloat16(r[i]):r[i]}, {#if[FP16]?shortBitsToFloat16(mathf.apply(a[i], b[i])):mathf.apply(a[i], b[i])}) == 0 ||\n@@ -929,1 +1040,1 @@\n-            Assert.assertTrue($Type$.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue($Wideboxtype$.compare({#if[FP16]?shortBitsToFloat16(r[i]):r[i]}, {#if[FP16]?shortBitsToFloat16(mathf.apply(a[i], b[i])):mathf.apply(a[i], b[i])}) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n@@ -940,2 +1051,2 @@\n-                Assert.assertTrue($Type$.compare(r[i],\n-                                  mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0 ||\n+                Assert.assertTrue($Wideboxtype$.compare({#if[FP16]?shortBitsToFloat16(r[i]):r[i]},\n+                                  {#if[FP16]?shortBitsToFloat16(mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])):mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])}) == 0 ||\n@@ -946,2 +1057,2 @@\n-            Assert.assertTrue($Type$.compare(r[i],\n-                              mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0,\n+            Assert.assertTrue($Wideboxtype$.compare({#if[FP16]?shortBitsToFloat16(r[i]):r[i]},\n+                              {#if[FP16]?shortBitsToFloat16(mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])):mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])}) == 0,\n@@ -969,1 +1080,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -975,1 +1086,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -996,1 +1107,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1002,1 +1113,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -1017,1 +1128,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1023,1 +1134,1 @@\n-            Assert.assertEquals(res, ref,\n+            AssertEquals(res, ref,\n@@ -1044,1 +1155,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1050,1 +1161,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1064,1 +1175,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1070,1 +1181,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1085,1 +1196,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1091,1 +1202,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1106,1 +1217,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1112,1 +1223,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1128,1 +1239,1 @@\n-                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                AssertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n@@ -1134,1 +1245,1 @@\n-            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+            AssertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n@@ -1142,0 +1253,8 @@\n+    static $type$ genValue(int i) {\n+#if[FP16]\n+        return float16ToShortBits(Float16.valueOf(i));\n+#else[FP16]\n+        return ($type$) i;\n+#end[FP16]\n+    }\n+\n@@ -1160,1 +1279,1 @@\n-            withToString(\"$type$[-i * 5]\", (int s) -> {\n+            withToString(\"$Wideboxtype$[-i * 5]\", (int s) -> {\n@@ -1162,1 +1281,1 @@\n-                            i -> ($type$)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1164,1 +1283,1 @@\n-            withToString(\"$type$[i * 5]\", (int s) -> {\n+            withToString(\"$Wideboxtype$[i * 5]\", (int s) -> {\n@@ -1166,1 +1285,1 @@\n-                            i -> ($type$)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1168,1 +1287,1 @@\n-            withToString(\"$type$[i + 1]\", (int s) -> {\n+            withToString(\"$Wideboxtype$[i + 1]\", (int s) -> {\n@@ -1170,1 +1289,1 @@\n-                            i -> ((($type$)(i + 1) == 0) ? 1 : ($type$)(i + 1)));\n+                            i -> ((($type$)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1172,1 +1291,1 @@\n-            withToString(\"$type$[intCornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"$Wideboxtype$[intCornerCaseValue(i)]\", (int s) -> {\n@@ -1184,1 +1303,5 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+#if[FP16]\n+                AssertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));\n+#else[FP16]\n+                AssertEquals(r[i], (int)(a[i+offs]));\n+#end[FP16]\n@@ -1187,1 +1310,1 @@\n-            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1208,0 +1331,8 @@\n+    static $type$ genValue(long i) {\n+#if[FP16]\n+        return float16ToShortBits(Float16.valueOf(i));\n+#else[FP16]\n+        return ($type$) i;\n+#end[FP16]\n+    }\n+\n@@ -1209,1 +1340,1 @@\n-            withToString(\"$type$[-i * 5]\", (int s) -> {\n+            withToString(\"$Wideboxtype$[-i * 5]\", (int s) -> {\n@@ -1211,1 +1342,1 @@\n-                            i -> ($type$)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1213,1 +1344,1 @@\n-            withToString(\"$type$[i * 5]\", (int s) -> {\n+            withToString(\"$Wideboxtype$[i * 5]\", (int s) -> {\n@@ -1215,1 +1346,1 @@\n-                            i -> ($type$)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1217,1 +1348,1 @@\n-            withToString(\"$type$[i + 1]\", (int s) -> {\n+            withToString(\"$Wideboxtype$[i + 1]\", (int s) -> {\n@@ -1219,1 +1350,1 @@\n-                            i -> ((($type$)(i + 1) == 0) ? 1 : ($type$)(i + 1)));\n+                            i -> ((($type$)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1221,1 +1352,1 @@\n-            withToString(\"$type$[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"$Wideboxtype$[cornerCaseValue(i)]\", (int s) -> {\n@@ -1234,1 +1365,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                AssertEquals(r[i], (long)(a[i+offs]));\n@@ -1237,1 +1368,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1246,1 +1377,5 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+#if[FP16]\n+                AssertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));\n+#else[FP16]\n+                AssertEquals(r[i], (long)(a[i+offs]));\n+#end[FP16]\n@@ -1249,1 +1384,1 @@\n-            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1258,1 +1393,5 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+#if[FP16]\n+                AssertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));\n+#else[FP16]\n+                AssertEquals(r[i], (double)(a[i+offs]));\n+#end[FP16]\n@@ -1261,1 +1400,1 @@\n-            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+            AssertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n@@ -1267,1 +1406,5 @@\n-        return {#if[FP]? $Type$.$type$To$Bitstype$Bits(e): e};\n+#if[FP16]\n+        return e;\n+#else[FP16]\n+        return {#if[FP]?$Wideboxtype$.$type$To$Bitstype$Bits(e): e};\n+#end[FP16]\n@@ -1271,1 +1414,1 @@\n-            withToString(\"$type$[-i * 5]\", (int s) -> {\n+            withToString(\"$Wideboxtype$[-i * 5]\", (int s) -> {\n@@ -1273,1 +1416,1 @@\n-                            i -> ($type$)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1275,1 +1418,1 @@\n-            withToString(\"$type$[i * 5]\", (int s) -> {\n+            withToString(\"$Wideboxtype$[i * 5]\", (int s) -> {\n@@ -1277,1 +1420,1 @@\n-                            i -> ($type$)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1279,1 +1422,1 @@\n-            withToString(\"$type$[i + 1]\", (int s) -> {\n+            withToString(\"$Wideboxtype$[i + 1]\", (int s) -> {\n@@ -1281,1 +1424,1 @@\n-                            i -> ((($type$)(i + 1) == 0) ? 1 : ($type$)(i + 1)));\n+                            i -> ((($type$)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1284,0 +1427,10 @@\n+#if[FP16]\n+            withToString(\"$Wideboxtype$[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> Float.floatToFloat16((0.01f + ((float)i \/ (i + 1)))));\n+            }),\n+            withToString(\"$Wideboxtype$[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01f + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (i % 17 == 0) ? cornerCaseValue(i) : Float.floatToFloat16((0.01f + ((float)i \/ (i + 1)))));\n+            }),\n+#else[FP16]\n@@ -1286,1 +1439,1 @@\n-                            i -> ($type$)0.01 + (($type$)i \/ (i + 1)));\n+                            i -> (($type$)0.01 + (($type$)i \/ (i + 1))));\n@@ -1290,1 +1443,1 @@\n-                            i -> i % 17 == 0 ? cornerCaseValue(i) : ($type$)0.01 + (($type$)i \/ (i + 1)));\n+                            i -> (i % 17 == 0) ? cornerCaseValue(i) : (($type$)0.01 + (($type$)i \/ (i + 1))));\n@@ -1292,0 +1445,1 @@\n+#end[FP16]\n@@ -1681,0 +1835,12 @@\n+#if[FP16]\n+        return switch(i % 8) {\n+            case 0  -> float16ToShortBits($Wideboxtype$.MAX_VALUE);\n+            case 1  -> float16ToShortBits($Wideboxtype$.MIN_VALUE);\n+            case 2  -> float16ToShortBits($Wideboxtype$.NEGATIVE_INFINITY);\n+            case 3  -> float16ToShortBits($Wideboxtype$.POSITIVE_INFINITY);\n+            case 4  -> float16ToShortBits($Wideboxtype$.NaN);\n+            case 5  -> float16ToShortBits(shortBitsToFloat16((short)0x7FFA));\n+            case 6  -> (($type$)0.0);\n+            default -> (($type$)-0.0);\n+        };\n+#else[FP16]\n@@ -1695,0 +1861,1 @@\n+#end[FP16]\n@@ -1812,0 +1979,260 @@\n+#if[FP16]\n+\n+    static boolean eq(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() == bt.floatValue();\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() != bt.floatValue();\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() < bt.floatValue();\n+    }\n+\n+    static boolean le(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() <= bt.floatValue();\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() > bt.floatValue();\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return at.floatValue() >= bt.floatValue();\n+    }\n+\n+    static $type$ firstNonZero($type$ a, $type$ b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        Float16 zero = shortBitsToFloat16((short)0);\n+        return Float16.compare(at, zero) != 0 ? a : b;\n+    }\n+\n+    static $type$ multiplicativeIdentity() {\n+        return ($type$)float16ToShortBits(Float16.valueOf(1.0f));\n+    }\n+\n+    static $type$ scalar_add($type$ a, $type$ b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.add(at, bt));\n+    }\n+\n+    static $type$ scalar_sub($type$ a, $type$ b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.subtract(at, bt));\n+    }\n+\n+    static $type$ scalar_mul($type$ a, $type$ b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.multiply(at, bt));\n+\n+    }\n+    static $type$ scalar_max($type$ a, $type$ b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.max(at, bt));\n+    }\n+\n+    static $type$ scalar_min($type$ a, $type$ b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.min(at, bt));\n+    }\n+\n+    static $type$ scalar_div($type$ a, $type$ b) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        return float16ToShortBits(Float16.divide(at, bt));\n+    }\n+\n+    static $type$ scalar_fma($type$ a, $type$ b, $type$ c) {\n+        Float16 at = shortBitsToFloat16(a);\n+        Float16 bt = shortBitsToFloat16(b);\n+        Float16 ct = shortBitsToFloat16(c);\n+        return float16ToShortBits(Float16.fma(at, bt, ct));\n+    }\n+\n+    static $type$ scalar_abs($type$ a) {\n+        Float16 at = shortBitsToFloat16(a);\n+        return float16ToShortBits(Float16.abs(at));\n+    }\n+\n+    static $type$ scalar_neg($type$ a) {\n+        Float16 at = shortBitsToFloat16(a);\n+        return float16ToShortBits(Float16.valueOf(-at.floatValue()));\n+    }\n+\n+    static $type$ scalar_sin($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(Math.sin(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ scalar_exp($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(Math.exp(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ scalar_log1p($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(Math.log1p(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ scalar_log($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(Math.log(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ scalar_log10($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(Math.log10(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ scalar_expm1($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(Math.expm1(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ scalar_cos($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(Math.cos(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ scalar_tan($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(Math.tan(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ scalar_sinh($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(Math.sinh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ scalar_cosh($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(Math.cosh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ scalar_tanh($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(Math.tanh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ scalar_asin($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(Math.asin(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ scalar_acos($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(Math.acos(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ scalar_atan($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(Math.atan(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ scalar_cbrt($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(Math.cbrt(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ scalar_sqrt($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(Math.sqrt(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ scalar_hypot($type$ a, $type$ b) {\n+        return float16ToShortBits(Float16.valueOf(Math.hypot(shortBitsToFloat16(a).doubleValue(),\n+                                                                     shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static $type$ scalar_pow($type$ a, $type$ b) {\n+        return float16ToShortBits(Float16.valueOf(Math.pow(shortBitsToFloat16(a).doubleValue(),\n+                                                                   shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static $type$ scalar_atan2($type$ a, $type$ b) {\n+        return float16ToShortBits(Float16.valueOf(Math.atan2(shortBitsToFloat16(a).doubleValue(),\n+                                                                     shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static $type$ strict_scalar_sin($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.sin(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ strict_scalar_exp($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.exp(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ strict_scalar_log1p($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.log1p(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ strict_scalar_log($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.log(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ strict_scalar_log10($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.log10(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ strict_scalar_expm1($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.expm1(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ strict_scalar_cos($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.cos(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ strict_scalar_tan($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.tan(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ strict_scalar_sinh($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.sinh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ strict_scalar_cosh($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.cosh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ strict_scalar_tanh($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.tanh(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ strict_scalar_asin($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.asin(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ strict_scalar_acos($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.acos(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ strict_scalar_atan($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.atan(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ strict_scalar_cbrt($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.cbrt(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ strict_scalar_sqrt($type$ a) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.sqrt(shortBitsToFloat16(a).doubleValue())));\n+    }\n+\n+    static $type$ strict_scalar_hypot($type$ a, $type$ b) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.hypot(shortBitsToFloat16(a).doubleValue(),\n+                                                                     shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static $type$ strict_scalar_pow($type$ a, $type$ b) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.pow(shortBitsToFloat16(a).doubleValue(),\n+                                                                   shortBitsToFloat16(b).doubleValue())));\n+    }\n+\n+    static $type$ strict_scalar_atan2($type$ a, $type$ b) {\n+        return float16ToShortBits(Float16.valueOf(StrictMath.atan2(shortBitsToFloat16(a).doubleValue(),\n+                                                                     shortBitsToFloat16(b).doubleValue())));\n+    }\n+#else[FP16]\n@@ -1836,0 +2263,215 @@\n+\n+    static $type$ firstNonZero($type$ a, $type$ b) {\n+        return $Wideboxtype$.compare(a, ($type$) 0) != 0 ? a : b;\n+    }\n+\n+    static $type$ multiplicativeIdentity() {\n+        return ($type$)1;\n+    }\n+\n+#if[BITWISE]\n+    static $type$ scalar_or($type$ a, $type$ b) {\n+        return ($type$)(a | b);\n+    }\n+\n+    static $type$ scalar_and($type$ a, $type$ b) {\n+        return ($type$)(a & b);\n+    }\n+\n+    static $type$ scalar_xor($type$ a, $type$ b) {\n+        return ($type$)(a ^ b);\n+    }\n+#end[BITWISE];\n+\n+    static $type$ scalar_add($type$ a, $type$ b) {\n+        return ($type$)(a + b);\n+    }\n+\n+    static $type$ scalar_sub($type$ a, $type$ b) {\n+        return ($type$)(a - b);\n+    }\n+\n+    static $type$ scalar_mul($type$ a, $type$ b) {\n+        return ($type$)(a * b);\n+    }\n+\n+    static $type$ scalar_min($type$ a, $type$ b) {\n+        return ($type$)(Math.min(a, b));\n+    }\n+\n+    static $type$ scalar_max($type$ a, $type$ b) {\n+        return ($type$)(Math.max(a, b));\n+    }\n+\n+    static $type$ scalar_div($type$ a, $type$ b) {\n+        return ($type$)(a \/ b);\n+    }\n+\n+    static $type$ scalar_fma($type$ a, $type$ b, $type$ c) {\n+        return ($type$)(Math.fma(a, b, c));\n+    }\n+\n+    static $type$ scalar_abs($type$ a) {\n+        return ($type$)(Math.abs(a));\n+    }\n+\n+    static $type$ scalar_neg($type$ a) {\n+        return (($type$)-a);\n+    }\n+\n+    static $type$ scalar_sin($type$ a) {\n+        return ($type$)Math.sin((double)a);\n+    }\n+\n+    static $type$ scalar_exp($type$ a) {\n+        return ($type$)Math.exp((double)a);\n+    }\n+\n+    static $type$ scalar_log1p($type$ a) {\n+        return ($type$)Math.log1p((double)a);\n+    }\n+\n+    static $type$ scalar_log($type$ a) {\n+        return ($type$)Math.log((double)a);\n+    }\n+\n+    static $type$ scalar_log10($type$ a) {\n+        return ($type$)Math.log10((double)a);\n+    }\n+\n+    static $type$ scalar_expm1($type$ a) {\n+        return ($type$)Math.expm1((double)a);\n+    }\n+\n+    static $type$ scalar_cos($type$ a) {\n+        return ($type$)Math.cos((double)a);\n+    }\n+\n+    static $type$ scalar_tan($type$ a) {\n+        return ($type$)Math.tan((double)a);\n+    }\n+\n+    static $type$ scalar_sinh($type$ a) {\n+        return ($type$)Math.sinh((double)a);\n+    }\n+\n+    static $type$ scalar_cosh($type$ a) {\n+        return ($type$)Math.cosh((double)a);\n+    }\n+\n+    static $type$ scalar_tanh($type$ a) {\n+        return ($type$)Math.tanh((double)a);\n+    }\n+\n+    static $type$ scalar_asin($type$ a) {\n+        return ($type$)Math.asin((double)a);\n+    }\n+\n+    static $type$ scalar_acos($type$ a) {\n+        return ($type$)Math.acos((double)a);\n+    }\n+\n+    static $type$ scalar_atan($type$ a) {\n+        return ($type$)Math.atan((double)a);\n+    }\n+\n+    static $type$ scalar_cbrt($type$ a) {\n+        return ($type$)Math.cbrt((double)a);\n+    }\n+\n+    static $type$ scalar_sqrt($type$ a) {\n+        return ($type$)Math.sqrt((double)a);\n+    }\n+\n+    static $type$ scalar_hypot($type$ a, $type$ b) {\n+        return ($type$)Math.hypot((double)a, (double)b);\n+    }\n+\n+    static $type$ scalar_pow($type$ a, $type$ b) {\n+        return ($type$)Math.pow((double)a, (double)b);\n+    }\n+\n+    static $type$ scalar_atan2($type$ a, $type$ b) {\n+        return ($type$)Math.atan2((double)a, (double)b);\n+    }\n+\n+    static $type$ strict_scalar_sin($type$ a) {\n+        return ($type$)StrictMath.sin((double)a);\n+    }\n+\n+    static $type$ strict_scalar_exp($type$ a) {\n+        return ($type$)StrictMath.exp((double)a);\n+    }\n+\n+    static $type$ strict_scalar_log1p($type$ a) {\n+        return ($type$)StrictMath.log1p((double)a);\n+    }\n+\n+    static $type$ strict_scalar_log($type$ a) {\n+        return ($type$)StrictMath.log((double)a);\n+    }\n+\n+    static $type$ strict_scalar_log10($type$ a) {\n+        return ($type$)StrictMath.log10((double)a);\n+    }\n+\n+    static $type$ strict_scalar_expm1($type$ a) {\n+        return ($type$)StrictMath.expm1((double)a);\n+    }\n+\n+    static $type$ strict_scalar_cos($type$ a) {\n+        return ($type$)StrictMath.cos((double)a);\n+    }\n+\n+    static $type$ strict_scalar_tan($type$ a) {\n+        return ($type$)StrictMath.tan((double)a);\n+    }\n+\n+    static $type$ strict_scalar_sinh($type$ a) {\n+        return ($type$)StrictMath.sinh((double)a);\n+    }\n+\n+    static $type$ strict_scalar_cosh($type$ a) {\n+        return ($type$)StrictMath.cosh((double)a);\n+    }\n+\n+    static $type$ strict_scalar_tanh($type$ a) {\n+        return ($type$)StrictMath.tanh((double)a);\n+    }\n+\n+    static $type$ strict_scalar_asin($type$ a) {\n+        return ($type$)StrictMath.asin((double)a);\n+    }\n+\n+    static $type$ strict_scalar_acos($type$ a) {\n+        return ($type$)StrictMath.acos((double)a);\n+    }\n+\n+    static $type$ strict_scalar_atan($type$ a) {\n+        return ($type$)StrictMath.atan((double)a);\n+    }\n+\n+    static $type$ strict_scalar_cbrt($type$ a) {\n+        return ($type$)StrictMath.cbrt((double)a);\n+    }\n+\n+    static $type$ strict_scalar_sqrt($type$ a) {\n+        return ($type$)StrictMath.sqrt((double)a);\n+    }\n+\n+    static $type$ strict_scalar_hypot($type$ a, $type$ b) {\n+        return ($type$)StrictMath.hypot((double)a, (double)b);\n+    }\n+\n+    static $type$ strict_scalar_pow($type$ a, $type$ b) {\n+        return ($type$)StrictMath.pow((double)a, (double)b);\n+    }\n+\n+    static $type$ strict_scalar_atan2($type$ a, $type$ b) {\n+        return ($type$)StrictMath.atan2((double)a, (double)b);\n+    }\n+#end[FP16]\n+    static $type$ additiveIdentity() {\n+        return ($type$)0;\n+    }\n+\n@@ -1855,2 +2497,26 @@\n-    static $type$ firstNonZero($type$ a, $type$ b) {\n-        return $Boxtype$.compare(a, ($type$) 0) != 0 ? a : b;\n+    static $type$ zeroValue() {\n+        return (short) 0;\n+    }\n+\n+    static $type$ maxValue() {\n+        return {#if[FP16]?float16ToShortBits($Wideboxtype$.$MaxValue$):$Wideboxtype$.$MaxValue$};\n+    }\n+\n+    static $type$ minValue() {\n+        return {#if[FP16]?float16ToShortBits($Wideboxtype$.$MinValue$):$Wideboxtype$.$MinValue$};\n+    }\n+\n+#if[FP]\n+#if[FP16]\n+    static boolean isNaN($type$ a) {\n+        return $Wideboxtype$.isNaN(shortBitsToFloat16(a));\n+    }\n+    static boolean isFinite($type$ a) {\n+        return $Wideboxtype$.isFinite(shortBitsToFloat16(a));\n+    }\n+    static boolean isInfinite($type$ a) {\n+        return $Wideboxtype$.isInfinite(shortBitsToFloat16(a));\n+    }\n+#else[FP16]\n+    static boolean isNaN($type$ a) {\n+        return $Wideboxtype$.isNaN(a);\n@@ -1858,0 +2524,8 @@\n+    static boolean isFinite($type$ a) {\n+        return $Wideboxtype$.isFinite(a);\n+    }\n+    static boolean isInfinite($type$ a) {\n+        return $Wideboxtype$.isInfinite(a);\n+    }\n+#end[FP16]\n+#end[FP]\n@@ -1861,0 +2535,17 @@\n+#if[FP16]\n+        $abstractvectortype$ three = $abstractvectortype$.broadcast(SPECIES, float16ToShortBits(Float16.valueOf(-3)));\n+        $abstractvectortype$ three2 = ($abstractvectortype$) SPECIES.broadcast(float16ToShortBits(Float16.valueOf(-3)));\n+        assert(three.eq(three2).allTrue());\n+        $abstractvectortype$ three3 = three2.broadcast(float16ToShortBits(Float16.valueOf(1))).broadcast(float16ToShortBits(Float16.valueOf(-3)));\n+        assert(three.eq(three3).allTrue());\n+        int scale = 2;\n+        $abstractvectortype$ higher = three.addIndex(scale);\n+        VectorMask<$Wideboxtype$> m = three.compare(VectorOperators.LE, higher);\n+        assert(m.allTrue());\n+        m = higher.min((float16ToShortBits(Float16.valueOf(-1)))).test(VectorOperators.IS_NEGATIVE);\n+        assert(m.allTrue());\n+        m = higher.test(VectorOperators.IS_FINITE);\n+        assert(m.allTrue());\n+        $type$ max = higher.reduceLanes(VectorOperators.MAX);\n+        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));\n+#else[FP16]\n@@ -1873,1 +2564,1 @@\n-        VectorMask<$Boxtype$> m = three.compare(VectorOperators.LE, higher);\n+        VectorMask<$Wideboxtype$> m = three.compare(VectorOperators.LE, higher);\n@@ -1883,0 +2574,1 @@\n+#end[FP16]\n@@ -1898,1 +2590,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1902,2 +2594,2 @@\n-        VectorShuffle<$Boxtype$> zip0 = VectorShuffle.makeZip(SPECIES, 0);\n-        VectorShuffle<$Boxtype$> zip1 = VectorShuffle.makeZip(SPECIES, 1);\n+        VectorShuffle<$Wideboxtype$> zip0 = VectorShuffle.makeZip(SPECIES, 0);\n+        VectorShuffle<$Wideboxtype$> zip1 = VectorShuffle.makeZip(SPECIES, 1);\n@@ -1913,3 +2605,3 @@\n-        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n-        VectorShuffle<$Boxtype$> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);\n-        VectorShuffle<$Boxtype$> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);\n+        AssertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        VectorShuffle<$Wideboxtype$> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);\n+        VectorShuffle<$Wideboxtype$> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);\n@@ -1919,1 +2611,1 @@\n-        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+        AssertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n@@ -1925,1 +2617,1 @@\n-        Assert.assertEquals(io, io2);\n+        AssertEquals(io, io2);\n@@ -1943,3 +2635,3 @@\n-        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n-        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n-        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+        AssertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        AssertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n@@ -1948,1 +2640,1 @@\n-        Assert.assertEquals(asIntegral.species(), SPECIES);\n+        AssertEquals(asIntegral.species(), SPECIES);\n@@ -1956,1 +2648,1 @@\n-        Assert.assertEquals(asFloating.species(), SPECIES);\n+        AssertEquals(asFloating.species(), SPECIES);\n@@ -1959,1 +2651,1 @@\n-#if[byteOrShort]\n+#if[byte]\n@@ -1965,1 +2657,1 @@\n-#else[byteOrShort]\n+#else[byte]\n@@ -1972,3 +2664,3 @@\n-        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n-        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n-        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n+        AssertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        AssertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        AssertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n@@ -1976,1 +2668,1 @@\n-#end[byteOrShort]\n+#end[byte]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":886,"deletions":194,"binary":false,"changes":1080,"status":"modified"},{"patch":"@@ -44,0 +44,4 @@\n+#if[FP16]\n+import jdk.incubator.vector.Float16;\n+import jdk.incubator.vector.HalffloatVector;\n+#end[FP16]\n@@ -72,0 +76,3 @@\n+#if[FP16]\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n+#else[FP16]\n@@ -73,0 +80,1 @@\n+#end[FP16]\n@@ -273,1 +281,1 @@\n-    static VectorShuffle<$Boxtype$> shuffleFromArray(int[] a, int i) {\n+    static VectorShuffle<$Wideboxtype$> shuffleFromArray(int[] a, int i) {\n@@ -278,1 +286,1 @@\n-    static void shuffleIntoArray(VectorShuffle<$Boxtype$> s, int[] a, int i) {\n+    static void shuffleIntoArray(VectorShuffle<$Wideboxtype$> s, int[] a, int i) {\n@@ -283,1 +291,1 @@\n-    static VectorShuffle<$Boxtype$> shuffleFromMemorySegment(MemorySegment mem, int i, ByteOrder bo) {\n+    static VectorShuffle<$Wideboxtype$> shuffleFromMemorySegment(MemorySegment mem, int i, ByteOrder bo) {\n@@ -288,1 +296,1 @@\n-    static void shuffleIntoMemorySegment(VectorShuffle<$Boxtype$> s, MemorySegment mem, int i, ByteOrder bo) {\n+    static void shuffleIntoMemorySegment(VectorShuffle<$Wideboxtype$> s, MemorySegment mem, int i, ByteOrder bo) {\n@@ -299,1 +307,1 @@\n-    static $abstractvectortype$ fromArray($type$[] a, int i, VectorMask<$Boxtype$> m) {\n+    static $abstractvectortype$ fromArray($type$[] a, int i, VectorMask<$Wideboxtype$> m) {\n@@ -309,1 +317,1 @@\n-    static void intoArray($abstractvectortype$ v, $type$[] a, int i, VectorMask<$Boxtype$> m) {\n+    static void intoArray($abstractvectortype$ v, $type$[] a, int i, VectorMask<$Wideboxtype$> m) {\n@@ -320,1 +328,1 @@\n-    static $abstractvectortype$ fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<$Boxtype$> m) {\n+    static $abstractvectortype$ fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<$Wideboxtype$> m) {\n@@ -330,1 +338,1 @@\n-    static void intoMemorySegment($abstractvectortype$ v, MemorySegment a, int i, ByteOrder bo, VectorMask<$Boxtype$> m) {\n+    static void intoMemorySegment($abstractvectortype$ v, MemorySegment a, int i, ByteOrder bo, VectorMask<$Wideboxtype$> m) {\n@@ -408,1 +416,1 @@\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n@@ -435,1 +443,1 @@\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n@@ -463,1 +471,1 @@\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n@@ -496,1 +504,1 @@\n-                VectorMask<$Boxtype$> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, i);\n@@ -526,2 +534,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, $Boxtype$.SIZE));\n-        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), $Boxtype$.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, $Wideboxtype$.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), $Wideboxtype$.SIZE);\n@@ -555,2 +563,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, $Boxtype$.SIZE));\n-        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), $Boxtype$.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, $Wideboxtype$.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), $Wideboxtype$.SIZE);\n@@ -592,1 +600,1 @@\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n@@ -619,2 +627,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, $Boxtype$.SIZE));\n-        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), $Boxtype$.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, $Wideboxtype$.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), $Wideboxtype$.SIZE);\n@@ -622,1 +630,1 @@\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n@@ -650,2 +658,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, $Boxtype$.SIZE));\n-        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), $Boxtype$.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, $Wideboxtype$.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), $Wideboxtype$.SIZE);\n@@ -653,1 +661,1 @@\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n@@ -701,1 +709,1 @@\n-        VectorMask<$Boxtype$> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+        VectorMask<$Wideboxtype$> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n@@ -717,1 +725,1 @@\n-                VectorMask<$Boxtype$> vmask = SPECIES.loadMask(a, i);\n+                VectorMask<$Wideboxtype$> vmask = SPECIES.loadMask(a, i);\n@@ -732,1 +740,1 @@\n-               VectorShuffle<$Boxtype$> shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+               VectorShuffle<$Wideboxtype$> shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n@@ -750,1 +758,1 @@\n-               VectorShuffle<$Boxtype$> shuffle = shuffleFromArray(a, i);\n+               VectorShuffle<$Wideboxtype$> shuffle = shuffleFromArray(a, i);\n@@ -758,1 +766,1 @@\n-           VectorShuffle<$Boxtype$> shuffle = shuffleFromArray(a, index);\n+           VectorShuffle<$Wideboxtype$> shuffle = shuffleFromArray(a, index);\n@@ -777,1 +785,1 @@\n-               VectorShuffle<$Boxtype$> shuffle = shuffleFromArray(a, i);\n+               VectorShuffle<$Wideboxtype$> shuffle = shuffleFromArray(a, i);\n@@ -808,1 +816,1 @@\n-               VectorShuffle<$Boxtype$> shuffle = VectorShuffle.fromMemorySegment(SPECIES, a, i, bo);\n+               VectorShuffle<$Wideboxtype$> shuffle = VectorShuffle.fromMemorySegment(SPECIES, a, i, bo);\n@@ -830,1 +838,1 @@\n-               VectorShuffle<$Boxtype$> shuffle = shuffleFromMemorySegment(a, i, ByteOrder.nativeOrder());\n+               VectorShuffle<$Wideboxtype$> shuffle = shuffleFromMemorySegment(a, i, ByteOrder.nativeOrder());\n@@ -859,1 +867,1 @@\n-               VectorShuffle<$Boxtype$> shuffle =\n+               VectorShuffle<$Wideboxtype$> shuffle =\n@@ -868,1 +876,1 @@\n-           VectorShuffle<$Boxtype$> shuffle =\n+           VectorShuffle<$Wideboxtype$> shuffle =\n@@ -960,1 +968,1 @@\n-    static $abstractvectortype$ fromCharArray(char[] a, int i, VectorMask<$Boxtype$> m) {\n+    static $abstractvectortype$ fromCharArray(char[] a, int i, VectorMask<$Wideboxtype$> m) {\n@@ -970,1 +978,1 @@\n-    static void intoCharArray($abstractvectortype$ v, char[] a, int i, VectorMask<$Boxtype$> m) {\n+    static void intoCharArray($abstractvectortype$ v, char[] a, int i, VectorMask<$Wideboxtype$> m) {\n@@ -1047,1 +1055,1 @@\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n@@ -1074,1 +1082,1 @@\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n@@ -1102,1 +1110,1 @@\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":46,"deletions":38,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -0,0 +1,328 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import java.util.stream.IntStream;\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.vector.*;\n+import org.openjdk.jmh.annotations.*;\n+import static jdk.incubator.vector.Float16.*;\n+import static java.lang.Float.*;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(jvmArgs = {\"--add-modules=jdk.incubator.vector\", \"-Xbatch\", \"-XX:-TieredCompilation\"})\n+public class HalffloatOperationsBenchmark {\n+    @Param({\"256\", \"512\", \"1024\", \"2048\"})\n+    int vectorDim;\n+\n+    int   [] rexp;\n+    short [] vectorRes;\n+    short [] vector1;\n+    short [] vector2;\n+    short [] vector3;\n+    short [] vector4;\n+    short [] vector5;\n+    boolean [] vectorPredicate;\n+\n+    static final short f16_one = Float.floatToFloat16(1.0f);\n+    static final short f16_two = Float.floatToFloat16(2.0f);\n+\n+    @Setup(Level.Trial)\n+    public void BmSetup() {\n+        rexp      = new int[vectorDim];\n+        vectorRes = new short[vectorDim];\n+        vector1   = new short[vectorDim];\n+        vector2   = new short[vectorDim];\n+        vector3   = new short[vectorDim];\n+        vector4   = new short[vectorDim];\n+        vector5   = new short[vectorDim];\n+        vectorPredicate = new boolean[vectorDim];\n+\n+        IntStream.range(0, vectorDim).forEach(i -> {vector1[i] = Float.floatToFloat16((float)i);});\n+        IntStream.range(0, vectorDim).forEach(i -> {vector2[i] = Float.floatToFloat16((float)i);});\n+        IntStream.range(0, vectorDim).forEach(i -> {vector3[i] = Float.floatToFloat16((float)i);});\n+        IntStream.range(0, vectorDim).forEach(i -> {vector4[i] = ((i & 0x1) == 0) ?\n+                                                                  float16ToRawShortBits(Float16.POSITIVE_INFINITY) :\n+                                                                  Float.floatToFloat16((float)i);});\n+        IntStream.range(0, vectorDim).forEach(i -> {vector5[i] = ((i & 0x1) == 0) ?\n+                                                                  float16ToRawShortBits(Float16.NaN) :\n+                                                                  Float.floatToFloat16((float)i);});\n+        \/\/ Special Values\n+        Float16 [] specialValues = {Float16.NaN, Float16.NEGATIVE_INFINITY, Float16.valueOf(0.0), Float16.valueOf(-0.0), Float16.POSITIVE_INFINITY};\n+        IntStream.range(0, vectorDim).forEach(\n+            i -> {\n+                if ((i % 64) == 0) {\n+                    int idx1 = i % specialValues.length;\n+                    int idx2 = (i + 1) % specialValues.length;\n+                    int idx3 = (i + 2) % specialValues.length;\n+                    vector1[i] = float16ToRawShortBits(specialValues[idx1]);\n+                    vector2[i] = float16ToRawShortBits(specialValues[idx2]);\n+                    vector3[i] = float16ToRawShortBits(specialValues[idx3]);\n+                }\n+            }\n+        );\n+    }\n+\n+    static final VectorSpecies<Float16> HSPECIES = HalffloatVector.SPECIES_PREFERRED;\n+    static final VectorSpecies<Float> FSPECIES = FloatVector.SPECIES_PREFERRED;\n+\n+    @Benchmark\n+    public void addBenchmark() {\n+        int i = 0;\n+        for (; i < HSPECIES.loopBound(vectorDim); i +=  HSPECIES.length()) {\n+            HalffloatVector.fromArray(HSPECIES, vector1, i)\n+                           .lanewise(VectorOperators.ADD,\n+                                     HalffloatVector.fromArray(HSPECIES, vector2, i))\n+                           .intoArray(vectorRes, i);\n+        }\n+        for (; i < vectorDim; i++) {\n+            vectorRes[i] = float16ToRawShortBits(add(shortBitsToFloat16(vector1[i]),\n+                                                     shortBitsToFloat16(vector2[i])));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void subBenchmark() {\n+        int i = 0;\n+        for (; i < HSPECIES.loopBound(vectorDim); i +=  HSPECIES.length()) {\n+            HalffloatVector.fromArray(HSPECIES, vector1, i)\n+                           .lanewise(VectorOperators.SUB,\n+                                     HalffloatVector.fromArray(HSPECIES, vector2, i))\n+                           .intoArray(vectorRes, i);\n+        }\n+        for (; i < vectorDim; i++) {\n+            vectorRes[i] = float16ToRawShortBits(subtract(shortBitsToFloat16(vector1[i]),\n+                                                          shortBitsToFloat16(vector2[i])));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void mulBenchmark() {\n+        int i = 0;\n+        for (; i < HSPECIES.loopBound(vectorDim); i +=  HSPECIES.length()) {\n+            HalffloatVector.fromArray(HSPECIES, vector1, i)\n+                           .lanewise(VectorOperators.MUL,\n+                                     HalffloatVector.fromArray(HSPECIES, vector2, i))\n+                           .intoArray(vectorRes, i);\n+        }\n+        for (; i < vectorDim; i++) {\n+            vectorRes[i] = float16ToRawShortBits(multiply(shortBitsToFloat16(vector1[i]),\n+                                                          shortBitsToFloat16(vector2[i])));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void divBenchmark() {\n+        int i = 0;\n+        for (; i < HSPECIES.loopBound(vectorDim); i +=  HSPECIES.length()) {\n+            HalffloatVector.fromArray(HSPECIES, vector1, i)\n+                           .lanewise(VectorOperators.DIV,\n+                                     HalffloatVector.fromArray(HSPECIES, vector2, i))\n+                           .intoArray(vectorRes, i);\n+        }\n+        for (; i < vectorDim; i++) {\n+            vectorRes[i] = float16ToRawShortBits(divide(shortBitsToFloat16(vector1[i]),\n+                                                        shortBitsToFloat16(vector2[i])));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fmaBenchmark() {\n+        int i = 0;\n+        for (; i < HSPECIES.loopBound(vectorDim); i +=  HSPECIES.length()) {\n+            HalffloatVector.fromArray(HSPECIES, vector1, i)\n+                           .lanewise(VectorOperators.FMA,\n+                                     HalffloatVector.fromArray(HSPECIES, vector2, i),\n+                                     HalffloatVector.fromArray(HSPECIES, vector3, i))\n+                           .intoArray(vectorRes, i);\n+        }\n+        for (; i < vectorDim; i++) {\n+            vectorRes[i] = float16ToRawShortBits(fma(shortBitsToFloat16(vector1[i]),\n+                                                     shortBitsToFloat16(vector2[i]),\n+                                                     shortBitsToFloat16(vector3[i])));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void maxBenchmark() {\n+        int i = 0;\n+        for (; i < HSPECIES.loopBound(vectorDim); i +=  HSPECIES.length()) {\n+            HalffloatVector.fromArray(HSPECIES, vector1, i)\n+                           .lanewise(VectorOperators.MAX,\n+                                     HalffloatVector.fromArray(HSPECIES, vector2, i))\n+                           .intoArray(vectorRes, i);\n+        }\n+        for (; i < vectorDim; i++) {\n+            vectorRes[i] = float16ToRawShortBits(max(shortBitsToFloat16(vector1[i]),\n+                                                     shortBitsToFloat16(vector2[i])));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void minBenchmark() {\n+        int i = 0;\n+        for (; i < HSPECIES.loopBound(vectorDim); i +=  HSPECIES.length()) {\n+            HalffloatVector.fromArray(HSPECIES, vector1, i)\n+                           .lanewise(VectorOperators.MIN,\n+                                     HalffloatVector.fromArray(HSPECIES, vector2, i))\n+                           .intoArray(vectorRes, i);\n+        }\n+        for (; i < vectorDim; i++) {\n+            vectorRes[i] = float16ToRawShortBits(min(shortBitsToFloat16(vector1[i]),\n+                                                     shortBitsToFloat16(vector2[i])));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void sqrtBenchmark() {\n+        int i = 0;\n+        for (; i < HSPECIES.loopBound(vectorDim); i +=  HSPECIES.length()) {\n+            HalffloatVector.fromArray(HSPECIES, vector1, i)\n+                           .lanewise(VectorOperators.SQRT)\n+                           .intoArray(vectorRes, i);\n+        }\n+        for (; i < vectorDim; i++) {\n+            vectorRes[i] = float16ToRawShortBits(sqrt(shortBitsToFloat16(vector1[i])));\n+        }\n+    }\n+\n+    @Benchmark\n+    public short cosineSimilarityDoubleRoundingFP16() {\n+        int i = 0;\n+        HalffloatVector macResVec = HalffloatVector.broadcast(HSPECIES, (short)0);\n+        HalffloatVector vector1SquareVec = HalffloatVector.broadcast(HSPECIES, (short)0);\n+        HalffloatVector vector2SquareVec = HalffloatVector.broadcast(HSPECIES, (short)0);\n+        \/\/ cosine distance = (VEC1 . VEC2) \/ ||VEC1||.||VEC2||\n+        for (; i < HSPECIES.loopBound(vectorDim); i += HSPECIES.length()) {\n+            \/\/ Explicit add and multiply operation ensures double rounding.\n+            HalffloatVector vec1 = HalffloatVector.fromArray(HSPECIES, vector1, i);\n+            HalffloatVector vec2 = HalffloatVector.fromArray(HSPECIES, vector2, i);\n+            macResVec = vec1.lanewise(VectorOperators.MUL, vec2)\n+                            .lanewise(VectorOperators.ADD, macResVec);\n+            vector1SquareVec = vec1.lanewise(VectorOperators.MUL, vec1)\n+                                .lanewise(VectorOperators.ADD, vector1SquareVec);\n+            vector2SquareVec = vec2.lanewise(VectorOperators.MUL, vec2)\n+                                .lanewise(VectorOperators.ADD, vector2SquareVec);\n+        }\n+        short macRes =  macResVec.lanewise(VectorOperators.DIV,\n+                                           vector1SquareVec.lanewise(VectorOperators.MUL,\n+                                                                  vector2SquareVec))\n+                                 .reduceLanes(VectorOperators.ADD);\n+\n+        short vector1Square = floatToFloat16(0.0f);\n+        short vector2Square = floatToFloat16(0.0f);\n+        for (; i < vectorDim; i++) {\n+            \/\/ Explicit add and multiply operation ensures double rounding.\n+            Float16 vec1 = shortBitsToFloat16(vector1[i]);\n+            Float16 vec2 = shortBitsToFloat16(vector2[i]);\n+            macRes = float16ToRawShortBits(add(multiply(vec1, vec2),\n+                                               shortBitsToFloat16(macRes)));\n+            vector1Square = float16ToRawShortBits(add(multiply(vec1, vec1),\n+                                                      shortBitsToFloat16(vector1Square)));\n+            vector2Square = float16ToRawShortBits(add(multiply(vec2, vec2),\n+                                                      shortBitsToFloat16(vector2Square)));\n+        }\n+        return float16ToRawShortBits(divide(shortBitsToFloat16(macRes),\n+                                            multiply(shortBitsToFloat16(vector1Square),\n+                                                     shortBitsToFloat16(vector2Square))));\n+    }\n+\n+    @Benchmark\n+    public short cosineSimilaritySingleRoundingFP16() {\n+        int i = 0;\n+        HalffloatVector macResVec = HalffloatVector.broadcast(HSPECIES, (short)0);\n+        HalffloatVector vector1SquareVec = HalffloatVector.broadcast(HSPECIES, (short)0);\n+        HalffloatVector vector2SquareVec = HalffloatVector.broadcast(HSPECIES, (short)0);\n+        \/\/ cosine distance = (VEC1 . VEC2) \/ ||VEC1||.||VEC2||\n+        for (; i < HSPECIES.loopBound(vectorDim); i += HSPECIES.length()) {\n+            \/\/ Explicit add and multiply operation ensures double rounding.\n+            HalffloatVector vec1 = HalffloatVector.fromArray(HSPECIES, vector1, i);\n+            HalffloatVector vec2 = HalffloatVector.fromArray(HSPECIES, vector2, i);\n+            macResVec = vec1.lanewise(VectorOperators.FMA, vec2, macResVec);\n+            vector1SquareVec = vec1.lanewise(VectorOperators.FMA, vec1, vector1SquareVec);\n+            vector2SquareVec = vec2.lanewise(VectorOperators.FMA, vec2, vector2SquareVec);\n+        }\n+        short macRes =  macResVec.lanewise(VectorOperators.DIV,\n+                                           vector1SquareVec.lanewise(VectorOperators.MUL,\n+                                                                     vector2SquareVec))\n+                                 .reduceLanes(VectorOperators.ADD);\n+\n+        short vector1Square = floatToFloat16(0.0f);\n+        short vector2Square = floatToFloat16(0.0f);\n+        for (; i < vectorDim; i++) {\n+            \/\/ Explicit add and multiply operation ensures double rounding.\n+            Float16 vec1 = shortBitsToFloat16(vector1[i]);\n+            Float16 vec2 = shortBitsToFloat16(vector2[i]);\n+            macRes = float16ToRawShortBits(fma(vec1, vec2,\n+                                               shortBitsToFloat16(macRes)));\n+            vector1Square = float16ToRawShortBits(fma(vec1, vec1,\n+                                                      shortBitsToFloat16(vector1Square)));\n+            vector2Square = float16ToRawShortBits(fma(vec2, vec2,\n+                                                      shortBitsToFloat16(vector2Square)));\n+        }\n+        return float16ToRawShortBits(divide(shortBitsToFloat16(macRes),\n+                                            multiply(shortBitsToFloat16(vector1Square),\n+                                                     shortBitsToFloat16(vector2Square))));\n+    }\n+\n+    @Benchmark\n+    public short euclideanDistanceFP16() {\n+        HalffloatVector resVec = HalffloatVector.broadcast(HSPECIES, (short)0);\n+        int i = 0;\n+        for (; i < HSPECIES.loopBound(vectorDim); i += HSPECIES.length()) {\n+            HalffloatVector diffVec = HalffloatVector.fromArray(HSPECIES, vector1, i)\n+                                                     .lanewise(VectorOperators.SUB,\n+                                                               HalffloatVector.fromArray(HSPECIES, vector2, i));\n+            resVec = diffVec.lanewise(VectorOperators.FMA, diffVec, resVec);\n+        }\n+        short distRes = resVec.lanewise(VectorOperators.SQRT)\n+                              .reduceLanes(VectorOperators.ADD);\n+        short squareRes = floatToFloat16(0.0f);\n+        for (; i < vectorDim; i++) {\n+            squareRes = float16ToRawShortBits(subtract(shortBitsToFloat16(vector1[i]), shortBitsToFloat16(vector2[i])));\n+            distRes = float16ToRawShortBits(fma(shortBitsToFloat16(squareRes), shortBitsToFloat16(squareRes), shortBitsToFloat16(distRes)));\n+        }\n+        return float16ToRawShortBits(sqrt(shortBitsToFloat16(distRes)));\n+    }\n+\n+    @Benchmark\n+    public short dotProductFP16() {\n+        HalffloatVector distResVec = HalffloatVector.broadcast(HSPECIES, (short)0);\n+        int i = 0;\n+        for (; i < HSPECIES.loopBound(vectorDim); i += HSPECIES.length()) {\n+            distResVec = HalffloatVector.fromArray(HSPECIES, vector1, i)\n+                                        .lanewise(VectorOperators.FMA,\n+                                                  HalffloatVector.fromArray(HSPECIES, vector2, i),\n+                                                  distResVec);\n+        }\n+        short distRes = distResVec.reduceLanes(VectorOperators.ADD);\n+        for (; i < vectorDim; i++) {\n+            vectorRes[i] = float16ToRawShortBits(multiply(shortBitsToFloat16(vector1[i]), shortBitsToFloat16(vector2[i])));\n+        }\n+        for (; i < vectorDim; i++) {\n+            distRes = float16ToRawShortBits(add(shortBitsToFloat16(vectorRes[i]), shortBitsToFloat16(distRes)));\n+        }\n+        return distRes;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/HalffloatOperationsBenchmark.java","additions":328,"deletions":0,"binary":false,"changes":328,"status":"added"}]}