{"files":[{"patch":"@@ -142,1 +142,1 @@\n-    heap->generation_sizer()->force_transfer_to_old(regions_transferred_to_old);\n+    heap->force_transfer_to_old(regions_transferred_to_old);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGlobalHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1298,1 +1298,1 @@\n-  bool transferred = gen_heap->generation_sizer()->transfer_to_old(1);\n+  bool transferred = gen_heap->transfer_to_old(1);\n@@ -1571,1 +1571,1 @@\n-      ShenandoahGenerationalHeap::cast(_heap)->generation_sizer()->transfer_to_young(old_collector_regions);\n+      ShenandoahGenerationalHeap::cast(_heap)->transfer_to_young(old_collector_regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -471,1 +471,1 @@\n-    bool result = ShenandoahGenerationalHeap::cast(heap)->generation_sizer()->transfer_to_young(regions_to_xfer);\n+    bool result = ShenandoahGenerationalHeap::cast(heap)->transfer_to_young(regions_to_xfer);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,208 +0,0 @@\n-\/*\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n-#include \"gc\/shenandoah\/shenandoahGenerationSizer.hpp\"\n-#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n-#include \"gc\/shenandoah\/shenandoahHeapRegion.hpp\"\n-#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n-#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n-#include \"gc\/shared\/gc_globals.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"runtime\/globals_extension.hpp\"\n-\n-\n-ShenandoahGenerationSizer::ShenandoahGenerationSizer()\n-        : _sizer_kind(SizerDefaults),\n-          _min_desired_young_regions(0),\n-          _max_desired_young_regions(0) {\n-\n-  if (FLAG_IS_CMDLINE(NewRatio)) {\n-    if (FLAG_IS_CMDLINE(NewSize) || FLAG_IS_CMDLINE(MaxNewSize)) {\n-      log_warning(gc, ergo)(\"-XX:NewSize and -XX:MaxNewSize override -XX:NewRatio\");\n-    } else {\n-      _sizer_kind = SizerNewRatio;\n-      return;\n-    }\n-  }\n-\n-  if (NewSize > MaxNewSize) {\n-    if (FLAG_IS_CMDLINE(MaxNewSize)) {\n-      log_warning(gc, ergo)(\"NewSize (%zuk) is greater than the MaxNewSize (%zuk). \"\n-                            \"A new max generation size of %zuk will be used.\",\n-              NewSize\/K, MaxNewSize\/K, NewSize\/K);\n-    }\n-    FLAG_SET_ERGO(MaxNewSize, NewSize);\n-  }\n-\n-  if (FLAG_IS_CMDLINE(NewSize)) {\n-    _min_desired_young_regions = MAX2(uint(NewSize \/ ShenandoahHeapRegion::region_size_bytes()), 1U);\n-    if (FLAG_IS_CMDLINE(MaxNewSize)) {\n-      _max_desired_young_regions = MAX2(uint(MaxNewSize \/ ShenandoahHeapRegion::region_size_bytes()), 1U);\n-      _sizer_kind = SizerMaxAndNewSize;\n-    } else {\n-      _sizer_kind = SizerNewSizeOnly;\n-    }\n-  } else if (FLAG_IS_CMDLINE(MaxNewSize)) {\n-    _max_desired_young_regions = MAX2(uint(MaxNewSize \/ ShenandoahHeapRegion::region_size_bytes()), 1U);\n-    _sizer_kind = SizerMaxNewSizeOnly;\n-  }\n-}\n-\n-size_t ShenandoahGenerationSizer::calculate_min_young_regions(size_t heap_region_count) {\n-  size_t min_young_regions = (heap_region_count * ShenandoahMinYoungPercentage) \/ 100;\n-  return MAX2(min_young_regions, (size_t) 1U);\n-}\n-\n-size_t ShenandoahGenerationSizer::calculate_max_young_regions(size_t heap_region_count) {\n-  size_t max_young_regions = (heap_region_count * ShenandoahMaxYoungPercentage) \/ 100;\n-  return MAX2(max_young_regions, (size_t) 1U);\n-}\n-\n-void ShenandoahGenerationSizer::recalculate_min_max_young_length(size_t heap_region_count) {\n-  assert(heap_region_count > 0, \"Heap must be initialized\");\n-\n-  switch (_sizer_kind) {\n-    case SizerDefaults:\n-      _min_desired_young_regions = calculate_min_young_regions(heap_region_count);\n-      _max_desired_young_regions = calculate_max_young_regions(heap_region_count);\n-      break;\n-    case SizerNewSizeOnly:\n-      _max_desired_young_regions = calculate_max_young_regions(heap_region_count);\n-      _max_desired_young_regions = MAX2(_min_desired_young_regions, _max_desired_young_regions);\n-      break;\n-    case SizerMaxNewSizeOnly:\n-      _min_desired_young_regions = calculate_min_young_regions(heap_region_count);\n-      _min_desired_young_regions = MIN2(_min_desired_young_regions, _max_desired_young_regions);\n-      break;\n-    case SizerMaxAndNewSize:\n-      \/\/ Do nothing. Values set on the command line, don't update them at runtime.\n-      break;\n-    case SizerNewRatio:\n-      _min_desired_young_regions = MAX2(uint(heap_region_count \/ (NewRatio + 1)), 1U);\n-      _max_desired_young_regions = _min_desired_young_regions;\n-      break;\n-    default:\n-      ShouldNotReachHere();\n-  }\n-\n-  assert(_min_desired_young_regions <= _max_desired_young_regions, \"Invalid min\/max young gen size values\");\n-}\n-\n-void ShenandoahGenerationSizer::heap_size_changed(size_t heap_size) {\n-  recalculate_min_max_young_length(heap_size \/ ShenandoahHeapRegion::region_size_bytes());\n-}\n-\n-bool ShenandoahGenerationSizer::transfer_regions(ShenandoahGeneration* src, ShenandoahGeneration* dst, size_t regions) const {\n-  const size_t bytes_to_transfer = regions * ShenandoahHeapRegion::region_size_bytes();\n-\n-  if (src->free_unaffiliated_regions() < regions) {\n-    \/\/ Source does not have enough free regions for this transfer. The caller should have\n-    \/\/ already capped the transfer based on available unaffiliated regions.\n-    return false;\n-  }\n-\n-  if (dst->max_capacity() + bytes_to_transfer > max_size_for(dst)) {\n-    \/\/ This transfer would cause the destination generation to grow above its configured maximum size.\n-    return false;\n-  }\n-\n-  if (src->max_capacity() - bytes_to_transfer < min_size_for(src)) {\n-    \/\/ This transfer would cause the source generation to shrink below its configured minimum size.\n-    return false;\n-  }\n-\n-  src->decrease_capacity(bytes_to_transfer);\n-  dst->increase_capacity(bytes_to_transfer);\n-  const size_t new_size = dst->max_capacity();\n-  log_info(gc, ergo)(\"Transfer %zu region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n-                     regions, src->name(), dst->name(), PROPERFMTARGS(new_size));\n-  return true;\n-}\n-\n-\n-size_t ShenandoahGenerationSizer::max_size_for(ShenandoahGeneration* generation) const {\n-  switch (generation->type()) {\n-    case YOUNG:\n-      return max_young_size();\n-    case OLD:\n-      \/\/ On the command line, max size of OLD is specified indirectly, by setting a minimum size of young.\n-      \/\/ OLD is what remains within the heap after YOUNG has been sized.\n-      return ShenandoahHeap::heap()->max_capacity() - min_young_size();\n-    default:\n-      ShouldNotReachHere();\n-      return 0;\n-  }\n-}\n-\n-size_t ShenandoahGenerationSizer::min_size_for(ShenandoahGeneration* generation) const {\n-  switch (generation->type()) {\n-    case YOUNG:\n-      return min_young_size();\n-    case OLD:\n-      \/\/ On the command line, min size of OLD is specified indirectly, by setting a maximum size of young.\n-      \/\/ OLD is what remains within the heap after YOUNG has been sized.\n-      return ShenandoahHeap::heap()->max_capacity() - max_young_size();\n-    default:\n-      ShouldNotReachHere();\n-      return 0;\n-  }\n-}\n-\n-\n-\/\/ Returns true iff transfer is successful\n-bool ShenandoahGenerationSizer::transfer_to_old(size_t regions) const {\n-  ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n-  return transfer_regions(heap->young_generation(), heap->old_generation(), regions);\n-}\n-\n-\/\/ This is used when promoting humongous or highly utilized regular regions in place.  It is not required in this situation\n-\/\/ that the transferred regions be unaffiliated.\n-void ShenandoahGenerationSizer::force_transfer_to_old(size_t regions) const {\n-  ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n-  ShenandoahGeneration* old_gen = heap->old_generation();\n-  ShenandoahGeneration* young_gen = heap->young_generation();\n-  const size_t bytes_to_transfer = regions * ShenandoahHeapRegion::region_size_bytes();\n-\n-  young_gen->decrease_capacity(bytes_to_transfer);\n-  old_gen->increase_capacity(bytes_to_transfer);\n-  const size_t new_size = old_gen->max_capacity();\n-  log_info(gc, ergo)(\"Forcing transfer of %zu region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n-                     regions, young_gen->name(), old_gen->name(), PROPERFMTARGS(new_size));\n-}\n-\n-\n-bool ShenandoahGenerationSizer::transfer_to_young(size_t regions) const {\n-  ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n-  return transfer_regions(heap->old_generation(), heap->young_generation(), regions);\n-}\n-\n-size_t ShenandoahGenerationSizer::min_young_size() const {\n-  return min_young_regions() * ShenandoahHeapRegion::region_size_bytes();\n-}\n-\n-size_t ShenandoahGenerationSizer::max_young_size() const {\n-  return max_young_regions() * ShenandoahHeapRegion::region_size_bytes();\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationSizer.cpp","additions":0,"deletions":208,"binary":false,"changes":208,"status":"deleted"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONSIZER_HPP\n-#define SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONSIZER_HPP\n-\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-class ShenandoahGeneration;\n-class ShenandoahGenerationalHeap;\n-\n-class ShenandoahGenerationSizer {\n-private:\n-  enum SizerKind {\n-    SizerDefaults,\n-    SizerNewSizeOnly,\n-    SizerMaxNewSizeOnly,\n-    SizerMaxAndNewSize,\n-    SizerNewRatio\n-  };\n-  SizerKind _sizer_kind;\n-\n-  size_t _min_desired_young_regions;\n-  size_t _max_desired_young_regions;\n-\n-  static size_t calculate_min_young_regions(size_t heap_region_count);\n-  static size_t calculate_max_young_regions(size_t heap_region_count);\n-\n-  \/\/ Update the given values for minimum and maximum young gen length in regions\n-  \/\/ given the number of heap regions depending on the kind of sizing algorithm.\n-  void recalculate_min_max_young_length(size_t heap_region_count);\n-\n-  \/\/ This will attempt to transfer regions from the `src` generation to `dst` generation.\n-  \/\/ If the transfer would violate the configured minimum size for the source or the configured\n-  \/\/ maximum size of the destination, it will not perform the transfer and will return false.\n-  \/\/ Returns true if the transfer is performed.\n-  bool transfer_regions(ShenandoahGeneration* src, ShenandoahGeneration* dst, size_t regions) const;\n-\n-  \/\/ Return the configured maximum size in bytes for the given generation.\n-  size_t max_size_for(ShenandoahGeneration* generation) const;\n-\n-  \/\/ Return the configured minimum size in bytes for the given generation.\n-  size_t min_size_for(ShenandoahGeneration* generation) const;\n-\n-public:\n-  ShenandoahGenerationSizer();\n-\n-  \/\/ Calculate the maximum length of the young gen given the number of regions\n-  \/\/ depending on the sizing algorithm.\n-  void heap_size_changed(size_t heap_size);\n-\n-  \/\/ Minimum size of young generation in bytes as multiple of region size.\n-  size_t min_young_size() const;\n-  size_t min_young_regions() const {\n-    return _min_desired_young_regions;\n-  }\n-\n-  \/\/ Maximum size of young generation in bytes as multiple of region size.\n-  size_t max_young_size() const;\n-  size_t max_young_regions() const {\n-    return _max_desired_young_regions;\n-  }\n-\n-  \/\/ True if transfer succeeds, else false. See transfer_regions.\n-  bool transfer_to_young(size_t regions) const;\n-  bool transfer_to_old(size_t regions) const;\n-\n-  \/\/ force transfer is used when we promote humongous objects.  May violate min\/max limits on generation sizes\n-  void force_transfer_to_old(size_t regions) const;\n-};\n-\n-#endif \/\/SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONSIZER_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationSizer.hpp","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -247,1 +247,1 @@\n-    _heap->generation_sizer()->force_transfer_to_old(1);\n+    _heap->force_transfer_to_old(1);\n@@ -289,1 +289,1 @@\n-    _heap->generation_sizer()->force_transfer_to_old(spanned_regions);\n+    _heap->force_transfer_to_old(spanned_regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalEvacuationTask.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-    gen_heap->generation_sizer()->transfer_to_young(excess_old_regions);\n+    gen_heap->transfer_to_young(excess_old_regions);\n@@ -123,1 +123,1 @@\n-    gen_heap->generation_sizer()->force_transfer_to_old(old_regions_deficit);\n+    gen_heap->force_transfer_to_old(old_regions_deficit);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -134,2 +134,1 @@\n-  \/\/ Max capacity is the maximum _allowed_ capacity. That is, the maximum allowed capacity\n-  \/\/ for old would be total heap - minimum capacity of young. This means the sum of the maximum\n+  \/\/ Max capacity is the maximum _allowed_ capacity. This means the sum of the maximum\n@@ -138,8 +137,6 @@\n-  _generation_sizer.heap_size_changed(max_capacity());\n-  size_t initial_capacity_young = _generation_sizer.max_young_size();\n-  size_t max_capacity_young = _generation_sizer.max_young_size();\n-  size_t initial_capacity_old = max_capacity() - max_capacity_young;\n-  size_t max_capacity_old = max_capacity() - initial_capacity_young;\n-\n-  _young_generation = new ShenandoahYoungGeneration(max_workers(), max_capacity_young, initial_capacity_young);\n-  _old_generation = new ShenandoahOldGeneration(max_workers(), max_capacity_old, initial_capacity_old);\n+  const size_t max_heap_capacity = max_capacity();\n+  const size_t initial_capacity_young = initial_young_size();\n+  const size_t initial_capacity_old = max_heap_capacity - initial_capacity_young;\n+\n+  _young_generation = new ShenandoahYoungGeneration(max_workers(), max_heap_capacity, initial_capacity_young);\n+  _old_generation = new ShenandoahOldGeneration(max_workers(), max_heap_capacity, initial_capacity_old);\n@@ -584,1 +581,1 @@\n-ShenandoahGenerationalHeap::TransferResult ShenandoahGenerationalHeap::balance_generations() {\n+ShenandoahGenerationalHeap::TransferResult ShenandoahGenerationalHeap::balance_generations() const {\n@@ -593,1 +590,1 @@\n-    const bool success = generation_sizer()->transfer_to_young(old_region_surplus);\n+    const bool success = transfer_to_young(old_region_surplus);\n@@ -601,1 +598,1 @@\n-    const bool success = generation_sizer()->transfer_to_old(old_region_deficit);\n+    const bool success = transfer_to_old(old_region_deficit);\n@@ -704,0 +701,38 @@\n+\/\/ Returns true iff transfer is successful\n+bool ShenandoahGenerationalHeap::transfer_to_old(size_t regions) const {\n+  return transfer_regions(young_generation(), old_generation(), regions);\n+}\n+\n+\/\/ Returns true iff transfer is successful\n+bool ShenandoahGenerationalHeap::transfer_to_young(size_t regions) const {\n+  return transfer_regions(old_generation(), young_generation(), regions);\n+}\n+\n+\/\/ This is used when promoting humongous or highly utilized regular regions in place.  It is not required in this situation\n+\/\/ that the transferred regions be unaffiliated.\n+void ShenandoahGenerationalHeap::force_transfer_to_old(size_t regions) const {\n+  const bool transferred = transfer_regions(young_generation(), old_generation(), regions, true \/* force *\/);\n+  assert(transferred, \"Forced transfer must succeed\");\n+}\n+\n+bool ShenandoahGenerationalHeap::transfer_regions(ShenandoahGeneration* src, ShenandoahGeneration* dst, size_t regions, bool force) {\n+\n+  if (!force && src->free_unaffiliated_regions() < regions) {\n+    \/\/ Source does not have enough free regions for this transfer. The caller should have\n+    \/\/ already capped the transfer based on available unaffiliated regions.\n+    return false;\n+  }\n+\n+  const size_t bytes_to_transfer = regions * ShenandoahHeapRegion::region_size_bytes();\n+  src->decrease_capacity(bytes_to_transfer);\n+  dst->increase_capacity(bytes_to_transfer);\n+  const size_t new_size = dst->max_capacity();\n+  log_info(gc, ergo)(\"Transfer %s %zu region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n+                     (force ? \" (forced)\" : \"\"), regions, src->name(), dst->name(), PROPERFMTARGS(new_size));\n+  return true;\n+}\n+\n+size_t ShenandoahGenerationalHeap::initial_young_size() const {\n+  return static_cast<size_t>(percent_of(ShenandoahInitYoungPercentage, num_regions())) * ShenandoahHeapRegion::region_size_bytes();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":48,"deletions":13,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -119,0 +119,3 @@\n+  \/\/ Initial size of young generation in bytes as a multiple of region size.\n+  size_t initial_young_size() const;\n+\n@@ -140,2 +143,0 @@\n-  const ShenandoahGenerationSizer* generation_sizer()  const { return &_generation_sizer;  }\n-\n@@ -149,1 +150,5 @@\n-  TransferResult balance_generations();\n+  TransferResult balance_generations() const;\n+\n+  \/\/ True if transfer succeeds, else false. See transfer_regions.\n+  bool transfer_to_young(size_t regions) const;\n+  bool transfer_to_old(size_t regions) const;\n@@ -151,0 +156,11 @@\n+  \/\/ force transfer is used when we promote humongous objects.  May violate min\/max limits on generation sizes\n+  void force_transfer_to_old(size_t regions) const;\n+\n+private:\n+  \/\/ This will attempt to transfer regions from the `src` generation to `dst` generation.\n+  \/\/ If the transfer would violate the configured minimum size for the source or the configured\n+  \/\/ maximum size of the destination, it will not perform the transfer and will return false.\n+  \/\/ Returns true if the transfer is performed.\n+  static bool transfer_regions(ShenandoahGeneration* src, ShenandoahGeneration* dst, size_t regions, bool force = false);\n+\n+public:\n@@ -154,0 +170,1 @@\n+\n@@ -165,2 +182,0 @@\n-\n-  ShenandoahGenerationSizer     _generation_sizer;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.hpp","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-#include \"gc\/shenandoah\/shenandoahGenerationSizer.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -397,10 +397,4 @@\n-  product(uintx, ShenandoahMinYoungPercentage, 20, EXPERIMENTAL,            \\\n-          \"The minimum percentage of the heap to use for the young \"        \\\n-          \"generation. Heuristics will not adjust the young generation \"    \\\n-          \"to be less than this.\")                                          \\\n-          range(0, 100)                                                     \\\n-                                                                            \\\n-  product(uintx, ShenandoahMaxYoungPercentage, 100, EXPERIMENTAL,           \\\n-          \"The maximum percentage of the heap to use for the young \"        \\\n-          \"generation. Heuristics will not adjust the young generation \"    \\\n-          \"to be more than this.\")                                          \\\n+  product(uintx, ShenandoahInitYoungPercentage, 80, EXPERIMENTAL,           \\\n+          \"The initial percentage of the heap to use for the young \"        \\\n+          \"generation. Heuristics may adjust the size of the young \"        \\\n+           \"generation to be more or less than this.\")                      \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"}]}