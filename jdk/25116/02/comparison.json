{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -425,0 +425,1 @@\n+                final ZipEntry currentEntry = entry;\n@@ -426,0 +427,5 @@\n+                if (currentEntry.crc != crc.getValue()) {\n+                    throw new ZipException(\"invalid entry CRC (expected 0x\"\n+                            + Long.toHexString(currentEntry.crc)\n+                            + \" but got 0x\" + Long.toHexString(crc.getValue()) + \")\");\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipInputStream.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.zip.CRC32;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n+import java.util.zip.ZipInputStream;\n+import java.util.zip.ZipOutputStream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8354799\n+ * @summary verifies that when using java.util.zip.ZipInputStream any incorrect CRC values for\n+ *          entries results in an exception when reading those entries\n+ * @run junit ZipInputStreamCRCCheck\n+ *\/\n+public class ZipInputStreamCRCCheck {\n+\n+    static List<Arguments> args() {\n+        return List.of(\n+                Arguments.of(ZipOutputStream.STORED, 10),\n+                Arguments.of(ZipOutputStream.STORED, 0),\n+                Arguments.of(ZipOutputStream.STORED, 1024),\n+                Arguments.of(ZipOutputStream.DEFLATED, 10),\n+                Arguments.of(ZipOutputStream.DEFLATED, 0),\n+                Arguments.of(ZipOutputStream.DEFLATED, 1024)\n+        );\n+    }\n+\n+    \/*\n+     * Creates a ZIP file containing an entry whose CRC value is set to an incorrect\n+     * value. The test then uses java.util.zip.ZipInputStream to read that ZIP file\n+     * and verifies that reading the entry's contents results in a ZipException due\n+     * to the incorrect CRC value.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"args\")\n+    void test(final int entryMethod, final int entrySize) throws Exception {\n+        final String entryName = entryMethod == ZipOutputStream.STORED\n+                ? \"stored-entry-size=\" + entrySize\n+                : \"deflated-entry-size=\" + entrySize;\n+        System.out.println(\"creating ZIP with entry \" + entryName);\n+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        try (final ZipOutputStream zos = new ZipOutputStream(baos)) {\n+\n+            final ZipEntry entry = new ZipEntry(entryName);\n+            entry.setSize(entrySize);\n+            entry.setMethod(entryMethod);\n+\n+            final byte[] entryContent = new byte[entrySize];\n+            final CRC32 crc = new CRC32();\n+            crc.update(entryContent);\n+            entry.setCrc(crc.getValue());\n+\n+            zos.putNextEntry(entry);\n+            zos.write(entryContent);\n+            zos.closeEntry();\n+        }\n+        final byte[] zipContent = baos.toByteArray();\n+        \/\/ now change the CRC value of the entry to an incorrect value\n+        changeEntryCRCValue(zipContent);\n+        \/\/ use ZipInputStream to read the entry from that ZIP containing the incorrect CRC value\n+        try (final ZipInputStream zis = new ZipInputStream(new ByteArrayInputStream(zipContent))) {\n+            final ZipEntry entry = zis.getNextEntry();\n+            assertEquals(entryName, entry.getName(), \"unexpected entry name\");\n+            final ZipException zipEx = assertThrows(ZipException.class, () -> {\n+                zis.readAllBytes();\n+                zis.closeEntry();\n+            }, \"expected to fail due to CRC error but didn't, computed crc=\" + entry.getCrc());\n+            assertNotNull(zipEx.getMessage(), \"missing exception message\");\n+            assertTrue(zipEx.getMessage().contains(\"invalid entry CRC\"),\n+                    \"Expected exception message to contain 'invalid entry CRC' but was \"\n+                            + zipEx.getMessage());\n+        }\n+    }\n+\n+    \/*\n+     * Updates the CRC value of the (sole) entry in the ZIP to an incorrect value\n+     *\/\n+    private static void changeEntryCRCValue(final byte[] zipContent) {\n+        final ByteBuffer bb = ByteBuffer.wrap(zipContent).order(ByteOrder.LITTLE_ENDIAN);\n+        final boolean hasDataDescriptor = (bb.position(6).getShort() & 8) != 0;\n+        \/\/ the offset corresponding to either the entry's LOC or the entry's data descriptor\n+        \/\/ where the CRC value should be updated\n+        final int crcOffset;\n+        \/\/ the CRC value that's currently present at the determined CRC offset\n+        final int currentCRC;\n+        if (hasDataDescriptor) {\n+            final int ddSigStart = findDataDescriptor(bb);\n+            \/\/ CRC value resides 4 bytes after the start of the data descriptor signature\n+            crcOffset = ddSigStart + 4;\n+        } else {\n+            \/\/ CRC value resides 14 bytes after the start of the LOC (which starts at the\n+            \/\/ beginning of the ZIP content)\n+            crcOffset = 14;\n+        }\n+        currentCRC = bb.position(crcOffset).getInt();\n+        \/\/ update the CRC value to an arbitrary value\n+        bb.position(crcOffset).putInt(currentCRC + 1);\n+        System.out.println(\"tampered the crc value\"\n+                + \" from 0x\" + Integer.toHexString(currentCRC)\n+                + \" to 0x\" + Integer.toHexString(bb.position(crcOffset).getInt()));\n+    }\n+\n+    \/*\n+     * Finds and returns the offset where the data descriptor starts within the ZIP content\n+     *\/\n+    private static int findDataDescriptor(final ByteBuffer zipContent) {\n+        final int DD_SIG = 0x08074b50; \/\/ (standard) data descriptor signature\n+        zipContent.rewind();\n+        while (zipContent.hasRemaining()) {\n+            final int pos = zipContent.position();\n+            if (zipContent.remaining() < 4) {\n+                break; \/\/ not enough content\n+            }\n+            final int fourBytes = zipContent.getInt(pos);\n+            if (fourBytes == DD_SIG) {\n+                return pos;\n+            }\n+            zipContent.position(pos + 1);\n+        }\n+        throw new RuntimeException(\"Missing data descriptor\");\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipInputStream\/ZipInputStreamCRCCheck.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"}]}