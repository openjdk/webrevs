{"files":[{"patch":"@@ -40,0 +40,1 @@\n+#include \"runtime\/thread.inline.hpp\"\n@@ -453,1 +454,2 @@\n-* to exit the VM after a hard-coded timeout (disallow WatcherThread to emergency dump).\n+* to exit the VM after a hard-coded timeout (the reason\n+* for disallowing the WatcherThread to issue an emergency dump).\n@@ -457,1 +459,1 @@\n-static bool prepare_for_emergency_dump(Thread* thread) {\n+static void release_locks(Thread* thread) {\n@@ -459,4 +461,0 @@\n-  if (thread->is_Watcher_thread()) {\n-    \/\/ need WatcherThread as a safeguard against potential deadlocks\n-    return false;\n-  }\n@@ -520,7 +518,0 @@\n-  return true;\n-}\n-\n-static volatile int jfr_shutdown_lock = 0;\n-\n-static bool guard_reentrancy() {\n-  return AtomicAccess::cmpxchg(&jfr_shutdown_lock, 0, 1) == 0;\n@@ -574,0 +565,27 @@\n+static volatile traceid _jfr_shutdown_tid = 0;\n+\n+static bool guard_reentrancy() {\n+  const traceid shutdown_tid = AtomicAccess::load(&_jfr_shutdown_tid);\n+  if (shutdown_tid == max_julong) {\n+    \/\/ Someone tried but did not have a proper thread for the purpose.\n+    return false;\n+  }\n+  if (shutdown_tid == 0) {\n+    Thread* const thread = Thread::current_or_null_safe();\n+    const traceid tid = thread != nullptr ? JFR_JVM_THREAD_ID(thread) : max_julong;\n+    if (AtomicAccess::cmpxchg(&_jfr_shutdown_tid, shutdown_tid, tid) != shutdown_tid) {\n+      if (thread != nullptr) {\n+        JavaThreadInVMAndNative jtivm(thread);\n+        release_locks(thread);\n+      }\n+      log_info(jfr, system)(\"A jfr emergency dump is already in progress, waiting for thread id \" UINT64_FORMAT_X, AtomicAccess::load(&_jfr_shutdown_tid));\n+      os::infinite_sleep(); \/\/ stay here until we exit normally or crash.\n+      ShouldNotReachHere();\n+    }\n+    return tid != max_julong;\n+  }\n+  \/\/ Recursive case\n+  assert(JFR_JVM_THREAD_ID(Thread::current_or_null_safe()) == shutdown_tid, \"invariant\");\n+  return false;\n+}\n+\n@@ -578,2 +596,4 @@\n-  Thread* thread = Thread::current_or_null_safe();\n-  if (thread == nullptr) {\n+  Thread* const thread = Thread::current_or_null_safe();\n+  assert(thread != nullptr, \"invariant\");\n+  if (thread->is_Watcher_thread()) {\n+    log_info(jfr, system)(\"The Watcher thread crashed so no jfr emergency dump will be generated.\");\n@@ -584,3 +604,1 @@\n-  if (!prepare_for_emergency_dump(thread)) {\n-    return;\n-  }\n+  release_locks(thread);\n@@ -588,0 +606,1 @@\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrEmergencyDump.cpp","additions":37,"deletions":18,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -510,0 +510,1 @@\n+    stop();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}