{"files":[{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.module.InvalidModuleDescriptorException;\n@@ -42,0 +43,4 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.lang.model.SourceVersion;\n@@ -116,11 +121,45 @@\n-        try (var stream = Files.find(sourceRootPath, 99, (path, attr) -> attr.isDirectory())) {\n-            var names = new TreeSet<String>();\n-            stream.filter(ProgramDescriptor::containsAtLeastOneRegularFile)\n-                  .map(sourceRootPath::relativize)\n-                  .map(Path::toString)\n-                  .filter(string -> !string.isEmpty())\n-                  .map(string -> string.replace(File.separatorChar, '.'))\n-                  .forEach(names::add);\n-            return names;\n-        } catch (IOException exception) {\n-            throw new UncheckedIOException(exception);\n+        return explodedPackages(sourceRootPath);\n+    }\n+\n+    \/\/ -- exploded directories --> based on jdk.internal.module.ModulePath\n+\n+    private static Set<String> explodedPackages(Path dir) {\n+        String separator = dir.getFileSystem().getSeparator();\n+        try (Stream<Path> stream = Files.find(dir, Integer.MAX_VALUE,\n+                (path, attrs) -> attrs.isRegularFile() && !isHidden(path))) {\n+            return stream.map(dir::relativize)\n+                    .map(path -> toPackageName(path, separator))\n+                    .flatMap(Optional::stream)\n+                    .collect(Collectors.toSet());\n+        } catch (IOException x) {\n+            throw new UncheckedIOException(x);\n+        }\n+    }\n+\n+    \/**\n+     * Maps the relative path of an entry in an exploded module to a package\n+     * name.\n+     *\n+     * @throws InvalidModuleDescriptorException if the name is a class file in\n+     *         the top-level directory (and it's not module-info.class)\n+     *\/\n+    private static Optional<String> toPackageName(Path file, String separator) {\n+        assert file.getRoot() == null;\n+\n+        Path parent = file.getParent();\n+        if (parent == null) {\n+            String name = file.toString();\n+            if (name.endsWith(\".class\") && !name.equals(\"module-info.class\")) {\n+                String msg = name + \" found in top-level directory\"\n+                        + \" (unnamed package not allowed in module)\";\n+                throw new InvalidModuleDescriptorException(msg);\n+            }\n+            return Optional.empty();\n+        }\n+\n+        String pn = parent.toString().replace(separator, \".\");\n+        if (SourceVersion.isName(pn)) {\n+            return Optional.of(pn);\n+        } else {\n+            \/\/ not a valid package name\n+            return Optional.empty();\n@@ -130,5 +169,8 @@\n-    private static boolean containsAtLeastOneRegularFile(Path directory) {\n-        try (var stream = Files.newDirectoryStream(directory, Files::isRegularFile)) {\n-            return stream.iterator().hasNext();\n-        } catch (IOException exception) {\n-            throw new UncheckedIOException(exception);\n+    \/**\n+     * Returns true if the given file exists and is a hidden file\n+     *\/\n+    private static boolean isHidden(Path file) {\n+        try {\n+            return Files.isHidden(file);\n+        } catch (IOException ioe) {\n+            return false;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/ProgramDescriptor.java","additions":58,"deletions":16,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8304400\n+ * @bug 8304400 8332226\n@@ -115,0 +115,2 @@\n+        var badFolder = Files.createDirectories(base.resolve(\".bad\"));\n+        Files.writeString(badFolder.resolve(\"bad.txt\"), \"bad\");\n@@ -143,0 +145,1 @@\n+            var actual = reader.list().toList();\n@@ -145,0 +148,2 @@\n+                    .bad\/\n+                    .bad\/bad.txt\n@@ -155,2 +160,2 @@\n-                    \"\"\".lines(),\n-                    reader.list());\n+                    \"\"\".lines().toList(),\n+                    actual, \"Actual lines -> \" + actual);\n","filename":"test\/langtools\/tools\/javac\/launcher\/ModuleSourceLauncherTests.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"}]}