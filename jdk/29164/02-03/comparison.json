{"files":[{"patch":"@@ -284,1 +284,1 @@\n-macro(OpaqueCheck)\n+macro(OpaqueConstantBool)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -591,1 +591,1 @@\n-          \/\/ We may have an OpaqueCheck node between If and Bool nodes. But we could also have a sub class of IfNode,\n+          \/\/ We may have an OpaqueConstantBool node between If and Bool nodes. But we could also have a sub class of IfNode,\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1475,1 +1475,1 @@\n-\/\/ an OpaqueCheck node that will cause the check to be removed after loop\n+\/\/ an OpaqueConstantBool node that will cause the check to be removed after loop\n@@ -1484,1 +1484,1 @@\n-  Node* opaq = _gvn.transform(new OpaqueCheckNode(C, tst, true));\n+  Node* opaq = _gvn.transform(new OpaqueConstantBoolNode(C, tst, true));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -902,1 +902,1 @@\n-    bol_lt = _gvn.transform(new OpaqueCheckNode(C, bol_lt, false));\n+    bol_lt = _gvn.transform(new OpaqueConstantBoolNode(C, bol_lt, false));\n@@ -943,1 +943,1 @@\n-    bol_lt = _gvn.transform(new OpaqueCheckNode(C, bol_lt, false));\n+    bol_lt = _gvn.transform(new OpaqueConstantBoolNode(C, bol_lt, false));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1237,1 +1237,1 @@\n-        assert(bol->is_OpaqueCheck() ||\n+        assert(bol->is_OpaqueConstantBool() ||\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1707,1 +1707,1 @@\n-      !n->is_OpaqueCheck() &&\n+      !n->is_OpaqueConstantBool() &&\n@@ -2048,2 +2048,2 @@\n-      assert(b->is_Bool() || b->is_OpaqueCheck() || b->is_OpaqueInitializedAssertionPredicate(),\n-             \"bool, non-null check with OpaqueCheck or Initialized Assertion Predicate with its Opaque node\");\n+      assert(b->is_Bool() || b->is_OpaqueConstantBool() || b->is_OpaqueInitializedAssertionPredicate(),\n+             \"bool, non-null check with OpaqueConstantBool or Initialized Assertion Predicate with its Opaque node\");\n@@ -2055,1 +2055,1 @@\n-  if (n->is_OpaqueCheck() || n->is_OpaqueInitializedAssertionPredicate()) {\n+  if (n->is_OpaqueConstantBool() || n->is_OpaqueInitializedAssertionPredicate()) {\n@@ -2231,1 +2231,1 @@\n-      if (use->is_If() || use->is_CMove() || use->is_OpaqueCheck() || use->is_OpaqueInitializedAssertionPredicate() ||\n+      if (use->is_If() || use->is_CMove() || use->is_OpaqueConstantBool() || use->is_OpaqueInitializedAssertionPredicate() ||\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2503,1 +2503,1 @@\n-               n->is_OpaqueCheck()    ||\n+               n->is_OpaqueConstantBool()    ||\n@@ -2551,2 +2551,2 @@\n-      } else if (n->is_OpaqueCheck()) {\n-        \/\/ Tests with OpaqueCheck nodes are implicitly known. Replace the node with true\/false. In debug builds,\n+      } else if (n->is_OpaqueConstantBool()) {\n+        \/\/ Tests with OpaqueConstantBool nodes are implicitly known. Replace the node with true\/false. In debug builds,\n@@ -2558,2 +2558,1 @@\n-        bool is_positive = n->as_OpaqueCheck()->is_positive();\n-        _igvn.replace_node(n, _igvn.intcon(is_positive?1:0));\n+        _igvn.replace_node(n, _igvn.intcon(n->as_OpaqueConstantBool()->constant()));\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-class OpaqueCheckNode;\n+class OpaqueConstantBoolNode;\n@@ -819,1 +819,1 @@\n-    DEFINE_CLASS_ID(OpaqueCheck,  Node, 17)\n+    DEFINE_CLASS_ID(OpaqueConstantBool,  Node, 17)\n@@ -999,1 +999,1 @@\n-  DEFINE_CLASS_QUERY(OpaqueCheck)\n+  DEFINE_CLASS_QUERY(OpaqueConstantBool)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-const Type* OpaqueCheckNode::Value(PhaseGVN* phase) const {\n+const Type* OpaqueConstantBoolNode::Value(PhaseGVN* phase) const {\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -133,2 +133,2 @@\n-\/\/ that the control path is also properly folded, we insert an If node with a OpaqueCheckNode as condition. During\n-\/\/ macro expansion, we replace the OpaqueCheckNodes with true in product builds such that the actually unneeded checks\n+\/\/ that the control path is also properly folded, we insert an If node with a OpaqueConstantBoolNode as condition. During\n+\/\/ macro expansion, we replace the OpaqueConstantBoolNodes with true in product builds such that the actually unneeded checks\n@@ -136,1 +136,1 @@\n-\/\/ verification code (i.e. removing OpaqueCheckNodes and use the BoolNode inputs instead). For more details, also see\n+\/\/ verification code (i.e. removing OpaqueConstantBoolNodes and use the BoolNode inputs instead). For more details, also see\n@@ -142,1 +142,1 @@\n-\/\/ OpaqueCheckNode before the If node in the guard. During macro expansion, we replace the OpaqueCheckNode with false\n+\/\/ OpaqueConstantBoolNode before the If node in the guard. During macro expansion, we replace the OpaqueConstantBoolNode with false\n@@ -144,1 +144,1 @@\n-\/\/ builds, we keep the actual checks as additional verification code (i.e. removing OpaqueCheckNodes and use the\n+\/\/ builds, we keep the actual checks as additional verification code (i.e. removing OpaqueConstantBoolNodes and use the\n@@ -146,1 +146,1 @@\n-class OpaqueCheckNode : public Node {\n+class OpaqueConstantBoolNode : public Node {\n@@ -148,1 +148,1 @@\n-  bool _positive;\n+  bool _constant;\n@@ -150,2 +150,2 @@\n-  OpaqueCheckNode(Compile* C, Node* tst, bool positive) : Node(nullptr, tst), _positive(positive) {\n-    init_class_id(Class_OpaqueCheck);\n+  OpaqueConstantBoolNode(Compile* C, Node* tst, bool positive) : Node(nullptr, tst), _constant(positive) {\n+    init_class_id(Class_OpaqueConstantBool);\n@@ -159,1 +159,2 @@\n-  bool is_positive() { return _positive; }\n+  int constant() const { return _constant ? 1 : 0; }\n+  virtual uint size_of() const { return sizeof(OpaqueConstantBoolNode); }\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -310,1 +310,1 @@\n-            if (use->is_OpaqueCheck() || use->is_OpaqueTemplateAssertionPredicate() ||\n+            if (use->is_OpaqueConstantBool() || use->is_OpaqueTemplateAssertionPredicate() ||\n@@ -334,2 +334,2 @@\n-              \/\/ Uses are either IfNodes, CMoves, OpaqueCheck or Opaque*AssertionPredicate\n-              if (u->is_OpaqueCheck() || u->is_OpaqueTemplateAssertionPredicate() ||\n+              \/\/ Uses are either IfNodes, CMoves, OpaqueConstantBool or Opaque*AssertionPredicate\n+              if (u->is_OpaqueConstantBool() || u->is_OpaqueTemplateAssertionPredicate() ||\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        \/\/     an OpaqueCheck which obviously is not the case and the assert fails.\n+        \/\/     an OpaqueConstantBool which obviously is not the case and the assert fails.\n@@ -80,1 +80,1 @@\n-    \/\/ removed loop (L) which also does not have an OpaqueCheck and the assert fails.\n+    \/\/ removed loop (L) which also does not have an OpaqueConstantBool and the assert fails.\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestCanReduceCheckUsersDifferentIfs.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8374582\n- * @summary Tests the creation and removal of opaque nodes at range checks points in string intrinsics.\n- * @library \/test\/lib \/\n- * @run driver ${test.main.class}\n- *\/\n-\n-package compiler.intrinsics.string;\n-\n-import compiler.lib.ir_framework.*;\n-\n-public class TestOpaqueCheckNodes {\n-\n-    static byte[] bytes = new byte[42];\n-\n-    public static void main(String[] args) {\n-        TestFramework.runWithFlags(\n-            \"-XX:CompileCommand=inline,java.lang.StringCoding::*\",\n-            \"-XX:CompileCommand=exclude,jdk.internal.util.Preconditions::checkFromIndexSize\");\n-    }\n-\n-    @Setup\n-    private static Object[] setup() {\n-        return new Object[] {bytes, 2, 23};\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.OPAQUE_CHECK, \"3\"}, phase = CompilePhase.AFTER_PARSING)\n-    @IR(failOn = {IRNode.OPAQUE_CHECK}, phase = CompilePhase.AFTER_MACRO_EXPANSION)\n-    @Arguments(setup = \"setup\")\n-    private static String test(byte[] bytes, int i, int l) {\n-        return new String(bytes, i , l);\n-    }\n-}\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestOpaqueCheckNodes.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8374582\n+ * @summary Tests the creation and removal of opaque nodes at range checks points in string intrinsics.\n+ * @library \/test\/lib \/\n+ * @run driver ${test.main.class}\n+ *\/\n+\n+package compiler.intrinsics.string;\n+\n+import compiler.lib.ir_framework.*;\n+\n+public class TestOpaqueConstantBoolNodes {\n+\n+    static byte[] bytes = new byte[42];\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\n+            \"-XX:CompileCommand=inline,java.lang.StringCoding::*\",\n+            \"-XX:CompileCommand=exclude,jdk.internal.util.Preconditions::checkFromIndexSize\");\n+    }\n+\n+    @Setup\n+    private static Object[] setup() {\n+        return new Object[] {bytes, 2, 23};\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.OPAQUE_CONSTANT_BOOL, \"3\"}, phase = CompilePhase.AFTER_PARSING)\n+    @IR(failOn = {IRNode.OPAQUE_CONSTANT_BOOL}, phase = CompilePhase.AFTER_MACRO_EXPANSION)\n+    @Arguments(setup = \"setup\")\n+    private static String test(byte[] bytes, int i, int l) {\n+        return new String(bytes, i , l);\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestOpaqueConstantBoolNodes.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -3140,1 +3140,1 @@\n-    public static final String OPAQUE_CHECK = PREFIX + \"OPAQUE_CHECK\" + POSTFIX;\n+    public static final String OPAQUE_CONSTANT_BOOL = PREFIX + \"OPAQUE_CONSTANT_BOOL\" + POSTFIX;\n@@ -3142,1 +3142,1 @@\n-        beforeMatchingNameRegex(OPAQUE_CHECK, \"OpaqueCheck\");\n+        beforeMatchingNameRegex(OPAQUE_CONSTANT_BOOL, \"OpaqueConstantBool\");\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,3 +68,3 @@\n-    private static final String CALL_STATIC_JAVA_AND_THEN_OPAQUE_CHECK = IRNode.START + \"CallStaticJava\" + SKIP + \"OpaqueCheck\" + IRNode.MID + IRNode.END;\n-    private static final String OPAQUE_CHECK_AND_THEN_CALL_STATIC_JAVA = IRNode.START + \"OpaqueCheck\" + SKIP + \"CallStaticJava\" + IRNode.MID + IRNode.END;\n-    \/* Having both CallStaticJava and OpaqueCheck, in any order. We use that in a failOn to make sure we have one\n+    private static final String CALL_STATIC_JAVA_AND_THEN_OPAQUE_CONSTANT_BOOL = IRNode.START + \"CallStaticJava\" + SKIP + \"OpaqueConstantBool\" + IRNode.MID + IRNode.END;\n+    private static final String OPAQUE_CONSTANT_BOOL_AND_THEN_CALL_STATIC_JAVA = IRNode.START + \"OpaqueConstantBool\" + SKIP + \"CallStaticJava\" + IRNode.MID + IRNode.END;\n+    \/* Having both CallStaticJava and OpaqueConstantBool, in any order. We use that in a failOn to make sure we have one\n@@ -72,1 +72,1 @@\n-     * The CallStaticJava happens when the call is not intrinsified, and the OpaqueCheck comes from the intrinsic.\n+     * The CallStaticJava happens when the call is not intrinsified, and the OpaqueConstantBool comes from the intrinsic.\n@@ -76,1 +76,1 @@\n-            \"(\" + CALL_STATIC_JAVA_AND_THEN_OPAQUE_CHECK + \") | (\" + OPAQUE_CHECK_AND_THEN_CALL_STATIC_JAVA + \")\";\n+            \"(\" + CALL_STATIC_JAVA_AND_THEN_OPAQUE_CONSTANT_BOOL + \") | (\" + OPAQUE_CONSTANT_BOOL_AND_THEN_CALL_STATIC_JAVA + \")\";\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/OpaqueAccesses.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}