{"files":[{"patch":"@@ -6262,4 +6262,8 @@\n-\/\/ - sun\/nio\/cs\/ISO_8859_1$Encoder.implEncodeISOArray\n-\/\/     return the number of characters copied.\n-\/\/ - java\/lang\/StringUTF16.compress\n-\/\/     return index of non-latin1 character if copy fails, otherwise 'len'.\n+\/\/ - sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes char[] to byte[] in ISO-8859-1\n+\/\/\n+\/\/ - java.lang.StringCoding#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes byte[] (containing UTF-16) to byte[] in ISO-8859-1\n+\/\/\n+\/\/ - java.lang.StringCoding#encodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes char[] to byte[] in ASCII\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2816,4 +2816,8 @@\n-\/\/ - sun\/nio\/cs\/ISO_8859_1$Encoder.implEncodeISOArray\n-\/\/     return the number of characters copied.\n-\/\/ - java\/lang\/StringUTF16.compress\n-\/\/     return index of non-latin1 character if copy fails, otherwise 'len'.\n+\/\/ - sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes char[] to byte[] in ISO-8859-1\n+\/\/\n+\/\/ - java.lang.StringCoding#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes byte[] (containing UTF-16) to byte[] in ISO-8859-1\n+\/\/\n+\/\/ - java.lang.StringCoding#encodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes char[] to byte[] in ASCII\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -6254,26 +6254,40 @@\n-\/\/ encode char[] to byte[] in ISO_8859_1 or ASCII\n-   \/\/@IntrinsicCandidate\n-   \/\/private static int implEncodeISOArray(byte[] sa, int sp,\n-   \/\/byte[] da, int dp, int len) {\n-   \/\/  int i = 0;\n-   \/\/  for (; i < len; i++) {\n-   \/\/    char c = StringUTF16.getChar(sa, sp++);\n-   \/\/    if (c > '\\u00FF')\n-   \/\/      break;\n-   \/\/    da[dp++] = (byte)c;\n-   \/\/  }\n-   \/\/  return i;\n-   \/\/}\n-   \/\/\n-   \/\/@IntrinsicCandidate\n-   \/\/private static int implEncodeAsciiArray(char[] sa, int sp,\n-   \/\/    byte[] da, int dp, int len) {\n-   \/\/  int i = 0;\n-   \/\/  for (; i < len; i++) {\n-   \/\/    char c = sa[sp++];\n-   \/\/    if (c >= '\\u0080')\n-   \/\/      break;\n-   \/\/    da[dp++] = (byte)c;\n-   \/\/  }\n-   \/\/  return i;\n-   \/\/}\n+\/\/ Encode given char[]\/byte[] to byte[] in ISO_8859_1 or ASCII\n+\/\/\n+\/\/ @IntrinsicCandidate\n+\/\/ int sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(\n+\/\/         char[] sa, int sp, byte[] da, int dp, int len) {\n+\/\/     int i = 0;\n+\/\/     for (; i < len; i++) {\n+\/\/         char c = sa[sp++];\n+\/\/         if (c > '\\u00FF')\n+\/\/             break;\n+\/\/         da[dp++] = (byte) c;\n+\/\/     }\n+\/\/     return i;\n+\/\/ }\n+\/\/\n+\/\/ @IntrinsicCandidate\n+\/\/ int java.lang.StringCoding.encodeISOArray0(\n+\/\/         byte[] sa, int sp, byte[] da, int dp, int len) {\n+\/\/   int i = 0;\n+\/\/   for (; i < len; i++) {\n+\/\/     char c = StringUTF16.getChar(sa, sp++);\n+\/\/     if (c > '\\u00FF')\n+\/\/       break;\n+\/\/     da[dp++] = (byte) c;\n+\/\/   }\n+\/\/   return i;\n+\/\/ }\n+\/\/\n+\/\/ @IntrinsicCandidate\n+\/\/ int java.lang.StringCoding.encodeAsciiArray0(\n+\/\/         char[] sa, int sp, byte[] da, int dp, int len) {\n+\/\/   int i = 0;\n+\/\/   for (; i < len; i++) {\n+\/\/     char c = sa[sp++];\n+\/\/     if (c >= '\\u0080')\n+\/\/       break;\n+\/\/     da[dp++] = (byte) c;\n+\/\/   }\n+\/\/   return i;\n+\/\/ }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":40,"deletions":26,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -418,1 +418,1 @@\n-   do_name(     countPositives_name,                       \"countPositives\")                                            \\\n+   do_name(     countPositives_name,                       \"countPositives0\")                                           \\\n@@ -423,1 +423,1 @@\n-   do_name(     encodeISOArray_name,                             \"implEncodeISOArray\")                                  \\\n+   do_name(     encodeISOArray_name,                             \"encodeISOArray0\")                                     \\\n@@ -429,1 +429,1 @@\n-   do_name(     encodeAsciiArray_name,                           \"implEncodeAsciiArray\")                                \\\n+   do_name(     encodeAsciiArray_name,                           \"encodeAsciiArray0\")                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -285,0 +285,1 @@\n+macro(OpaqueGuard)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -894,1 +894,1 @@\n-                                                     Node* *pos_index) {\n+                                                     Node* *pos_index, bool is_opaque) {\n@@ -901,0 +901,3 @@\n+  if (is_opaque) {\n+    bol_lt = _gvn.transform(new OpaqueGuardNode(C, bol_lt));\n+  }\n@@ -927,1 +930,2 @@\n-                                                  RegionNode* region) {\n+                                                  RegionNode* region,\n+                                                  bool is_opaque) {\n@@ -938,0 +942,3 @@\n+  if (is_opaque) {\n+    bol_lt = _gvn.transform(new OpaqueGuardNode(C, bol_lt));\n+  }\n@@ -943,1 +950,5 @@\n-void LibraryCallKit::generate_string_range_check(Node* array, Node* offset, Node* count, bool char_count) {\n+void LibraryCallKit::generate_string_range_check(Node* array,\n+                                                 Node* offset,\n+                                                 Node* count,\n+                                                 bool char_count,\n+                                                 bool halt_on_oob) {\n@@ -955,2 +966,2 @@\n-  generate_negative_guard(offset, bailout);\n-  generate_negative_guard(count, bailout);\n+  generate_negative_guard(offset, bailout, nullptr, halt_on_oob);\n+  generate_negative_guard(count, bailout, nullptr, halt_on_oob);\n@@ -958,1 +969,1 @@\n-  generate_limit_guard(offset, count, load_array_length(array), bailout);\n+  generate_limit_guard(offset, count, load_array_length(array), bailout, halt_on_oob);\n@@ -961,4 +972,11 @@\n-    PreserveJVMState pjvms(this);\n-    set_control(_gvn.transform(bailout));\n-    uncommon_trap(Deoptimization::Reason_intrinsic,\n-                  Deoptimization::Action_maybe_recompile);\n+    if (halt_on_oob) {\n+      bailout = _gvn.transform(bailout)->as_Region();\n+      Node* frame = _gvn.transform(new ParmNode(C->start(), TypeFunc::FramePtr));\n+      Node* halt = _gvn.transform(new HaltNode(bailout, frame, \"unexpected guard failure in intrinsic\"));\n+      C->root()->add_req(halt);\n+    } else {\n+      PreserveJVMState pjvms(this);\n+      set_control(_gvn.transform(bailout));\n+      uncommon_trap(Deoptimization::Reason_intrinsic,\n+                    Deoptimization::Action_maybe_recompile);\n+    }\n@@ -1122,0 +1140,1 @@\n+\/\/ int java.lang.StringCoding#countPositives0(byte[] ba, int off, int len)\n@@ -1134,3 +1153,1 @@\n-\n-  \/\/ Range checks\n-  generate_string_range_check(ba, offset, len, false);\n+  generate_string_range_check(ba, offset, len, false, true);\n@@ -1140,0 +1157,1 @@\n+\n@@ -6174,0 +6192,3 @@\n+\/\/ int sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/ int java.lang.StringCoding#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/ int java.lang.StringCoding#encodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len)\n@@ -6184,0 +6205,1 @@\n+  \/\/ Cast source & target arrays to not-null\n@@ -6186,0 +6208,3 @@\n+  if (stopped()) {\n+    return true;\n+  }\n@@ -6202,0 +6227,7 @@\n+  \/\/ Check source & target bounds\n+  generate_string_range_check(src, src_offset, length, src_elem == T_BYTE, true);\n+  generate_string_range_check(dst, dst_offset, length, false, true);\n+  if (stopped()) {\n+    return true;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":45,"deletions":13,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -161,1 +161,2 @@\n-                                Node* *pos_index = nullptr);\n+                                Node* *pos_index = nullptr,\n+                                bool is_opaque = false);\n@@ -164,1 +165,2 @@\n-                             RegionNode* region);\n+                             RegionNode* region,\n+                             bool is_opaque = false);\n@@ -166,1 +168,2 @@\n-                                    Node* length, bool char_count);\n+                                    Node* length, bool char_count,\n+                                    bool halt_on_oob = false);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1238,0 +1238,1 @@\n+               bol->is_OpaqueGuard() ||\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1708,0 +1708,1 @@\n+      !n->is_OpaqueGuard() &&\n@@ -2048,1 +2049,1 @@\n-      assert(b->is_Bool() || b->is_OpaqueNotNull() || b->is_OpaqueInitializedAssertionPredicate(),\n+      assert(b->is_Bool() || b->is_OpaqueNotNull() || b->is_OpaqueGuard() || b->is_OpaqueInitializedAssertionPredicate(),\n@@ -2055,1 +2056,1 @@\n-  if (n->is_OpaqueNotNull() || n->is_OpaqueInitializedAssertionPredicate()) {\n+  if (n->is_OpaqueNotNull() || n->is_OpaqueInitializedAssertionPredicate() || n->is_OpaqueGuard()) {\n@@ -2231,1 +2232,1 @@\n-      if (use->is_If() || use->is_CMove() || use->is_OpaqueNotNull() || use->is_OpaqueInitializedAssertionPredicate() ||\n+      if (use->is_If() || use->is_CMove() || use->is_OpaqueGuard() || use->is_OpaqueNotNull() || use->is_OpaqueInitializedAssertionPredicate() ||\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2504,0 +2504,1 @@\n+               n->is_OpaqueGuard()         ||\n@@ -2559,0 +2560,10 @@\n+#endif\n+        success = true;\n+      } else if (n->is_OpaqueGuard()) {\n+        \/\/ Tests with OpaqueGuard nodes are implicitly known to be false. Replace the node with false. In debug\n+        \/\/ builds, we leave the test in the graph to have an additional sanity check at runtime. If the test\n+        \/\/ fails (i.e. a bug), we will execute a Halt node.\n+#ifdef ASSERT\n+        _igvn.replace_node(n, n->in(1));\n+#else\n+        _igvn.replace_node(n, _igvn.intcon(0));\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -146,0 +146,1 @@\n+class OpaqueGuardNode;\n@@ -825,0 +826,1 @@\n+    DEFINE_CLASS_ID(OpaqueGuard,  Node, 23)\n@@ -1000,0 +1002,1 @@\n+  DEFINE_CLASS_QUERY(OpaqueGuard)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -113,0 +113,4 @@\n+}\n+\n+const Type* OpaqueGuardNode::Value(PhaseGVN* phase) const {\n+  return phase->type(in(1));\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -147,0 +147,22 @@\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual const Type* bottom_type() const { return TypeInt::BOOL; }\n+};\n+\n+\/\/ Similar to OpaqueNotNullNode but for guards. Sometimes we know that a size or limit guard is checked\n+\/\/ (e.g. there is already a guard in the caller) but the compiler cannot prove it. We could in principle avoid\n+\/\/ adding a guard in the intrinsic but in some cases (e.g. when the input is a constant that breaks the guard\n+\/\/ and the caller guard is not inlined) the input of the intrinsic can become top and the data path is folded.\n+\/\/ Similar to OpaqueNotNullNode to ensure that the control path is also properly folded, we insert a OpaqueGuardNode\n+\/\/ before the If node in the guard. During macro expansion, we replace the OpaqueGuardNode with false in product\n+\/\/ builds such that the actually unneeded guards are folded and do not end up in the emitted code. In debug builds,\n+\/\/ we keep the actual checks as additional verification code (i.e. removing OpaqueGuardNode and use the BoolNode\n+\/\/ inputs instead).\n+class OpaqueGuardNode : public Node {\n+ public:\n+  OpaqueGuardNode(Compile* C, Node* tst) : Node(nullptr, tst) {\n+    init_class_id(Class_OpaqueGuard);\n+    init_flags(Flag_is_macro);\n+    C->add_macro_node(this);\n+  }\n+\n+  virtual int Opcode() const;\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -310,1 +310,1 @@\n-            if (use->is_OpaqueNotNull() || use->is_OpaqueTemplateAssertionPredicate() ||\n+            if (use->is_OpaqueNotNull() || use->is_OpaqueGuard() || use->is_OpaqueTemplateAssertionPredicate() ||\n@@ -334,2 +334,2 @@\n-              \/\/ Uses are either IfNodes, CMoves, OpaqueNotNull, or Opaque*AssertionPredicate\n-              if (u->is_OpaqueNotNull() || u->is_OpaqueTemplateAssertionPredicate() ||\n+              \/\/ Uses are either IfNodes, CMoves, OpaqueNotNull, OpaqueGuard or Opaque*AssertionPredicate\n+              if (u->is_OpaqueNotNull() || u->is_OpaqueGuard() || u->is_OpaqueTemplateAssertionPredicate() ||\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1114,1 +1114,1 @@\n-            int ret = StringCoding.implEncodeISOArray(val, sp, dst, dp, len);\n+            int ret = StringCoding.encodeISOArray(val, sp, dst, dp, len);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.internal.util.Preconditions;\n@@ -31,0 +32,2 @@\n+import java.util.function.BiFunction;\n+\n@@ -41,1 +44,1 @@\n-    public static int countNonZeroAscii(String s) {\n+    static int countNonZeroAscii(String s) {\n@@ -53,1 +56,1 @@\n-    public static int countNonZeroAsciiLatin1(byte[] ba, int off, int len) {\n+    private static int countNonZeroAsciiLatin1(byte[] ba, int off, int len) {\n@@ -66,1 +69,1 @@\n-    public static int countNonZeroAsciiUTF16(byte[] ba, int off, int strlen) {\n+    private static int countNonZeroAsciiUTF16(byte[] ba, int off, int strlen) {\n@@ -77,1 +80,1 @@\n-    public static boolean hasNegatives(byte[] ba, int off, int len) {\n+    static boolean hasNegatives(byte[] ba, int off, int len) {\n@@ -88,0 +91,7 @@\n+     *\n+     * @param ba a byte array\n+     * @param off the index of the first byte to start reading from\n+     * @param len the total number of bytes to read\n+     * @throws NullPointerException if {@code ba} is null\n+     * @throws ArrayIndexOutOfBoundsException if the provided sub-range is\n+     *         {@linkplain Preconditions#checkFromIndexSize(int, int, int, BiFunction) out of bounds}\n@@ -89,0 +99,8 @@\n+    static int countPositives(byte[] ba, int off, int len) {\n+        Preconditions.checkFromIndexSize(\n+                off, len,\n+                ba.length,      \/\/ Implicit null check on `ba`\n+                Preconditions.AIOOBE_FORMATTER);\n+        return countPositives0(ba, off, len);\n+    }\n+\n@@ -90,1 +108,1 @@\n-    public static int countPositives(byte[] ba, int off, int len) {\n+    private static int countPositives0(byte[] ba, int off, int len) {\n@@ -100,0 +118,28 @@\n+    \/**\n+     * Encodes as many ISO-8859-1 codepoints as possible from the source byte\n+     * array containing characters encoded in UTF-16, into the destination byte\n+     * array, assuming that the encoding is ISO-8859-1 compatible.\n+     *\n+     * @param sa the source byte array containing characters encoded in UTF-16\n+     * @param sp the index of the <em>character (not byte!)<\/em> from the source array to start reading from\n+     * @param da the target byte array\n+     * @param dp the index of the target array to start writing to\n+     * @param len the maximum number of <em>characters (not bytes!)<\/em> to be encoded\n+     * @return the total number of <em>characters (not bytes!)<\/em> successfully encoded\n+     * @throws NullPointerException if any of the provided arrays is null\n+     *\/\n+    static int encodeISOArray(byte[] sa, int sp,\n+                              byte[] da, int dp, int len) {\n+        \/\/ This method should tolerate invalid arguments, matching the lenient behavior of the VM intrinsic.\n+        \/\/ Hence, using operator expressions instead of `Preconditions`, which throw on failure.\n+        int sl;\n+        if ((sp | dp | len) < 0 ||\n+                \/\/ Halving the length of `sa` to obtain the number of characters:\n+                sp >= (sl = sa.length >>> 1) ||     \/\/ Implicit null check on `sa`\n+                dp >= da.length) {                  \/\/ Implicit null check on `da`\n+            return 0;\n+        }\n+        int minLen = Math.min(len, Math.min(sl - sp, da.length - dp));\n+        return encodeISOArray0(sa, sp, da, dp, minLen);\n+    }\n+\n@@ -101,2 +147,2 @@\n-    public static int implEncodeISOArray(byte[] sa, int sp,\n-                                         byte[] da, int dp, int len) {\n+    private static int encodeISOArray0(byte[] sa, int sp,\n+                                       byte[] da, int dp, int len) {\n@@ -113,0 +159,26 @@\n+    \/**\n+     * Encodes as many ASCII codepoints as possible from the source\n+     * character array into the destination byte array, assuming that\n+     * the encoding is ASCII compatible.\n+     *\n+     * @param sa the source character array\n+     * @param sp the index of the source array to start reading from\n+     * @param da the target byte array\n+     * @param dp the index of the target array to start writing to\n+     * @param len the maximum number of characters to be encoded\n+     * @return the total number of characters successfully encoded\n+     * @throws NullPointerException if any of the provided arrays is null\n+     *\/\n+    static int encodeAsciiArray(char[] sa, int sp,\n+                                byte[] da, int dp, int len) {\n+        \/\/ This method should tolerate invalid arguments, matching the lenient behavior of the VM intrinsic.\n+        \/\/ Hence, using operator expressions instead of `Preconditions`, which throw on failure.\n+        if ((sp | dp | len) < 0 ||\n+                sp >= sa.length ||      \/\/ Implicit null check on `sa`\n+                dp >= da.length) {      \/\/ Implicit null check on `da`\n+            return 0;\n+        }\n+        int minLen = Math.min(len, Math.min(sa.length - sp, da.length - dp));\n+        return encodeAsciiArray0(sa, sp, da, dp, minLen);\n+    }\n+\n@@ -114,3 +186,2 @@\n-    public static int implEncodeAsciiArray(char[] sa, int sp,\n-                                           byte[] da, int dp, int len)\n-    {\n+    static int encodeAsciiArray0(char[] sa, int sp,\n+                                 byte[] da, int dp, int len) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringCoding.java","additions":82,"deletions":11,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-import java.util.concurrent.ScheduledExecutorService;\n@@ -2180,2 +2179,2 @@\n-            public int uncheckedEncodeASCII(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n-                return StringCoding.implEncodeAsciiArray(src, srcOff, dst, dstOff, len);\n+            public int encodeASCII(char[] sa, int sp, byte[] da, int dp, int len) {\n+                return StringCoding.encodeAsciiArray(sa, sp, da, dp, len);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -451,5 +451,3 @@\n-     * Encodes as many ASCII codepoints as possible from the source array into\n-     * the destination byte array, assuming that the encoding is ASCII\n-     * compatible.\n-     * <p>\n-     * <b>WARNING: This method does not perform any bound checks.<\/b>\n+     * Encodes as many ASCII codepoints as possible from the source\n+     * character array into the destination byte array, assuming that\n+     * the encoding is ASCII compatible.\n@@ -457,3 +455,9 @@\n-     * @return the number of bytes successfully encoded, or 0 if none\n-     *\/\n-    int uncheckedEncodeASCII(char[] src, int srcOff, byte[] dst, int dstOff, int len);\n+     * @param sa the source character array\n+     * @param sp the index of the source array to start reading from\n+     * @param da the target byte array\n+     * @param dp the index of the target array to start writing to\n+     * @param len the total number of characters to be encoded\n+     * @return the total number of characters successfully encoded\n+     * @throws NullPointerException if any of the provided arrays is null\n+     *\/\n+    int encodeASCII(char[] sa, int sp, byte[] da, int dp, int len);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -448,1 +448,1 @@\n-            int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n+            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/CESU_8.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -603,1 +603,1 @@\n-                    int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(dl - dp, sl - sp));\n+                    int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(dl - dp, sl - sp));\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/DoubleByte.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import jdk.internal.util.Preconditions;\n@@ -145,1 +144,13 @@\n-        \/\/ Method possible replaced with a compiler intrinsic.\n+        \/**\n+         * Encodes as many ISO-8859-1 codepoints as possible from the source\n+         * character array into the destination byte array, assuming that\n+         * the encoding is ISO-8859-1 compatible.\n+         *\n+         * @param sa the source character array\n+         * @param sp the index of the source array to start reading from\n+         * @param da the target byte array\n+         * @param dp the index of the target array to start writing to\n+         * @param len the maximum number of characters to be encoded\n+         * @return the total number of characters successfully encoded\n+         * @throws NullPointerException if any of the provided arrays is null\n+         *\/\n@@ -148,1 +159,5 @@\n-            if (len <= 0) {\n+            \/\/ This method should tolerate invalid arguments, matching the lenient behavior of the VM intrinsic.\n+            \/\/ Hence, using operator expressions instead of `Preconditions`, which throw on failure.\n+            if ((sp | dp | len) < 0 ||\n+                    sp >= sa.length ||      \/\/ Implicit null check on `sa`\n+                    dp >= da.length) {      \/\/ Implicit null check on `da`\n@@ -151,2 +166,2 @@\n-            encodeISOArrayCheck(sa, sp, da, dp, len);\n-            return implEncodeISOArray(sa, sp, da, dp, len);\n+            int minLen = Math.min(len, Math.min(sa.length - sp, da.length - dp));\n+            return encodeISOArray0(sa, sp, da, dp, minLen);\n@@ -156,3 +171,1 @@\n-        private static int implEncodeISOArray(char[] sa, int sp,\n-                                              byte[] da, int dp, int len)\n-        {\n+        private static int encodeISOArray0(char[] sa, int sp, byte[] da, int dp, int len) {\n@@ -169,11 +182,0 @@\n-        private static void encodeISOArrayCheck(char[] sa, int sp,\n-                                                byte[] da, int dp, int len) {\n-            Objects.requireNonNull(sa);\n-            Objects.requireNonNull(da);\n-            Preconditions.checkIndex(sp, sa.length, Preconditions.AIOOBE_FORMATTER);\n-            Preconditions.checkIndex(dp, da.length, Preconditions.AIOOBE_FORMATTER);\n-\n-            Preconditions.checkIndex(sp + len - 1, sa.length, Preconditions.AIOOBE_FORMATTER);\n-            Preconditions.checkIndex(dp + len - 1, da.length, Preconditions.AIOOBE_FORMATTER);\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/ISO_8859_1.java","additions":21,"deletions":19,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-                int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, len);\n+                int n = JLA.encodeASCII(sa, sp, da, dp, len);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/SingleByte.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-            int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n+            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/US_ASCII.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -455,1 +455,1 @@\n-            int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n+            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/UTF_8.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -312,1 +312,1 @@\n-                    int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(dl - dp, sl - sp));\n+                    int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(dl - dp, sl - sp));\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/EUC_JP.java.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8374582\n+ * @summary Tests the creation and removal of opaque nodes at range checks points in string intrinsics.\n+ * @library \/test\/lib \/\n+ * @run driver ${test.main.class}\n+ *\/\n+\n+package compiler.intrinsics.string;\n+\n+import compiler.lib.ir_framework.*;\n+\n+public class TestOpaqueGuardNodes {\n+\n+    static byte[] bytes = new byte[42];\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\n+            \"-XX:CompileCommand=inline,java.lang.StringCoding::*\",\n+            \"-XX:CompileCommand=exclude,jdk.internal.util.Preconditions::checkFromIndexSize\");\n+    }\n+\n+    @Setup\n+    private static Object[] setup() {\n+        return new Object[] {bytes, 2, 23};\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.OPAQUE_GUARD, \"3\"}, phase = CompilePhase.AFTER_PARSING)\n+    @IR(failOn = {IRNode.OPAQUE_GUARD}, phase = CompilePhase.AFTER_MACRO_EXPANSION)\n+    @Arguments(setup = \"setup\")\n+    private static String test(byte[] bytes, int i, int l) {\n+        return new String(bytes, i , l);\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestOpaqueGuardNodes.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8374582\n+ * @summary Tests handling of invalid array indices in C2 intrinsic if explicit range check in Java code is not inlined.\n+ * @modules java.base\/jdk.internal.access\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=inline,java.lang.StringCoding::*\n+ *      -XX:CompileCommand=exclude,jdk.internal.util.Preconditions::checkFromIndexSize\n+ *      ${test.main.class}\n+ *\/\n+\n+package compiler.intrinsics.string;\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n+public class TestRangeCheck {\n+\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+    public static void main(String[] args) {\n+        byte[] bytes = new byte[42];\n+        for (int i = 0; i < 10_000; ++i) {\n+            test(bytes);\n+        }\n+    }\n+\n+    private static int test(byte[] bytes) {\n+        try {\n+            \/\/ Calling `StringCoding::countPositives`, which is a \"front door\"\n+            \/\/ to the `StringCoding::countPositives0` intrinsic.\n+            \/\/ `countPositives` validates its input using\n+            \/\/ `Preconditions::checkFromIndexSize`, which also maps to an\n+            \/\/ intrinsic. When `checkFromIndexSize` is not inlined, C2 does not\n+            \/\/ know about the explicit range checks, and does not cut off the\n+            \/\/ dead code. As a result, an invalid value (e.g., `-1`) can be fed\n+            \/\/ as input into the `countPositives0` intrinsic, get replaced\n+            \/\/ by TOP, and cause a failure in the matcher.\n+            return JLA.countPositives(bytes, -1, 42);\n+        } catch (Exception e) {\n+            return 0;\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestRangeCheck.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -3140,0 +3140,5 @@\n+    public static final String OPAQUE_GUARD = PREFIX + \"OPAQUE_GUARD\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(OPAQUE_GUARD, \"OpaqueGuard\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}