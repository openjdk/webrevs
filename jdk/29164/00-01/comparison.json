{"files":[{"patch":"@@ -284,2 +284,1 @@\n-macro(OpaqueNotNull)\n-macro(OpaqueGuard)\n+macro(OpaqueCheck)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -591,1 +591,1 @@\n-          \/\/ We may have an OpaqueNotNull node between If and Bool nodes. But we could also have a sub class of IfNode,\n+          \/\/ We may have an OpaqueCheck node between If and Bool nodes. But we could also have a sub class of IfNode,\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1475,1 +1475,1 @@\n-\/\/ an OpaqueNotNull node that will cause the check to be removed after loop\n+\/\/ an OpaqueCheck node that will cause the check to be removed after loop\n@@ -1484,1 +1484,1 @@\n-  Node* opaq = _gvn.transform(new OpaqueNotNullNode(C, tst));\n+  Node* opaq = _gvn.transform(new OpaqueCheckNode(C, tst, true));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -902,1 +902,1 @@\n-    bol_lt = _gvn.transform(new OpaqueGuardNode(C, bol_lt));\n+    bol_lt = _gvn.transform(new OpaqueCheckNode(C, bol_lt, false));\n@@ -943,1 +943,1 @@\n-    bol_lt = _gvn.transform(new OpaqueGuardNode(C, bol_lt));\n+    bol_lt = _gvn.transform(new OpaqueCheckNode(C, bol_lt, false));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1237,2 +1237,1 @@\n-        assert(bol->is_OpaqueNotNull() ||\n-               bol->is_OpaqueGuard() ||\n+        assert(bol->is_OpaqueCheck() ||\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1707,2 +1707,1 @@\n-      !n->is_OpaqueNotNull() &&\n-      !n->is_OpaqueGuard() &&\n+      !n->is_OpaqueCheck() &&\n@@ -2049,2 +2048,2 @@\n-      assert(b->is_Bool() || b->is_OpaqueNotNull() || b->is_OpaqueGuard() || b->is_OpaqueInitializedAssertionPredicate(),\n-             \"bool, non-null check with OpaqueNotNull or Initialized Assertion Predicate with its Opaque node\");\n+      assert(b->is_Bool() || b->is_OpaqueCheck() || b->is_OpaqueInitializedAssertionPredicate(),\n+             \"bool, non-null check with OpaqueCheck or Initialized Assertion Predicate with its Opaque node\");\n@@ -2056,1 +2055,1 @@\n-  if (n->is_OpaqueNotNull() || n->is_OpaqueInitializedAssertionPredicate() || n->is_OpaqueGuard()) {\n+  if (n->is_OpaqueCheck() || n->is_OpaqueInitializedAssertionPredicate()) {\n@@ -2232,1 +2231,1 @@\n-      if (use->is_If() || use->is_CMove() || use->is_OpaqueGuard() || use->is_OpaqueNotNull() || use->is_OpaqueInitializedAssertionPredicate() ||\n+      if (use->is_If() || use->is_CMove() || use->is_OpaqueCheck() || use->is_OpaqueInitializedAssertionPredicate() ||\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2503,2 +2503,1 @@\n-               n->is_OpaqueNotNull()       ||\n-               n->is_OpaqueGuard()         ||\n+               n->is_OpaqueCheck()    ||\n@@ -2552,2 +2551,2 @@\n-      } else if (n->is_OpaqueNotNull()) {\n-        \/\/ Tests with OpaqueNotNull nodes are implicitly known to be true. Replace the node with true. In debug builds,\n+      } else if (n->is_OpaqueCheck()) {\n+        \/\/ Tests with OpaqueCheck nodes are implicitly known. Replace the node with true\/false. In debug builds,\n@@ -2559,11 +2558,2 @@\n-        _igvn.replace_node(n, _igvn.intcon(1));\n-#endif\n-        success = true;\n-      } else if (n->is_OpaqueGuard()) {\n-        \/\/ Tests with OpaqueGuard nodes are implicitly known to be false. Replace the node with false. In debug\n-        \/\/ builds, we leave the test in the graph to have an additional sanity check at runtime. If the test\n-        \/\/ fails (i.e. a bug), we will execute a Halt node.\n-#ifdef ASSERT\n-        _igvn.replace_node(n, n->in(1));\n-#else\n-        _igvn.replace_node(n, _igvn.intcon(0));\n+        bool is_positive = n->as_OpaqueCheck()->is_positive();\n+        _igvn.replace_node(n, _igvn.intcon(is_positive?1:0));\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -145,2 +145,1 @@\n-class OpaqueNotNullNode;\n-class OpaqueGuardNode;\n+class OpaqueCheckNode;\n@@ -820,1 +819,1 @@\n-    DEFINE_CLASS_ID(OpaqueNotNull,  Node, 17)\n+    DEFINE_CLASS_ID(OpaqueCheck,  Node, 17)\n@@ -826,1 +825,0 @@\n-    DEFINE_CLASS_ID(OpaqueGuard,  Node, 23)\n@@ -1001,2 +999,1 @@\n-  DEFINE_CLASS_QUERY(OpaqueNotNull)\n-  DEFINE_CLASS_QUERY(OpaqueGuard)\n+  DEFINE_CLASS_QUERY(OpaqueCheck)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -111,5 +111,1 @@\n-const Type* OpaqueNotNullNode::Value(PhaseGVN* phase) const {\n-  return phase->type(in(1));\n-}\n-\n-const Type* OpaqueGuardNode::Value(PhaseGVN* phase) const {\n+const Type* OpaqueCheckNode::Value(PhaseGVN* phase) const {\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -133,2 +133,2 @@\n-\/\/ that the control path is also properly folded, we insert an If node with a OpaqueNotNullNode as condition. During\n-\/\/ macro expansion, we replace the OpaqueNotNullNodes with true in product builds such that the actually unneeded checks\n+\/\/ that the control path is also properly folded, we insert an If node with a OpaqueCheckNode as condition. During\n+\/\/ macro expansion, we replace the OpaqueCheckNodes with true in product builds such that the actually unneeded checks\n@@ -136,1 +136,1 @@\n-\/\/ verification code (i.e. removing OpaqueNotNullNodes and use the BoolNode inputs instead). For more details, also see\n+\/\/ verification code (i.e. removing OpaqueCheckNodes and use the BoolNode inputs instead). For more details, also see\n@@ -138,1 +138,11 @@\n-class OpaqueNotNullNode : public Node {\n+\/\/ Similarly, sometimes we know that a size or limit guard is checked (e.g. there is already a guard in the caller) but\n+\/\/ the compiler cannot prove it. We could in principle avoid adding a guard in the intrinsic but in some cases (e.g.\n+\/\/ when the input is a constant that breaks the guard and the caller guard is not inlined) the input of the intrinsic\n+\/\/ can become top and the data path is folded. To ensure that the control path is also properly folded, we insert an\n+\/\/ OpaqueCheckNode before the If node in the guard. During macro expansion, we replace the OpaqueCheckNode with false\n+\/\/ in product builds such that the actually unneeded guards are folded and do not end up in the emitted code. In debug\n+\/\/ builds, we keep the actual checks as additional verification code (i.e. removing OpaqueCheckNodes and use the\n+\/\/ BoolNode inputs instead).\n+class OpaqueCheckNode : public Node {\n+ private:\n+  bool _positive;\n@@ -140,24 +150,2 @@\n-  OpaqueNotNullNode(Compile* C, Node* tst) : Node(nullptr, tst) {\n-    init_class_id(Class_OpaqueNotNull);\n-    init_flags(Flag_is_macro);\n-    C->add_macro_node(this);\n-  }\n-\n-  virtual int Opcode() const;\n-  virtual const Type* Value(PhaseGVN* phase) const;\n-  virtual const Type* bottom_type() const { return TypeInt::BOOL; }\n-};\n-\n-\/\/ Similar to OpaqueNotNullNode but for guards. Sometimes we know that a size or limit guard is checked\n-\/\/ (e.g. there is already a guard in the caller) but the compiler cannot prove it. We could in principle avoid\n-\/\/ adding a guard in the intrinsic but in some cases (e.g. when the input is a constant that breaks the guard\n-\/\/ and the caller guard is not inlined) the input of the intrinsic can become top and the data path is folded.\n-\/\/ Similar to OpaqueNotNullNode to ensure that the control path is also properly folded, we insert a OpaqueGuardNode\n-\/\/ before the If node in the guard. During macro expansion, we replace the OpaqueGuardNode with false in product\n-\/\/ builds such that the actually unneeded guards are folded and do not end up in the emitted code. In debug builds,\n-\/\/ we keep the actual checks as additional verification code (i.e. removing OpaqueGuardNode and use the BoolNode\n-\/\/ inputs instead).\n-class OpaqueGuardNode : public Node {\n- public:\n-  OpaqueGuardNode(Compile* C, Node* tst) : Node(nullptr, tst) {\n-    init_class_id(Class_OpaqueGuard);\n+  OpaqueCheckNode(Compile* C, Node* tst, bool positive) : Node(nullptr, tst), _positive(positive) {\n+    init_class_id(Class_OpaqueCheck);\n@@ -171,0 +159,1 @@\n+  bool is_positive() { return _positive; }\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":17,"deletions":28,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -310,1 +310,1 @@\n-            if (use->is_OpaqueNotNull() || use->is_OpaqueGuard() || use->is_OpaqueTemplateAssertionPredicate() ||\n+            if (use->is_OpaqueCheck() || use->is_OpaqueTemplateAssertionPredicate() ||\n@@ -334,2 +334,2 @@\n-              \/\/ Uses are either IfNodes, CMoves, OpaqueNotNull, OpaqueGuard or Opaque*AssertionPredicate\n-              if (u->is_OpaqueNotNull() || u->is_OpaqueGuard() || u->is_OpaqueTemplateAssertionPredicate() ||\n+              \/\/ Uses are either IfNodes, CMoves, OpaqueCheck or Opaque*AssertionPredicate\n+              if (u->is_OpaqueCheck() || u->is_OpaqueTemplateAssertionPredicate() ||\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        \/\/     an OpaqueNotNull which obviously is not the case and the assert fails.\n+        \/\/     an OpaqueCheck which obviously is not the case and the assert fails.\n@@ -80,1 +80,1 @@\n-    \/\/ removed loop (L) which also does not have an OpaqueNotNull and the assert fails.\n+    \/\/ removed loop (L) which also does not have an OpaqueCheck and the assert fails.\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestCanReduceCheckUsersDifferentIfs.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-public class TestOpaqueGuardNodes {\n+public class TestOpaqueCheckNodes {\n@@ -52,2 +52,2 @@\n-    @IR(counts = {IRNode.OPAQUE_GUARD, \"3\"}, phase = CompilePhase.AFTER_PARSING)\n-    @IR(failOn = {IRNode.OPAQUE_GUARD}, phase = CompilePhase.AFTER_MACRO_EXPANSION)\n+    @IR(counts = {IRNode.OPAQUE_CHECK, \"3\"}, phase = CompilePhase.AFTER_PARSING)\n+    @IR(failOn = {IRNode.OPAQUE_CHECK}, phase = CompilePhase.AFTER_MACRO_EXPANSION)\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestOpaqueCheckNodes.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestOpaqueGuardNodes.java","status":"renamed"},{"patch":"@@ -3140,1 +3140,1 @@\n-    public static final String OPAQUE_GUARD = PREFIX + \"OPAQUE_GUARD\" + POSTFIX;\n+    public static final String OPAQUE_CHECK = PREFIX + \"OPAQUE_CHECK\" + POSTFIX;\n@@ -3142,1 +3142,1 @@\n-        beforeMatchingNameRegex(OPAQUE_GUARD, \"OpaqueGuard\");\n+        beforeMatchingNameRegex(OPAQUE_CHECK, \"OpaqueCheck\");\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,3 +68,3 @@\n-    private static final String CALL_STATIC_JAVA_AND_THEN_OPAQUE_NOT_NULL = IRNode.START + \"CallStaticJava\" + SKIP + \"OpaqueNotNull\" + IRNode.MID + IRNode.END;\n-    private static final String OPAQUE_NOT_NULL_AND_THEN_CALL_STATIC_JAVA = IRNode.START + \"OpaqueNotNull\" + SKIP + \"CallStaticJava\" + IRNode.MID + IRNode.END;\n-    \/* Having both CallStaticJava and OpaqueNotNull, in any order. We use that in a failOn to make sure we have one\n+    private static final String CALL_STATIC_JAVA_AND_THEN_OPAQUE_CHECK = IRNode.START + \"CallStaticJava\" + SKIP + \"OpaqueCheck\" + IRNode.MID + IRNode.END;\n+    private static final String OPAQUE_CHECK_AND_THEN_CALL_STATIC_JAVA = IRNode.START + \"OpaqueCheck\" + SKIP + \"CallStaticJava\" + IRNode.MID + IRNode.END;\n+    \/* Having both CallStaticJava and OpaqueCheck, in any order. We use that in a failOn to make sure we have one\n@@ -72,1 +72,1 @@\n-     * The CallStaticJava happens when the call is not intrinsified, and the OpaqueNotNull comes from the intrinsic.\n+     * The CallStaticJava happens when the call is not intrinsified, and the OpaqueCheck comes from the intrinsic.\n@@ -76,1 +76,1 @@\n-            \"(\" + CALL_STATIC_JAVA_AND_THEN_OPAQUE_NOT_NULL + \") | (\" + OPAQUE_NOT_NULL_AND_THEN_CALL_STATIC_JAVA + \")\";\n+            \"(\" + CALL_STATIC_JAVA_AND_THEN_OPAQUE_CHECK + \") | (\" + OPAQUE_CHECK_AND_THEN_CALL_STATIC_JAVA + \")\";\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/OpaqueAccesses.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}