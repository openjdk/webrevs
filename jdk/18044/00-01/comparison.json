{"files":[{"patch":"@@ -41,1 +41,1 @@\n-import java.util.HashSet;\n+import java.util.List;\n@@ -128,19 +128,2 @@\n-        Set<String> loadedClasses = new HashSet<>(Set.of(classNames));\n-        int attempt = 0;\n-        while (!loadedClasses.isEmpty() && attempt < 20) {\n-            ClassUnloadCommon.triggerUnloading();\n-            for (String className : classNames) {\n-                if (loadedClasses.contains(className)) {\n-                    if (wb.isClassAlive(className)) {\n-                        \/\/ Parallel threads cleaning types in profiles might need more time,\n-                        \/\/ especially when TypeProfileWidth is 8 (default for UseJVMCICompiler).\n-                        Thread.sleep(100);\n-                    } else {\n-                        loadedClasses.remove(className);\n-                    }\n-                }\n-            }\n-            attempt++;\n-        }\n-        ClassUnloadCommon.failIf(!loadedClasses.isEmpty(), \"should be unloaded: \" + loadedClasses);\n-        System.err.printf(\"Classes unloaded after %d attempts%n\", attempt);\n+        Set<String> aliveClasses = ClassUnloadCommon.triggerUnloading(List.of(classNames));\n+        ClassUnloadCommon.failIf(!aliveClasses.isEmpty(), \"should be unloaded: \" + aliveClasses);\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassInitErrors\/InitExceptionUnloadTest.java","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,3 @@\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n@@ -70,0 +73,34 @@\n+    \/**\n+     * Calls triggerUnloading() in a retry loop for 2 seconds until WhiteBox.isClassAlive\n+     * determines that no classes named in classNames are alive.\n+     *\n+     * This variant of triggerUnloading() accommodates the inherent raciness\n+     * of class unloading. For example, it's possible for a JIT compilation to hold\n+     * strong roots to types (e.g. in virtual call or instanceof profiles) that\n+     * are not released or converted to weak roots until the compilation completes.\n+     *\n+     * @return the set of classes that have not been unloaded after exiting the retry loop\n+     *\/\n+    public static Set<String> triggerUnloading(List<String> classNames) {\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        Set<String> aliveClasses = new HashSet<>(classNames);\n+        int attempt = 0;\n+        while (!aliveClasses.isEmpty() && attempt < 20) {\n+            ClassUnloadCommon.triggerUnloading();\n+            for (String className : classNames) {\n+                if (aliveClasses.contains(className)) {\n+                    if (wb.isClassAlive(className)) {\n+                        try {\n+                            Thread.sleep(100);\n+                        } catch (InterruptedException ex) {\n+                        }\n+                    } else {\n+                        aliveClasses.remove(className);\n+                    }\n+                }\n+            }\n+            attempt++;\n+        }\n+        return aliveClasses;\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/classloader\/ClassUnloadCommon.java","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"}]}