{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import java.nio.CharBuffer;\n@@ -543,238 +544,1 @@\n-        \/\/ protect against huge length, negative values, and integer overflow\n-        try {\n-            Objects.checkFromIndexSize(offset, len, in.length);\n-        } catch (IndexOutOfBoundsException e) {\n-            throw new NumberFormatException\n-                (\"Bad offset or len arguments for char[] input.\");\n-        }\n-\n-        \/\/ This is the primary string to BigDecimal constructor; all\n-        \/\/ incoming strings end up here; it uses explicit (inline)\n-        \/\/ parsing for speed and generates at most one intermediate\n-        \/\/ (temporary) object (a char[] array) for non-compact case.\n-\n-        \/\/ Use locals for all fields values until completion\n-        int prec = 0;                 \/\/ record precision value\n-        long scl = 0;                 \/\/ record scale value\n-        long rs = 0;                  \/\/ the compact value in long\n-        BigInteger rb = null;         \/\/ the inflated value in BigInteger\n-        \/\/ use array bounds checking to handle too-long, len == 0,\n-        \/\/ bad offset, etc.\n-        try {\n-            \/\/ handle the sign\n-            char c = in[offset];\n-            boolean isneg = c == '-'; \/\/ leading minus means negative\n-            if (isneg || c == '+') {\n-                c = in[++offset];\n-                len--;\n-            }\n-\n-            \/\/ should now be at numeric part of the significand\n-            boolean dot = false;             \/\/ true when there is a '.'\n-            boolean isCompact = (len <= MAX_COMPACT_DIGITS);\n-            \/\/ integer significand array & idx is the index to it. The array\n-            \/\/ is ONLY used when we can't use a compact representation.\n-            if (isCompact) {\n-                \/\/ First compact case, we need not to preserve the character\n-                \/\/ and we can just compute the value in place.\n-                for (; ; ) {\n-                    if ((c == '0')) { \/\/ have zero\n-                        if (prec == 0)\n-                            prec = 1;\n-                        else if (rs != 0) {\n-                            rs *= 10;\n-                            ++prec;\n-                        } \/\/ else digit is a redundant leading zero\n-                        if (dot)\n-                            ++scl;\n-                    } else if ((c >= '1' && c <= '9')) { \/\/ have digit\n-                        int digit = c - '0';\n-                        if (prec != 1 || rs != 0)\n-                            ++prec; \/\/ prec unchanged if preceded by 0s\n-                        rs = rs * 10 + digit;\n-                        if (dot)\n-                            ++scl;\n-                    } else if (c == '.') {   \/\/ have dot\n-                        \/\/ have dot\n-                        if (dot) \/\/ two dots\n-                            throw new NumberFormatException(\"Character array\"\n-                                + \" contains more than one decimal point.\");\n-                        dot = true;\n-                    } else if (Character.isDigit(c)) { \/\/ slow path\n-                        int digit = Character.digit(c, 10);\n-                        if (digit == 0) {\n-                            if (prec == 0)\n-                                prec = 1;\n-                            else if (rs != 0) {\n-                                rs *= 10;\n-                                ++prec;\n-                            } \/\/ else digit is a redundant leading zero\n-                        } else {\n-                            if (prec != 1 || rs != 0)\n-                                ++prec; \/\/ prec unchanged if preceded by 0s\n-                            rs = rs * 10 + digit;\n-                        }\n-                        if (dot)\n-                            ++scl;\n-                    } else if ((c == 'e') || (c == 'E')) {\n-                        scl -= parseExp(in, offset, len);\n-                        break; \/\/ [saves a test]\n-                    } else {\n-                        throw new NumberFormatException(\"Character \" + c\n-                            + \" is neither a decimal digit number, decimal point, nor\"\n-                            + \" \\\"e\\\" notation exponential mark.\");\n-                    }\n-\n-                    if (--len == 0)\n-                        break;\n-                    c = in[++offset];\n-                }\n-                if (prec == 0) \/\/ no digits found\n-                    throw new NumberFormatException(\"No digits found.\");\n-                if (isneg)\n-                    rs = -rs;\n-                int mcp = mc.precision;\n-                int drop = prec - mcp; \/\/ prec has range [1, MAX_INT], mcp has range [0, MAX_INT];\n-                                       \/\/ therefore, this subtraction cannot overflow\n-                if (mcp > 0 && drop > 0) {  \/\/ do rounding\n-                    while (drop > 0) {\n-                        scl -= drop;\n-                        rs = divideAndRound(rs, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);\n-                        prec = longDigitLength(rs);\n-                        drop = prec - mcp;\n-                    }\n-                }\n-            } else {\n-                int start = offset;\n-                for (int idx = 0; ; ) {\n-                    \/\/ have digit\n-                    if ((c >= '0' && c <= '9') || Character.isDigit(c)) {\n-                        \/\/ First compact case, we need not to preserve the character\n-                        \/\/ and we can just compute the value in place.\n-                        if (c == '0' || Character.digit(c, 10) == 0) {\n-                            if (prec == 0) {\n-                                start = offset;\n-                                prec = 1;\n-                            } else if (idx != 0) {\n-                                ++idx;\n-                                ++prec;\n-                            } else\n-                                start = offset + 1;\n-                        } else {\n-                            if (prec != 1 || idx != 0)\n-                                ++prec; \/\/ prec unchanged if preceded by 0s\n-                            ++idx;\n-                        }\n-                        if (dot)\n-                            ++scl;\n-                    } else if (c == '.') {\n-                        \/\/ have dot\n-                        if (dot) \/\/ two dots\n-                            throw new NumberFormatException(\"Character array\"\n-                                + \" contains more than one decimal point.\");\n-                        dot = true;\n-                        if (idx == 0 && prec == 1)\n-                            start = offset;\n-                    } else if (c == 'e' || c == 'E') {\n-                        scl -= parseExp(in, offset, len);\n-                        break; \/\/ [saves a test]\n-                    } else\n-                        throw new NumberFormatException(\"Character \" + c\n-                            + \" is neither a decimal digit number, decimal point, nor\"\n-                            + \" \\\"e\\\" notation exponential mark.\");\n-\n-                    if (--len == 0)\n-                        break;\n-                    c = in[++offset];\n-                }\n-                \/\/ here when no characters left\n-                if (prec == 0) \/\/ no digits found\n-                    throw new NumberFormatException(\"No digits found.\");\n-                \/\/ Remove leading zeros from precision (digits count)\n-                rb = new BigInteger(in, isneg ? -1 : 1, start, prec);\n-                rs = compactValFor(rb);\n-                int mcp = mc.precision;\n-                if (mcp > 0 && (prec > mcp)) {\n-                    if (rs == INFLATED) {\n-                        int drop = prec - mcp;\n-                        while (drop > 0) {\n-                            scl -= drop;\n-                            rb = divideAndRoundByTenPow(rb, drop, mc.roundingMode.oldMode);\n-                            rs = compactValFor(rb);\n-                            if (rs != INFLATED) {\n-                                prec = longDigitLength(rs);\n-                                break;\n-                            }\n-                            prec = bigDigitLength(rb);\n-                            drop = prec - mcp;\n-                        }\n-                    }\n-                    if (rs != INFLATED) {\n-                        int drop = prec - mcp;\n-                        while (drop > 0) {\n-                            scl -= drop;\n-                            rs = divideAndRound(rs, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);\n-                            prec = longDigitLength(rs);\n-                            drop = prec - mcp;\n-                        }\n-                        rb = null;\n-                    }\n-                }\n-            }\n-        } catch (ArrayIndexOutOfBoundsException | NegativeArraySizeException e) {\n-            NumberFormatException nfe = new NumberFormatException();\n-            nfe.initCause(e);\n-            throw nfe;\n-        }\n-        if ((int) scl != scl) \/\/ overflow\n-            throw new NumberFormatException(\"Exponent overflow.\");\n-        this.scale = (int) scl;\n-        this.precision = prec;\n-        this.intCompact = rs;\n-        this.intVal = rb;\n-    }\n-\n-    \/*\n-     * parse exponent\n-     *\/\n-    private static long parseExp(char[] in, int offset, int len){\n-        long exp = 0;\n-        offset++;\n-        char c = in[offset];\n-        len--;\n-        boolean negexp = (c == '-');\n-        \/\/ optional sign\n-        if (negexp || c == '+') {\n-            offset++;\n-            c = in[offset];\n-            len--;\n-        }\n-        if (len <= 0) \/\/ no exponent digits\n-            throw new NumberFormatException(\"No exponent digits.\");\n-        \/\/ skip leading zeros in the exponent\n-        while (len > 10 && (c=='0' || (Character.digit(c, 10) == 0))) {\n-            offset++;\n-            c = in[offset];\n-            len--;\n-        }\n-        if (len > 10) \/\/ too many nonzero exponent digits\n-            throw new NumberFormatException(\"Too many nonzero exponent digits.\");\n-        \/\/ c now holds first digit of exponent\n-        for (;; len--) {\n-            int v;\n-            if (c >= '0' && c <= '9') {\n-                v = c - '0';\n-            } else {\n-                v = Character.digit(c, 10);\n-                if (v < 0) \/\/ not a digit\n-                    throw new NumberFormatException(\"Not a digit.\");\n-            }\n-            exp = exp * 10 + v;\n-            if (len == 1)\n-                break; \/\/ that was final character\n-            offset++;\n-            c = in[offset];\n-        }\n-        if (negexp) \/\/ apply sign\n-            exp = -exp;\n-        return exp;\n+        this(CharBuffer.wrap(in, offset, len), mc);\n@@ -786,1 +550,1 @@\n-    private static long parseExp(String in, int offset, int len){\n+    private static long parseExp(CharSequence in, int offset, int len){\n@@ -971,1 +735,1 @@\n-        this(val, MathContext.UNLIMITED);\n+        this((CharSequence) val, MathContext.UNLIMITED);\n@@ -987,0 +751,4 @@\n+        this((CharSequence) val, mc);\n+    }\n+\n+    private BigDecimal(CharSequence val, MathContext mc) {\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":8,"deletions":240,"binary":false,"changes":248,"status":"modified"},{"patch":"@@ -609,1 +609,1 @@\n-    BigInteger(String val, int sign, int off, int numDigits) {\n+    BigInteger(CharSequence val, int sign, int off, int numDigits) {\n@@ -638,51 +638,1 @@\n-                    throw new NumberFormatException(val);\n-                numIndex++;\n-                groupVal = 10 * groupVal + nextVal;\n-            } while (numIndex < end);\n-\n-            if (groupIndex == 0)\n-                magnitude[numWords - 1] = groupVal;\n-            else\n-                destructiveMulAdd(magnitude, intRadix[10], groupVal);\n-        }\n-\n-        mag = trustedStripLeadingZeroInts(magnitude);\n-        if (mag.length >= MAX_MAG_LENGTH) {\n-            checkRange();\n-        }\n-    }\n-\n-    \/*\n-     * Constructs a new BigInteger using a String with radix=10.\n-     * dot is allowed in the val.\n-     *\/\n-    BigInteger(char[] val, int sign, int off, int numDigits) {\n-        signum = sign;\n-        \/\/ Pre-allocate array of expected size\n-        int numWords;\n-        if (numDigits < 10)\n-            numWords = 1;\n-        else {\n-            long numBits = ((numDigits * bitsPerDigit[10]) >>> 10) + 1;\n-            if (numBits + 31 >= (1L << 32))\n-                reportOverflow();\n-            numWords = (int) (numBits + 31) >>> 5;\n-        }\n-        int[] magnitude = new int[numWords];\n-\n-        \/\/ Process first (potentially short) digit group\n-        int digitsPerInt10 = digitsPerInt[10];\n-        int firstGroupLen = numDigits % digitsPerInt10;\n-        if (firstGroupLen == 0)\n-            firstGroupLen = digitsPerInt10;\n-\n-        for (int numIndex = 0, groupIndex = 0; numIndex < numDigits; ++groupIndex) {\n-            int end = numIndex + (groupIndex == 0 ? firstGroupLen : digitsPerInt10);\n-            int groupVal = 0;\n-            do {\n-                char c = val[off++];\n-                if (c == '.')\n-                    continue;\n-                int nextVal = Character.digit(c, 10);\n-                if (nextVal == -1)\n-                    throw new NumberFormatException(new String(val));\n+                    throw new NumberFormatException(val.toString());\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":2,"deletions":52,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -61,2 +61,2 @@\n-    private String[] stringInputs;\n-    private char[][] charArrayInputs;\n+    private String[] stringInputs, stringHugeInputs, stringLargeInputs, stringSmallInputs;\n+    private char[][] charArrayInputs, charArrayHugeInputs, charArrayLargeInputs, charArraySmallInputs;\n@@ -71,0 +71,1 @@\n+\n@@ -72,0 +73,4 @@\n+        stringHugeInputs = new String[TEST_SIZE];\n+        stringLargeInputs = new String[TEST_SIZE];\n+        stringSmallInputs = new String[TEST_SIZE];\n+\n@@ -73,0 +78,4 @@\n+        charArrayHugeInputs = new char[TEST_SIZE][];\n+        charArrayLargeInputs = new char[TEST_SIZE][];\n+        charArraySmallInputs = new char[TEST_SIZE][];\n+\n@@ -91,0 +100,1 @@\n+\n@@ -92,0 +102,4 @@\n+            stringHugeInputs[i] = \"\" + -(i + 1) * 5434543453454355e100;\n+            stringLargeInputs[i] = \"\" + -(i + 1) * 5434543453454355e100;\n+            stringSmallInputs[i] = \"\" + -(i + 1) * 54345.0d;\n+\n@@ -93,0 +107,4 @@\n+            charArrayHugeInputs[i] = stringHugeInputs[i].toCharArray();\n+            charArrayLargeInputs[i] = stringLargeInputs[i].toCharArray();\n+            charArraySmallInputs[i] = stringSmallInputs[i].toCharArray();\n+\n@@ -130,0 +148,27 @@\n+    \/** Invokes the (String)-constructor of BigDecimal with huge values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testConstructorWithHugeString(Blackhole bh) {\n+        for (String s : stringHugeInputs) {\n+            bh.consume(new BigDecimal(s));\n+        }\n+    }\n+\n+    \/** Invokes the (String)-constructor of BigDecimal with large values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testConstructorWithLargeString(Blackhole bh) {\n+        for (String s : stringLargeInputs) {\n+            bh.consume(new BigDecimal(s));\n+        }\n+    }\n+\n+    \/** Invokes the (String)-constructor of BigDecimal with small values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testConstructorWithSmallString(Blackhole bh) {\n+        for (String s : stringSmallInputs) {\n+            bh.consume(new BigDecimal(s));\n+        }\n+    }\n+\n@@ -139,0 +184,28 @@\n+    \/** Invokes the (char[])-constructor of BigDecimal with huge values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testConstructorWithHugeCharArray(Blackhole bh) {\n+        for (char[] s : charArrayHugeInputs) {\n+            bh.consume(new BigDecimal(s));\n+        }\n+    }\n+\n+    \/** Invokes the (char[])-constructor of BigDecimal with large values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testConstructorWithLargeCharArray(Blackhole bh) {\n+        for (char[] s : charArrayLargeInputs) {\n+            bh.consume(new BigDecimal(s));\n+        }\n+    }\n+\n+    \/** Invokes the (char[])-constructor of BigDecimal with small values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testConstructorWithSmallCharArray(Blackhole bh) {\n+        for (char[] s : charArraySmallInputs) {\n+            bh.consume(new BigDecimal(s));\n+        }\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigDecimals.java","additions":75,"deletions":2,"binary":false,"changes":77,"status":"modified"}]}