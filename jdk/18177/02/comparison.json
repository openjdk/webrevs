{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import java.nio.CharBuffer;\n@@ -543,191 +544,1 @@\n-        \/\/ protect against huge length, negative values, and integer overflow\n-        try {\n-            Objects.checkFromIndexSize(offset, len, in.length);\n-        } catch (IndexOutOfBoundsException e) {\n-            throw new NumberFormatException\n-                (\"Bad offset or len arguments for char[] input.\");\n-        }\n-\n-        \/\/ This is the primary string to BigDecimal constructor; all\n-        \/\/ incoming strings end up here; it uses explicit (inline)\n-        \/\/ parsing for speed and generates at most one intermediate\n-        \/\/ (temporary) object (a char[] array) for non-compact case.\n-\n-        \/\/ Use locals for all fields values until completion\n-        int prec = 0;                 \/\/ record precision value\n-        long scl = 0;                 \/\/ record scale value\n-        long rs = 0;                  \/\/ the compact value in long\n-        BigInteger rb = null;         \/\/ the inflated value in BigInteger\n-        \/\/ use array bounds checking to handle too-long, len == 0,\n-        \/\/ bad offset, etc.\n-        try {\n-            \/\/ handle the sign\n-            boolean isneg = false;          \/\/ assume positive\n-            if (in[offset] == '-') {\n-                isneg = true;               \/\/ leading minus means negative\n-                offset++;\n-                len--;\n-            } else if (in[offset] == '+') { \/\/ leading + allowed\n-                offset++;\n-                len--;\n-            }\n-\n-            \/\/ should now be at numeric part of the significand\n-            boolean dot = false;             \/\/ true when there is a '.'\n-            char c;                          \/\/ current character\n-            boolean isCompact = (len <= MAX_COMPACT_DIGITS);\n-            \/\/ integer significand array & idx is the index to it. The array\n-            \/\/ is ONLY used when we can't use a compact representation.\n-            int idx = 0;\n-            if (isCompact) {\n-                \/\/ First compact case, we need not to preserve the character\n-                \/\/ and we can just compute the value in place.\n-                for (; len > 0; offset++, len--) {\n-                    c = in[offset];\n-                    if ((c == '0')) { \/\/ have zero\n-                        if (prec == 0)\n-                            prec = 1;\n-                        else if (rs != 0) {\n-                            rs *= 10;\n-                            ++prec;\n-                        } \/\/ else digit is a redundant leading zero\n-                        if (dot)\n-                            ++scl;\n-                    } else if ((c >= '1' && c <= '9')) { \/\/ have digit\n-                        int digit = c - '0';\n-                        if (prec != 1 || rs != 0)\n-                            ++prec; \/\/ prec unchanged if preceded by 0s\n-                        rs = rs * 10 + digit;\n-                        if (dot)\n-                            ++scl;\n-                    } else if (c == '.') {   \/\/ have dot\n-                        \/\/ have dot\n-                        if (dot) \/\/ two dots\n-                            throw new NumberFormatException(\"Character array\"\n-                                + \" contains more than one decimal point.\");\n-                        dot = true;\n-                    } else if (Character.isDigit(c)) { \/\/ slow path\n-                        int digit = Character.digit(c, 10);\n-                        if (digit == 0) {\n-                            if (prec == 0)\n-                                prec = 1;\n-                            else if (rs != 0) {\n-                                rs *= 10;\n-                                ++prec;\n-                            } \/\/ else digit is a redundant leading zero\n-                        } else {\n-                            if (prec != 1 || rs != 0)\n-                                ++prec; \/\/ prec unchanged if preceded by 0s\n-                            rs = rs * 10 + digit;\n-                        }\n-                        if (dot)\n-                            ++scl;\n-                    } else if ((c == 'e') || (c == 'E')) {\n-                        scl -= parseExp(in, offset, len);\n-                        break; \/\/ [saves a test]\n-                    } else {\n-                        throw new NumberFormatException(\"Character \" + c\n-                            + \" is neither a decimal digit number, decimal point, nor\"\n-                            + \" \\\"e\\\" notation exponential mark.\");\n-                    }\n-                }\n-                if (prec == 0) \/\/ no digits found\n-                    throw new NumberFormatException(\"No digits found.\");\n-                rs = isneg ? -rs : rs;\n-                int mcp = mc.precision;\n-                int drop = prec - mcp; \/\/ prec has range [1, MAX_INT], mcp has range [0, MAX_INT];\n-                                       \/\/ therefore, this subtraction cannot overflow\n-                if (mcp > 0 && drop > 0) {  \/\/ do rounding\n-                    while (drop > 0) {\n-                        scl -= drop;\n-                        rs = divideAndRound(rs, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);\n-                        prec = longDigitLength(rs);\n-                        drop = prec - mcp;\n-                    }\n-                }\n-            } else {\n-                char[] coeff = new char[len];\n-                for (; len > 0; offset++, len--) {\n-                    c = in[offset];\n-                    \/\/ have digit\n-                    if ((c >= '0' && c <= '9') || Character.isDigit(c)) {\n-                        \/\/ First compact case, we need not to preserve the character\n-                        \/\/ and we can just compute the value in place.\n-                        if (c == '0' || Character.digit(c, 10) == 0) {\n-                            if (prec == 0) {\n-                                coeff[idx] = c;\n-                                prec = 1;\n-                            } else if (idx != 0) {\n-                                coeff[idx++] = c;\n-                                ++prec;\n-                            } \/\/ else c must be a redundant leading zero\n-                        } else {\n-                            if (prec != 1 || idx != 0)\n-                                ++prec; \/\/ prec unchanged if preceded by 0s\n-                            coeff[idx++] = c;\n-                        }\n-                        if (dot)\n-                            ++scl;\n-                        continue;\n-                    }\n-                    \/\/ have dot\n-                    if (c == '.') {\n-                        \/\/ have dot\n-                        if (dot) \/\/ two dots\n-                            throw new NumberFormatException(\"Character array\"\n-                                + \" contains more than one decimal point.\");\n-                        dot = true;\n-                        continue;\n-                    }\n-                    \/\/ exponent expected\n-                    if ((c != 'e') && (c != 'E'))\n-                        throw new NumberFormatException(\"Character array\"\n-                            + \" is missing \\\"e\\\" notation exponential mark.\");\n-                    scl -= parseExp(in, offset, len);\n-                    break; \/\/ [saves a test]\n-                }\n-                \/\/ here when no characters left\n-                if (prec == 0) \/\/ no digits found\n-                    throw new NumberFormatException(\"No digits found.\");\n-                \/\/ Remove leading zeros from precision (digits count)\n-                rb = new BigInteger(coeff, isneg ? -1 : 1, prec);\n-                rs = compactValFor(rb);\n-                int mcp = mc.precision;\n-                if (mcp > 0 && (prec > mcp)) {\n-                    if (rs == INFLATED) {\n-                        int drop = prec - mcp;\n-                        while (drop > 0) {\n-                            scl -= drop;\n-                            rb = divideAndRoundByTenPow(rb, drop, mc.roundingMode.oldMode);\n-                            rs = compactValFor(rb);\n-                            if (rs != INFLATED) {\n-                                prec = longDigitLength(rs);\n-                                break;\n-                            }\n-                            prec = bigDigitLength(rb);\n-                            drop = prec - mcp;\n-                        }\n-                    }\n-                    if (rs != INFLATED) {\n-                        int drop = prec - mcp;\n-                        while (drop > 0) {\n-                            scl -= drop;\n-                            rs = divideAndRound(rs, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);\n-                            prec = longDigitLength(rs);\n-                            drop = prec - mcp;\n-                        }\n-                        rb = null;\n-                    }\n-                }\n-            }\n-        } catch (ArrayIndexOutOfBoundsException | NegativeArraySizeException e) {\n-            NumberFormatException nfe = new NumberFormatException();\n-            nfe.initCause(e);\n-            throw nfe;\n-        }\n-        if ((int) scl != scl) \/\/ overflow\n-            throw new NumberFormatException(\"Exponent overflow.\");\n-        this.scale = (int) scl;\n-        this.precision = prec;\n-        this.intCompact = rs;\n-        this.intVal = rb;\n+        this(CharBuffer.wrap(in, offset, len), mc);\n@@ -739,1 +550,1 @@\n-    private static long parseExp(char[] in, int offset, int len){\n+    private static long parseExp(CharSequence in, int offset, int len){\n@@ -742,1 +553,1 @@\n-        char c = in[offset];\n+        char c = in.charAt(offset);\n@@ -748,1 +559,1 @@\n-            c = in[offset];\n+            c = in.charAt(offset);\n@@ -756,1 +567,1 @@\n-            c = in[offset];\n+            c = in.charAt(offset);\n@@ -775,1 +586,1 @@\n-            c = in[offset];\n+            c = in.charAt(offset);\n@@ -924,1 +735,1 @@\n-        this(val.toCharArray(), 0, val.length());\n+        this((CharSequence) val, MathContext.UNLIMITED);\n@@ -940,1 +751,184 @@\n-        this(val.toCharArray(), 0, val.length(), mc);\n+        this((CharSequence) val, mc);\n+    }\n+\n+    private BigDecimal(CharSequence val, MathContext mc) {\n+        \/\/ Use locals for all fields values until completion\n+        int prec = 0;                 \/\/ record precision value\n+        long scl = 0;                 \/\/ record scale value\n+        long rs = 0;                  \/\/ the compact value in long\n+        BigInteger rb = null;         \/\/ the inflated value in BigInteger\n+        \/\/ use String bounds checking to handle too-long, len == 0,\n+        try {\n+            int len = val.length();\n+            int offset = 0;\n+            char c = val.charAt(offset);\n+            boolean isneg = c == '-'; \/\/ leading minus means negative\n+            if (isneg || c == '+') {\n+                c = val.charAt(++offset);\n+                len--;\n+            }\n+\n+            \/\/ should now be at numeric part of the significand\n+            boolean dot = false;             \/\/ true when there is a '.'\n+            boolean isCompact = (len <= MAX_COMPACT_DIGITS);\n+            \/\/ integer significand array & idx is the index to it. The array\n+            \/\/ is ONLY used when we can't use a compact representation.\n+            if (isCompact) {\n+                \/\/ First compact case, we need not to preserve the character\n+                \/\/ and we can just compute the value in place.\n+                for (; ; ) {\n+                    if ((c == '0')) { \/\/ have zero\n+                        if (prec == 0)\n+                            prec = 1;\n+                        else if (rs != 0) {\n+                            rs *= 10;\n+                            ++prec;\n+                        } \/\/ else digit is a redundant leading zero\n+                        if (dot)\n+                            ++scl;\n+                    } else if ((c >= '1' && c <= '9')) { \/\/ have digit\n+                        int digit = c - '0';\n+                        if (prec != 1 || rs != 0)\n+                            ++prec; \/\/ prec unchanged if preceded by 0s\n+                        rs = rs * 10 + digit;\n+                        if (dot)\n+                            ++scl;\n+                    } else if (c == '.') {   \/\/ have dot\n+                        \/\/ have dot\n+                        if (dot) \/\/ two dots\n+                            throw new NumberFormatException(\"Character array\"\n+                                + \" contains more than one decimal point.\");\n+                        dot = true;\n+                    } else if (Character.isDigit(c)) { \/\/ slow path\n+                        int digit = Character.digit(c, 10);\n+                        if (digit == 0) {\n+                            if (prec == 0)\n+                                prec = 1;\n+                            else if (rs != 0) {\n+                                rs *= 10;\n+                                ++prec;\n+                            } \/\/ else digit is a redundant leading zero\n+                        } else {\n+                            if (prec != 1 || rs != 0)\n+                                ++prec; \/\/ prec unchanged if preceded by 0s\n+                            rs = rs * 10 + digit;\n+                        }\n+                        if (dot)\n+                            ++scl;\n+                    } else if (c == 'e' || c == 'E') {\n+                        scl -= parseExp(val, offset, len);\n+                        break; \/\/ [saves a test]\n+                    } else\n+                        throw new NumberFormatException(\"Character \" + c\n+                            + \" is neither a decimal digit number, decimal point, nor\"\n+                            + \" \\\"e\\\" notation exponential mark.\");\n+\n+                    if (--len == 0)\n+                        break;\n+                    c = val.charAt(++offset);\n+                }\n+                if (prec == 0) \/\/ no digits found\n+                    throw new NumberFormatException(\"No digits found.\");\n+                if (isneg)\n+                    rs = -rs;\n+                int mcp = mc.precision;\n+                int drop = prec - mcp; \/\/ prec has range [1, MAX_INT], mcp has range [0, MAX_INT];\n+                \/\/ therefore, this subtraction cannot overflow\n+                if (mcp > 0 && drop > 0) {  \/\/ do rounding\n+                    while (drop > 0) {\n+                        scl -= drop;\n+                        rs = divideAndRound(rs, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);\n+                        prec = longDigitLength(rs);\n+                        drop = prec - mcp;\n+                    }\n+                }\n+            } else {\n+                int start = offset;\n+                for (int idx = 0; ; ) {\n+                    \/\/ have digit\n+                    if ((c >= '0' && c <= '9') || Character.isDigit(c)) {\n+                        \/\/ First compact case, we need not to preserve the character\n+                        \/\/ and we can just compute the value in place.\n+                        if (c == '0' || Character.digit(c, 10) == 0) {\n+                            if (prec == 0) {\n+                                start = offset;\n+                                prec = 1;\n+                            } else if (idx != 0) {\n+                                ++idx;\n+                                ++prec;\n+                            } else\n+                                start = offset + 1;\n+                        } else {\n+                            if (prec != 1 || idx != 0)\n+                                ++prec; \/\/ prec unchanged if preceded by 0s\n+                            ++idx;\n+                        }\n+                        if (dot)\n+                            ++scl;\n+                    } else if (c == '.') {\n+                        \/\/ have dot\n+                        if (dot) \/\/ two dots\n+                            throw new NumberFormatException(\"Character array\"\n+                                + \" contains more than one decimal point.\");\n+                        dot = true;\n+                        if (idx == 0 && prec == 1)\n+                            start = offset;\n+                    } else {\n+                        \/\/ exponent expected\n+                        if ((c != 'e') && (c != 'E'))\n+                            throw new NumberFormatException(\"Character array\"\n+                                + \" is missing \\\"e\\\" notation exponential mark.\");\n+                        scl -= parseExp(val, offset, len);\n+                        break; \/\/ [saves a test]\n+                    }\n+\n+                    if (--len == 0)\n+                        break;\n+                    c = val.charAt(++offset);\n+                }\n+                \/\/ here when no characters left\n+                if (prec == 0) \/\/ no digits found\n+                    throw new NumberFormatException(\"No digits found.\");\n+\n+                \/\/ Remove leading zeros from precision (digits count)\n+                rb = new BigInteger(val, isneg ? -1 : 1, start, prec);\n+                rs = compactValFor(rb);\n+                int mcp = mc.precision;\n+                if (mcp > 0 && (prec > mcp)) {\n+                    if (rs == INFLATED) {\n+                        int drop = prec - mcp;\n+                        while (drop > 0) {\n+                            scl -= drop;\n+                            rb = divideAndRoundByTenPow(rb, drop, mc.roundingMode.oldMode);\n+                            rs = compactValFor(rb);\n+                            if (rs != INFLATED) {\n+                                prec = longDigitLength(rs);\n+                                break;\n+                            }\n+                            prec = bigDigitLength(rb);\n+                            drop = prec - mcp;\n+                        }\n+                    }\n+                    if (rs != INFLATED) {\n+                        int drop = prec - mcp;\n+                        while (drop > 0) {\n+                            scl -= drop;\n+                            rs = divideAndRound(rs, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);\n+                            prec = longDigitLength(rs);\n+                            drop = prec - mcp;\n+                        }\n+                        rb = null;\n+                    }\n+                }\n+            }\n+        } catch (StringIndexOutOfBoundsException e) {\n+            NumberFormatException nfe = new NumberFormatException();\n+            nfe.initCause(e);\n+            throw nfe;\n+        }\n+        if ((int) scl != scl) \/\/ overflow\n+            throw new NumberFormatException(\"Exponent overflow.\");\n+        this.scale = (int) scl;\n+        this.precision = prec;\n+        this.intCompact = rs;\n+        this.intVal = rb;\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":192,"deletions":198,"binary":false,"changes":390,"status":"modified"},{"patch":"@@ -606,4 +606,2 @@\n-     * Constructs a new BigInteger using a char array with radix=10.\n-     * Sign is precalculated outside and not allowed in the val. The {@code val}\n-     * array is assumed to be unchanged for the duration of the constructor\n-     * call.\n+     * Constructs a new BigInteger using a String with radix=10.\n+     * dot is allowed in the val.\n@@ -611,14 +609,1 @@\n-    BigInteger(char[] val, int sign, int len) {\n-        int cursor = 0, numDigits;\n-\n-        \/\/ Skip leading zeros and compute number of digits in magnitude\n-        while (cursor < len && Character.digit(val[cursor], 10) == 0) {\n-            cursor++;\n-        }\n-        if (cursor == len) {\n-            signum = 0;\n-            mag = ZERO.mag;\n-            return;\n-        }\n-\n-        numDigits = len - cursor;\n+    BigInteger(CharSequence val, int sign, int off, int numDigits) {\n@@ -628,1 +613,1 @@\n-        if (len < 10) {\n+        if (numDigits < 10)\n@@ -630,1 +615,1 @@\n-        } else {\n+        else {\n@@ -632,1 +617,1 @@\n-            if (numBits + 31 >= (1L << 32)) {\n+            if (numBits + 31 >= (1L << 32))\n@@ -634,1 +619,0 @@\n-            }\n@@ -640,1 +624,2 @@\n-        int firstGroupLen = numDigits % digitsPerInt[10];\n+        int digitsPerInt10 = digitsPerInt[10];\n+        int firstGroupLen = numDigits % digitsPerInt10;\n@@ -642,7 +627,20 @@\n-            firstGroupLen = digitsPerInt[10];\n-        magnitude[numWords - 1] = parseInt(val, cursor,  cursor += firstGroupLen);\n-\n-        \/\/ Process remaining digit groups\n-        while (cursor < len) {\n-            int groupVal = parseInt(val, cursor, cursor += digitsPerInt[10]);\n-            destructiveMulAdd(magnitude, intRadix[10], groupVal);\n+            firstGroupLen = digitsPerInt10;\n+\n+        for (int numIndex = 0, groupIndex = 0; numIndex < numDigits; ++groupIndex) {\n+            int end = numIndex + (groupIndex == 0 ? firstGroupLen : digitsPerInt10);\n+            int groupVal = 0;\n+            do {\n+                char c = val.charAt(off++);\n+                if (c == '.')\n+                    continue;\n+                int nextVal = Character.digit(c, 10);\n+                if (nextVal == -1)\n+                    throw new NumberFormatException(val.toString());\n+                numIndex++;\n+                groupVal = 10 * groupVal + nextVal;\n+            } while (numIndex < end);\n+\n+            if (groupIndex == 0)\n+                magnitude[numWords - 1] = groupVal;\n+            else\n+                destructiveMulAdd(magnitude, intRadix[10], groupVal);\n@@ -650,0 +648,1 @@\n+\n@@ -656,18 +655,0 @@\n-    \/\/ Create an integer with the digits between the two indexes\n-    \/\/ Assumes start < end. The result may be negative, but it\n-    \/\/ is to be treated as an unsigned value.\n-    private int parseInt(char[] source, int start, int end) {\n-        int result = Character.digit(source[start++], 10);\n-        if (result == -1)\n-            throw new NumberFormatException(new String(source));\n-\n-        for (int index = start; index < end; index++) {\n-            int nextVal = Character.digit(source[index], 10);\n-            if (nextVal == -1)\n-                throw new NumberFormatException(new String(source));\n-            result = 10*result + nextVal;\n-        }\n-\n-        return result;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":29,"deletions":48,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -105,0 +105,23 @@\n+\n+        String[] strings = new String[] {\n+                \"12\",\n+                \"00000012345\",\n+                \".2e000000000000001\",\n+                \"1.2e000000000000001\",\n+                \"-0.000000000006325524822672631550863255248226726315508\",\n+                \"-6325524822672631550863255248226726315508.6325524822672631550863255248226726315508\",\n+                \"1234e+123\",\n+                \"1234567890123456789012345678901234567890\"\n+        };\n+        for (String s : strings) {\n+            BigDecimal bd = new BigDecimal(s);\n+            BigDecimal bd1 = new BigDecimal(s.toCharArray());\n+            if (!bd.equals(bd1)) {\n+                System.err.println(\"bd string: \" + s);\n+            }\n+            String bdString = bd.toString();\n+            BigDecimal bdDoppel = new BigDecimal(bdString);\n+            if (!bd.equals(bdDoppel)) {\n+                System.err.println(\"bd string: \" + bdString);\n+            }\n+        }\n@@ -139,0 +162,8 @@\n+\n+            BigDecimal tmp1 = new BigDecimal(s.toCharArray());\n+            \/\/ System.err.println(\"Testing \" + s);\n+            if (! expected.equals(tmp1) || tmp.precision() != 1) {\n+                System.err.println(\"Bad conversion of \" + s + \"got \" +\n+                        tmp1 + \"precision = \" + tmp1.precision());\n+                throw new RuntimeException(\"String constructor failure.\");\n+            }\n@@ -172,0 +203,2 @@\n+        if (!expected.equals(new BigDecimal(s.toCharArray())))\n+            throw new RuntimeException(s + \" is not equal to \" + expected);\n","filename":"test\/jdk\/java\/math\/BigDecimal\/StringConstructor.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -61,1 +61,2 @@\n-    private String[] stringInputs;\n+    private String[] stringInputs, stringHugeInputs, stringLargeInputs, stringSmallInputs;\n+    private char[][] charArrayInputs, charArrayHugeInputs, charArrayLargeInputs, charArraySmallInputs;\n@@ -70,0 +71,1 @@\n+\n@@ -71,0 +73,9 @@\n+        stringHugeInputs = new String[TEST_SIZE];\n+        stringLargeInputs = new String[TEST_SIZE];\n+        stringSmallInputs = new String[TEST_SIZE];\n+\n+        charArrayInputs = new char[TEST_SIZE][];\n+        charArrayHugeInputs = new char[TEST_SIZE][];\n+        charArrayLargeInputs = new char[TEST_SIZE][];\n+        charArraySmallInputs = new char[TEST_SIZE][];\n+\n@@ -89,0 +100,1 @@\n+\n@@ -90,0 +102,9 @@\n+            stringHugeInputs[i] = \"\" + -(i + 1) * 5434543453454355e100;\n+            stringLargeInputs[i] = \"\" + -(i + 1) * 5434543453454355e100;\n+            stringSmallInputs[i] = \"\" + -(i + 1) * 54345.0d;\n+\n+            charArrayInputs[i] = stringInputs[i].toCharArray();\n+            charArrayHugeInputs[i] = stringHugeInputs[i].toCharArray();\n+            charArrayLargeInputs[i] = stringLargeInputs[i].toCharArray();\n+            charArraySmallInputs[i] = stringSmallInputs[i].toCharArray();\n+\n@@ -127,0 +148,64 @@\n+    \/** Invokes the (String)-constructor of BigDecimal with huge values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testConstructorWithHugeString(Blackhole bh) {\n+        for (String s : stringHugeInputs) {\n+            bh.consume(new BigDecimal(s));\n+        }\n+    }\n+\n+    \/** Invokes the (String)-constructor of BigDecimal with large values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testConstructorWithLargeString(Blackhole bh) {\n+        for (String s : stringLargeInputs) {\n+            bh.consume(new BigDecimal(s));\n+        }\n+    }\n+\n+    \/** Invokes the (String)-constructor of BigDecimal with small values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testConstructorWithSmallString(Blackhole bh) {\n+        for (String s : stringSmallInputs) {\n+            bh.consume(new BigDecimal(s));\n+        }\n+    }\n+\n+    \/** Invokes the (char[])-constructor of BigDecimal with various different values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testConstructorWithCharArray(Blackhole bh) {\n+        for (char[] s : charArrayInputs) {\n+            bh.consume(new BigDecimal(s));\n+        }\n+    }\n+\n+    \/** Invokes the (char[])-constructor of BigDecimal with huge values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testConstructorWithHugeCharArray(Blackhole bh) {\n+        for (char[] s : charArrayHugeInputs) {\n+            bh.consume(new BigDecimal(s));\n+        }\n+    }\n+\n+    \/** Invokes the (char[])-constructor of BigDecimal with large values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testConstructorWithLargeCharArray(Blackhole bh) {\n+        for (char[] s : charArrayLargeInputs) {\n+            bh.consume(new BigDecimal(s));\n+        }\n+    }\n+\n+    \/** Invokes the (char[])-constructor of BigDecimal with small values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testConstructorWithSmallCharArray(Blackhole bh) {\n+        for (char[] s : charArraySmallInputs) {\n+            bh.consume(new BigDecimal(s));\n+        }\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigDecimals.java","additions":86,"deletions":1,"binary":false,"changes":87,"status":"modified"}]}