{"files":[{"patch":"@@ -565,7 +565,4 @@\n-            boolean isneg = false;          \/\/ assume positive\n-            if (in[offset] == '-') {\n-                isneg = true;               \/\/ leading minus means negative\n-                offset++;\n-                len--;\n-            } else if (in[offset] == '+') { \/\/ leading + allowed\n-                offset++;\n+            char c = in[offset];\n+            boolean isneg = c == '-'; \/\/ leading minus means negative\n+            if (isneg || c == '+') {\n+                c = in[++offset];\n@@ -577,1 +574,0 @@\n-            char c;                          \/\/ current character\n@@ -581,1 +577,0 @@\n-            int idx = 0;\n@@ -585,2 +580,1 @@\n-                for (; len > 0; offset++, len--) {\n-                    c = in[offset];\n+                for (; ; ) {\n@@ -633,0 +627,4 @@\n+\n+                    if (--len == 0)\n+                        break;\n+                    c = in[++offset];\n@@ -636,1 +634,2 @@\n-                rs = isneg ? -rs : rs;\n+                if (isneg)\n+                    rs = -rs;\n@@ -649,3 +648,2 @@\n-                char[] coeff = new char[len];\n-                for (; len > 0; offset++, len--) {\n-                    c = in[offset];\n+                int start = offset;\n+                for (int idx = 0; ; ) {\n@@ -658,1 +656,1 @@\n-                                coeff[idx] = c;\n+                                start = offset;\n@@ -661,1 +659,1 @@\n-                                coeff[idx++] = c;\n+                                ++idx;\n@@ -663,1 +661,2 @@\n-                            } \/\/ else c must be a redundant leading zero\n+                            } else\n+                                start = offset + 1;\n@@ -667,1 +666,1 @@\n-                            coeff[idx++] = c;\n+                            ++idx;\n@@ -671,4 +670,1 @@\n-                        continue;\n-                    }\n-                    \/\/ have dot\n-                    if (c == '.') {\n+                    } else if (c == '.') {\n@@ -680,8 +676,13 @@\n-                        continue;\n-                    }\n-                    \/\/ exponent expected\n-                    if ((c != 'e') && (c != 'E'))\n-                        throw new NumberFormatException(\"Character array\"\n-                            + \" is missing \\\"e\\\" notation exponential mark.\");\n-                    scl -= parseExp(in, offset, len);\n-                    break; \/\/ [saves a test]\n+                        if (idx == 0 && prec == 1)\n+                            start = offset;\n+                    } else if (c == 'e' || c == 'E') {\n+                        scl -= parseExp(in, offset, len);\n+                        break; \/\/ [saves a test]\n+                    } else\n+                        throw new NumberFormatException(\"Character \" + c\n+                            + \" is neither a decimal digit number, decimal point, nor\"\n+                            + \" \\\"e\\\" notation exponential mark.\");\n+\n+                    if (--len == 0)\n+                        break;\n+                    c = in[++offset];\n@@ -693,1 +694,1 @@\n-                rb = new BigInteger(coeff, isneg ? -1 : 1, prec);\n+                rb = new BigInteger(in, isneg ? -1 : 1, start, prec);\n@@ -782,0 +783,46 @@\n+    \/*\n+     * parse exponent\n+     *\/\n+    private static long parseExp(String in, int offset, int len){\n+        long exp = 0;\n+        offset++;\n+        char c = in.charAt(offset);\n+        len--;\n+        boolean negexp = (c == '-');\n+        \/\/ optional sign\n+        if (negexp || c == '+') {\n+            offset++;\n+            c = in.charAt(offset);\n+            len--;\n+        }\n+        if (len <= 0) \/\/ no exponent digits\n+            throw new NumberFormatException(\"No exponent digits.\");\n+        \/\/ skip leading zeros in the exponent\n+        while (len > 10 && (c=='0' || (Character.digit(c, 10) == 0))) {\n+            offset++;\n+            c = in.charAt(offset);\n+            len--;\n+        }\n+        if (len > 10) \/\/ too many nonzero exponent digits\n+            throw new NumberFormatException(\"Too many nonzero exponent digits.\");\n+        \/\/ c now holds first digit of exponent\n+        for (;; len--) {\n+            int v;\n+            if (c >= '0' && c <= '9') {\n+                v = c - '0';\n+            } else {\n+                v = Character.digit(c, 10);\n+                if (v < 0) \/\/ not a digit\n+                    throw new NumberFormatException(\"Not a digit.\");\n+            }\n+            exp = exp * 10 + v;\n+            if (len == 1)\n+                break; \/\/ that was final character\n+            offset++;\n+            c = in.charAt(offset);\n+        }\n+        if (negexp) \/\/ apply sign\n+            exp = -exp;\n+        return exp;\n+    }\n+\n@@ -924,1 +971,1 @@\n-        this(val.toCharArray(), 0, val.length());\n+        this(val, MathContext.UNLIMITED);\n@@ -940,1 +987,180 @@\n-        this(val.toCharArray(), 0, val.length(), mc);\n+        \/\/ Use locals for all fields values until completion\n+        int prec = 0;                 \/\/ record precision value\n+        long scl = 0;                 \/\/ record scale value\n+        long rs = 0;                  \/\/ the compact value in long\n+        BigInteger rb = null;         \/\/ the inflated value in BigInteger\n+        \/\/ use String bounds checking to handle too-long, len == 0,\n+        try {\n+            int len = val.length();\n+            int offset = 0;\n+            char c = val.charAt(offset);\n+            boolean isneg = c == '-'; \/\/ leading minus means negative\n+            if (isneg || c == '+') {\n+                c = val.charAt(++offset);\n+                len--;\n+            }\n+\n+            \/\/ should now be at numeric part of the significand\n+            boolean dot = false;             \/\/ true when there is a '.'\n+            boolean isCompact = (len <= MAX_COMPACT_DIGITS);\n+            \/\/ integer significand array & idx is the index to it. The array\n+            \/\/ is ONLY used when we can't use a compact representation.\n+            if (isCompact) {\n+                \/\/ First compact case, we need not to preserve the character\n+                \/\/ and we can just compute the value in place.\n+                for (; ; ) {\n+                    if ((c == '0')) { \/\/ have zero\n+                        if (prec == 0)\n+                            prec = 1;\n+                        else if (rs != 0) {\n+                            rs *= 10;\n+                            ++prec;\n+                        } \/\/ else digit is a redundant leading zero\n+                        if (dot)\n+                            ++scl;\n+                    } else if ((c >= '1' && c <= '9')) { \/\/ have digit\n+                        int digit = c - '0';\n+                        if (prec != 1 || rs != 0)\n+                            ++prec; \/\/ prec unchanged if preceded by 0s\n+                        rs = rs * 10 + digit;\n+                        if (dot)\n+                            ++scl;\n+                    } else if (c == '.') {   \/\/ have dot\n+                        \/\/ have dot\n+                        if (dot) \/\/ two dots\n+                            throw new NumberFormatException(\"Character array\"\n+                                + \" contains more than one decimal point.\");\n+                        dot = true;\n+                    } else if (Character.isDigit(c)) { \/\/ slow path\n+                        int digit = Character.digit(c, 10);\n+                        if (digit == 0) {\n+                            if (prec == 0)\n+                                prec = 1;\n+                            else if (rs != 0) {\n+                                rs *= 10;\n+                                ++prec;\n+                            } \/\/ else digit is a redundant leading zero\n+                        } else {\n+                            if (prec != 1 || rs != 0)\n+                                ++prec; \/\/ prec unchanged if preceded by 0s\n+                            rs = rs * 10 + digit;\n+                        }\n+                        if (dot)\n+                            ++scl;\n+                    } else if (c == 'e' || c == 'E') {\n+                        scl -= parseExp(val, offset, len);\n+                        break; \/\/ [saves a test]\n+                    } else\n+                        throw new NumberFormatException(\"Character \" + c\n+                            + \" is neither a decimal digit number, decimal point, nor\"\n+                            + \" \\\"e\\\" notation exponential mark.\");\n+\n+                    if (--len == 0)\n+                        break;\n+                    c = val.charAt(++offset);\n+                }\n+                if (prec == 0) \/\/ no digits found\n+                    throw new NumberFormatException(\"No digits found.\");\n+                if (isneg)\n+                    rs = -rs;\n+                int mcp = mc.precision;\n+                int drop = prec - mcp; \/\/ prec has range [1, MAX_INT], mcp has range [0, MAX_INT];\n+                \/\/ therefore, this subtraction cannot overflow\n+                if (mcp > 0 && drop > 0) {  \/\/ do rounding\n+                    while (drop > 0) {\n+                        scl -= drop;\n+                        rs = divideAndRound(rs, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);\n+                        prec = longDigitLength(rs);\n+                        drop = prec - mcp;\n+                    }\n+                }\n+            } else {\n+                int start = offset;\n+                for (int idx = 0; ; ) {\n+                    \/\/ have digit\n+                    if ((c >= '0' && c <= '9') || Character.isDigit(c)) {\n+                        \/\/ First compact case, we need not to preserve the character\n+                        \/\/ and we can just compute the value in place.\n+                        if (c == '0' || Character.digit(c, 10) == 0) {\n+                            if (prec == 0) {\n+                                start = offset;\n+                                prec = 1;\n+                            } else if (idx != 0) {\n+                                ++idx;\n+                                ++prec;\n+                            } else\n+                                start = offset + 1;\n+                        } else {\n+                            if (prec != 1 || idx != 0)\n+                                ++prec; \/\/ prec unchanged if preceded by 0s\n+                            ++idx;\n+                        }\n+                        if (dot)\n+                            ++scl;\n+                    } else if (c == '.') {\n+                        \/\/ have dot\n+                        if (dot) \/\/ two dots\n+                            throw new NumberFormatException(\"Character array\"\n+                                + \" contains more than one decimal point.\");\n+                        dot = true;\n+                        if (idx == 0 && prec == 1)\n+                            start = offset;\n+                    } else {\n+                        \/\/ exponent expected\n+                        if ((c != 'e') && (c != 'E'))\n+                            throw new NumberFormatException(\"Character array\"\n+                                + \" is missing \\\"e\\\" notation exponential mark.\");\n+                        scl -= parseExp(val, offset, len);\n+                        break; \/\/ [saves a test]\n+                    }\n+\n+                    if (--len == 0)\n+                        break;\n+                    c = val.charAt(++offset);\n+                }\n+                \/\/ here when no characters left\n+                if (prec == 0) \/\/ no digits found\n+                    throw new NumberFormatException(\"No digits found.\");\n+\n+                \/\/ Remove leading zeros from precision (digits count)\n+                rb = new BigInteger(val, isneg ? -1 : 1, start, prec);\n+                rs = compactValFor(rb);\n+                int mcp = mc.precision;\n+                if (mcp > 0 && (prec > mcp)) {\n+                    if (rs == INFLATED) {\n+                        int drop = prec - mcp;\n+                        while (drop > 0) {\n+                            scl -= drop;\n+                            rb = divideAndRoundByTenPow(rb, drop, mc.roundingMode.oldMode);\n+                            rs = compactValFor(rb);\n+                            if (rs != INFLATED) {\n+                                prec = longDigitLength(rs);\n+                                break;\n+                            }\n+                            prec = bigDigitLength(rb);\n+                            drop = prec - mcp;\n+                        }\n+                    }\n+                    if (rs != INFLATED) {\n+                        int drop = prec - mcp;\n+                        while (drop > 0) {\n+                            scl -= drop;\n+                            rs = divideAndRound(rs, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);\n+                            prec = longDigitLength(rs);\n+                            drop = prec - mcp;\n+                        }\n+                        rb = null;\n+                    }\n+                }\n+            }\n+        } catch (StringIndexOutOfBoundsException e) {\n+            NumberFormatException nfe = new NumberFormatException();\n+            nfe.initCause(e);\n+            throw nfe;\n+        }\n+        if ((int) scl != scl) \/\/ overflow\n+            throw new NumberFormatException(\"Exponent overflow.\");\n+        this.scale = (int) scl;\n+        this.precision = prec;\n+        this.intCompact = rs;\n+        this.intVal = rb;\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":260,"deletions":34,"binary":false,"changes":294,"status":"modified"},{"patch":"@@ -606,4 +606,2 @@\n-     * Constructs a new BigInteger using a char array with radix=10.\n-     * Sign is precalculated outside and not allowed in the val. The {@code val}\n-     * array is assumed to be unchanged for the duration of the constructor\n-     * call.\n+     * Constructs a new BigInteger using a String with radix=10.\n+     * dot is allowed in the val.\n@@ -611,14 +609,1 @@\n-    BigInteger(char[] val, int sign, int len) {\n-        int cursor = 0, numDigits;\n-\n-        \/\/ Skip leading zeros and compute number of digits in magnitude\n-        while (cursor < len && Character.digit(val[cursor], 10) == 0) {\n-            cursor++;\n-        }\n-        if (cursor == len) {\n-            signum = 0;\n-            mag = ZERO.mag;\n-            return;\n-        }\n-\n-        numDigits = len - cursor;\n+    BigInteger(String val, int sign, int off, int numDigits) {\n@@ -628,1 +613,1 @@\n-        if (len < 10) {\n+        if (numDigits < 10)\n@@ -630,1 +615,1 @@\n-        } else {\n+        else {\n@@ -632,1 +617,1 @@\n-            if (numBits + 31 >= (1L << 32)) {\n+            if (numBits + 31 >= (1L << 32))\n@@ -634,1 +619,0 @@\n-            }\n@@ -640,1 +624,2 @@\n-        int firstGroupLen = numDigits % digitsPerInt[10];\n+        int digitsPerInt10 = digitsPerInt[10];\n+        int firstGroupLen = numDigits % digitsPerInt10;\n@@ -642,7 +627,20 @@\n-            firstGroupLen = digitsPerInt[10];\n-        magnitude[numWords - 1] = parseInt(val, cursor,  cursor += firstGroupLen);\n-\n-        \/\/ Process remaining digit groups\n-        while (cursor < len) {\n-            int groupVal = parseInt(val, cursor, cursor += digitsPerInt[10]);\n-            destructiveMulAdd(magnitude, intRadix[10], groupVal);\n+            firstGroupLen = digitsPerInt10;\n+\n+        for (int numIndex = 0, groupIndex = 0; numIndex < numDigits; ++groupIndex) {\n+            int end = numIndex + (groupIndex == 0 ? firstGroupLen : digitsPerInt10);\n+            int groupVal = 0;\n+            do {\n+                char c = val.charAt(off++);\n+                if (c == '.')\n+                    continue;\n+                int nextVal = Character.digit(c, 10);\n+                if (nextVal == -1)\n+                    throw new NumberFormatException(val);\n+                numIndex++;\n+                groupVal = 10 * groupVal + nextVal;\n+            } while (numIndex < end);\n+\n+            if (groupIndex == 0)\n+                magnitude[numWords - 1] = groupVal;\n+            else\n+                destructiveMulAdd(magnitude, intRadix[10], groupVal);\n@@ -650,0 +648,1 @@\n+\n@@ -656,13 +655,42 @@\n-    \/\/ Create an integer with the digits between the two indexes\n-    \/\/ Assumes start < end. The result may be negative, but it\n-    \/\/ is to be treated as an unsigned value.\n-    private int parseInt(char[] source, int start, int end) {\n-        int result = Character.digit(source[start++], 10);\n-        if (result == -1)\n-            throw new NumberFormatException(new String(source));\n-\n-        for (int index = start; index < end; index++) {\n-            int nextVal = Character.digit(source[index], 10);\n-            if (nextVal == -1)\n-                throw new NumberFormatException(new String(source));\n-            result = 10*result + nextVal;\n+    \/*\n+     * Constructs a new BigInteger using a String with radix=10.\n+     * dot is allowed in the val.\n+     *\/\n+    BigInteger(char[] val, int sign, int off, int numDigits) {\n+        signum = sign;\n+        \/\/ Pre-allocate array of expected size\n+        int numWords;\n+        if (numDigits < 10)\n+            numWords = 1;\n+        else {\n+            long numBits = ((numDigits * bitsPerDigit[10]) >>> 10) + 1;\n+            if (numBits + 31 >= (1L << 32))\n+                reportOverflow();\n+            numWords = (int) (numBits + 31) >>> 5;\n+        }\n+        int[] magnitude = new int[numWords];\n+\n+        \/\/ Process first (potentially short) digit group\n+        int digitsPerInt10 = digitsPerInt[10];\n+        int firstGroupLen = numDigits % digitsPerInt10;\n+        if (firstGroupLen == 0)\n+            firstGroupLen = digitsPerInt10;\n+\n+        for (int numIndex = 0, groupIndex = 0; numIndex < numDigits; ++groupIndex) {\n+            int end = numIndex + (groupIndex == 0 ? firstGroupLen : digitsPerInt10);\n+            int groupVal = 0;\n+            do {\n+                char c = val[off++];\n+                if (c == '.')\n+                    continue;\n+                int nextVal = Character.digit(c, 10);\n+                if (nextVal == -1)\n+                    throw new NumberFormatException(new String(val));\n+                numIndex++;\n+                groupVal = 10 * groupVal + nextVal;\n+            } while (numIndex < end);\n+\n+            if (groupIndex == 0)\n+                magnitude[numWords - 1] = groupVal;\n+            else\n+                destructiveMulAdd(magnitude, intRadix[10], groupVal);\n@@ -671,1 +699,4 @@\n-        return result;\n+        mag = trustedStripLeadingZeroInts(magnitude);\n+        if (mag.length >= MAX_MAG_LENGTH) {\n+            checkRange();\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":75,"deletions":44,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -105,0 +105,23 @@\n+\n+        String[] strings = new String[] {\n+                \"12\",\n+                \"00000012345\",\n+                \".2e000000000000001\",\n+                \"1.2e000000000000001\",\n+                \"-0.000000000006325524822672631550863255248226726315508\",\n+                \"-6325524822672631550863255248226726315508.6325524822672631550863255248226726315508\",\n+                \"1234e+123\",\n+                \"1234567890123456789012345678901234567890\"\n+        };\n+        for (String s : strings) {\n+            BigDecimal bd = new BigDecimal(s);\n+            BigDecimal bd1 = new BigDecimal(s.toCharArray());\n+            if (!bd.equals(bd1)) {\n+                System.err.println(\"bd string: \" + s);\n+            }\n+            String bdString = bd.toString();\n+            BigDecimal bdDoppel = new BigDecimal(bdString);\n+            if (!bd.equals(bdDoppel)) {\n+                System.err.println(\"bd string: \" + bdString);\n+            }\n+        }\n@@ -139,0 +162,8 @@\n+\n+            BigDecimal tmp1 = new BigDecimal(s.toCharArray());\n+            \/\/ System.err.println(\"Testing \" + s);\n+            if (! expected.equals(tmp1) || tmp.precision() != 1) {\n+                System.err.println(\"Bad conversion of \" + s + \"got \" +\n+                        tmp1 + \"precision = \" + tmp1.precision());\n+                throw new RuntimeException(\"String constructor failure.\");\n+            }\n@@ -172,0 +203,2 @@\n+        if (!expected.equals(new BigDecimal(s.toCharArray())))\n+            throw new RuntimeException(s + \" is not equal to \" + expected);\n","filename":"test\/jdk\/java\/math\/BigDecimal\/StringConstructor.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+    private char[][] charArrayInputs;\n@@ -71,0 +72,1 @@\n+        charArrayInputs = new char[TEST_SIZE][];\n@@ -90,0 +92,1 @@\n+            charArrayInputs[i] = stringInputs[i].toCharArray();\n@@ -127,0 +130,9 @@\n+    \/** Invokes the (char[])-constructor of BigDecimal with various different values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testConstructorWithCharArray(Blackhole bh) {\n+        for (char[] s : charArrayInputs) {\n+            bh.consume(new BigDecimal(s));\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigDecimals.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"}]}