{"files":[{"patch":"@@ -543,6 +543,19 @@\n-        \/\/ protect against huge length, negative values, and integer overflow\n-        try {\n-            Objects.checkFromIndexSize(offset, len, in.length);\n-        } catch (IndexOutOfBoundsException e) {\n-            throw new NumberFormatException\n-                (\"Bad offset or len arguments for char[] input.\");\n+        this(new CharArraySequence(in, offset, len), mc);\n+    }\n+\n+    private record CharArraySequence(char[] array, int offset, int length) implements CharSequence {\n+        CharArraySequence {\n+            if ((offset | length) < 0 || length > array.length - offset)\n+                throw new NumberFormatException();\n+        }\n+\n+        @Override\n+        public int length() {\n+            return length;\n+        }\n+\n+        @Override\n+        public char charAt(int index) {\n+            if (index >= length)\n+                throw new IndexOutOfBoundsException();\n+            return array[index + offset];\n@@ -551,4 +564,5 @@\n-        \/\/ This is the primary string to BigDecimal constructor; all\n-        \/\/ incoming strings end up here; it uses explicit (inline)\n-        \/\/ parsing for speed and generates at most one intermediate\n-        \/\/ (temporary) object (a char[] array) for non-compact case.\n+        @Override\n+        public CharSequence subSequence(int offset, int length) {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n@@ -556,0 +570,1 @@\n+    private BigDecimal(CharSequence val, MathContext mc) {\n@@ -561,1 +576,1 @@\n-        \/\/ use array bounds checking to handle too-long, len == 0,\n+        \/\/ use CharSequence bounds checking to handle too-long, len == 0,\n@@ -564,0 +579,3 @@\n+            int len = val.length();\n+            int offset = 0;\n+            char c = val.charAt(offset);\n@@ -565,7 +583,3 @@\n-            boolean isneg = false;          \/\/ assume positive\n-            if (in[offset] == '-') {\n-                isneg = true;               \/\/ leading minus means negative\n-                offset++;\n-                len--;\n-            } else if (in[offset] == '+') { \/\/ leading + allowed\n-                offset++;\n+            boolean isneg = c == '-'; \/\/ leading minus means negative\n+            if (isneg || c == '+') {\n+                c = val.charAt(++offset);\n@@ -577,1 +591,1 @@\n-            char c;                          \/\/ current character\n+            int digit;\n@@ -581,1 +595,0 @@\n-            int idx = 0;\n@@ -585,3 +598,2 @@\n-                for (; len > 0; offset++, len--) {\n-                    c = in[offset];\n-                    if ((c == '0')) { \/\/ have zero\n+                for (; ; c = val.charAt(++offset)) {\n+                    if (c == '0') { \/\/ have zero\n@@ -596,2 +608,1 @@\n-                    } else if ((c >= '1' && c <= '9')) { \/\/ have digit\n-                        int digit = c - '0';\n+                    } else if (c >= '1' && c <= '9') { \/\/ have digit\n@@ -600,1 +611,1 @@\n-                        rs = rs * 10 + digit;\n+                        rs = rs * 10 + c - '0';\n@@ -609,2 +620,4 @@\n-                    } else if (Character.isDigit(c)) { \/\/ slow path\n-                        int digit = Character.digit(c, 10);\n+                    } else if (c == 'e' || c == 'E') {\n+                        scl -= parseExp(val, offset, len);\n+                        break; \/\/ [saves a test]\n+                    } else if ((digit = Character.digit(c, 10)) != -1) { \/\/ slow path\n@@ -625,4 +638,1 @@\n-                    } else if ((c == 'e') || (c == 'E')) {\n-                        scl -= parseExp(in, offset, len);\n-                        break; \/\/ [saves a test]\n-                    } else {\n+                    } else\n@@ -632,1 +642,3 @@\n-                    }\n+\n+                    if (--len == 0)\n+                        break;\n@@ -636,1 +648,2 @@\n-                rs = isneg ? -rs : rs;\n+                if (isneg)\n+                    rs = -rs;\n@@ -649,3 +662,2 @@\n-                char[] coeff = new char[len];\n-                for (; len > 0; offset++, len--) {\n-                    c = in[offset];\n+                int start = offset;\n+                for (int idx = 0; ; c = val.charAt(++offset)) {\n@@ -653,1 +665,31 @@\n-                    if ((c >= '0' && c <= '9') || Character.isDigit(c)) {\n+                    if (c == '0') {\n+                        if (prec == 0) {\n+                            start = offset;\n+                            prec = 1;\n+                        } else if (idx != 0) {\n+                            ++idx;\n+                            ++prec;\n+                        } else\n+                            start = offset + 1;\n+                        if (dot)\n+                            ++scl;\n+                    } else if (c >= '1' && c <= '9') {\n+                        \/\/ First compact case, we need not to preserve the character\n+                        \/\/ and we can just compute the value in place.\n+                        if (prec != 1 || idx != 0)\n+                            ++prec; \/\/ prec unchanged if preceded by 0s\n+                        ++idx;\n+                        if (dot)\n+                            ++scl;\n+                    } else if (c == '.') {\n+                        \/\/ have dot\n+                        if (dot) \/\/ two dots\n+                            throw new NumberFormatException(\"Character array\"\n+                                + \" contains more than one decimal point.\");\n+                        dot = true;\n+                        if (idx == 0 && prec == 1)\n+                            start = offset;\n+                    } else if (c == 'e' || c == 'E') {\n+                        scl -= parseExp(val, offset, len);\n+                        break; \/\/ [saves a test]\n+                    } else if ((digit = Character.digit(c, 10)) != -1) {\n@@ -656,1 +698,1 @@\n-                        if (c == '0' || Character.digit(c, 10) == 0) {\n+                        if (digit == 0) {\n@@ -658,1 +700,1 @@\n-                                coeff[idx] = c;\n+                                start = offset;\n@@ -661,1 +703,1 @@\n-                                coeff[idx++] = c;\n+                                ++idx;\n@@ -663,1 +705,2 @@\n-                            } \/\/ else c must be a redundant leading zero\n+                            } else\n+                                start = offset + 1;\n@@ -667,1 +710,1 @@\n-                            coeff[idx++] = c;\n+                            ++idx;\n@@ -671,13 +714,1 @@\n-                        continue;\n-                    }\n-                    \/\/ have dot\n-                    if (c == '.') {\n-                        \/\/ have dot\n-                        if (dot) \/\/ two dots\n-                            throw new NumberFormatException(\"Character array\"\n-                                + \" contains more than one decimal point.\");\n-                        dot = true;\n-                        continue;\n-                    }\n-                    \/\/ exponent expected\n-                    if ((c != 'e') && (c != 'E'))\n+                    } else\n@@ -686,2 +717,3 @@\n-                    scl -= parseExp(in, offset, len);\n-                    break; \/\/ [saves a test]\n+\n+                    if (--len == 0)\n+                        break;\n@@ -693,1 +725,1 @@\n-                rb = new BigInteger(coeff, isneg ? -1 : 1, prec);\n+                rb = new BigInteger(val, isneg ? -1 : 1, start, prec);\n@@ -723,1 +755,1 @@\n-        } catch (ArrayIndexOutOfBoundsException | NegativeArraySizeException e) {\n+        } catch (IndexOutOfBoundsException e) {\n@@ -739,1 +771,1 @@\n-    private static long parseExp(char[] in, int offset, int len){\n+    private static long parseExp(CharSequence in, int offset, int len){\n@@ -742,1 +774,1 @@\n-        char c = in[offset];\n+        char c = in.charAt(offset);\n@@ -748,1 +780,1 @@\n-            c = in[offset];\n+            c = in.charAt(offset);\n@@ -756,1 +788,1 @@\n-            c = in[offset];\n+            c = in.charAt(offset);\n@@ -775,1 +807,1 @@\n-            c = in[offset];\n+            c = in.charAt(offset);\n@@ -924,1 +956,1 @@\n-        this(val.toCharArray(), 0, val.length());\n+        this((CharSequence) val, MathContext.UNLIMITED);\n@@ -940,1 +972,1 @@\n-        this(val.toCharArray(), 0, val.length(), mc);\n+        this((CharSequence) val, mc);\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":99,"deletions":67,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -606,1 +606,1 @@\n-     * Constructs a new BigInteger using a char array with radix=10.\n+     * Constructs a new BigInteger using a String with radix=10.\n@@ -609,1 +609,1 @@\n-     * call.\n+     * dot is allowed in the val.\n@@ -611,14 +611,1 @@\n-    BigInteger(char[] val, int sign, int len) {\n-        int cursor = 0, numDigits;\n-\n-        \/\/ Skip leading zeros and compute number of digits in magnitude\n-        while (cursor < len && Character.digit(val[cursor], 10) == 0) {\n-            cursor++;\n-        }\n-        if (cursor == len) {\n-            signum = 0;\n-            mag = ZERO.mag;\n-            return;\n-        }\n-\n-        numDigits = len - cursor;\n+    BigInteger(CharSequence val, int sign, int off, int numDigits) {\n@@ -628,1 +615,1 @@\n-        if (len < 10) {\n+        if (numDigits < 10) {\n@@ -640,1 +627,2 @@\n-        int firstGroupLen = numDigits % digitsPerInt[10];\n+        int digitsPerInt10 = digitsPerInt[10];\n+        int firstGroupLen = numDigits % digitsPerInt10;\n@@ -642,7 +630,20 @@\n-            firstGroupLen = digitsPerInt[10];\n-        magnitude[numWords - 1] = parseInt(val, cursor,  cursor += firstGroupLen);\n-\n-        \/\/ Process remaining digit groups\n-        while (cursor < len) {\n-            int groupVal = parseInt(val, cursor, cursor += digitsPerInt[10]);\n-            destructiveMulAdd(magnitude, intRadix[10], groupVal);\n+            firstGroupLen = digitsPerInt10;\n+\n+        for (int numIndex = 0, groupIndex = 0; numIndex < numDigits; ++groupIndex) {\n+            int end = numIndex + (groupIndex == 0 ? firstGroupLen : digitsPerInt10);\n+            int groupVal = 0;\n+            do {\n+                char c = val.charAt(off++);\n+                if (c == '.')\n+                    continue;\n+                int nextVal = Character.digit(c, 10);\n+                if (nextVal == -1)\n+                    throw new NumberFormatException(val.toString());\n+                numIndex++;\n+                groupVal = 10 * groupVal + nextVal;\n+            } while (numIndex < end);\n+\n+            if (groupIndex == 0)\n+                magnitude[numWords - 1] = groupVal;\n+            else\n+                destructiveMulAdd(magnitude, intRadix[10], groupVal);\n@@ -650,0 +651,1 @@\n+\n@@ -656,18 +658,0 @@\n-    \/\/ Create an integer with the digits between the two indexes\n-    \/\/ Assumes start < end. The result may be negative, but it\n-    \/\/ is to be treated as an unsigned value.\n-    private int parseInt(char[] source, int start, int end) {\n-        int result = Character.digit(source[start++], 10);\n-        if (result == -1)\n-            throw new NumberFormatException(new String(source));\n-\n-        for (int index = start; index < end; index++) {\n-            int nextVal = Character.digit(source[index], 10);\n-            if (nextVal == -1)\n-                throw new NumberFormatException(new String(source));\n-            result = 10*result + nextVal;\n-        }\n-\n-        return result;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":27,"deletions":43,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import static org.testng.Assert.assertThrows;\n+\n@@ -70,0 +72,23 @@\n+\n+    @Test\n+    public void errorInput() {\n+        String[] strings = {\"+\", \"-\", \"\", \"e\", \".\"};\n+        for (String string : strings) {\n+            assertThrows(\n+                    NumberFormatException.class,\n+                    () -> new BigDecimal(string));\n+            assertThrows(\n+                    NumberFormatException.class,\n+                    () -> new BigDecimal(string.toCharArray()));\n+\n+            if (!string.isEmpty()) {\n+                assertThrows(\n+                        NumberFormatException.class,\n+                        () -> new BigDecimal(\n+                                (string + \"123\").toCharArray(), 0, 1));\n+                assertThrows(\n+                        NumberFormatException.class,\n+                        () -> new BigDecimal((\"12e\" + string + \"123\").toCharArray(), 3, 1));\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/java\/math\/BigDecimal\/Constructor.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -105,0 +105,23 @@\n+\n+        String[] strings = new String[] {\n+                \"12\",\n+                \"00000012345\",\n+                \".2e000000000000001\",\n+                \"1.2e000000000000001\",\n+                \"-0.000000000006325524822672631550863255248226726315508\",\n+                \"-6325524822672631550863255248226726315508.6325524822672631550863255248226726315508\",\n+                \"1234e+123\",\n+                \"1234567890123456789012345678901234567890\"\n+        };\n+        for (String s : strings) {\n+            BigDecimal bd = new BigDecimal(s);\n+            BigDecimal bd1 = new BigDecimal(s.toCharArray());\n+            if (!bd.equals(bd1)) {\n+                System.err.println(\"bd string: \" + s);\n+            }\n+            String bdString = bd.toString();\n+            BigDecimal bdDoppel = new BigDecimal(bdString);\n+            if (!bd.equals(bdDoppel)) {\n+                System.err.println(\"bd string: \" + bdString);\n+            }\n+        }\n@@ -139,0 +162,8 @@\n+\n+            BigDecimal tmp1 = new BigDecimal(s.toCharArray());\n+            \/\/ System.err.println(\"Testing \" + s);\n+            if (! expected.equals(tmp1) || tmp.precision() != 1) {\n+                System.err.println(\"Bad conversion of \" + s + \"got \" +\n+                        tmp1 + \"precision = \" + tmp1.precision());\n+                throw new RuntimeException(\"String constructor failure.\");\n+            }\n@@ -172,0 +203,2 @@\n+        if (!expected.equals(new BigDecimal(s.toCharArray())))\n+            throw new RuntimeException(s + \" is not equal to \" + expected);\n","filename":"test\/jdk\/java\/math\/BigDecimal\/StringConstructor.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -61,1 +61,2 @@\n-    private String[] stringInputs;\n+    private String[] stringInputs, stringHugeInputs, stringLargeInputs, stringSmallInputs;\n+    private char[][] charArrayInputs, charArrayHugeInputs, charArrayLargeInputs, charArraySmallInputs;\n@@ -70,0 +71,1 @@\n+\n@@ -71,0 +73,9 @@\n+        stringHugeInputs = new String[TEST_SIZE];\n+        stringLargeInputs = new String[TEST_SIZE];\n+        stringSmallInputs = new String[TEST_SIZE];\n+\n+        charArrayInputs = new char[TEST_SIZE][];\n+        charArrayHugeInputs = new char[TEST_SIZE][];\n+        charArrayLargeInputs = new char[TEST_SIZE][];\n+        charArraySmallInputs = new char[TEST_SIZE][];\n+\n@@ -89,0 +100,1 @@\n+\n@@ -91,0 +103,12 @@\n+            charArrayInputs[i] = stringInputs[i].toCharArray();\n+\n+            int intVal = Math.abs(r.nextInt());\n+            stringHugeInputs[i]\n+                    = \"\" + ((long) intVal + (long) Integer.MAX_VALUE)\n+                    + ((long) intVal + (long) Integer.MAX_VALUE) + \".55\";\n+            stringLargeInputs[i] = \"\" + ((long) intVal + (long) Integer.MAX_VALUE) + \".55\";\n+            stringSmallInputs[i] = \"\" + ((long) intVal \/ 1000) + \".55\";\n+\n+            charArrayHugeInputs[i] = stringHugeInputs[i].toCharArray();\n+            charArrayLargeInputs[i] = stringLargeInputs[i].toCharArray();\n+            charArraySmallInputs[i] = stringSmallInputs[i].toCharArray();\n@@ -127,0 +151,64 @@\n+    \/** Invokes the (String)-constructor of BigDecimal with huge values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testConstructorWithHugeString(Blackhole bh) {\n+        for (String s : stringHugeInputs) {\n+            bh.consume(new BigDecimal(s));\n+        }\n+    }\n+\n+    \/** Invokes the (String)-constructor of BigDecimal with large values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testConstructorWithLargeString(Blackhole bh) {\n+        for (String s : stringLargeInputs) {\n+            bh.consume(new BigDecimal(s));\n+        }\n+    }\n+\n+    \/** Invokes the (String)-constructor of BigDecimal with small values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testConstructorWithSmallString(Blackhole bh) {\n+        for (String s : stringSmallInputs) {\n+            bh.consume(new BigDecimal(s));\n+        }\n+    }\n+\n+    \/** Invokes the (char[])-constructor of BigDecimal with various different values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testConstructorWithCharArray(Blackhole bh) {\n+        for (char[] s : charArrayInputs) {\n+            bh.consume(new BigDecimal(s));\n+        }\n+    }\n+\n+    \/** Invokes the (char[])-constructor of BigDecimal with huge values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testConstructorWithHugeCharArray(Blackhole bh) {\n+        for (char[] s : charArrayHugeInputs) {\n+            bh.consume(new BigDecimal(s));\n+        }\n+    }\n+\n+    \/** Invokes the (char[])-constructor of BigDecimal with large values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testConstructorWithLargeCharArray(Blackhole bh) {\n+        for (char[] s : charArrayLargeInputs) {\n+            bh.consume(new BigDecimal(s));\n+        }\n+    }\n+\n+    \/** Invokes the (char[])-constructor of BigDecimal with small values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testConstructorWithSmallCharArray(Blackhole bh) {\n+        for (char[] s : charArraySmallInputs) {\n+            bh.consume(new BigDecimal(s));\n+        }\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigDecimals.java","additions":89,"deletions":1,"binary":false,"changes":90,"status":"modified"}]}