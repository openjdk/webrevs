{"files":[{"patch":"@@ -555,0 +555,198 @@\n+    private BigDecimal(CharSequence val, MathContext mc) {\n+        \/\/ Use locals for all fields values until completion\n+        int prec = 0;                 \/\/ record precision value\n+        long scl = 0;                 \/\/ record scale value\n+        long rs = 0;                  \/\/ the compact value in long\n+        BigInteger rb = null;         \/\/ the inflated value in BigInteger\n+        \/\/ use String bounds checking to handle too-long, len == 0,\n+        try {\n+            int len = val.length();\n+            int offset = 0;\n+            char c = val.charAt(offset);\n+            boolean isneg = c == '-'; \/\/ leading minus means negative\n+            if (isneg || c == '+') {\n+                c = val.charAt(++offset);\n+                len--;\n+            }\n+\n+            \/\/ should now be at numeric part of the significand\n+            boolean dot = false;             \/\/ true when there is a '.'\n+            int digit;\n+            boolean isCompact = (len <= MAX_COMPACT_DIGITS);\n+            \/\/ integer significand array & idx is the index to it. The array\n+            \/\/ is ONLY used when we can't use a compact representation.\n+            if (isCompact) {\n+                \/\/ First compact case, we need not to preserve the character\n+                \/\/ and we can just compute the value in place.\n+                for (; ; ) {\n+                    if (c == '0') { \/\/ have zero\n+                        if (prec == 0)\n+                            prec = 1;\n+                        else if (rs != 0) {\n+                            rs *= 10;\n+                            ++prec;\n+                        } \/\/ else digit is a redundant leading zero\n+                        if (dot)\n+                            ++scl;\n+                    } else if (c >= '1' && c <= '9') { \/\/ have digit\n+                        if (prec != 1 || rs != 0)\n+                            ++prec; \/\/ prec unchanged if preceded by 0s\n+                        rs = rs * 10 + c - '0';\n+                        if (dot)\n+                            ++scl;\n+                    } else if (c == '.') {   \/\/ have dot\n+                        \/\/ have dot\n+                        if (dot) \/\/ two dots\n+                            throw new NumberFormatException(\"Character array\"\n+                                + \" contains more than one decimal point.\");\n+                        dot = true;\n+                    } else if (c == 'e' || c == 'E') {\n+                        scl -= parseExp(val, offset, len);\n+                        break; \/\/ [saves a test]\n+                    } else if ((digit = Character.digit(c, 10)) != -1) { \/\/ slow path\n+                        if (digit == 0) {\n+                            if (prec == 0)\n+                                prec = 1;\n+                            else if (rs != 0) {\n+                                rs *= 10;\n+                                ++prec;\n+                            } \/\/ else digit is a redundant leading zero\n+                        } else {\n+                            if (prec != 1 || rs != 0)\n+                                ++prec; \/\/ prec unchanged if preceded by 0s\n+                            rs = rs * 10 + digit;\n+                        }\n+                        if (dot)\n+                            ++scl;\n+                    } else\n+                        throw new NumberFormatException(\"Character \" + c\n+                            + \" is neither a decimal digit number, decimal point, nor\"\n+                            + \" \\\"e\\\" notation exponential mark.\");\n+\n+                    if (--len == 0)\n+                        break;\n+                    c = val.charAt(++offset);\n+                }\n+                if (prec == 0) \/\/ no digits found\n+                    throw new NumberFormatException(\"No digits found.\");\n+                if (isneg)\n+                    rs = -rs;\n+                int mcp = mc.precision;\n+                int drop = prec - mcp; \/\/ prec has range [1, MAX_INT], mcp has range [0, MAX_INT];\n+                                       \/\/ therefore, this subtraction cannot overflow\n+                if (mcp > 0 && drop > 0) {  \/\/ do rounding\n+                    while (drop > 0) {\n+                        scl -= drop;\n+                        rs = divideAndRound(rs, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);\n+                        prec = longDigitLength(rs);\n+                        drop = prec - mcp;\n+                    }\n+                }\n+            } else {\n+                int start = offset;\n+                for (int idx = 0; ; ) {\n+                    \/\/ have digit\n+                    if (c == '0') {\n+                        if (prec == 0) {\n+                            start = offset;\n+                            prec = 1;\n+                        } else if (idx != 0) {\n+                            ++idx;\n+                            ++prec;\n+                        } else\n+                            start = offset + 1;\n+                        if (dot)\n+                            ++scl;\n+                    } else if (c >= '1' && c <= '9') {\n+                        \/\/ First compact case, we need not to preserve the character\n+                        \/\/ and we can just compute the value in place.\n+                        if (prec != 1 || idx != 0)\n+                            ++prec; \/\/ prec unchanged if preceded by 0s\n+                        ++idx;\n+                        if (dot)\n+                            ++scl;\n+                    } else if (c == '.') {\n+                        \/\/ have dot\n+                        if (dot) \/\/ two dots\n+                            throw new NumberFormatException(\"Character array\"\n+                                + \" contains more than one decimal point.\");\n+                        dot = true;\n+                        if (idx == 0 && prec == 1)\n+                            start = offset;\n+                    } else if (c == 'e' || c == 'E') {\n+                        scl -= parseExp(val, offset, len);\n+                        break; \/\/ [saves a test]\n+                    } else if ((digit = Character.digit(c, 10)) != -1) {\n+                        \/\/ First compact case, we need not to preserve the character\n+                        \/\/ and we can just compute the value in place.\n+                        if (digit == 0) {\n+                            if (prec == 0) {\n+                                start = offset;\n+                                prec = 1;\n+                            } else if (idx != 0) {\n+                                ++idx;\n+                                ++prec;\n+                            } else\n+                                start = offset + 1;\n+                        } else {\n+                            if (prec != 1 || idx != 0)\n+                                ++prec; \/\/ prec unchanged if preceded by 0s\n+                            ++idx;\n+                        }\n+                        if (dot)\n+                            ++scl;\n+                    } else\n+                        throw new NumberFormatException(\"Character array\"\n+                            + \" is missing \\\"e\\\" notation exponential mark.\");\n+\n+                    if (--len == 0)\n+                        break;\n+                    c = val.charAt(++offset);\n+                }\n+                \/\/ here when no characters left\n+                if (prec == 0) \/\/ no digits found\n+                    throw new NumberFormatException(\"No digits found.\");\n+                \/\/ Remove leading zeros from precision (digits count)\n+                rb = new BigInteger(val, isneg ? -1 : 1, start, prec);\n+                rs = compactValFor(rb);\n+                int mcp = mc.precision;\n+                if (mcp > 0 && (prec > mcp)) {\n+                    if (rs == INFLATED) {\n+                        int drop = prec - mcp;\n+                        while (drop > 0) {\n+                            scl -= drop;\n+                            rb = divideAndRoundByTenPow(rb, drop, mc.roundingMode.oldMode);\n+                            rs = compactValFor(rb);\n+                            if (rs != INFLATED) {\n+                                prec = longDigitLength(rs);\n+                                break;\n+                            }\n+                            prec = bigDigitLength(rb);\n+                            drop = prec - mcp;\n+                        }\n+                    }\n+                    if (rs != INFLATED) {\n+                        int drop = prec - mcp;\n+                        while (drop > 0) {\n+                            scl -= drop;\n+                            rs = divideAndRound(rs, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);\n+                            prec = longDigitLength(rs);\n+                            drop = prec - mcp;\n+                        }\n+                        rb = null;\n+                    }\n+                }\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            NumberFormatException nfe = new NumberFormatException();\n+            nfe.initCause(e);\n+            throw nfe;\n+        }\n+        if ((int) scl != scl) \/\/ overflow\n+            throw new NumberFormatException(\"Exponent overflow.\");\n+        this.scale = (int) scl;\n+        this.precision = prec;\n+        this.intCompact = rs;\n+        this.intVal = rb;\n+    }\n+\n@@ -762,199 +960,0 @@\n-    private BigDecimal(CharSequence val, MathContext mc) {\n-        \/\/ Use locals for all fields values until completion\n-        int prec = 0;                 \/\/ record precision value\n-        long scl = 0;                 \/\/ record scale value\n-        long rs = 0;                  \/\/ the compact value in long\n-        BigInteger rb = null;         \/\/ the inflated value in BigInteger\n-        \/\/ use String bounds checking to handle too-long, len == 0,\n-        try {\n-            int len = val.length();\n-            int offset = 0;\n-            char c = val.charAt(offset);\n-            boolean isneg = c == '-'; \/\/ leading minus means negative\n-            if (isneg || c == '+') {\n-                c = val.charAt(++offset);\n-                len--;\n-            }\n-\n-            \/\/ should now be at numeric part of the significand\n-            boolean dot = false;             \/\/ true when there is a '.'\n-            boolean isCompact = (len <= MAX_COMPACT_DIGITS);\n-            \/\/ integer significand array & idx is the index to it. The array\n-            \/\/ is ONLY used when we can't use a compact representation.\n-            int digit;\n-            if (isCompact) {\n-                \/\/ First compact case, we need not to preserve the character\n-                \/\/ and we can just compute the value in place.\n-                for (; ; ) {\n-                    if (c == '0') { \/\/ have zero\n-                        if (prec == 0)\n-                            prec = 1;\n-                        else if (rs != 0) {\n-                            rs *= 10;\n-                            ++prec;\n-                        } \/\/ else digit is a redundant leading zero\n-                        if (dot)\n-                            ++scl;\n-                    } else if (c >= '1' && c <= '9') { \/\/ have digit\n-                        if (prec != 1 || rs != 0)\n-                            ++prec; \/\/ prec unchanged if preceded by 0s\n-                        rs = rs * 10 + c - '0';\n-                        if (dot)\n-                            ++scl;\n-                    } else if (c == '.') {   \/\/ have dot\n-                        \/\/ have dot\n-                        if (dot) \/\/ two dots\n-                            throw new NumberFormatException(\"Character array\"\n-                                + \" contains more than one decimal point.\");\n-                        dot = true;\n-                    } else if (c == 'e' || c == 'E') {\n-                        scl -= parseExp(val, offset, len);\n-                        break; \/\/ [saves a test]\n-                    } else if ((digit = Character.digit(c, 10)) != -1) { \/\/ slow path\n-                        if (digit == 0) {\n-                            if (prec == 0)\n-                                prec = 1;\n-                            else if (rs != 0) {\n-                                rs *= 10;\n-                                ++prec;\n-                            } \/\/ else digit is a redundant leading zero\n-                        } else {\n-                            if (prec != 1 || rs != 0)\n-                                ++prec; \/\/ prec unchanged if preceded by 0s\n-                            rs = rs * 10 + digit;\n-                        }\n-                        if (dot)\n-                            ++scl;\n-                    } else\n-                        throw new NumberFormatException(\"Character \" + c\n-                            + \" is neither a decimal digit number, decimal point, nor\"\n-                            + \" \\\"e\\\" notation exponential mark.\");\n-\n-                    if (--len == 0)\n-                        break;\n-                    c = val.charAt(++offset);\n-                }\n-                if (prec == 0) \/\/ no digits found\n-                    throw new NumberFormatException(\"No digits found.\");\n-                if (isneg)\n-                    rs = -rs;\n-                int mcp = mc.precision;\n-                int drop = prec - mcp; \/\/ prec has range [1, MAX_INT], mcp has range [0, MAX_INT];\n-                \/\/ therefore, this subtraction cannot overflow\n-                if (mcp > 0 && drop > 0) {  \/\/ do rounding\n-                    while (drop > 0) {\n-                        scl -= drop;\n-                        rs = divideAndRound(rs, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);\n-                        prec = longDigitLength(rs);\n-                        drop = prec - mcp;\n-                    }\n-                }\n-            } else {\n-                int start = offset;\n-                for (int idx = 0; ; ) {\n-                    \/\/ have digit\n-                    if (c == '0') {\n-                        if (prec == 0) {\n-                            start = offset;\n-                            prec = 1;\n-                        } else if (idx != 0) {\n-                            ++idx;\n-                            ++prec;\n-                        } else\n-                            start = offset + 1;\n-                        if (dot)\n-                            ++scl;\n-                    } else if (c >= '1' && c <= '9') {\n-                        \/\/ First compact case, we need not to preserve the character\n-                        \/\/ and we can just compute the value in place.\n-                        if (prec != 1 || idx != 0)\n-                            ++prec; \/\/ prec unchanged if preceded by 0s\n-                        ++idx;\n-                        if (dot)\n-                            ++scl;\n-                    } else if (c == '.') {\n-                        \/\/ have dot\n-                        if (dot) \/\/ two dots\n-                            throw new NumberFormatException(\"Character array\"\n-                                + \" contains more than one decimal point.\");\n-                        dot = true;\n-                        if (idx == 0 && prec == 1)\n-                            start = offset;\n-                    } else if (c == 'e' || c == 'E') {\n-                        scl -= parseExp(val, offset, len);\n-                        break; \/\/ [saves a test]\n-                    } else if ((digit = Character.digit(c, 10)) != -1) {\n-                        \/\/ First compact case, we need not to preserve the character\n-                        \/\/ and we can just compute the value in place.\n-                        if (digit == 0) {\n-                            if (prec == 0) {\n-                                start = offset;\n-                                prec = 1;\n-                            } else if (idx != 0) {\n-                                ++idx;\n-                                ++prec;\n-                            } else\n-                                start = offset + 1;\n-                        } else {\n-                            if (prec != 1 || idx != 0)\n-                                ++prec; \/\/ prec unchanged if preceded by 0s\n-                            ++idx;\n-                        }\n-                        if (dot)\n-                            ++scl;\n-                    } else\n-                        throw new NumberFormatException(\"Character array\"\n-                            + \" is missing \\\"e\\\" notation exponential mark.\");\n-\n-                    if (--len == 0)\n-                        break;\n-                    c = val.charAt(++offset);\n-                }\n-                \/\/ here when no characters left\n-                if (prec == 0) \/\/ no digits found\n-                    throw new NumberFormatException(\"No digits found.\");\n-\n-                \/\/ Remove leading zeros from precision (digits count)\n-                rb = new BigInteger(val, isneg ? -1 : 1, start, prec);\n-                rs = compactValFor(rb);\n-                int mcp = mc.precision;\n-                if (mcp > 0 && (prec > mcp)) {\n-                    if (rs == INFLATED) {\n-                        int drop = prec - mcp;\n-                        while (drop > 0) {\n-                            scl -= drop;\n-                            rb = divideAndRoundByTenPow(rb, drop, mc.roundingMode.oldMode);\n-                            rs = compactValFor(rb);\n-                            if (rs != INFLATED) {\n-                                prec = longDigitLength(rs);\n-                                break;\n-                            }\n-                            prec = bigDigitLength(rb);\n-                            drop = prec - mcp;\n-                        }\n-                    }\n-                    if (rs != INFLATED) {\n-                        int drop = prec - mcp;\n-                        while (drop > 0) {\n-                            scl -= drop;\n-                            rs = divideAndRound(rs, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);\n-                            prec = longDigitLength(rs);\n-                            drop = prec - mcp;\n-                        }\n-                        rb = null;\n-                    }\n-                }\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            NumberFormatException nfe = new NumberFormatException();\n-            nfe.initCause(e);\n-            throw nfe;\n-        }\n-        if ((int) scl != scl) \/\/ overflow\n-            throw new NumberFormatException(\"Exponent overflow.\");\n-        this.scale = (int) scl;\n-        this.precision = prec;\n-        this.intCompact = rs;\n-        this.intVal = rb;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":198,"deletions":199,"binary":false,"changes":397,"status":"modified"}]}