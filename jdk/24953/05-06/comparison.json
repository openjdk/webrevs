{"files":[{"patch":"@@ -248,0 +248,12 @@\n+\/\/ For z = montmul(a,b), z will be  between -q and q and congruent\n+\/\/ to a * b * R^-1 mod q, where R > 2 * q, R is a power of 2,\n+\/\/ -R\/2 * q <= a * b < R\/2 * q.\n+\/\/ (See e.g. Algorithm 3 in https:\/\/eprint.iacr.org\/2018\/039.pdf)\n+\/\/ For the Java code, we use R = 2^20 and for the intrinsic, R = 2^16.\n+\/\/ In our computations, b is always c * R mod q, so the montmul() really\n+\/\/ computes a * c mod q. In the Java code, we use 32-bit numbers for the\n+\/\/ computations, and we use R = 2^20 because that way the a * b numbers\n+\/\/ that occur during all computations stay in the required range.\n+\/\/ For the intrinsics, we use R = 2^16, because this way we can do twice\n+\/\/ as much work in parallel, the only drawback is that we should do some Barrett\n+\/\/ reductions in kyberInverseNtt so that the numbers stay in the required range.\n@@ -383,0 +395,1 @@\n+  \/\/ Each level represents one iteration of the outer for loop of the Java version.\n@@ -482,0 +495,1 @@\n+  \/\/ Each level represents one iteration of the outer for loop of the Java version.\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_kyber.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"}]}