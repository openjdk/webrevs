{"files":[{"patch":"@@ -28,3 +28,2 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -34,1 +33,1 @@\n- * using {@linkplain ByteOrder#BIG_ENDIAN big endian order} (aka. \"network order\").\n+ * using {@linkplain java.nio.ByteOrder#BIG_ENDIAN big endian order} (aka. \"network order\").\n@@ -44,6 +43,15 @@\n-    private static final VarHandle SHORT = create(short[].class);\n-    private static final VarHandle CHAR = create(char[].class);\n-    private static final VarHandle INT = create(int[].class);\n-    private static final VarHandle FLOAT = create(float[].class);\n-    private static final VarHandle LONG = create(long[].class);\n-    private static final VarHandle DOUBLE = create(double[].class);\n+    \/**\n+     * The {@code Unsafe} can be functionality replaced by\n+     * {@linkplain java.lang.invoke.MethodHandles#byteArrayViewVarHandle byteArrayViewVarHandle},\n+     * but it's not feasible in practices, because {@code ByteArray} and {@code ByteArrayLittleEndian}\n+     * can be used in fundamental classes, {@code VarHandle} exercise many other\n+     * code at VM startup, this could lead a recursive calls when fundamental\n+     * classes is used in {@code VarHandle}.\n+     *\/\n+    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    @ForceInline\n+    static long arrayOffset(byte[] array, int typeBytes, int offset) {\n+        return (long) Preconditions.checkIndex(offset, array.length - typeBytes + 1, Preconditions.AIOOBE_FORMATTER)\n+                + Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+    }\n@@ -65,0 +73,1 @@\n+    @ForceInline\n@@ -81,0 +90,1 @@\n+    @ForceInline\n@@ -82,1 +92,4 @@\n-        return (char) CHAR.get(array, offset);\n+        return UNSAFE.getCharUnaligned(\n+            array,\n+            arrayOffset(array, Character.BYTES, offset),\n+            true);\n@@ -98,0 +111,1 @@\n+    @ForceInline\n@@ -99,1 +113,4 @@\n-        return (short) SHORT.get(array, offset);\n+        return UNSAFE.getShortUnaligned(\n+            array,\n+            arrayOffset(array, Short.BYTES, offset),\n+            true);\n@@ -115,0 +132,1 @@\n+    @ForceInline\n@@ -116,1 +134,1 @@\n-        return Short.toUnsignedInt((short) SHORT.get(array, offset));\n+        return Short.toUnsignedInt(getShort(array, offset));\n@@ -131,0 +149,1 @@\n+    @ForceInline\n@@ -132,1 +151,4 @@\n-        return (int) INT.get(array, offset);\n+        return UNSAFE.getIntUnaligned(\n+            array,\n+            arrayOffset(array, Integer.BYTES, offset),\n+            true);\n@@ -136,1 +158,1 @@\n-     * {@return a {@code float} from the provided {@code array} at the given {@code offset}\n+     * {@return an {@code unsigned int} from the provided {@code array} at the given {@code offset}\n@@ -139,2 +161,0 @@\n-     * Variants of {@linkplain Float#NaN } values are canonized to a single NaN value.\n-     * <p>\n@@ -145,0 +165,1 @@\n+     * @return an {@code long} representing an unsigned int from the array\n@@ -147,1 +168,1 @@\n-     * @see #setFloat(byte[], int, float)\n+     * @see #setUnsignedInt(byte[], int, long)\n@@ -149,4 +170,3 @@\n-    public static float getFloat(byte[] array, int offset) {\n-        \/\/ Using Float.intBitsToFloat collapses NaN values to a single\n-        \/\/ \"canonical\" NaN value\n-        return Float.intBitsToFloat((int) INT.get(array, offset));\n+    @ForceInline\n+    public static long getUnsignedInt(byte[] array, int offset) {\n+        return Integer.toUnsignedLong(getInt(array, offset));\n@@ -159,3 +179,0 @@\n-     * Variants of {@linkplain Float#NaN } values are silently read according\n-     * to their bit patterns.\n-     * <p>\n@@ -168,1 +185,1 @@\n-     * @see #setFloatRaw(byte[], int, float)\n+     * @see #setFloat(byte[], int, float)\n@@ -170,3 +187,3 @@\n-    public static float getFloatRaw(byte[] array, int offset) {\n-        \/\/ Just gets the bits as they are\n-        return (float) FLOAT.get(array, offset);\n+    @ForceInline\n+    public static float getFloat(byte[] array, int offset) {\n+        return Float.intBitsToFloat(getInt(array, offset));\n@@ -187,0 +204,1 @@\n+    @ForceInline\n@@ -188,1 +206,4 @@\n-        return (long) LONG.get(array, offset);\n+        return UNSAFE.getLongUnaligned(\n+            array,\n+            arrayOffset(array, Long.BYTES, offset),\n+            true);\n@@ -195,2 +216,0 @@\n-     * Variants of {@linkplain Double#NaN } values are canonized to a single NaN value.\n-     * <p>\n@@ -205,0 +224,1 @@\n+    @ForceInline\n@@ -206,23 +226,1 @@\n-        \/\/ Using Double.longBitsToDouble collapses NaN values to a single\n-        \/\/ \"canonical\" NaN value\n-        return Double.longBitsToDouble((long) LONG.get(array, offset));\n-    }\n-\n-    \/**\n-     * {@return a {@code double} from the provided {@code array} at the given {@code offset}\n-     * using big endian order}.\n-     * <p>\n-     * Variants of {@linkplain Double#NaN } values are silently read according to\n-     * their bit patterns.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to get a value from.\n-     * @param offset where extraction in the array should begin\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 8]\n-     * @see #setDoubleRaw(byte[], int, double)\n-     *\/\n-    public static double getDoubleRaw(byte[] array, int offset) {\n-        \/\/ Just gets the bits as they are\n-        return (double) DOUBLE.get(array, offset);\n+        return Double.longBitsToDouble(getLong(array, offset));\n@@ -247,0 +245,1 @@\n+    @ForceInline\n@@ -264,0 +263,1 @@\n+    @ForceInline\n@@ -265,1 +265,5 @@\n-        CHAR.set(array, offset, value);\n+        UNSAFE.putCharUnaligned(\n+                array,\n+                arrayOffset(array, Character.BYTES, offset),\n+                value,\n+                true);\n@@ -281,0 +285,1 @@\n+    @ForceInline\n@@ -282,1 +287,5 @@\n-        SHORT.set(array, offset, value);\n+        UNSAFE.putShortUnaligned(\n+                array,\n+                arrayOffset(array, Short.BYTES, offset),\n+                value,\n+                true);\n@@ -298,0 +307,1 @@\n+    @ForceInline\n@@ -299,1 +309,1 @@\n-        SHORT.set(array, offset, (short) (char) value);\n+        setShort(array, offset, (short) (char) value);\n@@ -315,0 +325,1 @@\n+    @ForceInline\n@@ -316,1 +327,23 @@\n-        INT.set(array, offset, value);\n+        UNSAFE.putIntUnaligned(\n+                array,\n+                arrayOffset(array, Integer.BYTES, offset),\n+                value,\n+                true);\n+    }\n+\n+    \/**\n+     * Sets (writes) the provided {@code value} using big endian order into\n+     * the provided {@code array} beginning at the given {@code offset}.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to set (write) a value into\n+     * @param offset where setting (writing) in the array should begin\n+     * @param value  value to set in the array\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 4]\n+     * @see #getUnsignedInt(byte[], int)\n+     *\/\n+    @ForceInline\n+    public static void setUnsignedInt(byte[] array, int offset, long value) {\n+        setInt(array, offset, (int) value);\n@@ -334,0 +367,1 @@\n+    @ForceInline\n@@ -337,1 +371,1 @@\n-        INT.set(array, offset, Float.floatToIntBits(value));\n+        setInt(array, offset, Float.floatToIntBits(value));\n@@ -354,1 +388,1 @@\n-     * @see #getFloatRaw(byte[], int)\n+     * @see #getFloat(byte[], int)\n@@ -356,0 +390,1 @@\n+    @ForceInline\n@@ -358,1 +393,1 @@\n-        FLOAT.set(array, offset, value);\n+        setInt(array, offset, Float.floatToRawIntBits(value));\n@@ -374,0 +409,1 @@\n+    @ForceInline\n@@ -375,1 +411,5 @@\n-        LONG.set(array, offset, value);\n+        UNSAFE.putLongUnaligned(\n+                array,\n+                arrayOffset(array, Long.BYTES, offset),\n+                value,\n+                true);\n@@ -393,0 +433,1 @@\n+    @ForceInline\n@@ -396,1 +437,1 @@\n-        LONG.set(array, offset, Double.doubleToLongBits(value));\n+        setLong(array, offset, Double.doubleToLongBits(value));\n@@ -413,1 +454,1 @@\n-     * @see #getDoubleRaw(byte[], int)\n+     * @see #getDouble(byte[], int)\n@@ -415,0 +456,1 @@\n+    @ForceInline\n@@ -417,5 +459,1 @@\n-        DOUBLE.set(array, offset, value);\n-    }\n-\n-    private static VarHandle create(Class<?> viewArrayClass) {\n-        return MethodHandles.byteArrayViewVarHandle(viewArrayClass, ByteOrder.BIG_ENDIAN);\n+        setLong(array, offset, Double.doubleToRawLongBits(value));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ByteArray.java","additions":108,"deletions":70,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -28,3 +28,5 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import static jdk.internal.util.ByteArray.arrayOffset;\n+import static jdk.internal.util.ByteArray.UNSAFE;\n@@ -34,1 +36,1 @@\n- * using {@linkplain ByteOrder#LITTLE_ENDIAN little endian order}.\n+ * using {@linkplain java.nio.ByteOrder#LITTLE_ENDIAN little endian order}.\n@@ -44,7 +46,0 @@\n-    private static final VarHandle SHORT = createLittleEndian(short[].class);\n-    private static final VarHandle CHAR = createLittleEndian(char[].class);\n-    private static final VarHandle INT = createLittleEndian(int[].class);\n-    private static final VarHandle FLOAT = createLittleEndian(float[].class);\n-    private static final VarHandle LONG = createLittleEndian(long[].class);\n-    private static final VarHandle DOUBLE = createLittleEndian(double[].class);\n-\n@@ -65,0 +60,1 @@\n+    @ForceInline\n@@ -81,0 +77,1 @@\n+    @ForceInline\n@@ -82,1 +79,4 @@\n-        return (char) CHAR.get(array, offset);\n+        return UNSAFE.getCharUnaligned(\n+            array,\n+            arrayOffset(array, Character.BYTES, offset),\n+            false);\n@@ -98,0 +98,1 @@\n+    @ForceInline\n@@ -99,1 +100,4 @@\n-        return (short) SHORT.get(array, offset);\n+        return UNSAFE.getShortUnaligned(\n+            array,\n+            arrayOffset(array, Short.BYTES, offset),\n+            false);\n@@ -115,0 +119,1 @@\n+    @ForceInline\n@@ -116,1 +121,1 @@\n-        return Short.toUnsignedInt((short) SHORT.get(array, offset));\n+        return Short.toUnsignedInt(getShort(array, offset));\n@@ -131,0 +136,1 @@\n+    @ForceInline\n@@ -132,1 +138,4 @@\n-        return (int) INT.get(array, offset);\n+        return UNSAFE.getIntUnaligned(\n+            array,\n+            arrayOffset(array, Integer.BYTES, offset),\n+            false);\n@@ -135,5 +144,3 @@\n-    \/**\n-     * {@return a {@code float} from the provided {@code array} at the given {@code offset}\n-     * using little endian order}.\n-     * <p>\n-     * Variants of {@linkplain Float#NaN } values are canonized to a single NaN value.\n+   \/**\n+     * {@return an {@code unsigned int} from the provided {@code array} at the given {@code offset}\n+     * using big endian order}.\n@@ -145,0 +152,1 @@\n+     * @return an {@code long} representing an unsigned int from the array\n@@ -147,1 +155,1 @@\n-     * @see #setFloat(byte[], int, float)\n+     * @see #setUnsignedInt(byte[], int, long)\n@@ -149,4 +157,3 @@\n-    public static float getFloat(byte[] array, int offset) {\n-        \/\/ Using Float.intBitsToFloat collapses NaN values to a single\n-        \/\/ \"canonical\" NaN value\n-        return Float.intBitsToFloat((int) INT.get(array, offset));\n+    @ForceInline\n+    public static long getUnsignedInt(byte[] array, int offset) {\n+        return Integer.toUnsignedLong(getInt(array, offset));\n@@ -159,3 +166,0 @@\n-     * Variants of {@linkplain Float#NaN } values are silently read according\n-     * to their bit patterns.\n-     * <p>\n@@ -168,1 +172,1 @@\n-     * @see #setFloatRaw(byte[], int, float)\n+     * @see #setFloat(byte[], int, float)\n@@ -170,3 +174,3 @@\n-    public static float getFloatRaw(byte[] array, int offset) {\n-        \/\/ Just gets the bits as they are\n-        return (float) FLOAT.get(array, offset);\n+    @ForceInline\n+    public static float getFloat(byte[] array, int offset) {\n+        return Float.intBitsToFloat(getInt(array, offset));\n@@ -187,0 +191,1 @@\n+    @ForceInline\n@@ -188,1 +193,4 @@\n-        return (long) LONG.get(array, offset);\n+        return UNSAFE.getLongUnaligned(\n+            array,\n+            arrayOffset(array, Long.BYTES, offset),\n+            false);\n@@ -195,2 +203,0 @@\n-     * Variants of {@linkplain Double#NaN } values are canonized to a single NaN value.\n-     * <p>\n@@ -205,0 +211,1 @@\n+    @ForceInline\n@@ -206,23 +213,1 @@\n-        \/\/ Using Double.longBitsToDouble collapses NaN values to a single\n-        \/\/ \"canonical\" NaN value\n-        return Double.longBitsToDouble((long) LONG.get(array, offset));\n-    }\n-\n-    \/**\n-     * {@return a {@code double} from the provided {@code array} at the given {@code offset}\n-     * using little endian order}.\n-     * <p>\n-     * Variants of {@linkplain Double#NaN } values are silently read according to\n-     * their bit patterns.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to get a value from.\n-     * @param offset where extraction in the array should begin\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 8]\n-     * @see #setDoubleRaw(byte[], int, double)\n-     *\/\n-    public static double getDoubleRaw(byte[] array, int offset) {\n-        \/\/ Just gets the bits as they are\n-        return (double) DOUBLE.get(array, offset);\n+        return Double.longBitsToDouble(getLong(array, offset));\n@@ -247,0 +232,1 @@\n+    @ForceInline\n@@ -264,0 +250,1 @@\n+    @ForceInline\n@@ -265,1 +252,5 @@\n-        CHAR.set(array, offset, value);\n+        UNSAFE.putCharUnaligned(\n+                array,\n+                arrayOffset(array, Character.BYTES, offset),\n+                value,\n+                false);\n@@ -281,0 +272,1 @@\n+    @ForceInline\n@@ -282,1 +274,5 @@\n-        SHORT.set(array, offset, value);\n+        UNSAFE.putShortUnaligned(\n+                array,\n+                arrayOffset(array, Short.BYTES, offset),\n+                value,\n+                false);\n@@ -298,0 +294,1 @@\n+    @ForceInline\n@@ -299,1 +296,1 @@\n-        SHORT.set(array, offset, (short) (char) value);\n+        setShort(array, offset, (short) (char) value);\n@@ -315,0 +312,1 @@\n+    @ForceInline\n@@ -316,1 +314,23 @@\n-        INT.set(array, offset, value);\n+        UNSAFE.putIntUnaligned(\n+                array,\n+                arrayOffset(array, Integer.BYTES, offset),\n+                value,\n+                false);\n+    }\n+\n+   \/**\n+     * Sets (writes) the provided {@code value} using big endian order into\n+     * the provided {@code array} beginning at the given {@code offset}.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to set (write) a value into\n+     * @param offset where setting (writing) in the array should begin\n+     * @param value  value to set in the array\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 4]\n+     * @see #getUnsignedInt(byte[], int)\n+     *\/\n+    @ForceInline\n+    public static void setUnsignedInt(byte[] array, int offset, long value) {\n+        setInt(array, offset, (int) value);\n@@ -334,0 +354,1 @@\n+    @ForceInline\n@@ -337,1 +358,1 @@\n-        INT.set(array, offset, Float.floatToIntBits(value));\n+        setInt(array, offset, Float.floatToIntBits(value));\n@@ -354,1 +375,1 @@\n-     * @see #getFloatRaw(byte[], int)\n+     * @see #getFloat(byte[], int)\n@@ -356,0 +377,1 @@\n+    @ForceInline\n@@ -358,1 +380,1 @@\n-        FLOAT.set(array, offset, value);\n+        setInt(array, offset, Float.floatToRawIntBits(value));\n@@ -374,0 +396,1 @@\n+    @ForceInline\n@@ -375,1 +398,5 @@\n-        LONG.set(array, offset, value);\n+        UNSAFE.putLongUnaligned(\n+                array,\n+                arrayOffset(array, Long.BYTES, offset),\n+                value,\n+                false);\n@@ -393,0 +420,1 @@\n+    @ForceInline\n@@ -396,1 +424,1 @@\n-        LONG.set(array, offset, Double.doubleToLongBits(value));\n+        setLong(array, offset, Double.doubleToLongBits(value));\n@@ -413,1 +441,1 @@\n-     * @see #getDoubleRaw(byte[], int)\n+     * @see #getDouble(byte[], int)\n@@ -415,0 +443,1 @@\n+    @ForceInline\n@@ -417,5 +446,1 @@\n-        DOUBLE.set(array, offset, value);\n-    }\n-\n-    private static VarHandle createLittleEndian(Class<?> viewArrayClass) {\n-        return MethodHandles.byteArrayViewVarHandle(viewArrayClass, ByteOrder.LITTLE_ENDIAN);\n+        setLong(array, offset, Double.doubleToRawLongBits(value));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ByteArrayLittleEndian.java","additions":98,"deletions":73,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8299576\n+ * @bug 8299576 8310843\n@@ -33,0 +33,1 @@\n+import jdk.internal.util.ByteArrayLittleEndian;\n@@ -40,0 +41,3 @@\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.ParameterizedTest;\n@@ -51,2 +55,3 @@\n-    @Test\n-    void testGetShort() {\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testGetShort(ByteArrayImpl ref, ByteArrayImpl ba) {\n@@ -55,2 +60,2 @@\n-            RefImpl.putShort(BUFF, OFFSET, expected);\n-            short actual = ByteArray.getShort(BUFF, OFFSET);\n+            ref.setShort(BUFF, OFFSET, expected);\n+            short actual = ba.getShort(BUFF, OFFSET);\n@@ -61,2 +66,3 @@\n-    @Test\n-    void testPutShort() {\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testSetShort(ByteArrayImpl ref, ByteArrayImpl ba) {\n@@ -65,2 +71,2 @@\n-            ByteArray.setShort(BUFF, OFFSET, expected);\n-            short actual = RefImpl.getShort(BUFF, OFFSET);\n+            ba.setShort(BUFF, OFFSET, expected);\n+            short actual = ref.getShort(BUFF, OFFSET);\n@@ -71,2 +77,3 @@\n-    @Test\n-    void testGetChar() {\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testGetChar(ByteArrayImpl ref, ByteArrayImpl ba) {\n@@ -75,2 +82,2 @@\n-            RefImpl.putChar(BUFF, OFFSET, expected);\n-            char actual = ByteArray.getChar(BUFF, OFFSET);\n+            ref.setChar(BUFF, OFFSET, expected);\n+            char actual = ba.getChar(BUFF, OFFSET);\n@@ -81,2 +88,3 @@\n-    @Test\n-    void testPutChar() {\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testSetChar(ByteArrayImpl ref, ByteArrayImpl ba) {\n@@ -85,2 +93,2 @@\n-            ByteArray.setChar(BUFF, OFFSET, expected);\n-            char actual = RefImpl.getChar(BUFF, OFFSET);\n+            ba.setChar(BUFF, OFFSET, expected);\n+            char actual = ref.getChar(BUFF, OFFSET);\n@@ -91,2 +99,3 @@\n-    @Test\n-    void testGetInt() {\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testGetInt(ByteArrayImpl ref, ByteArrayImpl ba) {\n@@ -95,2 +104,2 @@\n-            RefImpl.putInt(BUFF, OFFSET, expected);\n-            int actual = ByteArray.getInt(BUFF, OFFSET);\n+            ref.setInt(BUFF, OFFSET, expected);\n+            int actual = ba.getInt(BUFF, OFFSET);\n@@ -101,2 +110,3 @@\n-    @Test\n-    void testPutInt() {\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testSetInt(ByteArrayImpl ref, ByteArrayImpl ba) {\n@@ -105,2 +115,2 @@\n-            ByteArray.setInt(BUFF, OFFSET, expected);\n-            int actual = RefImpl.getInt(BUFF, OFFSET);\n+            ba.setInt(BUFF, OFFSET, expected);\n+            int actual = ref.getInt(BUFF, OFFSET);\n@@ -111,2 +121,3 @@\n-    @Test\n-    void testGetLong() {\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testGetLong(ByteArrayImpl ref, ByteArrayImpl ba) {\n@@ -114,2 +125,2 @@\n-            RefImpl.putLong(BUFF, OFFSET, expected);\n-            long actual = ByteArray.getLong(BUFF, OFFSET);\n+            ref.setLong(BUFF, OFFSET, expected);\n+            long actual = ba.getLong(BUFF, OFFSET);\n@@ -120,2 +131,3 @@\n-    @Test\n-    void testPutLong() {\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testSetLong(ByteArrayImpl ref, ByteArrayImpl ba) {\n@@ -123,2 +135,2 @@\n-            ByteArray.setLong(BUFF, OFFSET, expected);\n-            long actual = RefImpl.getLong(BUFF, OFFSET);\n+            ba.setLong(BUFF, OFFSET, expected);\n+            long actual = ref.getLong(BUFF, OFFSET);\n@@ -129,2 +141,3 @@\n-    @Test\n-    void testGetFloat() {\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testGetFloat(ByteArrayImpl ref, ByteArrayImpl ba) {\n@@ -132,2 +145,2 @@\n-            RefImpl.putFloat(BUFF, OFFSET, expected);\n-            float actual = ByteArray.getFloat(BUFF, OFFSET);\n+            ref.setFloat(BUFF, OFFSET, expected);\n+            float actual = ba.getFloat(BUFF, OFFSET);\n@@ -138,2 +151,3 @@\n-    @Test\n-    void testPutFloat() {\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testSetFloat(ByteArrayImpl ref, ByteArrayImpl ba) {\n@@ -141,2 +155,2 @@\n-            ByteArray.setFloat(BUFF, OFFSET, expected);\n-            float actual = RefImpl.getFloat(BUFF, OFFSET);\n+            ba.setFloat(BUFF, OFFSET, expected);\n+            float actual = ref.getFloat(BUFF, OFFSET);\n@@ -147,2 +161,3 @@\n-    @Test\n-    void testGetDouble() {\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testGetDouble(ByteArrayImpl ref, ByteArrayImpl ba) {\n@@ -150,2 +165,2 @@\n-            RefImpl.putDouble(BUFF, OFFSET, expected);\n-            double actual = ByteArray.getDouble(BUFF, OFFSET);\n+            ref.setDouble(BUFF, OFFSET, expected);\n+            double actual = ba.getDouble(BUFF, OFFSET);\n@@ -156,2 +171,3 @@\n-    @Test\n-    void testPutDouble() {\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testSetDouble(ByteArrayImpl ref, ByteArrayImpl ba) {\n@@ -159,2 +175,2 @@\n-            ByteArray.setDouble(BUFF, OFFSET, expected);\n-            double actual = RefImpl.getDouble(BUFF, OFFSET);\n+            ba.setDouble(BUFF, OFFSET, expected);\n+            double actual = ref.getDouble(BUFF, OFFSET);\n@@ -165,2 +181,3 @@\n-    @Test\n-    void testPutUnsignedShort() {\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testGetUnsignedShort(ByteArrayImpl ref, ByteArrayImpl ba) {\n@@ -169,2 +186,35 @@\n-            ByteArray.setUnsignedShort(BUFF, OFFSET, expected);\n-            int actual = Short.toUnsignedInt(RefImpl.getShort(BUFF, OFFSET));\n+            ref.setUnsignedShort(BUFF, OFFSET, expected);\n+            int actual = ba.getUnsignedShort(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testSetUnsignedShort(ByteArrayImpl ref, ByteArrayImpl ba) {\n+        longs().forEach(l -> {\n+            int expected = Short.toUnsignedInt((short) l);\n+            ba.setUnsignedShort(BUFF, OFFSET, expected);\n+            int actual = ref.getUnsignedShort(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testGetUnsignedInt(ByteArrayImpl ref, ByteArrayImpl ba) {\n+        longs().forEach(l -> {\n+            long expected = Integer.toUnsignedLong((int) l);\n+            ref.setUnsignedInt(BUFF, OFFSET, expected);\n+            long actual = ba.getUnsignedInt(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImplWithRef\")\n+    void testSetUnsignedInt(ByteArrayImpl ref, ByteArrayImpl ba) {\n+        longs().forEach(l -> {\n+            long expected = Integer.toUnsignedLong((int) l);\n+            ba.setUnsignedInt(BUFF, OFFSET, expected);\n+            long actual = ref.getUnsignedInt(BUFF, OFFSET);\n@@ -177,4 +227,5 @@\n-    @Test\n-    void testNullArray() {\n-        assertThrowsOriginal(NullPointerException.class, () -> ByteArray.getInt(null, OFFSET));\n-        assertThrowsOriginal(NullPointerException.class, () -> ByteArray.setInt(null, OFFSET, 1));\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImpl\")\n+    void testNullArray(ByteArrayImpl ba) {\n+        assertThrowsOriginal(NullPointerException.class, () -> ba.getInt(null, OFFSET));\n+        assertThrowsOriginal(NullPointerException.class, () -> ba.setInt(null, OFFSET, 1));\n@@ -183,4 +234,5 @@\n-    @Test\n-    void testNegArg() {\n-        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArray.getInt(BUFF, -1));\n-        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArray.setInt(BUFF, -1, 1));\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImpl\")\n+    void testNegArg(ByteArrayImpl ba) {\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ba.getInt(BUFF, -1));\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ba.setInt(BUFF, -1, 1));\n@@ -189,4 +241,5 @@\n-    @Test\n-    void testOutOfBounds() {\n-        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArray.getInt(BUFF, BUFF.length));\n-        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArray.setInt(BUFF, BUFF.length, 1));\n+    @ParameterizedTest\n+    @MethodSource(\"byteArrayImpl\")\n+    void testOutOfBounds(ByteArrayImpl ba) {\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ba.getInt(BUFF, BUFF.length));\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ba.setInt(BUFF, BUFF.length, 1));\n@@ -211,0 +264,1 @@\n+\n@@ -224,0 +278,10 @@\n+    static Stream<ByteArrayImpl> byteArrayImpl() {\n+        return Stream.of(UNSAFE, UNSAFE_LE);\n+    }\n+\n+    static Stream<Arguments> byteArrayImplWithRef() {\n+        return Stream.of(\n+                Arguments.of(REF, UNSAFE),\n+                Arguments.of(REF_LE, UNSAFE_LE));\n+    }\n+\n@@ -245,0 +309,55 @@\n+    private interface ByteArrayImpl {\n+        char getChar(byte[] b, int off);\n+\n+        short getShort(byte[] b, int off);\n+\n+        default int getUnsignedShort(byte[] b, int off) {\n+            return Short.toUnsignedInt(getShort(b, off));\n+        }\n+\n+        int getInt(byte[] b, int off);\n+\n+        default long getUnsignedInt(byte[] b, int off) {\n+            return Integer.toUnsignedLong(getInt(b, off));\n+        }\n+\n+        long getLong(byte[] b, int off);\n+\n+        default float getFloat(byte[] b, int off) {\n+            return Float.intBitsToFloat(getInt(b, off));\n+        }\n+\n+        default double getDouble(byte[] b, int off) {\n+            return Double.longBitsToDouble(getLong(b, off));\n+        }\n+\n+        \/*\n+         * Methods for packing primitive values into byte arrays starting at given\n+         * offsets.\n+         *\/\n+\n+        void setChar(byte[] b, int off, char val);\n+\n+        void setShort(byte[] b, int off, short val);\n+\n+        default void setUnsignedShort(byte[] b, int off, int val) {\n+            setShort(b, off, (short) val);\n+        }\n+\n+        void setInt(byte[] b, int off, int val);\n+\n+        default void setUnsignedInt(byte[] b, int off, long val) {\n+            setInt(b, off, (int) val);\n+        }\n+\n+        void setLong(byte[] b, int off, long val);\n+\n+        default void setFloat(byte[] b, int off, float val) {\n+            setInt(b, off, Float.floatToIntBits(val));\n+        }\n+\n+        default void setDouble(byte[] b, int off, double val) {\n+            setLong(b, off, Double.doubleToLongBits(val));\n+        }\n+    }\n+\n@@ -248,4 +367,2 @@\n-    private static final class RefImpl {\n-        private RefImpl() {}\n-\n-        static char getChar(byte[] b, int off) {\n+    private static final ByteArrayImpl REF = new ByteArrayImpl() {\n+        public char getChar(byte[] b, int off) {\n@@ -256,1 +373,1 @@\n-        static short getShort(byte[] b, int off) {\n+        public short getShort(byte[] b, int off) {\n@@ -261,1 +378,1 @@\n-        static int getInt(byte[] b, int off) {\n+        public int getInt(byte[] b, int off) {\n@@ -268,5 +385,1 @@\n-        static float getFloat(byte[] b, int off) {\n-            return Float.intBitsToFloat(getInt(b, off));\n-        }\n-\n-        static long getLong(byte[] b, int off) {\n+        public long getLong(byte[] b, int off) {\n@@ -283,10 +396,1 @@\n-        static double getDouble(byte[] b, int off) {\n-            return Double.longBitsToDouble(getLong(b, off));\n-        }\n-\n-        \/*\n-         * Methods for packing primitive values into byte arrays starting at given\n-         * offsets.\n-         *\/\n-\n-        static void putChar(byte[] b, int off, char val) {\n+        public void setChar(byte[] b, int off, char val) {\n@@ -297,1 +401,1 @@\n-        static void putShort(byte[] b, int off, short val) {\n+        public void setShort(byte[] b, int off, short val) {\n@@ -302,1 +406,1 @@\n-        static void putInt(byte[] b, int off, int val) {\n+        public void setInt(byte[] b, int off, int val) {\n@@ -309,5 +413,1 @@\n-        static void putFloat(byte[] b, int off, float val) {\n-            putInt(b, off, Float.floatToIntBits(val));\n-        }\n-\n-        static void putLong(byte[] b, int off, long val) {\n+        public void setLong(byte[] b, int off, long val) {\n@@ -323,0 +423,1 @@\n+    };\n@@ -324,2 +425,4 @@\n-        static void putDouble(byte[] b, int off, double val) {\n-            putLong(b, off, Double.doubleToLongBits(val));\n+    private static final ByteArrayImpl REF_LE = new ByteArrayImpl() {\n+        public char getChar(byte[] b, int off) {\n+            return (char) ((b[off] & 0xFF) +\n+                    (b[off + 1] << 8));\n@@ -327,1 +430,184 @@\n-    }\n+\n+        public short getShort(byte[] b, int off) {\n+            return (short) ((b[off] & 0xFF) +\n+                    (b[off + 1] << 8));\n+        }\n+\n+        public int getInt(byte[] b, int off) {\n+            return ((b[off] & 0xFF)) +\n+                    ((b[off + 1] & 0xFF) << 8) +\n+                    ((b[off + 2] & 0xFF) << 16) +\n+                    ((b[off + 3]) << 24);\n+        }\n+\n+        public long getLong(byte[] b, int off) {\n+            return ((b[off] & 0xFFL)) +\n+                    ((b[off + 1] & 0xFFL) << 8) +\n+                    ((b[off + 2] & 0xFFL) << 16) +\n+                    ((b[off + 3] & 0xFFL) << 24) +\n+                    ((b[off + 4] & 0xFFL) << 32) +\n+                    ((b[off + 5] & 0xFFL) << 40) +\n+                    ((b[off + 6] & 0xFFL) << 48) +\n+                    (((long) b[off + 7]) << 56);\n+        }\n+\n+        public void setChar(byte[] b, int off, char val) {\n+            b[off] = (byte) (val);\n+            b[off + 1] = (byte) (val >>> 8);\n+        }\n+\n+        public void setShort(byte[] b, int off, short val) {\n+            b[off] = (byte) (val);\n+            b[off + 1] = (byte) (val >>> 8);\n+        }\n+\n+        public void setInt(byte[] b, int off, int val) {\n+            b[off] = (byte) (val);\n+            b[off + 1] = (byte) (val >>> 8);\n+            b[off + 2] = (byte) (val >>> 16);\n+            b[off + 3] = (byte) (val >>> 24);\n+        }\n+\n+        public void setLong(byte[] b, int off, long val) {\n+            b[off] = (byte) (val);\n+            b[off + 1] = (byte) (val >>> 8);\n+            b[off + 2] = (byte) (val >>> 16);\n+            b[off + 3] = (byte) (val >>> 24);\n+            b[off + 4] = (byte) (val >>> 32);\n+            b[off + 5] = (byte) (val >>> 40);\n+            b[off + 6] = (byte) (val >>> 48);\n+            b[off + 7] = (byte) (val >>> 56);\n+        }\n+    };\n+\n+    private static final ByteArrayImpl UNSAFE = new ByteArrayImpl() {\n+        public char getChar(byte[] b, int off) {\n+            return ByteArray.getChar(b, off);\n+        }\n+\n+        public short getShort(byte[] b, int off) {\n+            return ByteArray.getShort(b, off);\n+        }\n+\n+        public int getUnsignedShort(byte[] b, int off) {\n+            return ByteArray.getUnsignedShort(b, off);\n+        }\n+\n+        public int getInt(byte[] b, int off) {\n+            return ByteArray.getInt(b, off);\n+        }\n+\n+        public long getUnsignedInt(byte[] b, int off) {\n+            return ByteArray.getUnsignedInt(b, off);\n+        }\n+\n+        public long getLong(byte[] b, int off) {\n+            return ByteArray.getLong(b, off);\n+        }\n+\n+        public float getFloat(byte[] b, int off) {\n+            return ByteArray.getFloat(b, off);\n+        }\n+\n+        public double getDouble(byte[] b, int off) {\n+            return ByteArray.getDouble(b, off);\n+        }\n+\n+        public void setChar(byte[] b, int off, char val) {\n+            ByteArray.setChar(b, off, val);\n+        }\n+\n+        public void setShort(byte[] b, int off, short val) {\n+            ByteArray.setShort(b, off, val);\n+        }\n+\n+        public void setUnsignedShort(byte[] b, int off, int val) {\n+            ByteArray.setUnsignedShort(b, off, val);\n+        }\n+\n+        public void setInt(byte[] b, int off, int val) {\n+            ByteArray.setInt(b, off, val);\n+        }\n+\n+        public void setUnsignedInt(byte[] b, int off, long val) {\n+            ByteArray.setUnsignedInt(b, off, val);\n+        }\n+\n+        public void setLong(byte[] b, int off, long val) {\n+            ByteArray.setLong(b, off, val);\n+        }\n+\n+        public void setFloat(byte[] b, int off, float val) {\n+            ByteArray.setFloat(b, off, val);\n+        }\n+\n+        public void setDouble(byte[] b, int off, double val) {\n+            ByteArray.setDouble(b, off, val);\n+        }\n+    };\n+\n+    private static final ByteArrayImpl UNSAFE_LE = new ByteArrayImpl() {\n+        public char getChar(byte[] b, int off) {\n+            return ByteArrayLittleEndian.getChar(b, off);\n+        }\n+\n+        public short getShort(byte[] b, int off) {\n+            return ByteArrayLittleEndian.getShort(b, off);\n+        }\n+\n+        public int getUnsignedShort(byte[] b, int off) {\n+            return ByteArrayLittleEndian.getUnsignedShort(b, off);\n+        }\n+\n+        public int getInt(byte[] b, int off) {\n+            return ByteArrayLittleEndian.getInt(b, off);\n+        }\n+\n+        public long getUnsignedInt(byte[] b, int off) {\n+            return ByteArrayLittleEndian.getUnsignedInt(b, off);\n+        }\n+\n+        public long getLong(byte[] b, int off) {\n+            return ByteArrayLittleEndian.getLong(b, off);\n+        }\n+\n+        public float getFloat(byte[] b, int off) {\n+            return ByteArrayLittleEndian.getFloat(b, off);\n+        }\n+\n+        public double getDouble(byte[] b, int off) {\n+            return ByteArrayLittleEndian.getDouble(b, off);\n+        }\n+\n+        public void setChar(byte[] b, int off, char val) {\n+            ByteArrayLittleEndian.setChar(b, off, val);\n+        }\n+\n+        public void setShort(byte[] b, int off, short val) {\n+            ByteArrayLittleEndian.setShort(b, off, val);\n+        }\n+\n+        public void setUnsignedShort(byte[] b, int off, int val) {\n+            ByteArrayLittleEndian.setUnsignedShort(b, off, val);\n+        }\n+\n+        public void setInt(byte[] b, int off, int val) {\n+            ByteArrayLittleEndian.setInt(b, off, val);\n+        }\n+\n+        public void setUnsignedInt(byte[] b, int off, long val) {\n+            ByteArrayLittleEndian.setUnsignedInt(b, off, val);\n+        }\n+\n+        public void setLong(byte[] b, int off, long val) {\n+            ByteArrayLittleEndian.setLong(b, off, val);\n+        }\n+\n+        public void setFloat(byte[] b, int off, float val) {\n+            ByteArrayLittleEndian.setFloat(b, off, val);\n+        }\n+\n+        public void setDouble(byte[] b, int off, double val) {\n+            ByteArrayLittleEndian.setDouble(b, off, val);\n+        }\n+    };\n","filename":"test\/jdk\/jdk\/internal\/util\/ByteArray\/ReadWriteValues.java","additions":382,"deletions":96,"binary":false,"changes":478,"status":"modified"}]}