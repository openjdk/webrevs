{"files":[{"patch":"@@ -105,0 +105,4 @@\n+    if (required_len < 0) {\n+      result_len = 0;\n+      return \"\";\n+    }\n","filename":"src\/hotspot\/share\/utilities\/ostream.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include <wchar.h>\n@@ -124,0 +125,22 @@\n+#ifndef ASSERT\n+\/\/ In debug builds, an encoding error should result in an assert. We do not test this here.\n+\/\/ In release builds, an encoding error should be swallowed silently.\n+TEST_VM(ostream, encoding_error) {\n+  const wchar_t w[] = { (wchar_t)-1, 0 };\n+  char buf[20];\n+  ::memset(buf, 'X', sizeof(buf));\n+  int n = ::snprintf(buf + 1, sizeof(buf) - 2, \"HALLO %ls\", w);\n+  if (n == -1) { \/\/ yes, we get an error. Retry using stringStream.\n+    ::memset(buf, 'X', sizeof(buf));\n+    stringStream ss (buf + 1, sizeof(buf) - 2);\n+    ss.print_cr(\"HALLO %ls\", w);\n+    \/\/ We should not have crashed or asserted in the libc or anything else.\n+    \/\/ We should not have overstepped the buffer boundaries either.\n+    ASSERT_EQ(buf[0], 'X');\n+    ASSERT_EQ(buf[sizeof(buf) - 1], 'X');\n+    \/\/ The resulting buffer should have length zero\n+    ASSERT_EQ(buf[1], '\\0');\n+  }\n+}\n+#endif\n+\n","filename":"test\/hotspot\/gtest\/utilities\/test_ostream.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"}]}