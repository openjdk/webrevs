{"files":[{"patch":"@@ -105,0 +105,4 @@\n+    if (required_len < 0) {\n+      result_len = 0;\n+      return \"\";\n+    }\n","filename":"src\/hotspot\/share\/utilities\/ostream.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023 SAP SE. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include <wchar.h>\n@@ -124,0 +125,32 @@\n+static void provoke_snprintf_error() {\n+  const wchar_t w[] = { (wchar_t)-1, 0 };\n+  char buf[20];\n+  ::memset(buf, 'X', sizeof(buf));\n+  int n = ::snprintf(buf + 1, sizeof(buf) - 2, \"HALLO %ls\", w);\n+  if (n == -1) { \/\/ yes, we get an error. Retry using stringStream.\n+    ::memset(buf, 'X', sizeof(buf));\n+    stringStream ss (buf + 1, sizeof(buf) - 2);\n+    ss.print_cr(\"HALLO %ls\", w); \/\/ should assert in debug\n+    \/\/ We should not have overstepped the buffer boundaries.\n+    ASSERT_EQ(buf[0], 'X');\n+    ASSERT_EQ(buf[sizeof(buf) - 1], 'X');\n+    \/\/ The resulting buffer should have length zero\n+    ASSERT_EQ(buf[1], '\\0');\n+  } else {\n+    \/\/ We are unable to provoke an error. For the debug-only death test,\n+    \/\/ just mimic the expected assert to satisfy the test.\n+    assert(false, \"fake assert vsnprintf encoding error fake assert\");\n+  }\n+}\n+\n+\/\/ In debug, snprintf error should result in an assert, in release, the error should\n+\/\/ be silently swallowed.\n+#ifdef ASSERT\n+TEST_VM_ASSERT_MSG(ostream, snprintf_error, \".*vsnprintf encoding error.*\")\n+#else\n+TEST_VM(ostream, snprintf_error)\n+#endif\n+{\n+  provoke_snprintf_error();\n+}\n+\n","filename":"test\/hotspot\/gtest\/utilities\/test_ostream.cpp","additions":35,"deletions":2,"binary":false,"changes":37,"status":"modified"}]}