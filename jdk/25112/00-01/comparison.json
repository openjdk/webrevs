{"files":[{"patch":"@@ -140,3 +140,3 @@\n-int ZMappedCache::size_class_index(size_t size) {\n-  \/\/ Returns the size class index of for size, or -1 if smaller than the smallest size class.\n-  const int size_class_power = log2i_graceful(size) - (int)ZGranuleSizeShift;\n+void ZMappedCache::Tree::verify() const {\n+#ifdef ASSERT\n+  \/\/ Verify\n@@ -144,3 +144,3 @@\n-  if (size_class_power < MinSizeClassShift) {\n-    \/\/ Allocation is smaller than the smallest size class minimum size.\n-    return -1;\n+  if (size() < 10) {\n+    \/\/ Only verify whole tree if the node count is low\n+    verify_self();\n@@ -149,1 +149,4 @@\n-  return MIN2(size_class_power, MaxSizeClassShift) - MinSizeClassShift;\n+  \/\/ Verify the externally tracked left most and right most nodes\n+  verify_left_most();\n+  verify_right_most();\n+#endif \/\/ ASSERT\n@@ -152,11 +155,3 @@\n-int ZMappedCache::guaranteed_size_class_index(size_t size) {\n-  \/\/ Returns the size class index of the smallest size class which can always\n-  \/\/ accommodate a size allocation, or -1 otherwise.\n-  const int size_class_power = log2i_ceil(size) - (int)ZGranuleSizeShift;\n-\n-  if (size_class_power > MaxSizeClassShift) {\n-    \/\/ Allocation is larger than the largest size class minimum size.\n-    return -1;\n-  }\n-\n-  return MAX2(size_class_power, MinSizeClassShift) - MinSizeClassShift;\n+void ZMappedCache::Tree::verify_left_most() const {\n+  assert(leftmost() == _left_most, \"must be \" PTR_FORMAT \" == \" PTR_FORMAT,\n+          p2i(leftmost()), p2i(this));\n@@ -165,2 +160,4 @@\n-void ZMappedCache::tree_insert(const Tree::Cursor& cursor, const ZVirtualMemory& vmem) {\n-  ZMappedCacheEntry* const entry = create_entry(vmem);\n+void ZMappedCache::Tree::verify_right_most() const {\n+  assert(rightmost() == _right_most, \"must be \" PTR_FORMAT \" == \" PTR_FORMAT,\n+          p2i(rightmost()), p2i(this));\n+}\n@@ -168,1 +165,4 @@\n-  TreeNode* node = entry->node_addr();\n+ZMappedCache::Tree::Tree()\n+  : TreeImpl(),\n+    _left_most(nullptr),\n+    _right_most(nullptr) {}\n@@ -170,0 +170,1 @@\n+void ZMappedCache::Tree::insert(TreeNode* node, const TreeCursor& cursor) {\n@@ -171,1 +172,1 @@\n-  _tree.insert_at_cursor(node, cursor);\n+  TreeImpl::insert_at_cursor(node, cursor);\n@@ -185,7 +186,0 @@\n-\n-  \/\/ Insert in size-class lists\n-  const size_t size = vmem.size();\n-  const int index = size_class_index(size);\n-  if (index != -1) {\n-    _size_class_lists[index].insert_first(entry->size_class_node());\n-  }\n@@ -194,4 +188,1 @@\n-void ZMappedCache::tree_remove(const Tree::Cursor& cursor, const ZVirtualMemory& vmem) {\n-  IntrusiveRBNode* const node = cursor.node();\n-  ZMappedCacheEntry* entry = ZMappedCacheEntry::cast_to_entry(node);\n-\n+void ZMappedCache::Tree::remove(TreeNode* node) {\n@@ -209,1 +200,16 @@\n-  _tree.remove_at_cursor(cursor);\n+  TreeImpl::remove(node);\n+}\n+\n+void ZMappedCache::Tree::replace(TreeNode* old_node, TreeNode* new_node, const TreeCursor& cursor) {\n+  if (_left_most == old_node) {\n+    \/\/ Keep track of left most node\n+    _left_most = new_node;\n+  }\n+\n+  if (_right_most == old_node) {\n+    \/\/ Keep track of right most node\n+    _right_most = new_node;\n+  }\n+\n+  \/\/ Replace in tree\n+  TreeImpl::replace_at_cursor(new_node, cursor);\n@@ -213,0 +219,53 @@\n+}\n+\n+const ZMappedCache::TreeNode* ZMappedCache::Tree::left_most() const {\n+  verify_left_most();\n+  return _left_most;\n+}\n+\n+ZMappedCache::TreeNode* ZMappedCache::Tree::left_most() {\n+  verify_left_most();\n+  return _left_most;\n+}\n+\n+const ZMappedCache::TreeNode* ZMappedCache::Tree::right_most() const {\n+  verify_right_most();\n+  return _right_most;\n+}\n+\n+ZMappedCache::TreeNode* ZMappedCache::Tree::right_most() {\n+  verify_right_most();\n+  return _right_most;\n+}\n+\n+int ZMappedCache::size_class_index(size_t size) {\n+  \/\/ Returns the size class index of for size, or -1 if smaller than the smallest size class.\n+  const int size_class_power = log2i_graceful(size) - (int)ZGranuleSizeShift;\n+\n+  if (size_class_power < MinSizeClassShift) {\n+    \/\/ Allocation is smaller than the smallest size class minimum size.\n+    return -1;\n+  }\n+\n+  return MIN2(size_class_power, MaxSizeClassShift) - MinSizeClassShift;\n+}\n+\n+int ZMappedCache::guaranteed_size_class_index(size_t size) {\n+  \/\/ Returns the size class index of the smallest size class which can always\n+  \/\/ accommodate a size allocation, or -1 otherwise.\n+  const int size_class_power = log2i_ceil(size) - (int)ZGranuleSizeShift;\n+\n+  if (size_class_power > MaxSizeClassShift) {\n+    \/\/ Allocation is larger than the largest size class minimum size.\n+    return -1;\n+  }\n+\n+  return MAX2(size_class_power, MinSizeClassShift) - MinSizeClassShift;\n+}\n+\n+void ZMappedCache::cache_insert(const TreeCursor& cursor, const ZVirtualMemory& vmem) {\n+  ZMappedCacheEntry* const entry = create_entry(vmem);\n+\n+  \/\/ Insert in tree\n+  TreeNode* node = entry->node_addr();\n+  _tree.insert(node, cursor);\n@@ -217,0 +276,15 @@\n+  if (index != -1) {\n+    _size_class_lists[index].insert_first(entry->size_class_node());\n+  }\n+}\n+\n+void ZMappedCache::cache_remove(const TreeCursor& cursor, const ZVirtualMemory& vmem) {\n+  TreeNode* const node = cursor.node();\n+  ZMappedCacheEntry* entry = ZMappedCacheEntry::cast_to_entry(node);\n+\n+  \/\/ Remove from tree\n+  _tree.remove(node);\n+\n+  \/\/ Remove from size-class lists\n+  const size_t size = vmem.size();\n+  const int index = size_class_index(size);\n@@ -225,1 +299,1 @@\n-void ZMappedCache::tree_replace(const Tree::Cursor& cursor, const ZVirtualMemory& vmem) {\n+void ZMappedCache::cache_replace(const TreeCursor& cursor, const ZVirtualMemory& vmem) {\n@@ -233,16 +307,0 @@\n-  if (_left_most == old_node) {\n-    \/\/ Keep track of left most node\n-    _left_most = new_node;\n-  }\n-\n-  if (_right_most == old_node) {\n-    \/\/ Keep track of right most node\n-    _right_most = new_node;\n-  }\n-\n-  \/\/ Replace in tree\n-  _tree.replace_at_cursor(new_node, cursor);\n-\n-  \/\/ Verify\n-  verify();\n-\n@@ -250,0 +308,1 @@\n+  _tree.replace(old_node, new_node, cursor);\n@@ -269,1 +328,1 @@\n-void ZMappedCache::tree_update(ZMappedCacheEntry* entry, const ZVirtualMemory& vmem) {\n+void ZMappedCache::cache_update(ZMappedCacheEntry* entry, const ZVirtualMemory& vmem) {\n@@ -297,45 +356,0 @@\n-void ZMappedCache::verify() const {\n-#ifdef ASSERT\n-  \/\/ Verify\n-\n-  if (_tree.size() < 10) {\n-    \/\/ Only verify whole tree if the node count is low\n-    _tree.verify_self();\n-  }\n-\n-  \/\/ Verify the externally tracked left most and right most nodes\n-  verify_left_most();\n-  verify_right_most();\n-#endif \/\/ ASSERT\n-}\n-\n-void ZMappedCache::verify_left_most() const {\n-  assert(_tree.leftmost() == _left_most, \"must be \" PTR_FORMAT \" == \" PTR_FORMAT,\n-         p2i(_tree.leftmost()), p2i(this));\n-}\n-\n-const ZMappedCache::TreeNode* ZMappedCache::left_most() const {\n-  verify_left_most();\n-  return _left_most;\n-}\n-\n-ZMappedCache::TreeNode* ZMappedCache::left_most() {\n-  verify_left_most();\n-  return _left_most;\n-}\n-\n-void ZMappedCache::verify_right_most() const {\n-  assert(_tree.rightmost() == _right_most, \"must be \" PTR_FORMAT \" == \" PTR_FORMAT,\n-         p2i(_tree.rightmost()), p2i(this));\n-}\n-\n-const ZMappedCache::TreeNode* ZMappedCache::right_most() const {\n-  verify_right_most();\n-  return _right_most;\n-}\n-\n-ZMappedCache::TreeNode* ZMappedCache::right_most() {\n-  verify_right_most();\n-  return _right_most;\n-}\n-\n@@ -366,1 +380,1 @@\n-      tree_update(entry, unused_vmem);\n+      cache_update(entry, unused_vmem);\n@@ -374,1 +388,1 @@\n-      auto cursor = _tree.cursor(entry->node_addr());\n+      TreeCursor cursor = _tree.cursor(entry->node_addr());\n@@ -376,1 +390,1 @@\n-      tree_replace(cursor, unused_vmem);\n+      cache_replace(cursor, unused_vmem);\n@@ -381,1 +395,1 @@\n-    auto cursor = _tree.cursor(entry->node_addr());\n+    TreeCursor cursor = _tree.cursor(entry->node_addr());\n@@ -383,1 +397,1 @@\n-    tree_remove(cursor, vmem);\n+    cache_remove(cursor, vmem);\n@@ -469,1 +483,1 @@\n-    for (ZMappedCache::TreeNode* node = right_most(); node != nullptr; node = node->prev()) {\n+    for (ZMappedCache::TreeNode* node = _tree.right_most(); node != nullptr; node = node->prev()) {\n@@ -484,1 +498,1 @@\n-    for (ZMappedCache::TreeNode* node = left_most(); node != nullptr; node = node->next()) {\n+    for (ZMappedCache::TreeNode* node = _tree.left_most(); node != nullptr; node = node->next()) {\n@@ -534,2 +548,0 @@\n-    _left_most(nullptr),\n-    _right_most(nullptr),\n@@ -543,2 +555,2 @@\n-  Tree::Cursor current_cursor = _tree.cursor(vmem.start());\n-  Tree::Cursor next_cursor = _tree.next(current_cursor);\n+  TreeCursor current_cursor = _tree.cursor(vmem.start());\n+  TreeCursor next_cursor = _tree.next(current_cursor);\n@@ -563,1 +575,1 @@\n-    tree_remove(current_cursor, left_vmem);\n+    cache_remove(current_cursor, left_vmem);\n@@ -566,1 +578,1 @@\n-    tree_update(next_entry, new_vmem);\n+    cache_update(next_entry, new_vmem);\n@@ -578,1 +590,1 @@\n-    tree_replace(current_cursor, new_vmem);\n+    cache_replace(current_cursor, new_vmem);\n@@ -593,1 +605,1 @@\n-    tree_update(next_entry, new_vmem);\n+    cache_update(next_entry, new_vmem);\n@@ -598,1 +610,1 @@\n-  tree_insert(current_cursor, vmem);\n+  cache_insert(current_cursor, vmem);\n@@ -707,1 +719,1 @@\n-  for (const ZMappedCache::TreeNode* node = left_most(); node != nullptr; node = node->next()) {\n+  for (const ZMappedCache::TreeNode* node = _tree.left_most(); node != nullptr; node = node->next()) {\n","filename":"src\/hotspot\/share\/gc\/z\/zMappedCache.cpp","additions":126,"deletions":114,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -51,1 +51,2 @@\n-  using Tree              = IntrusiveRBTree<zoffset, EntryCompare>;\n+  using TreeImpl          = IntrusiveRBTree<zoffset, EntryCompare>;\n+  using TreeCursor        = TreeImpl::Cursor;\n@@ -56,0 +57,28 @@\n+  class Tree : private TreeImpl {\n+  private:\n+    TreeNode* _left_most;\n+    TreeNode* _right_most;\n+\n+    void verify() const;\n+    void verify_left_most() const;\n+    void verify_right_most() const;\n+\n+  public:\n+    Tree();\n+\n+    void insert(TreeNode* node, const TreeCursor& cursor);\n+    void remove(TreeNode* node);\n+    void replace(TreeNode* old_node, TreeNode* new_node, const TreeCursor& cursor);\n+\n+    using TreeImpl::size;\n+\n+    using TreeImpl::cursor;\n+    using TreeImpl::next;\n+\n+    const TreeNode* left_most() const;\n+    TreeNode* left_most();\n+\n+    const TreeNode* right_most() const;\n+    TreeNode* right_most();\n+  };\n+\n@@ -63,2 +92,0 @@\n-  TreeNode*     _left_most;\n-  TreeNode*     _right_most;\n@@ -72,14 +99,4 @@\n-  void tree_insert(const Tree::Cursor& cursor, const ZVirtualMemory& vmem);\n-  void tree_remove(const Tree::Cursor& cursor, const ZVirtualMemory& vmem);\n-  void tree_replace(const Tree::Cursor& cursor, const ZVirtualMemory& vmem);\n-  void tree_update(ZMappedCacheEntry* entry, const ZVirtualMemory& vmem);\n-\n-  void verify() const;\n-\n-  void verify_left_most() const;\n-  const TreeNode* left_most() const;\n-  TreeNode* left_most();\n-\n-  void verify_right_most() const;\n-  const TreeNode* right_most() const;\n-  TreeNode* right_most();\n+  void cache_insert(const TreeCursor& cursor, const ZVirtualMemory& vmem);\n+  void cache_remove(const TreeCursor& cursor, const ZVirtualMemory& vmem);\n+  void cache_replace(const TreeCursor& cursor, const ZVirtualMemory& vmem);\n+  void cache_update(ZMappedCacheEntry* entry, const ZVirtualMemory& vmem);\n","filename":"src\/hotspot\/share\/gc\/z\/zMappedCache.hpp","additions":34,"deletions":17,"binary":false,"changes":51,"status":"modified"}]}