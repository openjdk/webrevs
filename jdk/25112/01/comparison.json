{"files":[{"patch":"@@ -1,293 +0,0 @@\n-\/*\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef SHARE_GC_Z_ZINTRUSIVERBTREE_HPP\n-#define SHARE_GC_Z_ZINTRUSIVERBTREE_HPP\n-\n-#include \"metaprogramming\/enableIf.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-enum class ZIntrusiveRBTreeDirection { LEFT, RIGHT };\n-\n-class ZIntrusiveRBTreeNode {\n-  template <typename Key, typename Compare>\n-  friend class ZIntrusiveRBTree;\n-\n-public:\n-  enum Color { RED = 0b0, BLACK = 0b1 };\n-\n-private:\n-  class ColoredNodePtr {\n-  private:\n-    static constexpr uintptr_t COLOR_MASK = 0b1;\n-    static constexpr uintptr_t NODE_MASK = ~COLOR_MASK;\n-\n-    uintptr_t _value;\n-\n-  public:\n-    ColoredNodePtr(ZIntrusiveRBTreeNode* node = nullptr, Color color = RED);\n-\n-    constexpr Color color() const;\n-    constexpr bool is_black() const;\n-    constexpr bool is_red() const;\n-\n-    ZIntrusiveRBTreeNode* node() const;\n-    ZIntrusiveRBTreeNode* red_node() const;\n-    ZIntrusiveRBTreeNode* black_node() const;\n-  };\n-\n-private:\n-  ColoredNodePtr _colored_parent;\n-  ZIntrusiveRBTreeNode* _left;\n-  ZIntrusiveRBTreeNode* _right;\n-\n-  template <ZIntrusiveRBTreeDirection DIRECTION>\n-  const ZIntrusiveRBTreeNode* find_next_node() const;\n-\n-  template <ZIntrusiveRBTreeDirection DIRECTION>\n-  const ZIntrusiveRBTreeNode* child() const;\n-  template <ZIntrusiveRBTreeDirection DIRECTION>\n-  ZIntrusiveRBTreeNode* child();\n-\n-  template <ZIntrusiveRBTreeDirection DIRECTION>\n-  ZIntrusiveRBTreeNode* const* child_addr() const;\n-\n-  template <ZIntrusiveRBTreeDirection DIRECTION>\n-  bool has_child() const;\n-\n-  template <ZIntrusiveRBTreeDirection DIRECTION>\n-  void update_child(ZIntrusiveRBTreeNode* new_child);\n-\n-  void link_node(ZIntrusiveRBTreeNode* parent, ZIntrusiveRBTreeNode** insert_location);\n-\n-  void copy_parent_and_color(ZIntrusiveRBTreeNode* other);\n-  void update_parent_and_color(ZIntrusiveRBTreeNode* parent, Color color);\n-\n-  void update_parent(ZIntrusiveRBTreeNode* parent);\n-  void update_color(Color color);\n-\n-  void update_left_child(ZIntrusiveRBTreeNode* new_child);\n-  void update_right_child(ZIntrusiveRBTreeNode* new_child);\n-\n-  const ZIntrusiveRBTreeNode* parent() const;\n-  ZIntrusiveRBTreeNode* parent();\n-  const ZIntrusiveRBTreeNode* red_parent() const;\n-  ZIntrusiveRBTreeNode* red_parent();\n-  const ZIntrusiveRBTreeNode* black_parent() const;\n-  ZIntrusiveRBTreeNode* black_parent();\n-\n-  bool has_parent() const;\n-\n-  Color color() const;\n-  bool is_black() const;\n-  bool is_red() const;\n-  static bool is_black(ZIntrusiveRBTreeNode* node);\n-\n-  ZIntrusiveRBTreeNode* const* left_child_addr() const;\n-  ZIntrusiveRBTreeNode* const* right_child_addr() const;\n-\n-  const ZIntrusiveRBTreeNode* left_child() const;\n-  ZIntrusiveRBTreeNode* left_child();\n-  const ZIntrusiveRBTreeNode* right_child() const;\n-  ZIntrusiveRBTreeNode* right_child();\n-\n-  bool has_left_child() const;\n-  bool has_right_child() const;\n-\n-public:\n-  ZIntrusiveRBTreeNode();\n-\n-  const ZIntrusiveRBTreeNode* prev() const;\n-  ZIntrusiveRBTreeNode* prev();\n-  const ZIntrusiveRBTreeNode* next() const;\n-  ZIntrusiveRBTreeNode* next();\n-};\n-\n-template <typename Key, typename Compare>\n-class ZIntrusiveRBTree {\n-public:\n-  class FindCursor {\n-    friend class ZIntrusiveRBTree<Key, Compare>;\n-\n-  private:\n-    ZIntrusiveRBTreeNode** _insert_location;\n-    ZIntrusiveRBTreeNode* _parent;\n-    bool _left_most;\n-    bool _right_most;\n-    DEBUG_ONLY(uintptr_t _sequence_number;)\n-\n-    FindCursor(ZIntrusiveRBTreeNode** insert_location, ZIntrusiveRBTreeNode* parent, bool left_most, bool right_most DEBUG_ONLY(COMMA uintptr_t sequence_number));\n-    FindCursor();\n-\n-#ifdef ASSERT\n-    bool is_valid(uintptr_t sequence_number) const;\n-#endif\n-\n-  public:\n-    FindCursor(const FindCursor&) = default;\n-    FindCursor& operator=(const FindCursor&) = default;\n-\n-    bool is_valid() const;\n-    bool found() const;\n-    ZIntrusiveRBTreeNode* node() const;\n-    bool is_left_most() const;\n-    bool is_right_most() const;\n-    ZIntrusiveRBTreeNode* parent() const;\n-    ZIntrusiveRBTreeNode** insert_location() const;\n-  };\n-\n-private:\n-  ZIntrusiveRBTreeNode* _root_node;\n-  ZIntrusiveRBTreeNode* _left_most;\n-  ZIntrusiveRBTreeNode* _right_most;\n-  DEBUG_ONLY(uintptr_t _sequence_number;)\n-\n-  NONCOPYABLE(ZIntrusiveRBTree);\n-\n-#ifdef ASSERT\n-  template <bool swap_left_right>\n-  bool verify_node(ZIntrusiveRBTreeNode* parent, ZIntrusiveRBTreeNode* left_child, ZIntrusiveRBTreeNode* right_child);\n-  template <bool swap_left_right>\n-  bool verify_node(ZIntrusiveRBTreeNode* parent);\n-  template <bool swap_left_right>\n-  bool verify_node(ZIntrusiveRBTreeNode* parent, ZIntrusiveRBTreeNode* left_child);\n-  struct any_t {};\n-  template <bool swap_left_right>\n-  bool verify_node(ZIntrusiveRBTreeNode* parent, any_t, ZIntrusiveRBTreeNode* right_child);\n-#endif \/\/ ASSERT\n-\n-  ZIntrusiveRBTreeNode* const* root_node_addr() const;\n-\n-  void update_child_or_root(ZIntrusiveRBTreeNode* old_node, ZIntrusiveRBTreeNode* new_node, ZIntrusiveRBTreeNode* parent);\n-  void rotate_and_update_child_or_root(ZIntrusiveRBTreeNode* old_node, ZIntrusiveRBTreeNode* new_node, ZIntrusiveRBTreeNode::Color color);\n-\n-  template <ZIntrusiveRBTreeDirection PARENT_SIBLING_DIRECTION>\n-  void rebalance_insert_with_sibling(ZIntrusiveRBTreeNode* node, ZIntrusiveRBTreeNode* parent, ZIntrusiveRBTreeNode* grand_parent);\n-  template <ZIntrusiveRBTreeDirection PARENT_SIBLING_DIRECTION>\n-  bool rebalance_insert_with_parent_sibling(ZIntrusiveRBTreeNode** node_addr, ZIntrusiveRBTreeNode** parent_addr, ZIntrusiveRBTreeNode* grand_parent);\n-  void rebalance_insert(ZIntrusiveRBTreeNode* new_node);\n-\n-  template <ZIntrusiveRBTreeDirection SIBLING_DIRECTION>\n-  bool rebalance_remove_with_sibling(ZIntrusiveRBTreeNode** node_addr, ZIntrusiveRBTreeNode** parent_addr);\n-  void rebalance_remove(ZIntrusiveRBTreeNode* rebalance_from);\n-\n-  FindCursor make_cursor(ZIntrusiveRBTreeNode* const* insert_location, ZIntrusiveRBTreeNode* parent, bool left_most, bool right_most) const;\n-  template <ZIntrusiveRBTreeDirection DIRECTION>\n-  FindCursor find_next(const FindCursor& cursor) const;\n-\n-public:\n-  ZIntrusiveRBTree();\n-\n-  ZIntrusiveRBTreeNode* first() const;\n-  ZIntrusiveRBTreeNode* last() const;\n-\n-  FindCursor root_cursor() const;\n-  FindCursor get_cursor(const ZIntrusiveRBTreeNode* node) const;\n-  FindCursor prev_cursor(const ZIntrusiveRBTreeNode* node) const;\n-  FindCursor next_cursor(const ZIntrusiveRBTreeNode* node) const;\n-  FindCursor prev(const FindCursor& cursor) const;\n-  FindCursor next(const FindCursor& cursor) const;\n-  FindCursor find(const Key& key) const;\n-\n-  void insert(ZIntrusiveRBTreeNode* new_node, const FindCursor& find_cursor);\n-  void replace(ZIntrusiveRBTreeNode* new_node, const FindCursor& find_cursor);\n-  void remove(const FindCursor& find_cursor);\n-\n-  void verify_tree();\n-\n-public:\n-  template <bool IsConst, bool Reverse>\n-  class IteratorImplementation;\n-\n-  using Iterator = IteratorImplementation<false, false>;\n-  using ConstIterator = IteratorImplementation<true, false>;\n-  using ReverseIterator = IteratorImplementation<false, true>;\n-  using ConstReverseIterator = IteratorImplementation<true, true>;\n-\n-  \/\/ remove and replace invalidate the iterators\n-  \/\/ however the iterators provide a remove and replace\n-  \/\/ function which does not invalidate that iterator nor\n-  \/\/ any end iterator\n-  Iterator begin();\n-  Iterator end();\n-  ConstIterator begin() const;\n-  ConstIterator end() const;\n-  ConstIterator cbegin() const;\n-  ConstIterator cend() const;\n-  ReverseIterator rbegin();\n-  ReverseIterator rend();\n-  ConstReverseIterator rbegin() const;\n-  ConstReverseIterator rend() const;\n-  ConstReverseIterator crbegin() const;\n-  ConstReverseIterator crend() const;\n-};\n-\n-template <typename Key, typename Compare>\n-template <bool IsConst, bool Reverse>\n-class ZIntrusiveRBTree<Key, Compare>::IteratorImplementation {\n-  friend IteratorImplementation<true, Reverse>;\n-\n-public:\n-  using difference_type   = std::ptrdiff_t;\n-  using value_type        = const ZIntrusiveRBTreeNode;\n-  using pointer           = value_type*;\n-  using reference         = value_type&;\n-\n-private:\n-  ZIntrusiveRBTree<Key, Compare>* _tree;\n-  const ZIntrusiveRBTreeNode* _node;\n-  bool _removed;\n-\n-  bool at_end() const;\n-\n-public:\n-  IteratorImplementation(ZIntrusiveRBTree<Key, Compare>& tree, pointer node);\n-  IteratorImplementation(const IteratorImplementation<IsConst, Reverse>&) = default;\n-  template <bool Enable = IsConst, ENABLE_IF(Enable)>\n-  IteratorImplementation(const IteratorImplementation<false, Reverse>& other);\n-\n-  reference operator*() const;\n-  pointer operator->();\n-  IteratorImplementation& operator--();\n-  IteratorImplementation operator--(int);\n-  IteratorImplementation& operator++();\n-  IteratorImplementation operator++(int);\n-\n-  template <bool Enable = !IsConst, ENABLE_IF(Enable)>\n-  void replace(ZIntrusiveRBTreeNode * new_node);\n-  template <bool Enable = !IsConst, ENABLE_IF(Enable)>\n-  void remove();\n-\n-  \/\/ Note: friend operator overloads defined inside class declaration because of problems with ADL\n-  friend bool operator==(const IteratorImplementation& a, const IteratorImplementation& b) {\n-    precond(a._tree == b._tree);\n-    return a._node == b._node;\n-  }\n-  friend bool operator!=(const IteratorImplementation& a, const IteratorImplementation& b) {\n-    precond(a._tree == b._tree);\n-    return a._node != b._node;\n-  }\n-};\n-\n-#endif \/\/ SHARE_GC_Z_ZINTRUSIVERBTREE_HPP\n","filename":"src\/hotspot\/share\/gc\/z\/zIntrusiveRBTree.hpp","additions":0,"deletions":293,"binary":false,"changes":293,"status":"deleted"},{"patch":"@@ -1,1351 +0,0 @@\n-\/*\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef SHARE_GC_Z_ZINTRUSIVERBTREE_INLINE_HPP\n-#define SHARE_GC_Z_ZINTRUSIVERBTREE_INLINE_HPP\n-\n-#include \"gc\/z\/zIntrusiveRBTree.hpp\"\n-\n-#include \"metaprogramming\/enableIf.hpp\"\n-#include \"utilities\/debug.hpp\"\n-\n-static constexpr ZIntrusiveRBTreeDirection other(const ZIntrusiveRBTreeDirection& direction) {\n-  return direction == ZIntrusiveRBTreeDirection::LEFT ? ZIntrusiveRBTreeDirection::RIGHT : ZIntrusiveRBTreeDirection::LEFT;\n-}\n-\n-inline ZIntrusiveRBTreeNode::ColoredNodePtr::ColoredNodePtr(ZIntrusiveRBTreeNode* node, Color color)\n-  : _value(reinterpret_cast<uintptr_t>(node) | color) {}\n-\n-inline constexpr ZIntrusiveRBTreeNode::Color ZIntrusiveRBTreeNode::ColoredNodePtr::color() const {\n-  return static_cast<Color>(_value & COLOR_MASK);\n-}\n-\n-inline constexpr bool ZIntrusiveRBTreeNode::ColoredNodePtr::is_black() const {\n-  return color() == BLACK;\n-}\n-\n-inline constexpr bool ZIntrusiveRBTreeNode::ColoredNodePtr::is_red() const {\n-  return color() == RED;\n-}\n-\n-inline ZIntrusiveRBTreeNode* ZIntrusiveRBTreeNode::ColoredNodePtr::node() const {\n-  return reinterpret_cast<ZIntrusiveRBTreeNode*>(_value & NODE_MASK);\n-}\n-\n-inline ZIntrusiveRBTreeNode* ZIntrusiveRBTreeNode::ColoredNodePtr::red_node() const {\n-  precond(is_red());\n-  return reinterpret_cast<ZIntrusiveRBTreeNode*>(_value);\n-}\n-inline ZIntrusiveRBTreeNode* ZIntrusiveRBTreeNode::ColoredNodePtr::black_node() const {\n-  precond(is_black());\n-  return reinterpret_cast<ZIntrusiveRBTreeNode*>(_value ^ BLACK);\n-}\n-\n-template <ZIntrusiveRBTreeDirection DIRECTION>\n-inline const ZIntrusiveRBTreeNode* ZIntrusiveRBTreeNode::find_next_node() const {\n-  constexpr ZIntrusiveRBTreeDirection OTHER_DIRECTION = other(DIRECTION);\n-  const ZIntrusiveRBTreeNode* node = this;\n-\n-  \/\/ Down the tree\n-  if (node->has_child<DIRECTION>()) {\n-    node = node->child<DIRECTION>();\n-    while (node->has_child<OTHER_DIRECTION>()) {\n-      node = node->child<OTHER_DIRECTION>();\n-    }\n-    return node;\n-  }\n-\n-  \/\/ Up the tree\n-  const ZIntrusiveRBTreeNode* parent = node->parent();\n-  while (parent != nullptr && node == parent->child<DIRECTION>()) {\n-    node = parent;\n-    parent = node->parent();\n-  }\n-  return parent;\n-}\n-\n-template <ZIntrusiveRBTreeDirection DIRECTION>\n-inline const ZIntrusiveRBTreeNode* ZIntrusiveRBTreeNode::child() const {\n-  if (DIRECTION == ZIntrusiveRBTreeDirection::LEFT) {\n-    return _left;\n-  }\n-  assert(DIRECTION == ZIntrusiveRBTreeDirection::RIGHT, \"must be\");\n-  return _right;\n-}\n-\n-template <ZIntrusiveRBTreeDirection DIRECTION>\n-inline ZIntrusiveRBTreeNode* ZIntrusiveRBTreeNode::child() {\n-  return const_cast<ZIntrusiveRBTreeNode*>(const_cast<const ZIntrusiveRBTreeNode*>(this)->template child<DIRECTION>());\n-}\n-\n-template <ZIntrusiveRBTreeDirection DIRECTION>\n-inline ZIntrusiveRBTreeNode* const* ZIntrusiveRBTreeNode::child_addr() const {\n-  if (DIRECTION == ZIntrusiveRBTreeDirection::LEFT) {\n-    return &_left;\n-  }\n-  assert(DIRECTION == ZIntrusiveRBTreeDirection::RIGHT, \"must be\");\n-  return &_right;\n-}\n-\n-template <ZIntrusiveRBTreeDirection DIRECTION>\n-inline bool ZIntrusiveRBTreeNode::has_child() const {\n-  if (DIRECTION == ZIntrusiveRBTreeDirection::LEFT) {\n-    return _left != nullptr;\n-  }\n-  assert(DIRECTION == ZIntrusiveRBTreeDirection::RIGHT, \"must be\");\n-  return _right != nullptr;\n-}\n-\n-template <ZIntrusiveRBTreeDirection DIRECTION>\n-inline void ZIntrusiveRBTreeNode::update_child(ZIntrusiveRBTreeNode* new_child) {\n-  if (DIRECTION == ZIntrusiveRBTreeDirection::LEFT) {\n-    _left = new_child;\n-    return;\n-  }\n-  assert(DIRECTION == ZIntrusiveRBTreeDirection::RIGHT, \"must be\");\n-  _right = new_child;\n-}\n-\n-inline void ZIntrusiveRBTreeNode::link_node(ZIntrusiveRBTreeNode* parent, ZIntrusiveRBTreeNode** insert_location) {\n-  \/\/ Newly linked node is always red\n-  _colored_parent = ColoredNodePtr(parent, RED);\n-  _left = nullptr;\n-  _right = nullptr;\n-\n-  \/\/ Link into location\n-  *insert_location = this;\n-}\n-\n-inline void ZIntrusiveRBTreeNode::copy_parent_and_color(ZIntrusiveRBTreeNode* other) {\n-  _colored_parent = other->_colored_parent;\n-}\n-\n-inline void ZIntrusiveRBTreeNode::update_parent_and_color(ZIntrusiveRBTreeNode* parent, Color color) {\n-  _colored_parent = ColoredNodePtr(parent, color);\n-}\n-\n-inline void ZIntrusiveRBTreeNode::update_parent(ZIntrusiveRBTreeNode* parent) {\n-  _colored_parent = ColoredNodePtr(parent, color());\n-}\n-\n-inline void ZIntrusiveRBTreeNode::update_color(Color color) {\n-  _colored_parent = ColoredNodePtr(parent(), color);\n-}\n-\n-inline void ZIntrusiveRBTreeNode::update_left_child(ZIntrusiveRBTreeNode* new_child) {\n-  update_child<ZIntrusiveRBTreeDirection::LEFT>(new_child);\n-}\n-\n-inline void ZIntrusiveRBTreeNode::update_right_child(ZIntrusiveRBTreeNode* new_child) {\n-  update_child<ZIntrusiveRBTreeDirection::RIGHT>(new_child);\n-}\n-\n-inline const ZIntrusiveRBTreeNode* ZIntrusiveRBTreeNode::parent() const {\n-  return _colored_parent.node();\n-}\n-\n-inline ZIntrusiveRBTreeNode* ZIntrusiveRBTreeNode::parent() {\n-  return const_cast<ZIntrusiveRBTreeNode*>(const_cast<const ZIntrusiveRBTreeNode*>(this)->parent());\n-}\n-\n-inline const ZIntrusiveRBTreeNode* ZIntrusiveRBTreeNode::red_parent() const {\n-  return _colored_parent.red_node();\n-}\n-inline ZIntrusiveRBTreeNode* ZIntrusiveRBTreeNode::red_parent() {\n-  return const_cast<ZIntrusiveRBTreeNode*>(const_cast<const ZIntrusiveRBTreeNode*>(this)->red_parent());\n-}\n-\n-inline const ZIntrusiveRBTreeNode* ZIntrusiveRBTreeNode::black_parent() const {\n-  return _colored_parent.black_node();\n-}\n-inline ZIntrusiveRBTreeNode* ZIntrusiveRBTreeNode::black_parent() {\n-  return const_cast<ZIntrusiveRBTreeNode*>(const_cast<const ZIntrusiveRBTreeNode*>(this)->black_parent());\n-}\n-\n-inline bool ZIntrusiveRBTreeNode::has_parent() const {\n-  return _colored_parent.node() != nullptr;\n-}\n-\n-inline ZIntrusiveRBTreeNode::Color ZIntrusiveRBTreeNode::color() const {\n-  return _colored_parent.color();\n-}\n-\n-inline bool ZIntrusiveRBTreeNode::is_black() const {\n-  return _colored_parent.is_black();\n-}\n-\n-inline bool ZIntrusiveRBTreeNode::is_red() const {\n-  return _colored_parent.is_red();\n-}\n-\n-inline bool ZIntrusiveRBTreeNode::is_black(ZIntrusiveRBTreeNode* node) {\n-  return node == nullptr || node->is_black();\n-}\n-\n-inline ZIntrusiveRBTreeNode* const* ZIntrusiveRBTreeNode::left_child_addr() const {\n-  return child_addr<ZIntrusiveRBTreeDirection::LEFT>();\n-}\n-\n-inline ZIntrusiveRBTreeNode* const* ZIntrusiveRBTreeNode::right_child_addr() const {\n-  return child_addr<ZIntrusiveRBTreeDirection::RIGHT>();\n-}\n-\n-inline const ZIntrusiveRBTreeNode* ZIntrusiveRBTreeNode::left_child() const {\n-  return child<ZIntrusiveRBTreeDirection::LEFT>();\n-}\n-\n-inline ZIntrusiveRBTreeNode* ZIntrusiveRBTreeNode::left_child() {\n-  return const_cast<ZIntrusiveRBTreeNode*>(const_cast<const ZIntrusiveRBTreeNode*>(this)->left_child());\n-}\n-\n-inline const ZIntrusiveRBTreeNode* ZIntrusiveRBTreeNode::right_child() const {\n-  return child<ZIntrusiveRBTreeDirection::RIGHT>();\n-}\n-\n-inline ZIntrusiveRBTreeNode* ZIntrusiveRBTreeNode::right_child() {\n-  return const_cast<ZIntrusiveRBTreeNode*>(const_cast<const ZIntrusiveRBTreeNode*>(this)->right_child());\n-}\n-\n-inline bool ZIntrusiveRBTreeNode::has_left_child() const {\n-  return has_child<ZIntrusiveRBTreeDirection::LEFT>();\n-}\n-\n-inline bool ZIntrusiveRBTreeNode::has_right_child() const {\n-  return has_child<ZIntrusiveRBTreeDirection::RIGHT>();\n-}\n-\n-inline ZIntrusiveRBTreeNode::ZIntrusiveRBTreeNode() {}\n-\n-inline const ZIntrusiveRBTreeNode* ZIntrusiveRBTreeNode::prev() const {\n-  return find_next_node<ZIntrusiveRBTreeDirection::LEFT>();\n-}\n-\n-inline ZIntrusiveRBTreeNode* ZIntrusiveRBTreeNode::prev() {\n-  return const_cast<ZIntrusiveRBTreeNode*>(const_cast<const ZIntrusiveRBTreeNode*>(this)->prev());\n-}\n-\n-inline const ZIntrusiveRBTreeNode* ZIntrusiveRBTreeNode::next() const {\n-  return find_next_node<ZIntrusiveRBTreeDirection::RIGHT>();\n-}\n-\n-inline ZIntrusiveRBTreeNode* ZIntrusiveRBTreeNode::next() {\n-  return const_cast<ZIntrusiveRBTreeNode*>(const_cast<const ZIntrusiveRBTreeNode*>(this)->next());\n-}\n-\n-#ifdef ASSERT\n-template <typename Key, typename Compare>\n-template <bool swap_left_right>\n-inline bool ZIntrusiveRBTree<Key, Compare>::verify_node(ZIntrusiveRBTreeNode* parent, ZIntrusiveRBTreeNode* left_child, ZIntrusiveRBTreeNode* right_child) {\n-  if (swap_left_right) {\n-    ::swap(left_child, right_child);\n-  }\n-  assert(parent->left_child() == left_child, swap_left_right ? \"Bad child Swapped\" : \"Bad child\");\n-  assert(parent->right_child() == right_child, swap_left_right ? \"Bad child Swapped\" : \"Bad child\");\n-  if (left_child != nullptr) {\n-    assert(left_child->parent() == parent, swap_left_right ? \"Bad parent Swapped\" : \"Bad parent\");\n-  }\n-  if (right_child != nullptr) {\n-    assert(right_child->parent() == parent, swap_left_right ? \"Bad parent Swapped\" : \"Bad parent\");\n-  }\n-  return true;\n-}\n-\n-template <typename Key, typename Compare>\n-template <bool swap_left_right>\n-inline bool ZIntrusiveRBTree<Key, Compare>::verify_node(ZIntrusiveRBTreeNode* parent) {\n-  if (parent == nullptr) {\n-    return true;\n-  }\n-  if (swap_left_right) {\n-    return verify_node<swap_left_right>(parent, parent->right_child());\n-  }\n-  return verify_node<swap_left_right>(parent, parent->left_child());\n-}\n-\n-template <typename Key, typename Compare>\n-template <bool swap_left_right>\n-inline bool ZIntrusiveRBTree<Key, Compare>::verify_node(ZIntrusiveRBTreeNode* parent, ZIntrusiveRBTreeNode* left_child) {\n-  if (swap_left_right) {\n-    return verify_node<swap_left_right>(parent, left_child, parent->left_child());\n-  }\n-  return verify_node<swap_left_right>(parent, left_child, parent->right_child());\n-}\n-\n-template <typename Key, typename Compare>\n-template <bool swap_left_right>\n-inline bool ZIntrusiveRBTree<Key, Compare>::verify_node(ZIntrusiveRBTreeNode* parent, any_t, ZIntrusiveRBTreeNode* right_child) {\n-  if (swap_left_right) {\n-    return verify_node<swap_left_right>(parent, parent->right_child(), right_child);\n-  }\n-  return verify_node<swap_left_right>(parent, parent->left_child(), right_child);\n-}\n-#endif \/\/ ASSERT\n-\n-template <typename Key, typename Compare>\n-inline ZIntrusiveRBTreeNode* const* ZIntrusiveRBTree<Key, Compare>::root_node_addr() const {\n-  return &_root_node;\n-}\n-\n-template <typename Key, typename Compare>\n-void ZIntrusiveRBTree<Key, Compare>::update_child_or_root(ZIntrusiveRBTreeNode* old_node, ZIntrusiveRBTreeNode* new_node, ZIntrusiveRBTreeNode* parent) {\n-  if (parent == nullptr) {\n-    \/\/ Update root\n-    _root_node = new_node;\n-    return;\n-  }\n-  if (old_node == parent->left_child()) {\n-    parent->update_left_child(new_node);\n-    return;\n-  }\n-  assert(old_node == parent->right_child(), \"must be\");\n-  parent->update_right_child(new_node);\n-}\n-\n-template <typename Key, typename Compare>\n-inline void ZIntrusiveRBTree<Key, Compare>::rotate_and_update_child_or_root(ZIntrusiveRBTreeNode* old_node, ZIntrusiveRBTreeNode* new_node, ZIntrusiveRBTreeNode::Color color) {\n-  ZIntrusiveRBTreeNode* const parent = old_node->parent();\n-  new_node->copy_parent_and_color(old_node);\n-  old_node->update_parent_and_color(new_node, color);\n-  update_child_or_root(old_node, new_node, parent);\n-}\n-\n-template <typename Key, typename Compare>\n-template <ZIntrusiveRBTreeDirection PARENT_SIBLING_DIRECTION>\n-inline void ZIntrusiveRBTree<Key, Compare>::rebalance_insert_with_sibling(ZIntrusiveRBTreeNode* node, ZIntrusiveRBTreeNode* parent, ZIntrusiveRBTreeNode* grand_parent) {\n-  DEBUG_ONLY(const bool swap_left_right = PARENT_SIBLING_DIRECTION == ZIntrusiveRBTreeDirection::LEFT;)\n-  constexpr ZIntrusiveRBTreeDirection OTHER_DIRECTION = other(PARENT_SIBLING_DIRECTION);\n-  ZIntrusiveRBTreeNode* sibling = parent->template child<PARENT_SIBLING_DIRECTION>();\n-  DEBUG_ONLY(bool rotated_parent = false;)\n-  if (node == sibling) {\n-    DEBUG_ONLY(rotated_parent = true;)\n-    \/\/ Rotate up node through parent\n-    ZIntrusiveRBTreeNode* child = node->template child<OTHER_DIRECTION>();\n-\n-    \/\/\/\/ PRE\n-    \/\/\n-    \/\/      G          G\n-    \/\/     \/            \\\n-    \/\/    p      or      p\n-    \/\/     \\            \/\n-    \/\/      n          n\n-    \/\/     \/            \\\n-    \/\/   (c)            (c)\n-    \/\/\n-    \/\/\/\/\n-    precond(grand_parent->is_black());\n-    precond(parent->is_red());\n-    precond(node->is_red());\n-    precond(verify_node<swap_left_right>(grand_parent, parent));\n-    precond(verify_node<swap_left_right>(parent, any_t{}, node));\n-    precond(verify_node<swap_left_right>(node, child));\n-    precond(verify_node<swap_left_right>(child));\n-\n-    \/\/ Fix children\n-    parent->template update_child<PARENT_SIBLING_DIRECTION>(child);\n-    node->template update_child<OTHER_DIRECTION>(parent);\n-\n-    \/\/ Fix parents and colors\n-    if (child != nullptr) {\n-      child->update_parent_and_color(parent, ZIntrusiveRBTreeNode::BLACK);\n-    }\n-    parent->update_parent_and_color(node, ZIntrusiveRBTreeNode::RED);\n-\n-    \/\/\/\/ POST\n-    \/\/\n-    \/\/        G          G\n-    \/\/       \/            \\\n-    \/\/      n      or      n\n-    \/\/     \/                \\\n-    \/\/    p                  p\n-    \/\/     \\                \/\n-    \/\/     (C)            (C)\n-    \/\/\n-    \/\/\/\/\n-    postcond(grand_parent->is_black());\n-    postcond(parent->is_red());\n-    postcond(node->is_red());\n-    postcond(ZIntrusiveRBTreeNode::is_black(child));\n-    \/\/ The grand_parent is updated in the next rotation\n-    \/\/ postcond(verify_node<swap_left_right>(grand_parent, node));\n-    postcond(verify_node<swap_left_right>(node, parent));\n-    postcond(verify_node<swap_left_right>(parent, any_t{}, child));\n-    postcond(verify_node<swap_left_right>(child));\n-\n-    parent = node;\n-    sibling = parent->template child<PARENT_SIBLING_DIRECTION>();\n-    DEBUG_ONLY(node = parent->template child<OTHER_DIRECTION>();)\n-  }\n-\n-  \/\/\/\/ PRE\n-  \/\/\n-  \/\/        G        G\n-  \/\/       \/          \\\n-  \/\/      p     or     p\n-  \/\/     \/ \\          \/ \\\n-  \/\/    n  (s)      (s)  n\n-  \/\/\n-  \/\/\/\/\n-  precond(grand_parent->is_black());\n-  precond(parent->is_red());\n-  precond(node->is_red());\n-  precond(rotated_parent || verify_node<swap_left_right>(grand_parent, parent));\n-  precond(verify_node<swap_left_right>(parent, node, sibling));\n-  precond(verify_node<swap_left_right>(node));\n-  precond(verify_node<swap_left_right>(sibling));\n-\n-  \/\/ Rotate up parent through grand-parent\n-\n-  \/\/ Fix children\n-  grand_parent->template update_child<OTHER_DIRECTION>(sibling);\n-  parent->template update_child<PARENT_SIBLING_DIRECTION>(grand_parent);\n-\n-  \/\/ Fix parents and colors\n-  if (sibling != nullptr) {\n-    sibling->update_parent_and_color(grand_parent, ZIntrusiveRBTreeNode::BLACK);\n-  }\n-  rotate_and_update_child_or_root(grand_parent, parent, ZIntrusiveRBTreeNode::RED);\n-\n-  \/\/\/\/ POST\n-  \/\/\n-  \/\/      P          P\n-  \/\/     \/ \\        \/ \\\n-  \/\/    n   g  or  g   n\n-  \/\/       \/        \\\n-  \/\/     (S)        (S)\n-  \/\/\n-  \/\/\/\/\n-  postcond(parent->is_black());\n-  postcond(grand_parent->is_red());\n-  postcond(node->is_red());\n-  postcond(ZIntrusiveRBTreeNode::is_black(sibling));\n-  postcond(verify_node<swap_left_right>(parent, node, grand_parent));\n-  postcond(verify_node<swap_left_right>(node));\n-  postcond(verify_node<swap_left_right>(grand_parent, sibling));\n-  postcond(verify_node<swap_left_right>(sibling));\n-}\n-\n-template <typename Key, typename Compare>\n-template <ZIntrusiveRBTreeDirection PARENT_SIBLING_DIRECTION>\n-inline bool ZIntrusiveRBTree<Key, Compare>::rebalance_insert_with_parent_sibling(ZIntrusiveRBTreeNode** node_addr, ZIntrusiveRBTreeNode** parent_addr, ZIntrusiveRBTreeNode* grand_parent) {\n-  DEBUG_ONLY(const bool swap_left_right = PARENT_SIBLING_DIRECTION == ZIntrusiveRBTreeDirection::LEFT;)\n-  constexpr ZIntrusiveRBTreeDirection OTHER_DIRECTION = other(PARENT_SIBLING_DIRECTION);\n-  ZIntrusiveRBTreeNode* const parent_sibling = grand_parent->template child<PARENT_SIBLING_DIRECTION>();\n-  ZIntrusiveRBTreeNode*& node = *node_addr;\n-  ZIntrusiveRBTreeNode*& parent = *parent_addr;\n-  if (parent_sibling != nullptr && parent_sibling->is_red()) {\n-    \/\/\/\/ PRE\n-    \/\/\n-    \/\/       G          G\n-    \/\/      \/ \\        \/ \\\n-    \/\/     p   u  or  u   p\n-    \/\/    \/ \\            \/ \\\n-    \/\/   n | n          n | n\n-    \/\/\n-    \/\/\/\/\n-    precond(grand_parent->is_black());\n-    precond(parent_sibling->is_red());\n-    precond(parent->is_red());\n-    precond(node->is_red());\n-    precond(verify_node<swap_left_right>(grand_parent, parent, parent_sibling));\n-    precond(parent->left_child() == node || parent->right_child() == node);\n-    precond(verify_node<swap_left_right>(parent));\n-    precond(verify_node<swap_left_right>(parent_sibling));\n-    precond(verify_node<swap_left_right>(node));\n-\n-    \/\/ Flip colors of parent, parent sibling and grand parent\n-    parent_sibling->update_parent_and_color(grand_parent, ZIntrusiveRBTreeNode::BLACK);\n-    parent->update_parent_and_color(grand_parent, ZIntrusiveRBTreeNode::BLACK);\n-    ZIntrusiveRBTreeNode* grand_grand_parent = grand_parent->black_parent();\n-    grand_parent->update_parent_and_color(grand_grand_parent, ZIntrusiveRBTreeNode::RED);\n-\n-    \/\/\/\/ POST\n-    \/\/\n-    \/\/       g          g\n-    \/\/      \/ \\        \/ \\\n-    \/\/     P   U  or  U   P\n-    \/\/    \/ \\            \/ \\\n-    \/\/   n | n          n | n\n-    \/\/\n-    \/\/\/\/\n-    postcond(grand_parent->is_red());\n-    postcond(parent_sibling->is_black());\n-    postcond(parent->is_black());\n-    postcond(node->is_red());\n-    postcond(verify_node<swap_left_right>(grand_parent, parent, parent_sibling));\n-    postcond(parent->left_child() == node || parent->right_child() == node);\n-    postcond(verify_node<swap_left_right>(parent));\n-    postcond(verify_node<swap_left_right>(parent_sibling));\n-    postcond(verify_node<swap_left_right>(node));\n-\n-    \/\/ Recurse up the tree\n-    node = grand_parent;\n-    parent = grand_grand_parent;\n-    return false; \/\/ Not finished\n-  }\n-\n-  rebalance_insert_with_sibling<PARENT_SIBLING_DIRECTION>(node, parent, grand_parent);\n-  return true; \/\/ Finished\n-}\n-\n-template <typename Key, typename Compare>\n-inline void ZIntrusiveRBTree<Key, Compare>::rebalance_insert(ZIntrusiveRBTreeNode* new_node) {\n-  ZIntrusiveRBTreeNode* node = new_node;\n-  ZIntrusiveRBTreeNode* parent = node->red_parent();\n-  for (;;) {\n-    precond(node->is_red());\n-    if (parent == nullptr) {\n-      \/\/ Recursive (or root) case\n-      node->update_parent_and_color(parent, ZIntrusiveRBTreeNode::BLACK);\n-      break;\n-    }\n-    if (parent->is_black()) {\n-      \/\/ Tree is balanced\n-      break;\n-    }\n-    ZIntrusiveRBTreeNode* grand_parent = parent->red_parent();\n-    if (parent == grand_parent->left_child() ? rebalance_insert_with_parent_sibling<ZIntrusiveRBTreeDirection::RIGHT>(&node, &parent, grand_parent)\n-                                            : rebalance_insert_with_parent_sibling<ZIntrusiveRBTreeDirection::LEFT>(&node, &parent, grand_parent)) {\n-      break;\n-    }\n-  }\n-}\n-\n-template <typename Key, typename Compare>\n-template <ZIntrusiveRBTreeDirection SIBLING_DIRECTION>\n-inline bool ZIntrusiveRBTree<Key, Compare>::rebalance_remove_with_sibling(ZIntrusiveRBTreeNode** node_addr, ZIntrusiveRBTreeNode** parent_addr) {\n-  DEBUG_ONLY(const bool swap_left_right = SIBLING_DIRECTION == ZIntrusiveRBTreeDirection::LEFT;)\n-  constexpr ZIntrusiveRBTreeDirection OTHER_DIRECTION = other(SIBLING_DIRECTION);\n-  ZIntrusiveRBTreeNode*& node = *node_addr;\n-  ZIntrusiveRBTreeNode*& parent = *parent_addr;\n-  ZIntrusiveRBTreeNode* sibling = parent->template child<SIBLING_DIRECTION>();\n-  if (sibling->is_red()) {\n-    ZIntrusiveRBTreeNode* sibling_child = sibling->template child<OTHER_DIRECTION>();\n-    \/\/\/\/ PRE\n-    \/\/\n-    \/\/     P          P\n-    \/\/    \/ \\        \/ \\\n-    \/\/   N   s  or  s   N\n-    \/\/      \/        \\\n-    \/\/     SC        SC\n-    \/\/\n-    \/\/\/\/\n-    precond(parent->is_black());\n-    precond(ZIntrusiveRBTreeNode::is_black(node));\n-    precond(sibling->is_red());\n-    precond(ZIntrusiveRBTreeNode::is_black(sibling_child));\n-    precond(verify_node<swap_left_right>(parent, node, sibling));\n-    precond(verify_node<swap_left_right>(node));\n-    precond(verify_node<swap_left_right>(sibling, sibling_child));\n-    precond(verify_node<swap_left_right>(sibling_child));\n-\n-    \/\/ Rotate sibling up through parent\n-\n-    \/\/ Fix children\n-    parent->template update_child<SIBLING_DIRECTION>(sibling_child);\n-    sibling->template update_child<OTHER_DIRECTION>(parent);\n-\n-    \/\/ Fix parents and colors\n-    sibling_child->update_parent_and_color(parent, ZIntrusiveRBTreeNode::BLACK);\n-    rotate_and_update_child_or_root(parent, sibling, ZIntrusiveRBTreeNode::RED);\n-\n-    \/\/\/\/ POST\n-    \/\/\n-    \/\/       S         S\n-    \/\/      \/           \\\n-    \/\/     p             p\n-    \/\/    \/ \\           \/ \\\n-    \/\/   N   SC        SC  N\n-    \/\/\n-    \/\/\/\/\n-    postcond(sibling->is_black());\n-    postcond(parent->is_red());\n-    postcond(ZIntrusiveRBTreeNode::is_black(node));\n-    postcond(ZIntrusiveRBTreeNode::is_black(sibling_child));\n-    postcond(verify_node<swap_left_right>(sibling, parent));\n-    postcond(verify_node<swap_left_right>(parent, node, sibling_child));\n-    postcond(verify_node<swap_left_right>(node));\n-    postcond(verify_node<swap_left_right>(sibling_child));\n-\n-    \/\/ node has a new sibling\n-    sibling = sibling_child;\n-  }\n-\n-  ZIntrusiveRBTreeNode* sibling_child = sibling->template child<SIBLING_DIRECTION>();\n-  DEBUG_ONLY(bool rotated_parent = false;)\n-  if (ZIntrusiveRBTreeNode::is_black(sibling_child)) {\n-    DEBUG_ONLY(rotated_parent = true;)\n-    ZIntrusiveRBTreeNode* sibling_other_child = sibling->template child<OTHER_DIRECTION>();\n-    if (ZIntrusiveRBTreeNode::is_black(sibling_other_child)) {\n-      \/\/\/\/ PRE\n-      \/\/\n-      \/\/    (p)        (p)\n-      \/\/    \/ \\        \/ \\\n-      \/\/   N   S  or  S   N\n-      \/\/\n-      \/\/\/\/\n-      precond(ZIntrusiveRBTreeNode::is_black(node));\n-      precond(sibling->is_black());\n-      precond(verify_node<swap_left_right>(parent, node, sibling));\n-\n-      \/\/ Flip sibling color to RED\n-      sibling->update_parent_and_color(parent, ZIntrusiveRBTreeNode::RED);\n-\n-      \/\/\/\/ POST\n-      \/\/\n-      \/\/    (p)        (p)\n-      \/\/    \/ \\        \/ \\\n-      \/\/   N   s  or  s   N\n-      \/\/\n-      \/\/\/\/\n-      postcond(ZIntrusiveRBTreeNode::is_black(node));\n-      postcond(sibling->is_red());\n-      postcond(verify_node<swap_left_right>(parent, node, sibling));\n-\n-      if (parent->is_black()) {\n-        \/\/ We did not introduce a RED-RED edge, if parent is\n-        \/\/ the root we are done, else recurse up the tree\n-        if (parent->parent() != nullptr) {\n-          node = parent;\n-          parent = node->parent();\n-          return false;\n-        }\n-        return true;\n-      }\n-      \/\/ Change RED-RED edge to BLACK-RED edge\n-      parent->update_color(ZIntrusiveRBTreeNode::BLACK);\n-      return true;\n-    }\n-\n-    ZIntrusiveRBTreeNode* sibling_grand_child = sibling_other_child->template child<SIBLING_DIRECTION>();\n-    \/\/\/\/ PRE\n-    \/\/\n-    \/\/    (p)          (p)\n-    \/\/    \/ \\          \/ \\\n-    \/\/   N   S        S   N\n-    \/\/      \/     or   \\\n-    \/\/    soc          soc\n-    \/\/      \\          \/\n-    \/\/     (sgc)     (sgc)\n-    \/\/\n-    \/\/\/\/\n-    precond(ZIntrusiveRBTreeNode::is_black(node));\n-    precond(sibling->is_black());\n-    precond(sibling_other_child->is_red());\n-    precond(verify_node<swap_left_right>(parent, node, sibling));\n-    precond(verify_node<swap_left_right>(node));\n-    precond(verify_node<swap_left_right>(sibling, sibling_other_child, sibling_child));\n-    precond(verify_node<swap_left_right>(sibling_other_child, any_t{}, sibling_grand_child));\n-    precond(verify_node<swap_left_right>(sibling_grand_child));\n-\n-    \/\/ Rotate sibling other child through the sibling\n-\n-    \/\/ Fix children\n-    sibling->template update_child<OTHER_DIRECTION>(sibling_grand_child);\n-    sibling_other_child->template update_child<SIBLING_DIRECTION>(sibling);\n-    parent->template update_child<SIBLING_DIRECTION>(sibling_other_child);\n-\n-    \/\/ Fix parents and colors\n-    if (sibling_grand_child != nullptr) {\n-      sibling_grand_child->update_parent_and_color(sibling, ZIntrusiveRBTreeNode::BLACK);\n-    }\n-    \/\/ Defer updating the sibling and sibling other child parents until\n-    \/\/ after we rotate below. This will also fix the any potential RED-RED\n-    \/\/ edge between parent and sibling_other_child\n-\n-    \/\/\/\/ POST\n-    \/\/\n-    \/\/    (p)            (p)\n-    \/\/    \/ \\            \/ \\\n-    \/\/   N  soc   or   soc  N\n-    \/\/      \/ \\        \/ \\\n-    \/\/    SGC  S      S  SGC\n-    \/\/\n-    \/\/\/\/\n-    postcond(ZIntrusiveRBTreeNode::is_black(node));\n-    postcond(sibling->is_black());\n-    postcond(sibling_other_child->is_red());\n-    postcond(ZIntrusiveRBTreeNode::is_black(sibling_grand_child));\n-    \/\/ Deferred\n-    \/\/ postcond(verify_node<swap_left_right>(parent, node, sibling_other_child));\n-    postcond(verify_node<swap_left_right>(node));\n-    \/\/ postcond(verify_node<swap_left_right>(sibling_other_child, sibling_grand_child, sibling));\n-    postcond(verify_node<swap_left_right>(sibling_grand_child));\n-    postcond(verify_node<swap_left_right>(sibling));\n-\n-    \/\/ node has a new sibling\n-    sibling_child = sibling;\n-    sibling = sibling_other_child;\n-  }\n-\n-  ZIntrusiveRBTreeNode* sibling_other_child = sibling->template child<OTHER_DIRECTION>();\n-  \/\/\/\/ PRE\n-  \/\/\n-  \/\/    (p)              (p)\n-  \/\/    \/ \\              \/ \\\n-  \/\/   N   S     or     S   N\n-  \/\/      \/ \\          \/ \\\n-  \/\/   (soc)(sc)    (sc)(soc)\n-  \/\/\n-  \/\/\/\/\n-  DEBUG_ONLY(ZIntrusiveRBTreeNode::Color parent_color = parent->color();)\n-  precond(ZIntrusiveRBTreeNode::is_black(node));\n-  precond(rotated_parent || sibling->is_black());\n-  DEBUG_ONLY(bool sibling_other_child_is_black = ZIntrusiveRBTreeNode::is_black(sibling_other_child);)\n-  precond(rotated_parent || verify_node<swap_left_right>(parent, node, sibling));\n-  precond(verify_node<swap_left_right>(node));\n-  precond(rotated_parent || verify_node<swap_left_right>(sibling, sibling_other_child, sibling_child));\n-  postcond(verify_node<swap_left_right>(sibling_other_child));\n-  postcond(verify_node<swap_left_right>(sibling_child));\n-\n-  \/\/ Rotate sibling through parent and fix colors\n-\n-  \/\/ Fix children\n-  parent->template update_child<SIBLING_DIRECTION>(sibling_other_child);\n-  sibling->template update_child<OTHER_DIRECTION>(parent);\n-\n-  \/\/ Fix parents and colors\n-  sibling_child->update_parent_and_color(sibling, ZIntrusiveRBTreeNode::BLACK);\n-  if (sibling_other_child != nullptr) {\n-    sibling_other_child->update_parent(parent);\n-  }\n-  rotate_and_update_child_or_root(parent, sibling, ZIntrusiveRBTreeNode::BLACK);\n-\n-  \/\/\/\/ POST\n-  \/\/\n-  \/\/      (s)           (s)\n-  \/\/      \/ \\           \/ \\\n-  \/\/     P   SC  or    SC  P\n-  \/\/    \/ \\               \/ \\\n-  \/\/   N (soc)         (soc) N\n-  \/\/\n-  \/\/\/\/\n-  postcond(sibling->color() == parent_color);\n-  postcond(parent->is_black());\n-  postcond(sibling_child->is_black());\n-  postcond(ZIntrusiveRBTreeNode::is_black(node));\n-  postcond(sibling_other_child_is_black == ZIntrusiveRBTreeNode::is_black(sibling_other_child));\n-  postcond(verify_node<swap_left_right>(sibling, parent, sibling_child));\n-  postcond(verify_node<swap_left_right>(parent, node, sibling_other_child));\n-  postcond(verify_node<swap_left_right>(sibling_child));\n-  postcond(verify_node<swap_left_right>(node));\n-  postcond(verify_node<swap_left_right>(sibling_other_child));\n-  return true;\n-}\n-\n-template <typename Key, typename Compare>\n-inline void ZIntrusiveRBTree<Key, Compare>::rebalance_remove(ZIntrusiveRBTreeNode* rebalance_from) {\n-  ZIntrusiveRBTreeNode* node = nullptr;\n-  ZIntrusiveRBTreeNode* parent = rebalance_from;\n-\n-  for (;;) {\n-    precond(ZIntrusiveRBTreeNode::is_black(node));\n-    precond(parent != nullptr);\n-    if (node == parent->left_child() ? rebalance_remove_with_sibling<ZIntrusiveRBTreeDirection::RIGHT>(&node, &parent)\n-                                    : rebalance_remove_with_sibling<ZIntrusiveRBTreeDirection::LEFT>(&node, &parent)) {\n-      break;\n-    }\n-  }\n-}\n-\n-template <typename Key, typename Compare>\n-inline ZIntrusiveRBTree<Key, Compare>::FindCursor::FindCursor(ZIntrusiveRBTreeNode** insert_location, ZIntrusiveRBTreeNode* parent, bool left_most, bool right_most DEBUG_ONLY(COMMA uintptr_t sequence_number))\n-  : _insert_location(insert_location),\n-    _parent(parent),\n-    _left_most(left_most),\n-    _right_most(right_most)\n-    DEBUG_ONLY(COMMA _sequence_number(sequence_number)) {}\n-\n-template <typename Key, typename Compare>\n-inline ZIntrusiveRBTree<Key, Compare>::FindCursor::FindCursor()\n-  : _insert_location(nullptr),\n-    _parent(nullptr),\n-    _left_most(),\n-    _right_most()\n-    DEBUG_ONLY(COMMA _sequence_number()) {}\n-\n-#ifdef ASSERT\n-template <typename Key, typename Compare>\n-inline bool ZIntrusiveRBTree<Key, Compare>::FindCursor::is_valid(uintptr_t sequence_number) const {\n-  return is_valid() && _sequence_number == sequence_number;\n-}\n-#endif \/\/ ASSERT\n-\n-template <typename Key, typename Compare>\n-inline bool ZIntrusiveRBTree<Key, Compare>::FindCursor::is_valid() const {\n-  return insert_location() != nullptr;\n-}\n-\n-template <typename Key, typename Compare>\n-inline bool ZIntrusiveRBTree<Key, Compare>::FindCursor::found() const {\n-  return node() != nullptr;\n-}\n-\n-template <typename Key, typename Compare>\n-inline ZIntrusiveRBTreeNode* ZIntrusiveRBTree<Key, Compare>::FindCursor::node() const {\n-  precond(is_valid());\n-  return *_insert_location == nullptr ? nullptr : *_insert_location;\n-}\n-\n-template <typename Key, typename Compare>\n-inline bool ZIntrusiveRBTree<Key, Compare>::FindCursor::is_left_most() const {\n-  precond(is_valid());\n-  return _left_most;\n-}\n-\n-template <typename Key, typename Compare>\n-inline bool ZIntrusiveRBTree<Key, Compare>::FindCursor::is_right_most() const {\n-  precond(is_valid());\n-  return _right_most;\n-}\n-\n-template <typename Key, typename Compare>\n-inline ZIntrusiveRBTreeNode* ZIntrusiveRBTree<Key, Compare>::FindCursor::parent() const {\n-  precond(is_valid());\n-  return _parent;\n-}\n-\n-template <typename Key, typename Compare>\n-inline ZIntrusiveRBTreeNode** ZIntrusiveRBTree<Key, Compare>::FindCursor::insert_location() const {\n-  return _insert_location;\n-}\n-\n-template <typename Key, typename Compare>\n-inline typename ZIntrusiveRBTree<Key, Compare>::FindCursor ZIntrusiveRBTree<Key, Compare>::make_cursor(ZIntrusiveRBTreeNode* const* insert_location, ZIntrusiveRBTreeNode* parent, bool left_most, bool right_most) const {\n-  return FindCursor(const_cast<ZIntrusiveRBTreeNode**>(insert_location), parent, left_most, right_most DEBUG_ONLY(COMMA _sequence_number));\n-}\n-\n-template <typename Key, typename Compare>\n-template <ZIntrusiveRBTreeDirection DIRECTION>\n-inline typename ZIntrusiveRBTree<Key, Compare>::FindCursor ZIntrusiveRBTree<Key, Compare>::find_next(const FindCursor& cursor) const {\n-  constexpr ZIntrusiveRBTreeDirection OTHER_DIRECTION = other(DIRECTION);\n-  if (cursor.found()) {\n-    ZIntrusiveRBTreeNode* const node = cursor.node();\n-    const ZIntrusiveRBTreeNode* const next_node = node->template find_next_node<DIRECTION>();\n-    if (next_node != nullptr) {\n-      return get_cursor(next_node);\n-    }\n-    const bool is_right_most = DIRECTION == ZIntrusiveRBTreeDirection::RIGHT && node == _right_most;\n-    const bool is_left_most = DIRECTION == ZIntrusiveRBTreeDirection::LEFT && node == _left_most;\n-    return make_cursor(node->template child_addr<DIRECTION>(), node, is_left_most, is_right_most);\n-  }\n-  ZIntrusiveRBTreeNode* const parent = cursor.parent();\n-  if (parent == nullptr) {\n-    assert(&_root_node == cursor.insert_location(), \"must be\");\n-    \/\/ tree is empty\n-    return FindCursor();\n-  }\n-  if (parent->template child_addr<OTHER_DIRECTION>() == cursor.insert_location()) {\n-    \/\/ Cursor at leaf in other direction, parent is next in direction\n-    return get_cursor(parent);\n-  }\n-  assert(parent->template child_addr<DIRECTION>() == cursor.insert_location(), \"must be\");\n-  \/\/ Cursor at leaf in direction, parent->next in direction is also cursors next in direction\n-  return get_cursor(parent->template find_next_node<DIRECTION>());\n-}\n-\n-template <typename Key, typename Compare>\n-inline ZIntrusiveRBTree<Key, Compare>::ZIntrusiveRBTree()\n-  : _root_node(nullptr),\n-    _left_most(nullptr),\n-    _right_most(nullptr)\n-    DEBUG_ONLY(COMMA _sequence_number()) {}\n-\n-template <typename Key, typename Compare>\n-inline ZIntrusiveRBTreeNode* ZIntrusiveRBTree<Key, Compare>::first() const {\n-  return _left_most;\n-}\n-\n-template <typename Key, typename Compare>\n-inline ZIntrusiveRBTreeNode* ZIntrusiveRBTree<Key, Compare>::last() const {\n-  return _right_most;\n-}\n-\n-template <typename Key, typename Compare>\n-inline typename ZIntrusiveRBTree<Key, Compare>::FindCursor ZIntrusiveRBTree<Key, Compare>::root_cursor() const {\n-  const bool is_left_most = _root_node == _left_most;\n-  const bool is_right_most = _root_node == _right_most;\n-  return make_cursor(&_root_node, nullptr, is_left_most, is_right_most);\n-}\n-\n-template <typename Key, typename Compare>\n-inline typename ZIntrusiveRBTree<Key, Compare>::FindCursor ZIntrusiveRBTree<Key, Compare>::get_cursor(const ZIntrusiveRBTreeNode* node) const {\n-  if (node == nullptr) {\n-    \/\/ Return a invalid cursor\n-    return FindCursor();\n-  }\n-  const bool is_left_most = node == _left_most;\n-  const bool is_right_most = node == _right_most;\n-  if (node->has_parent()) {\n-    const ZIntrusiveRBTreeNode* const parent = node->parent();\n-    if (parent->left_child() == node) {\n-      return make_cursor(parent->left_child_addr(), nullptr, is_left_most, is_right_most);\n-    }\n-    assert(parent->right_child() == node, \"must be\");\n-      return make_cursor(parent->right_child_addr(), nullptr, is_left_most, is_right_most);\n-  }\n-  \/\/ No parent, root node\n-  return make_cursor(&_root_node, nullptr, is_left_most, is_right_most);\n-}\n-\n-template <typename Key, typename Compare>\n-inline typename ZIntrusiveRBTree<Key, Compare>::FindCursor ZIntrusiveRBTree<Key, Compare>::prev_cursor(const ZIntrusiveRBTreeNode* node) const {\n-  return prev(get_cursor(node));\n-}\n-\n-template <typename Key, typename Compare>\n-inline typename ZIntrusiveRBTree<Key, Compare>::FindCursor ZIntrusiveRBTree<Key, Compare>::next_cursor(const ZIntrusiveRBTreeNode* node) const {\n-  return next(get_cursor(node));\n-}\n-\n-template <typename Key, typename Compare>\n-inline typename ZIntrusiveRBTree<Key, Compare>::FindCursor ZIntrusiveRBTree<Key, Compare>::prev(const FindCursor& cursor) const {\n-  return find_next<ZIntrusiveRBTreeDirection::LEFT>(cursor);\n-}\n-\n-template <typename Key, typename Compare>\n-inline typename ZIntrusiveRBTree<Key, Compare>::FindCursor ZIntrusiveRBTree<Key, Compare>::next(const FindCursor& cursor) const {\n-  return find_next<ZIntrusiveRBTreeDirection::RIGHT>(cursor);\n-}\n-\n-template <typename Key, typename Compare>\n-inline typename ZIntrusiveRBTree<Key, Compare>::FindCursor ZIntrusiveRBTree<Key, Compare>::find(const Key& key) const {\n-  Compare compare_fn;\n-  ZIntrusiveRBTreeNode* const* insert_location = root_node_addr();\n-  ZIntrusiveRBTreeNode* parent = nullptr;\n-  bool left_most = true;\n-  bool right_most = true;\n-  while (*insert_location != nullptr) {\n-    int result = compare_fn(key, *insert_location);\n-    if (result == 0) {\n-      assert(*insert_location != _left_most || left_most, \"must be\");\n-      assert(*insert_location != _right_most || right_most, \"must be\");\n-      return make_cursor(insert_location, parent, *insert_location == _left_most, *insert_location == _right_most);\n-    }\n-    parent = *insert_location;\n-    if (result < 0) {\n-      insert_location = parent->left_child_addr();\n-      \/\/ We took one step to the left, cannot be right_most.\n-      right_most = false;\n-    } else {\n-      insert_location = parent->right_child_addr();\n-      \/\/ We took one step to the right, cannot be left_most.\n-      left_most = false;\n-    }\n-  }\n-  return make_cursor(insert_location, parent, left_most, right_most);\n-}\n-\n-template <typename Key, typename Compare>\n-inline void ZIntrusiveRBTree<Key, Compare>::insert(ZIntrusiveRBTreeNode* new_node, const FindCursor& find_cursor) {\n-  precond(find_cursor.is_valid(_sequence_number));\n-  precond(!find_cursor.found());\n-  DEBUG_ONLY(_sequence_number++;)\n-\n-  \/\/ Link in the new node\n-  new_node->link_node(find_cursor.parent(), find_cursor.insert_location());\n-\n-  \/\/ Keep track of first and last node(s)\n-  if (find_cursor.is_left_most()) {\n-    _left_most = new_node;\n-  }\n-  if (find_cursor.is_right_most()) {\n-    _right_most = new_node;\n-  }\n-\n-  rebalance_insert(new_node);\n-}\n-\n-template <typename Key, typename Compare>\n-inline void ZIntrusiveRBTree<Key, Compare>::replace(ZIntrusiveRBTreeNode* new_node, const FindCursor& find_cursor) {\n-  precond(find_cursor.is_valid(_sequence_number));\n-  precond(find_cursor.found());\n-  DEBUG_ONLY(_sequence_number++;)\n-\n-  const ZIntrusiveRBTreeNode* const node = find_cursor.node();\n-\n-  if (new_node != node) {\n-    \/\/ Node has changed\n-\n-    \/\/ Copy the node to new location\n-    *new_node = *node;\n-\n-    \/\/ Update insert location\n-    *find_cursor.insert_location() = new_node;\n-\n-    \/\/ Update children's parent\n-    if (new_node->has_left_child()) {\n-      new_node->left_child()->update_parent(new_node);\n-    }\n-    if (new_node->has_right_child()) {\n-      new_node->right_child()->update_parent(new_node);\n-    }\n-\n-    \/\/ Keep track of first and last node(s)\n-    if (find_cursor.is_left_most()) {\n-      assert(_left_most == node, \"must be\");\n-      _left_most = new_node;\n-    }\n-    if (find_cursor.is_right_most()) {\n-      assert(_right_most == node, \"must be\");\n-      _right_most = new_node;\n-    }\n-  }\n-}\n-\n-template <typename Key, typename Compare>\n-inline void ZIntrusiveRBTree<Key, Compare>::remove(const FindCursor& find_cursor) {\n-  precond(find_cursor.is_valid(_sequence_number));\n-  precond(find_cursor.found());\n-  DEBUG_ONLY(_sequence_number++;)\n-\n-  ZIntrusiveRBTreeNode* const node = find_cursor.node();\n-  ZIntrusiveRBTreeNode* const parent = node->parent();\n-\n-  \/\/ Keep track of first and last node(s)\n-  if (find_cursor.is_left_most()) {\n-    assert(_left_most == node, \"must be\");\n-    _left_most = _left_most->next();\n-  }\n-  if (find_cursor.is_right_most()) {\n-    assert(_right_most == node, \"must be\");\n-    _right_most = _right_most->prev();\n-  }\n-\n-  ZIntrusiveRBTreeNode* rebalance_from = nullptr;\n-\n-  if (!node->has_left_child() && !node->has_right_child()) {\n-    \/\/ No children\n-\n-    \/\/ Remove node\n-    update_child_or_root(node, nullptr, parent);\n-    if (node->is_black()) {\n-      \/\/ We unbalanced the tree\n-      rebalance_from = parent;\n-    }\n-  } else if (!node->has_left_child() || !node->has_right_child()) {\n-    assert(node->has_right_child() || node->has_left_child(), \"must be\");\n-    \/\/ Only one child\n-    ZIntrusiveRBTreeNode* child = node->has_left_child() ? node->left_child() : node->right_child();\n-\n-    \/\/ Let child take nodes places\n-    update_child_or_root(node, child, parent);\n-\n-    \/\/ And update parent and color\n-    child->copy_parent_and_color(node);\n-  } else {\n-    assert(node->has_left_child() && node->has_right_child(), \"must be\");\n-    \/\/ Find next node and let it take the nodes place\n-    \/\/ This asymmetry always swap next instead of prev,\n-    \/\/ I wonder how this behaves w.r.t. our mapped cache\n-    \/\/ strategy of mostly removing from the left side of\n-    \/\/ the tree\n-\n-    \/\/ This will never walk up the tree, hope the compiler sees this.\n-    ZIntrusiveRBTreeNode* next_node = node->next();\n-\n-    ZIntrusiveRBTreeNode* next_node_parent = next_node->parent();\n-    ZIntrusiveRBTreeNode* next_node_child = next_node->right_child();\n-    if (next_node_parent != node) {\n-      \/\/ Not the direct descendant, adopt node's child\n-      ZIntrusiveRBTreeNode* node_child = node->right_child();\n-      next_node->update_right_child(node_child);\n-      node_child->update_parent(next_node);\n-\n-      \/\/ And let parent adopt their grand child\n-      next_node_parent->update_left_child(next_node_child);\n-    } else {\n-      next_node_parent = next_node;\n-    }\n-    \/\/ Adopt node's other child\n-    ZIntrusiveRBTreeNode* node_child = node->left_child();\n-    next_node->update_left_child(node_child);\n-    node_child->update_parent(next_node);\n-\n-    update_child_or_root(node, next_node, parent);\n-\n-    \/\/ Update parent(s) and colors\n-    if (next_node_child != nullptr) {\n-      next_node_child->update_parent_and_color(next_node_parent, ZIntrusiveRBTreeNode::BLACK);\n-    } else if (next_node->is_black()) {\n-      rebalance_from = next_node_parent;\n-    }\n-    next_node->copy_parent_and_color(node);\n-  }\n-\n-  if (rebalance_from == nullptr) {\n-    \/\/ Removal did not unbalance the tree\n-    return;\n-  }\n-\n-  rebalance_remove(rebalance_from);\n-}\n-\n-template <typename Key, typename Compare>\n-inline void ZIntrusiveRBTree<Key, Compare>::verify_tree() {\n-  \/\/ Properties:\n-  \/\/  (a) Node's are either BLACK or RED\n-  \/\/  (b) All nullptr children are counted as BLACK\n-  \/\/  (c) Compare::operator(Node*, Node*) <=> 0 is transitive\n-  \/\/ Invariants:\n-  \/\/  (1) Root node is BLACK\n-  \/\/  (2) All RED nodes only have BLACK children\n-  \/\/  (3) Every simple path from the root to a leaf\n-  \/\/      contains the same amount of BLACK nodes\n-  \/\/  (4) A node's children must have that node as\n-  \/\/      its parent\n-  \/\/  (5) Each node N in the sub-tree formed from a\n-  \/\/      node A's child must:\n-  \/\/        if left child:  Compare::operator(A, N) < 0\n-  \/\/        if right child: Compare::operator(A, N) > 0\n-  \/\/\n-  \/\/ Note: 1-4 may not hold during a call to insert\n-  \/\/       and remove.\n-\n-  \/\/ Helpers\n-  const auto is_leaf = [](ZIntrusiveRBTreeNode* node) {\n-    return node == nullptr;\n-  };\n-  const auto is_black = [&](ZIntrusiveRBTreeNode* node) {\n-    return is_leaf(node) || node->is_black();\n-  };\n-  const auto is_red = [&](ZIntrusiveRBTreeNode* node) {\n-    return !is_black(node);\n-  };\n-\n-  \/\/ Verify (1)\n-  ZIntrusiveRBTreeNode* const root_node = _root_node;\n-  guarantee(is_black(root_node), \"Invariant (1)\");\n-\n-  \/\/ Verify (2)\n-  const auto verify_2 = [&](ZIntrusiveRBTreeNode* node) {\n-    guarantee(!is_red(node) || is_black(node->left_child()), \"Invariant (2)\");\n-    guarantee(!is_red(node) || is_black(node->right_child()), \"Invariant (2)\");\n-  };\n-\n-  \/\/ Verify (3)\n-  size_t first_simple_path_black_nodes_traversed = 0;\n-  const auto verify_3 = [&](ZIntrusiveRBTreeNode* node, size_t black_nodes_traversed) {\n-    if (!is_leaf(node)) { return; }\n-    if (first_simple_path_black_nodes_traversed == 0) {\n-      first_simple_path_black_nodes_traversed = black_nodes_traversed;\n-    }\n-    guarantee(first_simple_path_black_nodes_traversed == black_nodes_traversed, \"Invariant (3)\");\n-  };\n-\n-  \/\/ Verify (4)\n-  const auto verify_4 = [&](ZIntrusiveRBTreeNode* node) {\n-    if (is_leaf(node)) { return; }\n-    guarantee(!node->has_left_child() || node->left_child()->parent() == node, \"Invariant (4)\");\n-    guarantee(!node->has_right_child() || node->right_child()->parent() == node, \"Invariant (4)\");\n-  };\n-  guarantee(root_node == nullptr || root_node->parent() == nullptr, \"Invariant (4)\");\n-\n-  \/\/ Verify (5)\n-  const auto verify_5 = [&](ZIntrusiveRBTreeNode* node) {\n-    \/\/ Because of the transitive property of Compare (c) we simply check\n-    \/\/ this that (5) hold for each parent child pair.\n-    if (is_leaf(node)) { return; }\n-    Compare compare_fn;\n-    guarantee(!node->has_left_child() || compare_fn(node->left_child(), node) < 0, \"Invariant (5)\");\n-    guarantee(!node->has_right_child() || compare_fn(node->right_child(), node) > 0, \"Invariant (5)\");\n-  };\n-\n-  \/\/ Walk every simple path by recursively descending the tree from the root\n-  const auto recursive_walk = [&](auto&& recurse, ZIntrusiveRBTreeNode* node, size_t black_nodes_traversed) {\n-    if (is_black(node)) { black_nodes_traversed++; }\n-    verify_2(node);\n-    verify_3(node, black_nodes_traversed);\n-    verify_4(node);\n-    verify_5(node);\n-    if (is_leaf(node)) { return; }\n-    recurse(recurse, node->left_child(), black_nodes_traversed);\n-    recurse(recurse, node->right_child(), black_nodes_traversed);\n-  };\n-  recursive_walk(recursive_walk, root_node, 0);\n-}\n-\n-template <typename Key, typename Compare>\n-inline typename ZIntrusiveRBTree<Key, Compare>::Iterator ZIntrusiveRBTree<Key, Compare>::begin() {\n-  return Iterator(*this, first());\n-}\n-\n-template <typename Key, typename Compare>\n-inline typename ZIntrusiveRBTree<Key, Compare>::Iterator ZIntrusiveRBTree<Key, Compare>::end() {\n-  return Iterator(*this, nullptr);\n-}\n-\n-template <typename Key, typename Compare>\n-inline typename ZIntrusiveRBTree<Key, Compare>::ConstIterator ZIntrusiveRBTree<Key, Compare>::begin() const {\n-  return cbegin();\n-}\n-\n-template <typename Key, typename Compare>\n-inline typename ZIntrusiveRBTree<Key, Compare>::ConstIterator ZIntrusiveRBTree<Key, Compare>::end() const {\n-  return cend();\n-}\n-\n-template <typename Key, typename Compare>\n-inline typename ZIntrusiveRBTree<Key, Compare>::ConstIterator ZIntrusiveRBTree<Key, Compare>::cbegin() const {\n-  return const_cast<ZIntrusiveRBTree<Key, Compare>*>(this)->begin();\n-}\n-\n-template <typename Key, typename Compare>\n-inline typename ZIntrusiveRBTree<Key, Compare>::ConstIterator ZIntrusiveRBTree<Key, Compare>::cend() const {\n-  return const_cast<ZIntrusiveRBTree<Key, Compare>*>(this)->end();\n-}\n-\n-template <typename Key, typename Compare>\n-inline typename ZIntrusiveRBTree<Key, Compare>::ReverseIterator ZIntrusiveRBTree<Key, Compare>::rbegin() {\n-  return ReverseIterator(*this, last());\n-}\n-\n-template <typename Key, typename Compare>\n-inline typename ZIntrusiveRBTree<Key, Compare>::ReverseIterator ZIntrusiveRBTree<Key, Compare>::rend() {\n-  return ReverseIterator(*this, nullptr);\n-}\n-\n-template <typename Key, typename Compare>\n-inline typename ZIntrusiveRBTree<Key, Compare>::ConstReverseIterator ZIntrusiveRBTree<Key, Compare>::rbegin() const {\n-  return crbegin();\n-}\n-\n-template <typename Key, typename Compare>\n-inline typename ZIntrusiveRBTree<Key, Compare>::ConstReverseIterator ZIntrusiveRBTree<Key, Compare>::rend() const {\n-  return crend();\n-}\n-\n-template <typename Key, typename Compare>\n-inline typename ZIntrusiveRBTree<Key, Compare>::ConstReverseIterator ZIntrusiveRBTree<Key, Compare>::crbegin() const {\n-  return const_cast<ZIntrusiveRBTree<Key, Compare>*>(this)->rbegin();\n-}\n-\n-template <typename Key, typename Compare>\n-inline typename ZIntrusiveRBTree<Key, Compare>::ConstReverseIterator ZIntrusiveRBTree<Key, Compare>::crend() const {\n-  return const_cast<ZIntrusiveRBTree<Key, Compare>*>(this)->rend();\n-}\n-\n-template <typename Key, typename Compare>\n-template <bool IsConst, bool Reverse>\n-inline bool ZIntrusiveRBTree<Key, Compare>::IteratorImplementation<IsConst, Reverse>::at_end() const {\n-  return _node == nullptr;\n-}\n-\n-template <typename Key, typename Compare>\n-template <bool IsConst, bool Reverse>\n-inline ZIntrusiveRBTree<Key, Compare>::IteratorImplementation<IsConst, Reverse>::IteratorImplementation(ZIntrusiveRBTree<Key, Compare>& tree, pointer node)\n-: _tree(&tree),\n-  _node(node),\n-  _removed(false) {}\n-\n-template <typename Key, typename Compare>\n-template <bool IsConst, bool Reverse>\n-template <bool Enable, ENABLE_IF_SDEFN(Enable)>\n-inline ZIntrusiveRBTree<Key, Compare>::IteratorImplementation<IsConst, Reverse>::IteratorImplementation(const IteratorImplementation<false, Reverse>& other)\n-: _tree(other._tree),\n-  _node(other._node),\n-  _removed(false) {}\n-\n-template <typename Key, typename Compare>\n-template <bool IsConst, bool Reverse>\n-inline typename ZIntrusiveRBTree<Key, Compare>::template IteratorImplementation<IsConst, Reverse>::reference ZIntrusiveRBTree<Key, Compare>::IteratorImplementation<IsConst, Reverse>::operator*() const {\n-  precond(!_removed);\n-  return *_node;\n-}\n-\n-template <typename Key, typename Compare>\n-template <bool IsConst, bool Reverse>\n-inline typename ZIntrusiveRBTree<Key, Compare>::template IteratorImplementation<IsConst, Reverse>::pointer ZIntrusiveRBTree<Key, Compare>::IteratorImplementation<IsConst, Reverse>::operator->() {\n-  precond(!_removed);\n-  return _node;\n-}\n-\n-template <typename Key, typename Compare>\n-template <bool IsConst, bool Reverse>\n-inline typename ZIntrusiveRBTree<Key, Compare>::template IteratorImplementation<IsConst, Reverse>& ZIntrusiveRBTree<Key, Compare>::IteratorImplementation<IsConst, Reverse>::operator--() {\n-  if (_removed) {\n-    _removed = false;\n-  } else if (Reverse) {\n-    precond(_node != _tree->last());\n-    _node = at_end() ? _tree->first() : _node->next();\n-  } else {\n-    precond(_node != _tree->first());\n-    _node = at_end() ? _tree->last() : _node->prev();\n-  }\n-  return *this;\n-}\n-\n-template <typename Key, typename Compare>\n-template <bool IsConst, bool Reverse>\n-inline typename ZIntrusiveRBTree<Key, Compare>::template IteratorImplementation<IsConst, Reverse> ZIntrusiveRBTree<Key, Compare>::IteratorImplementation<IsConst, Reverse>::operator--(int) {\n-  IteratorImplementation tmp = *this;\n-  --(*this);\n-  return tmp;\n-}\n-\n-template <typename Key, typename Compare>\n-template <bool IsConst, bool Reverse>\n-inline typename ZIntrusiveRBTree<Key, Compare>::template IteratorImplementation<IsConst, Reverse>& ZIntrusiveRBTree<Key, Compare>::IteratorImplementation<IsConst, Reverse>::operator++() {\n-  if (_removed) {\n-    _removed = false;\n-  } else if (Reverse) {\n-    precond(!at_end());\n-    _node = _node->prev();\n-  } else {\n-    precond(!at_end());\n-    _node = _node->next();\n-  }\n-  return *this;\n-}\n-\n-template <typename Key, typename Compare>\n-template <bool IsConst, bool Reverse>\n-inline typename ZIntrusiveRBTree<Key, Compare>::template IteratorImplementation<IsConst, Reverse> ZIntrusiveRBTree<Key, Compare>::IteratorImplementation<IsConst, Reverse>::operator++(int) {\n-  IteratorImplementation tmp = *this;\n-  ++(*this);\n-  return tmp;\n-}\n-\n-template <typename Key, typename Compare>\n-template <bool IsConst, bool Reverse>\n-template <bool Enable, ENABLE_IF_SDEFN(Enable)>\n-void ZIntrusiveRBTree<Key, Compare>::IteratorImplementation<IsConst, Reverse>::replace(ZIntrusiveRBTreeNode* new_node) {\n-  precond(!_removed);\n-  precond(!at_end());\n-  FindCursor cursor = _tree->get_cursor(_node);\n-  _node = new_node;\n-  _tree->replace(new_node, cursor);\n-}\n-\n-template <typename Key, typename Compare>\n-template <bool IsConst, bool Reverse>\n-template <bool Enable, ENABLE_IF_SDEFN(Enable)>\n-void ZIntrusiveRBTree<Key, Compare>::IteratorImplementation<IsConst, Reverse>::remove() {\n-  precond(!_removed);\n-  precond(!at_end());\n-  FindCursor cursor = _tree->get_cursor(_node);\n-  ++(*this);\n-  _removed = true;\n-  _tree->remove(cursor);\n-}\n-\n-#endif \/\/ SHARE_GC_Z_ZINTRUSIVERBTREE_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/z\/zIntrusiveRBTree.inline.hpp","additions":0,"deletions":1351,"binary":false,"changes":1351,"status":"deleted"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"gc\/z\/zIntrusiveRBTree.inline.hpp\"\n@@ -35,0 +34,1 @@\n+#include \"utilities\/rbTree.inline.hpp\"\n@@ -121,1 +121,1 @@\n-int ZMappedCache::EntryCompare::operator()(ZMappedCache::TreeNode* a, ZMappedCache::TreeNode* b) {\n+int ZMappedCache::EntryCompare::cmp(const IntrusiveRBNode* a, const IntrusiveRBNode* b) {\n@@ -131,1 +131,1 @@\n-int ZMappedCache::EntryCompare::operator()(zoffset key, ZMappedCache::TreeNode* node) {\n+int ZMappedCache::EntryCompare::cmp(zoffset key, const IntrusiveRBNode* node) {\n@@ -140,0 +140,101 @@\n+void ZMappedCache::Tree::verify() const {\n+#ifdef ASSERT\n+  \/\/ Verify\n+\n+  if (size() < 10) {\n+    \/\/ Only verify whole tree if the node count is low\n+    verify_self();\n+  }\n+\n+  \/\/ Verify the externally tracked left most and right most nodes\n+  verify_left_most();\n+  verify_right_most();\n+#endif \/\/ ASSERT\n+}\n+\n+void ZMappedCache::Tree::verify_left_most() const {\n+  assert(leftmost() == _left_most, \"must be \" PTR_FORMAT \" == \" PTR_FORMAT,\n+          p2i(leftmost()), p2i(this));\n+}\n+\n+void ZMappedCache::Tree::verify_right_most() const {\n+  assert(rightmost() == _right_most, \"must be \" PTR_FORMAT \" == \" PTR_FORMAT,\n+          p2i(rightmost()), p2i(this));\n+}\n+\n+ZMappedCache::Tree::Tree()\n+  : TreeImpl(),\n+    _left_most(nullptr),\n+    _right_most(nullptr) {}\n+\n+void ZMappedCache::Tree::insert(TreeNode* node, const TreeCursor& cursor) {\n+  \/\/ Insert in tree\n+  TreeImpl::insert_at_cursor(node, cursor);\n+\n+  if (_left_most == nullptr || EntryCompare::cmp(node, _left_most) < 0) {\n+    \/\/ Keep track of left most node\n+    _left_most = node;\n+  }\n+\n+  if (_right_most == nullptr || EntryCompare::cmp(_right_most, node) < 0) {\n+    \/\/ Keep track of right most node\n+    _right_most = node;\n+  }\n+\n+  \/\/ Verify\n+  verify();\n+}\n+\n+void ZMappedCache::Tree::remove(TreeNode* node) {\n+  if (_left_most == node) {\n+    \/\/ Keep track of left most node\n+    _left_most = node->next();\n+  }\n+\n+  if (_right_most == node) {\n+    \/\/ Keep track of right most node\n+    _right_most = node->prev();\n+  }\n+\n+  \/\/ Remove from tree\n+  TreeImpl::remove(node);\n+}\n+\n+void ZMappedCache::Tree::replace(TreeNode* old_node, TreeNode* new_node, const TreeCursor& cursor) {\n+  if (_left_most == old_node) {\n+    \/\/ Keep track of left most node\n+    _left_most = new_node;\n+  }\n+\n+  if (_right_most == old_node) {\n+    \/\/ Keep track of right most node\n+    _right_most = new_node;\n+  }\n+\n+  \/\/ Replace in tree\n+  TreeImpl::replace_at_cursor(new_node, cursor);\n+\n+  \/\/ Verify\n+  verify();\n+}\n+\n+const ZMappedCache::TreeNode* ZMappedCache::Tree::left_most() const {\n+  verify_left_most();\n+  return _left_most;\n+}\n+\n+ZMappedCache::TreeNode* ZMappedCache::Tree::left_most() {\n+  verify_left_most();\n+  return _left_most;\n+}\n+\n+const ZMappedCache::TreeNode* ZMappedCache::Tree::right_most() const {\n+  verify_right_most();\n+  return _right_most;\n+}\n+\n+ZMappedCache::TreeNode* ZMappedCache::Tree::right_most() {\n+  verify_right_most();\n+  return _right_most;\n+}\n+\n@@ -165,1 +266,1 @@\n-void ZMappedCache::tree_insert(const Tree::FindCursor& cursor, const ZVirtualMemory& vmem) {\n+void ZMappedCache::cache_insert(const TreeCursor& cursor, const ZVirtualMemory& vmem) {\n@@ -168,3 +269,0 @@\n-  \/\/ Insert creates a new entry\n-  _entry_count += 1;\n-\n@@ -172,1 +270,2 @@\n-  _tree.insert(entry->node_addr(), cursor);\n+  TreeNode* node = entry->node_addr();\n+  _tree.insert(node, cursor);\n@@ -182,5 +281,3 @@\n-void ZMappedCache::tree_remove(const Tree::FindCursor& cursor, const ZVirtualMemory& vmem) {\n-  ZMappedCacheEntry* entry = ZMappedCacheEntry::cast_to_entry(cursor.node());\n-\n-  \/\/ Remove destroys an old entry\n-  _entry_count -= 1;\n+void ZMappedCache::cache_remove(const TreeCursor& cursor, const ZVirtualMemory& vmem) {\n+  TreeNode* const node = cursor.node();\n+  ZMappedCacheEntry* entry = ZMappedCacheEntry::cast_to_entry(node);\n@@ -189,1 +286,1 @@\n-  _tree.remove(cursor);\n+  _tree.remove(node);\n@@ -191,1 +288,1 @@\n-  \/\/ Insert in size-class lists\n+  \/\/ Remove from size-class lists\n@@ -202,1 +299,1 @@\n-void ZMappedCache::tree_replace(const Tree::FindCursor& cursor, const ZVirtualMemory& vmem) {\n+void ZMappedCache::cache_replace(const TreeCursor& cursor, const ZVirtualMemory& vmem) {\n@@ -204,0 +301,1 @@\n+  IntrusiveRBNode* const new_node = entry->node_addr();\n@@ -205,2 +303,2 @@\n-  ZMappedCache::TreeNode* const node = cursor.node();\n-  ZMappedCacheEntry* const old_entry = ZMappedCacheEntry::cast_to_entry(node);\n+  ZMappedCache::TreeNode* const old_node = cursor.node();\n+  ZMappedCacheEntry* const old_entry = ZMappedCacheEntry::cast_to_entry(old_node);\n@@ -209,3 +307,0 @@\n-  \/\/ Replace in tree\n-  _tree.replace(entry->node_addr(), cursor);\n-\n@@ -213,0 +308,1 @@\n+  _tree.replace(old_node, new_node, cursor);\n@@ -232,1 +328,1 @@\n-void ZMappedCache::tree_update(ZMappedCacheEntry* entry, const ZVirtualMemory& vmem) {\n+void ZMappedCache::cache_update(ZMappedCacheEntry* entry, const ZVirtualMemory& vmem) {\n@@ -284,1 +380,1 @@\n-      tree_update(entry, unused_vmem);\n+      cache_update(entry, unused_vmem);\n@@ -292,3 +388,3 @@\n-      auto cursor = _tree.get_cursor(entry->node_addr());\n-      assert(cursor.is_valid(), \"must be\");\n-      tree_replace(cursor, unused_vmem);\n+      TreeCursor cursor = _tree.cursor(entry->node_addr());\n+      assert(cursor.valid(), \"must be\");\n+      cache_replace(cursor, unused_vmem);\n@@ -299,3 +395,3 @@\n-    auto cursor = _tree.get_cursor(entry->node_addr());\n-    assert(cursor.is_valid(), \"must be\");\n-    tree_remove(cursor, vmem);\n+    TreeCursor cursor = _tree.cursor(entry->node_addr());\n+    assert(cursor.valid(), \"must be\");\n+    cache_remove(cursor, vmem);\n@@ -387,1 +483,1 @@\n-    for (ZMappedCache::TreeNode* node = _tree.last(); node != nullptr; node = node->prev()) {\n+    for (ZMappedCache::TreeNode* node = _tree.right_most(); node != nullptr; node = node->prev()) {\n@@ -402,1 +498,1 @@\n-    for (ZMappedCache::TreeNode* node = _tree.first(); node != nullptr; node = node->next()) {\n+    for (ZMappedCache::TreeNode* node = _tree.left_most(); node != nullptr; node = node->next()) {\n@@ -452,1 +548,0 @@\n-    _entry_count(0),\n@@ -460,2 +555,2 @@\n-  Tree::FindCursor current_cursor = _tree.find(vmem.start());\n-  Tree::FindCursor next_cursor = _tree.next(current_cursor);\n+  TreeCursor current_cursor = _tree.cursor(vmem.start());\n+  TreeCursor next_cursor = _tree.next(current_cursor);\n@@ -464,1 +559,1 @@\n-  const bool extends_right = next_cursor.is_valid() && next_cursor.found() &&\n+  const bool extends_right = next_cursor.valid() && next_cursor.found() &&\n@@ -480,1 +575,1 @@\n-    tree_remove(current_cursor, left_vmem);\n+    cache_remove(current_cursor, left_vmem);\n@@ -483,1 +578,1 @@\n-    tree_update(next_entry, new_vmem);\n+    cache_update(next_entry, new_vmem);\n@@ -495,1 +590,1 @@\n-    tree_replace(current_cursor, new_vmem);\n+    cache_replace(current_cursor, new_vmem);\n@@ -510,1 +605,1 @@\n-    tree_update(next_entry, new_vmem);\n+    cache_update(next_entry, new_vmem);\n@@ -515,1 +610,1 @@\n-  tree_insert(current_cursor, vmem);\n+  cache_insert(current_cursor, vmem);\n@@ -574,1 +669,1 @@\n-  \/\/ values may be inconsistent. As such we read the _entry_count only once. And\n+  \/\/ values may be inconsistent. As such we read the _tree.size() only once. And\n@@ -577,1 +672,1 @@\n-  const size_t entry_count = Atomic::load(&_entry_count);\n+  const size_t entry_count = _tree.size();\n@@ -624,1 +719,1 @@\n-  for (ZMappedCache::TreeNode* node = _tree.first(); node != nullptr; node = node->next()) {\n+  for (const ZMappedCache::TreeNode* node = _tree.left_most(); node != nullptr; node = node->next()) {\n","filename":"src\/hotspot\/share\/gc\/z\/zMappedCache.cpp","additions":138,"deletions":43,"binary":false,"changes":181,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/z\/zIntrusiveRBTree.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"utilities\/rbTree.hpp\"\n@@ -43,2 +43,2 @@\n-    int operator()(ZIntrusiveRBTreeNode* a, ZIntrusiveRBTreeNode* b);\n-    int operator()(zoffset key, ZIntrusiveRBTreeNode* node);\n+    static int cmp(zoffset a, const IntrusiveRBNode* b);\n+    static int cmp(const IntrusiveRBNode*  a, const IntrusiveRBNode* b);\n@@ -51,2 +51,3 @@\n-  using Tree              = ZIntrusiveRBTree<zoffset, EntryCompare>;\n-  using TreeNode          = ZIntrusiveRBTreeNode;\n+  using TreeImpl          = IntrusiveRBTree<zoffset, EntryCompare>;\n+  using TreeCursor        = TreeImpl::Cursor;\n+  using TreeNode          = IntrusiveRBNode;\n@@ -56,0 +57,28 @@\n+  class Tree : private TreeImpl {\n+  private:\n+    TreeNode* _left_most;\n+    TreeNode* _right_most;\n+\n+    void verify() const;\n+    void verify_left_most() const;\n+    void verify_right_most() const;\n+\n+  public:\n+    Tree();\n+\n+    void insert(TreeNode* node, const TreeCursor& cursor);\n+    void remove(TreeNode* node);\n+    void replace(TreeNode* old_node, TreeNode* new_node, const TreeCursor& cursor);\n+\n+    using TreeImpl::size;\n+\n+    using TreeImpl::cursor;\n+    using TreeImpl::next;\n+\n+    const TreeNode* left_most() const;\n+    TreeNode* left_most();\n+\n+    const TreeNode* right_most() const;\n+    TreeNode* right_most();\n+  };\n+\n@@ -63,1 +92,0 @@\n-  size_t        _entry_count;\n@@ -71,4 +99,4 @@\n-  void tree_insert(const Tree::FindCursor& cursor, const ZVirtualMemory& vmem);\n-  void tree_remove(const Tree::FindCursor& cursor, const ZVirtualMemory& vmem);\n-  void tree_replace(const Tree::FindCursor& cursor, const ZVirtualMemory& vmem);\n-  void tree_update(ZMappedCacheEntry* entry, const ZVirtualMemory& vmem);\n+  void cache_insert(const TreeCursor& cursor, const ZVirtualMemory& vmem);\n+  void cache_remove(const TreeCursor& cursor, const ZVirtualMemory& vmem);\n+  void cache_replace(const TreeCursor& cursor, const ZVirtualMemory& vmem);\n+  void cache_update(ZMappedCacheEntry* entry, const ZVirtualMemory& vmem);\n","filename":"src\/hotspot\/share\/gc\/z\/zMappedCache.hpp","additions":38,"deletions":10,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1,379 +0,0 @@\n-\/*\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"gc\/z\/zIntrusiveRBTree.inline.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/arena.hpp\"\n-#include \"nmt\/memTag.hpp\"\n-#include \"unittest.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"zunittest.hpp\"\n-\n-#include <limits>\n-\n-struct ZRBTestEntryCompare {\n-  int operator()(const ZIntrusiveRBTreeNode* a, const ZIntrusiveRBTreeNode* b);\n-  int operator()(int key, const ZIntrusiveRBTreeNode* entry);\n-};\n-\n-class ZRBTestEntry : public ArenaObj {\n-  friend class ZIntrusiveRBTree<int, ZRBTestEntryCompare>;\n-\n-public:\n-  using ZTree = ZIntrusiveRBTree<int, ZRBTestEntryCompare>;\n-private:\n-  const int   _id;\n-  ZIntrusiveRBTreeNode _node;\n-\n-public:\n-  ZRBTestEntry(int id)\n-    : _id(id),\n-      _node() {}\n-\n-  int id() const {\n-    return _id;\n-  }\n-\n-  static ZIntrusiveRBTreeNode* cast_to_inner(ZRBTestEntry* element) {\n-    return &element->_node;\n-  }\n-  static const ZRBTestEntry* cast_to_outer(const ZIntrusiveRBTreeNode* node) {\n-    return (ZRBTestEntry*)((uintptr_t)node - offset_of(ZRBTestEntry, _node));\n-  }\n-\n-};\n-\n-int ZRBTestEntryCompare::operator()(const ZIntrusiveRBTreeNode* a, const ZIntrusiveRBTreeNode* b) {\n-  return ZRBTestEntry::cast_to_outer(a)->id() - ZRBTestEntry::cast_to_outer(b)->id();\n-}\n-int ZRBTestEntryCompare::operator()(int key, const ZIntrusiveRBTreeNode* entry) {\n-  return key - ZRBTestEntry::cast_to_outer(entry)->id();\n-}\n-\n-class ZTreeTest : public ZTest {\n-public:\n-  void shuffle_array(ZRBTestEntry** beg, ZRBTestEntry** end);\n-  void reverse_array(ZRBTestEntry** beg, ZRBTestEntry** end);\n-};\n-\n-class ResettableArena : public Arena {\n-public:\n-  using Arena::Arena;\n-\n-  void reset_arena() {\n-    if (_chunk != _first) {\n-      set_size_in_bytes(_chunk->length());\n-      Chunk::next_chop(_first);\n-    }\n-    _chunk = _first;\n-    _hwm = _chunk->bottom();\n-    _max = _chunk->top();\n-  }\n-};\n-\n-TEST_F(ZTreeTest, test_random) {\n-  constexpr size_t sizes[] = {1, 2, 4, 8, 16, 1024, 1024 * 1024};\n-  constexpr size_t num_sizes = ARRAY_SIZE(sizes);\n-  constexpr size_t iterations_multiplier = 4;\n-  constexpr size_t max_allocation_size = sizes[num_sizes - 1] * iterations_multiplier * sizeof(ZRBTestEntry);\n-  ResettableArena arena{MemTag::mtTest, Arena::Tag::tag_other, max_allocation_size};\n-  for (size_t s : sizes) {\n-    ZRBTestEntry::ZTree tree;\n-    const size_t num_iterations = s * iterations_multiplier;\n-    for (size_t i = 0; i < num_iterations; i++) {\n-      if (i % s == 0) {\n-        tree.verify_tree();\n-      }\n-      int id = random() % s;\n-      auto cursor = tree.find(id);\n-      if (cursor.found()) {\n-        \/\/ Replace or Remove\n-        if (i % 2 == 0) {\n-          \/\/ Replace\n-          if (i % 4 == 0) {\n-            \/\/ Replace with new\n-            tree.replace(ZRBTestEntry::cast_to_inner(new (&arena) ZRBTestEntry(id)), cursor);\n-          } else {\n-            \/\/ Replace with same\n-            tree.replace(cursor.node(), cursor);\n-          }\n-        } else {\n-          \/\/ Remove\n-          tree.remove(cursor);\n-        }\n-      } else {\n-        \/\/ Insert\n-        tree.insert(ZRBTestEntry::cast_to_inner(new (&arena) ZRBTestEntry(id)), cursor);\n-      }\n-    }\n-    tree.verify_tree();\n-    arena.reset_arena();\n-  }\n-}\n-\n-void ZTreeTest::reverse_array(ZRBTestEntry** beg, ZRBTestEntry** end) {\n-  if (beg == end) {\n-    return;\n-  }\n-\n-  ZRBTestEntry** first = beg;\n-  ZRBTestEntry** last = end - 1;\n-  while (first < last) {\n-    ::swap(*first, *last);\n-    first++;\n-    last--;\n-  }\n-}\n-\n-void ZTreeTest::shuffle_array(ZRBTestEntry** beg, ZRBTestEntry** end) {\n-  if (beg == end) {\n-    return;\n-  }\n-\n-  for (ZRBTestEntry** first = beg + 1; first != end; first++) {\n-    const ptrdiff_t distance = first - beg;\n-    ASSERT_GE(distance, 0);\n-    const ptrdiff_t random_index = random() % (distance + 1);\n-    ::swap(*first, *(beg + random_index));\n-  }\n-}\n-\n-TEST_F(ZTreeTest, test_insert) {\n-  Arena arena(MemTag::mtTest);\n-  constexpr size_t num_entries = 1024;\n-  ZRBTestEntry* forward[num_entries]{};\n-  ZRBTestEntry* reverse[num_entries]{};\n-  ZRBTestEntry* shuffle[num_entries]{};\n-  for (size_t i = 0; i < num_entries; i++) {\n-    const int id = static_cast<int>(i);\n-    forward[i] = new (&arena) ZRBTestEntry(id);\n-    reverse[i] = new (&arena) ZRBTestEntry(id);\n-    shuffle[i] = new (&arena) ZRBTestEntry(id);\n-  }\n-  reverse_array(reverse, reverse + num_entries);\n-  shuffle_array(shuffle, shuffle + num_entries);\n-\n-  ZRBTestEntry::ZTree forward_tree;\n-  auto cursor = forward_tree.root_cursor();\n-  for (size_t i = 0; i < num_entries; i++) {\n-    ASSERT_TRUE(cursor.is_valid());\n-    ASSERT_FALSE(cursor.found());\n-    ZIntrusiveRBTreeNode* const new_node = ZRBTestEntry::cast_to_inner(forward[i]);\n-    forward_tree.insert(new_node, cursor);\n-    cursor = forward_tree.next_cursor(new_node);\n-  }\n-  forward_tree.verify_tree();\n-\n-  ZRBTestEntry::ZTree reverse_tree;\n-  cursor = reverse_tree.root_cursor();\n-  for (size_t i = 0; i < num_entries; i++) {\n-    ASSERT_TRUE(cursor.is_valid());\n-    ASSERT_FALSE(cursor.found());\n-    ZIntrusiveRBTreeNode* const new_node = ZRBTestEntry::cast_to_inner(reverse[i]);\n-    reverse_tree.insert(new_node, cursor);\n-    cursor = reverse_tree.prev_cursor(new_node);\n-  }\n-  reverse_tree.verify_tree();\n-\n-  ZRBTestEntry::ZTree shuffle_tree;\n-  for (size_t i = 0; i < num_entries; i++) {\n-    cursor = shuffle_tree.find(reverse[i]->id());\n-    ASSERT_TRUE(cursor.is_valid());\n-    ASSERT_FALSE(cursor.found());\n-    ZIntrusiveRBTreeNode* const new_node = ZRBTestEntry::cast_to_inner(reverse[i]);\n-    shuffle_tree.insert(new_node, cursor);\n-  }\n-  shuffle_tree.verify_tree();\n-\n-  ZRBTestEntryCompare compare_fn;\n-  const ZIntrusiveRBTreeNode* forward_node = forward_tree.first();\n-  const ZIntrusiveRBTreeNode* reverse_node = reverse_tree.first();\n-  const ZIntrusiveRBTreeNode* shuffle_node = shuffle_tree.first();\n-  size_t count = 0;\n-  while (true) {\n-    count++;\n-    ASSERT_EQ(compare_fn(forward_node, reverse_node), 0);\n-    ASSERT_EQ(compare_fn(forward_node, shuffle_node), 0);\n-    ASSERT_EQ(compare_fn(reverse_node, shuffle_node), 0);\n-    const ZIntrusiveRBTreeNode* forward_next_node = forward_node->next();\n-    const ZIntrusiveRBTreeNode* reverse_next_node = reverse_node->next();\n-    const ZIntrusiveRBTreeNode* shuffle_next_node = shuffle_node->next();\n-    if (forward_next_node == nullptr) {\n-      ASSERT_EQ(forward_next_node, reverse_next_node);\n-      ASSERT_EQ(forward_next_node, shuffle_next_node);\n-      ASSERT_EQ(forward_node, forward_tree.last());\n-      ASSERT_EQ(reverse_node, reverse_tree.last());\n-      ASSERT_EQ(shuffle_node, shuffle_tree.last());\n-      break;\n-    }\n-    ASSERT_LT(compare_fn(forward_node, forward_next_node), 0);\n-    ASSERT_LT(compare_fn(reverse_node, reverse_next_node), 0);\n-    ASSERT_LT(compare_fn(shuffle_node, shuffle_next_node), 0);\n-    forward_node = forward_next_node;\n-    reverse_node = reverse_next_node;\n-    shuffle_node = shuffle_next_node;\n-  }\n-  ASSERT_EQ(count, num_entries);\n-}\n-\n-TEST_F(ZTreeTest, test_replace) {\n-  Arena arena(MemTag::mtTest);\n-  constexpr size_t num_entries = 1024;\n-  ZRBTestEntry::ZTree tree;\n-  auto cursor = tree.root_cursor();\n-  for (size_t i = 0; i < num_entries; i++) {\n-    ASSERT_TRUE(cursor.is_valid());\n-    ASSERT_FALSE(cursor.found());\n-    const int id = static_cast<int>(i) * 2 + 1;\n-    ZIntrusiveRBTreeNode* const new_node = ZRBTestEntry::cast_to_inner(new (&arena) ZRBTestEntry(id));\n-    tree.insert(new_node, cursor);\n-    cursor = tree.next_cursor(new_node);\n-  }\n-  tree.verify_tree();\n-\n-  size_t i = 0;\n-  for (auto it = tree.begin(), end = tree.end(); it != end; ++it) {\n-    auto& node = *it;\n-    if (i % (num_entries \/ 4)) {\n-      tree.verify_tree();\n-    }\n-    switch (i++ % 4) {\n-      case 0: {\n-        \/\/ Decrement\n-        ZRBTestEntry* new_entry = new (&arena) ZRBTestEntry(ZRBTestEntry::cast_to_outer(&node)->id() - 1);\n-        it.replace(ZRBTestEntry::cast_to_inner(new_entry));\n-      } break;\n-      case 1: break;\n-      case 2: {\n-        \/\/ Increment\n-        ZRBTestEntry* new_entry = new (&arena) ZRBTestEntry(ZRBTestEntry::cast_to_outer(&node)->id() + 1);\n-        it.replace(ZRBTestEntry::cast_to_inner(new_entry));\n-      } break;\n-      case 3: break;\n-      default:\n-        ShouldNotReachHere();\n-    }\n-  }\n-  tree.verify_tree();\n-\n-  int last_id = std::numeric_limits<int>::min();\n-  for (auto& node : tree) {\n-    int id = ZRBTestEntry::cast_to_outer(&node)->id();\n-    ASSERT_LT(last_id, id);\n-    last_id = id;\n-  }\n-  tree.verify_tree();\n-\n-  last_id = std::numeric_limits<int>::min();\n-  for (auto it = tree.begin(), end = tree.end(); it != end; ++it) {\n-    int id = ZRBTestEntry::cast_to_outer(&*it)->id();\n-    ASSERT_LT(last_id, id);\n-    last_id = id;\n-  }\n-  tree.verify_tree();\n-\n-  last_id = std::numeric_limits<int>::min();\n-  for (auto it = tree.cbegin(), end = tree.cend(); it != end; ++it) {\n-    int id = ZRBTestEntry::cast_to_outer(&*it)->id();\n-    ASSERT_LT(last_id, id);\n-    last_id = id;\n-  }\n-  tree.verify_tree();\n-\n-  last_id = std::numeric_limits<int>::max();\n-  for (auto it = tree.rbegin(), end = tree.rend(); it != end; ++it) {\n-    int id = ZRBTestEntry::cast_to_outer(&*it)->id();\n-    ASSERT_GT(last_id, id);\n-    last_id = id;\n-  }\n-  tree.verify_tree();\n-\n-  last_id = std::numeric_limits<int>::max();\n-  for (auto it = tree.crbegin(), end = tree.crend(); it != end; ++it) {\n-    int id = ZRBTestEntry::cast_to_outer(&*it)->id();\n-    ASSERT_GT(last_id, id);\n-    last_id = id;\n-  }\n-  tree.verify_tree();\n-}\n-\n-TEST_F(ZTreeTest, test_remove) {\n-  Arena arena(MemTag::mtTest);\n-  constexpr int num_entries = 1024;\n-  ZRBTestEntry::ZTree tree;\n-  int id = 0;\n-  tree.insert(ZRBTestEntry::cast_to_inner(new (&arena) ZRBTestEntry(++id)), tree.root_cursor());\n-  for (auto& node : tree) {\n-    if (ZRBTestEntry::cast_to_outer(&node)->id() == num_entries) {\n-      break;\n-    }\n-    auto cursor = tree.next_cursor(&node);\n-    ZIntrusiveRBTreeNode* const new_node = ZRBTestEntry::cast_to_inner(new (&arena) ZRBTestEntry(++id));\n-    tree.insert(new_node, cursor);\n-  }\n-  tree.verify_tree();\n-  ASSERT_EQ(ZRBTestEntry::cast_to_outer(tree.last())->id(), num_entries);\n-\n-  int i = 0;\n-  int removed = 0;\n-  for (auto it = tree.begin(), end = tree.end(); it != end; ++it) {\n-    if (i++ % 2 == 0) {\n-      it.remove();\n-      ++removed;\n-    }\n-  }\n-  tree.verify_tree();\n-\n-  int count = 0;\n-  for (auto it = tree.cbegin(), end = tree.cend(); it != end; ++it) {\n-    ++count;\n-  }\n-  ASSERT_EQ(count, num_entries - removed);\n-  tree.verify_tree();\n-\n-  for (auto it = tree.rbegin(), end = tree.rend(); it != end; ++it) {\n-    if (i++ % 2 == 0) {\n-      it.remove();\n-      ++removed;\n-    }\n-  }\n-  tree.verify_tree();\n-\n-  count = 0;\n-  for (auto it = tree.cbegin(), end = tree.cend(); it != end; ++it) {\n-    ++count;\n-  }\n-  ASSERT_EQ(count, num_entries - removed);\n-  tree.verify_tree();\n-\n-  for (auto it = tree.begin(), end = tree.end(); it != end; ++it) {\n-    it.remove();\n-    removed++;\n-  }\n-  tree.verify_tree();\n-\n-  ASSERT_EQ(removed, num_entries);\n-  ASSERT_EQ(tree.last(), nullptr);\n-  ASSERT_EQ(tree.first(), nullptr);\n-}\n","filename":"test\/hotspot\/gtest\/gc\/z\/test_zIntrusiveRBTree.cpp","additions":0,"deletions":379,"binary":false,"changes":379,"status":"deleted"}]}