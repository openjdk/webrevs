{"files":[{"patch":"@@ -37,1 +37,1 @@\n-    public static void main(String[] args) {\n+    public static void main(String[] args) throws Throwable {\n@@ -46,15 +46,14 @@\n-        try (Stream<String> lines = Files.lines(caseFoldingTxt)) {\n-            var caseFoldingEntries = lines.filter(line -> !line.startsWith(\"#\") && line.matches(supportedTypes))\n-                 .map(line -> {\n-                    String[] cols = line.split(\"; \");\n-                    return new String[] {cols[0], cols[1], cols[2]};\n-                 })\n-                .filter(cols -> {\n-                    \/\/  the folding case doesn't map back to the original char.\n-                    var cp1 = Integer.parseInt(cols[0], 16);\n-                    var cp2 = Integer.parseInt(cols[2], 16);\n-                    return Character.toUpperCase(cp2) != cp1 && Character.toLowerCase(cp2) != cp1;\n-                 })\n-                .map(cols -> String.format(\"        entry(0x%s, 0x%s),\", cols[0], cols[2]))\n-                .collect(Collectors.joining(\"\\n\"))\n-                .replaceFirst(\",$\", \"\");  \/\/ remove the last ','\n+        var caseFoldingEntries = Files.lines(caseFoldingTxt)\n+            .filter(line -> !line.startsWith(\"#\") && line.matches(supportedTypes))\n+            .map(line -> {\n+                String[] cols = line.split(\"; \");\n+                return new String[] {cols[0], cols[1], cols[2]};\n+            })\n+            .filter(cols -> {\n+                \/\/  the folding case doesn't map back to the original char.\n+                var cp1 = Integer.parseInt(cols[0], 16);\n+                var cp2 = Integer.parseInt(cols[2], 16);\n+                return Character.toUpperCase(cp2) != cp1 && Character.toLowerCase(cp2) != cp1;\n+            })\n+            .map(cols -> String.format(\"        entry(0x%s, 0x%s)\", cols[0], cols[2]))\n+            .collect(Collectors.joining(\",\\n\", \"\", \"\"));\n@@ -62,14 +61,3 @@\n-            \/\/ hack, hack, hack! the logic does not pick 0131. just add manually to support 'I's.\n-            \/\/ 0049; T; 0131; # LATIN CAPITAL LETTER I\n-            final String T_0x0131_0x49 = String.format(\"        entry(0x%04x, 0x%04x),\\n\", 0x0131, 0x49);\n-\n-            \/\/ Generate .java file\n-            Files.write(\n-                genSrcFile,\n-                Files.lines(templateFile)\n-                    .map(line -> line.contains(\"%%%Entries\") ? T_0x0131_0x49 + caseFoldingEntries : line)\n-                    .collect(Collectors.toList()),\n-                StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n+        \/\/ hack, hack, hack! the logic does not pick 0131. just add manually to support 'I's.\n+        \/\/ 0049; T; 0131; # LATIN CAPITAL LETTER I\n+        final String T_0x0131_0x49 = String.format(\"        entry(0x%04x, 0x%04x),\\n\", 0x0131, 0x49);\n@@ -77,0 +65,7 @@\n+        \/\/ Generate .java file\n+        Files.write(\n+            genSrcFile,\n+            Files.lines(templateFile)\n+                .map(line -> line.contains(\"%%%Entries\") ? T_0x0131_0x49 + caseFoldingEntries : line)\n+                .collect(Collectors.toList()),\n+            StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);\n","filename":"make\/jdk\/src\/classes\/build\/tools\/generatecharacter\/CaseFolding.java","additions":25,"deletions":30,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    private static Map<Integer, Integer> expanded_casefolding = Map.ofEntries(\n+    private static final Map<Integer, Integer> expanded_casefolding = Map.ofEntries(\n@@ -53,1 +53,1 @@\n-     * RL1.5 states: To meet this requirement, an implementation that supports cse-sensitive matching should\n+     * RL1.5 states: To meet this requirement, an implementation that supports case-sensitive matching should\n@@ -56,1 +56,1 @@\n-     * <li>Specify which character properties or constructs are closed under the matching.\n+     * <li>Specify which character properties or constructs are closed under the matching.<\/li>\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/regex\/CaseFolding.java.template","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}