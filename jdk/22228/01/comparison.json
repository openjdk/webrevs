{"files":[{"patch":"@@ -36,0 +36,2 @@\n+#include <limits>\n+\n@@ -456,1 +458,1 @@\n-  const size_t old_garbage = old_used - old_live;\n+  const double old_garbage = double(old_used - old_live);\n@@ -461,1 +463,1 @@\n-  const size_t reclaimed_per_young_gc = stats._young_stats._stat_heap._reclaimed_avg;\n+  const double reclaimed_per_young_gc = stats._young_stats._stat_heap._reclaimed_avg;\n@@ -464,2 +466,8 @@\n-  const double current_young_gc_time_per_bytes_freed = double(young_gc_time) \/ double(reclaimed_per_young_gc);\n-  const double potential_young_gc_time_per_bytes_freed = double(young_gc_time) \/ double(reclaimed_per_young_gc + old_garbage);\n+  const double current_young_gc_time_per_bytes_freed = young_gc_time \/ reclaimed_per_young_gc;\n+  const double potential_young_gc_time_per_bytes_freed = young_gc_time \/ (reclaimed_per_young_gc + old_garbage);\n+\n+  if (current_young_gc_time_per_bytes_freed == std::numeric_limits<double>::infinity()) {\n+    \/\/ Young collection's are not reclaiming any memory. Return infinity as a signal\n+    \/\/ to trigger an old collection, regardless of the amount of old garbage.\n+    return std::numeric_limits<double>::infinity();\n+  }\n@@ -486,2 +494,2 @@\n-  const size_t reclaimed_per_young_gc = stats._young_stats._stat_heap._reclaimed_avg;\n-  const size_t reclaimed_per_old_gc = stats._old_stats._stat_heap._reclaimed_avg;\n+  const double reclaimed_per_young_gc = stats._young_stats._stat_heap._reclaimed_avg;\n+  const double reclaimed_per_old_gc = stats._old_stats._stat_heap._reclaimed_avg;\n@@ -490,3 +498,2 @@\n-  const double current_young_gc_time_per_bytes_freed = double(young_gc_time) \/ double(reclaimed_per_young_gc);\n-  const double current_old_gc_time_per_bytes_freed = reclaimed_per_old_gc == 0 ? std::numeric_limits<double>::infinity()\n-                                                                               : (double(old_gc_time) \/ double(reclaimed_per_old_gc));\n+  const double current_young_gc_time_per_bytes_freed = young_gc_time \/ reclaimed_per_young_gc;\n+  const double current_old_gc_time_per_bytes_freed = old_gc_time \/ reclaimed_per_old_gc;\n@@ -534,4 +541,4 @@\n-  const size_t reclaimed_per_young_gc = stats._young_stats._stat_heap._reclaimed_avg;\n-  const size_t reclaimed_per_old_gc = stats._old_stats._stat_heap._reclaimed_avg;\n-  const double current_young_bytes_freed_per_gc_time = double(reclaimed_per_young_gc) \/ double(young_gc_time);\n-  const double current_old_bytes_freed_per_gc_time = double(reclaimed_per_old_gc) \/ double(old_gc_time);\n+  const double reclaimed_per_young_gc = stats._young_stats._stat_heap._reclaimed_avg;\n+  const double reclaimed_per_old_gc = stats._old_stats._stat_heap._reclaimed_avg;\n+  const double current_young_bytes_freed_per_gc_time = reclaimed_per_young_gc \/ young_gc_time;\n+  const double current_old_bytes_freed_per_gc_time = reclaimed_per_old_gc \/ old_gc_time;\n","filename":"src\/hotspot\/share\/gc\/z\/zDirector.cpp","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+#include <limits>\n+\n@@ -1852,2 +1854,3 @@\n-size_t ZStatHeap::reclaimed_avg() {\n-  return (size_t)_reclaimed_bytes.davg();\n+double ZStatHeap::reclaimed_avg() {\n+  \/\/ Make sure the reclaimed average is greater than 0.0 to avoid division by zero.\n+  return _reclaimed_bytes.davg() + std::numeric_limits<double>::denorm_min();\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -591,1 +591,1 @@\n-  size_t _reclaimed_avg;\n+  double _reclaimed_avg;\n@@ -702,1 +702,1 @@\n-  size_t reclaimed_avg();\n+  double reclaimed_avg();\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}