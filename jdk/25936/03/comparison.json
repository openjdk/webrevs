{"files":[{"patch":"@@ -333,0 +333,1 @@\n+  friend class LibraryCallKit;\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+  assert(jvms->map() == kit.map(), \"Out of sync JVM state\");\n@@ -1727,2 +1728,1 @@\n-  uint old_sp = sp();\n-  SafePointNode* old_map = clone_map();\n+  SavedState old_state = clone_map_and_save_state();\n@@ -1734,2 +1734,1 @@\n-    set_map(old_map);\n-    set_sp(old_sp);\n+    restore_state(old_state);\n@@ -1738,1 +1737,1 @@\n-  destruct_map_clone(old_map);\n+  destruct_map_clone(old_state);\n@@ -2376,0 +2375,35 @@\n+LibraryCallKit::SavedState LibraryCallKit::clone_map_and_save_state() {\n+  SavedState state;\n+  state.sp = sp();\n+  state.jvms = jvms();\n+  state.map = clone_map();\n+  for (DUIterator_Fast imax, i = control()->fast_outs(imax); i < imax; i++) {\n+    Node* out = control()->fast_out(i);\n+    if (out->is_CFG()) {\n+      state.ctrl_succ.push(out);\n+    }\n+  }\n+  return state;\n+}\n+\n+void LibraryCallKit::restore_state(const SavedState& state) {\n+  jvms()->set_map(state.map);\n+  jvms()->set_sp(state.sp);\n+  state.map->set_jvms(jvms());\n+  set_map(state.map);\n+  set_sp(state.sp);\n+  for (DUIterator_Fast imax, i = control()->fast_outs(imax); i < imax; i++) {\n+    Node* out = control()->fast_out(i);\n+    if (out->is_CFG() && out->in(0) == control() && out != map() && !state.ctrl_succ.member(out)) {\n+      _gvn.hash_delete(out);\n+      out->set_req(0, C->top());\n+      C->record_for_igvn(out);\n+      --i; --imax;\n+    }\n+  }\n+}\n+\n+void LibraryCallKit::destruct_map_clone(const SavedState& state) {\n+  GraphKit::destruct_map_clone(state.map);\n+}\n+\n@@ -2437,2 +2471,1 @@\n-  uint old_sp = sp();\n-  SafePointNode* old_map = clone_map();\n+  SavedState old_state = clone_map_and_save_state();\n@@ -2447,2 +2480,1 @@\n-      set_map(old_map);\n-      set_sp(old_sp);\n+      restore_state(old_state);\n@@ -2466,2 +2498,1 @@\n-    set_map(old_map);\n-    set_sp(old_sp);\n+    restore_state(old_state);\n@@ -2476,3 +2507,2 @@\n-      alias_type->adr_type() == TypeAryPtr::RANGE) {\n-    set_map(old_map);\n-    set_sp(old_sp);\n+  alias_type->adr_type() == TypeAryPtr::RANGE) {\n+    restore_state(old_state);\n@@ -2497,2 +2527,1 @@\n-      set_map(old_map);\n-      set_sp(old_sp);\n+      restore_state(old_state);\n@@ -2506,1 +2535,1 @@\n-  destruct_map_clone(old_map);\n+  destruct_map_clone(old_state);\n@@ -2742,2 +2771,1 @@\n-  uint old_sp = sp();\n-  SafePointNode* old_map = clone_map();\n+  SavedState old_state = clone_map_and_save_state();\n@@ -2752,2 +2780,1 @@\n-    set_map(old_map);\n-    set_sp(old_sp);\n+    restore_state(old_state);\n@@ -2757,1 +2784,1 @@\n-  destruct_map_clone(old_map);\n+  destruct_map_clone(old_state);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":49,"deletions":22,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -132,0 +132,19 @@\n+  \/* When an intrinsic makes changes before bailing out, it's necessary to restore the graph\n+   * as it was. See JDK-8359344 for what can happen wrong. It's also not always possible to\n+   * bailout before making changes because the bailing out decision might depend on new nodes\n+   * (their types, for instance).\n+   *\n+   * So, if an intrinsic might cause this situation, one must start by saving the state in a\n+   * SavedState using clone_map_and_save_state, and before returning in case of bailing out,\n+   * fix the graph using restore_state.\n+   *\/\n+  struct SavedState {\n+    uint sp;\n+    JVMState* jvms;\n+    SafePointNode* map;\n+    Unique_Node_List ctrl_succ;\n+  };\n+  SavedState clone_map_and_save_state();\n+  void restore_state(const SavedState&);\n+  void destruct_map_clone(const SavedState& sfp);\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -825,2 +825,1 @@\n-  uint old_sp = sp();\n-  SafePointNode* old_map = clone_map();\n+  SavedState old_state = clone_map_and_save_state();\n@@ -863,2 +862,1 @@\n-    set_map(old_map);\n-    set_sp(old_sp);\n+    restore_state(old_state);\n@@ -876,2 +874,1 @@\n-        set_map(old_map);\n-        set_sp(old_sp);\n+        restore_state(old_state);\n@@ -886,2 +883,1 @@\n-        set_map(old_map);\n-        set_sp(old_sp);\n+        restore_state(old_state);\n@@ -895,2 +891,1 @@\n-        set_map(old_map);\n-        set_sp(old_sp);\n+        restore_state(old_state);\n@@ -901,2 +896,1 @@\n-        set_map(old_map);\n-        set_sp(old_sp);\n+        restore_state(old_state);\n@@ -917,2 +911,1 @@\n-      set_map(old_map);\n-      set_sp(old_sp);\n+      restore_state(old_state);\n@@ -955,1 +948,1 @@\n-  destruct_map_clone(old_map);\n+  destruct_map_clone(old_state);\n@@ -1032,2 +1025,1 @@\n-  uint old_sp = sp();\n-  SafePointNode* old_map = clone_map();\n+  SavedState old_state = clone_map_and_save_state();\n@@ -1046,2 +1038,1 @@\n-    set_map(old_map);\n-    set_sp(old_sp);\n+    restore_state(old_state);\n@@ -1069,2 +1060,1 @@\n-        set_map(old_map);\n-        set_sp(old_sp);\n+        restore_state(old_state);\n@@ -1080,2 +1070,1 @@\n-      set_map(old_map);\n-      set_sp(old_sp);\n+      restore_state(old_state);\n@@ -1092,2 +1081,1 @@\n-    set_map(old_map);\n-    set_sp(old_sp);\n+    restore_state(old_state);\n@@ -1104,2 +1092,1 @@\n-      set_map(old_map);\n-      set_sp(old_sp);\n+      restore_state(old_state);\n@@ -1116,2 +1103,1 @@\n-    set_map(old_map);\n-    set_sp(old_sp);\n+    restore_state(old_state);\n@@ -1138,2 +1124,1 @@\n-    set_map(old_map);\n-    set_sp(old_sp);\n+    restore_state(old_state);\n@@ -1148,2 +1133,1 @@\n-      set_map(old_map);\n-      set_sp(old_sp);\n+      restore_state(old_state);\n@@ -1196,1 +1180,1 @@\n-  destruct_map_clone(old_map);\n+  destruct_map_clone(old_state);\n@@ -1319,2 +1303,1 @@\n-  uint old_sp = sp();\n-  SafePointNode* old_map = clone_map();\n+  SavedState old_state = clone_map_and_save_state();\n@@ -1342,2 +1325,1 @@\n-    set_map(old_map);\n-    set_sp(old_sp);\n+    restore_state(old_state);\n@@ -1351,2 +1333,1 @@\n-    set_map(old_map);\n-    set_sp(old_sp);\n+    restore_state(old_state);\n@@ -1367,2 +1348,1 @@\n-      set_map(old_map);\n-      set_sp(old_sp);\n+      restore_state(old_state);\n@@ -1381,2 +1361,1 @@\n-      set_map(old_map);\n-      set_sp(old_sp);\n+      restore_state(old_state);\n@@ -1391,2 +1370,1 @@\n-      set_map(old_map);\n-      set_sp(old_sp);\n+      restore_state(old_state);\n@@ -1415,1 +1393,1 @@\n-  destruct_map_clone(old_map);\n+  destruct_map_clone(old_state);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":25,"deletions":47,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.intrinsics;\n+\n+\/*\n+ * @test\n+ * @bug 8359344\n+ * @summary Intrinsic storeMasked can add some control flow before bailing out, leaving a malformed CFG.\n+ * @modules jdk.incubator.vector\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:TypeProfileLevel=222 -Xbatch\n+ *                   -XX:CompileCommand=compileonly,jdk.incubator.vector.Long*::intoArray0\n+ *                   -XX:+AbortVMOnCompilationFailure\n+ *                    compiler.intrinsics.VectorIntoArrayInvalidControlFlow\n+ *\n+ * @run main compiler.intrinsics.VectorIntoArrayInvalidControlFlow\n+ *\/\n+\n+import jdk.incubator.vector.*;\n+\n+public class VectorIntoArrayInvalidControlFlow {\n+    private static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_128;\n+    private static final LongVector longVector;\n+    private static final long[] longArray = new long[L_SPECIES.length()];\n+    private static final boolean[] longMask = new boolean[L_SPECIES.length()];\n+    private static final VectorMask<Long> longVectorMask;\n+\n+    static {\n+        for (int i = 0; i < L_SPECIES.length(); i++) {\n+            longArray[i] = i + 1;\n+            longMask[i] = L_SPECIES.length() > 1 && i % 2 == 0;\n+        }\n+        longVector = LongVector.fromArray(L_SPECIES, longArray, 0);\n+        longVectorMask = VectorMask.fromArray(L_SPECIES, longMask, 0);\n+    }\n+\n+    static long[] test() {\n+        long[] res = new long[L_SPECIES.length()];\n+        for(int j = 0; j < 10_000; j++) {\n+            longVector.intoArray(res, 0, longVectorMask);\n+        }\n+        return res;\n+    }\n+\n+    static public void main(String[] args) {\n+        test();\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/VectorIntoArrayInvalidControlFlow.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -102,3 +102,3 @@\n-    private static final String START = \"(\\\\d+(\\\\s){2}(\";\n-    private static final String MID = \".*)+(\\\\s){2}===.*\";\n-    private static final String END = \")\";\n+    public static final String START = \"(\\\\d+(\\\\s){2}(\";\n+    public static final String MID = \".*)+(\\\\s){2}===.*\";\n+    public static final String END = \")\";\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8155781\n+ * @bug 8155781 8359344\n@@ -28,21 +28,2 @@\n- *\n- * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n- *                                 -XX:-TieredCompilation -Xbatch\n- *                                 -XX:+UseCompressedOops -XX:+UseCompressedClassPointers\n- *                                 -XX:CompileCommand=dontinline,compiler.unsafe.OpaqueAccesses::test*\n- *                                 compiler.unsafe.OpaqueAccesses\n- * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n- *                                 -XX:-TieredCompilation -Xbatch\n- *                                 -XX:+UseCompressedOops -XX:-UseCompressedClassPointers\n- *                                 -XX:CompileCommand=dontinline,compiler.unsafe.OpaqueAccesses::test*\n- *                                 compiler.unsafe.OpaqueAccesses\n- * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n- *                                 -XX:-TieredCompilation -Xbatch\n- *                                 -XX:-UseCompressedOops -XX:+UseCompressedClassPointers\n- *                                 -XX:CompileCommand=dontinline,compiler.unsafe.OpaqueAccesses::test*\n- *                                 compiler.unsafe.OpaqueAccesses\n- * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n- *                                 -XX:-TieredCompilation -Xbatch\n- *                                 -XX:-UseCompressedOops -XX:-UseCompressedClassPointers\n- *                                 -XX:CompileCommand=dontinline,compiler.unsafe.OpaqueAccesses::test*\n- *                                 compiler.unsafe.OpaqueAccesses\n+ * @library \/test\/lib \/\n+ * @run driver compiler.unsafe.OpaqueAccesses\n@@ -52,0 +33,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -80,0 +63,18 @@\n+    \/\/ To the end of a line, a new line character, repeated.\n+    private static final String FULL_LINES = \"(.*\\\\R)*\";\n+    \/\/ Finish the line after the node type, skips full line, and eats until before the node types\n+    private static final String SKIP = IRNode.MID + IRNode.END + \"\\\\R\" + FULL_LINES + \"\\\\s*\" + IRNode.START;\n+\n+    private static final String CALL_STATIC_JAVA_AND_THEN_OPAQUE_NOT_NULL = IRNode.START + \"CallStaticJava\" + SKIP + \"OpaqueNotNull\" + IRNode.MID + IRNode.END;\n+    private static final String OPAQUE_NOT_NULL_AND_THEN_CALL_STATIC_JAVA = IRNode.START + \"OpaqueNotNull\" + SKIP + \"CallStaticJava\" + IRNode.MID + IRNode.END;\n+    \/* Having both CallStaticJava and OpaqueNotNull, in any order. We use that in a failOn to make sure we have one\n+     * or the other (or none), but not both.\n+     * The CallStaticJava happens when the call is not intrinsified, and the OpaqueNotNull comes from the intrinsic.\n+     * We don't want a unfinished intrinsic, with the call nevertheless.\n+     *\/\n+    private static final String BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL =\n+            \"(\" + CALL_STATIC_JAVA_AND_THEN_OPAQUE_NOT_NULL + \") | (\" + OPAQUE_NOT_NULL_AND_THEN_CALL_STATIC_JAVA + \")\";\n+\n+\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -84,0 +85,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -88,0 +91,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -92,0 +97,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -96,0 +103,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -100,0 +109,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -104,0 +115,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -108,0 +121,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -112,0 +127,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -116,0 +133,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -120,0 +139,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -124,0 +145,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -128,0 +151,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -132,0 +157,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -136,0 +163,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -140,0 +169,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -144,0 +175,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -148,0 +181,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -155,0 +190,1 @@\n+    @Test\n@@ -162,25 +198,44 @@\n-    public static void main(String[] args) {\n-        for (int i = 0; i < 20_000; i++) {\n-            \/\/ Instance\n-            testFixedOffsetField(INSTANCE);\n-            testFixedOffsetHeader0(INSTANCE);\n-            testFixedOffsetHeader4(INSTANCE);\n-            testFixedOffsetHeader8(INSTANCE);\n-            testFixedOffsetHeader12(INSTANCE);\n-            testFixedOffsetHeader16(INSTANCE);\n-            testFixedOffsetHeader17(INSTANCE);\n-            testFixedBase(F_OFFSET);\n-            testOpaque(INSTANCE, F_OFFSET);\n-            testMixedAccess();\n-\n-            \/\/ Array\n-            testFixedOffsetHeaderArray0(ARRAY);\n-            testFixedOffsetHeaderArray4(ARRAY);\n-            testFixedOffsetHeaderArray8(ARRAY);\n-            testFixedOffsetHeaderArray12(ARRAY);\n-            testFixedOffsetHeaderArray16(ARRAY);\n-            testFixedOffsetHeaderArray17(ARRAY);\n-            testFixedOffsetArray(ARRAY);\n-            testFixedBaseArray(E_OFFSET);\n-            testOpaqueArray(ARRAY, E_OFFSET);\n-        }\n+    @Run(test = {\n+            \"testFixedOffsetField\",\n+            \"testFixedOffsetHeader0\",\n+            \"testFixedOffsetHeader4\",\n+            \"testFixedOffsetHeader8\",\n+            \"testFixedOffsetHeader12\",\n+            \"testFixedOffsetHeader16\",\n+            \"testFixedOffsetHeader17\",\n+            \"testFixedBase\",\n+            \"testOpaque\",\n+            \"testMixedAccess\",\n+            \"testFixedOffsetHeaderArray0\",\n+            \"testFixedOffsetHeaderArray4\",\n+            \"testFixedOffsetHeaderArray8\",\n+            \"testFixedOffsetHeaderArray12\",\n+            \"testFixedOffsetHeaderArray16\",\n+            \"testFixedOffsetHeaderArray17\",\n+            \"testFixedOffsetArray\",\n+            \"testFixedBaseArray\",\n+            \"testOpaqueArray\",\n+    })\n+    public static void runMethod() {\n+        \/\/ Instance\n+        testFixedOffsetField(INSTANCE);\n+        testFixedOffsetHeader0(INSTANCE);\n+        testFixedOffsetHeader4(INSTANCE);\n+        testFixedOffsetHeader8(INSTANCE);\n+        testFixedOffsetHeader12(INSTANCE);\n+        testFixedOffsetHeader16(INSTANCE);\n+        testFixedOffsetHeader17(INSTANCE);\n+        testFixedBase(F_OFFSET);\n+        testOpaque(INSTANCE, F_OFFSET);\n+        testMixedAccess();\n+\n+        \/\/ Array\n+        testFixedOffsetHeaderArray0(ARRAY);\n+        testFixedOffsetHeaderArray4(ARRAY);\n+        testFixedOffsetHeaderArray8(ARRAY);\n+        testFixedOffsetHeaderArray12(ARRAY);\n+        testFixedOffsetHeaderArray16(ARRAY);\n+        testFixedOffsetHeaderArray17(ARRAY);\n+        testFixedOffsetArray(ARRAY);\n+        testFixedBaseArray(E_OFFSET);\n+        testOpaqueArray(ARRAY, E_OFFSET);\n@@ -189,0 +244,31 @@\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\n+                \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:-TieredCompilation\", \"-Xbatch\",\n+                \"-XX:+UseCompressedOops\", \"-XX:+UseCompressedClassPointers\",\n+                \"-XX:CompileCommand=dontinline,compiler.unsafe.OpaqueAccesses::test*\"\n+        );\n+        TestFramework.runWithFlags(\n+                \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:-TieredCompilation\", \"-Xbatch\",\n+                \"-XX:+UseCompressedOops\", \"-XX:-UseCompressedClassPointers\",\n+                \"-XX:CompileCommand=dontinline,compiler.unsafe.OpaqueAccesses::test*\"\n+        );\n+        TestFramework.runWithFlags(\n+                \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:-TieredCompilation\", \"-Xbatch\",\n+                \"-XX:-UseCompressedOops\", \"-XX:+UseCompressedClassPointers\",\n+                \"-XX:CompileCommand=dontinline,compiler.unsafe.OpaqueAccesses::test*\"\n+        );\n+        TestFramework.runWithFlags(\n+                \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:-TieredCompilation\", \"-Xbatch\",\n+                \"-XX:-UseCompressedOops\", \"-XX:-UseCompressedClassPointers\",\n+                \"-XX:CompileCommand=dontinline,compiler.unsafe.OpaqueAccesses::test*\"\n+        );\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/OpaqueAccesses.java","additions":133,"deletions":47,"binary":false,"changes":180,"status":"modified"}]}