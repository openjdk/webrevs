{"files":[{"patch":"@@ -333,0 +333,1 @@\n+  friend class LibraryCallKit;\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+  assert(jvms->map() == kit.map(), \"Out of sync JVM state\");\n@@ -1727,2 +1728,1 @@\n-  uint old_sp = sp();\n-  SafePointNode* old_map = clone_map();\n+  SavedState old_state(this);\n@@ -1734,2 +1734,0 @@\n-    set_map(old_map);\n-    set_sp(old_sp);\n@@ -1738,1 +1736,1 @@\n-  destruct_map_clone(old_map);\n+  old_state.discard();\n@@ -2376,0 +2374,39 @@\n+LibraryCallKit::SavedState::SavedState(LibraryCallKit* kit) :\n+  _kit(kit),\n+  _sp(kit->sp()),\n+  _jvms(kit->jvms()),\n+  _map(kit->clone_map())\n+{\n+  for (DUIterator_Fast imax, i = kit->control()->fast_outs(imax); i < imax; i++) {\n+    Node* out = kit->control()->fast_out(i);\n+    if (out->is_CFG()) {\n+      _ctrl_succ.push(out);\n+    }\n+  }\n+}\n+\n+LibraryCallKit::SavedState::~SavedState() {\n+  if (discarded) {\n+    return;\n+  }\n+  _kit->jvms()->set_map(_map);\n+  _kit->jvms()->set_sp(_sp);\n+  _map->set_jvms(_kit->jvms());\n+  _kit->set_map(_map);\n+  _kit->set_sp(_sp);\n+  for (DUIterator_Fast imax, i = _kit->control()->fast_outs(imax); i < imax; i++) {\n+    Node* out = _kit->control()->fast_out(i);\n+    if (out->is_CFG() && out->in(0) == _kit->control() && out != _kit->map() && !_ctrl_succ.member(out)) {\n+      _kit->_gvn.hash_delete(out);\n+      out->set_req(0, _kit->C->top());\n+      _kit->C->record_for_igvn(out);\n+      --i; --imax;\n+      _kit->_gvn.hash_find_insert(out);\n+    }\n+  }\n+}\n+\n+void LibraryCallKit::SavedState::discard() {\n+  discarded = true;\n+}\n+\n@@ -2437,2 +2474,1 @@\n-  uint old_sp = sp();\n-  SafePointNode* old_map = clone_map();\n+  SavedState old_state(this);\n@@ -2447,2 +2483,0 @@\n-      set_map(old_map);\n-      set_sp(old_sp);\n@@ -2466,2 +2500,0 @@\n-    set_map(old_map);\n-    set_sp(old_sp);\n@@ -2477,2 +2509,0 @@\n-    set_map(old_map);\n-    set_sp(old_sp);\n@@ -2497,2 +2527,0 @@\n-      set_map(old_map);\n-      set_sp(old_sp);\n@@ -2506,1 +2534,1 @@\n-  destruct_map_clone(old_map);\n+  old_state.discard();\n@@ -2742,2 +2770,1 @@\n-  uint old_sp = sp();\n-  SafePointNode* old_map = clone_map();\n+  SavedState old_state(this);\n@@ -2752,2 +2779,0 @@\n-    set_map(old_map);\n-    set_sp(old_sp);\n@@ -2757,1 +2782,1 @@\n-  destruct_map_clone(old_map);\n+  old_state.discard();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":46,"deletions":21,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -132,0 +132,23 @@\n+  \/* When an intrinsic makes changes before bailing out, it's necessary to restore the graph\n+   * as it was. See JDK-8359344 for what can happen wrong. It's also not always possible to\n+   * bailout before making changes because the bailing out decision might depend on new nodes\n+   * (their types, for instance).\n+   *\n+   * So, if an intrinsic might cause this situation, one must start by saving the state in a\n+   * SavedState by constructing it, and the state will be restored on destruction. If the\n+   * intrinsic is not bailing out, one need to call discard to prevent restoring the old state.\n+   *\/\n+  class SavedState {\n+    LibraryCallKit* _kit;\n+    uint _sp;\n+    JVMState* _jvms;\n+    SafePointNode* _map;\n+    Unique_Node_List _ctrl_succ;\n+    bool discarded = false;\n+\n+  public:\n+    SavedState(LibraryCallKit*);\n+    ~SavedState();\n+    void discard();\n+  };\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -825,2 +825,1 @@\n-  uint old_sp = sp();\n-  SafePointNode* old_map = clone_map();\n+  SavedState old_state(this);\n@@ -863,2 +862,0 @@\n-    set_map(old_map);\n-    set_sp(old_sp);\n@@ -876,2 +873,0 @@\n-        set_map(old_map);\n-        set_sp(old_sp);\n@@ -886,2 +881,0 @@\n-        set_map(old_map);\n-        set_sp(old_sp);\n@@ -895,2 +888,0 @@\n-        set_map(old_map);\n-        set_sp(old_sp);\n@@ -901,2 +892,0 @@\n-        set_map(old_map);\n-        set_sp(old_sp);\n@@ -917,2 +906,0 @@\n-      set_map(old_map);\n-      set_sp(old_sp);\n@@ -955,1 +942,1 @@\n-  destruct_map_clone(old_map);\n+  old_state.discard();\n@@ -1032,2 +1019,1 @@\n-  uint old_sp = sp();\n-  SafePointNode* old_map = clone_map();\n+  SavedState old_state(this);\n@@ -1046,2 +1032,0 @@\n-    set_map(old_map);\n-    set_sp(old_sp);\n@@ -1069,2 +1053,0 @@\n-        set_map(old_map);\n-        set_sp(old_sp);\n@@ -1080,2 +1062,0 @@\n-      set_map(old_map);\n-      set_sp(old_sp);\n@@ -1092,2 +1072,0 @@\n-    set_map(old_map);\n-    set_sp(old_sp);\n@@ -1104,2 +1082,0 @@\n-      set_map(old_map);\n-      set_sp(old_sp);\n@@ -1116,2 +1092,0 @@\n-    set_map(old_map);\n-    set_sp(old_sp);\n@@ -1138,2 +1112,0 @@\n-    set_map(old_map);\n-    set_sp(old_sp);\n@@ -1148,2 +1120,0 @@\n-      set_map(old_map);\n-      set_sp(old_sp);\n@@ -1196,1 +1166,1 @@\n-  destruct_map_clone(old_map);\n+  old_state.discard();\n@@ -1319,2 +1289,1 @@\n-  uint old_sp = sp();\n-  SafePointNode* old_map = clone_map();\n+  SavedState old_state(this);\n@@ -1342,2 +1311,0 @@\n-    set_map(old_map);\n-    set_sp(old_sp);\n@@ -1351,2 +1318,0 @@\n-    set_map(old_map);\n-    set_sp(old_sp);\n@@ -1367,2 +1332,0 @@\n-      set_map(old_map);\n-      set_sp(old_sp);\n@@ -1381,2 +1344,0 @@\n-      set_map(old_map);\n-      set_sp(old_sp);\n@@ -1391,2 +1352,0 @@\n-      set_map(old_map);\n-      set_sp(old_sp);\n@@ -1415,1 +1374,1 @@\n-  destruct_map_clone(old_map);\n+  old_state.discard();\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":6,"deletions":47,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.intrinsics;\n+\n+\/*\n+ * @test\n+ * @bug 8359344\n+ * @summary Intrinsic storeMasked can add some control flow before bailing out, leaving a malformed CFG.\n+ * @modules jdk.incubator.vector\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:TypeProfileLevel=222 -Xbatch\n+ *                   -XX:CompileCommand=compileonly,jdk.incubator.vector.Long*::intoArray0\n+ *                   -XX:+AbortVMOnCompilationFailure\n+ *                    compiler.intrinsics.VectorIntoArrayInvalidControlFlow\n+ *\n+ * @run main compiler.intrinsics.VectorIntoArrayInvalidControlFlow\n+ *\/\n+\n+import jdk.incubator.vector.*;\n+\n+public class VectorIntoArrayInvalidControlFlow {\n+    private static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_128;\n+    private static final LongVector longVector;\n+    private static final long[] longArray = new long[L_SPECIES.length()];\n+    private static final boolean[] longMask = new boolean[L_SPECIES.length()];\n+    private static final VectorMask<Long> longVectorMask;\n+\n+    static {\n+        for (int i = 0; i < L_SPECIES.length(); i++) {\n+            longArray[i] = i + 1;\n+            longMask[i] = L_SPECIES.length() > 1 && i % 2 == 0;\n+        }\n+        longVector = LongVector.fromArray(L_SPECIES, longArray, 0);\n+        longVectorMask = VectorMask.fromArray(L_SPECIES, longMask, 0);\n+    }\n+\n+    static long[] test() {\n+        long[] res = new long[L_SPECIES.length()];\n+        for(int j = 0; j < 10_000; j++) {\n+            longVector.intoArray(res, 0, longVectorMask);\n+        }\n+        return res;\n+    }\n+\n+    static public void main(String[] args) {\n+        test();\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/VectorIntoArrayInvalidControlFlow.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -102,3 +102,3 @@\n-    private static final String START = \"(\\\\d+(\\\\s){2}(\";\n-    private static final String MID = \".*)+(\\\\s){2}===.*\";\n-    private static final String END = \")\";\n+    public static final String START = \"(\\\\d+(\\\\s){2}(\";\n+    public static final String MID = \".*)+(\\\\s){2}===.*\";\n+    public static final String END = \")\";\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8155781\n+ * @bug 8155781 8359344\n@@ -28,21 +28,2 @@\n- *\n- * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n- *                                 -XX:-TieredCompilation -Xbatch\n- *                                 -XX:+UseCompressedOops -XX:+UseCompressedClassPointers\n- *                                 -XX:CompileCommand=dontinline,compiler.unsafe.OpaqueAccesses::test*\n- *                                 compiler.unsafe.OpaqueAccesses\n- * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n- *                                 -XX:-TieredCompilation -Xbatch\n- *                                 -XX:+UseCompressedOops -XX:-UseCompressedClassPointers\n- *                                 -XX:CompileCommand=dontinline,compiler.unsafe.OpaqueAccesses::test*\n- *                                 compiler.unsafe.OpaqueAccesses\n- * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n- *                                 -XX:-TieredCompilation -Xbatch\n- *                                 -XX:-UseCompressedOops -XX:+UseCompressedClassPointers\n- *                                 -XX:CompileCommand=dontinline,compiler.unsafe.OpaqueAccesses::test*\n- *                                 compiler.unsafe.OpaqueAccesses\n- * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n- *                                 -XX:-TieredCompilation -Xbatch\n- *                                 -XX:-UseCompressedOops -XX:-UseCompressedClassPointers\n- *                                 -XX:CompileCommand=dontinline,compiler.unsafe.OpaqueAccesses::test*\n- *                                 compiler.unsafe.OpaqueAccesses\n+ * @library \/test\/lib \/\n+ * @run driver compiler.unsafe.OpaqueAccesses\n@@ -52,0 +33,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -80,0 +63,18 @@\n+    \/\/ To the end of a line, a new line character, repeated.\n+    private static final String FULL_LINES = \"(.*\\\\R)*\";\n+    \/\/ Finish the line after the node type, skips full line, and eats until before the node types\n+    private static final String SKIP = IRNode.MID + IRNode.END + \"\\\\R\" + FULL_LINES + \"\\\\s*\" + IRNode.START;\n+\n+    private static final String CALL_STATIC_JAVA_AND_THEN_OPAQUE_NOT_NULL = IRNode.START + \"CallStaticJava\" + SKIP + \"OpaqueNotNull\" + IRNode.MID + IRNode.END;\n+    private static final String OPAQUE_NOT_NULL_AND_THEN_CALL_STATIC_JAVA = IRNode.START + \"OpaqueNotNull\" + SKIP + \"CallStaticJava\" + IRNode.MID + IRNode.END;\n+    \/* Having both CallStaticJava and OpaqueNotNull, in any order. We use that in a failOn to make sure we have one\n+     * or the other (or none), but not both.\n+     * The CallStaticJava happens when the call is not intrinsified, and the OpaqueNotNull comes from the intrinsic.\n+     * We don't want a unfinished intrinsic, with the call nevertheless.\n+     *\/\n+    private static final String BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL =\n+            \"(\" + CALL_STATIC_JAVA_AND_THEN_OPAQUE_NOT_NULL + \") | (\" + OPAQUE_NOT_NULL_AND_THEN_CALL_STATIC_JAVA + \")\";\n+\n+\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -84,0 +85,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -88,0 +91,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -92,0 +97,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -96,0 +103,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -100,0 +109,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -104,0 +115,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -108,0 +121,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -112,0 +127,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -116,0 +133,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -120,0 +139,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -124,0 +145,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -128,0 +151,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -132,0 +157,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -136,0 +163,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -140,0 +169,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -144,0 +175,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -148,0 +181,2 @@\n+    @Test\n+    @IR(failOn = {BOTH_CALL_STATIC_JAVA_AND_OPAQUE_NOT_NULL}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n@@ -155,0 +190,1 @@\n+    @Test\n@@ -162,25 +198,44 @@\n-    public static void main(String[] args) {\n-        for (int i = 0; i < 20_000; i++) {\n-            \/\/ Instance\n-            testFixedOffsetField(INSTANCE);\n-            testFixedOffsetHeader0(INSTANCE);\n-            testFixedOffsetHeader4(INSTANCE);\n-            testFixedOffsetHeader8(INSTANCE);\n-            testFixedOffsetHeader12(INSTANCE);\n-            testFixedOffsetHeader16(INSTANCE);\n-            testFixedOffsetHeader17(INSTANCE);\n-            testFixedBase(F_OFFSET);\n-            testOpaque(INSTANCE, F_OFFSET);\n-            testMixedAccess();\n-\n-            \/\/ Array\n-            testFixedOffsetHeaderArray0(ARRAY);\n-            testFixedOffsetHeaderArray4(ARRAY);\n-            testFixedOffsetHeaderArray8(ARRAY);\n-            testFixedOffsetHeaderArray12(ARRAY);\n-            testFixedOffsetHeaderArray16(ARRAY);\n-            testFixedOffsetHeaderArray17(ARRAY);\n-            testFixedOffsetArray(ARRAY);\n-            testFixedBaseArray(E_OFFSET);\n-            testOpaqueArray(ARRAY, E_OFFSET);\n-        }\n+    @Run(test = {\n+            \"testFixedOffsetField\",\n+            \"testFixedOffsetHeader0\",\n+            \"testFixedOffsetHeader4\",\n+            \"testFixedOffsetHeader8\",\n+            \"testFixedOffsetHeader12\",\n+            \"testFixedOffsetHeader16\",\n+            \"testFixedOffsetHeader17\",\n+            \"testFixedBase\",\n+            \"testOpaque\",\n+            \"testMixedAccess\",\n+            \"testFixedOffsetHeaderArray0\",\n+            \"testFixedOffsetHeaderArray4\",\n+            \"testFixedOffsetHeaderArray8\",\n+            \"testFixedOffsetHeaderArray12\",\n+            \"testFixedOffsetHeaderArray16\",\n+            \"testFixedOffsetHeaderArray17\",\n+            \"testFixedOffsetArray\",\n+            \"testFixedBaseArray\",\n+            \"testOpaqueArray\",\n+    })\n+    public static void runMethod() {\n+        \/\/ Instance\n+        testFixedOffsetField(INSTANCE);\n+        testFixedOffsetHeader0(INSTANCE);\n+        testFixedOffsetHeader4(INSTANCE);\n+        testFixedOffsetHeader8(INSTANCE);\n+        testFixedOffsetHeader12(INSTANCE);\n+        testFixedOffsetHeader16(INSTANCE);\n+        testFixedOffsetHeader17(INSTANCE);\n+        testFixedBase(F_OFFSET);\n+        testOpaque(INSTANCE, F_OFFSET);\n+        testMixedAccess();\n+\n+        \/\/ Array\n+        testFixedOffsetHeaderArray0(ARRAY);\n+        testFixedOffsetHeaderArray4(ARRAY);\n+        testFixedOffsetHeaderArray8(ARRAY);\n+        testFixedOffsetHeaderArray12(ARRAY);\n+        testFixedOffsetHeaderArray16(ARRAY);\n+        testFixedOffsetHeaderArray17(ARRAY);\n+        testFixedOffsetArray(ARRAY);\n+        testFixedBaseArray(E_OFFSET);\n+        testOpaqueArray(ARRAY, E_OFFSET);\n@@ -189,0 +244,31 @@\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\n+                \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:-TieredCompilation\", \"-Xbatch\",\n+                \"-XX:+UseCompressedOops\", \"-XX:+UseCompressedClassPointers\",\n+                \"-XX:CompileCommand=dontinline,compiler.unsafe.OpaqueAccesses::test*\"\n+        );\n+        TestFramework.runWithFlags(\n+                \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:-TieredCompilation\", \"-Xbatch\",\n+                \"-XX:+UseCompressedOops\", \"-XX:-UseCompressedClassPointers\",\n+                \"-XX:CompileCommand=dontinline,compiler.unsafe.OpaqueAccesses::test*\"\n+        );\n+        TestFramework.runWithFlags(\n+                \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:-TieredCompilation\", \"-Xbatch\",\n+                \"-XX:-UseCompressedOops\", \"-XX:+UseCompressedClassPointers\",\n+                \"-XX:CompileCommand=dontinline,compiler.unsafe.OpaqueAccesses::test*\"\n+        );\n+        TestFramework.runWithFlags(\n+                \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:-TieredCompilation\", \"-Xbatch\",\n+                \"-XX:-UseCompressedOops\", \"-XX:-UseCompressedClassPointers\",\n+                \"-XX:CompileCommand=dontinline,compiler.unsafe.OpaqueAccesses::test*\"\n+        );\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/OpaqueAccesses.java","additions":133,"deletions":47,"binary":false,"changes":180,"status":"modified"}]}