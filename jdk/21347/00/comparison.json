{"files":[{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/g1\/g1CollectionSetCandidates.hpp\"\n+#include \"gc\/g1\/g1CollectionSetCandidates.inline.hpp\"\n@@ -349,5 +349,3 @@\n-      time_remaining_ms = _policy->select_candidates_from_marking(&candidates()->marking_regions(),\n-                                                                  time_remaining_ms,\n-                                                                  &initial_old_regions,\n-                                                                  &_optional_old_regions,\n-                                                                  &pinned_marking_regions);\n+      time_remaining_ms = select_candidates_from_marking(time_remaining_ms,\n+                                                         &initial_old_regions,\n+                                                         &pinned_marking_regions);\n@@ -358,5 +356,3 @@\n-    _policy->select_candidates_from_retained(&candidates()->retained_regions(),\n-                                             time_remaining_ms,\n-                                             &initial_old_regions,\n-                                             &_optional_old_regions,\n-                                             &pinned_retained_regions);\n+    select_candidates_from_retained(time_remaining_ms,\n+                                    &initial_old_regions,\n+                                    &pinned_retained_regions);\n@@ -397,0 +393,209 @@\n+static void print_finish_message(const char* reason, bool from_marking) {\n+  log_debug(gc, ergo, cset)(\"Finish adding %s candidates to collection set (%s).\",\n+                            from_marking ? \"marking\" : \"retained\", reason);\n+}\n+\n+double G1CollectionSet::select_candidates_from_marking(double time_remaining_ms,\n+                                                       G1CollectionCandidateRegionList* initial_old_regions,\n+                                                       G1CollectionCandidateRegionList* pinned_old_regions) {\n+  uint num_expensive_regions = 0;\n+\n+  uint num_initial_regions_selected = 0;\n+  uint num_optional_regions_selected = 0;\n+  uint num_pinned_regions = 0;\n+\n+  double predicted_initial_time_ms = 0.0;\n+  double predicted_optional_time_ms = 0.0;\n+\n+  double optional_threshold_ms = time_remaining_ms * _policy->optional_prediction_fraction();\n+\n+  const uint min_old_cset_length = _policy->calc_min_old_cset_length(candidates()->last_marking_candidates_length());\n+  const uint max_old_cset_length = MAX2(min_old_cset_length, _policy->calc_max_old_cset_length());\n+  const uint max_optional_regions = max_old_cset_length - min_old_cset_length;\n+  bool check_time_remaining = _policy->use_adaptive_young_list_length();\n+\n+  G1CollectionCandidateList* marking_list = &candidates()->marking_regions();\n+  assert(marking_list != nullptr, \"must be\");\n+\n+  log_debug(gc, ergo, cset)(\"Start adding marking candidates to collection set. \"\n+                            \"Min %u regions, max %u regions, available %u regions\"\n+                            \"time remaining %1.2fms, optional threshold %1.2fms\",\n+                            min_old_cset_length, max_old_cset_length, marking_list->length(), time_remaining_ms, optional_threshold_ms);\n+\n+  G1CollectionCandidateListIterator iter = marking_list->begin();\n+  for (; iter != marking_list->end(); ++iter) {\n+    if (num_initial_regions_selected + num_optional_regions_selected >= max_old_cset_length) {\n+      \/\/ Added maximum number of old regions to the CSet.\n+      print_finish_message(\"Maximum number of regions reached\", true);\n+      break;\n+    }\n+    G1HeapRegion* hr = (*iter)->_r;\n+    \/\/ Skip evacuating pinned marking regions because we are not getting any free\n+    \/\/ space from them (and we expect to get free space from marking candidates).\n+    \/\/ Also prepare to move them to retained regions to be evacuated optionally later\n+    \/\/ to not impact the mixed phase too much.\n+    if (hr->has_pinned_objects()) {\n+      num_pinned_regions++;\n+      (*iter)->update_num_unreclaimed();\n+      log_trace(gc, ergo, cset)(\"Marking candidate %u can not be reclaimed currently. Skipping.\", hr->hrm_index());\n+      pinned_old_regions->append(hr);\n+      continue;\n+    }\n+    double predicted_time_ms = _policy->predict_region_total_time_ms(hr, false);\n+    time_remaining_ms = MAX2(time_remaining_ms - predicted_time_ms, 0.0);\n+    \/\/ Add regions to old set until we reach the minimum amount\n+    if (initial_old_regions->length() < min_old_cset_length) {\n+      initial_old_regions->append(hr);\n+      num_initial_regions_selected++;\n+      predicted_initial_time_ms += predicted_time_ms;\n+      \/\/ Record the number of regions added with no time remaining\n+      if (time_remaining_ms == 0.0) {\n+        num_expensive_regions++;\n+      }\n+    } else if (!check_time_remaining) {\n+      \/\/ In the non-auto-tuning case, we'll finish adding regions\n+      \/\/ to the CSet if we reach the minimum.\n+      print_finish_message(\"Region amount reached min\", true);\n+      break;\n+    } else {\n+      \/\/ Keep adding regions to old set until we reach the optional threshold\n+      if (time_remaining_ms > optional_threshold_ms) {\n+        predicted_initial_time_ms += predicted_time_ms;\n+        initial_old_regions->append(hr);\n+        num_initial_regions_selected++;\n+      } else if (time_remaining_ms > 0) {\n+        \/\/ Keep adding optional regions until time is up.\n+        assert(_optional_old_regions.length() < max_optional_regions, \"Should not be possible.\");\n+        predicted_optional_time_ms += predicted_time_ms;\n+        _optional_old_regions.append(hr);\n+        num_optional_regions_selected++;\n+      } else {\n+        print_finish_message(\"Predicted time too high\", true);\n+        break;\n+      }\n+    }\n+  }\n+  if (iter == marking_list->end()) {\n+    log_debug(gc, ergo, cset)(\"Marking candidates exhausted.\");\n+  }\n+\n+  if (num_expensive_regions > 0) {\n+    log_debug(gc, ergo, cset)(\"Added %u marking candidates to collection set although the predicted time was too high.\",\n+                              num_expensive_regions);\n+  }\n+\n+  log_debug(gc, ergo, cset)(\"Finish adding marking candidates to collection set. Initial: %u, optional: %u, pinned: %u, \"\n+                            \"predicted initial time: %1.2fms, predicted optional time: %1.2fms, time remaining: %1.2fms\",\n+                            num_initial_regions_selected, num_optional_regions_selected, num_pinned_regions,\n+                            predicted_initial_time_ms, predicted_optional_time_ms, time_remaining_ms);\n+\n+  assert(initial_old_regions->length() == num_initial_regions_selected, \"must be\");\n+  assert(_optional_old_regions.length() == num_optional_regions_selected, \"must be\");\n+  return time_remaining_ms;\n+}\n+\n+void G1CollectionSet::select_candidates_from_retained(double time_remaining_ms,\n+                                                      G1CollectionCandidateRegionList* initial_old_regions,\n+                                                      G1CollectionCandidateRegionList* pinned_old_regions) {\n+  uint num_initial_regions_selected = 0;\n+  uint num_optional_regions_selected = 0;\n+  uint num_expensive_regions_selected = 0;\n+  uint num_pinned_regions = 0;\n+\n+  double predicted_initial_time_ms = 0.0;\n+  double predicted_optional_time_ms = 0.0;\n+\n+  uint const min_regions = _policy->min_retained_old_cset_length();\n+  \/\/ We want to make sure that on the one hand we process the retained regions asap,\n+  \/\/ but on the other hand do not take too many of them as optional regions.\n+  \/\/ So we split the time budget into budget we will unconditionally take into the\n+  \/\/ initial old regions, and budget for taking optional regions from the retained\n+  \/\/ list.\n+  double optional_time_remaining_ms = _policy->max_time_for_retaining();\n+  time_remaining_ms = MIN2(time_remaining_ms, optional_time_remaining_ms);\n+\n+  G1CollectionCandidateList* retained_list = &candidates()->retained_regions();\n+\n+  log_debug(gc, ergo, cset)(\"Start adding retained candidates to collection set. \"\n+                            \"Min %u regions, available %u, \"\n+                            \"time remaining %1.2fms, optional remaining %1.2fms\",\n+                            min_regions, retained_list->length(), time_remaining_ms, optional_time_remaining_ms);\n+\n+  for (G1CollectionSetCandidateInfo* ci : *retained_list) {\n+    G1HeapRegion* r = ci->_r;\n+    double predicted_time_ms = _policy->predict_region_total_time_ms(r, collector_state()->in_young_only_phase());\n+    bool fits_in_remaining_time = predicted_time_ms <= time_remaining_ms;\n+    \/\/ If we can't reclaim that region ignore it for now.\n+    if (r->has_pinned_objects()) {\n+      num_pinned_regions++;\n+      if (ci->update_num_unreclaimed()) {\n+        log_trace(gc, ergo, cset)(\"Retained candidate %u can not be reclaimed currently. Skipping.\", r->hrm_index());\n+      } else {\n+        log_trace(gc, ergo, cset)(\"Retained candidate %u can not be reclaimed currently. Dropping.\", r->hrm_index());\n+        pinned_old_regions->append(r);\n+      }\n+      continue;\n+    }\n+\n+    if (fits_in_remaining_time || (num_expensive_regions_selected < min_regions)) {\n+      predicted_initial_time_ms += predicted_time_ms;\n+      if (!fits_in_remaining_time) {\n+        num_expensive_regions_selected++;\n+      }\n+      initial_old_regions->append(r);\n+      num_initial_regions_selected++;\n+    } else if (predicted_time_ms <= optional_time_remaining_ms) {\n+      predicted_optional_time_ms += predicted_time_ms;\n+      _optional_old_regions.append(r);\n+      num_optional_regions_selected++;\n+    } else {\n+      \/\/ Fits neither initial nor optional time limit. Exit.\n+      break;\n+    }\n+    time_remaining_ms = MAX2(0.0, time_remaining_ms - predicted_time_ms);\n+    optional_time_remaining_ms = MAX2(0.0, optional_time_remaining_ms - predicted_time_ms);\n+  }\n+\n+  uint num_regions_selected = num_initial_regions_selected + num_optional_regions_selected;\n+  if (num_regions_selected == retained_list->length()) {\n+    log_debug(gc, ergo, cset)(\"Retained candidates exhausted.\");\n+  }\n+  if (num_expensive_regions_selected > 0) {\n+    log_debug(gc, ergo, cset)(\"Added %u retained candidates to collection set although the predicted time was too high.\",\n+                              num_expensive_regions_selected);\n+  }\n+\n+  log_debug(gc, ergo, cset)(\"Finish adding retained candidates to collection set. Initial: %u, optional: %u, pinned: %u, \"\n+                            \"predicted initial time: %1.2fms, predicted optional time: %1.2fms, \"\n+                            \"time remaining: %1.2fms optional time remaining %1.2fms\",\n+                            num_initial_regions_selected, num_optional_regions_selected, num_pinned_regions,\n+                            predicted_initial_time_ms, predicted_optional_time_ms, time_remaining_ms, optional_time_remaining_ms);\n+}\n+\n+void G1CollectionSet::select_candidates_from_optional_regions(double time_remaining_ms,\n+                                                              G1CollectionCandidateRegionList* selected_regions) {\n+  assert(optional_region_length() > 0,\n+         \"Should only be called when there are optional regions\");\n+\n+  double total_prediction_ms = 0.0;\n+\n+  for (G1HeapRegion* r : _optional_old_regions) {\n+    double prediction_ms = _policy->predict_region_total_time_ms(r, false);\n+\n+    if (prediction_ms > time_remaining_ms) {\n+      log_debug(gc, ergo, cset)(\"Prediction %.3fms for region %u does not fit remaining time: %.3fms.\",\n+                                prediction_ms, r->hrm_index(), time_remaining_ms);\n+      break;\n+    }\n+    \/\/ This region will be included in the next optional evacuation.\n+\n+    total_prediction_ms += prediction_ms;\n+    time_remaining_ms -= prediction_ms;\n+\n+    selected_regions->append(r);\n+  }\n+\n+  log_debug(gc, ergo, cset)(\"Prepared %u regions out of %u for optional evacuation. Total predicted time: %.3fms\",\n+                            selected_regions->length(), _optional_old_regions.length(), total_prediction_ms);\n+}\n+\n@@ -444,3 +649,2 @@\n-  _policy->calculate_optional_collection_set_regions(&_optional_old_regions,\n-                                                     remaining_pause_time,\n-                                                     &selected_regions);\n+  select_candidates_from_optional_regions(remaining_pause_time,\n+                                          &selected_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":218,"deletions":14,"binary":false,"changes":232,"status":"modified"},{"patch":"@@ -199,0 +199,16 @@\n+  \/\/ Calculate and fill in the initial, optional and pinned old gen candidate regions from\n+  \/\/ the given candidate list and the remaining time.\n+  \/\/ Returns the remaining time.\n+  double select_candidates_from_marking(double time_remaining_ms,\n+                                        G1CollectionCandidateRegionList* initial_old_regions,\n+                                        G1CollectionCandidateRegionList* pinned_old_regions);\n+\n+  void select_candidates_from_retained(double time_remaining_ms,\n+                                       G1CollectionCandidateRegionList* initial_old_regions,\n+                                       G1CollectionCandidateRegionList* pinned_old_regions);\n+\n+  \/\/ Calculate the number of optional regions from the given collection set candidates,\n+  \/\/ the remaining time and the maximum number of these regions.\n+  void select_candidates_from_optional_regions(double time_remaining_ms,\n+                                               G1CollectionCandidateRegionList* selected);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1470,213 +1470,0 @@\n-static void print_finish_message(const char* reason, bool from_marking) {\n-  log_debug(gc, ergo, cset)(\"Finish adding %s candidates to collection set (%s).\",\n-                            from_marking ? \"marking\" : \"retained\", reason);\n-}\n-\n-double G1Policy::select_candidates_from_marking(G1CollectionCandidateList* marking_list,\n-                                                double time_remaining_ms,\n-                                                G1CollectionCandidateRegionList* initial_old_regions,\n-                                                G1CollectionCandidateRegionList* optional_old_regions,\n-                                                G1CollectionCandidateRegionList* pinned_old_regions) {\n-  assert(marking_list != nullptr, \"must be\");\n-\n-  uint num_expensive_regions = 0;\n-\n-  uint num_initial_regions_selected = 0;\n-  uint num_optional_regions_selected = 0;\n-  uint num_pinned_regions = 0;\n-\n-  double predicted_initial_time_ms = 0.0;\n-  double predicted_optional_time_ms = 0.0;\n-\n-  double optional_threshold_ms = time_remaining_ms * optional_prediction_fraction();\n-\n-  const uint min_old_cset_length = calc_min_old_cset_length(candidates()->last_marking_candidates_length());\n-  const uint max_old_cset_length = MAX2(min_old_cset_length, calc_max_old_cset_length());\n-  const uint max_optional_regions = max_old_cset_length - min_old_cset_length;\n-  bool check_time_remaining = use_adaptive_young_list_length();\n-\n-  log_debug(gc, ergo, cset)(\"Start adding marking candidates to collection set. \"\n-                            \"Min %u regions, max %u regions, available %u regions\"\n-                            \"time remaining %1.2fms, optional threshold %1.2fms\",\n-                            min_old_cset_length, max_old_cset_length, marking_list->length(), time_remaining_ms, optional_threshold_ms);\n-\n-  G1CollectionCandidateListIterator iter = marking_list->begin();\n-  for (; iter != marking_list->end(); ++iter) {\n-    if (num_initial_regions_selected + num_optional_regions_selected >= max_old_cset_length) {\n-      \/\/ Added maximum number of old regions to the CSet.\n-      print_finish_message(\"Maximum number of regions reached\", true);\n-      break;\n-    }\n-    G1HeapRegion* hr = (*iter)->_r;\n-    \/\/ Skip evacuating pinned marking regions because we are not getting any free\n-    \/\/ space from them (and we expect to get free space from marking candidates).\n-    \/\/ Also prepare to move them to retained regions to be evacuated optionally later\n-    \/\/ to not impact the mixed phase too much.\n-    if (hr->has_pinned_objects()) {\n-      num_pinned_regions++;\n-      (*iter)->update_num_unreclaimed();\n-      log_trace(gc, ergo, cset)(\"Marking candidate %u can not be reclaimed currently. Skipping.\", hr->hrm_index());\n-      pinned_old_regions->append(hr);\n-      continue;\n-    }\n-    double predicted_time_ms = predict_region_total_time_ms(hr, false);\n-    time_remaining_ms = MAX2(time_remaining_ms - predicted_time_ms, 0.0);\n-    \/\/ Add regions to old set until we reach the minimum amount\n-    if (initial_old_regions->length() < min_old_cset_length) {\n-      initial_old_regions->append(hr);\n-      num_initial_regions_selected++;\n-      predicted_initial_time_ms += predicted_time_ms;\n-      \/\/ Record the number of regions added with no time remaining\n-      if (time_remaining_ms == 0.0) {\n-        num_expensive_regions++;\n-      }\n-    } else if (!check_time_remaining) {\n-      \/\/ In the non-auto-tuning case, we'll finish adding regions\n-      \/\/ to the CSet if we reach the minimum.\n-      print_finish_message(\"Region amount reached min\", true);\n-      break;\n-    } else {\n-      \/\/ Keep adding regions to old set until we reach the optional threshold\n-      if (time_remaining_ms > optional_threshold_ms) {\n-        predicted_initial_time_ms += predicted_time_ms;\n-        initial_old_regions->append(hr);\n-        num_initial_regions_selected++;\n-      } else if (time_remaining_ms > 0) {\n-        \/\/ Keep adding optional regions until time is up.\n-        assert(optional_old_regions->length() < max_optional_regions, \"Should not be possible.\");\n-        predicted_optional_time_ms += predicted_time_ms;\n-        optional_old_regions->append(hr);\n-        num_optional_regions_selected++;\n-      } else {\n-        print_finish_message(\"Predicted time too high\", true);\n-        break;\n-      }\n-    }\n-  }\n-  if (iter == marking_list->end()) {\n-    log_debug(gc, ergo, cset)(\"Marking candidates exhausted.\");\n-  }\n-\n-  if (num_expensive_regions > 0) {\n-    log_debug(gc, ergo, cset)(\"Added %u marking candidates to collection set although the predicted time was too high.\",\n-                              num_expensive_regions);\n-  }\n-\n-  log_debug(gc, ergo, cset)(\"Finish adding marking candidates to collection set. Initial: %u, optional: %u, pinned: %u, \"\n-                            \"predicted initial time: %1.2fms, predicted optional time: %1.2fms, time remaining: %1.2fms\",\n-                            num_initial_regions_selected, num_optional_regions_selected, num_pinned_regions,\n-                            predicted_initial_time_ms, predicted_optional_time_ms, time_remaining_ms);\n-\n-  assert(initial_old_regions->length() == num_initial_regions_selected, \"must be\");\n-  assert(optional_old_regions->length() == num_optional_regions_selected, \"must be\");\n-  return time_remaining_ms;\n-}\n-\n-void G1Policy::select_candidates_from_retained(G1CollectionCandidateList* retained_list,\n-                                               double time_remaining_ms,\n-                                               G1CollectionCandidateRegionList* initial_old_regions,\n-                                               G1CollectionCandidateRegionList* optional_old_regions,\n-                                               G1CollectionCandidateRegionList* pinned_old_regions) {\n-\n-  uint const min_regions = min_retained_old_cset_length();\n-\n-  uint num_initial_regions_selected = 0;\n-  uint num_optional_regions_selected = 0;\n-  uint num_expensive_regions_selected = 0;\n-  uint num_pinned_regions = 0;\n-\n-  double predicted_initial_time_ms = 0.0;\n-  double predicted_optional_time_ms = 0.0;\n-\n-  \/\/ We want to make sure that on the one hand we process the retained regions asap,\n-  \/\/ but on the other hand do not take too many of them as optional regions.\n-  \/\/ So we split the time budget into budget we will unconditionally take into the\n-  \/\/ initial old regions, and budget for taking optional regions from the retained\n-  \/\/ list.\n-  double optional_time_remaining_ms = max_time_for_retaining();\n-  time_remaining_ms = MIN2(time_remaining_ms, optional_time_remaining_ms);\n-\n-  log_debug(gc, ergo, cset)(\"Start adding retained candidates to collection set. \"\n-                            \"Min %u regions, available %u, \"\n-                            \"time remaining %1.2fms, optional remaining %1.2fms\",\n-                            min_regions, retained_list->length(), time_remaining_ms, optional_time_remaining_ms);\n-\n-  for (G1CollectionSetCandidateInfo* ci : *retained_list) {\n-    G1HeapRegion* r = ci->_r;\n-    double predicted_time_ms = predict_region_total_time_ms(r, collector_state()->in_young_only_phase());\n-    bool fits_in_remaining_time = predicted_time_ms <= time_remaining_ms;\n-    \/\/ If we can't reclaim that region ignore it for now.\n-    if (r->has_pinned_objects()) {\n-      num_pinned_regions++;\n-      if (ci->update_num_unreclaimed()) {\n-        log_trace(gc, ergo, cset)(\"Retained candidate %u can not be reclaimed currently. Skipping.\", r->hrm_index());\n-      } else {\n-        log_trace(gc, ergo, cset)(\"Retained candidate %u can not be reclaimed currently. Dropping.\", r->hrm_index());\n-        pinned_old_regions->append(r);\n-      }\n-      continue;\n-    }\n-\n-    if (fits_in_remaining_time || (num_expensive_regions_selected < min_regions)) {\n-      predicted_initial_time_ms += predicted_time_ms;\n-      if (!fits_in_remaining_time) {\n-        num_expensive_regions_selected++;\n-      }\n-      initial_old_regions->append(r);\n-      num_initial_regions_selected++;\n-    } else if (predicted_time_ms <= optional_time_remaining_ms) {\n-      predicted_optional_time_ms += predicted_time_ms;\n-      optional_old_regions->append(r);\n-      num_optional_regions_selected++;\n-    } else {\n-      \/\/ Fits neither initial nor optional time limit. Exit.\n-      break;\n-    }\n-    time_remaining_ms = MAX2(0.0, time_remaining_ms - predicted_time_ms);\n-    optional_time_remaining_ms = MAX2(0.0, optional_time_remaining_ms - predicted_time_ms);\n-  }\n-\n-  uint num_regions_selected = num_initial_regions_selected + num_optional_regions_selected;\n-  if (num_regions_selected == retained_list->length()) {\n-    log_debug(gc, ergo, cset)(\"Retained candidates exhausted.\");\n-  }\n-  if (num_expensive_regions_selected > 0) {\n-    log_debug(gc, ergo, cset)(\"Added %u retained candidates to collection set although the predicted time was too high.\",\n-                              num_expensive_regions_selected);\n-  }\n-\n-  log_debug(gc, ergo, cset)(\"Finish adding retained candidates to collection set. Initial: %u, optional: %u, pinned: %u, \"\n-                            \"predicted initial time: %1.2fms, predicted optional time: %1.2fms, \"\n-                            \"time remaining: %1.2fms optional time remaining %1.2fms\",\n-                            num_initial_regions_selected, num_optional_regions_selected, num_pinned_regions,\n-                            predicted_initial_time_ms, predicted_optional_time_ms, time_remaining_ms, optional_time_remaining_ms);\n-}\n-\n-void G1Policy::calculate_optional_collection_set_regions(G1CollectionCandidateRegionList* optional_regions,\n-                                                         double time_remaining_ms,\n-                                                         G1CollectionCandidateRegionList* selected_regions) {\n-  assert(_collection_set->optional_region_length() > 0,\n-         \"Should only be called when there are optional regions\");\n-\n-  double total_prediction_ms = 0.0;\n-\n-  for (G1HeapRegion* r : *optional_regions) {\n-    double prediction_ms = predict_region_total_time_ms(r, false);\n-\n-    if (prediction_ms > time_remaining_ms) {\n-      log_debug(gc, ergo, cset)(\"Prediction %.3fms for region %u does not fit remaining time: %.3fms.\",\n-                                prediction_ms, r->hrm_index(), time_remaining_ms);\n-      break;\n-    }\n-    \/\/ This region will be included in the next optional evacuation.\n-\n-    total_prediction_ms += prediction_ms;\n-    time_remaining_ms -= prediction_ms;\n-\n-    selected_regions->append(r);\n-  }\n-\n-  log_debug(gc, ergo, cset)(\"Prepared %u regions out of %u for optional evacuation. Total predicted time: %.3fms\",\n-                            selected_regions->length(), optional_regions->length(), total_prediction_ms);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":0,"deletions":213,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -338,21 +338,1 @@\n-  \/\/ Calculate and fill in the initial, optional and pinned old gen candidate regions from\n-  \/\/ the given candidate list and the remaining time.\n-  \/\/ Returns the remaining time.\n-  double select_candidates_from_marking(G1CollectionCandidateList* marking_list,\n-                                        double time_remaining_ms,\n-                                        G1CollectionCandidateRegionList* initial_old_regions,\n-                                        G1CollectionCandidateRegionList* optional_old_regions,\n-                                        G1CollectionCandidateRegionList* pinned_old_regions);\n-\n-  void select_candidates_from_retained(G1CollectionCandidateList* retained_list,\n-                                       double time_remaining_ms,\n-                                       G1CollectionCandidateRegionList* initial_old_regions,\n-                                       G1CollectionCandidateRegionList* optional_old_regions,\n-                                       G1CollectionCandidateRegionList* pinned_old_regions);\n-\n-  \/\/ Calculate the number of optional regions from the given collection set candidates,\n-  \/\/ the remaining time and the maximum number of these regions and return the number\n-  \/\/ of actually selected regions in num_optional_regions.\n-  void calculate_optional_collection_set_regions(G1CollectionCandidateRegionList* optional_old_regions,\n-                                                 double time_remaining_ms,\n-                                                 G1CollectionCandidateRegionList* selected);\n+\n@@ -426,0 +406,1 @@\n+public:\n@@ -431,1 +412,0 @@\n-public:\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":2,"deletions":22,"binary":false,"changes":24,"status":"modified"}]}