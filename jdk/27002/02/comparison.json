{"files":[{"patch":"@@ -56,1 +56,13 @@\n-    VTransformScalarNode* vtn = new (_vtransform.arena()) VTransformScalarNode(_vtransform, n);\n+\n+    VTransformNode* vtn = nullptr;\n+    if (n->is_Load() || n->is_Store()) {\n+      MemNode* mem = n->as_Mem();\n+      const VPointer& mem_p = _vloop_analyzer.vpointers().vpointer(mem);\n+      vtn = new (_vtransform.arena()) VTransformMemopScalarNode(_vtransform, mem, mem_p);\n+    } else if (n->is_Phi()) {\n+      vtn = new (_vtransform.arena()) VTransformLoopPhiNode(_vtransform, n->as_Phi());\n+    } else if (n->is_CFG()) {\n+      vtn = new (_vtransform.arena()) VTransformCFGNode(_vtransform, n);\n+    } else {\n+      vtn = new (_vtransform.arena()) VTransformDataScalarNode(_vtransform, n);\n+    }\n@@ -111,2 +123,2 @@\n-    VTransformScalarNode* vtn = get_vtnode(n)->isa_Scalar();\n-    if (vtn == nullptr) { continue; }\n+    VTransformNode* vtn = get_vtnode(n);\n+    if (vtn->isa_Vector() != nullptr) { continue; }\n@@ -181,1 +193,1 @@\n-  VTransformNode* req = get_vtnode_or_wrap_as_input_scalar(n->in(index));\n+  VTransformNode* req = get_vtnode_or_wrap_as_outer(n->in(index));\n@@ -213,1 +225,1 @@\n-    VTransformNode* iv_vtn = get_vtnode_or_wrap_as_input_scalar(_vloop.iv());\n+    VTransformNode* iv_vtn = get_vtnode_or_wrap_as_outer(_vloop.iv());\n@@ -225,1 +237,1 @@\n-    VTransformNode* same_input_vtn = get_vtnode_or_wrap_as_input_scalar(same_input);\n+    VTransformNode* same_input_vtn = get_vtnode_or_wrap_as_outer(same_input);\n@@ -267,1 +279,1 @@\n-VTransformNode* SuperWordVTransformBuilder::get_vtnode_or_wrap_as_input_scalar(Node* n) {\n+VTransformNode* SuperWordVTransformBuilder::get_vtnode_or_wrap_as_outer(Node* n) {\n@@ -272,1 +284,1 @@\n-  vtn = new (_vtransform.arena()) VTransformInputScalarNode(_vtransform, n);\n+  vtn = new (_vtransform.arena()) VTransformOuterNode(_vtransform, n);\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.cpp","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-  VTransformNode* get_vtnode_or_wrap_as_input_scalar(Node* n);\n+  VTransformNode* get_vtnode_or_wrap_as_outer(Node* n);\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -285,2 +285,2 @@\n-          const VPointer& vp1 = vtn->vpointer(_vloop_analyzer);\n-          const VPointer& vp2 = use->vpointer(_vloop_analyzer);\n+          const VPointer& vp1 = vtn->vpointer();\n+          const VPointer& vp2 = use->vpointer();\n@@ -633,1 +633,1 @@\n-        const VPointer& p = vtn->vpointer(vloop_analyzer);\n+        const VPointer& p = vtn->vpointer();\n@@ -711,1 +711,21 @@\n-VTransformApplyResult VTransformScalarNode::apply(VTransformApplyState& apply_state) const {\n+VTransformApplyResult VTransformMemopScalarNode::apply(VTransformApplyState& apply_state) const {\n+  \/\/ This was just wrapped. Now we simply unwap without touching the inputs.\n+  return VTransformApplyResult::make_scalar(_node);\n+}\n+\n+VTransformApplyResult VTransformDataScalarNode::apply(VTransformApplyState& apply_state) const {\n+  \/\/ This was just wrapped. Now we simply unwap without touching the inputs.\n+  return VTransformApplyResult::make_scalar(_node);\n+}\n+\n+VTransformApplyResult VTransformLoopPhiNode::apply(VTransformApplyState& apply_state) const {\n+  \/\/ This was just wrapped. Now we simply unwap without touching the inputs.\n+  return VTransformApplyResult::make_scalar(_node);\n+}\n+\n+VTransformApplyResult VTransformCFGNode::apply(VTransformApplyState& apply_state) const {\n+  \/\/ This was just wrapped. Now we simply unwap without touching the inputs.\n+  return VTransformApplyResult::make_scalar(_node);\n+}\n+\n+VTransformApplyResult VTransformOuterNode::apply(VTransformApplyState& apply_state) const {\n@@ -864,1 +884,1 @@\n-  const VPointer& load_p = vpointer(apply_state.vloop_analyzer());\n+  const VPointer& load_p = vpointer();\n@@ -986,1 +1006,18 @@\n-void VTransformScalarNode::print_spec() const {\n+void VTransformMemopScalarNode::print_spec() const {\n+  tty->print(\"node[%d %s] \", _node->_idx, _node->Name());\n+  _vpointer.print_on(tty, false);\n+}\n+\n+void VTransformDataScalarNode::print_spec() const {\n+  tty->print(\"node[%d %s]\", _node->_idx, _node->Name());\n+}\n+\n+void VTransformLoopPhiNode::print_spec() const {\n+  tty->print(\"node[%d %s]\", _node->_idx, _node->Name());\n+}\n+\n+void VTransformCFGNode::print_spec() const {\n+  tty->print(\"node[%d %s]\", _node->_idx, _node->Name());\n+}\n+\n+void VTransformOuterNode::print_spec() const {\n@@ -1014,0 +1051,4 @@\n+  if (is_load_or_store_in_loop()) {\n+    tty->print(\" \");\n+    vpointer().print_on(tty, false);\n+  }\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":47,"deletions":6,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -63,2 +63,5 @@\n-class VTransformScalarNode;\n-class VTransformInputScalarNode;\n+class VTransformMemopScalarNode;\n+class VTransformDataScalarNode;\n+class VTransformLoopPhiNode;\n+class VTransformCFGNode;\n+class VTransformOuterNode;\n@@ -425,2 +428,2 @@\n-  virtual VTransformScalarNode* isa_Scalar() { return nullptr; }\n-  virtual VTransformInputScalarNode* isa_InputScalar() { return nullptr; }\n+  virtual VTransformMemopScalarNode* isa_MemopScalar() { return nullptr; }\n+  virtual VTransformOuterNode* isa_Outer() { return nullptr; }\n@@ -437,1 +440,1 @@\n-  virtual const VPointer& vpointer(const VLoopAnalyzer& vloop_analyzer) const { ShouldNotReachHere(); }\n+  virtual const VPointer& vpointer() const { ShouldNotReachHere(); }\n@@ -451,2 +454,2 @@\n-\/\/ Identity transform for scalar nodes.\n-class VTransformScalarNode : public VTransformNode {\n+\/\/ Identity transform for scalar loads and stores.\n+class VTransformMemopScalarNode : public VTransformNode {\n@@ -454,1 +457,2 @@\n-  Node* _node;\n+  MemNode* _node;\n+  const VPointer _vpointer;\n@@ -456,4 +460,9 @@\n-  VTransformScalarNode(VTransform& vtransform, Node* n) :\n-    VTransformNode(vtransform, n->req()), _node(n) {}\n-  Node* node() const { return _node; }\n-  virtual VTransformScalarNode* isa_Scalar() override { return this; }\n+  VTransformMemopScalarNode(VTransform& vtransform, MemNode* n, const VPointer& vpointer) :\n+    VTransformNode(vtransform, n->req()), _node(n), _vpointer(vpointer)\n+  {\n+    assert(node()->is_Load() || node()->is_Store(), \"must be memop\");\n+  }\n+\n+  MemNode* node() const { return _node; }\n+  virtual VTransformMemopScalarNode* isa_MemopScalar() override { return this; }\n+\n@@ -461,2 +470,3 @@\n-  virtual bool is_load_or_store_in_loop() const override { return _node->is_Load() || _node->is_Store(); }\n-  virtual const VPointer& vpointer(const VLoopAnalyzer& vloop_analyzer) const override { return vloop_analyzer.vpointers().vpointer(node()->as_Mem()); }\n+  virtual bool is_load_or_store_in_loop() const override { return true; }\n+\n+  virtual const VPointer& vpointer() const override { return _vpointer; }\n@@ -464,1 +474,49 @@\n-  NOT_PRODUCT(virtual const char* name() const override { return \"Scalar\"; };)\n+  NOT_PRODUCT(virtual const char* name() const override { return \"MemopScalar\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Identity transform for scalar data nodes.\n+class VTransformDataScalarNode : public VTransformNode {\n+private:\n+  Node* _node;\n+public:\n+  VTransformDataScalarNode(VTransform& vtransform, Node* n) :\n+    VTransformNode(vtransform, n->req()), _node(n)\n+  {\n+    assert(!_node->is_Mem() && !_node->is_Phi() && !_node->is_CFG(), \"must be data node: %s\", _node->Name());\n+  }\n+\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"DataScalar\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Identity transform for loop head phi nodes.\n+class VTransformLoopPhiNode : public VTransformNode {\n+private:\n+  PhiNode* _node;\n+public:\n+  VTransformLoopPhiNode(VTransform& vtransform, PhiNode* n) :\n+    VTransformNode(vtransform, n->req()), _node(n)\n+  {\n+    assert(_node->in(0)->is_Loop(), \"phi ctrl must be Loop: %s\", _node->in(0)->Name());\n+  }\n+\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"LoopPhi\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Identity transform for CFG nodes.\n+class VTransformCFGNode : public VTransformNode {\n+private:\n+  Node* _node;\n+public:\n+  VTransformCFGNode(VTransform& vtransform, Node* n) :\n+    VTransformNode(vtransform, n->req()), _node(n)\n+  {\n+    assert(_node->is_CFG(), \"must be CFG node: %s\", _node->Name());\n+  }\n+\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"CFG\"; };)\n@@ -471,1 +529,3 @@\n-class VTransformInputScalarNode : public VTransformScalarNode {\n+class VTransformOuterNode : public VTransformNode {\n+private:\n+  Node* _node;\n@@ -473,6 +533,7 @@\n-  VTransformInputScalarNode(VTransform& vtransform, Node* n) :\n-    VTransformScalarNode(vtransform, n) {}\n-  virtual VTransformInputScalarNode* isa_InputScalar() override { return this; }\n-  virtual bool is_load_in_loop() const override { return false; }\n-  virtual bool is_load_or_store_in_loop() const override { return false; }\n-  NOT_PRODUCT(virtual const char* name() const override { return \"InputScalar\"; };)\n+  VTransformOuterNode(VTransform& vtransform, Node* n) :\n+    VTransformNode(vtransform, n->req()), _node(n) {}\n+\n+  virtual VTransformOuterNode* isa_Outer() override { return this; }\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"Outer\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n@@ -601,1 +662,1 @@\n-  virtual const VPointer& vpointer(const VLoopAnalyzer& vloop_analyzer) const override { return _vpointer; }\n+  virtual const VPointer& vpointer() const override { return _vpointer; }\n@@ -635,2 +696,2 @@\n-    \/\/ We can ignore input nodes, they are outside the loop.\n-    if (vtn->isa_InputScalar() != nullptr) { continue; }\n+    \/\/ We must ignore nodes outside the loop.\n+    if (vtn->isa_Outer() != nullptr) { continue; }\n@@ -638,3 +699,3 @@\n-    VTransformScalarNode* scalar = vtn->isa_Scalar();\n-    if (scalar != nullptr && scalar->node()->is_Mem()) {\n-      callback(scalar->node()->as_Mem());\n+    VTransformMemopScalarNode* scalar = vtn->isa_MemopScalar();\n+    if (scalar != nullptr) {\n+      callback(scalar->node());\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":89,"deletions":28,"binary":false,"changes":117,"status":"modified"}]}