{"files":[{"patch":"@@ -80,1 +80,2 @@\n-            } else if (FontUtilities.isComplexCharCode(code)) {\n+            } else if (FontUtilities.isComplexCharCode(code) ||\n+                    CharToGlyphMapper.isVariationSelector(code)) {\n@@ -91,0 +92,15 @@\n+    public synchronized int charToVariationGlyph(int unicode, int variationSelector) {\n+        if (variationSelector == 0) {\n+            return charToGlyph(unicode);\n+        }\n+        final char[] unicodeArray = new char[4];\n+        final int[] glyphArray = new int[4];\n+\n+        int size = Character.toChars(unicode, unicodeArray, 0);\n+        size += Character.toChars(variationSelector, unicodeArray, size);\n+\n+        nativeCharsToGlyphs(fFont.getNativeFontPtr(), size, unicodeArray, glyphArray);\n+\n+        return glyphArray[0];\n+    }\n+\n@@ -108,4 +124,2 @@\n-            int base = unicode - 0x10000;\n-            surrogates[0] = (char)((base >>> 10) + HI_SURROGATE_START);\n-            surrogates[1] = (char)((base % 0x400) + LO_SURROGATE_START);\n-            charsToGlyphs(2, surrogates, glyphs);\n+            int size = Character.toChars(unicode, surrogates, 0);\n+            charsToGlyphs(size, surrogates, glyphs);\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/CCharToGlyphMapper.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -54,1 +54,19 @@\n-    private int convertToGlyph(int unicode) {\n+    @Override\n+    public int charToVariationGlyph(int unicode, int variationSelector) {\n+        if (variationSelector == 0) {\n+            return charToGlyph(unicode);\n+        } else {\n+            int glyph = convertToGlyph(unicode, variationSelector);\n+            if (glyph == missingGlyph) glyph = charToGlyph(unicode);\n+            return glyph;\n+        }\n+    }\n+\n+    @Override\n+    protected int convertToGlyph(int unicode) {\n+        int glyph = convertToGlyph(unicode, 0);\n+        return glyph;\n+    }\n+\n+    @Override\n+    protected int convertToGlyph(int unicode, int variationSelector) {\n@@ -57,1 +75,1 @@\n-            int glyphCode = mapper.charToGlyph(unicode);\n+            int glyphCode = mapper.charToVariationGlyph(unicode, variationSelector);\n@@ -63,1 +81,1 @@\n-                glyphCode = compositeGlyphCode(slot, glyphCode);\n+                glyphCode = font.compositeGlyphCode(slot, glyphCode);\n@@ -90,65 +108,0 @@\n-\n-    public boolean charsToGlyphsNS(int count, char[] unicodes, int[] glyphs) {\n-\n-        for (int i=0; i<count; i++) {\n-            int code = unicodes[i]; \/\/ char is unsigned.\n-\n-            if (code >= HI_SURROGATE_START &&\n-                code <= HI_SURROGATE_END && i < count - 1) {\n-                char low = unicodes[i + 1];\n-\n-                if (low >= LO_SURROGATE_START &&\n-                    low <= LO_SURROGATE_END) {\n-                    code = (code - HI_SURROGATE_START) *\n-                        0x400 + low - LO_SURROGATE_START + 0x10000;\n-                    glyphs[i + 1] = INVISIBLE_GLYPH_ID;\n-                }\n-            }\n-\n-            glyphs[i] = convertToGlyph(code);\n-\n-            if (code < FontUtilities.MIN_LAYOUT_CHARCODE) {\n-                continue;\n-            }\n-            else if (FontUtilities.isComplexCharCode(code)) {\n-                return true;\n-            }\n-            else if (code >= 0x10000) {\n-                i += 1; \/\/ Empty glyph slot after surrogate\n-                continue;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    public void charsToGlyphs(int count, char[] unicodes, int[] glyphs) {\n-        for (int i=0; i<count; i++) {\n-            int code = unicodes[i]; \/\/ char is unsigned.\n-\n-            if (code >= HI_SURROGATE_START &&\n-                code <= HI_SURROGATE_END && i < count - 1) {\n-                char low = unicodes[i + 1];\n-\n-                if (low >= LO_SURROGATE_START &&\n-                    low <= LO_SURROGATE_END) {\n-                    code = (code - HI_SURROGATE_START) *\n-                        0x400 + low - LO_SURROGATE_START + 0x10000;\n-\n-                    glyphs[i] = convertToGlyph(code);\n-                    i += 1; \/\/ Empty glyph slot after surrogate\n-                    glyphs[i] = INVISIBLE_GLYPH_ID;\n-                    continue;\n-                }\n-            }\n-\n-            glyphs[i] = convertToGlyph(code);\n-        }\n-    }\n-\n-    public void charsToGlyphs(int count, int[] unicodes, int[] glyphs) {\n-        for (int i=0; i<count; i++) {\n-             glyphs[i] = convertToGlyph(unicodes[i]);\n-        }\n-    }\n-\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/CCompositeGlyphMapper.java","additions":21,"deletions":68,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -74,6 +74,0 @@\n-    GeneralPath getGlyphVectorOutline(long pScalerContext,\n-                                               int[] glyphs, int numGlyphs,\n-                                               float x, float y) {\n-       throw new InternalError(\"Not implemented\");\n-    }\n-\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/CFont.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -63,0 +63,6 @@\n+    private static native void getNativeGlyphRenderData(long nativeStrikePtr,\n+                                                        int glyphCode,\n+                                                        double x,\n+                                                        double y,\n+                                                        GlyphRenderData result);\n+\n@@ -217,3 +223,4 @@\n-    \/\/ should implement, however not called though any path that is publicly exposed\n-    GeneralPath getGlyphVectorOutline(int[] glyphs, float x, float y) {\n-        throw new Error(\"not implemented yet\");\n+    GlyphRenderData getGlyphRenderData(int glyphCode, float x, float y) {\n+        GlyphRenderData result = new GlyphRenderData();\n+        getNativeGlyphRenderData(getNativeStrikePtr(), glyphCode, x, y, result);\n+        return result;\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/CStrike.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -82,6 +82,0 @@\n-    public  GeneralPath getGlyphVectorOutline(long pScalerContext,\n-                                              int[] glyphs, int numGlyphs,\n-                                              float x, float y) {\n-        return null;\n-    }\n-\n@@ -107,0 +101,4 @@\n+\n+    public SlotInfo getSlotInfoForGlyph(int glyphCode) {\n+        return new SlotInfo(getDelegateFont());\n+    }\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/NativeFont.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-    GeneralPath getGlyphVectorOutline(int[] glyphs, float x, float y) {\n+    GlyphRenderData getGlyphRenderData(int glyphCode, float x, float y) {\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/NativeStrike.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-    private boolean hasSlotData(GlyphVector gv) {\n+    private boolean hasSlotData(GlyphVector gv, Font2D font2D) {\n@@ -86,3 +86,9 @@\n-        for (int i = 0; i < length; i++) {\n-            if ((gv.getGlyphCode(i) & CompositeGlyphMapper.SLOTMASK) != 0) {\n-                return true;\n+        if (length > 0) {\n+            int slotMask = font2D\n+                    .getSlotInfoForGlyph(gv.getGlyphCode(0))\n+                    .getSlotMask();\n+            for (int i = 0; i < length; i++) {\n+                int glyphCode = gv.getGlyphCode(i);\n+                if ((glyphCode & slotMask) != 0) {\n+                    return true;\n+                }\n@@ -94,13 +100,1 @@\n-    private Font getSlotFont(Font font, int slot) {\n-        Font2D f2d = FontUtilities.getFont2D(font);\n-        if (f2d instanceof CFont) {\n-            CompositeFont cf = ((CFont)f2d).getCompositeFont2D();\n-            PhysicalFont pf = cf.getSlotFont(slot);\n-            Font f = new Font(pf.getFontName(null),\n-                              font.getStyle(), font.getSize());\n-            return f;\n-        }\n-        return null;\n-    }\n-\n-    private GlyphVector getGlyphVectorWithRange(final Font font, final GlyphVector gV, int start, int count) {\n+    private GlyphVector getGlyphVectorWithRange(final Font font, final GlyphVector gV, int start, int count, int slotShift) {\n@@ -109,1 +103,1 @@\n-            glyphs[i] = gV.getGlyphCode(start+i) & CompositeGlyphMapper.GLYPHMASK;\n+            glyphs[i] = gV.getGlyphCode(start+i) >>> slotShift;\n@@ -122,1 +116,2 @@\n-    private int getLengthOfSameSlot(final GlyphVector gV, final int targetSlot, final int start, final int length) {\n+    private int getLengthOfSameSlot(final GlyphVector gV, final int targetSlot, final int slotMask,\n+                                    final int start, final int length) {\n@@ -125,2 +120,1 @@\n-            int slot = (gV.getGlyphCode(start + count) &\n-                        CompositeGlyphMapper.SLOTMASK) >> 24;\n+            int slot = gV.getGlyphCode(start + count) & slotMask;\n@@ -146,1 +140,5 @@\n-        sg2d.setFont(gV.getFont());\n+        Font gvFont = gV.getFont();\n+        Font2D f2d = FontUtilities.getFont2D(gvFont);\n+        if (f2d instanceof FontSubstitution fs) {\n+            f2d = fs.getCompositeFont2D();\n+        }\n@@ -148,1 +146,1 @@\n-        if (hasSlotData(gV)) {\n+        if (hasSlotData(gV, f2d)) {\n@@ -153,4 +151,7 @@\n-                int slot = (gV.getGlyphCode(start) &\n-                            CompositeGlyphMapper.SLOTMASK) >> 24;\n-                sg2d.setFont(getSlotFont(gV.getFont(), slot));\n-                int count = getLengthOfSameSlot(gV, slot, start, length);\n+                int glyphCode = gV.getGlyphCode(start);\n+                Font2D.SlotInfo slotInfo = f2d.getSlotInfoForGlyph(glyphCode);\n+                int slotMask = slotInfo.getSlotMask();\n+                int slot = glyphCode & slotMask;\n+                sg2d.setFont(new Font(slotInfo.font.getFontName(null),\n+                        gvFont.getStyle(), gvFont.getSize()));\n+                int count = getLengthOfSameSlot(gV, slot, slotMask, start, length);\n@@ -158,1 +159,1 @@\n-                                                              gV, start, count);\n+                        gV, start, count, slotInfo.slotShift);\n@@ -165,0 +166,1 @@\n+            sg2d.setFont(gvFont);\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CTextPipe.java","additions":30,"deletions":28,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -208,9 +208,3 @@\n-\/*\n- * Class:     sun_font_CStrike\n- * Method:    getNativeGlyphOutline\n- * Signature: (JJIDD)Ljava\/awt\/geom\/GeneralPath;\n- *\/\n-JNIEXPORT jobject JNICALL\n-Java_sun_font_CStrike_getNativeGlyphOutline\n-    (JNIEnv *env, jclass clazz,\n-     jlong awtStrikePtr, jint glyphCode, jdouble xPos, jdouble yPos)\n+jobject getGlyphOutline(JNIEnv *env, AWTStrike *awtStrike,\n+                        CTFontRef font, CGGlyph glyph,\n+                        jdouble xPos, jdouble yPos)\n@@ -219,3 +213,0 @@\n-\n-JNI_COCOA_ENTER(env);\n-\n@@ -231,5 +222,0 @@\n-    AWTStrike *awtStrike = (AWTStrike *)jlong_to_ptr(awtStrikePtr);\n-    AWTFont *awtfont = awtStrike->fAWTFont;\n-\n-AWT_FONT_CLEANUP_CHECK(awtfont);\n-\n@@ -241,5 +227,0 @@\n-    \/\/ get the right font and glyph for this \"Java GlyphCode\"\n-\n-    CGGlyph glyph;\n-    const CTFontRef font = CTS_CopyCTFallbackFontAndGlyphForJavaGlyphCode(awtfont, glyphCode, &glyph);\n-\n@@ -258,1 +239,0 @@\n-    CFRelease(font);\n@@ -292,1 +272,0 @@\n-JNI_COCOA_EXIT(env);\n@@ -296,0 +275,204 @@\n+\/*\n+ * Class:     sun_font_CStrike\n+ * Method:    getNativeGlyphOutline\n+ * Signature: (JJIDD)Ljava\/awt\/geom\/GeneralPath;\n+ *\/\n+JNIEXPORT jobject JNICALL\n+Java_sun_font_CStrike_getNativeGlyphOutline\n+        (JNIEnv *env, jclass clazz,\n+         jlong awtStrikePtr, jint glyphCode, jdouble xPos, jdouble yPos) {\n+    jobject generalPath = NULL;\n+\n+    JNI_COCOA_ENTER(env);\n+    AWT_FONT_CLEANUP_SETUP;\n+\n+    AWTStrike *awtStrike = (AWTStrike *)jlong_to_ptr(awtStrikePtr);\n+    AWTFont *awtfont = awtStrike->fAWTFont;\n+    AWT_FONT_CLEANUP_CHECK(awtfont);\n+\n+    \/\/ get the right font and glyph for this \"Java GlyphCode\"\n+    CGGlyph glyph;\n+    const CTFontRef font = CTS_CopyCTFallbackFontAndGlyphForJavaGlyphCode(awtfont, glyphCode, &glyph);\n+\n+    generalPath = getGlyphOutline(env, awtStrike, font, glyph, xPos, yPos);\n+\n+    cleanup:\n+    CFRelease(font);\n+\n+    AWT_FONT_CLEANUP_FINISH;\n+    JNI_COCOA_EXIT(env);\n+\n+    return generalPath;\n+}\n+\n+\/\/ OpenType data is Big-Endian\n+#define GET_BE_INT32(data, i) CFSwapInt32BigToHost(*(const UInt32*) ((const UInt8*) (data) + (i)))\n+#define GET_BE_INT16(data, i) CFSwapInt16BigToHost(*(const UInt16*) ((const UInt8*) (data) + (i)))\n+\n+static bool addBitmapRenderData(JNIEnv *env, AWTStrike *awtStrike,\n+                                CTFontRef font, CGGlyph glyph,\n+                                jdouble xPos, jdouble yPos, jobject result) {\n+    bool success = false;\n+\n+    DECLARE_CLASS_RETURN(jc_GlyphRenderData, \"sun\/font\/GlyphRenderData\", false);\n+    DECLARE_METHOD_RETURN(GlyphRenderDataAddBitmap, jc_GlyphRenderData, \"addBitmap\", \"(DDDDDDIIII[I)V\", false);\n+\n+    AWT_FONT_CLEANUP_SETUP;\n+\n+    CTFontDescriptorRef descriptor = NULL;\n+    CGFontRef cgFont = CTFontCopyGraphicsFont(font, &descriptor);\n+\n+    CFDataRef sbixTable = CGFontCopyTableForTag(cgFont, kCTFontTableSbix);\n+    if (sbixTable == NULL) {\n+        goto cleanup;\n+    }\n+\n+    \/\/ Parse sbix table\n+    CFIndex sbixSize = CFDataGetLength(sbixTable);\n+    if (sbixSize < 8) {\n+        goto cleanup; \/\/ Corrupted table\n+    }\n+    const UInt8* sbix = CFDataGetBytePtr(sbixTable);\n+    UInt32 numStrikes = GET_BE_INT32(sbix, 4);\n+    if (8 + 4 * numStrikes > sbixSize) {\n+        goto cleanup; \/\/ Corrupted table\n+    }\n+    \/\/ Find last strike which has data for our glyph\n+    \/\/ Last is usually the biggest\n+    const UInt8* glyphData = NULL;\n+    UInt32 size;\n+    UInt16 ppem, ppi;\n+    for (int i = numStrikes - 1; i >= 0; i--) {\n+        const UInt8* strike = sbix + GET_BE_INT32(sbix, 8 + 4 * i);\n+        if (strike + 12 + 4 * glyph > sbix + sbixSize) {\n+            goto cleanup; \/\/ Corrupted table\n+        }\n+        UInt32 offset = GET_BE_INT32(strike, 4 + 4 * glyph);\n+        size = GET_BE_INT32(strike, 8 + 4 * glyph) - offset;\n+        if (size > 0) {\n+            ppem = GET_BE_INT16(strike, 0);\n+            ppi = GET_BE_INT16(strike, 2);\n+            glyphData = strike + offset;\n+            break;\n+        }\n+    }\n+    if (glyphData == NULL) {\n+        goto cleanup;\n+    }\n+    if (glyphData + 4 > sbix + sbixSize) {\n+        goto cleanup; \/\/ Corrupted table\n+    }\n+\n+    \/\/ Read glyph data\n+    FourCharCode graphicType = GET_BE_INT32(glyphData, 4);\n+    glyphData += 8;\n+    size -= 8;\n+    if (glyphData + size > sbix + sbixSize) {\n+        goto cleanup; \/\/ Corrupted table\n+    }\n+\n+    \/\/ Decode glyph image\n+    CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, glyphData, size, NULL);\n+    CGImageRef image = NULL;\n+    if (graphicType == 'jpg ') {\n+        image = CGImageCreateWithJPEGDataProvider(dataProvider, NULL, false, kCGRenderingIntentDefault);\n+    } else if (graphicType == 'png ') {\n+        image = CGImageCreateWithPNGDataProvider(dataProvider, NULL, false, kCGRenderingIntentDefault);\n+    }\n+    CGDataProviderRelease(dataProvider);\n+\n+    if (image != NULL) {\n+        CGBitmapInfo info = CGImageGetBitmapInfo(image);\n+        size_t bits = CGImageGetBitsPerPixel(image);\n+        jint colorModel = -1;\n+        if (info & (kCGImageAlphaPremultipliedLast | kCGImageAlphaLast)) {\n+            colorModel = 0; \/\/ RGBA\n+        } else if (info & (kCGImageAlphaPremultipliedFirst | kCGImageAlphaFirst)) {\n+            colorModel = 1; \/\/ ARGB\n+        }\n+        if (colorModel != -1 && (info & kCGBitmapFloatComponents) == 0 && bits == 32) {\n+            size_t width = CGImageGetWidth(image);\n+            size_t height = CGImageGetHeight(image);\n+            size_t pitch = CGImageGetBytesPerRow(image) \/ 4;\n+            dataProvider = CGImageGetDataProvider(image);\n+            CFDataRef data = CGDataProviderCopyData(dataProvider);\n+\n+            jbyteArray array = (*env)->NewIntArray(env, pitch * height);\n+            (*env)->SetIntArrayRegion(env, array, 0, pitch * height, (const jint*) CFDataGetBytePtr(data));\n+            CFRelease(data);\n+\n+            double pointSize = 72.0 * ppem \/ ppi;\n+            double scale = 1.0 \/ pointSize;\n+            font = CTFontCreateWithGraphicsFont(cgFont, pointSize, NULL, descriptor);\n+            CGRect bbox = CTFontGetBoundingRectsForGlyphs(font, kCTFontOrientationDefault, &glyph, NULL, 1);\n+            CFRelease(font);\n+            double tx = bbox.origin.x + xPos * pointSize \/ awtStrike->fSize;\n+            double ty = -bbox.origin.y - (double) height + yPos * pointSize \/ awtStrike->fSize;\n+\n+            jdouble m00 = awtStrike->fTx.a * scale, m10 = awtStrike->fTx.b * scale;\n+            jdouble m01 = -awtStrike->fTx.c * scale, m11 = -awtStrike->fTx.d * scale;\n+            jdouble m02 = m00 * tx + m01 * ty, m12 = m10 * tx + m11 * ty;\n+\n+            (*env)->CallVoidMethod(env, result, GlyphRenderDataAddBitmap,\n+                                   m00, m10, m01, m11, m02, m12,\n+                                   width, height, pitch, 0, array);\n+            success = true;\n+        }\n+        CGImageRelease(image);\n+    }\n+\n+    \/\/ Cleanup\n+    cleanup:\n+    if (sbixTable) {\n+        CFRelease(sbixTable);\n+    }\n+    if (cgFont) {\n+        CFRelease(cgFont);\n+    }\n+    if (descriptor) {\n+        CFRelease(descriptor);\n+    }\n+\n+    AWT_FONT_CLEANUP_FINISH;\n+    return success;\n+}\n+\n+\/*\n+ * Class:     sun_font_CStrike\n+ * Method:    getNativeGlyphRenderData\n+ * Signature: (JIDDLsun\/font\/GlyphRenderData;)V\n+ *\/\n+JNIEXPORT void JNICALL\n+Java_sun_font_CStrike_getNativeGlyphRenderData\n+        (JNIEnv *env, jclass clazz,\n+         jlong awtStrikePtr, jint glyphCode, jdouble xPos, jdouble yPos, jobject result)\n+{\n+    JNI_COCOA_ENTER(env);\n+\n+    DECLARE_CLASS(jc_GlyphRenderData, \"sun\/font\/GlyphRenderData\");\n+    DECLARE_FIELD(GlyphRenderDataOutline, jc_GlyphRenderData, \"outline\", \"Ljava\/awt\/geom\/GeneralPath;\")\n+\n+    AWT_FONT_CLEANUP_SETUP;\n+\n+    AWTStrike *awtStrike = (AWTStrike *)jlong_to_ptr(awtStrikePtr);\n+    AWTFont *awtfont = awtStrike->fAWTFont;\n+    AWT_FONT_CLEANUP_CHECK(awtfont);\n+\n+    \/\/ get the right font and glyph for this \"Java GlyphCode\"\n+    CGGlyph glyph;\n+    const CTFontRef font = CTS_CopyCTFallbackFontAndGlyphForJavaGlyphCode(awtfont, glyphCode, &glyph);\n+\n+    if (!addBitmapRenderData(env, awtStrike, font, glyph, xPos, yPos, result)) {\n+        jobject gp = getGlyphOutline(env, awtStrike, font, glyph, xPos, yPos);\n+        if (gp != NULL) {\n+            (*env)->SetObjectField(env, result, GlyphRenderDataOutline, gp);\n+        }\n+    }\n+\n+    cleanup:\n+    CFRelease(font);\n+\n+    AWT_FONT_CLEANUP_FINISH;\n+    JNI_COCOA_EXIT(env);\n+}\n+\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/AWTStrike.m","additions":207,"deletions":24,"binary":false,"changes":231,"status":"modified"},{"patch":"@@ -588,0 +588,1 @@\n+    glyphInfo->format = (UInt8) pixelSize;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/CGGlyphImages.m","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,4 @@\n+#define VS_START  0xFE00\n+#define VS_END    0xFE0F\n+#define VSS_START 0xE0100\n+#define VSS_END   0xE01FF\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/CoreTextSupport.h","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -91,0 +91,13 @@\n+int NextUnicode(const UniChar unicodes[], UnicodeScalarValue *codePoint, const size_t index, const size_t limit) {\n+    if (index >= limit) {\n+        return 0;\n+    }\n+    UniChar unicode = unicodes[index];\n+    UniChar nextUnicode = (index+1) < limit ? unicodes[index+1] : 0;\n+    bool surrogatePair = unicode >= HI_SURROGATE_START && unicode <= HI_SURROGATE_END\n+                         && nextUnicode >= LO_SURROGATE_START && nextUnicode <= LO_SURROGATE_END;\n+    *codePoint = surrogatePair ? (((int)(unicode - HI_SURROGATE_START)) << 10)\n+                                + nextUnicode - LO_SURROGATE_START + 0x10000 : unicode;\n+    return surrogatePair ? 2 : 1;\n+}\n+\n@@ -104,6 +117,15 @@\n-    size_t i;\n-    for (i = 0; i < count; i++) {\n-        UniChar unicode = unicodes[i];\n-        UniChar nextUnicode = (i+1) < count ? unicodes[i+1] : 0;\n-        bool surrogatePair = unicode >= HI_SURROGATE_START && unicode <= HI_SURROGATE_END\n-                             && nextUnicode >= LO_SURROGATE_START && nextUnicode <= LO_SURROGATE_END;\n+    size_t i, size;\n+    for (i = 0; i < count; i += size) {\n+        UnicodeScalarValue codePoint, variationCodePoint;\n+        int codePointSize = size = NextUnicode(unicodes, &codePoint, i, count);\n+        if (size == 0) {\n+            break;\n+        }\n+\n+        int variationSize = NextUnicode(unicodes, &variationCodePoint, i + size , count);\n+        bool hasVariationSelector = variationSize > 0 &&\n+                ((variationCodePoint >= VSS_START && variationCodePoint <= VSS_END) ||\n+                 (variationCodePoint >= VS_START && variationCodePoint <= VS_END));\n+        if (hasVariationSelector) {\n+            size += variationSize;\n+        }\n@@ -112,1 +134,1 @@\n-        if (glyph > 0) {\n+        if (glyph > 0 && (!hasVariationSelector || glyphs[i + codePointSize] > 0)) {\n@@ -114,1 +136,0 @@\n-            if (surrogatePair) i++;\n@@ -119,1 +140,1 @@\n-                                                                          surrogatePair ? 2 : 1);\n+                                                                          size);\n@@ -121,1 +142,1 @@\n-            CTFontGetGlyphsForCharacters(fallback, &unicodes[i], &glyphs[i], surrogatePair ? 2 : 1);\n+            CTFontGetGlyphsForCharacters(fallback, &unicodes[i], &glyphs[i], size);\n@@ -127,2 +148,0 @@\n-            int codePoint = surrogatePair ? (((int)(unicode - HI_SURROGATE_START)) << 10)\n-                                            + nextUnicode - LO_SURROGATE_START + 0x10000 : unicode;\n@@ -133,1 +152,0 @@\n-        if (surrogatePair) i++;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/CoreTextSupport.m","additions":31,"deletions":13,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -716,1 +716,1 @@\n-        if (ginfo->rowBytes == ginfo->width) {\n+        if (ginfo->format == sun_font_StrikeCache_PIXEL_FORMAT_GREYSCALE) {\n@@ -727,1 +727,1 @@\n-        } else if (ginfo->rowBytes == ginfo->width * 4) {\n+        } else if (ginfo->format == sun_font_StrikeCache_PIXEL_FORMAT_BGRA) {\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLTextRenderer.m","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1067,1 +1067,1 @@\n-    final int getControlCodeGlyph(int charCode, boolean noSurrogates) {\n+    static int getControlCodeGlyph(int charCode, boolean noSurrogates) {\n@@ -1080,1 +1080,1 @@\n-    final char getFormatCharGlyph(int charCode) {\n+    static char getFormatCharGlyph(int charCode) {\n@@ -1147,3 +1147,1 @@\n-        static final int VS_NOGLYPH = 0;\n-        private int getGlyph(int charCode, int variationSelector) {\n-            int targetSelector = -1;\n+        private int findVariationSelectorIndex(int variationSelector) {\n@@ -1152,2 +1150,1 @@\n-                    targetSelector = i;\n-                    break;\n+                    return i;\n@@ -1156,0 +1153,5 @@\n+            return -1;\n+        }\n+\n+        static final int VS_NOGLYPH = 0;\n+        private int getGlyph(int charCode, int targetSelector) {\n@@ -1171,0 +1173,3 @@\n+        if (variationSelector == 0) {\n+            return getGlyph(charCode);\n+        }\n@@ -1172,8 +1177,9 @@\n-        if (uvs == null) {\n-            glyph = getGlyph(charCode);\n-        } else {\n-            int result = uvs.getGlyph(charCode, variationSelector);\n-            if (result > 0) {\n-                glyph = (char)(result & 0xFFFF);\n-            } else {\n-                glyph = getGlyph(charCode);\n+        if (uvs != null) {\n+            int targetSelector = uvs.findVariationSelectorIndex(variationSelector);\n+            if (targetSelector != -1) {\n+                int result = uvs.getGlyph(charCode, targetSelector);\n+                if (result > 0) {\n+                    glyph = (char)(result & 0xFFFF);\n+                } else {\n+                    glyph = getGlyph(charCode);\n+                }\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/CMap.java","additions":21,"deletions":15,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -91,2 +91,25 @@\n-    public abstract void charsToGlyphs(int count,\n-                                       char[] unicodes, int[] glyphs);\n+    private boolean charsToGlyphs(int count, char[] unicodes, int[] glyphs, boolean checkShaping) {\n+        for (int i = 0; i < count; i++) {\n+            int code = unicodes[i]; \/\/ char is unsigned.\n+            if (code >= HI_SURROGATE_START && code <= HI_SURROGATE_END && i < count - 1) {\n+                char low = unicodes[i + 1];\n+                if (low >= LO_SURROGATE_START && low <= LO_SURROGATE_END) {\n+                    code = (code - HI_SURROGATE_START) * 0x400 + low - LO_SURROGATE_START + 0x10000;\n+                    glyphs[i + 1] = INVISIBLE_GLYPH_ID;\n+                }\n+            }\n+\n+            glyphs[i] = charToGlyph(code);\n+\n+            if (code >= FontUtilities.MIN_LAYOUT_CHARCODE) {\n+                if (checkShaping &&\n+                        (FontUtilities.isComplexCharCode(code) ||\n+                         CharToGlyphMapper.isVariationSelector(code))) {\n+                    return true;\n+                } else if (code >= 0x10000) {\n+                    i++; \/\/ Empty glyph slot after surrogate.\n+                }\n+            }\n+        }\n+        return false;\n+    }\n@@ -94,2 +117,3 @@\n-    public abstract boolean charsToGlyphsNS(int count,\n-                                            char[] unicodes, int[] glyphs);\n+    public void charsToGlyphs(int count, char[] unicodes, int[] glyphs) {\n+        charsToGlyphs(count, unicodes, glyphs, false);\n+    }\n@@ -97,2 +121,10 @@\n-    public abstract void charsToGlyphs(int count,\n-                                       int[] unicodes, int[] glyphs);\n+    public boolean charsToGlyphsNS(int count, char[] unicodes, int[] glyphs) {\n+        return charsToGlyphs(count, unicodes, glyphs, true);\n+    }\n+\n+    public void charsToGlyphs(int count,\n+                              int[] unicodes, int[] glyphs) {\n+        for (int i = 0; i < count; i++) {\n+            glyphs[i] = charToGlyph(unicodes[i]);\n+        }\n+    }\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/CharToGlyphMapper.java","additions":38,"deletions":6,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.util.Arrays;\n+import java.util.List;\n@@ -49,1 +51,1 @@\n-    private PhysicalFont[] components;\n+    private Font2D[] components;\n@@ -56,0 +58,1 @@\n+    int slotShift, slotMask;\n@@ -69,8 +72,3 @@\n-        if (compNames == null) {\n-            numSlots = componentFileNames.length;\n-        } else {\n-            numSlots = componentNames.length;\n-        }\n-        \/* We will limit the number of slots to 254.\n-         * We store the slot for a glyph id in a byte and we may use one slot\n-         * for an EUDC font, and we may also create a composite\n+        \/* We will limit the number of slots to 255.\n+         * Previously we stored the slot for a glyph\n+         * id in a byte, and we may create a composite\n@@ -78,1 +76,4 @@\n-         * So we want to leave space for the two additional slots.\n+         * That's not a problem anymore, as number of bits\n+         * reserved for a slot index can vary (see #slotShift),\n+         * but the more it takes, the less is left for actual\n+         * glyph code, so we'll keep this limit for now.\n@@ -80,1 +81,3 @@\n-         numSlots = (numSlots <= 254) ? numSlots : 254;\n+        List<Font2D> additionalFallbackFonts = fm.getAdditionalFallbackFonts();\n+        numSlots = Math.min(255, additionalFallbackFonts.size() +\n+                (compNames != null ? compNames.length : compFileNames.length));\n@@ -85,1 +88,1 @@\n-        numMetricsSlots = metricsSlotCnt;\n+        numMetricsSlots = Math.min(metricsSlotCnt, numSlots);\n@@ -89,0 +92,7 @@\n+        components = new Font2D[numSlots];\n+        deferredInitialisation = new boolean[numSlots];\n+        if (defer) {\n+            Arrays.fill(deferredInitialisation, 0, numMetricsSlots, true);\n+            Arrays.fill(deferredInitialisation, numMetricsSlots +\n+                    additionalFallbackFonts.size(), numSlots, true);\n+        }\n@@ -90,2 +100,1 @@\n-         * See if this is a windows locale which has a system EUDC font.\n-         * If so add it as the final fallback component of the composite.\n+         * Insert additional fallback fonts if any.\n@@ -95,1 +104,1 @@\n-        if (fm.getEUDCFont() != null) {\n+        if (!additionalFallbackFonts.isEmpty()) {\n@@ -97,2 +106,2 @@\n-            int fbCnt = numSlots - msCnt;\n-            numSlots++;\n+            int adCnt = additionalFallbackFonts.size();\n+            int fbCnt = numSlots - msCnt - adCnt;\n@@ -102,3 +111,5 @@\n-                componentNames[msCnt] = fm.getEUDCFont().getFontName(null);\n-                System.arraycopy(compNames, msCnt,\n-                                 componentNames, msCnt+1, fbCnt);\n+                for (int i = 0; i < adCnt; i++) {\n+                    componentNames[msCnt + i] =\n+                            additionalFallbackFonts.get(i).getFontName(null);\n+                }\n+                System.arraycopy(compNames, msCnt, componentNames, msCnt+adCnt, fbCnt);\n@@ -108,4 +119,2 @@\n-                System.arraycopy(compFileNames, 0,\n-                                  componentFileNames, 0, msCnt);\n-                System.arraycopy(compFileNames, msCnt,\n-                                  componentFileNames, msCnt+1, fbCnt);\n+                System.arraycopy(compFileNames, 0, componentFileNames, 0, msCnt);\n+                System.arraycopy(compFileNames, msCnt, componentFileNames, msCnt+adCnt, fbCnt);\n@@ -113,15 +122,2 @@\n-            components = new PhysicalFont[numSlots];\n-            components[msCnt] = fm.getEUDCFont();\n-            deferredInitialisation = new boolean[numSlots];\n-            if (defer) {\n-                for (int i=0; i<numSlots-1; i++) {\n-                    deferredInitialisation[i] = true;\n-                }\n-            }\n-        } else {\n-            components = new PhysicalFont[numSlots];\n-            deferredInitialisation = new boolean[numSlots];\n-            if (defer) {\n-                for (int i=0; i<numSlots; i++) {\n-                    deferredInitialisation[i] = true;\n-                }\n+            for (int i = 0; i < adCnt; i++) {\n+                components[msCnt + i] = additionalFallbackFonts.get(i);\n@@ -155,0 +151,1 @@\n+        initSlotMask();\n@@ -160,1 +157,1 @@\n-    CompositeFont(PhysicalFont[] slotFonts) {\n+    CompositeFont(Font2D[] slotFonts) {\n@@ -171,1 +168,1 @@\n-        components = new PhysicalFont[numSlots];\n+        components = new Font2D[numSlots];\n@@ -174,0 +171,1 @@\n+        initSlotMask();\n@@ -178,1 +176,1 @@\n-     * It creates a new CompositeFont with the contents of the Physical\n+     * It creates a new CompositeFont with the contents of the\n@@ -181,1 +179,1 @@\n-    CompositeFont(PhysicalFont physFont, CompositeFont compFont) {\n+    CompositeFont(Font2D font, CompositeFont compFont) {\n@@ -185,3 +183,3 @@\n-        fullName = physFont.fullName;\n-        familyName = physFont.familyName;\n-        style = physFont.style;\n+        fullName = font.fullName;\n+        familyName = font.familyName;\n+        style = font.style;\n@@ -200,2 +198,2 @@\n-            components = new PhysicalFont[numSlots];\n-            components[0] = physFont;\n+            components = new Font2D[numSlots];\n+            components[0] = font;\n@@ -207,1 +205,1 @@\n-                componentNames[0] = physFont.fullName;\n+                componentNames[0] = font.fullName;\n@@ -222,0 +220,19 @@\n+        initSlotMask();\n+    }\n+\n+    private void initSlotMask() {\n+        \/\/ slotShift = number of lowest bits encoding the slot index.\n+        slotShift = 32 - Integer.numberOfLeadingZeros(numSlots - 1); \/\/ ceil(log2(numSlots))\n+        slotMask = (1 << slotShift) - 1; \/\/ Mask for extracting the slot index.\n+    }\n+\n+    int decodeSlot(int glyphCode) {\n+        return glyphCode & slotMask;\n+    }\n+\n+    int decodeGlyphCode(int glyphCode) {\n+        return glyphCode >>> slotShift;\n+    }\n+\n+    int compositeGlyphCode(int slot, int glyphCode) {\n+        return (glyphCode << slotShift) | (slot & slotMask);\n@@ -303,9 +320,4 @@\n-                    try {\n-                        components[slot] =\n-                            (PhysicalFont) fm.findFont2D(componentNames[slot],\n-                                                         style,\n-                                                FontManager.PHYSICAL_FALLBACK);\n-                    } catch (ClassCastException cce) {\n-                        \/* Assign default physical font to the slot *\/\n-                        components[slot] = fm.getDefaultPhysicalFont();\n-                    }\n+                    components[slot] =\n+                        fm.findFont2D(componentNames[slot],\n+                                                     style,\n+                                            FontManager.PHYSICAL_FALLBACK);\n@@ -319,1 +331,1 @@\n-    void replaceComponentFont(PhysicalFont oldFont, PhysicalFont newFont) {\n+    void replaceComponentFont(Font2D oldFont, Font2D newFont) {\n@@ -357,1 +369,1 @@\n-        PhysicalFont font = getSlotFont(0);\n+        Font2D font = getSlotFont(0);\n@@ -369,1 +381,1 @@\n-    public PhysicalFont getSlotFont(int slot) {\n+    public Font2D getSlotFont(int slot) {\n@@ -380,1 +392,1 @@\n-            PhysicalFont font = components[slot];\n+            Font2D font = components[slot];\n@@ -382,8 +394,4 @@\n-                try {\n-                    font = (PhysicalFont) fm.\n-                        findFont2D(componentNames[slot], style,\n-                                   FontManager.PHYSICAL_FALLBACK);\n-                    components[slot] = font;\n-                } catch (ClassCastException cce) {\n-                    font = fm.getDefaultPhysicalFont();\n-                }\n+                font = fm.\n+                    findFont2D(componentNames[slot], style,\n+                               FontManager.PHYSICAL_FALLBACK);\n+                components[slot] = font;\n@@ -416,1 +424,1 @@\n-        int slot = glyphCode >>> 24;\n+        int slot = decodeSlot(glyphCode);\n@@ -421,2 +429,2 @@\n-        int slotglyphCode = glyphCode & CompositeStrike.SLOTMASK;\n-        PhysicalFont slotFont = getSlotFont(slot);\n+        int slotglyphCode = decodeGlyphCode(glyphCode);\n+        Font2D slotFont = getSlotFont(slot);\n@@ -491,0 +499,8 @@\n+    @Override\n+    public SlotInfo getSlotInfoForGlyph(int glyphCode) {\n+        SlotInfo info = getSlotFont(decodeSlot(glyphCode))\n+                .getSlotInfoForGlyph(decodeGlyphCode(glyphCode));\n+        info.slotShift += slotShift;\n+        return info;\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/CompositeFont.java","additions":89,"deletions":73,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -47,3 +47,0 @@\n-    public static final int SLOTMASK =  0xff000000;\n-    public static final int GLYPHMASK = 0x00ffffff;\n-\n@@ -70,4 +67,0 @@\n-    public int compositeGlyphCode(int slot, int glyphCode) {\n-        return (slot << 24 | (glyphCode & GLYPHMASK));\n-    }\n-\n@@ -82,1 +75,1 @@\n-            missingGlyph = compositeGlyphCode(0, missingGlyph);\n+            missingGlyph = font.compositeGlyphCode(0, missingGlyph);\n@@ -120,1 +113,5 @@\n-    private int convertToGlyph(int unicode) {\n+    protected int convertToGlyph(int unicode) {\n+        return convertToGlyph(unicode, 0);\n+    }\n+\n+    protected int convertToGlyph(int unicode, int variationSelector) {\n@@ -125,1 +122,1 @@\n-                int glyphCode = mapper.charToGlyph(unicode);\n+                int glyphCode = mapper.charToVariationGlyph(unicode, variationSelector);\n@@ -127,2 +124,4 @@\n-                    glyphCode = compositeGlyphCode(slot, glyphCode);\n-                    setCachedGlyphCode(unicode, glyphCode);\n+                    glyphCode = font.compositeGlyphCode(slot, glyphCode);\n+                    if (variationSelector == 0) {\n+                        setCachedGlyphCode(unicode, glyphCode);\n+                    }\n@@ -136,0 +135,11 @@\n+    @Override\n+    public int charToVariationGlyph(int unicode, int variationSelector) {\n+        if (variationSelector == 0) {\n+            return charToGlyph(unicode);\n+        } else {\n+            int glyph = convertToGlyph(unicode, variationSelector);\n+            \/\/ Fallback to base glyph if variation was not found.\n+            return glyph != missingGlyph ? glyph : charToGlyph(unicode);\n+        }\n+    }\n+\n@@ -172,1 +182,1 @@\n-                return compositeGlyphCode(prefSlot, glyphCode);\n+                return font.compositeGlyphCode(prefSlot, glyphCode);\n@@ -187,87 +197,0 @@\n-    \/* This variant checks if shaping is needed and immediately\n-     * returns true if it does. A caller of this method should be expecting\n-     * to check the return type because it needs to know how to handle\n-     * the character data for display.\n-     *\/\n-    public boolean charsToGlyphsNS(int count, char[] unicodes, int[] glyphs) {\n-\n-        for (int i=0; i<count; i++) {\n-            int code = unicodes[i]; \/\/ char is unsigned.\n-\n-            if (code >= HI_SURROGATE_START &&\n-                code <= HI_SURROGATE_END && i < count - 1) {\n-                char low = unicodes[i + 1];\n-\n-                if (low >= LO_SURROGATE_START &&\n-                    low <= LO_SURROGATE_END) {\n-                    code = (code - HI_SURROGATE_START) *\n-                        0x400 + low - LO_SURROGATE_START + 0x10000;\n-                    glyphs[i + 1] = INVISIBLE_GLYPH_ID;\n-                }\n-            }\n-\n-            int gc = glyphs[i] = getCachedGlyphCode(code);\n-            if (gc == UNINITIALIZED_GLYPH) {\n-                glyphs[i] = convertToGlyph(code);\n-            }\n-\n-            if (code < FontUtilities.MIN_LAYOUT_CHARCODE) {\n-                continue;\n-            }\n-            else if (FontUtilities.isComplexCharCode(code) ||\n-                     CharToGlyphMapper.isVariationSelector(code)) {\n-                return true;\n-            }\n-            else if (code >= 0x10000) {\n-                i += 1; \/\/ Empty glyph slot after surrogate\n-                continue;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    \/* The conversion is not very efficient - looping as it does, converting\n-     * one char at a time. However the cache should fill very rapidly.\n-     *\/\n-    public void charsToGlyphs(int count, char[] unicodes, int[] glyphs) {\n-        for (int i=0; i<count; i++) {\n-            int code = unicodes[i]; \/\/ char is unsigned.\n-\n-            if (code >= HI_SURROGATE_START &&\n-                code <= HI_SURROGATE_END && i < count - 1) {\n-                char low = unicodes[i + 1];\n-\n-                if (low >= LO_SURROGATE_START &&\n-                    low <= LO_SURROGATE_END) {\n-                    code = (code - HI_SURROGATE_START) *\n-                        0x400 + low - LO_SURROGATE_START + 0x10000;\n-\n-                    int gc = glyphs[i] = getCachedGlyphCode(code);\n-                    if (gc == UNINITIALIZED_GLYPH) {\n-                        glyphs[i] = convertToGlyph(code);\n-                    }\n-                    i += 1; \/\/ Empty glyph slot after surrogate\n-                    glyphs[i] = INVISIBLE_GLYPH_ID;\n-                    continue;\n-                }\n-            }\n-\n-            int gc = glyphs[i] = getCachedGlyphCode(code);\n-            if (gc == UNINITIALIZED_GLYPH) {\n-                glyphs[i] = convertToGlyph(code);\n-            }\n-        }\n-    }\n-\n-    public void charsToGlyphs(int count, int[] unicodes, int[] glyphs) {\n-        for (int i=0; i<count; i++) {\n-            int code = unicodes[i];\n-\n-            glyphs[i] = getCachedGlyphCode(code);\n-            if (glyphs[i] == UNINITIALIZED_GLYPH) {\n-                glyphs[i] = convertToGlyph(code);\n-            }\n-        }\n-    }\n-\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/CompositeGlyphMapper.java","additions":23,"deletions":100,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -44,2 +44,0 @@\n-    static final int SLOTMASK = 0xffffff;\n-\n@@ -47,1 +45,1 @@\n-    private PhysicalStrike[] strikes;\n+    private FontStrike[] strikes;\n@@ -65,1 +63,1 @@\n-        strikes = new PhysicalStrike[compFont.numSlots];\n+        strikes = new FontStrike[compFont.numSlots];\n@@ -69,2 +67,2 @@\n-    PhysicalStrike getStrikeForGlyph(int glyphCode) {\n-        return getStrikeForSlot(glyphCode >>> 24);\n+    FontStrike getStrikeForGlyph(int glyphCode) {\n+        return getStrikeForSlot(compFont.decodeSlot(glyphCode));\n@@ -73,1 +71,1 @@\n-    PhysicalStrike getStrikeForSlot(int slot) {\n+    FontStrike getStrikeForSlot(int slot) {\n@@ -77,1 +75,1 @@\n-        PhysicalStrike strike = strikes[slot];\n+        FontStrike strike = strikes[slot];\n@@ -80,1 +78,1 @@\n-                (PhysicalStrike)(compFont.getSlotFont(slot).getStrike(desc));\n+                compFont.getSlotFont(slot).getStrike(desc);\n@@ -116,2 +114,3 @@\n-        PhysicalStrike strike = getStrikeForSlot(0);\n-        int numptrs = strike.getSlot0GlyphImagePtrs(glyphCodes, images, len);\n+        FontStrike strike = getStrikeForSlot(0);\n+        int numptrs = strike.getSlot0GlyphImagePtrs(glyphCodes, images, len,\n+                compFont.slotMask, compFont.slotShift);\n@@ -123,1 +122,1 @@\n-            images[i] = strike.getGlyphImagePtr(glyphCodes[i] & SLOTMASK);\n+            images[i] = strike.getGlyphImagePtr(compFont.decodeGlyphCode(glyphCodes[i]));\n@@ -129,2 +128,2 @@\n-        PhysicalStrike strike = getStrikeForGlyph(glyphCode);\n-        return strike.getGlyphImagePtr(glyphCode & SLOTMASK);\n+        FontStrike strike = getStrikeForGlyph(glyphCode);\n+        return strike.getGlyphImagePtr(compFont.decodeGlyphCode(glyphCode));\n@@ -134,2 +133,2 @@\n-        PhysicalStrike strike = getStrikeForGlyph(glyphCode);\n-        strike.getGlyphImageBounds(glyphCode & SLOTMASK, pt, result);\n+        FontStrike strike = getStrikeForGlyph(glyphCode);\n+        strike.getGlyphImageBounds(compFont.decodeGlyphCode(glyphCode), pt, result);\n@@ -139,2 +138,2 @@\n-        PhysicalStrike strike = getStrikeForGlyph(glyphCode);\n-        return strike.getGlyphMetrics(glyphCode & SLOTMASK);\n+        FontStrike strike = getStrikeForGlyph(glyphCode);\n+        return strike.getGlyphMetrics(compFont.decodeGlyphCode(glyphCode));\n@@ -148,2 +147,2 @@\n-        PhysicalStrike strike = getStrikeForGlyph(glyphCode);\n-        return strike.getGlyphAdvance(glyphCode & SLOTMASK);\n+        FontStrike strike = getStrikeForGlyph(glyphCode);\n+        return strike.getGlyphAdvance(compFont.decodeGlyphCode(glyphCode));\n@@ -164,2 +163,2 @@\n-        PhysicalStrike strike = getStrikeForGlyph(glyphCode);\n-        return strike.getGlyphOutlineBounds(glyphCode & SLOTMASK);\n+        FontStrike strike = getStrikeForGlyph(glyphCode);\n+        return strike.getGlyphOutlineBounds(compFont.decodeGlyphCode(glyphCode));\n@@ -170,2 +169,2 @@\n-        PhysicalStrike strike = getStrikeForGlyph(glyphCode);\n-        GeneralPath path = strike.getGlyphOutline(glyphCode & SLOTMASK, x, y);\n+        FontStrike strike = getStrikeForGlyph(glyphCode);\n+        GeneralPath path = strike.getGlyphOutline(compFont.decodeGlyphCode(glyphCode), x, y);\n@@ -179,37 +178,3 @@\n-    \/* The physical font slot for each glyph is encoded in the glyph ID\n-     * To be as efficient as possible we find a run of glyphs from the\n-     * same slot and create a temporary array of these glyphs decoded\n-     * to the slot. The slot font is then queried for the GeneralPath\n-     * for that run of glyphs. GeneralPaths from each run are appended\n-     * to create the shape for the whole glyph array.\n-     *\/\n-    GeneralPath getGlyphVectorOutline(int[] glyphs, float x, float y) {\n-        GeneralPath path = null;\n-        GeneralPath gp;\n-        int glyphIndex = 0;\n-        int[] tmpGlyphs;\n-\n-        while (glyphIndex < glyphs.length) {\n-            int start = glyphIndex;\n-            int slot = glyphs[glyphIndex] >>> 24;\n-            while (glyphIndex < glyphs.length &&\n-                   (glyphs[glyphIndex+1] >>> 24) == slot) {\n-                glyphIndex++;\n-            }\n-            int tmpLen = glyphIndex-start+1;\n-            tmpGlyphs = new int[tmpLen];\n-            for (int i=0;i<tmpLen;i++) {\n-                tmpGlyphs[i] = glyphs[i] & SLOTMASK;\n-            }\n-            gp = getStrikeForSlot(slot).getGlyphVectorOutline(tmpGlyphs, x, y);\n-            if (path == null) {\n-                path = gp;\n-            } else if (gp != null) {\n-                path.append(gp, false);\n-            }\n-        }\n-        if (path == null) {\n-            return new GeneralPath();\n-        } else {\n-            return path;\n-        }\n+    GlyphRenderData getGlyphRenderData(int glyphCode, float x, float y) {\n+        FontStrike strike = getStrikeForGlyph(glyphCode);\n+        return strike.getGlyphRenderData(compFont.decodeGlyphCode(glyphCode), x, y);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/CompositeStrike.java","additions":26,"deletions":61,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -224,1 +224,2 @@\n-    GeneralPath getGlyphVectorOutline(long pScalerContext, int[] glyphs, int numGlyphs, float x, float y) {\n+    public GlyphRenderData getGlyphRenderData(long pScalerContext, int glyphCode,\n+                                              float x, float y) {\n@@ -226,1 +227,1 @@\n-            return getScaler().getGlyphVectorOutline(pScalerContext, glyphs, numGlyphs, x, y);\n+            return getScaler().getGlyphRenderData(pScalerContext, glyphCode, x, y);\n@@ -229,1 +230,1 @@\n-            return getGlyphVectorOutline(pScalerContext, glyphs, numGlyphs, x, y);\n+            return getGlyphRenderData(pScalerContext, glyphCode, x, y);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FileFont.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -222,1 +222,2 @@\n-            !((TrueTypeFont)fileFont).useEmbeddedBitmapsForSize(intPtSize)) {\n+            !((TrueTypeFont)fileFont).useEmbeddedBitmapsForSize(intPtSize) &&\n+            !((TrueTypeFont)fileFont).hasCOLRTable()) {\n@@ -393,1 +394,1 @@\n-    int getSlot0GlyphImagePtrs(int[] glyphCodes, long[] images, int len) {\n+    int getSlot0GlyphImagePtrs(int[] glyphCodes, long[] images, int len, int slotMask, int slotShift) {\n@@ -399,1 +400,1 @@\n-            if (glyphCode >>> 24 != 0) {\n+            if ((glyphCode & slotMask) != 0) {\n@@ -403,0 +404,1 @@\n+                glyphCode >>>= slotShift;\n@@ -742,1 +744,5 @@\n-        int width = StrikeCache.unsafe.getChar(ptr+StrikeCache.widthOffset);\n+        byte format = StrikeCache.unsafe.getByte(ptr+StrikeCache.formatOffset);\n+        if (format != StrikeCache.PIXEL_FORMAT_LCD) {\n+            return origMinX;\n+        }\n+\n@@ -747,4 +753,0 @@\n-        if (rowBytes == width) {\n-            return origMinX;\n-        }\n-\n@@ -937,3 +939,28 @@\n-    GeneralPath getGlyphVectorOutline(int[] glyphs, float x, float y) {\n-        return fileFont.getGlyphVectorOutline(pScalerContext,\n-                                              glyphs, glyphs.length, x, y);\n+    private\n+        WeakReference<ConcurrentHashMap<Integer, GlyphRenderData>> glyphRenderDataMapRef;\n+\n+    GlyphRenderData getGlyphRenderData(int glyphCode, float x, float y) {\n+\n+        GlyphRenderData grd = null;\n+        ConcurrentHashMap<Integer, GlyphRenderData> glyphRenderDataMap = null;\n+\n+        if (glyphRenderDataMapRef != null) {\n+            glyphRenderDataMap = glyphRenderDataMapRef.get();\n+            if (glyphRenderDataMap != null) {\n+                grd = glyphRenderDataMap.get(glyphCode);\n+            }\n+        }\n+\n+        if (grd == null) {\n+            grd = fileFont.getGlyphRenderData(pScalerContext, glyphCode, 0, 0);\n+            if (glyphRenderDataMap == null) {\n+                glyphRenderDataMap = new ConcurrentHashMap<>();\n+                glyphRenderDataMapRef = new WeakReference<>(glyphRenderDataMap);\n+            }\n+            glyphRenderDataMap.put(glyphCode, grd);\n+        }\n+        grd = new GlyphRenderData(grd); \/\/ mutable!\n+        if (x != 0f || y != 0f) {\n+            grd.transform(AffineTransform.getTranslateInstance(x, y));\n+        }\n+        return grd;\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FileFontStrike.java","additions":38,"deletions":11,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -573,0 +573,15 @@\n+    public static class SlotInfo {\n+        public Font2D font;\n+        public int slotShift;\n+        public SlotInfo(Font2D font) {\n+            this.font = font;\n+        }\n+        public int getSlotMask() {\n+            return (1 << slotShift) - 1;\n+        }\n+    }\n+\n+    public SlotInfo getSlotInfoForGlyph(int glyphCode) {\n+        return new SlotInfo(this);\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/Font2D.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -37,4 +37,3 @@\n-    CompositeFont font;\n-    char[] text;\n-    int start;\n-    int limit;\n+    private Font2D font;\n+    private char[] text;\n+    private int limit;\n@@ -42,1 +41,1 @@\n-    CompositeGlyphMapper mapper; \/\/ handy cache\n+    private CharToGlyphMapper mapper; \/\/ handy cache\n@@ -44,2 +43,3 @@\n-    int slot = -1;\n-    int pos;\n+    private int slot;\n+    private int pos;\n+    private Font2D.SlotInfo slotInfo;\n@@ -47,1 +47,1 @@\n-    public void init(CompositeFont font, char[] text, int start, int limit) {\n+    public void init(Font2D font, char[] text, int start, int limit) {\n@@ -54,1 +54,0 @@\n-        this.start = start;\n@@ -57,2 +56,2 @@\n-        this.mapper = (CompositeGlyphMapper)font.getMapper();\n-        this.slot = -1;\n+        this.mapper = font.getMapper();\n+        this.slot = 0;\n@@ -60,0 +59,1 @@\n+        this.slotInfo = null;\n@@ -62,2 +62,2 @@\n-    public PhysicalFont getFont() {\n-        return slot == -1 ? null : font.getSlotFont(slot);\n+    public Font2D.SlotInfo getSlotInfo() {\n+        return slotInfo;\n@@ -66,2 +66,2 @@\n-    public int getGlyphMask() {\n-        return slot << 24;\n+    public int getSlot() {\n+        return slot;\n@@ -115,1 +115,1 @@\n-    public boolean next(int script, int lim) {\n+    public boolean next(int lim) {\n@@ -121,3 +121,21 @@\n-        int sl = mapper.charToGlyph(ch) & CompositeGlyphMapper.SLOTMASK;\n-        slot = sl >>> 24;\n-        while ((ch = nextCodePoint(lim)) != DONE && (mapper.charToGlyph(ch) & CompositeGlyphMapper.SLOTMASK) == sl);\n+        int nch = nextCodePoint(lim);\n+        int vs = CharToGlyphMapper.isVariationSelector(nch) ? nch : 0;\n+        int gl = mapper.charToVariationGlyph(ch, vs);\n+        slotInfo = font.getSlotInfoForGlyph(gl);\n+        int slotMask = slotInfo.getSlotMask();\n+        slot = gl & slotMask;\n+        if (slotInfo.slotShift == 0) {\n+            \/\/ This is a non-composite font, so return early.\n+            pos = lim;\n+            return true;\n+        }\n+        do {\n+            if (vs == 0) {\n+                ch = nch;\n+            } else {\n+                ch = nextCodePoint(lim);\n+            }\n+            nch = nextCodePoint(lim);\n+            vs = CharToGlyphMapper.isVariationSelector(nch) ? nch : 0;\n+        } while(ch != DONE && isSameRun(ch, vs, slotMask));\n+        pushback(nch);\n@@ -129,2 +147,7 @@\n-    public boolean next() {\n-        return next(Script.COMMON, limit);\n+    private boolean isSameRun(int ch, int variationSelector, int slotMask) {\n+        \/\/ Every font is meant to be able to render format chars\n+        \/\/ So we make format chars stick to the current font run\n+        if (CMap.getFormatCharGlyph(ch) == CharToGlyphMapper.INVISIBLE_GLYPH_ID) {\n+            return true;\n+        }\n+        return (mapper.charToVariationGlyph(ch, variationSelector) & slotMask) == slot;\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FontRunIterator.java","additions":44,"deletions":21,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -167,2 +167,2 @@\n-    abstract GeneralPath getGlyphVectorOutline(long pScalerContext, int[] glyphs,\n-                                               int numGlyphs, float x, float y)\n+    abstract GlyphRenderData getGlyphRenderData(long pScalerContext, int glyphCode,\n+                                                float x, float y)\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FontScaler.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -76,2 +76,1 @@\n-    abstract GeneralPath\n-        getGlyphVectorOutline(int[] glyphs, float x, float y);\n+    abstract GlyphRenderData getGlyphRenderData(int glyphCode, float x, float y);\n@@ -79,0 +78,3 @@\n+    int getSlot0GlyphImagePtrs(int[] glyphCodes, long[] images, int len, int slotMask, int slotShift) {\n+        return 0;\n+    }\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FontStrike.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-    public static final int MAX_LAYOUT_CHARCODE = 0x206F;\n+    public static final int MAX_LAYOUT_CHARCODE = CharToGlyphMapper.VSS_END;\n@@ -308,0 +308,15 @@\n+        else if (code >= 0x20d0 && code <= 0x20f0) { \/\/ U+20D0 - U+20F0 combining diacritical marks for symbols\n+            return true;\n+        }\n+        else if (code >= 0x1f1e6 && code <= 0x1f1ff) { \/\/ U+1F1E6 - U+1F1FF flag letters https:\/\/emojipedia.org\/emoji-flag-sequence\/\n+            return true;\n+        }\n+        else if (code == 0x1f3f4) { \/\/ black flag https:\/\/emojipedia.org\/emoji-tag-sequence\/\n+            return true;\n+        }\n+        else if (code >= 0x1f3fb && code <= 0x1f3ff) { \/\/ U+1F3FB - U+1F3FF emoji modifiers\n+            return true;\n+        }\n+        else if (CharToGlyphMapper.isVariationSelector(code)) {\n+            return true;\n+        }\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FontUtilities.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -151,3 +151,2 @@\n-    synchronized GeneralPath getGlyphVectorOutline(\n-                     long pScalerContext, int[] glyphs, int numGlyphs,\n-                     float x, float y) throws FontScalerException {\n+    synchronized GlyphRenderData getGlyphRenderData(long pScalerContext, int glyphCode,\n+                                                    float x, float y) throws FontScalerException {\n@@ -155,6 +154,7 @@\n-            return getGlyphVectorOutlineNative(font.get(),\n-                                               pScalerContext,\n-                                               nativeScaler,\n-                                               glyphs,\n-                                               numGlyphs,\n-                                               x, y);\n+            GlyphRenderData result = new GlyphRenderData();\n+            getGlyphRenderDataNative(font.get(),\n+                                     pScalerContext,\n+                                     nativeScaler,\n+                                     glyphCode,\n+                                     x, y, result);\n+            return result;\n@@ -162,2 +162,2 @@\n-        return FontScaler\n-            .getNullScaler().getGlyphVectorOutline(0L, glyphs, numGlyphs, x, y);\n+        return FontScaler.getNullScaler().\n+                getGlyphRenderData(0L, glyphCode, x,y);\n@@ -253,3 +253,3 @@\n-    private native GeneralPath getGlyphVectorOutlineNative(Font2D font,\n-            long pScalerContext, long pScaler,\n-            int[] glyphs, int numGlyphs, float x, float y);\n+    private native void getGlyphRenderDataNative(Font2D font, long pScalerContext,\n+            long pScaler, int glyphCode,\n+            float x, float y, GlyphRenderData result);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FreetypeFontScaler.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-        public void layout(FontStrikeDesc sd, float[] mat, float ptSize, int gmask,\n+        public void layout(FontStrikeDesc sd, float[] mat, float ptSize, int slot, int slotShift,\n@@ -410,30 +410,13 @@\n-        if (font2D instanceof CompositeFont) {\n-            _scriptRuns.init(text, offset, count); \/\/ ??? how to handle 'common' chars\n-            _fontRuns.init((CompositeFont)font2D, text, offset, lim);\n-            while (_scriptRuns.next()) {\n-                int limit = _scriptRuns.getScriptLimit();\n-                int script = _scriptRuns.getScriptCode();\n-                while (_fontRuns.next(script, limit)) {\n-                    Font2D pfont = _fontRuns.getFont();\n-                    \/* layout can't deal with NativeFont instances. The\n-                     * native font is assumed to know of a suitable non-native\n-                     * substitute font. This currently works because\n-                     * its consistent with the way NativeFonts delegate\n-                     * in other cases too.\n-                     *\/\n-                    if (pfont instanceof NativeFont) {\n-                        pfont = ((NativeFont)pfont).getDelegateFont();\n-                    }\n-                    int gmask = _fontRuns.getGlyphMask();\n-                    int pos = _fontRuns.getPos();\n-                    nextEngineRecord(start, pos, script, lang, pfont, gmask);\n-                    start = pos;\n-                }\n-            }\n-        } else {\n-            _scriptRuns.init(text, offset, count); \/\/ ??? don't worry about 'common' chars\n-            while (_scriptRuns.next()) {\n-                int limit = _scriptRuns.getScriptLimit();\n-                int script = _scriptRuns.getScriptCode();\n-                nextEngineRecord(start, limit, script, lang, font2D, 0);\n-                start = limit;\n+        _scriptRuns.init(text, offset, count); \/\/ ??? how to handle 'common' chars\n+        _fontRuns.init(font2D, text, offset, lim);\n+        while (_scriptRuns.next()) {\n+            int limit = _scriptRuns.getScriptLimit();\n+            int script = _scriptRuns.getScriptCode();\n+            while (_fontRuns.next(limit)) {\n+                Font2D.SlotInfo slotInfo = _fontRuns.getSlotInfo();\n+                Font2D pfont = slotInfo.font;\n+                int slotShift = slotInfo.slotShift;\n+                int slot = _fontRuns.getSlot();\n+                int pos = _fontRuns.getPos();\n+                nextEngineRecord(start, pos, script, lang, pfont, slot, slotShift);\n+                start = pos;\n@@ -511,1 +494,1 @@\n-    private void nextEngineRecord(int start, int limit, int script, int lang, Font2D font, int gmask) {\n+    private void nextEngineRecord(int start, int limit, int script, int lang, Font2D font, int slot, int slotShift) {\n@@ -519,1 +502,1 @@\n-        er.init(start, limit, font, script, lang, gmask);\n+        er.init(start, limit, font, script, lang, slot, slotShift);\n@@ -628,1 +611,2 @@\n-        private int gmask;\n+        private int slot;\n+        private int slotShift;\n@@ -637,1 +621,1 @@\n-        void init(int start, int limit, Font2D font, int script, int lang, int gmask) {\n+        void init(int start, int limit, Font2D font, int script, int lang, int slot, int slotShift) {\n@@ -640,1 +624,2 @@\n-            this.gmask = gmask;\n+            this.slot = slot;\n+            this.slotShift = slotShift;\n@@ -669,1 +654,1 @@\n-            engine.layout(_sd, _mat, ptSize, gmask, start - _offset, _textRecord,\n+            engine.layout(_sd, _mat, ptSize, slot, slotShift, start - _offset, _textRecord,\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/GlyphLayout.java","additions":22,"deletions":37,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -505,1 +505,10 @@\n-        return FontUtilities.isMacOSX;\n+        return true;\n+    }\n+\n+    \/**\n+     * @return {@link StrikeCache#PIXEL_FORMAT_GREYSCALE} for greyscale,\n+     * {@link StrikeCache#PIXEL_FORMAT_LCD} for LCD and {@link StrikeCache#PIXEL_FORMAT_BGRA} for BGRA glyph\n+     *\/\n+    public byte getPixelFormat(int glyphIndex) {\n+        return StrikeCache.unsafe.getByte(images[glyphIndex] +\n+                StrikeCache.formatOffset);\n@@ -509,5 +518,1 @@\n-        int width = StrikeCache.unsafe.getChar(images[glyphIndex] +\n-                                               StrikeCache.widthOffset);\n-        int rowBytes = StrikeCache.unsafe.getChar(images[glyphIndex] +\n-                                                  StrikeCache.rowBytesOffset);\n-        return rowBytes == width * 4;\n+        return getPixelFormat(glyphIndex) == StrikeCache.PIXEL_FORMAT_BGRA;\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/GlyphList.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright 2000-2022 JetBrains s.r.o.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.font;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+import java.awt.*;\n+import java.awt.color.ColorSpace;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.GeneralPath;\n+import java.awt.image.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Data for rendering any number of glyphs bypassing glyph cache.\n+ *\/\n+public class GlyphRenderData {\n+\n+    public GeneralPath outline;\n+    public List<ColorLayer> colorLayers;\n+    public List<Bitmap> bitmaps;\n+\n+    public GlyphRenderData() {}\n+    public GlyphRenderData(GlyphRenderData i) {\n+        if (i.outline != null) {\n+            outline = (GeneralPath) i.outline.clone();\n+        }\n+        if (i.colorLayers != null) {\n+            colorLayers = new ArrayList<>(i.colorLayers.size());\n+            for (ColorLayer l : i.colorLayers) {\n+                colorLayers.add(new ColorLayer(l.color, (GeneralPath) l.outline.clone()));\n+            }\n+        }\n+        if (i.bitmaps != null) {\n+            bitmaps = new ArrayList<>(i.bitmaps.size());\n+            for (Bitmap b : i.bitmaps) {\n+                bitmaps.add(new Bitmap(new AffineTransform(b.transform), b.image));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * @param i must not be used afterwards\n+     *\/\n+    public void merge(GlyphRenderData i) {\n+        if (i.outline != null) {\n+            if (outline == null) {\n+                outline = i.outline;\n+            } else {\n+                outline.append(i.outline.getPathIterator(null), false);\n+            }\n+        }\n+        if (i.colorLayers != null) {\n+            if (colorLayers == null) {\n+                colorLayers = i.colorLayers;\n+            } else {\n+                colorLayers.addAll(i.colorLayers);\n+            }\n+        }\n+        if (i.bitmaps != null) {\n+            if (bitmaps == null) {\n+                bitmaps = i.bitmaps;\n+            } else {\n+                bitmaps.addAll(i.bitmaps);\n+            }\n+        }\n+    }\n+\n+    public void transform(AffineTransform transform) {\n+        if (outline != null) {\n+            outline.transform(transform);\n+        }\n+        if (colorLayers != null) {\n+            for (ColorLayer layer : colorLayers) {\n+                layer.outline.transform(transform);\n+            }\n+        }\n+        if (bitmaps != null) {\n+            for (Bitmap bitmap : bitmaps) {\n+                bitmap.transform.preConcatenate(transform);\n+            }\n+        }\n+    }\n+\n+    public void draw(Graphics2D g) {\n+        if (outline != null) {\n+            g.fill(outline);\n+        }\n+        if (colorLayers != null) {\n+            Color color = g.getColor();\n+            for (ColorLayer layer : colorLayers) {\n+                g.setColor(layer.color == null ? color : layer.color);\n+                g.fill(layer.outline);\n+            }\n+            g.setColor(color);\n+        }\n+        if (bitmaps != null) {\n+            for (Bitmap bitmap : bitmaps) {\n+                g.drawImage(bitmap.image, bitmap.transform, null);\n+            }\n+        }\n+    }\n+\n+    public record ColorLayer(Color color, GeneralPath outline) {}\n+\n+    public record Bitmap(AffineTransform transform, Image image) {}\n+\n+    \/\/ These methods exist for convenience and are called from native\n+\n+    private void setColorLayersList(int capacity) {\n+        colorLayers = new ArrayList<>(capacity);\n+    }\n+\n+    private void addColorLayers(GeneralPath outline) {\n+        colorLayers.add(new ColorLayer(null, outline));\n+    }\n+\n+    private void addColorLayers(int r, int g, int b, int a, GeneralPath outline) {\n+        colorLayers.add(new ColorLayer(new Color(r, g, b, a), outline));\n+    }\n+\n+    private static DirectColorModel colorModel(boolean premultiplied, int bits, int r, int g, int b, int a) {\n+        if (Unsafe.getUnsafe().isBigEndian()) {\n+            r = Integer.reverse(r) >>> (32 - bits);\n+            g = Integer.reverse(g) >>> (32 - bits);\n+            b = Integer.reverse(b) >>> (32 - bits);\n+            a = Integer.reverse(a) >>> (32 - bits);\n+        }\n+        return new DirectColorModel(ColorSpace.getInstance(ColorSpace.CS_sRGB),\n+                bits, r, g, b, a, premultiplied, DataBuffer.TYPE_INT);\n+    }\n+    private static final DirectColorModel[] BITMAP_COLOR_MODELS = {\n+            colorModel(false, 32, \/\/ macOS RGBA\n+                    0x000000ff,\n+                    0x0000ff00,\n+                    0x00ff0000,\n+                    0xff000000),\n+            colorModel(false, 32, \/\/ macOS ARGB\n+                    0x0000ff00,\n+                    0x00ff0000,\n+                    0xff000000,\n+                    0x000000ff),\n+            colorModel(true, 32, \/\/ Freetype BGRA\n+                    0x00ff0000,\n+                    0x0000ff00,\n+                    0x000000ff,\n+                    0xff000000)\n+    };\n+    private void addBitmap(double m00, double m10,\n+                           double m01, double m11,\n+                           double m02, double m12,\n+                           int width, int height, int pitch,\n+                           int colorModel, int[] data) {\n+        if (bitmaps == null) {\n+            bitmaps = new ArrayList<>();\n+        }\n+        DirectColorModel color = BITMAP_COLOR_MODELS[colorModel];\n+        DataBuffer buffer = new DataBufferInt(data, data.length);\n+        WritableRaster raster = Raster.createPackedRaster(buffer, width, height, pitch, color.getMasks(), null);\n+        BufferedImage image = new BufferedImage(color, raster, color.isAlphaPremultiplied(), null);\n+        bitmaps.add(new Bitmap(new AffineTransform(m00, m10, m01, m11, m02, m12), image));\n+    }\n+}\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/GlyphRenderData.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -62,3 +62,3 @@\n-    GeneralPath getGlyphVectorOutline(long pScalerContext, int[] glyphs,\n-        int numGlyphs, float x, float y) {\n-        return new GeneralPath();\n+    GlyphRenderData getGlyphRenderData(long pScalerContext, int glyphCode,\n+                                       float x, float y) {\n+        return new GlyphRenderData();\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/NullFontScaler.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -111,3 +111,0 @@\n-    abstract GeneralPath getGlyphVectorOutline(long pScalerContext,\n-                                               int[] glyphs, int numGlyphs,\n-                                               float x, float y);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/PhysicalFont.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -117,4 +117,0 @@\n-    int getSlot0GlyphImagePtrs(int[] glyphCodes, long[] images, int  len) {\n-        return 0;\n-    }\n-\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/PhysicalStrike.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -880,0 +880,15 @@\n+    public GlyphRenderData getGlyphRenderData(float x, float y) {\n+        setFRCTX();\n+        initPositions();\n+\n+        GlyphRenderData result = new GlyphRenderData();\n+        for (int i = 0, n = 0; i < glyphs.length; ++i, n += 2) {\n+            float px = x + positions[n];\n+            float py = y + positions[n+1];\n+\n+            getGlyphStrike(i).appendGlyphRenderData(glyphs[i], result, px, py);\n+        }\n+\n+        return result;\n+    }\n+\n@@ -1070,1 +1085,4 @@\n-                vglyphs[i] = font2D.getValidatedGlyphCode(oglyphs[i]);\n+                vglyphs[i] = font2D.getValidatedGlyphCode(\n+                        font2D instanceof CompositeFont comp ?\n+                                comp.compositeGlyphCode(0, oglyphs[i]) :\n+                                oglyphs[i]);\n@@ -1819,0 +1837,13 @@\n+\n+        void appendGlyphRenderData(int glyphID, GlyphRenderData result, float x, float y) {\n+            \/\/ !!! fontStrike needs a method for this.  For that matter, GeneralPath does.\n+            GlyphRenderData grd;\n+            if (sgv.invdtx == null) {\n+                grd = strike.getGlyphRenderData(glyphID, x + dx, y + dy);\n+            } else {\n+                grd = strike.getGlyphRenderData(glyphID, 0, 0);\n+                grd.transform(sgv.invdtx);\n+                grd.transform(AffineTransform.getTranslateInstance(x + dx, y + dy));\n+            }\n+            result.merge(grd);\n+        }\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/StandardGlyphVector.java","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.annotation.Native;\n@@ -117,0 +118,1 @@\n+    static int formatOffset;\n@@ -119,0 +121,5 @@\n+    @Native public static final byte PIXEL_FORMAT_UNKNOWN   = -1;\n+    @Native public static final byte PIXEL_FORMAT_GREYSCALE = 1;\n+    @Native public static final byte PIXEL_FORMAT_LCD       = 3;\n+    @Native public static final byte PIXEL_FORMAT_BGRA      = 4;\n+\n@@ -143,1 +150,1 @@\n-        long[] nativeInfo = new long[13];\n+        long[] nativeInfo = new long[14];\n@@ -160,0 +167,1 @@\n+        formatOffset = (int) nativeInfo[13];\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/StrikeCache.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -299,1 +299,1 @@\n-    public TrueTypeFont getEUDCFont() {\n+    public List<Font2D> getAdditionalFallbackFonts() {\n@@ -301,1 +301,1 @@\n-        return null;\n+        return List.of();\n@@ -461,1 +461,1 @@\n-        PhysicalFont oldFont = oldComp.getSlotFont(0);\n+        Font2D oldFont = oldComp.getSlotFont(0);\n@@ -471,2 +471,2 @@\n-        if (!(newFont instanceof PhysicalFont)) {\n-            newFont = oldFont;\n+        if (newFont == null) {\n+            return handle;\n@@ -474,1 +474,0 @@\n-        PhysicalFont physicalFont = (PhysicalFont)newFont;\n@@ -480,1 +479,1 @@\n-        CompositeFont compFont = new CompositeFont(physicalFont, dialog2D);\n+        CompositeFont compFont = new CompositeFont(newFont, dialog2D);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/SunFontManager.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-    public void layout(FontStrikeDesc desc, float[] mat, float ptSize, int gmask,\n+    public void layout(FontStrikeDesc desc, float[] mat, float ptSize, int slot, int slotShift,\n@@ -175,1 +175,1 @@\n-                    typo_flags, gmask);\n+                    typo_flags, slot, slotShift);\n@@ -185,1 +185,1 @@\n-              int baseIndex, Point2D.Float pt, int typo_flags, int slot);\n+              int baseIndex, Point2D.Float pt, int typo_flags, int slot, int slotShift);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/SunLayoutEngine.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+    public static final int COLRTag = 0x434f4c52; \/\/ 'COLR'\n@@ -880,0 +881,4 @@\n+    boolean hasCOLRTable() {\n+        return getDirectoryEntry(COLRTag) != null;\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/TrueTypeFont.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -135,71 +135,0 @@\n-    public void charsToGlyphs(int count, int[] unicodes, int[] glyphs) {\n-        for (int i=0;i<count;i++) {\n-            glyphs[i] = getGlyphFromCMAP(unicodes[i]);\n-        }\n-    }\n-\n-    public void charsToGlyphs(int count, char[] unicodes, int[] glyphs) {\n-\n-        for (int i=0; i<count; i++) {\n-            int code = unicodes[i]; \/\/ char is unsigned.\n-\n-            if (code >= HI_SURROGATE_START &&\n-                code <= HI_SURROGATE_END && i < count - 1) {\n-                char low = unicodes[i + 1];\n-\n-                if (low >= LO_SURROGATE_START &&\n-                    low <= LO_SURROGATE_END) {\n-                    code = (code - HI_SURROGATE_START) *\n-                        0x400 + low - LO_SURROGATE_START + 0x10000;\n-\n-                    glyphs[i] = getGlyphFromCMAP(code);\n-                    i += 1; \/\/ Empty glyph slot after surrogate\n-                    glyphs[i] = INVISIBLE_GLYPH_ID;\n-                    continue;\n-                }\n-            }\n-            glyphs[i] = getGlyphFromCMAP(code);\n-\n-        }\n-    }\n-\n-    \/* This variant checks if shaping is needed and immediately\n-     * returns true if it does. A caller of this method should be expecting\n-     * to check the return type because it needs to know how to handle\n-     * the character data for display.\n-     *\/\n-    public boolean charsToGlyphsNS(int count, char[] unicodes, int[] glyphs) {\n-\n-        for (int i=0; i<count; i++) {\n-            int code = unicodes[i]; \/\/ char is unsigned.\n-\n-            if (code >= HI_SURROGATE_START &&\n-                code <= HI_SURROGATE_END && i < count - 1) {\n-                char low = unicodes[i + 1];\n-\n-                if (low >= LO_SURROGATE_START &&\n-                    low <= LO_SURROGATE_END) {\n-                    code = (code - HI_SURROGATE_START) *\n-                        0x400 + low - LO_SURROGATE_START + 0x10000;\n-                    glyphs[i + 1] = INVISIBLE_GLYPH_ID;\n-                }\n-            }\n-\n-            glyphs[i] = getGlyphFromCMAP(code);\n-\n-            if (code < FontUtilities.MIN_LAYOUT_CHARCODE) {\n-                continue;\n-            }\n-            else if (FontUtilities.isComplexCharCode(code) ||\n-                     CharToGlyphMapper.isVariationSelector(code)) {\n-                return true;\n-            }\n-            else if (code >= 0x10000) {\n-                i += 1; \/\/ Empty glyph slot after surrogate\n-                continue;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/TrueTypeGlyphMapper.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -101,76 +101,0 @@\n-\n-    public void charsToGlyphs(int count, char[] unicodes, int[] glyphs) {\n-        \/* The conversion into surrogates is misleading.\n-         * The Type1 glyph mapper only accepts 16 bit unsigned shorts.\n-         * If its > not in the range it can use assign the missing glyph.\n-         *\/\n-        for (int i=0; i<count; i++) {\n-            int code = unicodes[i]; \/\/ char is unsigned.\n-\n-            if (code >= HI_SURROGATE_START &&\n-                code <= HI_SURROGATE_END && i < count - 1) {\n-                char low = unicodes[i + 1];\n-\n-                if (low >= LO_SURROGATE_START &&\n-                    low <= LO_SURROGATE_END) {\n-                    code = (code - HI_SURROGATE_START) *\n-                        0x400 + low - LO_SURROGATE_START + 0x10000;\n-                    glyphs[i + 1] = 0xFFFF; \/\/ invisible glyph\n-                }\n-            }\n-            glyphs[i] = charToGlyph(code);\n-            if (code >= 0x10000) {\n-                i += 1; \/\/ Empty glyph slot after surrogate\n-            }\n-        }\n-    }\n-\n-    public void charsToGlyphs(int count, int[] unicodes, int[] glyphs) {\n-        \/* I believe this code path is never exercised. Its there mainly\n-         * for surrogates and\/or the opentype engine which aren't likely\n-         * to be an issue for Type1 fonts. So no need to optimise it.\n-         *\/\n-        for (int i=0; i<count; i++) {\n-            glyphs[i] = charToGlyph(unicodes[i]);\n-        }\n-    }\n-\n-\n-    \/* This variant checks if shaping is needed and immediately\n-     * returns true if it does. A caller of this method should be expecting\n-     * to check the return type because it needs to know how to handle\n-     * the character data for display.\n-     *\/\n-    public boolean charsToGlyphsNS(int count, char[] unicodes, int[] glyphs) {\n-\n-        for (int i=0; i<count; i++) {\n-            int code = unicodes[i]; \/\/ char is unsigned.\n-\n-            if (code >= HI_SURROGATE_START &&\n-                code <= HI_SURROGATE_END && i < count - 1) {\n-                char low = unicodes[i + 1];\n-\n-                if (low >= LO_SURROGATE_START &&\n-                    low <= LO_SURROGATE_END) {\n-                    code = (code - HI_SURROGATE_START) *\n-                        0x400 + low - LO_SURROGATE_START + 0x10000;\n-                    glyphs[i + 1] = INVISIBLE_GLYPH_ID;\n-                }\n-            }\n-\n-            glyphs[i] = charToGlyph(code);\n-\n-            if (code < FontUtilities.MIN_LAYOUT_CHARCODE) {\n-                continue;\n-            }\n-            else if (FontUtilities.isComplexCharCode(code)) {\n-                return true;\n-            }\n-            else if (code >= 0x10000) {\n-                i += 1; \/\/ Empty glyph slot after surrogate\n-                continue;\n-            }\n-        }\n-\n-        return false;\n-    }\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/Type1GlyphMapper.java","additions":0,"deletions":76,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import sun.font.StrikeCache;\n@@ -44,1 +45,1 @@\n-        boolean isColor = false;\n+        byte pixelFormat = StrikeCache.PIXEL_FORMAT_UNKNOWN;\n@@ -49,4 +50,4 @@\n-                boolean newIsColor = gl.isColorGlyph(i);\n-                if (newIsColor != isColor) {\n-                    drawGlyphListSegment(sg2d, gl, prevLimit, i, aaHint,\n-                            isColor);\n+                byte newFormat = gl.getPixelFormat(i);\n+                if (newFormat != pixelFormat) {\n+                    drawGlyphListSegment(sg2d, gl,\n+                            prevLimit, i, aaHint, pixelFormat);\n@@ -54,1 +55,1 @@\n-                    isColor = newIsColor;\n+                    pixelFormat = newFormat;\n@@ -58,1 +59,1 @@\n-        drawGlyphListSegment(sg2d, gl, prevLimit, len, aaHint, isColor);\n+        drawGlyphListSegment(sg2d, gl, prevLimit, len, aaHint, pixelFormat);\n@@ -63,1 +64,1 @@\n-                                      int aaHint, boolean isColor) {\n+                                      int aaHint, byte pixelFormat) {\n@@ -65,7 +66,3 @@\n-        if (isColor) {\n-            sg2d.loops.drawGlyphListColorLoop.\n-                    DrawGlyphListColor(sg2d, sg2d.surfaceData,\n-                            gl, fromglyph, toGlyph);\n-        } else {\n-            switch (aaHint) {\n-                case SunHints.INTVAL_TEXT_ANTIALIAS_OFF:\n+        switch (pixelFormat) {\n+            case StrikeCache.PIXEL_FORMAT_GREYSCALE:\n+                if (aaHint == SunHints.INTVAL_TEXT_ANTIALIAS_OFF) {\n@@ -75,2 +72,1 @@\n-                    return;\n-                case SunHints.INTVAL_TEXT_ANTIALIAS_ON:\n+                } else {\n@@ -80,8 +76,12 @@\n-                    return;\n-                case SunHints.INTVAL_TEXT_ANTIALIAS_LCD_HRGB:\n-                case SunHints.INTVAL_TEXT_ANTIALIAS_LCD_VRGB:\n-                    sg2d.loops.drawGlyphListLCDLoop.\n-                            DrawGlyphListLCD(sg2d, sg2d.surfaceData,\n-                                    gl, fromglyph, toGlyph);\n-                    return;\n-            }\n+                }\n+                return;\n+            case StrikeCache.PIXEL_FORMAT_LCD:\n+                sg2d.loops.drawGlyphListLCDLoop.\n+                        DrawGlyphListLCD(sg2d, sg2d.surfaceData,\n+                                gl, fromglyph, toGlyph);\n+                return;\n+            case StrikeCache.PIXEL_FORMAT_BGRA:\n+                sg2d.loops.drawGlyphListColorLoop.\n+                        DrawGlyphListColor(sg2d, sg2d.surfaceData,\n+                                gl, fromglyph, toGlyph);\n+                return;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/GlyphListLoopPipe.java","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+\n+import sun.font.GlyphRenderData;\n+import sun.font.StandardGlyphVector;\n@@ -34,3 +37,1 @@\n-import java.awt.Shape;\n-import java.awt.geom.AffineTransform;\n-import java.awt.font.TextLayout;\n+import java.awt.geom.GeneralPath;\n@@ -81,16 +82,0 @@\n-        Shape s = tl.getOutline(AffineTransform.getTranslateInstance(x, y));\n-\n-        int textAAHint = g2d.getFontInfo().aaHint;\n-\n-        int prevaaHint = - 1;\n-        if (textAAHint != SunHints.INTVAL_TEXT_ANTIALIAS_OFF &&\n-            g2d.antialiasHint != SunHints.INTVAL_ANTIALIAS_ON) {\n-            prevaaHint = g2d.antialiasHint;\n-            g2d.antialiasHint =  SunHints.INTVAL_ANTIALIAS_ON;\n-            g2d.validatePipe();\n-        } else if (textAAHint == SunHints.INTVAL_TEXT_ANTIALIAS_OFF\n-            && g2d.antialiasHint != SunHints.INTVAL_ANTIALIAS_OFF) {\n-            prevaaHint = g2d.antialiasHint;\n-            g2d.antialiasHint =  SunHints.INTVAL_ANTIALIAS_OFF;\n-            g2d.validatePipe();\n-        }\n@@ -98,6 +83,2 @@\n-        g2d.fill(s);\n-\n-        if (prevaaHint != -1) {\n-             g2d.antialiasHint = prevaaHint;\n-             g2d.validatePipe();\n-        }\n+        \/\/ This will end up calling our drawGlyphVector\n+        tl.draw(g2d, (float) x, (float) y);\n@@ -109,0 +90,7 @@\n+        GlyphRenderData grd;\n+        if (gv instanceof StandardGlyphVector) {\n+            grd = ((StandardGlyphVector) gv).getGlyphRenderData(x, y);\n+        } else {\n+            grd = new GlyphRenderData();\n+            grd.outline = new GeneralPath(gv.getOutline(x, y));\n+        }\n@@ -110,1 +98,0 @@\n-        Shape s = gv.getOutline(x, y);\n@@ -137,1 +124,1 @@\n-        g2d.fill(s);\n+        grd.draw(g2d);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/OutlineTextRenderer.java","additions":14,"deletions":27,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"sun_font_StrikeCache.h\"\n@@ -77,1 +78,2 @@\n-    UInt8         managed;\n+    UInt8        managed;\n+    UInt8        format; \/\/ sun_font_StrikeCache_PIXEL_FORMAT_*\n","filename":"src\/java.desktop\/share\/native\/common\/font\/fontscalerdefs.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,0 +83,6 @@\n+\n+    \/* sun\/font\/GlyphRenderData *\/\n+    jfieldID glyphRenderDataOutline, glyphRenderDataColorLayers;\n+    jmethodID glyphRenderDataSetColorLayersListMID,\n+      glyphRenderDataAddColorLayerMID, glyphRenderDataAddColorLayerFGMID,\n+      glyphRenderDataAddBitmapMID;\n","filename":"src\/java.desktop\/share\/native\/common\/font\/sunfontids.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1090,1 +1090,1 @@\n-        if (ginfo->rowBytes == ginfo->width) {\n+        if (ginfo->format == sun_font_StrikeCache_PIXEL_FORMAT_GREYSCALE) {\n@@ -1099,1 +1099,1 @@\n-        } else if (ginfo->rowBytes == ginfo->width * 4) {\n+        } else if (ginfo->format == sun_font_StrikeCache_PIXEL_FORMAT_BGRA) {\n","filename":"src\/java.desktop\/share\/native\/common\/java2d\/opengl\/OGLTextRenderer.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -548,2 +548,1 @@\n-        \/* rowBytes==width tests if its a B&W or LCD glyph *\/\n-        if (ginfo->width == ginfo->rowBytes) {\n+        if (ginfo->format != sun_font_StrikeCache_PIXEL_FORMAT_LCD) {\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/DrawGlyphList.c","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-                     jobject gvdata, jint slot,\n+                     jobject gvdata, jint slot, jint slotShift,\n@@ -138,1 +138,1 @@\n-        glyphs[storei] = (unsigned int)(glyphInfo[i].codepoint | slot);\n+        glyphs[storei] = (unsigned int)((glyphInfo[i].codepoint << slotShift) | slot);\n@@ -243,1 +243,2 @@\n-     jint slot) {\n+     jint slot,\n+     jint slotShift) {\n@@ -306,1 +307,1 @@\n-     ret = storeGVData(env, gvdata, slot, baseIndex, offset, startPt,\n+     ret = storeGVData(env, gvdata, slot, slotShift, baseIndex, offset, startPt,\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/HBShaper.c","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -47,0 +47,43 @@\n+#if defined(_WIN32) || defined(__APPLE__)\n+#include FT_COLOR_H\n+#define COLOR_OUTLINES_AVAILABLE (1)\n+#else\n+\/\/ Linux is built with system Freetype by default,\n+\/\/ and it's often a bit old and doesn't have FT_COLOR_H.\n+\/\/ Thus, we load required symbols dynamically on Linux.\n+#define DYNAMIC_COLOR_OUTLINES\n+\n+typedef struct FT_Color__Dynamic {\n+    FT_Byte  blue;\n+    FT_Byte  green;\n+    FT_Byte  red;\n+    FT_Byte  alpha;\n+} FT_Color_Dynamic;\n+\n+typedef struct FT_LayerIterator__Dynamic {\n+    FT_UInt   num_layers;\n+    FT_UInt   layer;\n+    FT_Byte*  p;\n+} FT_LayerIterator_Dynamic;\n+\n+#define FT_Color FT_Color_Dynamic\n+#define FT_LayerIterator FT_LayerIterator_Dynamic\n+\n+typedef FT_Error (*FT_Palette_Select_Func)(FT_Face     face,\n+                                           FT_UShort   palette_index,\n+                                           FT_Color*  *apalette);\n+\n+typedef FT_Bool (*FT_Get_Color_Glyph_Layer_Func)(FT_Face            face,\n+                                                 FT_UInt            base_glyph,\n+                                                 FT_UInt           *aglyph_index,\n+                                                 FT_UInt           *acolor_index,\n+                                                 FT_LayerIterator*  iterator);\n+\n+FT_Palette_Select_Func FT_Palette_Select_Dynamic = NULL;\n+FT_Get_Color_Glyph_Layer_Func FT_Get_Color_Glyph_Layer_Dynamic = NULL;\n+\n+#define FT_Palette_Select FT_Palette_Select_Dynamic\n+#define FT_Get_Color_Glyph_Layer FT_Get_Color_Glyph_Layer_Dynamic\n+#define COLOR_OUTLINES_AVAILABLE (FT_Palette_Select && FT_Get_Color_Glyph_Layer)\n+#endif\n+\n@@ -59,0 +102,10 @@\n+#define  FT26Dot6ToInt(x) (((int)(x)) >> 6)\n+#define  FT26Dot6ToIntRound(x) (((int)(x + (1 << 5))) >> 6)\n+#define  FT26Dot6ToIntCeil(x) (((int)(x - 1 + (1 << 6))) >> 6)\n+#define  IntToFT26Dot6(x) (((FT_Fixed)(x)) << 6)\n+\n+\/\/ Define these manually when building with old Freetype (before 2.5)\n+#if !defined(FT_LOAD_COLOR)\n+#define FT_LOAD_COLOR ( 1L << 20 )\n+#define FT_PIXEL_MODE_BGRA 7\n+#endif\n@@ -93,0 +146,3 @@\n+    int        fixedSizeIndex;\/* -1 for scalable fonts and index inside\n+                               * scalerInfo->face->available_sizes otherwise *\/\n+    jboolean colorFont;\n@@ -95,0 +151,7 @@\n+\/* SampledBGRABitmap contains (possibly) downscaled image data\n+ * prepared for sampling when generating transformed bitmap *\/\n+typedef struct SampledBGRABitmap {\n+    unsigned char* data;\n+    int left, top, width, height, rowBytes, xDownscale, yDownscale;\n+} SampledBGRABitmap;\n+\n@@ -118,0 +181,11 @@\n+\n+#ifdef DYNAMIC_COLOR_OUTLINES\n+    void *lib = dlopen(\"libfreetype.so\", RTLD_LOCAL|RTLD_LAZY);\n+    if (!lib) {\n+        lib = dlopen(\"libfreetype.so.6\", RTLD_LOCAL|RTLD_LAZY);\n+    }\n+    if (lib) {\n+        FT_Palette_Select = (FT_Palette_Select_Func)dlsym(lib, \"FT_Palette_Select\");\n+        FT_Get_Color_Glyph_Layer = (FT_Get_Color_Glyph_Layer_Func)dlsym(lib, \"FT_Get_Color_Glyph_Layer\");\n+    }\n+#endif\n@@ -325,1 +399,1 @@\n-    (context->doBold ? BOLD_FACTOR(units_per_EM, y_scale) : 0)\n+    ((context->doBold && !context->colorFont) ? BOLD_FACTOR(units_per_EM, y_scale) : 0)\n@@ -564,1 +638,1 @@\n-    if (context->doItalize) {\n+    if (context->doItalize && !context->colorFont) {\n@@ -591,0 +665,4 @@\n+        context->colorFont =\n+            FT_HAS_COLOR(scalerInfo->face) || !FT_IS_SCALABLE(scalerInfo->face) ?\n+            JNI_TRUE : JNI_FALSE;\n+\n@@ -594,1 +672,23 @@\n-        errCode = FT_Set_Char_Size(scalerInfo->face, 0, context->ptsz, 72, 72);\n+        int charSize;\n+        if (FT_IS_SCALABLE(scalerInfo->face)) { \/\/ Standard scalable face\n+            context->fixedSizeIndex = -1;\n+            charSize = context->ptsz;\n+        } else { \/\/ Non-scalable face (that should only be bitmap faces)\n+            const int ptsz = context->ptsz;\n+            \/\/ Best size is smallest, but not smaller than requested\n+            int bestSizeIndex = 0;\n+            FT_Pos bestSize = scalerInfo->face->available_sizes[0].size;\n+            int i;\n+            for (i = 1; i < scalerInfo->face->num_fixed_sizes; i++) {\n+                FT_Pos size = scalerInfo->face->available_sizes[i].size;\n+                if ((size >= ptsz && bestSize >= ptsz && size < bestSize) ||\n+                    (size < ptsz && bestSize < ptsz && size > bestSize) ||\n+                    (size >= ptsz && bestSize < ptsz)) {\n+                    bestSizeIndex = i;\n+                    bestSize = size;\n+                }\n+            }\n+            context->fixedSizeIndex = bestSizeIndex;\n+            charSize = (int) bestSize;\n+        }\n+        errCode = FT_Set_Char_Size(scalerInfo->face, 0, charSize, 72, 72);\n@@ -607,1 +707,2 @@\n-#define OBLIQUE_MODIFIER(y)  (context->doItalize ? ((y)*FT_MATRIX_OBLIQUE_XY\/FT_MATRIX_ONE) : 0)\n+#define OBLIQUE_MODIFIER(y) \\\n+    ((context->doItalize && !context->colorFont) ? ((y)*FT_MATRIX_OBLIQUE_XY\/FT_MATRIX_ONE) : 0)\n@@ -668,30 +769,56 @@\n-    \/*\n-     * See FreeType source code: src\/base\/ftobjs.c ft_recompute_scaled_metrics()\n-     * http:\/\/icedtea.classpath.org\/bugzilla\/show_bug.cgi?id=1659\n-     *\/\n-    \/* ascent *\/\n-    ax = 0;\n-    ay = -(jfloat) (FT_MulFixFloatShift6(\n-                       ((jlong) scalerInfo->face->ascender),\n-                       (jlong) scalerInfo->face->size->metrics.y_scale));\n-    \/* descent *\/\n-    dx = 0;\n-    dy = -(jfloat) (FT_MulFixFloatShift6(\n-                       ((jlong) scalerInfo->face->descender),\n-                       (jlong) scalerInfo->face->size->metrics.y_scale));\n-    \/* baseline *\/\n-    bx = by = 0;\n-\n-    \/* leading *\/\n-    lx = 0;\n-    ly = (jfloat) (FT_MulFixFloatShift6(\n-                      (jlong) scalerInfo->face->height,\n-                      (jlong) scalerInfo->face->size->metrics.y_scale))\n-                  + ay - dy;\n-    \/* max advance *\/\n-    mx = (jfloat) FT26Dot6ToFloat(\n-                     scalerInfo->face->size->metrics.max_advance +\n-                     OBLIQUE_MODIFIER(scalerInfo->face->size->metrics.height) +\n-                     BOLD_MODIFIER(scalerInfo->face->units_per_EM,\n-                             scalerInfo->face->size->metrics.y_scale));\n-    my = 0;\n+    if (context->fixedSizeIndex == -1) {\n+        \/*\n+         * See FreeType source code: src\/base\/ftobjs.c ft_recompute_scaled_metrics()\n+         * http:\/\/icedtea.classpath.org\/bugzilla\/show_bug.cgi?id=1659\n+         *\/\n+        \/* ascent *\/\n+        ax = 0;\n+        ay = -(jfloat) (FT_MulFixFloatShift6(\n+                ((jlong) scalerInfo->face->ascender),\n+                (jlong) scalerInfo->face->size->metrics.y_scale));\n+        \/* descent *\/\n+        dx = 0;\n+        dy = -(jfloat) (FT_MulFixFloatShift6(\n+                ((jlong) scalerInfo->face->descender),\n+                (jlong) scalerInfo->face->size->metrics.y_scale));\n+        \/* baseline *\/\n+        bx = by = 0;\n+\n+        \/* leading *\/\n+        lx = 0;\n+        ly = (jfloat) (FT_MulFixFloatShift6(\n+                (jlong) scalerInfo->face->height,\n+                (jlong) scalerInfo->face->size->metrics.y_scale))\n+             + ay - dy;\n+        \/* max advance *\/\n+        mx = (jfloat) FT26Dot6ToFloat(\n+                scalerInfo->face->size->metrics.max_advance +\n+                OBLIQUE_MODIFIER(scalerInfo->face->size->metrics.height) +\n+                BOLD_MODIFIER(scalerInfo->face->units_per_EM,\n+                              scalerInfo->face->size->metrics.y_scale));\n+        my = 0;\n+    } else {\n+        \/* Just manually scale metrics for non-scalable fonts *\/\n+        FT_Fixed scale = FT_DivFix(context->ptsz,\n+                                   scalerInfo->face->available_sizes[context->fixedSizeIndex].size);\n+        \/* ascent *\/\n+        ax = 0;\n+        ay = -(jfloat) FT_MulFixFloatShift6(\n+                scalerInfo->face->size->metrics.ascender, scale);\n+        \/* descent *\/\n+        dx = 0;\n+        dy = -(jfloat) FT_MulFixFloatShift6(\n+                scalerInfo->face->size->metrics.descender, scale);\n+        \/* baseline *\/\n+        bx = by = 0;\n+\n+        \/* leading *\/\n+        lx = 0;\n+        ly = (jfloat) FT_MulFixFloatShift6(\n+                scalerInfo->face->size->metrics.height, scale) + ay - dy;\n+        \/* max advance *\/\n+        \/* no bold\/italic transformations for non-scalable fonts *\/\n+        mx = (jfloat) FT_MulFixFloatShift6(\n+                scalerInfo->face->size->metrics.max_advance, scale);\n+        my = 0;\n+    }\n@@ -715,1 +842,1 @@\n-        jboolean renderImage);\n+        jboolean renderImage, jboolean setupContext);\n@@ -744,1 +871,1 @@\n-          env, scaler, font2D, pScalerContext, pScaler, glyphCode, JNI_FALSE);\n+          env, scaler, font2D, pScalerContext, pScaler, glyphCode, JNI_FALSE, JNI_TRUE);\n@@ -770,1 +897,1 @@\n-                                 pScalerContext, pScaler, glyphCode, JNI_FALSE);\n+                                 pScalerContext, pScaler, glyphCode, JNI_FALSE, JNI_TRUE);\n@@ -887,0 +1014,195 @@\n+\/* Get enclosing axis-aligned rectangle of transformed bitmap bounds *\/\n+static FT_BBox getTransformedBitmapBoundingBox(FT_GlyphSlot ftglyph,\n+                                               const FT_Matrix* transform) {\n+    FT_Vector corners[4];\n+    corners[0].x = corners[2].x = IntToFT26Dot6(ftglyph->bitmap_left);\n+    corners[0].y = corners[1].y = IntToFT26Dot6(ftglyph->bitmap_top);\n+    corners[1].x = corners[3].x = IntToFT26Dot6(ftglyph->bitmap_left +\n+                                                (FT_Int) ftglyph->bitmap.width);\n+    corners[2].y = corners[3].y = IntToFT26Dot6(ftglyph->bitmap_top -\n+                                                (FT_Int) ftglyph->bitmap.rows);\n+\n+    FT_Vector_Transform(corners, transform);\n+    FT_BBox bb = {corners[0].x, corners[0].y, corners[0].x, corners[0].y};\n+    int i;\n+    for (i = 1; i < 4; i++) {\n+        FT_Vector_Transform(corners + i, transform);\n+        if (corners[i].x < bb.xMin) {\n+            bb.xMin = corners[i].x;\n+        }\n+        if (corners[i].x > bb.xMax) {\n+            bb.xMax = corners[i].x;\n+        }\n+        if (corners[i].y < bb.yMin) {\n+            bb.yMin = corners[i].y;\n+        }\n+        if (corners[i].y > bb.yMax) {\n+            bb.yMax = corners[i].y;\n+        }\n+    }\n+    bb.xMin = FT26Dot6ToInt(bb.xMin);\n+    bb.yMin = FT26Dot6ToInt(bb.yMin);\n+    bb.xMax = FT26Dot6ToIntCeil(bb.xMax);\n+    bb.yMax = FT26Dot6ToIntCeil(bb.yMax);\n+    return bb;\n+}\n+\n+\/* Generate SampledBGRABitmap, downscaling original image when necessary.\n+ * It may allocate memory for downscaled image,\n+ * so it must be freed with freeSampledBGRABitmap() *\/\n+static SampledBGRABitmap createSampledBGRABitmap(FT_GlyphSlot ftglyph,\n+                                                 int xDownscale,\n+                                                 int yDownscale) {\n+    SampledBGRABitmap sampledBitmap;\n+    if (xDownscale == 1 && yDownscale == 1) { \/\/ No downscale, use original data\n+        sampledBitmap.data = ftglyph->bitmap.buffer;\n+        sampledBitmap.left = ftglyph->bitmap_left;\n+        sampledBitmap.top = ftglyph->bitmap_top;\n+        sampledBitmap.width = (int) ftglyph->bitmap.width;\n+        sampledBitmap.height = (int) ftglyph->bitmap.rows;\n+        sampledBitmap.rowBytes = ftglyph->bitmap.pitch;\n+        sampledBitmap.xDownscale = 1;\n+        sampledBitmap.yDownscale = 1;\n+    } else { \/\/ Generate downscaled bitmap\n+        sampledBitmap.left = ftglyph->bitmap_left \/ xDownscale;\n+        sampledBitmap.top = (ftglyph->bitmap_top + yDownscale - 1) \/ yDownscale;\n+        sampledBitmap.width = (int)\n+                (ftglyph->bitmap_left + (FT_Pos) ftglyph->bitmap.width -\n+                 sampledBitmap.left * xDownscale + xDownscale - 1) \/ xDownscale;\n+        sampledBitmap.height = (int)\n+                (sampledBitmap.top * yDownscale - ftglyph->bitmap_top +\n+                 (FT_Pos) ftglyph->bitmap.rows + yDownscale - 1) \/ yDownscale;\n+        sampledBitmap.data =\n+                malloc(4 * sampledBitmap.width * sampledBitmap.height);\n+        sampledBitmap.rowBytes = sampledBitmap.width * 4;\n+        sampledBitmap.xDownscale = xDownscale;\n+        sampledBitmap.yDownscale = yDownscale;\n+        int xOffset = sampledBitmap.left * xDownscale - ftglyph->bitmap_left;\n+        int yOffset = ftglyph->bitmap_top - sampledBitmap.top * yDownscale;\n+        int x, y;\n+        for (y = 0; y < sampledBitmap.height; y++) {\n+            for (x = 0; x < sampledBitmap.width; x++) {\n+                \/\/ Average pixels\n+                int b = 0, g = 0, r = 0, a = 0;\n+                int xFrom = x * xDownscale + xOffset,\n+                        yFrom = y * yDownscale + yOffset,\n+                        xTo = xFrom + xDownscale,\n+                        yTo = yFrom + yDownscale;\n+                if (xFrom < 0) {\n+                    xFrom = 0;\n+                }\n+                if (xTo > (int) ftglyph->bitmap.width) {\n+                    xTo = (int) ftglyph->bitmap.width;\n+                }\n+                if (yFrom < 0) {\n+                    yFrom = 0;\n+                }\n+                if (yTo > (int) ftglyph->bitmap.rows) {\n+                    yTo = (int) ftglyph->bitmap.rows;\n+                }\n+                int i, j;\n+                for (j = yFrom; j < yTo; j++) {\n+                    for (i = xFrom; i < xTo; i++) {\n+                        int offset = j * ftglyph->bitmap.pitch + i * 4;\n+                        b += ftglyph->bitmap.buffer[offset + 0];\n+                        g += ftglyph->bitmap.buffer[offset + 1];\n+                        r += ftglyph->bitmap.buffer[offset + 2];\n+                        a += ftglyph->bitmap.buffer[offset + 3];\n+                    }\n+                }\n+                int offset = y * sampledBitmap.rowBytes + x * 4;\n+                sampledBitmap.data[offset + 0] = b \/ xDownscale \/ yDownscale;\n+                sampledBitmap.data[offset + 1] = g \/ xDownscale \/ yDownscale;\n+                sampledBitmap.data[offset + 2] = r \/ xDownscale \/ yDownscale;\n+                sampledBitmap.data[offset + 3] = a \/ xDownscale \/ yDownscale;\n+            }\n+        }\n+    }\n+    return sampledBitmap;\n+}\n+static void freeSampledBGRABitmap(SampledBGRABitmap* bitmap) {\n+    if (bitmap->xDownscale != 1 || bitmap->yDownscale != 1) {\n+        free(bitmap->data);\n+    }\n+}\n+\/* Get color (returned via b, g, r and a variables, [0-256))\n+ * from specific pixel in bitmap.\n+ * Returns black-transparent (0,0,0,0) color when sampling out of bounds *\/\n+static void sampleBGRABitmapGlyph(int* b, int* g, int* r, int* a,\n+                                  const SampledBGRABitmap* bitmap,\n+                                  int x, int y) {\n+    int column = x - bitmap->left, row = bitmap->top - y;\n+    if (column < 0 || column >= bitmap->width ||\n+        row < 0 || row >= bitmap->height) {\n+        *b = *g = *r = *a = 0;\n+    } else {\n+        int offset = row * bitmap->rowBytes + column * 4;\n+        *b = bitmap->data[offset + 0];\n+        *g = bitmap->data[offset + 1];\n+        *r = bitmap->data[offset + 2];\n+        *a = bitmap->data[offset + 3];\n+    }\n+}\n+static int bilinearColorMix(int c00, int c10, int c01, int c11,\n+                            float x, float y) {\n+    float top = (float) c00 + x * (float) (c10 - c00);\n+    float bottom = (float) c01 + x * (float) (c11 - c01);\n+    return (int) (top + y * (bottom - top));\n+}\n+\/* Transform ftglyph into pre-allocated glyphInfo with transform matrix *\/\n+static void transformBGRABitmapGlyph(FT_GlyphSlot ftglyph, GlyphInfo* glyphInfo,\n+                                     const FT_Matrix* transform,\n+                                     const FT_BBox* dstBoundingBox,\n+                                     const jboolean linear) {\n+    FT_Matrix inv = *transform;\n+    FT_Matrix_Invert(&inv); \/\/ Transformed -> original bitmap space\n+    int invScaleX = (int) sqrt((double) FTFixedToFloat(FT_MulFix(inv.xx, inv.xx) +\n+                                                       FT_MulFix(inv.xy, inv.xy)));\n+    int invScaleY = (int) sqrt((double) FTFixedToFloat(FT_MulFix(inv.yx, inv.yx) +\n+                                                       FT_MulFix(inv.yy, inv.yy)));\n+    if (invScaleX < 1) {\n+        invScaleX = 1;\n+    }\n+    if (invScaleY < 1) {\n+        invScaleY = 1;\n+    }\n+    SampledBGRABitmap sampledBitmap =\n+            createSampledBGRABitmap(ftglyph, invScaleX, invScaleY);\n+    int x, y;\n+    for (y = 0; y < glyphInfo->height; y++) {\n+        for (x = 0; x < glyphInfo->width; x++) {\n+            FT_Vector position = {\n+                    IntToFT26Dot6(dstBoundingBox->xMin + x),\n+                    IntToFT26Dot6(dstBoundingBox->yMax - y)\n+            };\n+            FT_Vector_Transform(&position, &inv);\n+            int sampleX = FT26Dot6ToInt(position.x \/ invScaleX),\n+                    sampleY = FT26Dot6ToInt(position.y \/ invScaleY);\n+            int b, g, r, a;\n+            sampleBGRABitmapGlyph(&b, &g, &r, &a,\n+                                  &sampledBitmap, sampleX, sampleY);\n+            if (linear) {\n+                int bX, gX, rX, aX, bY, gY, rY, aY, bXY, gXY, rXY, aXY;\n+                sampleBGRABitmapGlyph(&bX, &gX, &rX, &aX,\n+                                      &sampledBitmap, sampleX + 1, sampleY);\n+                sampleBGRABitmapGlyph(&bY, &gY, &rY, &aY,\n+                                      &sampledBitmap, sampleX, sampleY + 1);\n+                sampleBGRABitmapGlyph(&bXY, &gXY, &rXY, &aXY,\n+                                      &sampledBitmap, sampleX + 1, sampleY + 1);\n+                float fractX = FT26Dot6ToFloat((position.x \/ invScaleX) & 63),\n+                        fractY = FT26Dot6ToFloat((position.y \/ invScaleY) & 63);\n+                b = bilinearColorMix(b, bX, bY, bXY, fractX, fractY);\n+                g = bilinearColorMix(g, gX, gY, gXY, fractX, fractY);\n+                r = bilinearColorMix(r, rX, rY, rXY, fractX, fractY);\n+                a = bilinearColorMix(a, aX, aY, aXY, fractX, fractY);\n+            }\n+            glyphInfo->image[y*glyphInfo->rowBytes + x * 4 + 0] = b;\n+            glyphInfo->image[y*glyphInfo->rowBytes + x * 4 + 1] = g;\n+            glyphInfo->image[y*glyphInfo->rowBytes + x * 4 + 2] = r;\n+            glyphInfo->image[y*glyphInfo->rowBytes + x * 4 + 3] = a;\n+        }\n+    }\n+    freeSampledBGRABitmap(&sampledBitmap);\n+}\n+\n+\n@@ -906,1 +1228,1 @@\n-        pScalerContext, pScaler, glyphCode, JNI_TRUE);\n+        pScalerContext, pScaler, glyphCode, JNI_TRUE, JNI_TRUE);\n@@ -913,1 +1235,1 @@\n-        jboolean renderImage) {\n+        jboolean renderImage, jboolean setupContext) {\n@@ -931,4 +1253,6 @@\n-    error = setupFTContext(env, font2D, scalerInfo, context);\n-    if (error) {\n-        invalidateJavaScaler(env, scaler, scalerInfo);\n-        return ptr_to_jlong(getNullGlyphImage());\n+    if (setupContext) {\n+        error = setupFTContext(env, font2D, scalerInfo, context);\n+        if (error) {\n+            invalidateJavaScaler(env, scaler, scalerInfo);\n+            return ptr_to_jlong(getNullGlyphImage());\n+        }\n@@ -944,1 +1268,2 @@\n-    if (context->aaType == TEXT_AA_ON && context->fmType == TEXT_FM_ON) {\n+    if ((context->aaType == TEXT_AA_ON && context->fmType == TEXT_FM_ON) ||\n+        context->colorFont) {\n@@ -948,1 +1273,6 @@\n-    if (!context->useSbits) {\n+    if (context->colorFont) {\n+        renderFlags |= FT_LOAD_COLOR;\n+    }\n+\n+    \/* Don't disable bitmaps for color glyphs *\/\n+    if (!context->useSbits && !context->colorFont) {\n@@ -958,3 +1288,1 @@\n-    if (context->aaType == TEXT_AA_OFF) {\n-        target = FT_LOAD_TARGET_MONO;\n-    } else if (context->aaType == TEXT_AA_ON) {\n+    if (context->aaType == TEXT_AA_ON || context->colorFont) {\n@@ -962,0 +1290,2 @@\n+    } else if (context->aaType == TEXT_AA_OFF) {\n+        target = FT_LOAD_TARGET_MONO;\n@@ -979,0 +1309,4 @@\n+    \/* After call to FT_Render_Glyph, glyph format will be changed from\n+     * FT_GLYPH_FORMAT_OUTLINE to FT_GLYPH_FORMAT_BITMAP, so save this value *\/\n+    int outlineGlyph = ftglyph->format == FT_GLYPH_FORMAT_OUTLINE;\n+\n@@ -980,1 +1314,1 @@\n-    if (context->doBold) { \/* if bold style *\/\n+    if (context->doBold && outlineGlyph && !context->colorFont) { \/* if bold style *\/\n@@ -986,1 +1320,1 @@\n-    if (renderImage && (ftglyph->format == FT_GLYPH_FORMAT_OUTLINE)) {\n+    if (renderImage && outlineGlyph) {\n@@ -1001,0 +1335,4 @@\n+    FT_Fixed manualScale = context->fixedSizeIndex == -1 ? ftFixed1 : FT_DivFix(\n+            context->ptsz, scalerInfo->face->available_sizes[context->fixedSizeIndex].size);\n+    FT_Matrix manualTransform;\n+    FT_BBox manualTransformBoundingBox;\n@@ -1002,2 +1340,21 @@\n-        width  = (UInt16) ftglyph->bitmap.width;\n-        rowBytes = width;\n+        if (context->fixedSizeIndex == -1) {\n+            width  = (UInt16) ftglyph->bitmap.width;\n+            height = (UInt16) ftglyph->bitmap.rows;\n+        } else {\n+            \/* Fixed size glyph, prepare matrix and\n+             * bounding box for manual transformation *\/\n+            manualTransform.xx = FT_MulFix(context->transform.xx, manualScale);\n+            manualTransform.xy = FT_MulFix(context->transform.xy, manualScale);\n+            manualTransform.yx = FT_MulFix(context->transform.yx, manualScale);\n+            manualTransform.yy = FT_MulFix(context->transform.yy, manualScale);\n+            manualTransformBoundingBox =\n+                    getTransformedBitmapBoundingBox(ftglyph, &manualTransform);\n+            width  = (UInt16) (manualTransformBoundingBox.xMax -\n+                               manualTransformBoundingBox.xMin);\n+            height = (UInt16) (manualTransformBoundingBox.yMax -\n+                               manualTransformBoundingBox.yMin);\n+        }\n+        if (width > MAX_GLYPH_DIM || height > MAX_GLYPH_DIM) {\n+            glyphInfo = getNullGlyphImage();\n+            return ptr_to_jlong(glyphInfo);\n+        }\n@@ -1005,1 +1362,5 @@\n-           rowBytes = PADBYTES + width + PADBYTES;\n+            rowBytes = PADBYTES + width + PADBYTES;\n+        } else if (ftglyph->bitmap.pixel_mode == FT_PIXEL_MODE_BGRA) {\n+            rowBytes = width * 4;\n+        } else {\n+            rowBytes = width;\n@@ -1007,6 +1368,1 @@\n-        height = (UInt16) ftglyph->bitmap.rows;\n-            if (width > MAX_GLYPH_DIM || height > MAX_GLYPH_DIM) {\n-              glyphInfo = getNullGlyphImage();\n-              return ptr_to_jlong(glyphInfo);\n-            }\n-     } else {\n+    } else {\n@@ -1016,1 +1372,1 @@\n-     }\n+    }\n@@ -1031,0 +1387,9 @@\n+    if (ftglyph->bitmap.pixel_mode == FT_PIXEL_MODE_BGRA) {\n+        glyphInfo->format = sun_font_StrikeCache_PIXEL_FORMAT_BGRA;\n+    } else if (ftglyph->bitmap.pixel_mode == FT_PIXEL_MODE_LCD ||\n+             ftglyph->bitmap.pixel_mode == FT_PIXEL_MODE_LCD_V) {\n+        glyphInfo->format = sun_font_StrikeCache_PIXEL_FORMAT_LCD;\n+    } else {\n+        glyphInfo->format = sun_font_StrikeCache_PIXEL_FORMAT_GREYSCALE;\n+    }\n+\n@@ -1032,2 +1397,7 @@\n-        glyphInfo->topLeftX  = (float)  ftglyph->bitmap_left;\n-        glyphInfo->topLeftY  = (float) -ftglyph->bitmap_top;\n+        if (context->fixedSizeIndex == -1) {\n+            glyphInfo->topLeftX = (float)  ftglyph->bitmap_left;\n+            glyphInfo->topLeftY = (float) -ftglyph->bitmap_top;\n+        } else {\n+            glyphInfo->topLeftX =  (float)  manualTransformBoundingBox.xMin;\n+            glyphInfo->topLeftY =  (float) -manualTransformBoundingBox.yMax;\n+        }\n@@ -1044,1 +1414,1 @@\n-    if (context->fmType == TEXT_FM_ON) {\n+    if (context->fmType == TEXT_FM_ON && outlineGlyph) {\n@@ -1052,1 +1422,2 @@\n-            glyphInfo->advanceX = FT26Dot6ToFloat(ftglyph->advance.x);\n+            glyphInfo->advanceX = FT26Dot6ToIntRound(\n+                    FT_MulFix(ftglyph->advance.x, manualScale));\n@@ -1056,1 +1427,2 @@\n-            glyphInfo->advanceY = FT26Dot6ToFloat(-ftglyph->advance.y);\n+            glyphInfo->advanceY = FT26Dot6ToIntRound(\n+                    -FT_MulFix(ftglyph->advance.y, manualScale));\n@@ -1058,2 +1430,4 @@\n-            glyphInfo->advanceX = FT26Dot6ToFloat(ftglyph->advance.x);\n-            glyphInfo->advanceY = FT26Dot6ToFloat(-ftglyph->advance.y);\n+            glyphInfo->advanceX = FT26Dot6ToFloat(\n+                    FT_MulFix(ftglyph->advance.x, manualScale));\n+            glyphInfo->advanceY = FT26Dot6ToFloat(\n+                    -FT_MulFix(ftglyph->advance.y, manualScale));\n@@ -1069,0 +1443,1 @@\n+        \/\/4 bytes per pixel for BGRA glyphs\n@@ -1070,14 +1445,5 @@\n-        if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_MONO) {\n-            \/* convert from 8 pixels per byte to 1 byte per pixel *\/\n-            CopyBW2Grey8(ftglyph->bitmap.buffer,\n-                         ftglyph->bitmap.pitch,\n-                         (void *) glyphInfo->image,\n-                         width,\n-                         width,\n-                         height);\n-        } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_GRAY) {\n-            \/* byte per pixel to byte per pixel => just copy *\/\n-            memcpy(glyphInfo->image, ftglyph->bitmap.buffer, imageSize);\n-        } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_GRAY4) {\n-            \/* 4 bits per pixel to byte per pixel *\/\n-            CopyGrey4ToGrey8(ftglyph->bitmap.buffer,\n+        if (context->fixedSizeIndex == -1) {\n+            \/\/ Standard format convertation without image transformation\n+            if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_MONO) {\n+                \/* convert from 8 pixels per byte to 1 byte per pixel *\/\n+                CopyBW2Grey8(ftglyph->bitmap.buffer,\n@@ -1089,17 +1455,35 @@\n-        } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD) {\n-            \/* 3 bytes per pixel to 3 bytes per pixel *\/\n-            CopyFTSubpixelToSubpixel(ftglyph->bitmap.buffer,\n-                                     ftglyph->bitmap.pitch,\n-                                     (void *) (glyphInfo->image+PADBYTES),\n-                                     rowBytes,\n-                                     width,\n-                                     height);\n-        } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD_V) {\n-            \/* 3 bytes per pixel to 3 bytes per pixel *\/\n-            CopyFTSubpixelVToSubpixel(ftglyph->bitmap.buffer,\n-                                      ftglyph->bitmap.pitch,\n-                                      (void *) glyphInfo->image,\n-                                      width*3,\n-                                      width,\n-                                      height);\n-            glyphInfo->rowBytes *=3;\n+            } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_GRAY) {\n+                \/* byte per pixel to byte per pixel => just copy *\/\n+                memcpy(glyphInfo->image, ftglyph->bitmap.buffer, imageSize);\n+            } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_GRAY4) {\n+                \/* 4 bits per pixel to byte per pixel *\/\n+                CopyGrey4ToGrey8(ftglyph->bitmap.buffer,\n+                                 ftglyph->bitmap.pitch,\n+                                 (void *) glyphInfo->image,\n+                                 width,\n+                                 width,\n+                                 height);\n+            } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD) {\n+                \/* 3 bytes per pixel to 3 bytes per pixel *\/\n+                CopyFTSubpixelToSubpixel(ftglyph->bitmap.buffer,\n+                                         ftglyph->bitmap.pitch,\n+                                         (void *) (glyphInfo->image+PADBYTES),\n+                                         rowBytes,\n+                                         width,\n+                                         height);\n+            } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD_V) {\n+                \/* 3 bytes per pixel to 3 bytes per pixel *\/\n+                CopyFTSubpixelVToSubpixel(ftglyph->bitmap.buffer,\n+                                          ftglyph->bitmap.pitch,\n+                                          (void *) glyphInfo->image,\n+                                          width*3,\n+                                          width,\n+                                          height);\n+                glyphInfo->rowBytes *=3;\n+            } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_BGRA) {\n+                \/* 4 bytes per pixel to 4 bytes per pixel => just copy *\/\n+                memcpy(glyphInfo->image, ftglyph->bitmap.buffer, imageSize);\n+            } else {\n+                free(glyphInfo);\n+                glyphInfo = getNullGlyphImage();\n+            }\n@@ -1107,2 +1491,11 @@\n-            free(glyphInfo);\n-            glyphInfo = getNullGlyphImage();\n+            \/\/ Here we have to transform image manually\n+            \/\/ Only BGRA format is supported (should be enough)\n+            if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_BGRA) {\n+                transformBGRABitmapGlyph(ftglyph, glyphInfo,\n+                                         &manualTransform,\n+                                         &manualTransformBoundingBox,\n+                                         context->aaType != TEXT_AA_OFF);\n+            } else {\n+                free(glyphInfo);\n+                glyphInfo = getNullGlyphImage();\n+            }\n@@ -1202,3 +1595,2 @@\n-static FT_Outline* getFTOutline(JNIEnv* env, jobject font2D,\n-        FTScalerContext *context, FTScalerInfo* scalerInfo,\n-        jint glyphCode, jfloat xpos, jfloat ypos) {\n+static FT_Outline* getFTOutlineNoSetup(FTScalerContext *context, FTScalerInfo* scalerInfo,\n+                                       jint glyphCode, jfloat xpos, jfloat ypos) {\n@@ -1209,10 +1601,0 @@\n-    if (glyphCode >= INVISIBLE_GLYPHS ||\n-            isNullScalerContext(context) || scalerInfo == NULL) {\n-        return NULL;\n-    }\n-\n-    error = setupFTContext(env, font2D, scalerInfo, context);\n-    if (error) {\n-        return NULL;\n-    }\n-\n@@ -1227,0 +1609,1 @@\n+    int outlineGlyph = ftglyph->format == FT_GLYPH_FORMAT_OUTLINE;\n@@ -1229,1 +1612,1 @@\n-    if (context->doBold) { \/* if bold style *\/\n+    if (context->doBold && outlineGlyph && !context->colorFont) { \/* if bold style *\/\n@@ -1240,0 +1623,18 @@\n+static FT_Outline* getFTOutline(JNIEnv* env, jobject font2D,\n+                                FTScalerContext *context, FTScalerInfo* scalerInfo,\n+                                jint glyphCode, jfloat xpos, jfloat ypos) {\n+    FT_Error error;\n+\n+    if (glyphCode >= INVISIBLE_GLYPHS ||\n+        isNullScalerContext(context) || scalerInfo == NULL) {\n+        return NULL;\n+    }\n+\n+    error = setupFTContext(env, font2D, scalerInfo, context);\n+    if (error) {\n+        return NULL;\n+    }\n+\n+    return getFTOutlineNoSetup(context, scalerInfo, glyphCode, xpos, ypos);\n+}\n+\n@@ -1396,3 +1797,1 @@\n-static jobject getGlyphGeneralPath(JNIEnv* env, jobject font2D,\n-        FTScalerContext *context, FTScalerInfo *scalerInfo,\n-        jint glyphCode, jfloat xpos, jfloat ypos) {\n+static jobject outlineToGeneralPath(JNIEnv* env, FT_Outline* outline) {\n@@ -1400,1 +1799,0 @@\n-    FT_Outline* outline;\n@@ -1406,3 +1804,0 @@\n-    outline = getFTOutline(env, font2D, context, scalerInfo,\n-                           glyphCode, xpos, ypos);\n-\n@@ -1446,0 +1841,72 @@\n+static jboolean addColorLayersRenderData(JNIEnv* env, FTScalerContext *context,\n+                                         FTScalerInfo* scalerInfo, jint glyphCode,\n+                                         jfloat xpos, jfloat ypos, jobject result) {\n+\n+    if (!COLOR_OUTLINES_AVAILABLE) return JNI_FALSE;\n+    FT_Error error;\n+\n+    FT_Color* colors;\n+    error = FT_Palette_Select(scalerInfo->face, 0, &colors);\n+    if (error) {\n+        return JNI_FALSE;\n+    }\n+\n+    FT_LayerIterator iterator;\n+    iterator.p = NULL;\n+    FT_UInt glyphIndex, colorIndex;\n+    if (!FT_Get_Color_Glyph_Layer(scalerInfo->face, glyphCode,\n+                                  &glyphIndex, &colorIndex, &iterator)) {\n+        return JNI_FALSE;\n+    }\n+    (*env)->CallVoidMethod(env, result, sunFontIDs.glyphRenderDataSetColorLayersListMID, iterator.num_layers);\n+    do {\n+        FT_Outline* outline = getFTOutlineNoSetup(context, scalerInfo, glyphIndex, xpos, ypos);\n+        jobject gp = outlineToGeneralPath(env, outline);\n+\n+        if (colorIndex == 0xFFFF) {\n+            (*env)->CallVoidMethod(env, result, sunFontIDs.glyphRenderDataAddColorLayerFGMID, gp);\n+        } else {\n+            (*env)->CallVoidMethod(env, result, sunFontIDs.glyphRenderDataAddColorLayerMID,\n+                                   colors[colorIndex].red, colors[colorIndex].green,\n+                                   colors[colorIndex].blue, colors[colorIndex].alpha, gp);\n+        }\n+    } while(FT_Get_Color_Glyph_Layer(scalerInfo->face, glyphCode,\n+                                     &glyphIndex, &colorIndex, &iterator));\n+\n+    return JNI_TRUE;\n+}\n+\n+static void addBitmapRenderData(JNIEnv *env, jobject scaler, jobject font2D,\n+                                FTScalerContext *context, FTScalerInfo* scalerInfo,\n+                                jint glyphCode, jfloat xpos, jfloat ypos, jobject result) {\n+    GlyphInfo* glyphInfo = (GlyphInfo*) jlong_to_ptr(getGlyphImageNativeInternal(\n+            env, scaler, font2D,\n+            ptr_to_jlong(context), ptr_to_jlong(scalerInfo),\n+            glyphCode, JNI_FALSE, JNI_FALSE));\n+\n+    FT_GlyphSlot ftglyph = scalerInfo->face->glyph;\n+\n+    if (ftglyph->bitmap.pixel_mode != FT_PIXEL_MODE_BGRA) {\n+        return;\n+    }\n+\n+    int pitch = ftglyph->bitmap.pitch \/ 4;\n+    int size = pitch * ftglyph->bitmap.rows;\n+    jintArray array = (*env)->NewIntArray(env, size);\n+    (*env)->SetIntArrayRegion(env, array, 0, size, (jint*) ftglyph->bitmap.buffer);\n+\n+    double bitmapSize = (double) scalerInfo->face->available_sizes[context->fixedSizeIndex].size;\n+    double scale = (double) context->ptsz \/ bitmapSize \/ (double) (ftFixed1);\n+    double tx = ftglyph->bitmap_left + xpos * bitmapSize \/ (double) context->ptsz;\n+    double ty = -ftglyph->bitmap_top + ypos * bitmapSize \/ (double) context->ptsz;\n+\n+    jdouble m00 = (jdouble) context->transform.xx * scale, m10 = (jdouble) context->transform.xy * scale;\n+    jdouble m01 = (jdouble) context->transform.yx * scale, m11 = (jdouble) context->transform.yy * scale;\n+    jdouble m02 = m00 * tx + m01 * ty, m12 = m10 * tx + m11 * ty;\n+\n+    free(glyphInfo);\n+    (*env)->CallVoidMethod(env, result, sunFontIDs.glyphRenderDataAddBitmapMID,\n+                           m00, m10, m01, m11, m02, m12,\n+                           ftglyph->bitmap.width, ftglyph->bitmap.rows, pitch, 2, array);\n+}\n+\n@@ -1460,7 +1927,4 @@\n-    jobject gp = getGlyphGeneralPath(env,\n-                               font2D,\n-                               context,\n-                               scalerInfo,\n-                               glyphCode,\n-                               xpos,\n-                               ypos);\n+    FT_Outline* outline = getFTOutline(env, font2D, context,\n+                                       scalerInfo, glyphCode,\n+                                       xpos, ypos);\n+    jobject gp = outlineToGeneralPath(env, outline);\n@@ -1475,0 +1939,38 @@\n+\/*\n+ * Class:     sun_font_FreetypeFontScaler\n+ * Method:    getGlyphRenderDataNative\n+ * Signature: (Lsun\/font\/Font2D;JIFFLsun\/font\/GlyphRenderData;)V\n+ *\/\n+JNIEXPORT void JNICALL\n+Java_sun_font_FreetypeFontScaler_getGlyphRenderDataNative(\n+        JNIEnv *env, jobject scaler, jobject font2D, jlong pScalerContext,\n+        jlong pScaler, jint glyphCode, jfloat xpos, jfloat ypos, jobject result) {\n+\n+    FTScalerContext *context =\n+            (FTScalerContext*) jlong_to_ptr(pScalerContext);\n+    FTScalerInfo* scalerInfo = (FTScalerInfo *) jlong_to_ptr(pScaler);\n+\n+    if (glyphCode >= INVISIBLE_GLYPHS ||\n+        isNullScalerContext(context) || scalerInfo == NULL) {\n+        return;\n+    }\n+\n+    FT_Error error = setupFTContext(env, font2D, scalerInfo, context);\n+    if (error) {\n+        return;\n+    }\n+\n+    if (context->fixedSizeIndex == -1) {\n+        if (!context->colorFont ||\n+            !addColorLayersRenderData(env, context, scalerInfo, glyphCode, xpos, ypos, result)) {\n+            FT_Outline* outline = getFTOutlineNoSetup(context, scalerInfo, glyphCode, xpos, ypos);\n+            jobject gp = outlineToGeneralPath(env, outline);\n+            if (gp != NULL) {\n+                (*env)->SetObjectField(env, result, sunFontIDs.glyphRenderDataOutline, gp);\n+            }\n+        }\n+    } else {\n+        addBitmapRenderData(env, scaler, font2D, context, scalerInfo, glyphCode, xpos, ypos, result);\n+    }\n+}\n+\n@@ -1523,91 +2025,0 @@\n-\/*\n- * Class:     sun_font_FreetypeFontScaler\n- * Method:    getGlyphVectorOutlineNative\n- * Signature: (Lsun\/font\/Font2D;J[IIFF)Ljava\/awt\/geom\/GeneralPath;\n- *\/\n-JNIEXPORT jobject\n-JNICALL\n-Java_sun_font_FreetypeFontScaler_getGlyphVectorOutlineNative(\n-        JNIEnv *env, jobject scaler, jobject font2D,\n-        jlong pScalerContext, jlong pScaler,\n-        jintArray glyphArray, jint numGlyphs, jfloat xpos, jfloat ypos) {\n-\n-    FT_Outline* outline;\n-    jobject gp = NULL;\n-    jbyteArray types;\n-    jfloatArray coords;\n-    GPData gpdata;\n-    int i;\n-    jint *glyphs;\n-\n-    FTScalerContext *context =\n-         (FTScalerContext*) jlong_to_ptr(pScalerContext);\n-    FTScalerInfo *scalerInfo =\n-             (FTScalerInfo*) jlong_to_ptr(pScaler);\n-\n-    glyphs = NULL;\n-    if (numGlyphs > 0 && 0xffffffffu \/ sizeof(jint) >= (unsigned int)numGlyphs) {\n-        glyphs = (jint*) malloc(numGlyphs*sizeof(jint));\n-    }\n-    if (glyphs == NULL) {\n-        \/\/ We reach here if:\n-        \/\/ 1. numGlyphs <= 0,\n-        \/\/ 2. overflow check failed, or\n-        \/\/ 3. malloc failed.\n-        gp = (*env)->NewObject(env, sunFontIDs.gpClass, sunFontIDs.gpCtrEmpty);\n-        return gp;\n-    }\n-\n-    (*env)->GetIntArrayRegion(env, glyphArray, 0, numGlyphs, glyphs);\n-\n-    gpdata.numCoords = 0;\n-    for (i=0; i<numGlyphs;i++) {\n-        if (glyphs[i] >= INVISIBLE_GLYPHS) {\n-            continue;\n-        }\n-        outline = getFTOutline(env,\n-                               font2D,\n-                               context,\n-                               scalerInfo,\n-                               glyphs[i],\n-                               xpos, ypos);\n-\n-        if (outline == NULL || outline->n_points == 0) {\n-            continue;\n-        }\n-\n-        gpdata.pointTypes  = NULL;\n-        gpdata.pointCoords = NULL;\n-        if (!allocateSpaceForGP(&gpdata, outline->n_points,\n-                                outline->n_contours)) {\n-            break;\n-        }\n-\n-        addToGP(&gpdata, outline);\n-    }\n-    free(glyphs);\n-\n-    if (gpdata.numCoords != 0) {\n-      types = (*env)->NewByteArray(env, gpdata.numTypes);\n-      coords = (*env)->NewFloatArray(env, gpdata.numCoords);\n-\n-      if (types && coords) {\n-        (*env)->SetByteArrayRegion(env, types, 0,\n-                                   gpdata.numTypes, gpdata.pointTypes);\n-        (*env)->SetFloatArrayRegion(env, coords, 0,\n-                                    gpdata.numCoords, gpdata.pointCoords);\n-\n-        gp=(*env)->NewObject(env,\n-                             sunFontIDs.gpClass,\n-                             sunFontIDs.gpCtr,\n-                             gpdata.wr,\n-                             types,\n-                             gpdata.numTypes,\n-                             coords,\n-                             gpdata.numCoords);\n-        return gp;\n-      }\n-    }\n-    return (*env)->NewObject(env, sunFontIDs.gpClass, sunFontIDs.gpCtrEmpty);\n-}\n-\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/freetypeScaler.c","additions":630,"deletions":219,"binary":false,"changes":849,"status":"modified"},{"patch":"@@ -192,0 +192,14 @@\n+    CHECK_NULL(tmpClass = (*env)->FindClass(env, \"sun\/font\/GlyphRenderData\"));\n+    CHECK_NULL(sunFontIDs.glyphRenderDataOutline =\n+         (*env)->GetFieldID(env, tmpClass, \"outline\", \"Ljava\/awt\/geom\/GeneralPath;\"));\n+    CHECK_NULL(sunFontIDs.glyphRenderDataColorLayers =\n+         (*env)->GetFieldID(env, tmpClass, \"colorLayers\", \"Ljava\/util\/List;\"));\n+    CHECK_NULL(sunFontIDs.glyphRenderDataSetColorLayersListMID =\n+          (*env)->GetMethodID(env, tmpClass, \"setColorLayersList\", \"(I)V\"));\n+    CHECK_NULL(sunFontIDs.glyphRenderDataAddColorLayerMID =\n+          (*env)->GetMethodID(env, tmpClass, \"addColorLayers\", \"(IIIILjava\/awt\/geom\/GeneralPath;)V\"));\n+    CHECK_NULL(sunFontIDs.glyphRenderDataAddColorLayerFGMID =\n+          (*env)->GetMethodID(env, tmpClass, \"addColorLayers\", \"(Ljava\/awt\/geom\/GeneralPath;)V\"));\n+    CHECK_NULL(sunFontIDs.glyphRenderDataAddBitmapMID =\n+          (*env)->GetMethodID(env, tmpClass, \"addBitmap\", \"(DDDDDDIIII[I)V\"));\n+\n@@ -317,1 +331,1 @@\n-    if ((*env)->GetArrayLength(env, results) < 13) {\n+    if ((*env)->GetArrayLength(env, results) < 14) {\n@@ -344,0 +358,1 @@\n+    nresults[13] = (size_t)&(info->format)-baseAddr;\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/sunFont.c","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -110,4 +110,0 @@\n-    GeneralPath getGlyphVectorOutline(int[] glyphs, float x, float y) {\n-        return delegateStrike.getGlyphVectorOutline(glyphs, x, y);\n-    }\n-\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/DelegateStrike.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -289,6 +289,0 @@\n-    public  GeneralPath getGlyphVectorOutline(long pScalerContext,\n-                                              int[] glyphs, int numGlyphs,\n-                                              float x,  float y) {\n-        return null;\n-    }\n-\n@@ -313,0 +307,4 @@\n+    public SlotInfo getSlotInfoForGlyph(int glyphCode) {\n+        return new SlotInfo(getDelegateFont());\n+    }\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/NativeFont.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -291,2 +291,2 @@\n-     GeneralPath getGlyphVectorOutline(int[] glyphs, float x, float y) {\n-         return new GeneralPath();\n+     GlyphRenderData getGlyphRenderData(int glyphCode, float x, float y) {\n+         return new GlyphRenderData();\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/NativeStrike.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-    native void doDrawGlyphList(long dstData, long xgc,\n+    native boolean doDrawGlyphList(long dstData, long xgc,\n@@ -81,1 +81,21 @@\n-            doDrawGlyphList(x11sd.getNativeOps(), xgc, clip, gl);\n+            boolean allGlyphsRendered = doDrawGlyphList(x11sd.getNativeOps(), xgc, clip, gl);\n+            \/\/ There are some color glyphs, which we couldn't draw\n+            if (!allGlyphsRendered) {\n+                gl.startGlyphIteration();\n+                for (int i = 0; i < gl.getNumGlyphs(); i++) {\n+                    if (gl.isColorGlyph(i)) {\n+                        int end;\n+                        for (end = i + 1; end < gl.getNumGlyphs(); end++) {\n+                            if (!gl.isColorGlyph(end)) {\n+                                break;\n+                            }\n+                        }\n+                        sg2d.loops.drawGlyphListColorLoop.\n+                                DrawGlyphListColor(sg2d, sg2d.surfaceData,\n+                                        gl, i, end);\n+                        i = end - 1;\n+                    } else {\n+                        gl.setGlyphIndex(i);\n+                    }\n+                }\n+            }\n@@ -92,1 +112,1 @@\n-        void doDrawGlyphList(long dstData, long xgc,\n+        boolean doDrawGlyphList(long dstData, long xgc,\n@@ -96,1 +116,1 @@\n-            super.doDrawGlyphList(dstData, xgc, clip, gl);\n+            return super.doDrawGlyphList(dstData, xgc, clip, gl);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/X11TextRenderer.java","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -41,0 +41,6 @@\n+    \/**\n+     * BGRA glyphs are rendered as images\n+     * and therefore don't belong to any glyph set\n+     *\/\n+    public static final int BGRA_GLYPH_SET = -1;\n+\n@@ -50,0 +56,1 @@\n+    final EnumMap<XRGlyphCacheEntry.Type, Integer> glyphSetsByType;\n@@ -66,0 +73,5 @@\n+        glyphSetsByType = new EnumMap<>(XRGlyphCacheEntry.Type.class);\n+        glyphSetsByType.put(XRGlyphCacheEntry.Type.GRAYSCALE, grayGlyphSet);\n+        glyphSetsByType.put(XRGlyphCacheEntry.Type.LCD, lcdGlyphSet);\n+        glyphSetsByType.put(XRGlyphCacheEntry.Type.BGRA, BGRA_GLYPH_SET);\n+\n@@ -107,1 +119,1 @@\n-    public XRGlyphCacheEntry[] cacheGlyphs(GlyphList glyphList) {\n+    public XRGlyphCacheEntry[] cacheGlyphs(GlyphList glyphList, int parentXid) {\n@@ -117,1 +129,2 @@\n-            if (imgPtrs[i] == 0L) {\n+            if (imgPtrs[i] == 0L ||\n+                imgPtrs[i] == StrikeCache.invisibleGlyphPtr) {\n@@ -127,1 +140,1 @@\n-                    uncachedGlyphs = new ArrayList<XRGlyphCacheEntry>();\n+                    uncachedGlyphs = new ArrayList<>();\n@@ -137,1 +150,1 @@\n-            uploadGlyphs(entries, uncachedGlyphs, glyphList, null);\n+            uploadGlyphs(entries, uncachedGlyphs, glyphList, parentXid);\n@@ -143,1 +156,3 @@\n-    protected void uploadGlyphs(XRGlyphCacheEntry[] glyphs, ArrayList<XRGlyphCacheEntry> uncachedGlyphs, GlyphList gl, int[] glIndices) {\n+    protected void uploadGlyphs(XRGlyphCacheEntry[] glyphs,\n+                                ArrayList<XRGlyphCacheEntry> uncachedGlyphs,\n+                                GlyphList gl, int parentXid) {\n@@ -152,4 +167,13 @@\n-        boolean containsLCDGlyphs = containsLCDGlyphs(uncachedGlyphs);\n-        List<XRGlyphCacheEntry>[] seperatedGlyphList = seperateGlyphTypes(uncachedGlyphs, containsLCDGlyphs);\n-        List<XRGlyphCacheEntry> grayGlyphList = seperatedGlyphList[0];\n-        List<XRGlyphCacheEntry> lcdGlyphList = seperatedGlyphList[1];\n+        EnumMap<XRGlyphCacheEntry.Type, List<XRGlyphCacheEntry>>\n+                glyphListsByType = separateGlyphTypes(uncachedGlyphs);\n+\n+        uploadGlyphs(grayGlyphSet, gl,\n+                     glyphListsByType.get(XRGlyphCacheEntry.Type.GRAYSCALE));\n+        uploadGlyphs(lcdGlyphSet, gl,\n+                     glyphListsByType.get(XRGlyphCacheEntry.Type.LCD));\n+        List<XRGlyphCacheEntry> bgraGlyphs = glyphListsByType.getOrDefault(\n+                XRGlyphCacheEntry.Type.BGRA, List.of());\n+        if (!bgraGlyphs.isEmpty()) {\n+            con.addBGRAGlyphImages(parentXid, bgraGlyphs);\n+        }\n+    }\n@@ -157,0 +181,5 @@\n+    private void uploadGlyphs(int glyphSet, GlyphList glyphList,\n+                              List<XRGlyphCacheEntry> cacheEntries) {\n+        if (cacheEntries == null || cacheEntries.isEmpty()) {\n+            return;\n+        }\n@@ -163,6 +192,2 @@\n-            if (grayGlyphList != null && grayGlyphList.size() > 0) {\n-                con.XRenderAddGlyphs(grayGlyphSet, gl, grayGlyphList, generateGlyphImageStream(grayGlyphList));\n-            }\n-            if (lcdGlyphList != null && lcdGlyphList.size() > 0) {\n-                con.XRenderAddGlyphs(lcdGlyphSet, gl, lcdGlyphList, generateGlyphImageStream(lcdGlyphList));\n-            }\n+            con.XRenderAddGlyphs(glyphSet, glyphList, cacheEntries,\n+                    generateGlyphImageStream(cacheEntries));\n@@ -170,1 +195,1 @@\n-            ArrayList<XRGlyphCacheEntry> tmpList = new ArrayList<XRGlyphCacheEntry>(1);\n+            ArrayList<XRGlyphCacheEntry> tmpList = new ArrayList<>(1);\n@@ -172,2 +197,1 @@\n-\n-            for (XRGlyphCacheEntry entry : uncachedGlyphs) {\n+            for (XRGlyphCacheEntry entry : cacheEntries) {\n@@ -175,6 +199,2 @@\n-\n-                if (entry.getGlyphSet() == grayGlyphSet) {\n-                    con.XRenderAddGlyphs(grayGlyphSet, gl, tmpList, generateGlyphImageStream(tmpList));\n-                } else {\n-                    con.XRenderAddGlyphs(lcdGlyphSet, gl, tmpList, generateGlyphImageStream(tmpList));\n-                }\n+                con.XRenderAddGlyphs(glyphSet, glyphList, tmpList,\n+                                     generateGlyphImageStream(tmpList));\n@@ -186,1 +206,1 @@\n-     * Separates lcd and grayscale glyphs queued for upload, and sets the\n+     * Separates bgra, lcd and grayscale glyphs queued for upload, and sets the\n@@ -189,4 +209,4 @@\n-    protected List<XRGlyphCacheEntry>[] seperateGlyphTypes(List<XRGlyphCacheEntry> glyphList, boolean containsLCDGlyphs) {\n-        ArrayList<XRGlyphCacheEntry> lcdGlyphs = null;\n-        ArrayList<XRGlyphCacheEntry> grayGlyphs = null;\n-\n+    protected EnumMap<XRGlyphCacheEntry.Type, List<XRGlyphCacheEntry>>\n+            separateGlyphTypes(List<XRGlyphCacheEntry> glyphList) {\n+        EnumMap<XRGlyphCacheEntry.Type, List<XRGlyphCacheEntry>> glyphLists =\n+                new EnumMap<>(XRGlyphCacheEntry.Type.class);\n@@ -194,13 +214,4 @@\n-            if (cacheEntry.isGrayscale(containsLCDGlyphs)) {\n-                if (grayGlyphs == null) {\n-                    grayGlyphs = new ArrayList<>(glyphList.size());\n-                }\n-                cacheEntry.setGlyphSet(grayGlyphSet);\n-                grayGlyphs.add(cacheEntry);\n-            } else {\n-                if (lcdGlyphs == null) {\n-                    lcdGlyphs = new ArrayList<>(glyphList.size());\n-                }\n-                cacheEntry.setGlyphSet(lcdGlyphSet);\n-                lcdGlyphs.add(cacheEntry);\n-            }\n+            XRGlyphCacheEntry.Type cacheEntryType = cacheEntry.getType();\n+            cacheEntry.setGlyphSet(glyphSetsByType.get(cacheEntryType));\n+            glyphLists.computeIfAbsent(cacheEntryType, ignore ->\n+                    new ArrayList<>(glyphList.size())).add(cacheEntry);\n@@ -208,5 +219,1 @@\n-        \/\/ Arrays and generics don't play well together\n-        @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n-        List<XRGlyphCacheEntry>[] tmp =\n-            (List<XRGlyphCacheEntry>[]) (new List[] { grayGlyphs, lcdGlyphs });\n-        return tmp;\n+        return glyphLists;\n@@ -229,14 +236,1 @@\n-    protected boolean containsLCDGlyphs(List<XRGlyphCacheEntry> entries) {\n-        boolean containsLCDGlyphs = false;\n-\n-        for (XRGlyphCacheEntry entry : entries) {\n-            containsLCDGlyphs = !(entry.getSourceRowBytes() == entry.getWidth());\n-\n-            if (containsLCDGlyphs) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    protected void clearCache(XRGlyphCacheEntry[] glyps) {\n+    protected void clearCache(XRGlyphCacheEntry[] glyphs) {\n@@ -255,2 +249,4 @@\n-        for (XRGlyphCacheEntry glyph : glyps) {\n-            glyph.setPinned();\n+        for (XRGlyphCacheEntry glyph : glyphs) {\n+            if (glyph != null) {\n+                glyph.setPinned();\n+            }\n@@ -271,2 +267,4 @@\n-        for (XRGlyphCacheEntry glyph : glyps) {\n-            glyph.setUnpinned();\n+        for (XRGlyphCacheEntry glyph : glyphs) {\n+            if (glyph != null) {\n+                glyph.setUnpinned();\n+            }\n@@ -281,0 +279,2 @@\n+        long[] removedBGRAGlyphPtrs = null;\n+        int removedBGRAGlyphPtrsCount = 0;\n@@ -293,1 +293,1 @@\n-            } else {\n+            } else if (entry.getGlyphSet() == lcdGlyphSet) {\n@@ -295,0 +295,11 @@\n+            } else if (entry.getGlyphSet() == BGRA_GLYPH_SET) {\n+                if (removedBGRAGlyphPtrs == null) {\n+                    removedBGRAGlyphPtrs = new long[10];\n+                } else if (removedBGRAGlyphPtrsCount >= removedBGRAGlyphPtrs.length) {\n+                    long[] n = new long[removedBGRAGlyphPtrs.length * 2];\n+                    System.arraycopy(removedBGRAGlyphPtrs, 0, n, 0,\n+                                     removedBGRAGlyphPtrs.length);\n+                    removedBGRAGlyphPtrs = n;\n+                }\n+                removedBGRAGlyphPtrs[removedBGRAGlyphPtrsCount++] =\n+                        entry.getBgraGlyphInfoPtr();\n@@ -307,0 +318,5 @@\n+\n+        if (removedBGRAGlyphPtrsCount > 0) {\n+            con.freeBGRAGlyphImages(removedBGRAGlyphPtrs,\n+                                    removedBGRAGlyphPtrsCount);\n+        }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/XRGlyphCache.java","additions":82,"deletions":66,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-    long glyphInfoPtr;\n+    long glyphInfoPtr, bgraGlyphInfoPtr;\n@@ -55,0 +55,8 @@\n+    public long getBgraGlyphInfoPtr() {\n+        return bgraGlyphInfoPtr;\n+    }\n+\n+    public void setBgraGlyphInfoPtr(long bgraGlyphInfoPtr) {\n+        this.bgraGlyphInfoPtr = bgraGlyphInfoPtr;\n+    }\n+\n@@ -135,1 +143,1 @@\n-        int paddedWidth = getPaddedWidth(uploadAsLCD);\n+        int paddedWidth = getPaddedWidth();\n@@ -137,1 +145,1 @@\n-        if (!uploadAsLCD) {\n+        if (getType() == Type.GRAYSCALE) {\n@@ -179,2 +187,11 @@\n-    public boolean isGrayscale(boolean listContainsLCDGlyphs) {\n-        return getSourceRowBytes() == getWidth() && !(getWidth() == 0 && getHeight() == 0 && listContainsLCDGlyphs);\n+    public Type getType() {\n+        byte format = StrikeCache.unsafe.getByte(glyphInfoPtr + StrikeCache.formatOffset);\n+        if (format == StrikeCache.PIXEL_FORMAT_GREYSCALE) {\n+            return Type.GRAYSCALE;\n+        } else if (format == StrikeCache.PIXEL_FORMAT_LCD) {\n+            return Type.LCD;\n+        } else if (format == StrikeCache.PIXEL_FORMAT_BGRA) {\n+            return Type.BGRA;\n+        } else {\n+            throw new IllegalStateException(\"Unknown glyph format: \" + format);\n+        }\n@@ -183,3 +200,3 @@\n-    public int getPaddedWidth(boolean listContainsLCDGlyphs) {\n-        int width = getWidth();\n-        return isGrayscale(listContainsLCDGlyphs) ? (int) Math.ceil(width \/ 4.0) * 4 : width;\n+    public int getPaddedWidth() {\n+        return getType() == Type.GRAYSCALE ?\n+                (int) Math.ceil(getWidth() \/ 4.0) * 4 : getWidth();\n@@ -188,3 +205,2 @@\n-    public int getDestinationRowBytes(boolean listContainsLCDGlyphs) {\n-        boolean grayscale = isGrayscale(listContainsLCDGlyphs);\n-        return grayscale ? getPaddedWidth(grayscale) : getWidth() * 4;\n+    public int getDestinationRowBytes() {\n+        return getType() == Type.GRAYSCALE ? getPaddedWidth() : getWidth() * 4;\n@@ -193,2 +209,2 @@\n-    public int getGlyphDataLenth(boolean listContainsLCDGlyphs) {\n-        return getDestinationRowBytes(listContainsLCDGlyphs) * getHeight();\n+    public int getGlyphDataLenth() {\n+        return getDestinationRowBytes() * getHeight();\n@@ -220,0 +236,9 @@\n+\n+\n+    public enum Type {\n+        GRAYSCALE,\n+        LCD,\n+        BGRA\n+    }\n+\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/XRGlyphCacheEntry.java","additions":38,"deletions":13,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -81,1 +81,2 @@\n-            XRGlyphCacheEntry[] cachedGlyphs = glyphCache.cacheGlyphs(gl);\n+            XRGlyphCacheEntry[] cachedGlyphs =\n+                    glyphCache.cacheGlyphs(gl, x11sd.getXid());\n@@ -83,1 +84,3 @@\n-            int activeGlyphSet = cachedGlyphs[0].getGlyphSet();\n+            \/* Do not initialize it to cachedGlyphs[0].getGlyphSet(),\n+             * as it may cause NPE *\/\n+            int activeGlyphSet = 0;\n@@ -88,0 +91,4 @@\n+            \/* Accumulated advances are used to adjust glyph positions\n+             * when mixing BGRA and standard glyphs as they have\n+             * completely different methods of rendering. *\/\n+            float accumulatedXEltAdvanceX = 0, accumulatedXEltAdvanceY = 0;\n@@ -95,1 +102,0 @@\n-                eltList.getGlyphs().addInt(cacheEntry.getGlyphID());\n@@ -98,0 +104,11 @@\n+                if (glyphSet == XRGlyphCache.BGRA_GLYPH_SET) {\n+                    \/* BGRA glyphs store pointers to BGRAGlyphInfo\n+                     * struct instead of glyph index *\/\n+                    eltList.getGlyphs().addInt(\n+                            (int) (cacheEntry.getBgraGlyphInfoPtr() >> 32));\n+                    eltList.getGlyphs().addInt(\n+                            (int) cacheEntry.getBgraGlyphInfoPtr());\n+                } else {\n+                    eltList.getGlyphs().addInt(cacheEntry.getGlyphID());\n+                }\n+\n@@ -106,1 +123,5 @@\n-                        || eltList.getCharCnt(eltIndex) == MAX_ELT_GLYPH_COUNT) {\n+                        \/* We don't care about number of glyphs when\n+                         * rendering BGRA glyphs because they are not rendered\n+                         * using XRenderCompositeText. *\/\n+                        || (glyphSet != XRGlyphCache.BGRA_GLYPH_SET &&\n+                            eltList.getCharCnt(eltIndex) == MAX_ELT_GLYPH_COUNT)) {\n@@ -139,7 +160,14 @@\n-                    \/\/ Offset of the current glyph is the difference\n-                    \/\/ to the last glyph and this one\n-                    eltList.setXOff(eltIndex, (posX - oldPosX));\n-                    eltList.setYOff(eltIndex, (posY - oldPosY));\n-\n-                    oldPosX = posX;\n-                    oldPosY = posY;\n+                    if (glyphSet == XRGlyphCache.BGRA_GLYPH_SET) {\n+                        \/\/ BGRA glyphs use absolute positions\n+                        eltList.setXOff(eltIndex,\n+                                        (int) (accumulatedXEltAdvanceX + posX));\n+                        eltList.setYOff(eltIndex,\n+                                        (int) (accumulatedXEltAdvanceY + posY));\n+                    } else {\n+                        \/\/ Offset of the current glyph is the difference\n+                        \/\/ to the last glyph and this one\n+                        eltList.setXOff(eltIndex, (posX - oldPosX));\n+                        eltList.setYOff(eltIndex, (posY - oldPosY));\n+                        oldPosX = posX;\n+                        oldPosY = posY;\n+                    }\n@@ -150,0 +178,7 @@\n+                if (glyphSet == XRGlyphCache.BGRA_GLYPH_SET) {\n+                    advX += cacheEntry.getXAdvance();\n+                    advY += cacheEntry.getYAdvance();\n+                } else {\n+                    accumulatedXEltAdvanceX += cacheEntry.getXAdvance();\n+                    accumulatedXEltAdvanceY += cacheEntry.getYAdvance();\n+                }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/XRTextRenderer.java","additions":46,"deletions":11,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -97,0 +97,5 @@\n+    public void addBGRAGlyphImages(int drawable,\n+                                   List<XRGlyphCacheEntry> cacheEntries);\n+\n+    public void freeBGRAGlyphImages(long[] glyphInfoPointers, int glyphCount);\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/java2d\/xr\/XRBackend.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -253,0 +253,20 @@\n+    public void addBGRAGlyphImages(int drawable,\n+                                   List<XRGlyphCacheEntry> cacheEntries) {\n+        long[] glyphInfoPtrs = getGlyphInfoPtrs(cacheEntries);\n+        addBGRAGlyphImagesNative(drawable, glyphInfoPtrs,\n+                                 glyphInfoPtrs.length, FMTPTR_ARGB32);\n+        \/* addBGRAGlyphImagesNative replaced values in\n+         * glyphInfoPtrs with pointers to BGRAGlyphInfo structs, save them *\/\n+        int i = 0;\n+        for (XRGlyphCacheEntry cacheEntry : cacheEntries) {\n+            cacheEntry.setBgraGlyphInfoPtr(glyphInfoPtrs[i++]);\n+        }\n+    }\n+\n+    private native void addBGRAGlyphImagesNative(int drawable,\n+                                                 long[] glyphInfoPtrs,\n+                                                 int glyphCnt, long format32);\n+\n+    public native void freeBGRAGlyphImages(long[] glyphInfoPointers,\n+                                           int glyphCount);\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/java2d\/xr\/XRBackendNative.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -292,0 +292,1 @@\n+    glyphInfo->format = sun_font_StrikeCache_PIXEL_FORMAT_GREYSCALE;\n","filename":"src\/java.desktop\/unix\/native\/common\/java2d\/x11\/X11FontScaler_md.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-                       jint clipRight, jint clipBottom)\n+                       jint clipRight, jint clipBottom, jboolean *allGlyphsRendered)\n@@ -127,1 +127,1 @@\n-        rowBytes = glyphs[glyphCounter].width;\n+        rowBytes = glyphs[glyphCounter].rowBytes;\n@@ -133,0 +133,5 @@\n+        if ((int) rowBytes == width * 4) { \/\/ Skip colored glyphs\n+            *allGlyphsRendered = JNI_FALSE;\n+            continue;\n+        }\n+\n@@ -209,1 +214,1 @@\n-                 SurfaceDataBounds *bounds, ImageRef *glyphs, jint totalGlyphs)\n+                 SurfaceDataBounds *bounds, ImageRef *glyphs, jint totalGlyphs, jboolean *allGlyphsRendered)\n@@ -262,1 +267,1 @@\n-                       cx1, cy1, cx2, cy2);\n+                       cx1, cy1, cx2, cy2, allGlyphsRendered);\n","filename":"src\/java.desktop\/unix\/native\/common\/java2d\/x11\/X11TextRenderer_md.c","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -62,0 +62,8 @@\n+\/* BGRA glyph that is rendered using XRenderComposite instead of\n+ * XRenderCompositeText32. Used for colored glyphs *\/\n+typedef struct _BGRAGlyphInfo {\n+    GlyphInfo* glyphInfo;\n+    Pixmap pixmap;\n+    Picture picture;\n+} BGRAGlyphInfo;\n+\n@@ -882,0 +890,68 @@\n+JNIEXPORT void JNICALL\n+Java_sun_java2d_xr_XRBackendNative_addBGRAGlyphImagesNative\n+        (JNIEnv* env, jclass clazz, jint drawable,\n+         jlongArray javaGlyphInfoPointersArray, jint glyphCnt, jlong format32) {\n+    jlong* glyphInfoPointers;\n+    if ((glyphInfoPointers = (jlong *)\n+        (*env)->GetPrimitiveArrayCritical(env, javaGlyphInfoPointersArray, NULL)) == NULL) {\n+        return;\n+    }\n+\n+    XRenderPictFormat* format = (XRenderPictFormat*) jlong_to_ptr(format32);\n+    XRenderPictureAttributes pictureAttributes;\n+\n+    int i;\n+    for (i = 0; i < glyphCnt; i++) {\n+        GlyphInfo* glyphInfo = (GlyphInfo*) jlong_to_ptr(glyphInfoPointers[i]);\n+\n+        Pixmap pixmap = XCreatePixmap(awt_display, (Drawable) drawable,\n+                                      glyphInfo->width, glyphInfo->height, 32);\n+        GC gc = XCreateGC(awt_display, (Drawable) pixmap, 0L, NULL);\n+        XImage* image = XCreateImage(awt_display, NULL, 32, ZPixmap, 0,\n+                                     (char*) glyphInfo->image,\n+                                     glyphInfo->width, glyphInfo->height,\n+                                     32, glyphInfo->rowBytes);\n+        XPutImage(awt_display, pixmap, gc, image, 0, 0, 0, 0,\n+                  glyphInfo->width, glyphInfo->height);\n+        image->data = NULL;\n+        XDestroyImage(image);\n+        XFreeGC(awt_display, gc);\n+        Picture picture = XRenderCreatePicture(awt_display, pixmap, format,\n+                                               0, &pictureAttributes);\n+\n+        BGRAGlyphInfo* bgraGlyphInfo =\n+                (BGRAGlyphInfo*) malloc(sizeof(BGRAGlyphInfo));\n+        bgraGlyphInfo->glyphInfo = glyphInfo;\n+        bgraGlyphInfo->pixmap = pixmap;\n+        bgraGlyphInfo->picture = picture;\n+\n+        glyphInfoPointers[i] = ptr_to_jlong(bgraGlyphInfo);\n+    }\n+\n+    (*env)->ReleasePrimitiveArrayCritical(env, javaGlyphInfoPointersArray,\n+                                          glyphInfoPointers, JNI_ABORT);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_java2d_xr_XRBackendNative_freeBGRAGlyphImages\n+        (JNIEnv* env, jclass clazz,\n+         jlongArray javaGlyphInfoPointersArray, jint glyphCnt) {\n+    jlong* glyphInfoPointers;\n+    if ((glyphInfoPointers = (jlong *)\n+        (*env)->GetPrimitiveArrayCritical(env, javaGlyphInfoPointersArray, NULL)) == NULL) {\n+        return;\n+    }\n+\n+    int i;\n+    for (i = 0; i < glyphCnt; i++) {\n+        BGRAGlyphInfo* bgraGlyphInfo =\n+                (BGRAGlyphInfo*) jlong_to_ptr(glyphInfoPointers[i]);\n+        XRenderFreePicture(awt_display, bgraGlyphInfo->picture);\n+        XFreePixmap(awt_display, bgraGlyphInfo->pixmap);\n+        free(bgraGlyphInfo);\n+    }\n+\n+    (*env)->ReleasePrimitiveArrayCritical(env, javaGlyphInfoPointersArray,\n+                                          glyphInfoPointers, JNI_ABORT);\n+}\n+\n@@ -959,8 +1035,35 @@\n-    for (i=0; i < eltCnt; i++) {\n-      xelts[i].nchars = elts[i*4 + 0];\n-      xelts[i].xOff = elts[i*4 + 1];\n-      xelts[i].yOff = elts[i*4 + 2];\n-      xelts[i].glyphset = (GlyphSet) elts[i*4 + 3];\n-      xelts[i].chars = &xids[charCnt];\n-\n-      charCnt += xelts[i].nchars;\n+    int totalXElts = 0;\n+    for (i = 0; i < eltCnt; i++) {\n+        int nchars = elts[i*4];\n+        int xOff = elts[i*4 + 1];\n+        int yOff = elts[i*4 + 2];\n+        int glyphset = (GlyphSet) elts[i*4 + 3];\n+        if (glyphset == -1) { \/\/ BGRA glyph, render as image\n+            float x = (float) xOff;\n+            float y = (float) yOff;\n+            int ch;\n+            for (ch = 0; ch < nchars; ch++) {\n+                BGRAGlyphInfo* bgraGlyphInfo = (BGRAGlyphInfo*)\n+                        (((jlong) xids[charCnt + ch * 2] << 32) |\n+                        (((jlong) xids[charCnt + ch * 2 + 1]) & 0xFFFFFFFF));\n+                GlyphInfo* glyph = bgraGlyphInfo->glyphInfo;\n+                XRenderComposite(awt_display, PictOpOver,\n+                                 bgraGlyphInfo->picture,\n+                                 (Picture) 0, (Picture) dst,\n+                                 0, 0, 0, 0,\n+                                 (int) (x + glyph->topLeftX),\n+                                 (int) (y + glyph->topLeftY),\n+                                 glyph->width, glyph->height);\n+                x += glyph->advanceX;\n+                y += glyph->advanceY;\n+            }\n+            charCnt += nchars * 2;\n+        } else { \/\/ Standard XRender glyph\n+            xelts[totalXElts].nchars = nchars;\n+            xelts[totalXElts].xOff = xOff;\n+            xelts[totalXElts].yOff = yOff;\n+            xelts[totalXElts].glyphset = glyphset;\n+            xelts[totalXElts].chars = &xids[charCnt];\n+            charCnt += nchars;\n+            totalXElts++;\n+        }\n@@ -969,3 +1072,5 @@\n-    XRenderCompositeText32(awt_display, op, (Picture) src, (Picture) dst,\n-                           (XRenderPictFormat *) jlong_to_ptr(maskFmt),\n-                            sx, sy, 0, 0, xelts, eltCnt);\n+    if (totalXElts > 0) {\n+        XRenderCompositeText32(awt_display, op, (Picture) src, (Picture) dst,\n+                               (XRenderPictFormat *) jlong_to_ptr(maskFmt),\n+                               sx, sy, 0, 0, xelts, totalXElts);\n+    }\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/java2d\/x11\/XRBackendNative.c","additions":116,"deletions":11,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n- SurfaceDataBounds *bounds, ImageRef *glyphs, jint totalGlyphs);\n+ SurfaceDataBounds *bounds, ImageRef *glyphs, jint totalGlyphs, jboolean *allGlyphsRendered);\n@@ -53,1 +53,1 @@\n- * Signature: (Lsun\/java2d\/SurfaceData;Ljava\/awt\/Rectangle;ILsun\/font\/GlyphList;J)V\n+ * Signature: (Lsun\/java2d\/SurfaceData;Ljava\/awt\/Rectangle;ILsun\/font\/GlyphList;J)Z\n@@ -55,1 +55,1 @@\n-JNIEXPORT void JNICALL Java_sun_font_X11TextRenderer_doDrawGlyphList\n+JNIEXPORT jboolean JNICALL Java_sun_font_X11TextRenderer_doDrawGlyphList\n@@ -67,1 +67,1 @@\n-        return;\n+        return JNI_TRUE;\n@@ -71,1 +71,1 @@\n-        return;\n+        return JNI_TRUE;\n@@ -73,0 +73,1 @@\n+    jboolean allGlyphsRendered = JNI_TRUE;\n@@ -74,1 +75,1 @@\n-                     &bounds, gbv->glyphs, gbv->numGlyphs);\n+                     &bounds, gbv->glyphs, gbv->numGlyphs, &allGlyphsRendered);\n@@ -76,0 +77,1 @@\n+    return allGlyphsRendered;\n","filename":"src\/java.desktop\/unix\/native\/libfontmanager\/X11TextRenderer.c","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,2 +29,1 @@\n-import java.awt.FontFormatException;\n-import java.awt.GraphicsEnvironment;\n+import java.awt.*;\n@@ -34,5 +33,2 @@\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Locale;\n-import java.util.NoSuchElementException;\n-import java.util.StringTokenizer;\n+import java.util.*;\n+import java.util.List;\n@@ -41,3 +37,1 @@\n-import sun.font.FontManager;\n-import sun.font.SunFontManager;\n-import sun.font.TrueTypeFont;\n+import sun.font.*;\n@@ -46,1 +40,1 @@\n- * The X11 implementation of {@link FontManager}.\n+ * The Win32 implementation of {@link FontManager}.\n@@ -51,13 +45,14 @@\n-    private static final TrueTypeFont eudcFont =\n-            AccessController.doPrivileged(new PrivilegedAction<TrueTypeFont>() {\n-                public TrueTypeFont run() {\n-                    String eudcFile = getEUDCFontFile();\n-                    if (eudcFile != null) {\n-                        try {\n-                            \/* Must use Java rasteriser since GDI doesn't\n-                             * enumerate (allow direct use) of EUDC fonts.\n-                             *\/\n-                            return new TrueTypeFont(eudcFile, null, 0,\n-                                                        true, false);\n-                        } catch (FontFormatException e) {\n-                        }\n+    private static final List<Font2D> additionalFallbackFonts =\n+            AccessController.doPrivileged((PrivilegedAction<List<Font2D>>) () -> {\n+                List<Font2D> list = new ArrayList<>();\n+                list.add(new EmojiFont());\n+                \/\/ https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/intl\/end-user-defined-characters\n+                String eudcFile = getEUDCFontFile();\n+                if (eudcFile != null) {\n+                    try {\n+                        \/* Must use Java rasteriser since GDI doesn't\n+                         * enumerate (allow direct use) of EUDC fonts.\n+                         *\/\n+                        list.add(new TrueTypeFont(eudcFile, null, 0,\n+                                true, false));\n+                    } catch (FontFormatException e) {\n@@ -65,1 +60,0 @@\n-                    return null;\n@@ -67,1 +61,2 @@\n-            });\n+                return Collections.unmodifiableList(list);\n+    });\n@@ -77,2 +72,2 @@\n-    public TrueTypeFont getEUDCFont() {\n-        return eudcFont;\n+    public List<Font2D> getAdditionalFallbackFonts() {\n+        return additionalFallbackFonts;\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/Win32FontManager.java","additions":23,"deletions":28,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -569,1 +569,1 @@\n-                PhysicalFont slotFont = compFont.getSlotFont(slot);\n+                Font2D slotFont = compFont.getSlotFont(slot);\n@@ -803,1 +803,1 @@\n-                PhysicalFont slotFont = compFont.getSlotFont(slot);\n+                Font2D slotFont = compFont.getSlotFont(slot);\n@@ -834,1 +834,1 @@\n-                          Font font, PhysicalFont font2D,\n+                          Font font, Font2D font2D,\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WPathGraphics.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,285 @@\n+\/*\r\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\r\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+ *\r\n+ * This code is free software; you can redistribute it and\/or modify it\r\n+ * under the terms of the GNU General Public License version 2 only, as\r\n+ * published by the Free Software Foundation.\r\n+ *\r\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+ * version 2 for more details (a copy is included in the LICENSE file that\r\n+ * accompanied this code).\r\n+ *\r\n+ * You should have received a copy of the GNU General Public License version\r\n+ * 2 along with this work; if not, write to the Free Software Foundation,\r\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+ *\r\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+ * or visit www.oracle.com if you need additional information or have any\r\n+ * questions.\r\n+ *\/\r\n+\r\n+package sun.font;\r\n+\r\n+import java.awt.*;\r\n+import java.awt.geom.GeneralPath;\r\n+import java.awt.geom.Point2D;\r\n+import java.awt.geom.Rectangle2D;\r\n+\r\n+public class EmojiFont extends Font2D {\r\n+\r\n+    private Font2D symbol, emoji;\r\n+    private volatile boolean init;\r\n+\r\n+    public EmojiFont() {\r\n+        handle = new Font2DHandle(this);\r\n+        fullName = \"Emoji.plain\";\r\n+        familyName = \"Emoji\";\r\n+        fontRank = JRE_RANK;\r\n+        style = Font.PLAIN;\r\n+    }\r\n+\r\n+    private void init() {\r\n+        if (!init) {\r\n+            synchronized (this) {\r\n+                if (!init) {\r\n+                    SunFontManager fm = SunFontManager.getInstance();\r\n+                    symbol = fm.findFont2D(\"Segoe UI Symbol\", Font.PLAIN, FontManager.NO_FALLBACK);\r\n+                    emoji = fm.findFont2D(\"Segoe UI Emoji\", Font.PLAIN, FontManager.NO_FALLBACK);\r\n+                    init = true;\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void getStyleMetrics(float pointSize, float[] metrics, int offset) {\r\n+        init();\r\n+        if (emoji != null) {\r\n+            emoji.getStyleMetrics(pointSize, metrics, offset);\r\n+        } else if (symbol != null) {\r\n+            symbol.getStyleMetrics(pointSize, metrics, offset);\r\n+        } else {\r\n+            super.getStyleMetrics(pointSize, metrics, offset);\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    FontStrike createStrike(FontStrikeDesc desc) {\r\n+        init();\r\n+        return new Strike(desc);\r\n+    }\r\n+\r\n+    @Override\r\n+    protected int getValidatedGlyphCode(int glyphCode) {\r\n+        init();\r\n+        Font2D slot = (glyphCode & 1) == 1 ? emoji : symbol;\r\n+        if (emoji != null) {\r\n+            int result = slot.getValidatedGlyphCode(glyphCode >>> 1);\r\n+            if (result != slot.getMissingGlyphCode()) {\r\n+                return glyphCode;\r\n+            }\r\n+        }\r\n+        return getMissingGlyphCode();\r\n+    }\r\n+\r\n+    @Override\r\n+    CharToGlyphMapper getMapper() {\r\n+        init();\r\n+        if (mapper == null) {\r\n+            mapper = new Mapper();\r\n+        }\r\n+        return mapper;\r\n+    }\r\n+\r\n+    @Override\r\n+    public boolean hasSupplementaryChars() {\r\n+        init();\r\n+        return (emoji != null && emoji.hasSupplementaryChars()) ||\r\n+                (symbol != null && symbol.hasSupplementaryChars());\r\n+    }\r\n+\r\n+    @Override\r\n+    public int getNumGlyphs() {\r\n+        init();\r\n+        return Math.max(emoji != null ? emoji.getNumGlyphs() : 0,\r\n+                symbol != null ? symbol.getNumGlyphs() : 0);\r\n+    }\r\n+\r\n+    @Override\r\n+    public boolean canDisplay(int cp) {\r\n+        return (Character.isEmoji(cp) || Character.isEmojiComponent(cp)) && getMapper().canDisplay(cp);\r\n+    }\r\n+\r\n+    @Override\r\n+    public SlotInfo getSlotInfoForGlyph(int glyphCode) {\r\n+        SlotInfo info = ((glyphCode & 1) == 1 ? emoji : symbol)\r\n+                .getSlotInfoForGlyph(glyphCode >>> 1);\r\n+        info.slotShift++;\r\n+        return info;\r\n+    }\r\n+\r\n+    private class Strike extends FontStrike {\r\n+\r\n+        private final FontStrike symbol, emoji;\r\n+\r\n+        private Strike(FontStrikeDesc desc) {\r\n+            this.desc = desc;\r\n+            this.disposer = new FontStrikeDisposer(EmojiFont.this, desc);\r\n+            symbol = EmojiFont.this.symbol == null ? null :\r\n+                    EmojiFont.this.symbol.getStrike(desc);\r\n+            emoji = EmojiFont.this.emoji == null ? null :\r\n+                    EmojiFont.this.emoji.getStrike(desc);\r\n+        }\r\n+\r\n+        private FontStrike getStrikeForGlyph(int glyphCode) {\r\n+            return (glyphCode & 1) == 1 ? emoji : symbol;\r\n+        }\r\n+\r\n+        @Override\r\n+        public int getNumGlyphs() {\r\n+            return EmojiFont.this.getNumGlyphs();\r\n+        }\r\n+\r\n+        @Override\r\n+        StrikeMetrics getFontMetrics() {\r\n+            if (strikeMetrics == null) {\r\n+                StrikeMetrics compMetrics = new StrikeMetrics();\r\n+                if (emoji != null) {\r\n+                    compMetrics.merge(emoji.getFontMetrics());\r\n+                }\r\n+                if (symbol != null) {\r\n+                    compMetrics.merge(symbol.getFontMetrics());\r\n+                }\r\n+                strikeMetrics = compMetrics;\r\n+            }\r\n+            return strikeMetrics;\r\n+        }\r\n+\r\n+        @Override\r\n+        void getGlyphImagePtrs(int[] glyphCodes, long[] images, int len) {\r\n+            for (int i = 0; i < len; i++) {\r\n+                images[i] = getGlyphImagePtr(glyphCodes[i]);\r\n+            }\r\n+        }\r\n+\r\n+        @Override\r\n+        long getGlyphImagePtr(int glyphCode) {\r\n+            FontStrike strike = getStrikeForGlyph(glyphCode);\r\n+            return strike.getGlyphImagePtr(glyphCode >>> 1);\r\n+        }\r\n+\r\n+        @Override\r\n+        void getGlyphImageBounds(int glyphCode, Point2D.Float pt, Rectangle result) {\r\n+            FontStrike strike = getStrikeForGlyph(glyphCode);\r\n+            strike.getGlyphImageBounds(glyphCode >>> 1, pt, result);\r\n+        }\r\n+\r\n+        @Override\r\n+        Point2D.Float getGlyphMetrics(int glyphCode) {\r\n+            FontStrike strike = getStrikeForGlyph(glyphCode);\r\n+            return strike.getGlyphMetrics(glyphCode >>> 1);\r\n+        }\r\n+\r\n+        @Override\r\n+        Point2D.Float getCharMetrics(char ch) {\r\n+            return getGlyphMetrics(getMapper().charToGlyph(ch));\r\n+        }\r\n+\r\n+        @Override\r\n+        float getGlyphAdvance(int glyphCode) {\r\n+            FontStrike strike = getStrikeForGlyph(glyphCode);\r\n+            return strike.getGlyphAdvance(glyphCode >>> 1);\r\n+        }\r\n+\r\n+        @Override\r\n+        float getCodePointAdvance(int cp) {\r\n+            return getGlyphAdvance(getMapper().charToGlyph(cp));\r\n+        }\r\n+\r\n+        @Override\r\n+        Rectangle2D.Float getGlyphOutlineBounds(int glyphCode) {\r\n+            FontStrike strike = getStrikeForGlyph(glyphCode);\r\n+            return strike.getGlyphOutlineBounds(glyphCode >>> 1);\r\n+        }\r\n+\r\n+        @Override\r\n+        GeneralPath getGlyphOutline(int glyphCode, float x, float y) {\r\n+            FontStrike strike = getStrikeForGlyph(glyphCode);\r\n+            GeneralPath path = strike.getGlyphOutline(glyphCode >>> 1, x, y);\r\n+            return path != null ? path : new GeneralPath();\r\n+        }\r\n+\r\n+        @Override\r\n+        GlyphRenderData getGlyphRenderData(int glyphCode, float x, float y) {\r\n+            FontStrike strike = getStrikeForGlyph(glyphCode);\r\n+            return strike.getGlyphRenderData(glyphCode >>> 1, x, y);\r\n+        }\r\n+    }\r\n+\r\n+    class Mapper extends CharToGlyphMapper {\r\n+\r\n+        private final CharToGlyphMapper symbol, emoji;\r\n+\r\n+        private Mapper() {\r\n+            symbol = EmojiFont.this.symbol == null ? null :\r\n+                    EmojiFont.this.symbol.getMapper();\r\n+            emoji = EmojiFont.this.emoji == null ? null :\r\n+                    EmojiFont.this.emoji.getMapper();\r\n+            if (EmojiFont.this.emoji != null) {\r\n+                missingGlyph = compositeGlyphCode(true, EmojiFont.this.emoji.getMissingGlyphCode());\r\n+            } else if (EmojiFont.this.symbol != null) {\r\n+                missingGlyph = compositeGlyphCode(false, EmojiFont.this.symbol.getMissingGlyphCode());\r\n+            }\r\n+        }\r\n+\r\n+        private int compositeGlyphCode(boolean slot, int glyphCode) {\r\n+            return slot ? (glyphCode << 1) | 1 : glyphCode << 1;\r\n+        }\r\n+\r\n+        private boolean getSlot(int unicode, int variationSelector) {\r\n+            return switch (variationSelector) {\r\n+                case 0xFE0F -> true;\r\n+                case 0xFE0E -> false;\r\n+                default -> Character.isEmojiPresentation(unicode);\r\n+            };\r\n+        }\r\n+\r\n+        @Override\r\n+        public int getNumGlyphs() {\r\n+            return EmojiFont.this.getNumGlyphs();\r\n+        }\r\n+\r\n+        @Override\r\n+        public int charToVariationGlyph(int unicode, int variationSelector) {\r\n+            boolean slot = getSlot(unicode, variationSelector);\r\n+            CharToGlyphMapper mapper = slot ? emoji : symbol;\r\n+            if (mapper != null) {\r\n+                int glyph = mapper.charToGlyph(unicode);\r\n+                if (glyph != mapper.getMissingGlyphCode()) {\r\n+                    return compositeGlyphCode(slot, glyph);\r\n+                }\r\n+            }\r\n+            mapper = slot ? symbol : emoji;\r\n+            if (mapper != null) {\r\n+                int glyph = mapper.charToGlyph(unicode);\r\n+                if (glyph != mapper.getMissingGlyphCode()) {\r\n+                    return compositeGlyphCode(!slot, glyph);\r\n+                }\r\n+            }\r\n+            return missingGlyph;\r\n+        }\r\n+\r\n+        @Override\r\n+        public int charToGlyph(int unicode) {\r\n+            return charToVariationGlyph(unicode, 0);\r\n+        }\r\n+\r\n+        @Override\r\n+        public int charToGlyph(char unicode) {\r\n+            return charToGlyph((int) unicode);\r\n+        }\r\n+    }\r\n+}\r\n","filename":"src\/java.desktop\/windows\/classes\/sun\/font\/EmojiFont.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"added"},{"patch":"@@ -82,2 +82,1 @@\n-    public  GeneralPath getGlyphVectorOutline(long pScalerContext,\n-                                              int[] glyphs, int numGlyphs,\n+    public GlyphRenderData getGlyphRenderData(long pScalerContext, int glyphCode,\n@@ -107,0 +106,4 @@\n+\n+    public SlotInfo getSlotInfoForGlyph(int glyphCode) {\n+        return new SlotInfo(getDelegateFont());\n+    }\n","filename":"src\/java.desktop\/windows\/classes\/sun\/font\/NativeFont.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-    GeneralPath getGlyphVectorOutline(int[] glyphs, float x, float y) {\n+    GlyphRenderData getGlyphRenderData(int glyphCode, float x, float y) {\n","filename":"src\/java.desktop\/windows\/classes\/sun\/font\/NativeStrike.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-allfonts.symbols=Segoe UI Symbol\n@@ -253,2 +252,1 @@\n-sequence.fallback=symbols,\\\n-                  chinese-ms950,chinese-hkscs,chinese-ms936,chinese-gb18030,\\\n+sequence.fallback=chinese-ms950,chinese-hkscs,chinese-ms936,chinese-gb18030,\\\n@@ -331,0 +329,1 @@\n+filename.Segoe_UI_Emoji=seguiemj.ttf\n","filename":"src\/java.desktop\/windows\/data\/fontconfig\/fontconfig.properties","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -795,1 +795,1 @@\n-        grayscale = (ginfo->rowBytes == ginfo->width);\n+        grayscale = (ginfo->format == sun_font_StrikeCache_PIXEL_FORMAT_GREYSCALE);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/d3d\/D3DTextRenderer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -439,0 +439,1 @@\n+    glyphInfo->format = sun_font_StrikeCache_PIXEL_FORMAT_LCD;\n","filename":"src\/java.desktop\/windows\/native\/libfontmanager\/lcdglyph.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright 2021 JetBrains s.r.o.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 8269806\n+ * @summary Checks that complex emoji are rendered with proper shaping.\n+ *\/\n+\n+import javax.imageio.ImageIO;\n+import java.awt.*;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.stream.Stream;\n+\n+public class ComplexEmoji {\n+    private static final int IMG_WIDTH = 60;\n+    private static final int IMG_HEIGHT = 20;\n+\n+    private static final String[] EMOJI = {\n+            \"\\ud83d\\udd25\", \/\/ Fire\n+            \"\\u2764\\ufe0f\", \/\/ Heart + color variation selector\n+            \"\\ud83e\\udd18\\ud83c\\udffb\", \/\/ Horns sign - white hand\n+            \"\\ud83d\\udc41\\ufe0f\\u200d\\ud83d\\udde8\\ufe0f\", \/\/ Eye in speech bubble - ZWJ sequence\n+            \"\\uD83C\\uDDE6\\uD83C\\uDDF6\", \/\/ Antarctica flag\n+            \"\\ud83c\\udff4\\udb40\\udc67\\udb40\\udc62\\udb40\\udc65\\udb40\\udc6e\\udb40\\udc67\\udb40\\udc7f\", \/\/ England flag - tag sequence\n+    };\n+\n+    public static void main(String[] args) {\n+        requireFont(\"Apple Color Emoji\", \"Segoe UI Emoji\", \"Noto Color Emoji\");\n+\n+        \/\/ Platform-specific tricks\n+        if (System.getProperty(\"os.name\").toLowerCase().contains(\"windows\")) {\n+            EMOJI[4] = EMOJI[5] = null; \/\/ Flags and tags are not supported on Windows\n+        }\n+\n+        BufferedImage img = new BufferedImage(IMG_WIDTH, IMG_HEIGHT, BufferedImage.TYPE_INT_RGB);\n+        String errors = \"\";\n+        for (int i = 0; i < EMOJI.length; i++) {\n+            String emoji = EMOJI[i];\n+            if (emoji == null) {\n+                continue;\n+            }\n+            drawEmoji(img, emoji);\n+            String error = checkEmoji(img);\n+            if (error != null) {\n+                errors += \"\\n#\" + i + \": \" + error;\n+                try {\n+                    ImageIO.write(img, \"PNG\", new File(\"ComplexEmoji\" + i + \".png\"));\n+                } catch (IOException e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        }\n+        if (!errors.isEmpty()) {\n+            throw new RuntimeException(errors);\n+        }\n+    }\n+\n+    private static void drawEmoji(Image img, String emoji) {\n+        Graphics g = img.getGraphics();\n+        g.setColor(Color.white);\n+        g.fillRect(0, 0, IMG_WIDTH, IMG_HEIGHT);\n+        g.setFont(new Font(Font.DIALOG, Font.PLAIN, 12));\n+        \/\/ Try to trick shaper by prepending \"A\" letter\n+        \/\/ White on white will not be visible anyway\n+        g.drawString(\"A\" + emoji, 2, 15);\n+        g.dispose();\n+    }\n+\n+    private static String checkEmoji(BufferedImage img) {\n+        Point min = new Point(Integer.MAX_VALUE, Integer.MAX_VALUE);\n+        Point max = new Point(Integer.MIN_VALUE, Integer.MIN_VALUE);\n+        for (int x = 0; x < IMG_WIDTH; x++) {\n+            for (int y = 0; y < IMG_HEIGHT; y++) {\n+                int rgb = img.getRGB(x, y);\n+                if (rgb != -1) {\n+                    if (x < min.x) {\n+                        min.x = x;\n+                    }\n+                    if (y < min.y) {\n+                        min.y = y;\n+                    }\n+                    if (x > max.x) {\n+                        max.x = x;\n+                    }\n+                    if (y > max.y) {\n+                        max.y = y;\n+                    }\n+                }\n+            }\n+        }\n+        if (min.x >= max.x || min.y >= max.y) {\n+            return \"Empty image\";\n+        }\n+        int width = max.x - min.x + 1;\n+        int height = max.y - min.y + 1;\n+        double ratio = (double) width \/ (double) height;\n+        if (ratio > 1.5) {\n+            return \"Too wide image, is there few glyphs instead of one?\";\n+        }\n+        return null;\n+    }\n+\n+    private static void requireFont(String macOS, String windows, String linux) {\n+        String os = System.getProperty(\"os.name\").toLowerCase();\n+        String font;\n+        if (os.contains(\"mac\")) {\n+            font = macOS;\n+        } else if (os.contains(\"windows\")) {\n+            font = windows;\n+        } else if (os.contains(\"linux\")) {\n+            font = linux;\n+        } else {\n+            return;\n+        }\n+        String[] fs = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n+        if (Stream.of(fs).noneMatch(s -> s.equals(font))) {\n+            System.err.println(\"Required font not found: \" + font);\n+            System.exit(0);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/font\/Emoji\/ComplexEmoji.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright 2021 JetBrains s.r.o.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 8263583 8269806\n+ * @summary Checks that emoji character has a non-empty and identical\n+ *          representation when rendered to different types of images,\n+ *          including an accelerated surface.\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 Emoji\n+ *\/\n+\n+import java.awt.*;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.VolatileImage;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+public class Emoji {\n+    private static final int IMG_WIDTH = 20;\n+    private static final int IMG_HEIGHT = 20;\n+    private static final Font FONT = new Font(\n+            System.getProperty(\"os.name\").toLowerCase().contains(\"linux\") ?\n+                    \"Noto Color Emoji\" : Font.DIALOG, Font.PLAIN, 12);\n+\n+    public static void main(String[] args) {\n+        requireFont(\"Apple Color Emoji\", \"Segoe UI Emoji\", \"Noto Color Emoji\");\n+\n+        GraphicsConfiguration cfg\n+                = GraphicsEnvironment.getLocalGraphicsEnvironment()\n+                .getDefaultScreenDevice().getDefaultConfiguration();\n+\n+        VolatileImage vImg = cfg.createCompatibleVolatileImage(IMG_WIDTH,\n+                                                               IMG_HEIGHT);\n+        BufferedImage refImg;\n+        int attempt = 0;\n+        do {\n+            if (++attempt > 10) {\n+                throw new RuntimeException(\"Failed to render to VolatileImage\");\n+            }\n+            if (vImg.validate(cfg) == VolatileImage.IMAGE_INCOMPATIBLE) {\n+                throw new RuntimeException(\"Unexpected validation failure\");\n+            }\n+            drawEmoji(vImg);\n+            refImg = vImg.getSnapshot();\n+        } while (vImg.contentsLost());\n+\n+        boolean rendered = false;\n+        for (int x = 0; x < IMG_WIDTH; x++) {\n+            for (int y = 0; y < IMG_HEIGHT; y++) {\n+                if (refImg.getRGB(x, y) != 0xFFFFFFFF) {\n+                    rendered = true;\n+                    break;\n+                }\n+            }\n+        }\n+        if (!rendered) {\n+            throw new RuntimeException(\"Emoji character wasn't rendered\");\n+        }\n+\n+        List<Integer> imageTypes = List.of(\n+                BufferedImage.TYPE_INT_RGB,\n+                BufferedImage.TYPE_INT_ARGB,\n+                BufferedImage.TYPE_INT_ARGB_PRE,\n+                BufferedImage.TYPE_INT_BGR,\n+                BufferedImage.TYPE_3BYTE_BGR,\n+                BufferedImage.TYPE_4BYTE_ABGR,\n+                BufferedImage.TYPE_4BYTE_ABGR_PRE\n+        );\n+        for (Integer type : imageTypes) {\n+            BufferedImage img = new BufferedImage(IMG_WIDTH, IMG_HEIGHT, type);\n+            drawEmoji(img);\n+            for (int x = 0; x < IMG_WIDTH; x++) {\n+                for (int y = 0; y < IMG_HEIGHT; y++) {\n+                    if (refImg.getRGB(x, y) != img.getRGB(x, y)) {\n+                        throw new RuntimeException(\n+                                \"Rendering differs for image type \" + type);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void drawEmoji(Image img) {\n+        Graphics g = img.getGraphics();\n+        g.setColor(Color.white);\n+        g.fillRect(0, 0, IMG_WIDTH, IMG_HEIGHT);\n+        g.setFont(FONT);\n+        g.drawString(\"\\uD83D\\uDE00\" \/* U+1F600 'GRINNING FACE' *\/, 2, 15);\n+        g.dispose();\n+    }\n+\n+    private static void requireFont(String macOS, String windows, String linux) {\n+        String os = System.getProperty(\"os.name\").toLowerCase();\n+        String font;\n+        if (os.contains(\"mac\")) {\n+            font = macOS;\n+        } else if (os.contains(\"windows\")) {\n+            font = windows;\n+        } else if (os.contains(\"linux\")) {\n+            font = linux;\n+        } else {\n+            return;\n+        }\n+        String[] fs = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n+        if (Stream.of(fs).noneMatch(s -> s.equals(font))) {\n+            System.err.println(\"Required font not found: \" + font);\n+            System.exit(0);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/font\/Emoji\/Emoji.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright 2021 JetBrains s.r.o.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 8269806\n+ * @summary Checks that variation selectors work.\n+ *\/\n+\n+import javax.imageio.ImageIO;\n+import java.awt.*;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.awt.RenderingHints.KEY_TEXT_ANTIALIASING;\n+import static java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_OFF;\n+\n+public class EmojiVariation {\n+    private static final int IMG_WIDTH = 100;\n+    private static final int IMG_HEIGHT = 50;\n+\n+    private static final Color SYMBOL_COLOR = Color.MAGENTA;\n+\n+    \/\/ These emoji must be monochrome by default\n+    private static final String[] SYMBOLS = {\n+            \"\\u0023\",\"\\u002a\",\"\\u0030\",\"\\u0031\",\"\\u0032\",\"\\u0033\",\"\\u0034\",\"\\u0035\",\"\\u0036\",\"\\u0037\",\"\\u0038\",\"\\u0039\",\n+            \"\\u00a9\",\"\\u00ae\",\"\\u203c\",\"\\u2049\",\"\\u2122\",\"\\u2139\",\"\\u2194\",\"\\u2195\",\"\\u2196\",\"\\u2197\",\"\\u2198\",\"\\u2199\",\n+            \"\\u21a9\",\"\\u21aa\",\"\\u2328\",\"\\u23cf\",\"\\u23ed\",\"\\u23ee\",\"\\u23ef\",\"\\u23f1\",\"\\u23f2\",\"\\u23f8\",\"\\u23f9\",\"\\u23fa\",\n+            \"\\u24c2\",\"\\u25aa\",\"\\u25ab\",\"\\u25b6\",\"\\u25c0\",\"\\u25fb\",\"\\u25fc\",\"\\u2600\",\"\\u2601\",\"\\u2602\",\"\\u2603\",\"\\u2604\",\n+            \"\\u260e\",\"\\u2611\",\"\\u2618\",\"\\u261d\",\"\\u2620\",\"\\u2622\",\"\\u2623\",\"\\u2626\",\"\\u262a\",\"\\u262e\",\"\\u262f\",\"\\u2638\",\n+            \"\\u2639\",\"\\u263a\",\"\\u2640\",\"\\u2642\",\"\\u265f\",\"\\u2660\",\"\\u2663\",\"\\u2665\",\"\\u2666\",\"\\u2668\",\"\\u267b\",\"\\u267e\",\n+            \"\\u2692\",\"\\u2694\",\"\\u2695\",\"\\u2696\",\"\\u2697\",\"\\u2699\",\"\\u269b\",\"\\u269c\",\"\\u26a0\",\"\\u26b0\",\"\\u26b1\",\"\\u26c8\",\n+            \"\\u26cf\",\"\\u26d1\",\"\\u26d3\",\"\\u26e9\",\"\\u26f0\",\"\\u26f1\",\"\\u26f4\",\"\\u26f7\",\"\\u26f8\",\"\\u26f9\",\"\\u2702\",\"\\u2708\",\n+            \"\\u2709\",\"\\u270c\",\"\\u270d\",\"\\u270f\",\"\\u2712\",\"\\u2714\",\"\\u2716\",\"\\u271d\",\"\\u2721\",\"\\u2733\",\"\\u2734\",\"\\u2744\",\n+            \"\\u2747\",\"\\u2763\",\"\\u2764\",\"\\u27a1\",\"\\u2934\",\"\\u2935\",\"\\u2b05\",\"\\u2b06\",\"\\u2b07\",\"\\u3030\",\"\\u303d\",\"\\u3297\",\n+            \"\\u3299\",\"\\ud83c\\udd70\",\"\\ud83c\\udd71\",\"\\ud83c\\udd7e\",\"\\ud83c\\udd7f\",\"\\ud83c\\ude02\",\"\\ud83c\\ude37\",\n+            \"\\ud83c\\udf21\",\"\\ud83c\\udf24\",\"\\ud83c\\udf25\",\"\\ud83c\\udf26\",\"\\ud83c\\udf27\",\"\\ud83c\\udf28\",\"\\ud83c\\udf29\",\n+            \"\\ud83c\\udf2a\",\"\\ud83c\\udf2b\",\"\\ud83c\\udf2c\",\"\\ud83c\\udf36\",\"\\ud83c\\udf7d\",\"\\ud83c\\udf96\",\"\\ud83c\\udf97\",\n+            \"\\ud83c\\udf99\",\"\\ud83c\\udf9a\",\"\\ud83c\\udf9b\",\"\\ud83c\\udf9e\",\"\\ud83c\\udf9f\",\"\\ud83c\\udfcb\",\"\\ud83c\\udfcc\",\n+            \"\\ud83c\\udfcd\",\"\\ud83c\\udfce\",\"\\ud83c\\udfd4\",\"\\ud83c\\udfd5\",\"\\ud83c\\udfd6\",\"\\ud83c\\udfd7\",\"\\ud83c\\udfd8\",\n+            \"\\ud83c\\udfd9\",\"\\ud83c\\udfda\",\"\\ud83c\\udfdb\",\"\\ud83c\\udfdc\",\"\\ud83c\\udfdd\",\"\\ud83c\\udfde\",\"\\ud83c\\udfdf\",\n+            \"\\ud83c\\udff3\",\"\\ud83c\\udff5\",\"\\ud83c\\udff7\",\"\\ud83d\\udc3f\",\"\\ud83d\\udc41\",\"\\ud83d\\udcfd\",\"\\ud83d\\udd49\",\n+            \"\\ud83d\\udd4a\",\"\\ud83d\\udd6f\",\"\\ud83d\\udd70\",\"\\ud83d\\udd73\",\"\\ud83d\\udd74\",\"\\ud83d\\udd75\",\"\\ud83d\\udd76\",\n+            \"\\ud83d\\udd77\",\"\\ud83d\\udd78\",\"\\ud83d\\udd79\",\"\\ud83d\\udd87\",\"\\ud83d\\udd8a\",\"\\ud83d\\udd8b\",\"\\ud83d\\udd8c\",\n+            \"\\ud83d\\udd8d\",\"\\ud83d\\udd90\",\"\\ud83d\\udda5\",\"\\ud83d\\udda8\",\"\\ud83d\\uddb1\",\"\\ud83d\\uddb2\",\"\\ud83d\\uddbc\",\n+            \"\\ud83d\\uddc2\",\"\\ud83d\\uddc3\",\"\\ud83d\\uddc4\",\"\\ud83d\\uddd1\",\"\\ud83d\\uddd2\",\"\\ud83d\\uddd3\",\"\\ud83d\\udddc\",\n+            \"\\ud83d\\udddd\",\"\\ud83d\\uddde\",\"\\ud83d\\udde1\",\"\\ud83d\\udde3\",\"\\ud83d\\udde8\",\"\\ud83d\\uddef\",\"\\ud83d\\uddf3\",\n+            \"\\ud83d\\uddfa\",\"\\ud83d\\udecb\",\"\\ud83d\\udecd\",\"\\ud83d\\udece\",\"\\ud83d\\udecf\",\"\\ud83d\\udee0\",\"\\ud83d\\udee1\",\n+            \"\\ud83d\\udee2\",\"\\ud83d\\udee3\",\"\\ud83d\\udee4\",\"\\ud83d\\udee5\",\"\\ud83d\\udee9\",\"\\ud83d\\udef0\",\"\\ud83d\\udef3\",\n+    };\n+\n+    private enum Variation {\n+        DEFAULT(\"\"),\n+        MONO(\"\\ufe0e\"),\n+        COLOR(\"\\ufe0f\");\n+\n+        final String suffix;\n+\n+        Variation(String suffix) {\n+            this.suffix = suffix;\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        requireFont(\"Apple Color Emoji\", \"Segoe UI Emoji\", \"Noto Color Emoji\");\n+        requireFont(\"Zapf Dingbats\", \"Segoe UI Symbol\", \"DejaVu Sans\");\n+\n+        \/\/ Platform-specific tricks\n+       if (System.getProperty(\"os.name\").toLowerCase().contains(\"linux\")) {\n+           \/\/ Many emoji on Linux don't have monochrome variants\n+           Arrays.fill(SYMBOLS, 28, 37, null);\n+           Arrays.fill(SYMBOLS, 83, 94, null);\n+           Arrays.fill(SYMBOLS, 117, SYMBOLS.length, null);\n+        } else if (System.getProperty(\"os.name\").toLowerCase().contains(\"mac\")) {\n+           \/\/ Many emoji on macOS don't have monochrome variants\n+           Arrays.fill(SYMBOLS, 28, 36, null);\n+           Arrays.fill(SYMBOLS, 81, 94, null);\n+           Arrays.fill(SYMBOLS, 127, SYMBOLS.length, null);\n+        }\n+\n+        BufferedImage img = new BufferedImage(IMG_WIDTH, IMG_HEIGHT, BufferedImage.TYPE_INT_RGB);\n+        String errors = \"\";\n+        for (String s : SYMBOLS) {\n+            if (s == null) {\n+                continue;\n+            }\n+            errors += test(img, s, Variation.DEFAULT, false);\n+            errors += test(img, s, Variation.MONO, false);\n+            errors += test(img, s, Variation.COLOR, true);\n+        }\n+\n+        if (System.getProperty(\"os.name\").toLowerCase().contains(\"windows\")) {\n+            \/\/ Bonus points: check that variation selectors work other way too\n+            String s = \"\\ud83d\\udd25\";\n+            errors += test(img, s, Variation.DEFAULT, true);\n+            errors += test(img, s, Variation.MONO, false);\n+            errors += test(img, s, Variation.COLOR, true);\n+        }\n+\n+        if (!errors.isEmpty()) {\n+            throw new RuntimeException(errors);\n+        }\n+    }\n+\n+    private static String test(BufferedImage img, String symbol, Variation variation, boolean expectColor) {\n+        draw(img, symbol + variation.suffix);\n+        String error = check(img, expectColor);\n+        if (error != null) {\n+            String name = symbol.chars().mapToObj(c -> {\n+                String s = Integer.toHexString(c);\n+                return \"0\".repeat(4 - s.length()) + s;\n+            }).collect(Collectors.joining(\"-\")) + \"-\" + variation;\n+            try {\n+                ImageIO.write(img, \"PNG\", new File(\"EmojiVariation-\" + name + \".png\"));\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+            return \"\\n\" + name + \": \" + error;\n+        }\n+        return \"\";\n+    }\n+\n+    private static void draw(Image img, String symbol) {\n+        Graphics2D g = (Graphics2D) img.getGraphics();\n+        g.setColor(Color.white);\n+        g.fillRect(0, 0, IMG_WIDTH, IMG_HEIGHT);\n+        g.setFont(new Font(Font.DIALOG, Font.PLAIN, 50));\n+        g.setRenderingHint(KEY_TEXT_ANTIALIASING, VALUE_TEXT_ANTIALIAS_OFF);\n+        g.setColor(SYMBOL_COLOR);\n+        g.drawString(symbol, 2, 42);\n+        g.dispose();\n+    }\n+\n+    private static String check(BufferedImage img, boolean expectColor) {\n+        boolean rendered = false;\n+        boolean color = false;\n+        for (int x = 0; x < IMG_WIDTH; x++) {\n+            for (int y = 0; y < IMG_HEIGHT; y++) {\n+                int rgb = img.getRGB(x, y);\n+                if (rgb != Color.white.getRGB()) {\n+                    rendered = true;\n+                    if ((rgb & 0xff00ff) != 0xff00ff) {\n+                        \/\/ When monochrome symbol is rendered with AA=ON,\n+                        \/\/ pixel color may be anywhere between magenta (SYMBOL_COLOR) and white,\n+                        \/\/ which is 0xff00ff - 0xffffff. This means only green component may vary,\n+                        \/\/ red and green must always be 0xff\n+                        color = true;\n+                    }\n+                }\n+            }\n+        }\n+        if (!rendered) {\n+            return \"Empty image\";\n+        } else if (color != expectColor) {\n+            return expectColor ? \"Expected color but rendered mono\" : \"Expected mono but rendered color\";\n+        }\n+        return null;\n+    }\n+\n+    private static void requireFont(String macOS, String windows, String linux) {\n+        String os = System.getProperty(\"os.name\").toLowerCase();\n+        String font;\n+        if (os.contains(\"mac\")) {\n+            font = macOS;\n+        } else if (os.contains(\"windows\")) {\n+            font = windows;\n+        } else if (os.contains(\"linux\")) {\n+            font = linux;\n+        } else {\n+            return;\n+        }\n+        String[] fs = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n+        if (Stream.of(fs).noneMatch(s -> s.equals(font))) {\n+            System.err.println(\"Required font not found: \" + font);\n+            System.exit(0);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/font\/Emoji\/EmojiVariation.java","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright 2021 JetBrains s.r.o.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 8269806\n+ * @summary Checks that emoji rendered via glyph cache and bypassing it look similar.\n+ *\/\n+\n+import javax.imageio.ImageIO;\n+import java.awt.*;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.util.stream.Stream;\n+\n+import static java.awt.RenderingHints.KEY_TEXT_ANTIALIASING;\n+import static java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_ON;\n+\n+public class OutlineTextRendererEmoji {\n+    private static final int IMG_WIDTH = 84;\n+    private static final int IMG_HEIGHT = 84;\n+    private static final int EMOJI_X = 0;\n+    private static final int EMOJI_Y = 70;\n+    private static final int FONT_SIZE = 70;\n+    private static final String EMOJI = \"\\ud83d\\udd25\"; \/\/ Fire\n+\n+    private static final int WINDOW_SIZE = 12; \/\/ In pixels\n+    private static final double THRESHOLD = 0.98;\n+\n+    public static void main(String[] args) throws Exception {\n+        requireFont(\"Apple Color Emoji\", \"Segoe UI Emoji\", \"Noto Color Emoji\");\n+\n+        BufferedImage small = new BufferedImage(IMG_WIDTH, IMG_HEIGHT, BufferedImage.TYPE_INT_RGB);\n+        BufferedImage rescaled = new BufferedImage(IMG_WIDTH, IMG_HEIGHT, BufferedImage.TYPE_INT_RGB);\n+        BufferedImage big = new BufferedImage(IMG_WIDTH*2, IMG_HEIGHT*2, BufferedImage.TYPE_INT_RGB);\n+        drawEmoji(small, EMOJI_X, EMOJI_Y, FONT_SIZE);\n+        drawEmoji(big, EMOJI_X*2, EMOJI_Y*2, FONT_SIZE*2);\n+        checkEmoji(small, big, rescaled);\n+    }\n+\n+    private static void drawEmoji(Image img, int x, int y, int size) {\n+        Graphics2D g = (Graphics2D) img.getGraphics();\n+        g.setColor(Color.white);\n+        g.fillRect(0, 0, img.getWidth(null), img.getHeight(null));\n+        g.setFont(new Font(Font.DIALOG, Font.PLAIN, size));\n+        g.setRenderingHint(KEY_TEXT_ANTIALIASING, VALUE_TEXT_ANTIALIAS_ON);\n+        g.drawString(EMOJI, x, y);\n+        g.dispose();\n+    }\n+\n+    private static void checkEmoji(BufferedImage small, BufferedImage big, BufferedImage rescaled) throws Exception {\n+        Graphics2D g2d = rescaled.createGraphics();\n+        g2d.drawImage(big.getScaledInstance(small.getWidth(), small.getHeight(), Image.SCALE_SMOOTH), 0, 0, null);\n+        g2d.dispose();\n+\n+        double ssim = SSIM.calculate(small, rescaled, WINDOW_SIZE);\n+        System.out.println(\"SSIM is \" + ssim);\n+\n+        if (ssim < THRESHOLD) {\n+            ImageIO.write(small, \"PNG\", new File(\"OutlineTextRendererEmoji-small.png\"));\n+            ImageIO.write(big, \"PNG\", new File(\"OutlineTextRendererEmoji-big.png\"));\n+            ImageIO.write(rescaled, \"PNG\", new File(\"OutlineTextRendererEmoji-rescaled.png\"));\n+            throw new Exception(\"Images mismatch: \" + ssim);\n+        }\n+    }\n+\n+    private static class SSIM {\n+        private static double calculate(BufferedImage a, BufferedImage b, int windowSize) {\n+            if (a.getWidth() != b.getWidth() || a.getHeight() != b.getHeight()) {\n+                throw new IllegalArgumentException(\"Images must have same size\");\n+            }\n+            if (a.getWidth() % windowSize != 0 || a.getHeight() % windowSize != 0) {\n+                throw new IllegalArgumentException(\"Image sizes must be multiple of windowSize\");\n+            }\n+\n+            final double K1 = 0.01, K2 = 0.03;\n+            final double L = 255; \/\/ dynamic range per component (2^8 - 1)\n+            final double c1 = Math.pow(L * K1, 2);\n+            final double c2 = Math.pow(L * K2, 2);\n+\n+            double result = 0, alpha = 0;\n+            int windows = 0;\n+            for (int y = 0; y <= a.getHeight() - windowSize; y++) {\n+                for (int x = 0; x <= a.getWidth() - windowSize; x++) {\n+\n+                    \/\/ Calculate averages\n+                    double[] avgA = vec(), avgB = vec();\n+                    for (int py = 0; py < windowSize; py++) {\n+                        for (int px = 0; px < windowSize; px++) {\n+                            avgA = add(avgA, vec(a.getRGB(x + px, y + py)));\n+                            avgB = add(avgB, vec(b.getRGB(x + px, y + py)));\n+                        }\n+                    }\n+                    avgA = div(avgA, windowSize * windowSize);\n+                    avgB = div(avgB, windowSize * windowSize);\n+\n+                    \/\/ Calculate variance and covariance\n+                    double[] varA = vec(), varB = vec(), cov = vec();\n+                    for (int py = 0; py < windowSize; py++) {\n+                        for (int px = 0; px < windowSize; px++) {\n+                            double[] da = sub(avgA, vec(a.getRGB(x + px, y + py)));\n+                            double[] db = sub(avgB, vec(b.getRGB(x + px, y + py)));\n+                            varA = add(varA, mul(da, da));\n+                            varB = add(varB, mul(db, db));\n+                            cov = add(cov, mul(da, db));\n+                        }\n+                    }\n+                    varA = div(varA, windowSize * windowSize);\n+                    varB = div(varB, windowSize * windowSize);\n+                    cov = div(cov, windowSize * windowSize);\n+\n+                    \/\/ Calculate ssim\n+                    double[] ssim = vec();\n+                    for (int i = 0; i < 4; i++) {\n+                        ssim[i] = (\n+                                (2 * avgA[i] * avgB[i] + c1) * (2 * cov[i] + c2)\n+                        ) \/ (\n+                                (avgA[i]*avgA[i] + avgB[i]*avgB[i] + c1) * (varA[i] + varB[i] + c2)\n+                        );\n+                    }\n+\n+                    result += ssim[0] + ssim[1] + ssim[2];\n+                    alpha += ssim[3];\n+                    windows++;\n+                }\n+            }\n+            if (alpha == windows) {\n+                result \/= 3.0;\n+            } else {\n+                result = (result + alpha) \/ 4.0;\n+            }\n+            return result \/ (double) windows;\n+        }\n+\n+        private static double[] vec(double... v) {\n+            if (v.length == 0) {\n+                return new double[4];\n+            } else if (v.length == 1) {\n+                return new double[] {v[0],v[0],v[0],v[0]};\n+            } else {\n+                return v;\n+            }\n+        }\n+        private static double[] vec(int color) {\n+            return vec(color & 0xff, (color >> 8) & 0xff, (color >> 16) & 0xff, (color >> 24) & 0xff);\n+        }\n+\n+        interface Op {  double apply(double a, double b); }\n+        private static double[] apply(Op op, double[] a, double... b) {\n+            b = vec(b);\n+            double[] r = new double[4];\n+            for (int i = 0; i < 4; i++) r[i] = op.apply(a[i], b[i]);\n+            return r;\n+        }\n+\n+        private static double[] add(double[] a, double... b) { return apply((i, j) -> i + j, a, b); }\n+        private static double[] sub(double[] a, double... b) { return apply((i, j) -> i - j, a, b); }\n+        private static double[] mul(double[] a, double... b) { return apply((i, j) -> i * j, a, b); }\n+        private static double[] div(double[] a, double... b) { return apply((i, j) -> i \/ j, a, b); }\n+    }\n+\n+    private static void requireFont(String macOS, String windows, String linux) {\n+        String os = System.getProperty(\"os.name\").toLowerCase();\n+        String font;\n+        if (os.contains(\"mac\")) {\n+            font = macOS;\n+        } else if (os.contains(\"windows\")) {\n+            font = windows;\n+        } else if (os.contains(\"linux\")) {\n+            font = linux;\n+        } else {\n+            return;\n+        }\n+        String[] fs = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n+        if (Stream.of(fs).noneMatch(s -> s.equals(font))) {\n+            System.err.println(\"Required font not found: \" + font);\n+            System.exit(0);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/font\/Emoji\/OutlineTextRendererEmoji.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -67,2 +67,2 @@\n-            PhysicalFont pf = ((CompositeFont)f2d).getSlotFont(0);\n-            fullName = pf.getFontName(Locale.ENGLISH);\n+            Font2D slot = ((CompositeFont)f2d).getSlotFont(0);\n+            fullName = slot.getFontName(Locale.ENGLISH);\n","filename":"test\/jdk\/java\/awt\/font\/FontNames\/FCCompositeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright 2021 JetBrains s.r.o.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key headful\n- * @bug 8263583\n- * @summary Checks that emoji character has a non-empty and identical\n- *          representation when rendered to different types of images,\n- *          including an accelerated (OpenGL or Metal) surface.\n- * @requires (os.family == \"mac\")\n- * @run main\/othervm -Dsun.java2d.uiScale=1 MacEmoji\n- *\/\n-\n-import java.awt.*;\n-import java.awt.image.BufferedImage;\n-import java.awt.image.VolatileImage;\n-import java.util.List;\n-\n-public class MacEmoji {\n-    private static final int IMG_WIDTH = 20;\n-    private static final int IMG_HEIGHT = 20;\n-\n-    public static void main(String[] args) {\n-        GraphicsConfiguration cfg\n-                = GraphicsEnvironment.getLocalGraphicsEnvironment()\n-                .getDefaultScreenDevice().getDefaultConfiguration();\n-\n-        VolatileImage vImg = cfg.createCompatibleVolatileImage(IMG_WIDTH,\n-                                                               IMG_HEIGHT);\n-        BufferedImage refImg;\n-        int attempt = 0;\n-        do {\n-            if (++attempt > 10) {\n-                throw new RuntimeException(\"Failed to render to VolatileImage\");\n-            }\n-            if (vImg.validate(cfg) == VolatileImage.IMAGE_INCOMPATIBLE) {\n-                throw new RuntimeException(\"Unexpected validation failure\");\n-            }\n-            drawEmoji(vImg);\n-            refImg = vImg.getSnapshot();\n-        } while (vImg.contentsLost());\n-\n-        boolean rendered = false;\n-        for (int x = 0; x < IMG_WIDTH; x++) {\n-            for (int y = 0; y < IMG_HEIGHT; y++) {\n-                if (refImg.getRGB(x, y) != 0xFFFFFFFF) {\n-                    rendered = true;\n-                    break;\n-                }\n-            }\n-        }\n-        if (!rendered) {\n-            throw new RuntimeException(\"Emoji character wasn't rendered\");\n-        }\n-\n-        List<Integer> imageTypes = List.of(\n-                BufferedImage.TYPE_INT_RGB,\n-                BufferedImage.TYPE_INT_ARGB,\n-                BufferedImage.TYPE_INT_ARGB_PRE,\n-                BufferedImage.TYPE_INT_BGR,\n-                BufferedImage.TYPE_3BYTE_BGR,\n-                BufferedImage.TYPE_4BYTE_ABGR,\n-                BufferedImage.TYPE_4BYTE_ABGR_PRE\n-        );\n-        for (Integer type : imageTypes) {\n-            BufferedImage img = new BufferedImage(IMG_WIDTH, IMG_HEIGHT, type);\n-            drawEmoji(img);\n-            for (int x = 0; x < IMG_WIDTH; x++) {\n-                for (int y = 0; y < IMG_HEIGHT; y++) {\n-                    if (refImg.getRGB(x, y) != img.getRGB(x, y)) {\n-                        throw new RuntimeException(\n-                                \"Rendering differs for image type \" + type);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    private static void drawEmoji(Image img) {\n-        Graphics g = img.getGraphics();\n-        g.setColor(Color.white);\n-        g.fillRect(0, 0, IMG_WIDTH, IMG_HEIGHT);\n-        g.setFont(new Font(Font.DIALOG, Font.PLAIN, 12));\n-        g.drawString(\"\\uD83D\\uDE00\" \/* U+1F600 'GRINNING FACE' *\/, 2, 15);\n-        g.dispose();\n-    }\n-}\n","filename":"test\/jdk\/java\/awt\/font\/MacEmoji.java","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"}]}