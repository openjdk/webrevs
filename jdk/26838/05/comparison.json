{"files":[{"patch":"@@ -2394,12 +2394,1 @@\n-  __ fmv_x_w(dst, src);\n-\n-  \/\/ preserve the payloads of non-canonical NaNs.\n-  __ srai(dst, dst, 13);\n-  \/\/ preserve the sign bit.\n-  __ srai(tmp, dst, 13);\n-  __ slli(tmp, tmp, 10);\n-  __ mv(t0, 0x3ff);\n-  __ orr(tmp, tmp, t0);\n-\n-  \/\/ get the result by merging sign bit and payloads of preserved non-canonical NaNs.\n-  __ andr(dst, dst, tmp);\n+  __ float_to_float16_NaN(dst, src, t0, tmp);\n@@ -2413,1 +2402,1 @@\n-  auto stub = C2CodeStub::make<Register, FloatRegister, Register>(dst, src, xtmp, 130, float_to_float16_slow_path);\n+  auto stub = C2CodeStub::make<Register, FloatRegister, Register>(dst, src, xtmp, 64, float_to_float16_slow_path);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -5957,0 +5957,56 @@\n+\/\/ Helper routine processing the slow path of NaN when converting float to float16\n+void MacroAssembler::float_to_float16_NaN(Register dst, FloatRegister src,\n+                                          Register tmp1, Register tmp2) {\n+  fmv_x_w(dst, src);\n+\n+  \/\/  Float (32 bits)\n+  \/\/    Bit:     31        30 to 23          22 to 0\n+  \/\/          +---+------------------+-----------------------------+\n+  \/\/          | S |     Exponent     |      Mantissa (Fraction)    |\n+  \/\/          +---+------------------+-----------------------------+\n+  \/\/          1 bit       8 bits                  23 bits\n+  \/\/\n+  \/\/  Float (16 bits)\n+  \/\/    Bit:    15        14 to 10         9 to 0\n+  \/\/          +---+----------------+------------------+\n+  \/\/          | S |    Exponent    |     Mantissa     |\n+  \/\/          +---+----------------+------------------+\n+  \/\/          1 bit      5 bits          10 bits\n+  const int fp_sign_bits = 1;\n+  const int fp32_bits = 32;\n+  const int fp32_exponent_bits = 8;\n+  const int fp32_mantissa_1st_part_bits = 10;\n+  const int fp32_mantissa_2nd_part_bits = 9;\n+  const int fp32_mantissa_3rd_part_bits = 4;\n+  const int fp16_exponent_bits = 5;\n+  const int fp16_mantissa_bits = 10;\n+\n+  \/\/ preserve the sign bit and exponent, clear mantissa.\n+  srai(tmp2, dst, fp32_bits - fp_sign_bits - fp16_exponent_bits);\n+  slli(tmp2, tmp2, fp16_mantissa_bits);\n+\n+  \/\/ Preserve high order bit of float NaN in the\n+  \/\/ binary16 result NaN (tenth bit); OR in remaining\n+  \/\/ bits into lower 9 bits of binary 16 significand.\n+  \/\/   | (doppel & 0x007f_e000) >> 13 \/\/ 10 bits\n+  \/\/   | (doppel & 0x0000_1ff0) >> 4  \/\/  9 bits\n+  \/\/   | (doppel & 0x0000_000f));     \/\/  4 bits\n+  \/\/\n+  \/\/ Check j.l.Float.floatToFloat16 for more information.\n+  \/\/ 10 bits\n+  int left_shift = fp_sign_bits + fp32_exponent_bits + 32;\n+  int right_shift = left_shift + fp32_mantissa_2nd_part_bits + fp32_mantissa_3rd_part_bits;\n+  slli(tmp1, dst, left_shift);\n+  srli(tmp1, tmp1, right_shift);\n+  orr(tmp2, tmp2, tmp1);\n+  \/\/ 9 bits\n+  left_shift += fp32_mantissa_1st_part_bits;\n+  right_shift = left_shift + fp32_mantissa_3rd_part_bits;\n+  slli(tmp1, dst, left_shift);\n+  srli(tmp1, tmp1, right_shift);\n+  orr(tmp2, tmp2, tmp1);\n+  \/\/ 4 bits\n+  andi(tmp1, dst, 0xf);\n+  orr(dst, tmp2, tmp1);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":56,"deletions":0,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -1434,0 +1434,3 @@\n+  \/\/ Helper routine processing the slow path of NaN when converting float to float16\n+  void float_to_float16_NaN(Register dst, FloatRegister src, Register tmp1, Register tmp2);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -8557,1 +8557,1 @@\n-  format %{ \"fmv.h.x $dst, $src\" %}\n+  format %{ \"fmv.h.x $dst, $src\\t# reinterpretS2HF\" %}\n@@ -8577,1 +8577,1 @@\n-  format %{ \"fmv.x.h $dst, $src\" %}\n+  format %{ \"fmv.x.h $dst, $src\\t# reinterpretHF2S\" %}\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6360,12 +6360,2 @@\n-    __ fmv_x_w(dst, src);\n-\n-    \/\/ preserve the payloads of non-canonical NaNs.\n-    __ srai(dst, dst, 13);\n-    \/\/ preserve the sign bit.\n-    __ srai(t1, dst, 13);\n-    __ slli(t1, t1, 10);\n-    __ mv(t0, 0x3ff);\n-    __ orr(t1, t1, t0);\n-\n-    \/\/ get the result by merging sign bit and payloads of preserved non-canonical NaNs.\n-    __ andr(dst, dst, t1);\n+\n+    __ float_to_float16_NaN(dst, src, t0, t1);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8365206\n+ * @summary Verify NaN sign and significand bits are preserved across conversions,\n+ *          float -> float16 -> float\n+ * @requires (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zfh.*\")\n+ * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @library \/test\/lib \/\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xmixed -XX:-BackgroundCompilation -XX:-UseOnStackReplacement\n+ *                   -XX:CompileThresholdScaling=1000.0 Binary16ConversionNaN_2\n+ *\/\n+\n+\/*\n+ * The behavior tested below is an implementation property not\n+ * required by the specification. It would be acceptable for this\n+ * information to not be preserved (as long as a NaN is returned) if,\n+ * say, a intrinsified version using native hardware instructions\n+ * behaved differently.\n+ *\n+ * If that is the case, this test should be modified to disable\n+ * intrinsics or to otherwise not run on platforms with an differently\n+ * behaving intrinsic.\n+ *\/\n+\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import jdk.test.whitebox.WhiteBox;\n+import java.lang.reflect.Method;\n+import java.util.Random;\n+\n+public class Binary16ConversionNaN_2 {\n+\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    \/*\n+     * Put all 16-bit NaN values through a conversion loop and make\n+     * sure the significand, sign, and exponent are all preserved.\n+     *\/\n+    public static void main(String... argv) throws NoSuchMethodException {\n+        int errors = 0;\n+        final int NAN_EXPONENT = 0x7f80_0000;\n+        final int SIGN_BIT     = 0x8000_0000;\n+\n+        \/\/ First, run with Interpreter only to  collect \"gold\" data.\n+        \/\/ Glags -Xmixed -XX:CompileThresholdScaling=1000.0 are used\n+        \/\/ to prevent compilation during this phase.\n+        float[] pVal = new float[1024];\n+        float[] pRes = new float[1024];\n+        float[] nVal = new float[1024];\n+        float[] nRes = new float[1024];\n+\n+        Random rand = new Random();\n+\n+        \/\/ A NaN has a nonzero significand\n+        for (int i = 1; i <= 0x3ff; i++) {\n+            int shift = rand.nextInt(13+1);\n+            int binaryNaN = (NAN_EXPONENT | (i << shift));\n+            assert isNaN(binaryNaN);\n+            \/\/ the payloads of non-canonical NaNs are preserved.\n+            float f1 = Float.intBitsToFloat(binaryNaN);\n+            float f2 = testRoundTrip(f1);\n+            errors  += verify(f1, f2);\n+            pVal[i] = f1;\n+            pRes[i] = f2;\n+\n+            int binaryNegNaN = (SIGN_BIT | binaryNaN);\n+            float f3 = Float.intBitsToFloat(binaryNegNaN);\n+            float f4 = testRoundTrip(f3);\n+            errors  += verify(f3, f4);\n+            nVal[i] = f3;\n+            nRes[i] = f4;\n+        }\n+        if (errors > 0) { \/\/ Exit if Interpreter failed\n+            throw new RuntimeException(errors + \" errors\");\n+        }\n+\n+        Method test_method = Binary16ConversionNaN_2.class.getDeclaredMethod(\"testRoundTrip\", float.class);\n+\n+        \/\/ Compile with C1 and compare results\n+        WHITE_BOX.enqueueMethodForCompilation(test_method, CompilerWhiteBoxTest.COMP_LEVEL_SIMPLE);\n+        if (!WHITE_BOX.isMethodCompiled(test_method)) {\n+            throw new RuntimeException(\"test is not compiled by C1\");\n+        }\n+        for (int i = 1; i <= 0x3ff; i++) {\n+            float f1 = testRoundTrip(pVal[i]);\n+            errors  += verifyCompiler(pRes[i], f1, \"C1\");\n+            float f2 = testRoundTrip(nVal[i]);\n+            errors  += verifyCompiler(nRes[i], f2, \"C1\");\n+        }\n+\n+        WHITE_BOX.deoptimizeMethod(test_method);\n+\n+        \/\/ Compile with C2 and compare results\n+        WHITE_BOX.enqueueMethodForCompilation(test_method, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+        if (!WHITE_BOX.isMethodCompiled(test_method)) {\n+            throw new RuntimeException(\"test is not compiled by C2\");\n+        }\n+        for (int i = 1; i <= 0x3ff; i++) {\n+            float f1 = testRoundTrip(pVal[i]);\n+            errors  += verifyCompiler(pRes[i], f1, \"C2\");\n+            float f2 = testRoundTrip(nVal[i]);\n+            errors  += verifyCompiler(nRes[i], f2, \"C2\");\n+        }\n+\n+        if (errors > 0) {\n+            throw new RuntimeException(errors + \" errors\");\n+        }\n+    }\n+\n+    private static boolean isNaN(int binary) {\n+        return ((binary & 0x7f80_0000) == 0x7f80_0000) \/\/ Max exponent and...\n+            && ((binary & 0x007f_ffff) != 0 );         \/\/ significand nonzero.\n+    }\n+\n+    private static float testRoundTrip(float f) {\n+        short s = Float.floatToFloat16(f);\n+        return Float.float16ToFloat(s);\n+    }\n+\n+    private static int verify(float f1, float f2) {\n+        int errors = 0;\n+        int i1 = Float.floatToRawIntBits(f1);\n+        int i2 = Float.floatToRawIntBits(f2);\n+        assert Float.isNaN(f1);\n+        if (!Float.isNaN(f2) ||\n+            ((i1 & 0x8000_0000) != (i2 & 0x8000_0000))) {\n+            errors++;\n+            System.out.println(\"Roundtrip failure on NaN value \" +\n+                               Integer.toHexString(i1) +\n+                               \"\\t got back \" + Integer.toHexString(i2));\n+        }\n+        return errors;\n+    }\n+\n+    private static int verifyCompiler(float f1, float f2, String name) {\n+        int errors = 0;\n+        int i1 = Float.floatToRawIntBits(f1);\n+        int i2 = Float.floatToRawIntBits(f2);\n+        assert Float.isNaN(f1);\n+        if (!Float.isNaN(f2) ||\n+            ((i1 & 0x8000_0000) != (i2 & 0x8000_0000))) {\n+            errors++;\n+            System.out.println(\"Roundtrip failure on NaN value \" +\n+                               Integer.toHexString(i1) +\n+                               \"\\t got back \" + Integer.toHexString(i2) +\n+                               \"\\t from \" + name + \" code\");\n+        }\n+        return errors;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/Binary16ConversionNaN_2.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"}]}