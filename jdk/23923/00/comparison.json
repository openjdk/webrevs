{"files":[{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import static java.util.stream.Collectors.joining;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Class to replace tokens in strings.\n+ * <p>\n+ * Single instance holds a list of tokens. Tokens can be substrings of each other.\n+ * The implementation performs greedy replacement: longer tokens are replaced first.\n+ *\/\n+public final class TokenReplace {\n+\n+    private record TokenCut(String[] main, String[] sub) {\n+        static String[] orderTokens(String... tokens) {\n+            if (tokens.length == 0) {\n+                throw new IllegalArgumentException(\"Empty token list\");\n+            }\n+\n+            final var orderedTokens = Stream.of(tokens)\n+                    .sorted(Comparator.<String>naturalOrder().thenComparing(Comparator.comparingInt(String::length)))\n+                    .distinct()\n+                    .toArray(String[]::new);\n+\n+            if (orderedTokens[0].isEmpty()) {\n+                throw new IllegalArgumentException(\"Empty token in the list of tokens\");\n+            }\n+\n+            return orderedTokens;\n+        }\n+\n+        static TokenCut createFromOrderedTokens(String... tokens) {\n+            final List<Integer> subTokens = new ArrayList<>();\n+\n+            for (var i = 0; i < tokens.length - 1; ++i) {\n+                final var x = tokens[i];\n+                for (var j = i + 1; j < tokens.length; ++j) {\n+                    final var y = tokens[j];\n+                    if (y.contains(x)) {\n+                        subTokens.add(i);\n+                    }\n+                }\n+            }\n+\n+            if (subTokens.isEmpty()) {\n+                return new TokenCut(tokens, null);\n+            } else {\n+                final var main = IntStream.range(0, tokens.length)\n+                        .mapToObj(Integer::valueOf)\n+                        .filter(Predicate.not(subTokens::contains))\n+                        .map(i -> {\n+                            return tokens[i];\n+                        }).toArray(String[]::new);\n+                final var sub = subTokens.stream().map(i -> {\n+                    return tokens[i];\n+                }).toArray(String[]::new);\n+                return new TokenCut(main, sub);\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"TokenCut(main=%s, sub=%s)\", Arrays.toString(main), Arrays.toString(sub));\n+        }\n+    }\n+\n+    public TokenReplace(String... tokens) {\n+        tokens = TokenCut.orderTokens(tokens);\n+\n+        this.tokens = tokens;\n+        regexps = new ArrayList<>();\n+\n+        for(;;) {\n+            final var tokenCut = TokenCut.createFromOrderedTokens(tokens);\n+            regexps.add(Pattern.compile(Stream.of(tokenCut.main()).map(Pattern::quote).collect(joining(\"|\", \"(\", \")\"))));\n+\n+            if (tokenCut.sub() == null) {\n+                break;\n+            }\n+\n+            tokens = tokenCut.sub();\n+        }\n+    }\n+\n+    public String applyTo(String str, Function<String, Object> tokenValueSupplier) {\n+        Objects.requireNonNull(str);\n+        Objects.requireNonNull(tokenValueSupplier);\n+        for (final var regexp : regexps) {\n+            str = regexp.matcher(str).replaceAll(mr -> {\n+                final var token = mr.group();\n+                return Matcher.quoteReplacement(Objects.requireNonNull(tokenValueSupplier.apply(token), () -> {\n+                    return String.format(\"Null value for token [%s]\", token);\n+                }).toString());\n+            });\n+        }\n+        return str;\n+    }\n+\n+    public String recursiveApplyTo(String str, Function<String, Object> tokenValueSupplier) {\n+        String newStr;\n+        int counter = tokens.length + 1;\n+        while (!(newStr = applyTo(str, tokenValueSupplier)).equals(str)) {\n+            str = newStr;\n+            if (counter-- == 0) {\n+                throw new IllegalStateException(\"Infinite recursion\");\n+            }\n+        }\n+        return newStr;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        \/\/ Auto generated code\n+        final int prime = 31;\n+        int result = 1;\n+        result = prime * result + Arrays.hashCode(tokens);\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        \/\/ Auto generated code\n+        if (this == obj) {\n+            return true;\n+        }\n+        if ((obj == null) || (getClass() != obj.getClass())) {\n+            return false;\n+        }\n+        TokenReplace other = (TokenReplace) obj;\n+        return Arrays.equals(tokens, other.tokens);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"TokenReplace(\" + String.join(\"|\", tokens) + \")\";\n+    }\n+\n+    public static TokenReplace combine(TokenReplace x, TokenReplace y) {\n+        return new TokenReplace(Stream.of(x.tokens, y.tokens).flatMap(Stream::of).toArray(String[]::new));\n+    }\n+\n+    public static Function<String, Object> createCachingTokenValueSupplier(Map<String, Supplier<Object>> tokenValueSuppliers) {\n+        Objects.requireNonNull(tokenValueSuppliers);\n+        final Map<String, Object> cache = new HashMap<>();\n+        return token -> {\n+            final var value = cache.computeIfAbsent(token, k -> {\n+                final var tokenValueSupplier = Objects.requireNonNull(tokenValueSuppliers.get(token), () -> {\n+                    return String.format(\"No token value supplier for token [%s]\", token);\n+                });\n+                return Optional.ofNullable(tokenValueSupplier.get()).orElse(NULL_SUPPLIED);\n+            });\n+\n+            if (value == NULL_SUPPLIED) {\n+                throw new NullPointerException(String.format(\"Null value for token [%s]\", token));\n+            }\n+\n+            return value;\n+        };\n+    }\n+\n+    private final String[] tokens;\n+    private final transient List<Pattern> regexps;\n+    private final static Object NULL_SUPPLIED = new Object();\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/TokenReplace.java","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -167,3 +167,3 @@\n-    macros[_T(\"$APPDIR\")] = appDirPath;\n-    macros[_T(\"$BINDIR\")] = FileUtils::dirname(launcherPath);\n-    macros[_T(\"$ROOTDIR\")] = imageRoot;\n+    macros[_T(\"APPDIR\")] = appDirPath;\n+    macros[_T(\"BINDIR\")] = FileUtils::dirname(launcherPath);\n+    macros[_T(\"ROOTDIR\")] = imageRoot;\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/AppLauncher.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include <set>\n@@ -31,0 +32,1 @@\n+#include \"SysInfo.h\"\n@@ -35,0 +37,1 @@\n+#include \"StringProcessing.h\"\n@@ -63,6 +66,8 @@\n-tstring expandMacros(const tstring& str, const CfgFile::Macros& macros) {\n-    tstring reply = str;\n-    CfgFile::Macros::const_iterator it = macros.begin();\n-    const CfgFile::Macros::const_iterator end = macros.end();\n-    for (; it != end; ++it) {\n-        reply = tstrings::replace(reply, it->first, it->second);\n+template <typename CfgFileType, typename OpType>\n+void iterateProperties(CfgFileType& cfgFile, OpType& op) {\n+    for (auto mapIt = cfgFile.begin(), mapEnd = cfgFile.end(); mapIt != mapEnd; ++mapIt) {\n+        for (auto propertyIt = mapIt->second.begin(), propertyEnd = mapIt->second.end(); propertyIt != propertyEnd; ++propertyIt) {\n+            for (auto strIt = propertyIt->second.begin(), strEnd = propertyIt->second.end(); strIt != strEnd; ++strIt) {\n+                op(strIt);\n+            }\n+        }\n@@ -70,1 +75,0 @@\n-    return reply;\n@@ -73,0 +77,40 @@\n+struct tokenize_strings {\n+    void operator () (tstring_array::const_iterator& strIt) {\n+        const auto tokens = StringProcessing::tokenize(*strIt);\n+        values.push_back(tokens);\n+    }\n+\n+    std::set<tstring> variableNames() const {\n+        std::set<tstring> allVariableNames;\n+        for (auto it = values.begin(), end = values.end(); it != end; ++it) {\n+            const auto variableNames = StringProcessing::extractVariableNames(*it);\n+            allVariableNames.insert(variableNames.begin(), variableNames.end());\n+        }\n+\n+        return allVariableNames;\n+    }\n+\n+    std::vector<StringProcessing::TokenizedString> values;\n+};\n+\n+class expand_macros {\n+public:\n+    expand_macros(const CfgFile::Macros& m,\n+        std::vector<StringProcessing::TokenizedString>::iterator iter) : macros(m), curTokenizedString(iter) {\n+    }\n+\n+    void operator () (tstring_array::iterator& strIt) {\n+        StringProcessing::expandVariables(*curTokenizedString, macros);\n+        auto newStr = StringProcessing::stringify(*curTokenizedString);\n+        ++curTokenizedString;\n+        if (*strIt != newStr) {\n+            LOG_TRACE(tstrings::any() << \"Map [\" << *strIt << \"] into [\" << newStr << \"]\");\n+        }\n+        strIt->swap(newStr);\n+    }\n+\n+private:\n+    const CfgFile::Macros& macros;\n+    std::vector<StringProcessing::TokenizedString>::iterator curTokenizedString;\n+};\n+\n@@ -78,13 +122,13 @@\n-    PropertyMap::iterator mapIt = copyCfgFile.data.begin();\n-    const PropertyMap::iterator mapEnd = copyCfgFile.data.end();\n-    for (; mapIt != mapEnd; ++mapIt) {\n-        Properties::iterator propertyIt = mapIt->second.begin();\n-        const Properties::iterator propertyEnd = mapIt->second.end();\n-        for (; propertyIt != propertyEnd; ++propertyIt) {\n-            tstring_array::iterator strIt = propertyIt->second.begin();\n-            const tstring_array::iterator strEnd = propertyIt->second.end();\n-            for (; strIt != strEnd; ++strIt) {\n-                tstring newValue;\n-                while ((newValue = ::expandMacros(*strIt, macros)) != *strIt) {\n-                    strIt->swap(newValue);\n-                }\n+    tokenize_strings tokenizedStrings;\n+    iterateProperties(static_cast<const CfgFile::PropertyMap&>(copyCfgFile.data), tokenizedStrings);\n+\n+    Macros allMacros(macros);\n+\n+    const auto variableNames = tokenizedStrings.variableNames();\n+    for (auto it = variableNames.begin(), end = variableNames.end(); it != end; ++it) {\n+        if (macros.find(*it) == macros.end()) {\n+            \/\/ Not one of the reserved macro names. Assuming an environment variable.\n+            const auto envVarName = *it;\n+            if (SysInfo::isEnvVariableSet(envVarName)) {\n+                const auto envVarValue = SysInfo::getEnvVariable(envVarName);\n+                allMacros[envVarName] = envVarValue;\n@@ -95,0 +139,3 @@\n+    expand_macros expandMacros(allMacros, tokenizedStrings.values.begin());\n+    iterateProperties(copyCfgFile.data, expandMacros);\n+\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/CfgFile.cpp","additions":68,"deletions":21,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,1 +96,1 @@\n-     * Returns copy of this instance with the given macros expanded.\n+     * Returns copy of this instance with the given macros and environment variables expanded.\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/CfgFile.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"kludge_c++11.h\"\n+\n+#include <algorithm>\n+#include \"StringProcessing.h\"\n+\n+\n+namespace StringProcessing {\n+\n+namespace {\n+\n+class TokenBuilder {\n+public:\n+    TokenBuilder(const tstring& v): cur(v.c_str()) {\n+    }\n+\n+    void addNextToken(tstring::const_pointer end, TokenType type, TokenizedString& tokens) {\n+        if (end != cur) {\n+            const auto value = tstring(cur, end - cur);\n+            cur = end;\n+            tokens.push_back(Token(type, value));\n+        }\n+    }\n+\n+private:\n+    tstring::const_pointer cur;\n+};\n+\n+bool isValidVariableFirstChar(tstring::value_type chr) {\n+    if ('A' <= chr && chr <= 'Z') {\n+        return true;\n+    } else if ('a' <= chr && chr <= 'z') {\n+        return true;\n+    } else if ('_' == chr) {\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+bool isValidVariableOtherChar(tstring::value_type chr) {\n+    if (isValidVariableFirstChar(chr)) {\n+        return true;\n+    } else if ('0' <= chr && chr <= '9') {\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+} \/\/  namespace\n+\n+TokenizedString tokenize(const tstring& str) {\n+    TokenizedString tokens;\n+    TokenBuilder tb(str);\n+    tstring::const_pointer cur = str.c_str();\n+    const tstring::const_pointer end = cur + str.length();\n+    while (cur != end) {\n+        if (*cur == '\\\\' && cur + 1 != end) {\n+            const auto maybeNextToken = cur++;\n+            if (*cur == '\\\\' || *cur == '$') {\n+                tb.addNextToken(maybeNextToken, STRING, tokens);\n+                tb.addNextToken(++cur, ESCAPED_CHAR, tokens);\n+                continue;\n+            }\n+        } else if (*cur == '$' && cur + 1 != end) {\n+            const auto maybeNextToken = cur++;\n+            bool variableFound = false;\n+            if (*cur == '{') {\n+                do {\n+                    cur++;\n+                } while (cur != end && *cur != '}');\n+                if (cur != end) {\n+                    variableFound = true;\n+                    cur++;\n+                }\n+            } else if (isValidVariableFirstChar(*cur)) {\n+                variableFound = true;\n+                do {\n+                    cur++;\n+                } while (cur != end && isValidVariableOtherChar(*cur));\n+            } else {\n+                continue;\n+            }\n+            if (variableFound) {\n+                tb.addNextToken(maybeNextToken, STRING, tokens);\n+                tb.addNextToken(cur, VARIABLE, tokens);\n+            }\n+        } else {\n+            ++cur;\n+        }\n+    }\n+    tb.addNextToken(cur, STRING, tokens);\n+    return tokens;\n+}\n+\n+\n+tstring stringify(const TokenizedString& tokens) {\n+    tstringstream ss;\n+    TokenizedString::const_iterator it = tokens.begin();\n+    const TokenizedString::const_iterator end = tokens.end();\n+    for (; it != end; ++it) {\n+        if (it->type() == ESCAPED_CHAR) {\n+            ss << it->value().substr(1);\n+        }\n+        else {\n+            ss << it->value();\n+        }\n+    }\n+    return ss.str();\n+}\n+\n+\n+namespace {\n+\n+tstring getVariableName(const tstring& str) {\n+    if (tstrings::endsWith(str, _T(\"}\"))) {\n+        \/\/ ${VAR}\n+        return str.substr(2, str.length() - 3);\n+    } else {\n+        \/\/ $VAR\n+        return str.substr(1);\n+    }\n+}\n+\n+} \/\/ namespace\n+\n+VariableNameList extractVariableNames(const TokenizedString& tokens) {\n+    VariableNameList reply;\n+\n+    TokenizedString::const_iterator it = tokens.begin();\n+    const TokenizedString::const_iterator end = tokens.end();\n+    for (; it != end; ++it) {\n+        if (it->type() == VARIABLE) {\n+            reply.push_back(getVariableName(it->value()));\n+        }\n+    }\n+\n+    std::sort(reply.begin(), reply.end());\n+    reply.erase(std::unique(reply.begin(), reply.end()), reply.end());\n+    return reply;\n+}\n+\n+\n+void expandVariables(TokenizedString& tokens, const VariableValues& variableValues) {\n+    TokenizedString::iterator it = tokens.begin();\n+    const TokenizedString::iterator end = tokens.end();\n+    for (; it != end; ++it) {\n+        if (it->type() == VARIABLE) {\n+            const auto entry = variableValues.find(getVariableName(it->value()));\n+            if (entry != variableValues.end()) {\n+                auto newToken = Token(STRING, entry->second);\n+                std::swap(*it, newToken);\n+            }\n+        }\n+    }\n+}\n+\n+} \/\/ namespace StringProcessing\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/StringProcessing.cpp","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+#ifndef StringProcessor_h\n+#define StringProcessor_h\n+\n+#include <map>\n+#include \"tstrings.h\"\n+\n+\n+namespace StringProcessing {\n+\n+enum TokenType {\n+    STRING,\n+    VARIABLE,\n+    ESCAPED_CHAR\n+};\n+\n+class Token {\n+public:\n+    Token(TokenType type, const tstring& str): theType(type), theStr(str) {\n+    }\n+\n+    TokenType type() const {\n+        return theType;\n+    }\n+\n+    const tstring& value() const {\n+        return theStr;\n+    }\n+\n+private:\n+    TokenType theType;\n+    tstring theStr;\n+};\n+\n+typedef std::vector<Token> TokenizedString;\n+typedef std::vector<tstring> VariableNameList;\n+typedef std::map<tstring, tstring> VariableValues;\n+\n+TokenizedString tokenize(const tstring& str);\n+\n+tstring stringify(const TokenizedString& tokens);\n+\n+VariableNameList extractVariableNames(const TokenizedString& tokens);\n+\n+void expandVariables(TokenizedString& tokens, const VariableValues& variableValues);\n+\n+} \/\/ namespace StringProcessing\n+\n+#endif \/\/ StringProcessor_h\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/StringProcessing.h","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -25,0 +25,3 @@\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+\n@@ -38,1 +41,0 @@\n-import java.util.stream.Collectors;\n@@ -40,1 +42,0 @@\n-import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n@@ -42,1 +43,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n@@ -396,5 +396,3 @@\n-            }).collect(\n-                    Collectors.toMap(tokens -> tokens[0], tokens -> tokens[1],\n-                            (oldValue, newValue) -> {\n-                                return newValue;\n-                            }));\n+            }).collect(toMap(tokens -> tokens[0], tokens -> tokens[1], (oldValue, newValue) -> {\n+                return newValue;\n+            }));\n@@ -422,5 +420,3 @@\n-        var map = Map.of(\n-                \"$APPDIR\", cmd.appLayout().appDirectory(),\n-                \"$ROOTDIR\",\n-                cmd.isImagePackageType() ? cmd.outputBundle() : cmd.appInstallationDirectory(),\n-                \"$BINDIR\", cmd.appLayout().launchersDirectory());\n+        var map = Stream.of(JPackageCommand.Macro.values()).collect(toMap(x -> {\n+            return String.format(\"$%s\", x.name());\n+        }, cmd::macroValue));\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/AdditionalLauncher.java","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.HashMap;\n@@ -38,0 +39,1 @@\n+import java.util.Map;\n@@ -95,0 +97,7 @@\n+        setEnvVars.remove(envVarName);\n+        return this;\n+    }\n+\n+    public Executor setEnvVar(String envVarName, String envVarValue) {\n+        setEnvVars.put(Objects.requireNonNull(envVarName), Objects.requireNonNull(envVarValue));\n+        removeEnvVars.remove(envVarName);\n@@ -373,0 +382,15 @@\n+        if (!setEnvVars.isEmpty()) {\n+            final var defaultEnv = builder.environment();\n+            final var envComm = Comm.compare(defaultEnv.keySet(), setEnvVars.keySet());\n+            envComm.unique2().forEach(envVar -> {\n+                TKit.trace(String.format(\"Adding %s=[%s] to environment\", envVar, setEnvVars.get(envVar)));\n+            });\n+            envComm.common().forEach(envVar -> {\n+                final var curValue = defaultEnv.get(envVar);\n+                final var newValue = setEnvVars.get(envVar);\n+                if (!curValue.equals(newValue)) {\n+                    TKit.trace(String.format(\"Setting %s=[%s] in environment\", envVar, setEnvVars.get(envVar)));\n+                }\n+            });\n+            defaultEnv.putAll(setEnvVars);\n+        }\n@@ -374,2 +398,3 @@\n-            final var envComm = Comm.compare(builder.environment().keySet(), removeEnvVars);\n-            builder.environment().keySet().removeAll(envComm.common());\n+            final var defaultEnv = builder.environment().keySet();\n+            final var envComm = Comm.compare(defaultEnv, removeEnvVars);\n+            defaultEnv.removeAll(envComm.common());\n@@ -518,0 +543,1 @@\n+    private Map<String, String> setEnvVars = new HashMap<>();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Executor.java","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -830,0 +830,26 @@\n+    public static enum Macro {\n+        APPDIR(cmd -> {\n+            return cmd.appLayout().appDirectory().toString();\n+        }),\n+        BINDIR(cmd -> {\n+            return cmd.appLayout().launchersDirectory().toString();\n+        }),\n+        ROOTDIR(cmd -> {\n+            return (cmd.isImagePackageType() ? cmd.outputBundle() : cmd.appInstallationDirectory()).toString();\n+        });\n+\n+        private Macro(Function<JPackageCommand, String> getValue) {\n+            this.getValue = Objects.requireNonNull(getValue);\n+        }\n+\n+        String value(JPackageCommand cmd) {\n+            return getValue.apply(cmd);\n+        }\n+\n+        private final Function<JPackageCommand, String> getValue;\n+    }\n+\n+    public String macroValue(Macro macro) {\n+        return macro.value(this);\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,290 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class TokenReplaceTest {\n+\n+    public record TestSpec(String str, Optional<String> expectedStr, Optional<Exception> expectedCtorException,\n+            Optional<Exception> expectedApplyToException, Map<String, String> tokenWithValues, boolean recursive) {\n+\n+        public TestSpec {\n+            Objects.requireNonNull(expectedStr);\n+            Objects.requireNonNull(expectedCtorException);\n+            Objects.requireNonNull(expectedApplyToException);\n+            Objects.requireNonNull(tokenWithValues);\n+            tokenWithValues.values().forEach(Objects::requireNonNull);\n+\n+            if (expectedStr.isPresent()) {\n+                if (!(expectedCtorException.isEmpty() && expectedApplyToException.isEmpty())) {\n+                    throw new IllegalArgumentException();\n+                }\n+            } else if (expectedCtorException.isEmpty() == expectedApplyToException.isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        static final class Builder {\n+\n+            Builder str(String v) {\n+                str = v;\n+                return this;\n+            }\n+\n+            Builder recursive(boolean v) {\n+                recursive = v;\n+                return this;\n+            }\n+\n+            Builder recursive() {\n+                return recursive(true);\n+            }\n+\n+            Builder expect(String v) {\n+                expectedStr = v;\n+                return this;\n+            }\n+\n+            Builder expectCtorThrow(String v) {\n+                expectedCtorException = new IllegalArgumentException(v);\n+                return this;\n+            }\n+\n+            Builder expectApplyToNPE() {\n+                expectedApplyToException = new NullPointerException();\n+                return this;\n+            }\n+\n+            Builder expectInfiniteRecursion() {\n+                expectedApplyToException = new IllegalStateException(\"Infinite recursion\");\n+                return this;\n+            }\n+\n+            Builder token(String token, String value) {\n+                tokenWithValues.put(token, value);\n+                return this;\n+            }\n+\n+            TestSpec create() {\n+                return new TestSpec(str, expectedStr(), Optional.ofNullable(expectedCtorException),\n+                        Optional.ofNullable(expectedApplyToException), tokenWithValues, recursive);\n+            }\n+\n+            private Optional<String> expectedStr() {\n+                if (expectedCtorException == null && expectedApplyToException == null) {\n+                    return Optional.ofNullable(expectedStr).or(() -> Optional.of(str));\n+                } else {\n+                    return Optional.empty();\n+                }\n+            }\n+\n+            private boolean recursive;\n+            private String str;\n+            private String expectedStr;\n+            private Exception expectedCtorException;\n+            private Exception expectedApplyToException;\n+            private final Map<String, String> tokenWithValues = new HashMap<>();\n+        }\n+\n+        void test() {\n+            final var tokens = tokenWithValues.keySet().toArray(String[]::new);\n+            expectedStr.ifPresent(expected -> {\n+                final var tokenReplace = new TokenReplace(tokens);\n+                final String actual;\n+                if (recursive) {\n+                    actual = tokenReplace.recursiveApplyTo(str, tokenWithValues::get);\n+                } else {\n+                    actual = tokenReplace.applyTo(str, tokenWithValues::get);\n+                }\n+                assertEquals(expected, actual);\n+            });\n+\n+            expectedCtorException.ifPresent(expected -> {\n+                final var ex = assertThrows(expected.getClass(), () -> {\n+                    new TokenReplace(tokens);\n+                });\n+                assertEquals(expected.getMessage(), ex.getMessage());\n+            });\n+\n+            expectedApplyToException.ifPresent(expected -> {\n+                final var tokenReplace = new TokenReplace(tokens);\n+                final var ex = assertThrows(expected.getClass(), () -> {\n+                    if (recursive) {\n+                        tokenReplace.recursiveApplyTo(str, tokenWithValues::get);\n+                    } else {\n+                        tokenReplace.applyTo(str, tokenWithValues::get);\n+                    }\n+                });\n+                assertEquals(expected.getMessage(), ex.getMessage());\n+            });\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test(TestSpec spec) {\n+        spec.test();\n+    }\n+\n+    public static Stream<TestSpec> test() {\n+        return Stream.of(\n+                testSpec(\"foo\").token(\"\", \"B\").expectCtorThrow(\"Empty token in the list of tokens\"),\n+                testSpec(\"foo\").expectCtorThrow(\"Empty token list\"),\n+                testSpec(\"a\").expect(\"a\").token(\"b\", \"B\"),\n+                testSpec(\"a\").expect(\"A\").token(\"a\", \"A\"),\n+                testSpec(\"aaa\").expect(\"AAA\").token(\"a\", \"A\"),\n+                testSpec(\"aaa\").recursive().expect(\"{B}{B}{B}\").token(\"a\", \"b\").token(\"b\", \"{B}\"),\n+                testSpec(\"aaa\").token(\"a\", \"aa\").token(\"aa\", \"C\").expect(\"Caa\"),\n+                testSpec(\"aaa\").token(\"a\", \"aa\").token(\"aa\", \"C\").expect(\"CC\").recursive(),\n+                testSpec(\"aaa\").expect(\"A2A\").token(\"a\", \"A\").token(\"aa\", \"A2\"),\n+                testSpec(\"aaa\").token(\"a\", \"b\").token(\"b\", \"c\").token(\"c\", \"a\").expect(\"bbb\"),\n+                testSpec(\"aaa\").token(\"a\", \"b\").token(\"b\", \"\").recursive().expect(\"\"),\n+                testSpec(\"aaa\").token(\"a\", \"\").recursive().expect(\"\"),\n+                testSpec(\"aaa\").token(\"a\", \"b\").token(\"b\", \"c\").token(\"c\", \"a\").expectInfiniteRecursion().recursive(),\n+                testSpec(null).token(\"a\", \"b\").expectApplyToNPE(),\n+                testSpec(\"abc\").expect(\"abc\").token(\".\", \"A\"),\n+                testSpec(\"abc.\").expect(\"abcD\").token(\".\", \"D\")\n+        ).map(TestSpec.Builder::create);\n+    }\n+\n+    private static final class CountingSupplier implements Supplier<Object> {\n+\n+        CountingSupplier(Object value, int expectedCount) {\n+            this.value = value;\n+            this.expectedCount = expectedCount;\n+        }\n+\n+        @Override\n+        public Object get() {\n+            counter++;\n+            return value;\n+        }\n+\n+        public Object value() {\n+            return value;\n+        }\n+\n+        void verifyCount() {\n+            assertEquals(expectedCount, counter);\n+        }\n+\n+        private final Object value;\n+        private int counter;\n+        private final int expectedCount;\n+    }\n+\n+    @Test\n+    public void testCombine() {\n+        final var x = new TokenReplace(\"a\");\n+        final var y = new TokenReplace(\"aa\");\n+\n+        final var xy = TokenReplace.combine(x, y);\n+\n+        assertEquals(xy, new TokenReplace(\"aa\", \"a\"));\n+        assertEquals(xy, new TokenReplace(\"a\", \"aa\"));\n+    }\n+\n+    @Test\n+    public void testCombine2() {\n+        final var x = new TokenReplace(\"a\");\n+        final var y = new TokenReplace(\"a\");\n+\n+        final var xy = TokenReplace.combine(x, y);\n+\n+        assertEquals(xy, new TokenReplace(\"a\", \"a\"));\n+        assertEquals(xy, new TokenReplace(\"a\"));\n+        assertEquals(xy, x);\n+        assertEquals(xy, y);\n+    }\n+\n+    @Test\n+    public void testCombine3() {\n+        final var x = new TokenReplace(\"a\");\n+        final var y = new TokenReplace(\"b\");\n+\n+        final var xy = TokenReplace.combine(x, y);\n+\n+        assertEquals(xy, new TokenReplace(\"a\", \"b\"));\n+        assertEquals(xy, new TokenReplace(\"b\", \"a\"));\n+    }\n+\n+    @Test\n+    public void testEquals() {\n+        final var x = new TokenReplace(\"x\");\n+        final var y = new TokenReplace(\"y\");\n+        final var y2 = new TokenReplace(\"y\");\n+\n+        assertNotEquals(x, y);\n+        assertNotEquals(x, null);\n+        assertNotEquals(null, x);\n+        assertNotEquals(x, \"x\");\n+\n+        assertEquals(y, y2);\n+        assertEquals(y, y);\n+    }\n+\n+    @Test\n+    public void testCreateCachingTokenValueSupplier() {\n+        final var neverCalledSupplier = new CountingSupplier(\"\", 0);\n+        final var calledOnceSupplier = new CountingSupplier(\"foo\", 1);\n+        final var calledOnceNullSupplier = new CountingSupplier(null, 1);\n+\n+        final var supplier = TokenReplace.createCachingTokenValueSupplier(Map.of(\n+                \"never\", neverCalledSupplier,\n+                \"once\", calledOnceSupplier,\n+                \"onceNull\", calledOnceNullSupplier\n+        ));\n+\n+        for (int i = 0; i != 2; i++) {\n+            assertEquals(calledOnceSupplier.value(), supplier.apply(\"once\"));\n+\n+            final var ex = assertThrows(NullPointerException.class, () -> supplier.apply(\"onceNull\"));\n+            assertEquals(\"Null value for token [onceNull]\", ex.getMessage());\n+        }\n+\n+        final var ex = assertThrows(NullPointerException.class, () -> supplier.apply(\"foo\"));\n+        assertEquals(\"No token value supplier for token [foo]\", ex.getMessage());\n+\n+        neverCalledSupplier.verifyCount();\n+        calledOnceSupplier.verifyCount();\n+        calledOnceNullSupplier.verifyCount();\n+    }\n+\n+    private static TestSpec.Builder testSpec(String str) {\n+        return new TestSpec.Builder().str(str);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/TokenReplaceTest.java","additions":290,"deletions":0,"binary":false,"changes":290,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static jdk.jpackage.test.HelloApp.configureAndExecute;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.TokenReplace;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Executor;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.JPackageCommand.Macro;\n+import jdk.jpackage.test.TKit;\n+\n+\/*\n+ * @test\n+ * @summary Tests environment variables substitution by jpackage launcher\n+ * @bug 8341641\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @build AppLauncherSubstTest\n+ * @run main\/othervm -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=AppLauncherSubstTest\n+ *\/\n+public class AppLauncherSubstTest {\n+\n+    record TestSpec(String str, String expectedStr, Map<String, String> env) {\n+\n+        static class Builder {\n+\n+            Builder str(String v) {\n+                str = v;\n+                return this;\n+            }\n+\n+            Builder expect(String v) {\n+                expectedStr = v;\n+                return this;\n+            }\n+\n+            Builder var(String name, String value) {\n+                env.put(name, value);\n+                return this;\n+            }\n+\n+            TestSpec create() {\n+                return new TestSpec(str, Optional.ofNullable(expectedStr).orElse(str), env);\n+            }\n+\n+            private String str;\n+            private String expectedStr;\n+            private Map<String, String> env = new HashMap<>();\n+        }\n+\n+        public TestSpec {\n+            Objects.requireNonNull(str);\n+            Objects.requireNonNull(expectedStr);\n+            Objects.requireNonNull(env);\n+            env.entrySet().forEach(Objects::requireNonNull);\n+        }\n+\n+        public String resolveExpectedStr(JPackageCommand cmd) {\n+            return MACROS.applyTo(expectedStr, token -> {\n+                \/\/ @@APPDIR@@ -> APPDIR\n+                final var macro = token.substring(2, token.length() - 2);\n+                return Path.of(cmd.macroValue(Macro.valueOf(macro))).toAbsolutePath();\n+            });\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final var sb = new StringBuilder();\n+            sb.append(\"str=\").append(str);\n+            sb.append(\", expect=\").append(expectedStr);\n+            if (!env.isEmpty()) {\n+                sb.append(\", env=\").append(env);\n+            }\n+            return sb.toString();\n+        }\n+\n+        private final static TokenReplace MACROS = new TokenReplace(Stream.of(Macro.values()).map(macro -> {\n+            return String.format(\"@@%s@@\", macro);\n+        }).toArray(String[]::new));\n+    }\n+\n+    @Test\n+    @ParameterSupplier\n+    public static void test(TestSpec spec) throws IOException {\n+        final var cmd = JPackageCommand.helloAppImage(TEST_APP_JAVA + \"*Hello\")\n+                .ignoreFakeRuntime()\n+                .setArgumentValue(\"--java-options\", \"-D\" + TEST_PROP + \"=\");\n+\n+        cmd.execute();\n+\n+        \/\/ Manually edit main launcher config file. Don't do it directly because\n+        \/\/ jpackage doesn't pass the value of `--java-options` option as-is into the config file.\n+        final var cfgFile = cmd.appLauncherCfgPath(null);\n+        TKit.createTextFile(cfgFile, Files.readAllLines(cfgFile).stream().map(line -> {\n+            return TEST_PROP_REGEXP.matcher(line).replaceFirst(Matcher.quoteReplacement(spec.str()));\n+        }));\n+\n+        final var launcherExec = new Executor()\n+                .saveOutput()\n+                .dumpOutput()\n+                .setExecutable(cmd.appLauncherPath().toAbsolutePath())\n+                .addArguments(\"--print-sys-prop=\" + TEST_PROP);\n+\n+        spec.env().forEach(launcherExec::setEnvVar);\n+\n+        final var resolvedExpectedStr = spec.resolveExpectedStr(cmd);\n+        final var actualStr = configureAndExecute(0, launcherExec).getFirstLineOfOutput().substring((TEST_PROP + \"=\").length());\n+\n+        if (TKit.isWindows() && !resolvedExpectedStr.equals(spec.expectedStr())) {\n+            TKit.assertEquals(resolvedExpectedStr.toLowerCase(), actualStr.toLowerCase(), \"Check the property value is as expected [lowercase]\");\n+        } else {\n+            TKit.assertEquals(resolvedExpectedStr, actualStr, \"Check the property value is as expected\");\n+        }\n+    }\n+\n+    public static Collection<Object[]> test() {\n+        return Stream.of(\n+                testSpec(\"\"),\n+                testSpec(\"$ONE ${TWO} ${ONE} $TWO ONE TWO\").expect(\"one two one two ONE TWO\").var(\"ONE\", \"one\").var(\"TWO\", \"two\"),\n+                testSpec(\"\\\\$FOO\\\\\\\\$FOO\\\\${FOO}\\\\\\\\${FOO}\").expect(\"$FOO\\\\BAR${FOO}\\\\BAR\").var(\"FOO\", \"BAR\"),\n+                testSpec(\"$FOO-$BAR\").expect(\"$FOO-\").var(\"BAR\", \"\"),\n+                testSpec(\"${BINDIR}${APPDIR}${ROOTDIR}\").expect(\"@@BINDIR@@@@APPDIR@@@@ROOTDIR@@\").var(\"BINDIR\", \"a\").var(\"APPDIR\", \"b\").var(\"ROOTDIR\", \"c\"),\n+                testSpec(\"$BINDIR$APPDIR$ROOTDIR\").expect(\"@@BINDIR@@@@APPDIR@@@@ROOTDIR@@\"),\n+                testSpec(\"$BINDIR2$APPDIR2$ROOTDIR2\").expect(\"$BINDIR2$APPDIR2$ROOTDIR2\")\n+        ).map(TestSpec.Builder::create).map(v -> {\n+            return new Object[] {v};\n+        }).toList();\n+    }\n+\n+    private static TestSpec.Builder testSpec(String str) {\n+        return new TestSpec.Builder().str(str);\n+    }\n+\n+    private static final Path TEST_APP_JAVA = TKit.TEST_SRC_ROOT.resolve(\"apps\/PrintEnv.java\");\n+\n+    private static final String TEST_PROP = \"jdk.jpackage.test.Property\";\n+    private static final Pattern TEST_PROP_REGEXP = Pattern.compile(\"(?<=\" + Pattern.quote(TEST_PROP) + \"=).*\");\n+}\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppLauncherSubstTest.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"}]}