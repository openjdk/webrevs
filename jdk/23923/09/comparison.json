{"files":[{"patch":"@@ -45,0 +45,6 @@\n+\/**\n+ * Class to replace tokens in strings.\n+ * <p>\n+ * Single instance holds a list of tokens. Tokens can be substrings of each other.\n+ * The implementation performs greedy replacement: longer tokens are replaced first.\n+ *\/\n@@ -106,1 +112,1 @@\n-        for(;;) {\n+        for (;;) {\n@@ -156,1 +162,1 @@\n-        if (this == obj)\n+        if (this == obj) {\n@@ -158,3 +164,2 @@\n-        if (obj == null)\n-            return false;\n-        if (getClass() != obj.getClass())\n+        }\n+        if ((obj == null) || (getClass() != obj.getClass())) {\n@@ -162,0 +167,1 @@\n+        }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/TokenReplace.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -222,0 +222,20 @@\n+    Value can contain substrings that will be expanded at runtime.\n+    Two types of such substrings are supported: environment variables\n+    and \"APPDIR\", \"BINDIR\", and \"ROOTDIR\" tokens.\n+\n+    An expandable substring should be enclosed between the dollar\n+    sign character ($) and the first following non-alphanumeric\n+    character. Alternatively, it can be enclosed between \"${\" and \"}\"\n+    substrings.\n+\n+    Expandable substrings are case-sensitive on Unix and\n+    case-insensitive on Windows. No string expansion occurs if the\n+    referenced environment variable is undefined.\n+\n+    Environment variables with names \"APPDIR\", \"BINDIR\", and \"ROOTDIR\"\n+    will be ignored, and these expandable substrings will be\n+    replaced by values calculated by the app launcher.\n+\n+    Prefix the dollar sign character with the backslash character (\\)\n+    to prevent substring expansion.\n+\n@@ -228,0 +248,3 @@\n+    Value can contain substrings that will be substituted at runtime,\n+    such as for the --arguments option.\n+\n","filename":"src\/jdk.jpackage\/share\/man\/jpackage.md","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -167,3 +167,3 @@\n-    macros[_T(\"$APPDIR\")] = appDirPath;\n-    macros[_T(\"$BINDIR\")] = FileUtils::dirname(launcherPath);\n-    macros[_T(\"$ROOTDIR\")] = imageRoot;\n+    macros[_T(\"APPDIR\")] = appDirPath;\n+    macros[_T(\"BINDIR\")] = FileUtils::dirname(launcherPath);\n+    macros[_T(\"ROOTDIR\")] = imageRoot;\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/AppLauncher.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include <set>\n@@ -31,0 +32,1 @@\n+#include \"SysInfo.h\"\n@@ -35,0 +37,1 @@\n+#include \"StringProcessing.h\"\n@@ -63,6 +66,8 @@\n-tstring expandMacros(const tstring& str, const CfgFile::Macros& macros) {\n-    tstring reply = str;\n-    CfgFile::Macros::const_iterator it = macros.begin();\n-    const CfgFile::Macros::const_iterator end = macros.end();\n-    for (; it != end; ++it) {\n-        reply = tstrings::replace(reply, it->first, it->second);\n+template <typename CfgFileType, typename OpType>\n+void iterateProperties(CfgFileType& cfgFile, OpType& op) {\n+    for (auto mapIt = cfgFile.begin(), mapEnd = cfgFile.end(); mapIt != mapEnd; ++mapIt) {\n+        for (auto propertyIt = mapIt->second.begin(), propertyEnd = mapIt->second.end(); propertyIt != propertyEnd; ++propertyIt) {\n+            for (auto strIt = propertyIt->second.begin(), strEnd = propertyIt->second.end(); strIt != strEnd; ++strIt) {\n+                op(strIt);\n+            }\n+        }\n@@ -70,1 +75,0 @@\n-    return reply;\n@@ -73,0 +77,40 @@\n+struct tokenize_strings {\n+    void operator () (tstring_array::const_iterator& strIt) {\n+        const auto tokens = StringProcessing::tokenize(*strIt);\n+        values.push_back(tokens);\n+    }\n+\n+    std::set<tstring> variableNames() const {\n+        std::set<tstring> allVariableNames;\n+        for (auto it = values.begin(), end = values.end(); it != end; ++it) {\n+            const auto variableNames = StringProcessing::extractVariableNames(*it);\n+            allVariableNames.insert(variableNames.begin(), variableNames.end());\n+        }\n+\n+        return allVariableNames;\n+    }\n+\n+    std::vector<StringProcessing::TokenizedString> values;\n+};\n+\n+class expand_macros {\n+public:\n+    expand_macros(const CfgFile::Macros& m,\n+        std::vector<StringProcessing::TokenizedString>::iterator iter) : macros(m), curTokenizedString(iter) {\n+    }\n+\n+    void operator () (tstring_array::iterator& strIt) {\n+        StringProcessing::expandVariables(*curTokenizedString, macros);\n+        auto newStr = StringProcessing::stringify(*curTokenizedString);\n+        ++curTokenizedString;\n+        if (*strIt != newStr) {\n+            LOG_TRACE(tstrings::any() << \"Map [\" << *strIt << \"] into [\" << newStr << \"]\");\n+        }\n+        strIt->swap(newStr);\n+    }\n+\n+private:\n+    const CfgFile::Macros& macros;\n+    std::vector<StringProcessing::TokenizedString>::iterator curTokenizedString;\n+};\n+\n@@ -78,13 +122,13 @@\n-    PropertyMap::iterator mapIt = copyCfgFile.data.begin();\n-    const PropertyMap::iterator mapEnd = copyCfgFile.data.end();\n-    for (; mapIt != mapEnd; ++mapIt) {\n-        Properties::iterator propertyIt = mapIt->second.begin();\n-        const Properties::iterator propertyEnd = mapIt->second.end();\n-        for (; propertyIt != propertyEnd; ++propertyIt) {\n-            tstring_array::iterator strIt = propertyIt->second.begin();\n-            const tstring_array::iterator strEnd = propertyIt->second.end();\n-            for (; strIt != strEnd; ++strIt) {\n-                tstring newValue;\n-                while ((newValue = ::expandMacros(*strIt, macros)) != *strIt) {\n-                    strIt->swap(newValue);\n-                }\n+    tokenize_strings tokenizedStrings;\n+    iterateProperties(static_cast<const CfgFile::PropertyMap&>(copyCfgFile.data), tokenizedStrings);\n+\n+    Macros allMacros(macros);\n+\n+    const auto variableNames = tokenizedStrings.variableNames();\n+    for (auto it = variableNames.begin(), end = variableNames.end(); it != end; ++it) {\n+        if (macros.find(*it) == macros.end()) {\n+            \/\/ Not one of the reserved macro names. Assuming an environment variable.\n+            const auto envVarName = *it;\n+            if (SysInfo::isEnvVariableSet(envVarName)) {\n+                const auto envVarValue = SysInfo::getEnvVariable(envVarName);\n+                allMacros[envVarName] = envVarValue;\n@@ -95,0 +139,3 @@\n+    expand_macros expandMacros(allMacros, tokenizedStrings.values.begin());\n+    iterateProperties(copyCfgFile.data, expandMacros);\n+\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/CfgFile.cpp","additions":68,"deletions":21,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,1 @@\n-#include <map>\n-#include \"tstrings.h\"\n+#include \"StringProcessing.h\"\n@@ -93,1 +92,1 @@\n-    typedef std::map<tstring, tstring> Macros;\n+    typedef StringProcessing::VariableValues Macros;\n@@ -96,1 +95,1 @@\n-     * Returns copy of this instance with the given macros expanded.\n+     * Returns copy of this instance with the given macros and environment variables expanded.\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/CfgFile.h","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"kludge_c++11.h\"\n+\n+#include <algorithm>\n+#include \"StringProcessing.h\"\n+\n+\n+namespace StringProcessing {\n+\n+namespace {\n+\n+class TokenBuilder {\n+public:\n+    TokenBuilder(const tstring& v): cur(v.c_str()) {\n+    }\n+\n+    void addNextToken(tstring::const_pointer end, TokenType type, TokenizedString& tokens) {\n+        if (end != cur) {\n+            const auto value = tstring(cur, end - cur);\n+            cur = end;\n+            tokens.push_back(Token(type, value));\n+        }\n+    }\n+\n+private:\n+    tstring::const_pointer cur;\n+};\n+\n+bool isValidVariableFirstChar(tstring::value_type chr) {\n+    if ('A' <= chr && chr <= 'Z') {\n+        return true;\n+    } else if ('a' <= chr && chr <= 'z') {\n+        return true;\n+    } else if ('_' == chr) {\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+bool isValidVariableOtherChar(tstring::value_type chr) {\n+    if (isValidVariableFirstChar(chr)) {\n+        return true;\n+    } else if ('0' <= chr && chr <= '9') {\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+} \/\/  namespace\n+\n+TokenizedString tokenize(const tstring& str) {\n+    TokenizedString tokens;\n+    TokenBuilder tb(str);\n+    tstring::const_pointer cur = str.c_str();\n+    const tstring::const_pointer end = cur + str.length();\n+    while (cur != end) {\n+        if (*cur == '\\\\' && cur + 1 != end) {\n+            const auto maybeNextToken = cur++;\n+            if (*cur == '\\\\' || *cur == '$') {\n+                tb.addNextToken(maybeNextToken, STRING, tokens);\n+                tb.addNextToken(++cur, ESCAPED_CHAR, tokens);\n+                continue;\n+            }\n+        } else if (*cur == '$' && cur + 1 != end) {\n+            const auto maybeNextToken = cur++;\n+            bool variableFound = false;\n+            if (*cur == '{') {\n+                do {\n+                    cur++;\n+                } while (cur != end && *cur != '}');\n+                if (cur != end) {\n+                    variableFound = true;\n+                    cur++;\n+                }\n+            } else if (isValidVariableFirstChar(*cur)) {\n+                variableFound = true;\n+                do {\n+                    cur++;\n+                } while (cur != end && isValidVariableOtherChar(*cur));\n+            } else {\n+                continue;\n+            }\n+            if (variableFound) {\n+                tb.addNextToken(maybeNextToken, STRING, tokens);\n+                tb.addNextToken(cur, VARIABLE, tokens);\n+            }\n+        } else {\n+            ++cur;\n+        }\n+    }\n+    tb.addNextToken(cur, STRING, tokens);\n+    return tokens;\n+}\n+\n+\n+tstring stringify(const TokenizedString& tokens) {\n+    tstringstream ss;\n+    TokenizedString::const_iterator it = tokens.begin();\n+    const TokenizedString::const_iterator end = tokens.end();\n+    for (; it != end; ++it) {\n+        if (it->type() == ESCAPED_CHAR) {\n+            ss << it->value().substr(1);\n+        } else {\n+            ss << it->value();\n+        }\n+    }\n+    return ss.str();\n+}\n+\n+\n+namespace {\n+\n+tstring getVariableName(const tstring& str) {\n+    if (tstrings::endsWith(str, _T(\"}\"))) {\n+        \/\/ ${VAR}\n+        return str.substr(2, str.length() - 3);\n+    } else {\n+        \/\/ $VAR\n+        return str.substr(1);\n+    }\n+}\n+\n+} \/\/ namespace\n+\n+VariableNameList extractVariableNames(const TokenizedString& tokens) {\n+    VariableNameList reply;\n+\n+    TokenizedString::const_iterator it = tokens.begin();\n+    const TokenizedString::const_iterator end = tokens.end();\n+    for (; it != end; ++it) {\n+        if (it->type() == VARIABLE) {\n+            reply.push_back(getVariableName(it->value()));\n+        }\n+    }\n+\n+    std::sort(reply.begin(), reply.end());\n+    reply.erase(std::unique(reply.begin(), reply.end()), reply.end());\n+    return reply;\n+}\n+\n+\n+void expandVariables(TokenizedString& tokens, const VariableValues& variableValues) {\n+    TokenizedString::iterator it = tokens.begin();\n+    const TokenizedString::iterator end = tokens.end();\n+    for (; it != end; ++it) {\n+        if (it->type() == VARIABLE) {\n+            const auto entry = variableValues.find(getVariableName(it->value()));\n+            if (entry != variableValues.end()) {\n+                auto newToken = Token(STRING, entry->second);\n+                std::swap(*it, newToken);\n+            }\n+        }\n+    }\n+}\n+\n+} \/\/ namespace StringProcessing\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/StringProcessing.cpp","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+#ifndef StringProcessor_h\n+#define StringProcessor_h\n+\n+#include <map>\n+#include \"tstrings.h\"\n+\n+\n+namespace StringProcessing {\n+\n+enum TokenType {\n+    STRING,\n+    VARIABLE,\n+    ESCAPED_CHAR\n+};\n+\n+class Token {\n+public:\n+    Token(TokenType type, const tstring& str): theType(type), theStr(str) {\n+    }\n+\n+    TokenType type() const {\n+        return theType;\n+    }\n+\n+    const tstring& value() const {\n+        return theStr;\n+    }\n+\n+private:\n+    TokenType theType;\n+    tstring theStr;\n+};\n+\n+typedef std::vector<Token> TokenizedString;\n+typedef std::vector<tstring> VariableNameList;\n+#ifdef _WIN32\n+struct less_ignore_case {\n+    bool operator() (const tstring& x, const tstring& y) const {\n+        return std::less<tstring>()(tstrings::toLower(x), tstrings::toLower(y));\n+    }\n+};\n+typedef std::map<tstring, tstring, less_ignore_case> VariableValues;\n+#else\n+typedef std::map<tstring, tstring> VariableValues;\n+#endif\n+\n+TokenizedString tokenize(const tstring& str);\n+\n+tstring stringify(const TokenizedString& tokens);\n+\n+VariableNameList extractVariableNames(const TokenizedString& tokens);\n+\n+void expandVariables(TokenizedString& tokens, const VariableValues& variableValues);\n+\n+} \/\/ namespace StringProcessing\n+\n+#endif \/\/ StringProcessor_h\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/StringProcessing.h","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -25,0 +25,3 @@\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+\n@@ -38,1 +41,0 @@\n-import java.util.stream.Collectors;\n@@ -40,1 +42,0 @@\n-import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n@@ -42,1 +43,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n@@ -396,5 +396,3 @@\n-            }).collect(\n-                    Collectors.toMap(tokens -> tokens[0], tokens -> tokens[1],\n-                            (oldValue, newValue) -> {\n-                                return newValue;\n-                            }));\n+            }).collect(toMap(tokens -> tokens[0], tokens -> tokens[1], (oldValue, newValue) -> {\n+                return newValue;\n+            }));\n@@ -422,5 +420,3 @@\n-        var map = Map.of(\n-                \"$APPDIR\", cmd.appLayout().appDirectory(),\n-                \"$ROOTDIR\",\n-                cmd.isImagePackageType() ? cmd.outputBundle() : cmd.appInstallationDirectory(),\n-                \"$BINDIR\", cmd.appLayout().launchersDirectory());\n+        var map = Stream.of(JPackageCommand.Macro.values()).collect(toMap(x -> {\n+            return String.format(\"$%s\", x.name());\n+        }, cmd::macroValue));\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/AdditionalLauncher.java","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -862,0 +862,26 @@\n+    public static enum Macro {\n+        APPDIR(cmd -> {\n+            return cmd.appLayout().appDirectory().toString();\n+        }),\n+        BINDIR(cmd -> {\n+            return cmd.appLayout().launchersDirectory().toString();\n+        }),\n+        ROOTDIR(cmd -> {\n+            return (cmd.isImagePackageType() ? cmd.outputBundle() : cmd.appInstallationDirectory()).toString();\n+        });\n+\n+        private Macro(Function<JPackageCommand, String> getValue) {\n+            this.getValue = Objects.requireNonNull(getValue);\n+        }\n+\n+        String value(JPackageCommand cmd) {\n+            return getValue.apply(cmd);\n+        }\n+\n+        private final Function<JPackageCommand, String> getValue;\n+    }\n+\n+    public String macroValue(Macro macro) {\n+        return macro.value(this);\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,249 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static jdk.internal.util.OperatingSystem.WINDOWS;\n+import static jdk.jpackage.test.HelloApp.configureAndExecute;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.TokenReplace;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Executor;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.JPackageCommand.Macro;\n+import jdk.jpackage.test.TKit;\n+\n+\/*\n+ * @test\n+ * @summary Tests environment variables substitution by jpackage launcher\n+ * @bug 8341641\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @build AppLauncherSubstTest\n+ * @run main\/othervm -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=AppLauncherSubstTest\n+ *\/\n+public class AppLauncherSubstTest {\n+\n+    record TestSpec(String str, String expectedStr, Map<String, String> env) {\n+\n+        static class Builder {\n+\n+            Builder str(String v) {\n+                str = v;\n+                return this;\n+            }\n+\n+            Builder expect(String v) {\n+                expectedStr = v;\n+                return this;\n+            }\n+\n+            Builder var(String name, String value) {\n+                env.put(name, value);\n+                return this;\n+            }\n+\n+            TestSpec create() {\n+                return new TestSpec(str, Optional.ofNullable(expectedStr).orElse(str), env);\n+            }\n+\n+            private String str;\n+            private String expectedStr;\n+            private Map<String, String> env = new LinkedHashMap<>();\n+        }\n+\n+        public TestSpec {\n+            Objects.requireNonNull(str);\n+            Objects.requireNonNull(expectedStr);\n+            Objects.requireNonNull(env);\n+            env.entrySet().forEach(Objects::requireNonNull);\n+        }\n+\n+        public String resolveExpectedStr(JPackageCommand cmd) {\n+            return MACROS.applyTo(expectedStr, token -> {\n+                \/\/ @@APPDIR@@ -> APPDIR\n+                final var macro = token.substring(2, token.length() - 2);\n+                return Path.of(cmd.macroValue(Macro.valueOf(macro))).toAbsolutePath();\n+            });\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final var sb = new StringBuilder();\n+            sb.append(\"str=\").append(str);\n+            sb.append(\", expect=\").append(expectedStr);\n+            if (!env.isEmpty()) {\n+                sb.append(\", env=\").append(env);\n+            }\n+            return sb.toString();\n+        }\n+\n+        private final static TokenReplace MACROS = new TokenReplace(Stream.of(Macro.values()).map(macro -> {\n+            return String.format(\"@@%s@@\", macro);\n+        }).toArray(String[]::new));\n+    }\n+\n+    @Test\n+    @ParameterSupplier\n+    @ParameterSupplier(value = \"testCaseSensitive\", ifNotOS = WINDOWS)\n+    @ParameterSupplier(value = \"testCaseInsensitive\", ifOS = WINDOWS)\n+    public static void test(TestSpec spec) throws IOException {\n+        final var cmd = JPackageCommand.helloAppImage(TEST_APP_JAVA + \"*Hello\")\n+                .ignoreFakeRuntime()\n+                .setArgumentValue(\"--java-options\", \"-D\" + TEST_PROP + \"=\");\n+\n+        cmd.execute();\n+\n+        \/\/ Manually edit main launcher config file. Don't do it directly because\n+        \/\/ jpackage doesn't pass the value of `--java-options` option as-is into the config file.\n+        final var cfgFile = cmd.appLauncherCfgPath(null);\n+        TKit.createTextFile(cfgFile, Files.readAllLines(cfgFile).stream().map(line -> {\n+            return TEST_PROP_REGEXP.matcher(line).replaceFirst(Matcher.quoteReplacement(spec.str()));\n+        }));\n+\n+        final var launcherExec = new Executor()\n+                .saveOutput()\n+                .dumpOutput()\n+                .setExecutable(cmd.appLauncherPath().toAbsolutePath())\n+                .addArguments(\"--print-sys-prop=\" + TEST_PROP);\n+\n+        spec.env().forEach(launcherExec::setEnvVar);\n+\n+        final var resolvedExpectedStr = spec.resolveExpectedStr(cmd);\n+        final var actualStr = configureAndExecute(0, launcherExec).getFirstLineOfOutput().substring((TEST_PROP + \"=\").length());\n+\n+        if (TKit.isWindows() && !resolvedExpectedStr.equals(spec.expectedStr())) {\n+            TKit.assertEquals(resolvedExpectedStr.toLowerCase(), actualStr.toLowerCase(), \"Check the property value is as expected [lowercase]\");\n+        } else {\n+            TKit.assertEquals(resolvedExpectedStr, actualStr, \"Check the property value is as expected\");\n+        }\n+    }\n+\n+    public static Collection<Object[]> test() {\n+        return Stream.of(\n+                testSpec(\"\"),\n+                testSpec(\"$ONE ${TWO} ${ONE} $TWO ONE TWO\").expect(\"one two one two ONE TWO\").var(\"ONE\", \"one\").var(\"TWO\", \"two\"),\n+                testSpec(\"\\\\$FOO\\\\\\\\$FOO\\\\${FOO}\\\\\\\\${FOO}\").expect(\"$FOO\\\\BAR${FOO}\\\\BAR\").var(\"FOO\", \"BAR\"),\n+                testSpec(\"$FOO-$BAR\").expect(\"$FOO-\").var(\"BAR\", \"\"),\n+                testSpec(\"${BINDIR}${APPDIR}${ROOTDIR}\").expect(\"@@BINDIR@@@@APPDIR@@@@ROOTDIR@@\").var(\"BINDIR\", \"a\").var(\"APPDIR\", \"b\").var(\"ROOTDIR\", \"c\"),\n+                testSpec(\"$BINDIR$APPDIR$ROOTDIR\").expect(\"@@BINDIR@@@@APPDIR@@@@ROOTDIR@@\"),\n+                testSpec(\"$BINDIR2$APPDIR2$ROOTDIR2\").expect(\"$BINDIR2$APPDIR2$ROOTDIR2\")\n+        ).map(TestSpec.Builder::create).map(v -> {\n+            return new Object[] {v};\n+        }).toList();\n+    }\n+\n+    public static Collection<Object[]> testCaseSensitive() {\n+        final List<TestSpec> testCases = new ArrayList<>();\n+        for (final var macro : Macro.values()) {\n+            testCases.addAll(createTestCases(macro, true));\n+        }\n+\n+        testCases.addAll(Stream.of(\n+                testSpec(\"$ALPHA $alpha\").expect(\"A a\").var(\"ALPHA\", \"A\").var(\"alpha\", \"a\"),\n+                testSpec(\"$ALPHA $alpha\").expect(\"$ALPHA a\").var(\"alpha\", \"a\"),\n+                testSpec(\"$ALPHA $alpha\").expect(\"A $alpha\").var(\"ALPHA\", \"A\")\n+        ).map(TestSpec.Builder::create).toList());\n+\n+        return testCases.stream().map(v -> {\n+            return new Object[] {v};\n+        }).toList();\n+    }\n+\n+    public static Collection<Object[]> testCaseInsensitive() {\n+        final List<TestSpec> testCases = new ArrayList<>();\n+        for (final var macro : Macro.values()) {\n+            testCases.addAll(createTestCases(macro, false));\n+        }\n+\n+        testCases.addAll(Stream.of(\n+                testSpec(\"$ALPHA $alpha\").expect(\"A A\").var(\"AlphA\", \"A\"),\n+                testSpec(\"$ALPHA $alpha\").expect(\"a a\").var(\"alpha\", \"a\"),\n+                testSpec(\"$ALPHA $alpha\").expect(\"A A\").var(\"ALPHA\", \"A\")\n+        ).map(TestSpec.Builder::create).toList());\n+\n+        return testCases.stream().map(v -> {\n+            return new Object[] {v};\n+        }).toList();\n+    }\n+\n+    private static List<TestSpec> createTestCases(Macro macro, boolean caseSensitive) {\n+        final var name = macro.name();\n+        final var name2 = name.transform(str -> {\n+            final var chars = name.toCharArray();\n+            for (int i = 0; i < chars.length; i += 2) {\n+                chars[i] = Character.toLowerCase(chars[i]);\n+            }\n+            return new String(chars);\n+        });\n+\n+        if (name.equals(name2)) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        final var testSpec = testSpec(String.format(\"${%s}${%s}\", name, name2)).var(name, \"A\").var(name2, \"[foo]\");\n+        if (caseSensitive) {\n+            testSpec.expect(String.format(\"@@%s@@[foo]\", name, name2));\n+        } else {\n+            testSpec.expect(String.format(\"@@%s@@@@%s@@\", name, name));\n+        }\n+\n+        final var testSpec2 = testSpec(String.format(\"${%s}${%s}\", name, name2)).var(name, \"A\");\n+        if (caseSensitive) {\n+            testSpec2.expect(String.format(\"@@%s@@${%s}\", name, name2));\n+        } else {\n+            testSpec2.expect(String.format(\"@@%s@@@@%s@@\", name, name));\n+        }\n+\n+        final var testSpec3 = testSpec(String.format(\"${%s}${%s}\", name, name2));\n+        if (caseSensitive) {\n+            testSpec3.expect(String.format(\"@@%s@@${%s}\", name, name2));\n+        } else {\n+            testSpec3.expect(String.format(\"@@%s@@@@%s@@\", name, name));\n+        }\n+\n+        return Stream.of(testSpec, testSpec2).map(TestSpec.Builder::create).toList();\n+    }\n+\n+    private static TestSpec.Builder testSpec(String str) {\n+        return new TestSpec.Builder().str(str);\n+    }\n+\n+    private static final Path TEST_APP_JAVA = TKit.TEST_SRC_ROOT.resolve(\"apps\/PrintEnv.java\");\n+\n+    private static final String TEST_PROP = \"jdk.jpackage.test.Property\";\n+    private static final Pattern TEST_PROP_REGEXP = Pattern.compile(\"(?<=\" + Pattern.quote(TEST_PROP) + \"=).*\");\n+}\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppLauncherSubstTest.java","additions":249,"deletions":0,"binary":false,"changes":249,"status":"added"}]}