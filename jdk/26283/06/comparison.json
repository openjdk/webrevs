{"files":[{"patch":"@@ -2476,0 +2476,4 @@\n+bool Matcher::should_attempt_register_biasing(int mopc) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1079,0 +1079,4 @@\n+bool Matcher::should_attempt_register_biasing(int mopc) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2393,0 +2393,4 @@\n+bool Matcher::should_attempt_register_biasing(int mopc) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2063,0 +2063,4 @@\n+}\n+\n+bool Matcher::should_attempt_register_biasing(int mopc) {\n+  return false;\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1896,0 +1896,4 @@\n+bool Matcher::should_attempt_register_biasing(int mopc) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -437,0 +437,67 @@\n+bool Matcher::should_attempt_register_biasing(int mopc) {\n+  switch(mopc) {\n+    default:\n+      return false;\n+    case addI_rReg_ndd_rule:\n+    case addI_rReg_rReg_imm_ndd_rule:\n+    case addI_rReg_rReg_mem_ndd_rule:\n+    case addL_rReg_ndd_rule:\n+    case addL_rReg_rReg_imm_ndd_rule:\n+    case andI_rReg_ndd_rule:\n+    case andI_rReg_rReg_imm_ndd_rule:\n+    case andI_rReg_rReg_mem_ndd_rule:\n+    case andL_rReg_ndd_rule:\n+    case andL_rReg_rReg_imm_ndd_rule:\n+    case addL_rReg_rReg_mem_ndd_rule:\n+    case decI_rReg_ndd_rule:\n+    case decL_rReg_ndd_rule:\n+    case incI_rReg_ndd_rule:\n+    case incL_rReg_ndd_rule:\n+    case maxI_rReg_ndd_rule:\n+    case minI_rReg_ndd_rule:\n+    case mulI_rReg_ndd_rule:\n+    case mulI_rReg_rReg_mem_ndd_rule:\n+    case mulL_rReg_ndd_rule:\n+    case mulL_rReg_rReg_mem_ndd_rule:\n+    case negI_rReg_2_ndd_rule:\n+    case negI_rReg_ndd_rule:\n+    case negL_rReg_2_ndd_rule:\n+    case negL_rReg_ndd_rule:\n+    case orI_rReg_imm_rReg_ndd_rule:\n+    case orI_rReg_ndd_rule:\n+    case orI_rReg_rReg_imm_ndd_rule:\n+    case orI_rReg_rReg_mem_ndd_rule:\n+    case orL_rReg_imm_rReg_ndd_rule:\n+    case orL_rReg_ndd_rule:\n+    case orL_rReg_rReg_imm_ndd_rule:\n+    case orL_rReg_rReg_mem_ndd_rule:\n+    case rolI_rReg_Var_ndd_rule:\n+    case rolL_rReg_Var_ndd_rule:\n+    case rorI_rReg_Var_ndd_rule:\n+    case rorL_rReg_Var_ndd_rule:\n+    case salI_rReg_immI2_ndd_rule:\n+    case salI_rReg_imm_ndd_rule:\n+    case salL_rReg_immI2_ndd_rule:\n+    case salL_rReg_imm_ndd_rule:\n+    case sarI_rReg_imm_ndd_rule:\n+    case sarL_rReg_imm_ndd_rule:\n+    case shrI_rReg_imm_ndd_rule:\n+    case shrL_rReg_imm_ndd_rule:\n+    case subI_rReg_ndd_rule:\n+    case subI_rReg_rReg_imm_ndd_rule:\n+    case subI_rReg_rReg_mem_ndd_rule:\n+    case subL_rReg_ndd_rule:\n+    case subL_rReg_rReg_imm_ndd_rule:\n+    case subL_rReg_rReg_mem_ndd_rule:\n+    case xorI_rReg_im1_ndd_rule:\n+    case xorI_rReg_ndd_rule:\n+    case xorI_rReg_rReg_imm_ndd_rule:\n+    case xorI_rReg_rReg_mem_ndd_rule:\n+    case xorL_rReg_im1_ndd_rule:\n+    case xorL_rReg_ndd_rule:\n+    case xorL_rReg_rReg_mem_ndd_rule:\n+      assert(VM_Version::supports_apx_f(), \"\");\n+      return true;\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":67,"deletions":0,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -1481,0 +1481,23 @@\n+OptoReg::Name PhaseChaitin::select_bias_lrg_color(LRG& lrg, uint bias_lrg) {\n+  if (bias_lrg != 0) {\n+    \/\/ If bias lrg has a color.\n+    if(!_ifg->_yanked->test(bias_lrg)) {\n+      OptoReg::Name reg = lrgs(bias_lrg).reg();\n+      \/\/  And it is legal for you,\n+      if (is_legal_reg(lrg, reg)) {\n+        return reg;\n+      }\n+    } else if (!lrg.mask().is_offset()) {\n+      \/\/ Choose a color which is legal for him\n+      ResourceMark rm(C->regmask_arena());\n+      RegMask tempmask(lrg.mask(), C->regmask_arena());\n+      tempmask.and_with(lrgs(bias_lrg).mask());\n+      tempmask.clear_to_sets(lrg.num_regs());\n+      OptoReg::Name reg = find_first_set(lrg, tempmask);\n+      if (OptoReg::is_valid(reg))\n+        return reg;\n+    }\n+  }\n+  return OptoReg::Bad;\n+}\n+\n@@ -1502,0 +1525,1 @@\n+  \/\/ Try biasing the color with non-interfering first input's lrg.\n@@ -1503,18 +1527,10 @@\n-  if (copy_lrg != 0) {\n-    \/\/ If he has a color,\n-    if(!_ifg->_yanked->test(copy_lrg)) {\n-      OptoReg::Name reg = lrgs(copy_lrg).reg();\n-      \/\/  And it is legal for you,\n-      if (is_legal_reg(lrg, reg)) {\n-        return reg;\n-      }\n-    } else if (!lrg.mask().is_offset()) {\n-      \/\/ Choose a color which is legal for him\n-      ResourceMark rm(C->regmask_arena());\n-      RegMask tempmask(lrg.mask(), C->regmask_arena());\n-      tempmask.and_with(lrgs(copy_lrg).mask());\n-      tempmask.clear_to_sets(lrg.num_regs());\n-      OptoReg::Name reg = find_first_set(lrg, tempmask);\n-      if (OptoReg::is_valid(reg))\n-        return reg;\n-    }\n+  OptoReg::Name reg = select_bias_lrg_color(lrg, copy_lrg);\n+  if (reg != OptoReg::Bad) {\n+    return reg;\n+  }\n+  \/\/ For commutative operations, try biasing the color with non-interfering\n+  \/\/ second input's lrg.\n+  copy_lrg = _lrg_map.find(lrg._copy_bias2);\n+  reg = select_bias_lrg_color(lrg, copy_lrg);\n+  if (reg != OptoReg::Bad) {\n+    return reg;\n@@ -1534,1 +1550,1 @@\n-  OptoReg::Name reg = lrg.mask().find_first_elem();\n+  reg = lrg.mask().find_first_elem();\n@@ -1650,0 +1666,45 @@\n+\n+    auto is_commutative_oper = [](MachNode* def) {\n+      if (def) {\n+        switch(def->ideal_Opcode()) {\n+          case Op_AddI: case Op_AddL:\n+          case Op_MulI: case Op_MulL:\n+          case Op_XorI: case Op_XorL:\n+          case Op_OrI:  case Op_OrL:\n+          case Op_AndI: case Op_AndL:\n+            return true;\n+          default:\n+            return false;\n+        }\n+      }\n+      return false;\n+    };\n+\n+    Node* def = lrg->_def;\n+    MachNode* mdef = lrg->is_singledef() && !lrg->_is_bound && def->is_Mach() ? def->as_Mach() : nullptr;\n+    if (mdef != nullptr && Matcher::should_attempt_register_biasing(mdef->Opcode())) {\n+      if (mdef->req() > 1) {\n+        Node* in1 = mdef->in(mdef->oper_input_base());\n+        if (in1 != nullptr) {\n+          uint lrin1 = _lrg_map.find(in1);\n+          \/\/ If a def does not interfere with first input's def,\n+          \/\/ then bias its color towards its input's def.\n+          if (lrin1 != 0 && lrg->_copy_bias == 0 && _ifg->test_edge_sq(lidx, lrin1) == 0) {\n+            lrg->_copy_bias = lrin1;\n+          }\n+        }\n+      }\n+\n+      if (is_commutative_oper(mdef) && mdef->req() > 2) {\n+        Node* in2 = mdef->in(mdef->oper_input_base() + 1);\n+        if (in2 != nullptr) {\n+          uint lrin2 = _lrg_map.find(in2);\n+          \/\/ If a def does not interfere with second input's def,\n+          \/\/ then bias its color towards its input's def.\n+          if (lrin2 != 0 && lrg->_copy_bias2 == 0 && _ifg->test_edge_sq(lidx, lrin2) == 0) {\n+            lrg->_copy_bias2 = lrin2;\n+          }\n+        }\n+      }\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":80,"deletions":19,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+  uint _copy_bias2;             \/\/ Index of second LRG which we want to share color\n@@ -706,0 +707,2 @@\n+  \/\/ Helper function which implements color biasing\n+  OptoReg::Name select_bias_lrg_color(LRG& lrg, uint bias_lrg);\n","filename":"src\/hotspot\/share\/opto\/chaitin.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -509,0 +509,2 @@\n+  static bool should_attempt_register_biasing(int mopc);\n+\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}