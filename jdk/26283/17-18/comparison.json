{"files":[{"patch":"@@ -2636,0 +2636,5 @@\n+static bool is_ndd_demotable(const MachNode* mdef) {\n+  return (((mdef->flags() & Node::PD::Flag_ndd_demotable) != 0) ||\n+          ((mdef->flags() & Node::PD::Flag_ndd_demotable_commutative) != 0));\n+}\n+\n@@ -2641,5 +2646,3 @@\n-  if (mdef->num_opnds() <= oper_index || mdef->operand_index(oper_index) < 0 ||\n-      \/\/ Complex memory operand covers multiple incoming edges needed for\n-      \/\/ address computation, biasing def towards any address component will not\n-      \/\/ result into NDD demotion by assembler.\n-      mdef->operand_num_edges(oper_index) != 1) {\n+  if (mdef->num_opnds() <= oper_index ||\n+      mdef->operand_index(oper_index) < 0 ||\n+      mdef->in(mdef->operand_index(oper_index)) != nullptr) {\n@@ -2649,0 +2652,13 @@\n+  \/\/ Demotion candidate must be register mask compatible with definition.\n+  const RegMask& oper_mask = mdef->in_RegMask(mdef->operand_index(oper_index));\n+  if (!oper_mask.overlap(mdef->out_RegMask())) {\n+    assert(!is_ndd_demotable(mdef), \"%s\", mdef->Name());\n+    return false;\n+  }\n+\n+  \/\/ Complex memory operand covers multiple incoming edges needed for\n+  \/\/ address computation, biasing def towards any address component will not\n+  \/\/ result into NDD demotion by assembler.\n+  if (mdef->operand_num_edges(oper_index) != 1) {\n+    return false;\n+  }\n@@ -2650,1 +2666,0 @@\n-  bool res = false;\n@@ -2658,3 +2673,1 @@\n-    case 1: {\n-      res = (((mdef->flags() & Node::PD::Flag_ndd_demotable) != 0) ||\n-              ((mdef->flags() & Node::PD::Flag_ndd_demotable_commutative) != 0));\n+    case 1: return is_ndd_demotable(mdef);\n@@ -2662,16 +2675,2 @@\n-    }\n-    break;\n-\n-    \/\/ Definition operand of commutative operation can be biased towards\n-    \/\/ second operand.\n-    case 2: {\n-      res = ((mdef->flags() & Node::PD::Flag_ndd_demotable_commutative) != 0);\n-    }\n-    break;\n-\n-    \/\/ Current scheme only selects upto two biaising candidates\n-    default: {\n-      assert(false, \"unhandled operand index\");\n-    }\n-    break;\n-  }\n+    \/\/ Definition operand of commutative operation can be biased towards second operand.\n+    case 2: return (mdef->flags() & Node::PD::Flag_ndd_demotable_commutative) != 0;\n@@ -2679,3 +2678,2 @@\n-  if (res) {\n-    \/\/ Demotion candidate must be register mask compatible with definition.\n-    assert(mdef->in_RegMask(mdef->operand_index(oper_index)).overlap(mdef->out_RegMask()), \"sanity\");\n+    \/\/ Current scheme only selects up to two biaising candidates\n+    default: assert(false, \"unhandled operand index: %s\", mdef->Name()); break;\n@@ -2684,1 +2682,1 @@\n-  return res;\n+  return false;\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":27,"deletions":29,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -1485,0 +1485,2 @@\n+  }\n+\n@@ -1486,1 +1488,1 @@\n-  } else if (bias_lrg2_idx != 0 && !_ifg->_yanked->test(bias_lrg2_idx)) {\n+  if (bias_lrg2_idx != 0 && !_ifg->_yanked->test(bias_lrg2_idx)) {\n@@ -1492,1 +1494,3 @@\n-  } else if (!lrg.mask().is_offset()) {\n+  }\n+\n+  if (!lrg.mask().is_offset()) {\n@@ -1495,3 +1499,5 @@\n-    \/\/ live range with minimum degree of freedom, this will enhance\n-    \/\/ the chances of register sharing once the bias live range\n-    \/\/ becomes the part of IFG.\n+    \/\/ live range with minimum degree of freedom, this will\n+    \/\/ enhance the chances of register sharing once the bias\n+    \/\/ live range becomes the part of IFG.\n+    lrgs(bias_lrg1_idx).compute_set_mask_size();\n+    lrgs(bias_lrg2_idx).compute_set_mask_size();\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"}]}