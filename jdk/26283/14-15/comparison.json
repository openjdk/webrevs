{"files":[{"patch":"@@ -2476,1 +2476,1 @@\n-bool Matcher::is_register_biasing_candidate(const MachNode* mdef, int biasing_candidate, int oper_index) {\n+bool Matcher::is_register_biasing_candidate(const MachNode* mdef, int oper_index) {\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1079,1 +1079,1 @@\n-bool Matcher::is_register_biasing_candidate(const MachNode* mdef, int biasing_candidate, int oper_index) {\n+bool Matcher::is_register_biasing_candidate(const MachNode* mdef, int oper_index) {\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2393,1 +2393,1 @@\n-bool Matcher::is_register_biasing_candidate(const MachNode* mdef, int biasing_candidate, int oper_index) {\n+bool Matcher::is_register_biasing_candidate(const MachNode* mdef, int oper_index) {\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2073,1 +2073,1 @@\n-bool Matcher::is_register_biasing_candidate(const MachNode* mdef, int biasing_candidate, int oper_index) {\n+bool Matcher::is_register_biasing_candidate(const MachNode* mdef, int oper_index) {\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1896,1 +1896,1 @@\n-bool Matcher::is_register_biasing_candidate(const MachNode* mdef, int biasing_candidate, int oper_index) {\n+bool Matcher::is_register_biasing_candidate(const MachNode* mdef, int oper_index) {\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2636,1 +2636,1 @@\n-bool Matcher::is_register_biasing_candidate(const MachNode* mdef, int biasing_candidate, int oper_index) {\n+bool Matcher::is_register_biasing_candidate(const MachNode* mdef, int oper_index) {\n@@ -2649,4 +2649,0 @@\n-  \/\/ Demotion candidate must be register mask compatible with definition.\n-  if (!mdef->in_RegMask(mdef->operand_index(oper_index)).overlap(mdef->out_RegMask())) {\n-    return false;\n-  }\n@@ -2654,1 +2650,2 @@\n-  switch (biasing_candidate) {\n+  bool res = false;\n+  switch (oper_index) {\n@@ -2662,1 +2659,1 @@\n-      return (((mdef->flags() & Node::PD::Flag_ndd_demotable) != 0) ||\n+      res = (((mdef->flags() & Node::PD::Flag_ndd_demotable) != 0) ||\n@@ -2664,0 +2661,1 @@\n+\n@@ -2665,0 +2663,1 @@\n+    break;\n@@ -2669,1 +2668,1 @@\n-      return ((mdef->flags() & Node::PD::Flag_ndd_demotable_commutative) != 0);\n+      res = ((mdef->flags() & Node::PD::Flag_ndd_demotable_commutative) != 0);\n@@ -2671,0 +2670,1 @@\n+    break;\n@@ -2673,1 +2673,9 @@\n-    default: return false;\n+    default: {\n+      assert(false, \"unhandled operand index\");\n+    }\n+    break;\n+  }\n+\n+  if (res) {\n+    \/\/ Demotion candidate must be register mask compatible with definition.\n+    assert(mdef->in_RegMask(mdef->operand_index(oper_index)).overlap(mdef->out_RegMask()), \"sanity\");\n@@ -2676,1 +2684,1 @@\n-  return false;\n+  return res;\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1474,19 +1474,37 @@\n-OptoReg::Name PhaseChaitin::select_bias_lrg_color(LRG& lrg, uint bias_lrg) {\n-  if (bias_lrg != 0) {\n-    \/\/ If bias_lrg has a color\n-    if (!_ifg->_yanked->test(bias_lrg)) {\n-      OptoReg::Name reg = lrgs(bias_lrg).reg();\n-      \/\/  And it is legal for lrg\n-      if (is_legal_reg(lrg, reg)) {\n-        return reg;\n-      }\n-    } else if (!lrg.mask().is_offset()) {\n-      \/\/ Choose a color which is legal for bias_lrg\n-      ResourceMark rm(C->regmask_arena());\n-      RegMask tempmask(lrg.mask(), C->regmask_arena());\n-      tempmask.and_with(lrgs(bias_lrg).mask());\n-      tempmask.clear_to_sets(lrg.num_regs());\n-      OptoReg::Name reg = find_first_set(lrg, tempmask);\n-      if (OptoReg::is_valid(reg)) {\n-        return reg;\n-      }\n+OptoReg::Name PhaseChaitin::select_bias_lrg_color(LRG &lrg) {\n+  uint bias_lrg1_idx = lrg._copy_bias;\n+  uint bias_lrg2_idx = lrg._copy_bias2;\n+\n+  \/\/ If bias_lrg1 has a color\n+  if (bias_lrg1_idx != 0 && !_ifg->_yanked->test(bias_lrg1_idx)) {\n+    OptoReg::Name reg = lrgs(bias_lrg1_idx).reg();\n+    \/\/  And it is legal for lrg\n+    if (is_legal_reg(lrg, reg)) {\n+      return reg;\n+    }\n+  \/\/ If bias_lrg2 has a color\n+  } else if (bias_lrg2_idx != 0 && !_ifg->_yanked->test(bias_lrg2_idx)) {\n+    OptoReg::Name reg = lrgs(bias_lrg2_idx).reg();\n+    \/\/  And it is legal for lrg\n+    if (is_legal_reg(lrg, reg)) {\n+      return reg;\n+    }\n+  } else if (!lrg.mask().is_offset()) {\n+    \/\/ Since both the bias live ranges are not part of IFG yet,\n+    \/\/ hence constrain the definition mask with the bias\n+    \/\/ live range with minimum degree of freedom, this will enhance\n+    \/\/ the chances of register sharing once the bias live range\n+    \/\/ becomes the part of IFG.\n+    uint bias_lrg = lrgs(bias_lrg1_idx).degrees_of_freedom() >\n+                            lrgs(bias_lrg2_idx).degrees_of_freedom()\n+                        ? bias_lrg2_idx\n+                        : bias_lrg1_idx;\n+\n+    \/\/ Choose a color which is legal for bias_lrg\n+    ResourceMark rm(C->regmask_arena());\n+    RegMask tempmask(lrg.mask(), C->regmask_arena());\n+    tempmask.and_with(lrgs(bias_lrg).mask());\n+    tempmask.clear_to_sets(lrg.num_regs());\n+    OptoReg::Name reg = find_first_set(lrg, tempmask);\n+    if (OptoReg::is_valid(reg)) {\n+      return reg;\n@@ -1519,11 +1537,3 @@\n-  \/\/ Try biasing the color with non-interfering first input's lrg.\n-  uint copy_lrg = _lrg_map.find(lrg._copy_bias);\n-  OptoReg::Name reg = select_bias_lrg_color(lrg, copy_lrg);\n-  if (reg != OptoReg::Bad) {\n-    return reg;\n-  }\n-  \/\/ For commutative operations, try biasing the color with non-interfering\n-  \/\/ second input's lrg.\n-  copy_lrg = _lrg_map.find(lrg._copy_bias2);\n-  reg = select_bias_lrg_color(lrg, copy_lrg);\n-  if (reg != OptoReg::Bad) {\n+  \/\/ Try biasing the color with non-interfering bias live range[s].\n+  OptoReg::Name reg = select_bias_lrg_color(lrg);\n+  if (OptoReg::is_valid(reg)) {\n@@ -1662,14 +1672,6 @@\n-    MachNode* mdef = lrg->is_singledef() && !lrg->_is_bound && def->is_Mach() ? def->as_Mach() : nullptr;\n-    if (mdef != nullptr) {\n-      int i = 1;\n-      uint lrg_def = _lrg_map.find(def);\n-      for (; i < mdef->num_opnds(); i++) {\n-        if (Matcher::is_register_biasing_candidate(mdef, 1, i)) {\n-          Node* in1 = mdef->in(mdef->operand_index(i));\n-          if (in1 != nullptr) {\n-            uint lrg_in1 = _lrg_map.find(in1);\n-            if (lrg_in1 != 0 && lrg->_copy_bias == 0 && !_ifg->test_edge_sq(lrg_def, lrg_in1)) {\n-              lrg->_copy_bias = lrg_in1;\n-              break;\n-            }\n-          }\n+    if (lrg->is_singledef() && !lrg->_is_bound && def->is_Mach()) {\n+      MachNode* mdef = def->as_Mach();\n+      if (Matcher::is_register_biasing_candidate(mdef, 1)) {\n+        Node* in1 = mdef->in(mdef->operand_index(1));\n+        if (in1 != nullptr && lrg->_copy_bias == 0) {\n+          lrg->_copy_bias = _lrg_map.find(in1);\n@@ -1681,10 +1683,4 @@\n-      for (; i < mdef->num_opnds(); i++) {\n-        if (Matcher::is_register_biasing_candidate(mdef, 2, i)) {\n-          Node* in2 = mdef->in(mdef->operand_index(i));\n-          if (in2 != nullptr) {\n-            uint lrg_in2 = _lrg_map.find(in2);\n-            if (lrg_in2 != 0 && lrg->_copy_bias == 0 && !_ifg->test_edge_sq(lrg_def, lrg_in2)) {\n-              lrg->_copy_bias2 = lrg_in2;\n-              break;\n-            }\n-          }\n+      if (Matcher::is_register_biasing_candidate(mdef, 2)) {\n+        Node* in2 = mdef->in(mdef->operand_index(2));\n+        if (in2 != nullptr && lrg->_copy_bias2 == 0) {\n+          lrg->_copy_bias2 = _lrg_map.find(in2);\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":50,"deletions":54,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -708,1 +708,1 @@\n-  OptoReg::Name select_bias_lrg_color(LRG& lrg, uint bias_lrg);\n+  OptoReg::Name select_bias_lrg_color(LRG& lrg);\n","filename":"src\/hotspot\/share\/opto\/chaitin.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -509,1 +509,1 @@\n-  static bool is_register_biasing_candidate(const MachNode* mdef, int biasing_candidate, int oper_index);\n+  static bool is_register_biasing_candidate(const MachNode* mdef, int oper_index);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}