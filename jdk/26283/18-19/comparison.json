{"files":[{"patch":"@@ -144,1 +144,1 @@\n-    Label detect_486, cpu486, detect_586, std_cpuid1, std_cpuid4, std_cpuid24, std_cpuid29;\n+    Label detect_486, cpu486, detect_586, std_cpuid1, std_cpuid4, std_cpuid24;\n@@ -343,10 +343,0 @@\n-    \/\/\n-    \/\/ cpuid(0x29) APX NCI NDD NF (EAX = 29H, ECX = 0).\n-    \/\/\n-    __ bind(std_cpuid29);\n-    __ movl(rax, 0x29);\n-    __ movl(rcx, 0);\n-    __ cpuid();\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version::std_cpuid29_offset())));\n-    __ movl(Address(rsi, 0), rbx);\n-\n@@ -2920,2 +2910,1 @@\n-      xem_xcr0_eax.bits.apx_f != 0 &&\n-      std_cpuid29_ebx.bits.apx_nci_ndd_nf != 0) {\n+      xem_xcr0_eax.bits.apx_f != 0) {\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -309,8 +309,0 @@\n-  union StdCpuidEax29Ecx0 {\n-    uint32_t value;\n-    struct {\n-      uint32_t  apx_nci_ndd_nf  : 1,\n-                                : 31;\n-    } bits;\n-  };\n-\n@@ -602,4 +594,0 @@\n-    \/\/ cpuid function 0x29 APX Advanced Performance Extensions Leaf\n-    \/\/ eax = 0x29, ecx = 0\n-    StdCpuidEax29Ecx0 std_cpuid29_ebx;\n-\n@@ -726,1 +714,0 @@\n-  static ByteSize std_cpuid29_offset() { return byte_offset_of(CpuidInfo, std_cpuid29_ebx); }\n@@ -776,3 +763,1 @@\n-  static void set_apx_cpuFeatures() {\n-    _features.set_feature(CPU_APX_F);\n-  }\n+  static void set_apx_cpuFeatures() { _features.set_feature(CPU_APX_F); }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2637,2 +2637,1 @@\n-  return (((mdef->flags() & Node::PD::Flag_ndd_demotable) != 0) ||\n-          ((mdef->flags() & Node::PD::Flag_ndd_demotable_commutative) != 0));\n+  return ((mdef->flags() & Node::PD::Flag_ndd_demotable) != 0);\n@@ -2641,4 +2640,7 @@\n-bool Matcher::is_register_biasing_candidate(const MachNode* mdef, int oper_index) {\n-  if (mdef == nullptr) {\n-    return false;\n-  }\n+static bool is_ndd_demotable_commutative(const MachNode* mdef) {\n+  return ((mdef->flags() & Node::PD::Flag_ndd_demotable_commutative) != 0);\n+}\n+\n+static bool is_demotion_candidate(const MachNode* mdef) {\n+  return (is_ndd_demotable(mdef) || is_ndd_demotable_commutative(mdef));\n+}\n@@ -2646,3 +2648,3 @@\n-  if (mdef->num_opnds() <= oper_index ||\n-      mdef->operand_index(oper_index) < 0 ||\n-      mdef->in(mdef->operand_index(oper_index)) != nullptr) {\n+bool Matcher::is_register_biasing_candidate(const MachNode* mdef,\n+                                            int oper_index) {\n+  if (mdef == nullptr) {\n@@ -2652,4 +2654,4 @@\n-  \/\/ Demotion candidate must be register mask compatible with definition.\n-  const RegMask& oper_mask = mdef->in_RegMask(mdef->operand_index(oper_index));\n-  if (!oper_mask.overlap(mdef->out_RegMask())) {\n-    assert(!is_ndd_demotable(mdef), \"%s\", mdef->Name());\n+  if (mdef->num_opnds() <= oper_index || mdef->operand_index(oper_index) < 0 ||\n+      mdef->in(mdef->operand_index(oper_index)) == nullptr) {\n+    assert(oper_index != 1 || !is_demotion_candidate(mdef), \"%s\", mdef->Name());\n+    assert(oper_index != 2 || !is_ndd_demotable_commutative(mdef), \"%s\", mdef->Name());\n@@ -2663,0 +2665,8 @@\n+    assert(!is_ndd_demotable(mdef), \"%s\", mdef->Name());\n+    return false;\n+  }\n+\n+  \/\/ Demotion candidate must be register mask compatible with definition.\n+  const RegMask &oper_mask = mdef->in_RegMask(mdef->operand_index(oper_index));\n+  if (!oper_mask.overlap(mdef->out_RegMask())) {\n+    assert(!is_demotion_candidate(mdef), \"%s\", mdef->Name());\n@@ -2667,13 +2677,18 @@\n-    \/\/ First operand of MachNode corresponding to Intel APX NDD selection\n-    \/\/ pattern can share its assigned register with definition operand if\n-    \/\/ their live ranges do not overlap. In such a scenario we can demote\n-    \/\/ it to legacy map0\/map1 instruction by replacing its 4-byte extended\n-    \/\/ EVEX prefix with shorter REX\/REX2 encoding. Demotion candidates\n-    \/\/ are decorated with a special flag by instruction selector.\n-    case 1: return is_ndd_demotable(mdef);\n-\n-    \/\/ Definition operand of commutative operation can be biased towards second operand.\n-    case 2: return (mdef->flags() & Node::PD::Flag_ndd_demotable_commutative) != 0;\n-\n-    \/\/ Current scheme only selects up to two biaising candidates\n-    default: assert(false, \"unhandled operand index: %s\", mdef->Name()); break;\n+  \/\/ First operand of MachNode corresponding to Intel APX NDD selection\n+  \/\/ pattern can share its assigned register with definition operand if\n+  \/\/ their live ranges do not overlap. In such a scenario we can demote\n+  \/\/ it to legacy map0\/map1 instruction by replacing its 4-byte extended\n+  \/\/ EVEX prefix with shorter REX\/REX2 encoding. Demotion candidates\n+  \/\/ are decorated with a special flag by instruction selector.\n+  case 1:\n+    return is_demotion_candidate(mdef);\n+\n+  \/\/ Definition operand of commutative operation can be biased towards second\n+  \/\/ operand.\n+  case 2:\n+    return (mdef->flags() & Node::PD::Flag_ndd_demotable_commutative) != 0;\n+\n+  \/\/ Current scheme only selects up to two biaising candidates\n+  default:\n+    assert(false, \"unhandled operand index: %s\", mdef->Name());\n+    break;\n@@ -14003,1 +14018,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":42,"deletions":27,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -1475,2 +1475,2 @@\n-  uint bias_lrg1_idx = lrg._copy_bias;\n-  uint bias_lrg2_idx = lrg._copy_bias2;\n+  uint bias_lrg1_idx = _lrg_map.find(lrg._copy_bias);\n+  uint bias_lrg2_idx = _lrg_map.find(lrg._copy_bias2);\n@@ -1496,1 +1496,2 @@\n-  if (!lrg.mask().is_offset()) {\n+  uint bias_lrg_idx = 0;\n+  if (bias_lrg1_idx != 0 && bias_lrg2_idx != 0) {\n@@ -1504,4 +1505,9 @@\n-    uint bias_lrg = lrgs(bias_lrg1_idx).degrees_of_freedom() >\n-                            lrgs(bias_lrg2_idx).degrees_of_freedom()\n-                        ? bias_lrg2_idx\n-                        : bias_lrg1_idx;\n+    bias_lrg_idx = lrgs(bias_lrg1_idx).degrees_of_freedom() >\n+                           lrgs(bias_lrg2_idx).degrees_of_freedom()\n+                       ? bias_lrg2_idx\n+                       : bias_lrg1_idx;\n+  } else if (bias_lrg1_idx != 0) {\n+    bias_lrg_idx = bias_lrg1_idx;\n+  } else if (bias_lrg2_idx != 0) {\n+    bias_lrg_idx = bias_lrg2_idx;\n+  }\n@@ -1509,0 +1515,6 @@\n+  \/\/ RegisterMask with offset sets all the mask bits before offset.\n+  \/\/ It's mainly used for allocation from stack slots. Constrain the\n+  \/\/ register mask of definition live range using bias mask only if\n+  \/\/ both masks have zero offset.\n+  if (bias_lrg_idx != 0 && !lrg.mask().is_offset() &&\n+      !lrgs(bias_lrg_idx).mask().is_offset()) {\n@@ -1512,1 +1524,1 @@\n-    tempmask.and_with(lrgs(bias_lrg).mask());\n+    tempmask.and_with(lrgs(bias_lrg_idx).mask());\n@@ -1544,5 +1556,3 @@\n-  if (lrg._copy_bias != 0 || lrg._copy_bias2 != 0) {\n-    OptoReg::Name reg = select_bias_lrg_color(lrg);\n-    if (OptoReg::is_valid(reg)) {\n-      return reg;\n-    }\n+  OptoReg::Name reg = select_bias_lrg_color(lrg);\n+  if (OptoReg::is_valid(reg)) {\n+    return reg;\n@@ -1562,1 +1572,1 @@\n-  OptoReg::Name reg = lrg.mask().find_first_elem();\n+  reg = lrg.mask().find_first_elem();\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":24,"deletions":14,"binary":false,"changes":38,"status":"modified"}]}