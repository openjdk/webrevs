{"files":[{"patch":"@@ -2476,0 +2476,4 @@\n+bool Matcher::is_register_biasing_candidate(const MachNode* mdef, int oper_index) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1079,0 +1079,4 @@\n+bool Matcher::is_register_biasing_candidate(const MachNode* mdef, int oper_index) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2393,0 +2393,4 @@\n+bool Matcher::is_register_biasing_candidate(const MachNode* mdef, int oper_index) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2073,0 +2073,4 @@\n+bool Matcher::is_register_biasing_candidate(const MachNode* mdef, int oper_index) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1896,0 +1896,4 @@\n+bool Matcher::is_register_biasing_candidate(const MachNode* mdef, int oper_index) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-    Label detect_486, cpu486, detect_586, std_cpuid1, std_cpuid4, std_cpuid24, std_cpuid29;\n+    Label detect_486, cpu486, detect_586, std_cpuid1, std_cpuid4, std_cpuid24;\n@@ -343,10 +343,0 @@\n-    \/\/\n-    \/\/ cpuid(0x29) APX NCI NDD NF (EAX = 29H, ECX = 0).\n-    \/\/\n-    __ bind(std_cpuid29);\n-    __ movl(rax, 0x29);\n-    __ movl(rcx, 0);\n-    __ cpuid();\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version::std_cpuid29_offset())));\n-    __ movl(Address(rsi, 0), rbx);\n-\n@@ -2920,2 +2910,1 @@\n-      xem_xcr0_eax.bits.apx_f != 0 &&\n-      std_cpuid29_ebx.bits.apx_nci_ndd_nf != 0) {\n+      xem_xcr0_eax.bits.apx_f != 0) {\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -309,8 +309,0 @@\n-  union StdCpuidEax29Ecx0 {\n-    uint32_t value;\n-    struct {\n-      uint32_t  apx_nci_ndd_nf  : 1,\n-                                : 31;\n-    } bits;\n-  };\n-\n@@ -602,4 +594,0 @@\n-    \/\/ cpuid function 0x29 APX Advanced Performance Extensions Leaf\n-    \/\/ eax = 0x29, ecx = 0\n-    StdCpuidEax29Ecx0 std_cpuid29_ebx;\n-\n@@ -726,1 +714,0 @@\n-  static ByteSize std_cpuid29_offset() { return byte_offset_of(CpuidInfo, std_cpuid29_ebx); }\n@@ -776,3 +763,1 @@\n-  static void set_apx_cpuFeatures() {\n-    _features.set_feature(CPU_APX_F);\n-  }\n+  static void set_apx_cpuFeatures() { _features.set_feature(CPU_APX_F); }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2636,0 +2636,64 @@\n+static bool is_ndd_demotable(const MachNode* mdef) {\n+  return ((mdef->flags() & Node::PD::Flag_ndd_demotable) != 0);\n+}\n+\n+static bool is_ndd_demotable_commutative(const MachNode* mdef) {\n+  return ((mdef->flags() & Node::PD::Flag_ndd_demotable_commutative) != 0);\n+}\n+\n+static bool is_demotion_candidate(const MachNode* mdef) {\n+  return (is_ndd_demotable(mdef) || is_ndd_demotable_commutative(mdef));\n+}\n+\n+bool Matcher::is_register_biasing_candidate(const MachNode* mdef,\n+                                            int oper_index) {\n+  if (mdef == nullptr) {\n+    return false;\n+  }\n+\n+  if (mdef->num_opnds() <= oper_index || mdef->operand_index(oper_index) < 0 ||\n+      mdef->in(mdef->operand_index(oper_index)) == nullptr) {\n+    assert(oper_index != 1 || !is_demotion_candidate(mdef), \"%s\", mdef->Name());\n+    assert(oper_index != 2 || !is_ndd_demotable_commutative(mdef), \"%s\", mdef->Name());\n+    return false;\n+  }\n+\n+  \/\/ Complex memory operand covers multiple incoming edges needed for\n+  \/\/ address computation, biasing def towards any address component will not\n+  \/\/ result into NDD demotion by assembler.\n+  if (mdef->operand_num_edges(oper_index) != 1) {\n+    assert(!is_ndd_demotable(mdef), \"%s\", mdef->Name());\n+    return false;\n+  }\n+\n+  \/\/ Demotion candidate must be register mask compatible with definition.\n+  const RegMask &oper_mask = mdef->in_RegMask(mdef->operand_index(oper_index));\n+  if (!oper_mask.overlap(mdef->out_RegMask())) {\n+    assert(!is_demotion_candidate(mdef), \"%s\", mdef->Name());\n+    return false;\n+  }\n+\n+  switch (oper_index) {\n+  \/\/ First operand of MachNode corresponding to Intel APX NDD selection\n+  \/\/ pattern can share its assigned register with definition operand if\n+  \/\/ their live ranges do not overlap. In such a scenario we can demote\n+  \/\/ it to legacy map0\/map1 instruction by replacing its 4-byte extended\n+  \/\/ EVEX prefix with shorter REX\/REX2 encoding. Demotion candidates\n+  \/\/ are decorated with a special flag by instruction selector.\n+  case 1:\n+    return is_demotion_candidate(mdef);\n+\n+  \/\/ Definition operand of commutative operation can be biased towards second\n+  \/\/ operand.\n+  case 2:\n+    return (mdef->flags() & Node::PD::Flag_ndd_demotable_commutative) != 0;\n+\n+  \/\/ Current scheme only selects up to two biaising candidates\n+  default:\n+    assert(false, \"unhandled operand index: %s\", mdef->Name());\n+    break;\n+  }\n+\n+  return false;\n+}\n+\n@@ -2825,1 +2889,1 @@\n-  enum NodeFlags {\n+  enum NodeFlags : uint64_t {\n@@ -2837,1 +2901,3 @@\n-    _last_flag                = Flag_clears_sign_flag\n+    Flag_ndd_demotable        = Node::_last_flag << 12,\n+    Flag_ndd_demotable_commutative = Node::_last_flag << 13,\n+    _last_flag                = Flag_ndd_demotable_commutative\n@@ -9828,1 +9894,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_commutative);\n@@ -9856,1 +9922,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n@@ -9899,1 +9965,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_commutative);\n@@ -9956,0 +10022,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -10010,0 +10077,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -10116,1 +10184,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_commutative);\n@@ -10144,1 +10212,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n@@ -10187,1 +10255,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_commutative);\n@@ -10243,0 +10311,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -10297,0 +10366,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -11011,1 +11081,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n@@ -11025,1 +11095,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n@@ -11068,1 +11138,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n@@ -11126,1 +11196,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n@@ -11140,1 +11210,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n@@ -11183,1 +11253,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n@@ -11255,1 +11325,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n@@ -11283,1 +11353,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n@@ -11324,1 +11394,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n@@ -11352,1 +11422,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n@@ -11397,0 +11467,1 @@\n+  flag(PD::Flag_ndd_demotable_commutative);\n@@ -11438,0 +11509,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -11489,0 +11561,1 @@\n+  flag(PD::Flag_ndd_demotable_commutative);\n@@ -11530,0 +11603,1 @@\n+  flag(PD::Flag_ndd_demotable_commutative);\n@@ -11804,0 +11878,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -11832,0 +11907,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -11938,0 +12014,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -12044,0 +12121,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -12151,0 +12229,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -12179,0 +12258,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -12285,0 +12365,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -12391,0 +12472,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -12562,0 +12644,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -12626,0 +12709,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -12678,0 +12762,1 @@\n+\n@@ -12691,0 +12776,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -12755,0 +12841,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -12832,1 +12919,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n@@ -12925,1 +13012,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n@@ -12969,1 +13056,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n@@ -13169,1 +13256,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n@@ -13198,1 +13285,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n@@ -13212,1 +13299,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n@@ -13256,1 +13343,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n@@ -13332,1 +13419,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n@@ -13358,0 +13445,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -13388,1 +13476,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n@@ -13434,1 +13522,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n@@ -13513,1 +13601,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n@@ -13569,1 +13657,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n@@ -13613,1 +13701,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n@@ -13816,1 +13904,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n@@ -13871,1 +13959,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n@@ -13885,1 +13973,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n@@ -13930,1 +14018,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n@@ -14009,1 +14097,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n@@ -14035,0 +14123,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -14065,1 +14154,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n@@ -14111,1 +14200,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n@@ -16566,0 +16655,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -16617,0 +16707,1 @@\n+  flag(PD::Flag_ndd_demotable);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":129,"deletions":38,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -1474,0 +1474,60 @@\n+OptoReg::Name PhaseChaitin::select_bias_lrg_color(LRG &lrg) {\n+  uint bias_lrg1_idx = _lrg_map.find(lrg._copy_bias);\n+  uint bias_lrg2_idx = _lrg_map.find(lrg._copy_bias2);\n+\n+  \/\/ If bias_lrg1 has a color\n+  if (bias_lrg1_idx != 0 && !_ifg->_yanked->test(bias_lrg1_idx)) {\n+    OptoReg::Name reg = lrgs(bias_lrg1_idx).reg();\n+    \/\/  And it is legal for lrg\n+    if (is_legal_reg(lrg, reg)) {\n+      return reg;\n+    }\n+  }\n+\n+  \/\/ If bias_lrg2 has a color\n+  if (bias_lrg2_idx != 0 && !_ifg->_yanked->test(bias_lrg2_idx)) {\n+    OptoReg::Name reg = lrgs(bias_lrg2_idx).reg();\n+    \/\/  And it is legal for lrg\n+    if (is_legal_reg(lrg, reg)) {\n+      return reg;\n+    }\n+  }\n+\n+  uint bias_lrg_idx = 0;\n+  if (bias_lrg1_idx != 0 && bias_lrg2_idx != 0) {\n+    \/\/ Since both the bias live ranges are not part of IFG yet,\n+    \/\/ hence constrain the definition mask with the bias\n+    \/\/ live range with minimum degree of freedom, this will\n+    \/\/ enhance the chances of register sharing once the bias\n+    \/\/ live range becomes the part of IFG.\n+    lrgs(bias_lrg1_idx).compute_set_mask_size();\n+    lrgs(bias_lrg2_idx).compute_set_mask_size();\n+    bias_lrg_idx = lrgs(bias_lrg1_idx).degrees_of_freedom() >\n+                           lrgs(bias_lrg2_idx).degrees_of_freedom()\n+                       ? bias_lrg2_idx\n+                       : bias_lrg1_idx;\n+  } else if (bias_lrg1_idx != 0) {\n+    bias_lrg_idx = bias_lrg1_idx;\n+  } else if (bias_lrg2_idx != 0) {\n+    bias_lrg_idx = bias_lrg2_idx;\n+  }\n+\n+  \/\/ RegisterMask with offset sets all the mask bits before offset.\n+  \/\/ It's mainly used for allocation from stack slots. Constrain the\n+  \/\/ register mask of definition live range using bias mask only if\n+  \/\/ both masks have zero offset.\n+  if (bias_lrg_idx != 0 && !lrg.mask().is_offset() &&\n+      !lrgs(bias_lrg_idx).mask().is_offset()) {\n+    \/\/ Choose a color which is legal for bias_lrg\n+    ResourceMark rm(C->regmask_arena());\n+    RegMask tempmask(lrg.mask(), C->regmask_arena());\n+    tempmask.and_with(lrgs(bias_lrg_idx).mask());\n+    tempmask.clear_to_sets(lrg.num_regs());\n+    OptoReg::Name reg = find_first_set(lrg, tempmask);\n+    if (OptoReg::is_valid(reg)) {\n+      return reg;\n+    }\n+  }\n+  return OptoReg::Bad;\n+}\n+\n@@ -1495,19 +1555,4 @@\n-  uint copy_lrg = _lrg_map.find(lrg._copy_bias);\n-  if (copy_lrg != 0) {\n-    \/\/ If he has a color,\n-    if(!_ifg->_yanked->test(copy_lrg)) {\n-      OptoReg::Name reg = lrgs(copy_lrg).reg();\n-      \/\/  And it is legal for you,\n-      if (is_legal_reg(lrg, reg)) {\n-        return reg;\n-      }\n-    } else if (!lrg.mask().is_offset()) {\n-      \/\/ Choose a color which is legal for him\n-      ResourceMark rm(C->regmask_arena());\n-      RegMask tempmask(lrg.mask(), C->regmask_arena());\n-      tempmask.and_with(lrgs(copy_lrg).mask());\n-      tempmask.clear_to_sets(lrg.num_regs());\n-      OptoReg::Name reg = find_first_set(lrg, tempmask);\n-      if (OptoReg::is_valid(reg))\n-        return reg;\n-    }\n+  \/\/ Try biasing the color with non-interfering bias live range[s].\n+  OptoReg::Name reg = select_bias_lrg_color(lrg);\n+  if (OptoReg::is_valid(reg)) {\n+    return reg;\n@@ -1527,1 +1572,1 @@\n-  OptoReg::Name reg = lrg.mask().find_first_elem();\n+  reg = lrg.mask().find_first_elem();\n@@ -1643,0 +1688,21 @@\n+\n+    Node* def = lrg->_def;\n+    if (lrg->is_singledef() && !lrg->_is_bound && def->is_Mach()) {\n+      MachNode* mdef = def->as_Mach();\n+      if (Matcher::is_register_biasing_candidate(mdef, 1)) {\n+        Node* in1 = mdef->in(mdef->operand_index(1));\n+        if (in1 != nullptr && lrg->_copy_bias == 0) {\n+          lrg->_copy_bias = _lrg_map.find(in1);\n+        }\n+      }\n+\n+      \/\/ For commutative operation, def allocation can also be\n+      \/\/ biased towards LRG of second input's def.\n+      if (Matcher::is_register_biasing_candidate(mdef, 2)) {\n+        Node* in2 = mdef->in(mdef->operand_index(2));\n+        if (in2 != nullptr && lrg->_copy_bias2 == 0) {\n+          lrg->_copy_bias2 = _lrg_map.find(in2);\n+        }\n+      }\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":86,"deletions":20,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+  uint _copy_bias2;             \/\/ Index of second LRG which we want to share color\n@@ -706,0 +707,2 @@\n+  \/\/ Helper function which implements color biasing\n+  OptoReg::Name select_bias_lrg_color(LRG& lrg);\n","filename":"src\/hotspot\/share\/opto\/chaitin.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1126,0 +1126,3 @@\n+      if (lrg._copy_bias2 != 0) {\n+        print_prop(\"copy_bias2\", lrg._copy_bias2);\n+      }\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -463,0 +463,7 @@\n+int MachNode::operand_num_edges(uint oper_index) const {\n+  if (num_opnds() > oper_index) {\n+    return _opnds[oper_index]->num_edges();\n+  }\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -269,0 +269,1 @@\n+  int  operand_num_edges(uint operand) const;\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -509,0 +509,2 @@\n+  static bool is_register_biasing_candidate(const MachNode* mdef, int oper_index);\n+\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -831,20 +831,20 @@\n-  enum NodeFlags {\n-    Flag_is_Copy                     = 1 << 0, \/\/ should be first bit to avoid shift\n-    Flag_rematerialize               = 1 << 1,\n-    Flag_needs_anti_dependence_check = 1 << 2,\n-    Flag_is_macro                    = 1 << 3,\n-    Flag_is_Con                      = 1 << 4,\n-    Flag_is_cisc_alternate           = 1 << 5,\n-    Flag_is_dead_loop_safe           = 1 << 6,\n-    Flag_may_be_short_branch         = 1 << 7,\n-    Flag_avoid_back_to_back_before   = 1 << 8,\n-    Flag_avoid_back_to_back_after    = 1 << 9,\n-    Flag_has_call                    = 1 << 10,\n-    Flag_has_swapped_edges           = 1 << 11,\n-    Flag_is_scheduled                = 1 << 12,\n-    Flag_is_expensive                = 1 << 13,\n-    Flag_is_predicated_vector        = 1 << 14,\n-    Flag_for_post_loop_opts_igvn     = 1 << 15,\n-    Flag_for_merge_stores_igvn       = 1 << 16,\n-    Flag_is_removed_by_peephole      = 1 << 17,\n-    Flag_is_predicated_using_blend   = 1 << 18,\n+  enum NodeFlags : uint64_t {\n+    Flag_is_Copy                     = 1ULL << 0, \/\/ should be first bit to avoid shift\n+    Flag_rematerialize               = 1ULL << 1,\n+    Flag_needs_anti_dependence_check = 1ULL << 2,\n+    Flag_is_macro                    = 1ULL << 3,\n+    Flag_is_Con                      = 1ULL << 4,\n+    Flag_is_cisc_alternate           = 1ULL << 5,\n+    Flag_is_dead_loop_safe           = 1ULL << 6,\n+    Flag_may_be_short_branch         = 1ULL << 7,\n+    Flag_avoid_back_to_back_before   = 1ULL << 8,\n+    Flag_avoid_back_to_back_after    = 1ULL << 9,\n+    Flag_has_call                    = 1ULL << 10,\n+    Flag_has_swapped_edges           = 1ULL << 11,\n+    Flag_is_scheduled                = 1ULL << 12,\n+    Flag_is_expensive                = 1ULL << 13,\n+    Flag_is_predicated_vector        = 1ULL << 14,\n+    Flag_for_post_loop_opts_igvn     = 1ULL << 15,\n+    Flag_for_merge_stores_igvn       = 1ULL << 16,\n+    Flag_is_removed_by_peephole      = 1ULL << 17,\n+    Flag_is_predicated_using_blend   = 1ULL << 18,\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"}]}