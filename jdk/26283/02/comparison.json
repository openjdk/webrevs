{"files":[{"patch":"@@ -1471,0 +1471,23 @@\n+OptoReg::Name PhaseChaitin::select_bias_lrg_color(LRG& lrg, uint bias_lrg, int chunk) {\n+  if (bias_lrg != 0) {\n+    \/\/ If bias lrg has a color.\n+    if(!_ifg->_yanked->test(bias_lrg)) {\n+      OptoReg::Name reg = lrgs(bias_lrg).reg();\n+      \/\/  And it is legal for you,\n+      if (is_legal_reg(lrg, reg, chunk)) {\n+        return reg;\n+      }\n+    } else if( chunk == 0 ) {\n+      \/\/ Choose a color which is legal for him\n+      RegMask tempmask = lrg.mask();\n+      tempmask.AND(lrgs(bias_lrg).mask());\n+      tempmask.clear_to_sets(lrg.num_regs());\n+      OptoReg::Name reg = find_first_set(lrg, tempmask, chunk);\n+      if (OptoReg::is_valid(reg)) {\n+        return reg;\n+      }\n+    }\n+  }\n+  return OptoReg::Bad;\n+}\n+\n@@ -1491,0 +1514,1 @@\n+  \/\/ Try biasing the color with non-interfering first input's lrg.\n@@ -1492,16 +1516,10 @@\n-  if (copy_lrg != 0) {\n-    \/\/ If he has a color,\n-    if(!_ifg->_yanked->test(copy_lrg)) {\n-      OptoReg::Name reg = lrgs(copy_lrg).reg();\n-      \/\/  And it is legal for you,\n-      if (is_legal_reg(lrg, reg, chunk))\n-        return reg;\n-    } else if( chunk == 0 ) {\n-      \/\/ Choose a color which is legal for him\n-      RegMask tempmask = lrg.mask();\n-      tempmask.AND(lrgs(copy_lrg).mask());\n-      tempmask.clear_to_sets(lrg.num_regs());\n-      OptoReg::Name reg = find_first_set(lrg, tempmask, chunk);\n-      if (OptoReg::is_valid(reg))\n-        return reg;\n-    }\n+  OptoReg::Name reg = select_bias_lrg_color(lrg, copy_lrg, chunk);\n+  if (reg != OptoReg::Bad) {\n+    return reg;\n+  }\n+  \/\/ For commutative operations, try biasing the color with non-interfering\n+  \/\/ second input's lrg.\n+  copy_lrg = _lrg_map.find(lrg._copy_bias2);\n+  reg = select_bias_lrg_color(lrg, copy_lrg, chunk);\n+  if (reg != OptoReg::Bad) {\n+    return reg;\n@@ -1519,1 +1537,1 @@\n-  OptoReg::Name reg = lrg.mask().find_first_elem();\n+  reg = lrg.mask().find_first_elem();\n@@ -1632,0 +1650,43 @@\n+\n+    auto is_commutative_oper = [](MachNode* def) {\n+      if (def) {\n+        switch(def->ideal_Opcode()) {\n+          case Op_AddI: case Op_AddL:\n+          case Op_MulI: case Op_MulL:\n+          case Op_XorI: case Op_XorL:\n+          case Op_OrI:  case Op_OrL:\n+          case Op_AndI: case Op_AndL:\n+            return true;\n+          default:\n+            return false;\n+        }\n+      }\n+      return false;\n+    };\n+\n+    Node* def = lrg->_def;\n+    MachNode* mdef = lrg->is_singledef() && !lrg->_is_bound && def->is_Mach() ? def->as_Mach() : nullptr;\n+    if (mdef != nullptr && mdef->req() > 1) {\n+      Node* in1 = mdef->in(mdef->oper_input_base());\n+      if (in1 != nullptr) {\n+        uint lrin1 = _lrg_map.find(in1);\n+        \/\/ If a def does not interfere with first input's def,\n+        \/\/ then bias its color towards its input's def.\n+        if (lrin1 != 0 && lrg->_copy_bias == 0 && _ifg->test_edge_sq(lidx, lrin1) == 0) {\n+          lrg->_copy_bias = lrin1;\n+        }\n+      }\n+    }\n+\n+    if (is_commutative_oper(mdef) && mdef->req() > 2) {\n+      Node* in2 = mdef->in(mdef->oper_input_base() + 1);\n+      if (in2 != nullptr) {\n+        uint lrin2 = _lrg_map.find(in2);\n+        \/\/ If a def does not interfere with second input's def,\n+        \/\/ then bias its color towards its input's def.\n+        if (lrin2 != 0 && lrg->_copy_bias2 == 0 && _ifg->test_edge_sq(lidx, lrin2) == 0) {\n+          lrg->_copy_bias2 = lrin2;\n+        }\n+      }\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":78,"deletions":17,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+  uint _copy_bias2;             \/\/ Index of second LRG which we want to share color\n@@ -703,0 +704,2 @@\n+  \/\/ Helper function which implements color biasing\n+  OptoReg::Name select_bias_lrg_color(LRG& lrg, uint bias_lrg, int chunk);\n","filename":"src\/hotspot\/share\/opto\/chaitin.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -306,1 +306,1 @@\n-    @IR(counts = {IRNode.MEM_TO_REG_SPILL_COPY, \"=4\"},\n+    @IR(counts = {IRNode.MEM_TO_REG_SPILL_COPY, \"=3\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestRedundantLea.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}