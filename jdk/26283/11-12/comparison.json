{"files":[{"patch":"@@ -2476,1 +2476,1 @@\n-bool Matcher::should_attempt_register_biasing(const MachNode* mdef, int oper_index) {\n+bool Matcher::is_register_biasing_candidate(const MachNode* mdef, int oper_index) {\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1079,1 +1079,1 @@\n-bool Matcher::should_attempt_register_biasing(const MachNode* mdef, int oper_index) {\n+bool Matcher::is_register_biasing_candidate(const MachNode* mdef, int oper_index) {\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2393,1 +2393,1 @@\n-bool Matcher::should_attempt_register_biasing(const MachNode* mdef, int oper_index) {\n+bool Matcher::is_register_biasing_candidate(const MachNode* mdef, int oper_index) {\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2073,1 +2073,1 @@\n-bool Matcher::should_attempt_register_biasing(const MachNode* mdef, int oper_index) {\n+bool Matcher::is_register_biasing_candidate(const MachNode* mdef, int oper_index) {\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1896,1 +1896,1 @@\n-bool Matcher::should_attempt_register_biasing(const MachNode* mdef, int oper_index) {\n+bool Matcher::is_register_biasing_candidate(const MachNode* mdef, int oper_index) {\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2636,1 +2636,1 @@\n-bool Matcher::should_attempt_register_biasing(const MachNode* mdef, int oper_index) {\n+bool Matcher::is_register_biasing_candidate(const MachNode *mdef, int oper_index) {\n@@ -2641,1 +2641,5 @@\n-  if (mdef->num_opnds() <= oper_index || mdef->operand_index(oper_index) < 0) {\n+  if (mdef->num_opnds() <= oper_index || mdef->operand_index(oper_index) < 0 ||\n+      \/\/ Complex memory operand covers multiple incoming edges needed for\n+      \/\/ address computation, biasing def towards any address component will not\n+      \/\/ result into NDD demotion by assembler.\n+      mdef->operand_num_edges(oper_index) == 1) {\n@@ -2645,6 +2649,20 @@\n-  \/\/ Returns true for MachNode corresponding to Intel APX NDD selection patterns which\n-  \/\/ can be demoted to REX\/REX2 encodings. For commutative operations with register\n-  \/\/ operands, allocation of definition operand is biased towards both the operands.\n-  return (((mdef->flags() & Node::PD::Flag_ndd_demotable) != 0) &&\n-           (oper_index != 2 ||\n-            ((mdef->flags() & Node::PD::Flag_ndd_commutative) != 0)));\n+  \/\/ First operand of MachNode corresponding to Intel APX NDD selection\n+  \/\/ pattern can share its assigned register with definition operand if\n+  \/\/ their live ranges do not overlap, in such a scenario we can demote\n+  \/\/ it to legacy map0\/map1 instruction by replacing its 4-byte extended\n+  \/\/ EVEX prefix with shorter REX\/REX2 encoding. Demotion candidates\n+  \/\/ are decorated with a special flag by instruction selector.\n+  if (oper_index == 1 &&\n+      ((mdef->flags() & Node::PD::Flag_ndd_demotable) != 0)) {\n+    return true;\n+  }\n+\n+  \/\/ For commutative operation allocation of definition\n+  \/\/ operand can also be biased towards second operand.\n+  if (oper_index == 2 &&\n+      ((mdef->flags() & Node::PD::Flag_ndd_commutative) != 0) &&\n+      ((mdef->flags() & Node::PD::Flag_ndd_demotable) != 0)) {\n+    return true;\n+  }\n+\n+  return false;\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":26,"deletions":8,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1663,1 +1663,1 @@\n-    if (Matcher::should_attempt_register_biasing(mdef, 1)) {\n+    if (Matcher::is_register_biasing_candidate(mdef, 1)) {\n@@ -1667,5 +1667,1 @@\n-        \/\/ Complex memory operand covers multiple incoming\n-        \/\/ edges needed for address computation, biasing def\n-        \/\/ towards any address component will not result into\n-        \/\/ NDD demotion by assembler.\n-        if (lrg_in1 != 0 && lrg->_copy_bias == 0 && mdef->operand_num_edges(1) == 1) {\n+        if (lrg_in1 != 0 && lrg->_copy_bias == 0) {\n@@ -1679,1 +1675,1 @@\n-    if (Matcher::should_attempt_register_biasing(mdef, 2)) {\n+    if (Matcher::is_register_biasing_candidate(mdef, 2)) {\n@@ -1683,1 +1679,1 @@\n-        if (lrg_in2 != 0 && lrg->_copy_bias2 == 0 && mdef->operand_num_edges(2) == 1) {\n+        if (lrg_in2 != 0 && lrg->_copy_bias2 == 0) {\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -509,1 +509,1 @@\n-  static bool should_attempt_register_biasing(const MachNode* mdef, int oper_index);\n+  static bool is_register_biasing_candidate(const MachNode* mdef, int oper_index);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}