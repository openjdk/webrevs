{"files":[{"patch":"@@ -155,0 +155,4 @@\n+bool CollectedHeap::contains_null(const oop* p) {\n+  return *p == NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -449,0 +449,6 @@\n+  \/\/ GCs are free to represent the bit representation for null differently in memory,\n+  \/\/ which is typically not observable when using the Access API. However, if for\n+  \/\/ some reason a context doesn't allow using the Access API, then this function\n+  \/\/ explicitly checks if the given memory location contains a null value.\n+  bool contains_null(const oop* p);\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -769,1 +769,1 @@\n-  assert(*entry == nullptr, \"Releasing uncleared entry: \" PTR_FORMAT, p2i(entry));\n+  assert(Universe::heap()->contains_null(entry), \"Releasing uncleared entry: \" PTR_FORMAT, p2i(entry));\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}