{"files":[{"patch":"@@ -29,2 +29,0 @@\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n@@ -32,1 +30,0 @@\n-import java.util.Objects;\n@@ -55,1 +52,2 @@\n-        return SegmentFactories.allocateSegment(byteSize, byteAlignment, session, shouldReserveMemory);\n+        long address = SegmentFactories.allocateNative(byteSize, byteAlignment, session, shouldReserveMemory, false);\n+        return new NativeMemorySegmentImpl(address, byteSize, false, session);\n@@ -60,3 +58,3 @@\n-        NativeMemorySegmentImpl segment = allocateNoInit(byteSize, byteAlignment);\n-        segment.fill((byte)0);\n-        return segment;\n+        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n+        long address = SegmentFactories.allocateNative(byteSize, byteAlignment, session, shouldReserveMemory, true);\n+        return new NativeMemorySegmentImpl(address, byteSize, false, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ArenaImpl.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.internal.vm.annotation.DontInline;\n@@ -178,2 +179,2 @@\n-    public static NativeMemorySegmentImpl allocateSegment(long byteSize, long byteAlignment, MemorySessionImpl sessionImpl,\n-                                                          boolean shouldReserve) {\n+    public static long allocateNative(long byteSize, long byteAlignment, MemorySessionImpl sessionImpl,\n+                                      boolean shouldReserve, boolean init) {\n@@ -185,3 +186,6 @@\n-        long alignedSize = Math.max(1L, byteAlignment > MAX_MALLOC_ALIGN ?\n-                byteSize + (byteAlignment - 1) :\n-                byteSize);\n+        \/\/ Align up to 8 so we can init the memory with longs\n+        long alignedSize = init ? Utils.alignUp(byteSize, Long.BYTES) : byteSize;\n+\n+        if (byteAlignment > MAX_MALLOC_ALIGN) {\n+            return allocateNativeOveraligned(byteSize, byteAlignment, sessionImpl, shouldReserve, init, alignedSize);\n+        }\n@@ -192,5 +196,4 @@\n-\n-        long buf = allocateMemoryWrapper(alignedSize);\n-        long alignedBuf = Utils.alignUp(buf, byteAlignment);\n-        NativeMemorySegmentImpl segment = new NativeMemorySegmentImpl(buf, alignedSize,\n-                false, sessionImpl);\n+        long address = allocateMemoryWrapper(alignedSize);\n+        if (init) {\n+            initNativeMemory(address, alignedSize);\n+        }\n@@ -200,1 +203,1 @@\n-                UNSAFE.freeMemory(buf);\n+                UNSAFE.freeMemory(address);\n@@ -206,3 +209,30 @@\n-        if (alignedSize != byteSize) {\n-            long delta = alignedBuf - buf;\n-            segment = (NativeMemorySegmentImpl) segment.asSlice(delta, byteSize);\n+        return address;\n+    }\n+\n+    @DontInline\n+    private static long allocateNativeOveraligned(long byteSize, long byteAlignment, MemorySessionImpl sessionImpl,\n+                                                  boolean shouldReserve, boolean init, long alignedSize) {\n+        long allocSize = alignedSize + byteAlignment - MAX_MALLOC_ALIGN;\n+        if (shouldReserve) {\n+            AbstractMemorySegmentImpl.NIO_ACCESS.reserveMemory(allocSize, byteSize);\n+        }\n+        long base = allocateMemoryWrapper(allocSize);\n+        long res = Utils.alignUp(base, byteAlignment);\n+        if (init) {\n+            initNativeMemory(res, alignedSize);\n+        }\n+        sessionImpl.addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+            @Override\n+            public void cleanup() {\n+                UNSAFE.freeMemory(base);\n+                if (shouldReserve) {\n+                    AbstractMemorySegmentImpl.NIO_ACCESS.unreserveMemory(allocSize, byteSize);\n+                }\n+            }\n+        });\n+        return res;\n+    }\n+\n+    private static void initNativeMemory(long address, long byteSize) {\n+        for (long i = 0; i < byteSize; i += Long.BYTES) {\n+            UNSAFE.putLongUnaligned(null, address + i, 0);\n@@ -210,1 +240,0 @@\n-        return segment;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentFactories.java","additions":44,"deletions":15,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-    private static boolean pageAlignDirectMemory;\n+    private static Boolean pageAlignDirectMemory;\n@@ -159,1 +159,1 @@\n-        return pageAlignDirectMemory;\n+        return pageAlignDirectMemory != null && pageAlignDirectMemory;\n@@ -264,3 +264,1 @@\n-        s = props.get(\"sun.nio.PageAlignDirectMemory\");\n-        if (\"true\".equals(s))\n-            pageAlignDirectMemory = true;\n+        pageAlignDirectMemory = \"true\".equals(props.get(\"sun.nio.PageAlignDirectMemory\"));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/VM.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,16 +26,1 @@\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.TearDown;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.*;\n@@ -43,2 +28,0 @@\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.ValueLayout;\n@@ -47,0 +30,2 @@\n+import java.util.function.Consumer;\n+import org.openjdk.jmh.annotations.*;\n@@ -56,3 +41,1 @@\n-    Arena arena = Arena.ofConfined();\n-\n-    @Param({\"5\", \"20\", \"100\", \"500\", \"1000\"})\n+    @Param({\"5\", \"20\", \"100\", \"500\", \"2000\", \"8000\"})\n@@ -61,5 +44,0 @@\n-    @TearDown\n-    public void tearDown() {\n-        arena.close();\n-    }\n-\n@@ -67,1 +45,1 @@\n-    public MemorySegment alloc_confined() {\n+    public long alloc_confined() {\n@@ -69,1 +47,1 @@\n-            return arena.allocate(size);\n+            return arena.allocate(size).address();\n@@ -87,6 +65,35 @@\n-    public static class CallocArena implements Arena {\n-\n-        static final MethodHandle CALLOC = Linker.nativeLinker()\n-                .downcallHandle(\n-                        Linker.nativeLinker().defaultLookup().findOrThrow(\"calloc\"),\n-                        FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG));\n+    private static class CallocArena implements Arena {\n+\n+        static final MethodHandle CALLOC;\n+        static final MethodHandle FREE;\n+        static final long ADDRESS_SIZE;\n+        static final Consumer<MemorySegment> CLEANUP;\n+\n+        static {\n+            ADDRESS_SIZE = AddressLayout.ADDRESS.byteSize();\n+            var linker = Linker.nativeLinker();\n+            var lookup = linker.defaultLookup();\n+            var callocAddr = lookup.findOrThrow(\"calloc\");\n+            var freeAddr = lookup.findOrThrow(\"free\");\n+            if (ADDRESS_SIZE == Long.BYTES) {\n+                CALLOC = linker.downcallHandle(callocAddr, FunctionDescriptor.of(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG));\n+                FREE = linker.downcallHandle(freeAddr, FunctionDescriptor.ofVoid(ValueLayout.JAVA_LONG));\n+                CLEANUP = ms -> {\n+                    try {\n+                        FREE.invokeExact(ms.address());\n+                    } catch (Throwable e) {\n+                        throw new AssertionError(e);\n+                    }\n+                };\n+            } else {\n+                CALLOC = linker.downcallHandle(callocAddr, FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.JAVA_INT, ValueLayout.JAVA_INT));\n+                FREE = linker.downcallHandle(freeAddr, FunctionDescriptor.ofVoid(ValueLayout.JAVA_INT));\n+                CLEANUP = ms -> {\n+                    try {\n+                        FREE.invokeExact((int)ms.address());\n+                    } catch (Throwable e) {\n+                        throw new AssertionError(e);\n+                    }\n+                };\n+            }\n+        }\n@@ -94,1 +101,1 @@\n-        static MemorySegment calloc(long size) {\n+        static long calloc(long size) {\n@@ -96,3 +103,7 @@\n-                return (MemorySegment)CALLOC.invokeExact(size, 1L);\n-            } catch (Throwable ex) {\n-                throw new IllegalStateException(ex);\n+                if (ADDRESS_SIZE == Long.BYTES) {\n+                    return (long)CALLOC.invokeExact(1L, size);\n+                } else {\n+                    return (int)CALLOC.invokeExact(1, (int)size);\n+                }\n+            } catch (Throwable e) {\n+                throw new AssertionError(e);\n@@ -116,2 +127,2 @@\n-            return calloc(byteSize)\n-                    .reinterpret(byteSize, arena, CLayouts::freeMemory);\n+            long address = calloc(byteSize);\n+            return MemorySegment.ofAddress(address).reinterpret(byteSize, arena, CLEANUP);\n@@ -121,1 +132,1 @@\n-    public static class UnsafeArena implements Arena {\n+    private static class UnsafeArena implements Arena {\n@@ -137,3 +148,3 @@\n-            MemorySegment segment = MemorySegment.ofAddress(Utils.unsafe.allocateMemory(byteSize));\n-            Utils.unsafe.setMemory(segment.address(), byteSize, (byte)0);\n-            return segment.reinterpret(byteSize, arena, ms -> Utils.unsafe.freeMemory(segment.address()));\n+            long address = Utils.unsafe.allocateMemory(byteSize);\n+            Utils.unsafe.setMemory(address, byteSize, (byte)0);\n+            return MemorySegment.ofAddress(address).reinterpret(byteSize, arena, ms -> Utils.unsafe.freeMemory(ms.address()));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/AllocTest.java","additions":55,"deletions":44,"binary":false,"changes":99,"status":"modified"}]}