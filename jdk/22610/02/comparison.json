{"files":[{"patch":"@@ -29,2 +29,0 @@\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n@@ -32,1 +30,0 @@\n-import java.util.Objects;\n@@ -54,2 +51,1 @@\n-        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n-        return SegmentFactories.allocateSegment(byteSize, byteAlignment, session, shouldReserveMemory);\n+        return SegmentFactories.allocateNativeSegment(byteSize, byteAlignment, session, shouldReserveMemory, false);\n@@ -60,3 +56,1 @@\n-        NativeMemorySegmentImpl segment = allocateNoInit(byteSize, byteAlignment);\n-        segment.fill((byte)0);\n-        return segment;\n+        return SegmentFactories.allocateNativeSegment(byteSize, byteAlignment, session, shouldReserveMemory, true);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ArenaImpl.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.internal.vm.annotation.DontInline;\n@@ -178,2 +179,8 @@\n-    public static NativeMemorySegmentImpl allocateSegment(long byteSize, long byteAlignment, MemorySessionImpl sessionImpl,\n-                                                          boolean shouldReserve) {\n+    public static NativeMemorySegmentImpl allocateNativeSegment(long byteSize, long byteAlignment, MemorySessionImpl sessionImpl,\n+                                                                boolean shouldReserve, boolean init) {\n+        long address = SegmentFactories.allocateNativeInternal(byteSize, byteAlignment, sessionImpl, shouldReserve, init);\n+        return new NativeMemorySegmentImpl(address, byteSize, false, sessionImpl);\n+    }\n+\n+    private static long allocateNativeInternal(long byteSize, long byteAlignment, MemorySessionImpl sessionImpl,\n+                                               boolean shouldReserve, boolean init) {\n@@ -181,0 +188,1 @@\n+        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n@@ -185,3 +193,11 @@\n-        long alignedSize = Math.max(1L, byteAlignment > MAX_MALLOC_ALIGN ?\n-                byteSize + (byteAlignment - 1) :\n-                byteSize);\n+        \/\/ Align the allocation size up to a multiple of 8 so we can init the memory with longs\n+        long alignedSize = init ? Utils.alignUp(byteSize, Long.BYTES) : byteSize;\n+\n+        long allocationSize;\n+        long allocationBase;\n+        long result;\n+        if (byteAlignment > MAX_MALLOC_ALIGN) {\n+            allocationSize = alignedSize + byteAlignment - MAX_MALLOC_ALIGN;\n+            if (shouldReserve) {\n+                AbstractMemorySegmentImpl.NIO_ACCESS.reserveMemory(allocationSize, byteSize);\n+            }\n@@ -189,2 +205,10 @@\n-        if (shouldReserve) {\n-            AbstractMemorySegmentImpl.NIO_ACCESS.reserveMemory(alignedSize, byteSize);\n+            allocationBase = allocateMemoryWrapper(allocationSize);\n+            result = Utils.alignUp(allocationBase, byteAlignment);\n+        } else {\n+            allocationSize = alignedSize;\n+            if (shouldReserve) {\n+                AbstractMemorySegmentImpl.NIO_ACCESS.reserveMemory(allocationSize, byteSize);\n+            }\n+\n+            allocationBase = allocateMemoryWrapper(allocationSize);\n+            result = allocationBase;\n@@ -193,4 +217,3 @@\n-        long buf = allocateMemoryWrapper(alignedSize);\n-        long alignedBuf = Utils.alignUp(buf, byteAlignment);\n-        NativeMemorySegmentImpl segment = new NativeMemorySegmentImpl(buf, alignedSize,\n-                false, sessionImpl);\n+        if (init) {\n+            initNativeMemory(result, alignedSize);\n+        }\n@@ -200,1 +223,1 @@\n-                UNSAFE.freeMemory(buf);\n+                UNSAFE.freeMemory(allocationBase);\n@@ -202,1 +225,1 @@\n-                    AbstractMemorySegmentImpl.NIO_ACCESS.unreserveMemory(alignedSize, byteSize);\n+                    AbstractMemorySegmentImpl.NIO_ACCESS.unreserveMemory(allocationSize, byteSize);\n@@ -206,3 +229,6 @@\n-        if (alignedSize != byteSize) {\n-            long delta = alignedBuf - buf;\n-            segment = (NativeMemorySegmentImpl) segment.asSlice(delta, byteSize);\n+        return result;\n+    }\n+\n+    private static void initNativeMemory(long address, long byteSize) {\n+        for (long i = 0; i < byteSize; i += Long.BYTES) {\n+            UNSAFE.putLongUnaligned(null, address + i, 0);\n@@ -210,1 +236,0 @@\n-        return segment;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentFactories.java","additions":42,"deletions":17,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-    private static boolean pageAlignDirectMemory;\n+    private static Boolean pageAlignDirectMemory;\n@@ -159,1 +159,1 @@\n-        return pageAlignDirectMemory;\n+        return pageAlignDirectMemory != null && pageAlignDirectMemory;\n@@ -264,3 +264,1 @@\n-        s = props.get(\"sun.nio.PageAlignDirectMemory\");\n-        if (\"true\".equals(s))\n-            pageAlignDirectMemory = true;\n+        pageAlignDirectMemory = \"true\".equals(props.get(\"sun.nio.PageAlignDirectMemory\"));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/VM.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,16 +26,1 @@\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.TearDown;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.*;\n@@ -43,2 +28,0 @@\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.ValueLayout;\n@@ -47,0 +30,2 @@\n+import java.util.function.Consumer;\n+import org.openjdk.jmh.annotations.*;\n@@ -56,3 +41,1 @@\n-    Arena arena = Arena.ofConfined();\n-\n-    @Param({\"5\", \"20\", \"100\", \"500\", \"1000\"})\n+    @Param({\"5\", \"20\", \"100\", \"500\", \"2000\", \"8000\"})\n@@ -61,5 +44,0 @@\n-    @TearDown\n-    public void tearDown() {\n-        arena.close();\n-    }\n-\n@@ -67,1 +45,1 @@\n-    public MemorySegment alloc_confined() {\n+    public long alloc_confined() {\n@@ -69,1 +47,1 @@\n-            return arena.allocate(size);\n+            return arena.allocate(size).address();\n@@ -87,6 +65,21 @@\n-    public static class CallocArena implements Arena {\n-\n-        static final MethodHandle CALLOC = Linker.nativeLinker()\n-                .downcallHandle(\n-                        Linker.nativeLinker().defaultLookup().findOrThrow(\"calloc\"),\n-                        FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG));\n+    private static class CallocArena implements Arena {\n+\n+        static final MethodHandle CALLOC;\n+        static final MethodHandle FREE;\n+        static final Consumer<MemorySegment> CLEANUP;\n+\n+        static {\n+            var linker = Linker.nativeLinker();\n+            var lookup = linker.defaultLookup();\n+            var callocAddr = lookup.findOrThrow(\"calloc\");\n+            var freeAddr = lookup.findOrThrow(\"free\");\n+            CALLOC = linker.downcallHandle(callocAddr, FunctionDescriptor.of(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG));\n+            FREE = linker.downcallHandle(freeAddr, FunctionDescriptor.ofVoid(ValueLayout.JAVA_LONG));\n+            CLEANUP = ms -> {\n+                try {\n+                    FREE.invokeExact(ms.address());\n+                } catch (Throwable e) {\n+                    throw new AssertionError(e);\n+                }\n+            };\n+        }\n@@ -94,1 +87,1 @@\n-        static MemorySegment calloc(long size) {\n+        static long calloc(long size) {\n@@ -96,3 +89,3 @@\n-                return (MemorySegment)CALLOC.invokeExact(size, 1L);\n-            } catch (Throwable ex) {\n-                throw new IllegalStateException(ex);\n+                return (long)CALLOC.invokeExact(1L, size);\n+            } catch (Throwable e) {\n+                throw new AssertionError(e);\n@@ -116,2 +109,2 @@\n-            return calloc(byteSize)\n-                    .reinterpret(byteSize, arena, CLayouts::freeMemory);\n+            long address = calloc(byteSize);\n+            return MemorySegment.ofAddress(address).reinterpret(byteSize, arena, CLEANUP);\n@@ -121,1 +114,1 @@\n-    public static class UnsafeArena implements Arena {\n+    private static class UnsafeArena implements Arena {\n@@ -137,3 +130,3 @@\n-            MemorySegment segment = MemorySegment.ofAddress(Utils.unsafe.allocateMemory(byteSize));\n-            Utils.unsafe.setMemory(segment.address(), byteSize, (byte)0);\n-            return segment.reinterpret(byteSize, arena, ms -> Utils.unsafe.freeMemory(segment.address()));\n+            long address = Utils.unsafe.allocateMemory(byteSize);\n+            Utils.unsafe.setMemory(address, byteSize, (byte)0);\n+            return MemorySegment.ofAddress(address).reinterpret(byteSize, arena, ms -> Utils.unsafe.freeMemory(ms.address()));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/AllocTest.java","additions":37,"deletions":44,"binary":false,"changes":81,"status":"modified"}]}