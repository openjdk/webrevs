{"files":[{"patch":"@@ -51,2 +51,1 @@\n-        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n-        return SegmentFactories.allocateSegment(byteSize, byteAlignment, session, shouldReserveMemory);\n+        return SegmentFactories.allocateNativeSegment(byteSize, byteAlignment, session, shouldReserveMemory, false);\n@@ -57,3 +56,1 @@\n-        NativeMemorySegmentImpl segment = allocateNoInit(byteSize, byteAlignment);\n-        segment.fill((byte)0);\n-        return segment;\n+        return SegmentFactories.allocateNativeSegment(byteSize, byteAlignment, session, shouldReserveMemory, true);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ArenaImpl.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import jdk.internal.vm.annotation.DontInline;\n@@ -178,2 +179,8 @@\n-    public static NativeMemorySegmentImpl allocateSegment(long byteSize, long byteAlignment, MemorySessionImpl sessionImpl,\n-                                                          boolean shouldReserve) {\n+    public static NativeMemorySegmentImpl allocateNativeSegment(long byteSize, long byteAlignment, MemorySessionImpl sessionImpl,\n+                                                                boolean shouldReserve, boolean init) {\n+        long address = SegmentFactories.allocateNativeInternal(byteSize, byteAlignment, sessionImpl, shouldReserve, init);\n+        return new NativeMemorySegmentImpl(address, byteSize, false, sessionImpl);\n+    }\n+\n+    private static long allocateNativeInternal(long byteSize, long byteAlignment, MemorySessionImpl sessionImpl,\n+                                               boolean shouldReserve, boolean init) {\n@@ -181,0 +188,1 @@\n+        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n@@ -185,3 +193,11 @@\n-        long alignedSize = Math.max(1L, byteAlignment > MAX_MALLOC_ALIGN ?\n-                byteSize + (byteAlignment - 1) :\n-                byteSize);\n+        \/\/ Align the allocation size up to a multiple of 8 so we can init the memory with longs\n+        long alignedSize = init ? Utils.alignUp(byteSize, Long.BYTES) : byteSize;\n+\n+        long allocationSize;\n+        long allocationBase;\n+        long result;\n+        if (byteAlignment > MAX_MALLOC_ALIGN) {\n+            allocationSize = alignedSize + byteAlignment - MAX_MALLOC_ALIGN;\n+            if (shouldReserve) {\n+                AbstractMemorySegmentImpl.NIO_ACCESS.reserveMemory(allocationSize, byteSize);\n+            }\n@@ -189,2 +205,10 @@\n-        if (shouldReserve) {\n-            AbstractMemorySegmentImpl.NIO_ACCESS.reserveMemory(alignedSize, byteSize);\n+            allocationBase = allocateMemoryWrapper(allocationSize);\n+            result = Utils.alignUp(allocationBase, byteAlignment);\n+        } else {\n+            allocationSize = alignedSize;\n+            if (shouldReserve) {\n+                AbstractMemorySegmentImpl.NIO_ACCESS.reserveMemory(allocationSize, byteSize);\n+            }\n+\n+            allocationBase = allocateMemoryWrapper(allocationSize);\n+            result = allocationBase;\n@@ -193,4 +217,3 @@\n-        long buf = allocateMemoryWrapper(alignedSize);\n-        long alignedBuf = Utils.alignUp(buf, byteAlignment);\n-        NativeMemorySegmentImpl segment = new NativeMemorySegmentImpl(buf, alignedSize,\n-                false, sessionImpl);\n+        if (init) {\n+            initNativeMemory(result, alignedSize);\n+        }\n@@ -200,1 +223,1 @@\n-                UNSAFE.freeMemory(buf);\n+                UNSAFE.freeMemory(allocationBase);\n@@ -202,1 +225,1 @@\n-                    AbstractMemorySegmentImpl.NIO_ACCESS.unreserveMemory(alignedSize, byteSize);\n+                    AbstractMemorySegmentImpl.NIO_ACCESS.unreserveMemory(allocationSize, byteSize);\n@@ -206,3 +229,6 @@\n-        if (alignedSize != byteSize) {\n-            long delta = alignedBuf - buf;\n-            segment = (NativeMemorySegmentImpl) segment.asSlice(delta, byteSize);\n+        return result;\n+    }\n+\n+    private static void initNativeMemory(long address, long byteSize) {\n+        for (long i = 0; i < byteSize; i += Long.BYTES) {\n+            UNSAFE.putLongUnaligned(null, address + i, 0);\n@@ -210,1 +236,0 @@\n-        return segment;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentFactories.java","additions":43,"deletions":18,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,1 +154,1 @@\n-    private static boolean pageAlignDirectMemory;\n+    private static Boolean pageAlignDirectMemory;\n@@ -159,1 +159,1 @@\n-        return pageAlignDirectMemory;\n+        return pageAlignDirectMemory != null && pageAlignDirectMemory;\n@@ -264,3 +264,1 @@\n-        s = props.get(\"sun.nio.PageAlignDirectMemory\");\n-        if (\"true\".equals(s))\n-            pageAlignDirectMemory = true;\n+        pageAlignDirectMemory = \"true\".equals(props.get(\"sun.nio.PageAlignDirectMemory\"));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/VM.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,16 +26,1 @@\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.TearDown;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.*;\n@@ -43,2 +28,0 @@\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.ValueLayout;\n@@ -47,0 +30,2 @@\n+import java.util.function.Consumer;\n+import org.openjdk.jmh.annotations.*;\n@@ -56,3 +41,1 @@\n-    Arena arena = Arena.ofConfined();\n-\n-    @Param({\"5\", \"20\", \"100\", \"500\", \"1000\"})\n+    @Param({\"5\", \"20\", \"100\", \"500\", \"2000\", \"8000\"})\n@@ -61,5 +44,0 @@\n-    @TearDown\n-    public void tearDown() {\n-        arena.close();\n-    }\n-\n@@ -87,1 +65,1 @@\n-    public static class CallocArena implements Arena {\n+    private static class CallocArena implements Arena {\n@@ -121,1 +99,1 @@\n-    public static class UnsafeArena implements Arena {\n+    private static class UnsafeArena implements Arena {\n@@ -137,3 +115,3 @@\n-            MemorySegment segment = MemorySegment.ofAddress(Utils.unsafe.allocateMemory(byteSize));\n-            Utils.unsafe.setMemory(segment.address(), byteSize, (byte)0);\n-            return segment.reinterpret(byteSize, arena, ms -> Utils.unsafe.freeMemory(segment.address()));\n+            long address = Utils.unsafe.allocateMemory(byteSize);\n+            Utils.unsafe.setMemory(address, byteSize, (byte)0);\n+            return MemorySegment.ofAddress(address).reinterpret(byteSize, arena, ms -> Utils.unsafe.freeMemory(ms.address()));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/AllocTest.java","additions":9,"deletions":31,"binary":false,"changes":40,"status":"modified"}]}