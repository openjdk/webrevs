{"files":[{"patch":"@@ -3304,0 +3304,162 @@\n+\n+    static final class Remainder {\n+        private Remainder() {throw new UnsupportedOperationException();}\n+\n+        private static final double zero = 0.0;\n+\n+        static double compute(double x, double p) {\n+            int hx,hp;\n+            \/*unsigned*\/ int sx, lx, lp;\n+            double p_half;\n+\n+            hx = __HI(x);           \/* high word of x *\/\n+            lx = __LO(x);           \/* low  word of x *\/\n+            hp = __HI(p);           \/* high word of p *\/\n+            lp = __LO(p);           \/* low  word of p *\/\n+            sx = hx&0x80000000;\n+            hp &= 0x7fffffff;\n+            hx &= 0x7fffffff;\n+\n+            \/* purge off exception values *\/\n+            if ((hp | lp) == 0) return (x*p)\/(x*p);      \/* p = 0 *\/\n+            if((hx >= 0x7ff00000) ||                   \/* x not finite *\/\n+               ((hp >= 0x7ff00000) &&                   \/* p is NaN *\/\n+                (((hp - 0x7ff00000) | lp) != 0)))\n+                return (x*p)\/(x*p);\n+\n+            if (hp <= 0x7fdfffff) x = fmod(x,p+p);  \/* now x < 2p *\/\n+            if (((hx - hp)|(lx - lp))==0) return zero*x;\n+            x  = Math.abs(x);\n+            p  = Math.abs(p);\n+            if (hp < 0x00200000) {\n+                if(x+x > p) {\n+                    x -= p;\n+                    if(x + x >= p) x -= p;\n+                }\n+            } else {\n+                p_half = 0.5*p;\n+                if(x > p_half) {\n+                    x -= p;\n+                    if(x >= p_half) x -= p;\n+                }\n+            }\n+            \/\/ __HI(x) ^= sx\n+            x = __HI(x, __HI(x) ^ sx);\n+            return x;\n+        }\n+\n+        private static double one = 1.0, Zero[] = {0.0, -0.0,};\n+\n+        static double fmod(double x, double y) {\n+            int n,hx,hy,hz,ix,iy,sx,i;\n+            \/*unsigned*\/ int lx,ly,lz;\n+\n+            hx = __HI(x);           \/* high word of x *\/\n+            lx = __LO(x);           \/* low  word of x *\/\n+            hy = __HI(y);           \/* high word of y *\/\n+            ly = __LO(y);           \/* low  word of y *\/\n+            sx = hx&0x80000000;             \/* sign of x *\/\n+            hx ^=sx;                \/* |x| *\/\n+            hy &= 0x7fffffff;       \/* |y| *\/\n+\n+            \/* purge off exception values *\/\n+            if((hy|ly)==0||(hx>=0x7ff00000)||       \/* y=0,or x not finite *\/\n+               ((hy|((ly | -ly) >> 31))>0x7ff00000))     \/* or y is NaN *\/\n+                return (x*y)\/(x*y);\n+            if(hx <=hy) {\n+                if((hx<hy)||(Integer.compareUnsigned(lx, ly) < 0)) return x;      \/* |x|<|y| return x *\/\n+                if(lx==ly)\n+                    return Zero[sx>>>31];  \/* |x|=|y| return x*0*\/ \/\/ unsigned shift\n+            }\n+\n+            \/* determine ix = ilogb(x) *\/\n+            if(hx<0x00100000) {     \/* subnormal x *\/\n+                if(hx==0) {\n+                    for (ix = -1043, i=lx; i>0; i<<=1) ix -=1;\n+                } else {\n+                    for (ix = -1022,i=(hx<<11); i>0; i<<=1) ix -=1;\n+                }\n+            } else ix = (hx>>20)-1023;\n+\n+            \/* determine iy = ilogb(y) *\/\n+            if(hy<0x00100000) {     \/* subnormal y *\/\n+                if(hy==0) {\n+                    for (iy = -1043, i=ly; i>0; i<<=1) iy -=1;\n+                } else {\n+                    for (iy = -1022,i=(hy<<11); i>0; i<<=1) iy -=1;\n+                }\n+            } else iy = (hy>>20)-1023;\n+\n+            \/* set up {hx,lx}, {hy,ly} and align y to x *\/\n+            if(ix >= -1022)\n+                hx = 0x00100000|(0x000fffff&hx);\n+            else {          \/* subnormal x, shift x to normal *\/\n+                n = -1022-ix;\n+                if(n<=31) {\n+                    hx = (hx<<n)|(lx>>>(32-n)); \/\/ unsigned shift\n+                    lx <<= n;\n+                } else {\n+                    hx = lx<<(n-32);\n+                    lx = 0;\n+                }\n+            }\n+            if(iy >= -1022)\n+                hy = 0x00100000|(0x000fffff&hy);\n+            else {          \/* subnormal y, shift y to normal *\/\n+                n = -1022-iy;\n+                if(n<=31) {\n+                    hy = (hy<<n)|(ly>>>(32-n)); \/\/ unsigned shift\n+                    ly <<= n;\n+                } else {\n+                    hy = ly<<(n-32);\n+                    ly = 0;\n+                }\n+            }\n+\n+            \/* fix point fmod *\/\n+            n = ix - iy;\n+            while(n-- != 0) {\n+                hz=hx-hy;lz=lx-ly; if(Integer.compareUnsigned(lx, ly) < 0 ) hz -= 1;\n+                if(hz<0){hx = hx+hx+(lx>>>31); lx = lx+lx;} \/\/ unsigned shift\n+                else {\n+                    if((hz|lz)==0)          \/* return sign(x)*0 *\/\n+                        return Zero[sx>>>31]; \/\/ unsigned shift\n+                    hx = hz+hz+(lz>>>31); lx = lz+lz; \/\/ unsigned shift\n+                }\n+            }\n+            hz=hx-hy;lz=lx-ly; if(Integer.compareUnsigned(lx, ly) < 0) hz -= 1;\n+            if(hz>=0) {hx=hz;lx=lz;}\n+\n+            \/* convert back to floating value and restore the sign *\/\n+            if((hx|lx)==0)                  \/* return sign(x)*0 *\/\n+                return Zero[sx>>>31]; \/\/ unsigned shift\n+            while(Integer.compareUnsigned(hx, 0x00100000) < 0) {          \/* normalize x *\/\n+                hx = hx+hx+(lx>>31); lx = lx+lx;\n+                iy -= 1;\n+            }\n+            if(iy>= -1022) {        \/* normalize output *\/\n+                hx = ((hx-0x00100000)|((iy+1023)<<20));\n+                \/\/ __HI(x) = hx|sx;\n+                x = __HI(x, hx|sx);\n+                \/\/ __LO(x) = lx;\n+                x = __LO(x, lx);\n+            } else {                \/* subnormal output *\/\n+                n = -1022 - iy;\n+                if(n<=20) {\n+                    lx = (lx>>>n)|(hx<<(32-n)); \/\/ unsigned shift\n+                    hx >>= n;\n+                } else if (n<=31) {\n+                    lx = (hx<<(32-n))|(lx>>>n); hx = sx; \/\/ unsigned shift\n+                } else {\n+                    lx = hx>>(n-32); hx = sx;\n+                }\n+                \/\/ __HI(x) = hx|sx;\n+                x = __HI(x, hx|sx);\n+                \/\/ __LO(x) = lx;\n+                x = __LO(x, lx);\n+                x *= one;           \/* create necessary signal *\/\n+            }\n+            return x;               \/* exact output *\/\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/FdLibm.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -392,1 +392,3 @@\n-    public static native double IEEEremainder(double f1, double f2);\n+    public static double IEEEremainder(double f1, double f2) {\n+        return FdLibm.Remainder.compute(f1, f2);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}