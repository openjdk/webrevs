{"files":[{"patch":"@@ -326,9 +326,0 @@\n-void ObjectMonitor::ClearSuccOnSuspend::operator()(JavaThread* current) {\n-  if (current->is_suspended()) {\n-    if (_om->has_successor(current)) {\n-      _om->clear_successor();\n-      OrderAccess::fence(); \/\/ always do a full fence when successor is cleared\n-    }\n-  }\n-}\n-\n@@ -487,1 +478,1 @@\n-bool ObjectMonitor::enter(JavaThread* current) {\n+bool ObjectMonitor::enter(JavaThread* current, bool post_jvmti_events) {\n@@ -508,1 +499,1 @@\n-  enter_with_contention_mark(current, contention_mark);\n+  enter_with_contention_mark(current, contention_mark, post_jvmti_events);\n@@ -527,1 +518,1 @@\n-void ObjectMonitor::enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark &cm) {\n+void ObjectMonitor::enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark &cm, bool post_jvmti_events) {\n@@ -631,1 +622,1 @@\n-  if (JvmtiExport::should_post_monitor_contended_entered()) {\n+  if (post_jvmti_events && JvmtiExport::should_post_monitor_contended_entered()) {\n@@ -1089,1 +1080,1 @@\n-  assert(current->thread_state() != _thread_blocked, \"invariant\");\n+  assert(current->thread_state() == _thread_blocked, \"invariant\");\n@@ -1093,1 +1084,0 @@\n-  assert_mark_word_consistency();\n@@ -1129,15 +1119,6 @@\n-\n-      assert(current->thread_state() == _thread_in_vm, \"invariant\");\n-\n-      {\n-        ClearSuccOnSuspend csos(this);\n-        ThreadBlockInVMPreprocess<ClearSuccOnSuspend> tbivs(current, csos, true \/* allow_suspend *\/);\n-        if (do_timed_parked) {\n-          current->_ParkEvent->park(recheck_interval);\n-          \/\/ Increase the recheck_interval, but clamp the value.\n-          recheck_interval *= 8;\n-          if (recheck_interval > MAX_RECHECK_INTERVAL) {\n-            recheck_interval = MAX_RECHECK_INTERVAL;\n-          }\n-        } else {\n-          current->_ParkEvent->park();\n+      if (do_timed_parked) {\n+        current->_ParkEvent->park(recheck_interval);\n+        \/\/ Increase the recheck_interval, but clamp the value.\n+        recheck_interval *= 8;\n+        if (recheck_interval > MAX_RECHECK_INTERVAL) {\n+          recheck_interval = MAX_RECHECK_INTERVAL;\n@@ -1145,0 +1126,2 @@\n+      } else {\n+        current->_ParkEvent->park();\n@@ -1171,1 +1154,0 @@\n-  assert_mark_word_consistency();\n@@ -1881,2 +1863,1 @@\n-      ClearSuccOnSuspend csos(this);\n-      ThreadBlockInVMPreprocess<ClearSuccOnSuspend> tbivs(current, csos, true \/* allow_suspend *\/);\n+      ThreadBlockInVM tbivm(current, false \/* allow_suspend *\/);\n@@ -1934,0 +1915,35 @@\n+    OrderAccess::fence();\n+\n+    assert(!has_owner(current), \"invariant\");\n+    ObjectWaiter::TStates v = node.TState;\n+    if (v == ObjectWaiter::TS_RUN) {\n+      \/\/ We use the NoPreemptMark for the very rare case where the previous\n+      \/\/ preempt attempt failed due to OOM. The preempt on monitor contention\n+      \/\/ could succeed but we can't unmount now.\n+      NoPreemptMark npm(current);\n+      enter(current);\n+    } else {\n+      guarantee(v == ObjectWaiter::TS_ENTER, \"invariant\");\n+      ExitOnSuspend eos(this);\n+      {\n+        ThreadBlockInVMPreprocess<ExitOnSuspend> tbivs(current, eos, true \/* allow_suspend *\/);\n+        reenter_internal(current, &node);\n+        \/\/ We can go to a safepoint at the end of this block. If we\n+        \/\/ do a thread dump during that safepoint, then this thread will show\n+        \/\/ as having \"-locked\" the monitor, but the OS and java.lang.Thread\n+        \/\/ states will still report that the thread is blocked trying to\n+        \/\/ acquire it.\n+        \/\/ If there is a suspend request, ExitOnSuspend will exit the OM\n+        \/\/ and set the OM as pending.\n+      }\n+      if (eos.exited()) {\n+        \/\/ ExitOnSuspend exit the OM\n+        assert(!has_owner(current), \"invariant\");\n+        guarantee(node.TState == ObjectWaiter::TS_RUN, \"invariant\");\n+        current->set_current_pending_monitor(nullptr);\n+        enter(current, false);\n+      }\n+      assert(has_owner(current), \"invariant\");\n+      node.wait_reenter_end(this);\n+    }\n+\n@@ -1962,16 +1978,0 @@\n-    OrderAccess::fence();\n-\n-    assert(!has_owner(current), \"invariant\");\n-    ObjectWaiter::TStates v = node.TState;\n-    if (v == ObjectWaiter::TS_RUN) {\n-      \/\/ We use the NoPreemptMark for the very rare case where the previous\n-      \/\/ preempt attempt failed due to OOM. The preempt on monitor contention\n-      \/\/ could succeed but we can't unmount now.\n-      NoPreemptMark npm(current);\n-      enter(current);\n-    } else {\n-      guarantee(v == ObjectWaiter::TS_ENTER, \"invariant\");\n-      reenter_internal(current, &node);\n-      node.wait_reenter_end(this);\n-    }\n-\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":49,"deletions":49,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -361,7 +361,0 @@\n-  class ClearSuccOnSuspend {\n-   protected:\n-    ObjectMonitor* _om;\n-   public:\n-    ClearSuccOnSuspend(ObjectMonitor* om) : _om(om)  {}\n-    void operator()(JavaThread* current);\n-  };\n@@ -374,1 +367,1 @@\n-  bool      enter(JavaThread* current);\n+  bool      enter(JavaThread* current, bool post_jvmti_events = true);\n@@ -377,1 +370,1 @@\n-  void      enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark& contention_mark);\n+  void      enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark& contention_mark, bool post_jvmti_events = true);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,1 +31,21 @@\n- * @run main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait\n+ * @run main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait 1\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4413752 8262881\n+ * @summary Test SuspendThread with ObjectMonitor wait.\n+ * @requires vm.jvmti\n+ * @library \/test\/lib\n+ * @compile SuspendWithObjectMonitorWait.java\n+ * @run main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait 2\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4413752 8262881\n+ * @summary Test SuspendThread with ObjectMonitor wait.\n+ * @requires vm.jvmti\n+ * @library \/test\/lib\n+ * @compile SuspendWithObjectMonitorWait.java\n+ * @run main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait 3\n@@ -90,0 +110,1 @@\n+        int test = Integer.parseInt(args[0]);\n@@ -125,1 +146,1 @@\n-        System.exit(run(timeMax, System.out) + exit_delta);\n+        System.exit(run(timeMax, System.out, test) + exit_delta);\n@@ -144,2 +165,8 @@\n-    public static int run(int timeMax, PrintStream out) {\n-        return (new SuspendWithObjectMonitorWait()).doWork(timeMax, out);\n+    public static int run(int timeMax, PrintStream out, int test) {\n+        switch (test) {\n+            case 1: return (new SuspendWithObjectMonitorWait()).doWork1(timeMax, out);\n+            case 2: return (new SuspendWithObjectMonitorWait()).doWork2(timeMax, out);\n+            case 3: return (new SuspendWithObjectMonitorWait()).doWork3(timeMax, out);\n+            default: throw new RuntimeException(\"Unknown test\");\n+        }\n+\n@@ -156,1 +183,2 @@\n-    public int doWork(int timeMax, PrintStream out) {\n+    \/\/ Default scenario, the resumer thread is always able to grab the threadLock once notified by the main thread.\n+    public int doWork1(int timeMax, PrintStream out) {\n@@ -268,0 +296,235 @@\n+\n+    \/\/ Notify the resumer while holding the threadLock\n+    public int doWork2(int timeMax, PrintStream out) {\n+        SuspendWithObjectMonitorWaitWorker waiter;    \/\/ waiter thread\n+        SuspendWithObjectMonitorWaitWorker resumer;    \/\/ resumer thread\n+\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n+            testState = TS_INIT;  \/\/ starting the test loop\n+\n+            \/\/ launch the waiter thread\n+            synchronized (barrierLaunch) {\n+                waiter = new SuspendWithObjectMonitorWaitWorker(\"waiter\");\n+                waiter.start();\n+\n+                while (testState != TS_WAITER_RUNNING) {\n+                    try {\n+                        barrierLaunch.wait(0);  \/\/ wait until it is running\n+                    } catch (InterruptedException ex) {\n+                    }\n+                }\n+            }\n+\n+            \/\/ launch the resumer thread\n+            synchronized (barrierLaunch) {\n+                resumer = new SuspendWithObjectMonitorWaitWorker(\"resumer\", waiter);\n+                resumer.start();\n+\n+                while (testState != TS_RESUMER_RUNNING) {\n+                    try {\n+                        barrierLaunch.wait(0);  \/\/ wait until it is running\n+                    } catch (InterruptedException ex) {\n+                    }\n+                }\n+            }\n+\n+            checkTestState(TS_RESUMER_RUNNING);\n+\n+            \/\/ The waiter thread was synchronized on threadLock before it\n+            \/\/ set TS_WAITER_RUNNING and notified barrierLaunch above so\n+            \/\/ we cannot enter threadLock until the waiter thread calls\n+            \/\/ threadLock.wait().\n+            synchronized (threadLock) {\n+                \/\/ notify waiter thread so it can try to reenter threadLock\n+                testState = TS_READY_TO_NOTIFY;\n+                threadLock.notify();\n+\n+                \/\/ wait for the waiter thread to block\n+                logDebug(\"before contended enter wait\");\n+                int retCode = wait4ContendedEnter(waiter);\n+                if (retCode != 0) {\n+                    throw new RuntimeException(\"error in JVMTI GetThreadState: \"\n+                                                + \"retCode=\" + retCode);\n+                }\n+                logDebug(\"done contended enter wait\");\n+\n+                checkTestState(TS_READY_TO_NOTIFY);\n+                testState = TS_CALL_SUSPEND;\n+                logDebug(\"before suspend thread\");\n+                retCode = suspendThread(waiter);\n+                if (retCode != 0) {\n+                    throw new RuntimeException(\"error in JVMTI SuspendThread: \"\n+                                                + \"retCode=\" + retCode);\n+                }\n+                logDebug(\"suspended thread\");\n+\n+                \/\/\n+                \/\/ At this point, all of the child threads are running\n+                \/\/ and we can get to meat of the test:\n+                \/\/\n+                \/\/ - suspended threadLock waiter (trying to reenter)\n+                \/\/ - a threadLock enter in the resumer thread\n+                \/\/ - resumption of the waiter thread\n+                \/\/ - a threadLock enter in the freshly resumed waiter thread\n+                \/\/\n+\n+                synchronized (barrierResumer) {\n+                    checkTestState(TS_CALL_SUSPEND);\n+\n+                    \/\/ tell resumer thread to resume waiter thread\n+                    testState = TS_READY_TO_RESUME;\n+                    barrierResumer.notify();\n+\n+                    \/\/ Can't call checkTestState() here because the\n+                    \/\/ resumer thread may have already resumed the\n+                    \/\/ waiter thread.\n+                }\n+                try { Thread.sleep(1000);\n+                } catch(Exception e) {}\n+            }\n+\n+            try {\n+                resumer.join(JOIN_MAX * 1000);\n+                if (resumer.isAlive()) {\n+                    System.err.println(\"Failure at \" + count + \" loops.\");\n+                    throw new InternalError(\"resumer thread is stuck\");\n+                }\n+                waiter.join(JOIN_MAX * 1000);\n+                if (waiter.isAlive()) {\n+                    System.err.println(\"Failure at \" + count + \" loops.\");\n+                    throw new InternalError(\"waiter thread is stuck\");\n+                }\n+            } catch (InterruptedException ex) {\n+            }\n+\n+            checkTestState(TS_WAITER_DONE);\n+        }\n+\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                \" seconds.\");\n+\n+        return 0;\n+    }\n+\n+    \/\/ Suspend on the re-entry path of wait.\n+    public int doWork3(int timeMax, PrintStream out) {\n+        SuspendWithObjectMonitorWaitWorker waiter;    \/\/ waiter thread\n+        SuspendWithObjectMonitorWaitWorker resumer;    \/\/ resumer thread\n+\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n+            testState = TS_INIT;  \/\/ starting the test loop\n+\n+            \/\/ launch the waiter thread\n+            synchronized (barrierLaunch) {\n+                waiter = new SuspendWithObjectMonitorWaitWorker(\"waiter\", 1);\n+                waiter.start();\n+\n+                while (testState != TS_WAITER_RUNNING) {\n+                    try {\n+                        barrierLaunch.wait(0);  \/\/ wait until it is running\n+                    } catch (InterruptedException ex) {\n+                    }\n+                }\n+            }\n+\n+            \/\/ launch the resumer thread\n+            synchronized (barrierLaunch) {\n+                resumer = new SuspendWithObjectMonitorWaitWorker(\"resumer\", waiter);\n+                resumer.start();\n+\n+                while (testState != TS_RESUMER_RUNNING) {\n+                    try {\n+                        barrierLaunch.wait(0);  \/\/ wait until it is running\n+                    } catch (InterruptedException ex) {\n+                    }\n+                }\n+            }\n+\n+            try { Thread.sleep(1000);\n+            } catch(Exception e) {}\n+\n+            checkTestState(TS_RESUMER_RUNNING);\n+\n+            \/\/ The waiter thread was synchronized on threadLock before it\n+            \/\/ set TS_WAITER_RUNNING and notified barrierLaunch above so\n+            \/\/ we cannot enter threadLock until the waiter thread calls\n+            \/\/ threadLock.wait().\n+            synchronized (threadLock) {\n+                \/\/ notify waiter thread so it can try to reenter threadLock\n+                testState = TS_READY_TO_NOTIFY;\n+                threadLock.notify();\n+\n+                \/\/ wait for the waiter thread to block\n+                logDebug(\"before contended enter wait\");\n+                int retCode = wait4ContendedEnter(waiter);\n+                if (retCode != 0) {\n+                    throw new RuntimeException(\"error in JVMTI GetThreadState: \"\n+                                                 + \"retCode=\" + retCode);\n+                }\n+                logDebug(\"done contended enter wait\");\n+\n+                checkTestState(TS_READY_TO_NOTIFY);\n+                testState = TS_CALL_SUSPEND;\n+                logDebug(\"before suspend thread\");\n+                retCode = suspendThread(waiter);\n+                if (retCode != 0) {\n+                    throw new RuntimeException(\"error in JVMTI SuspendThread: \"\n+                                                + \"retCode=\" + retCode);\n+                }\n+                logDebug(\"suspended thread\");\n+\n+                \/\/\n+                \/\/ At this point, all of the child threads are running\n+                \/\/ and we can get to meat of the test:\n+                \/\/\n+                \/\/ - suspended threadLock waiter (trying to reenter)\n+                \/\/ - a threadLock enter in the resumer thread\n+                \/\/ - resumption of the waiter thread\n+                \/\/ - a threadLock enter in the freshly resumed waiter thread\n+                \/\/\n+\n+                synchronized (barrierResumer) {\n+                    checkTestState(TS_CALL_SUSPEND);\n+\n+                    \/\/ tell resumer thread to resume waiter thread\n+                    testState = TS_READY_TO_RESUME;\n+                    barrierResumer.notify();\n+\n+                    \/\/ Can't call checkTestState() here because the\n+                    \/\/ resumer thread may have already resumed the\n+                    \/\/ waiter thread.\n+                }\n+                try { Thread.sleep(1000);\n+                } catch(Exception e) {}\n+            }\n+\n+            try {\n+                resumer.join(JOIN_MAX * 1000);\n+                if (resumer.isAlive()) {\n+                    System.err.println(\"Failure at \" + count + \" loops.\");\n+                    throw new InternalError(\"resumer thread is stuck\");\n+                }\n+                waiter.join(JOIN_MAX * 1000);\n+                if (waiter.isAlive()) {\n+                    System.err.println(\"Failure at \" + count + \" loops.\");\n+                    throw new InternalError(\"waiter thread is stuck\");\n+                }\n+            } catch (InterruptedException ex) {\n+            }\n+\n+            checkTestState(TS_WAITER_DONE);\n+        }\n+\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                \" seconds.\");\n+\n+        return 0;\n+    }\n@@ -270,0 +533,2 @@\n+\n+\n@@ -272,0 +537,1 @@\n+    private final long waitTimeout;\n@@ -275,0 +541,6 @@\n+        this.waitTimeout = 0;\n+    }\n+\n+    public SuspendWithObjectMonitorWaitWorker(String name, long waitTimeout) {\n+        super(name);\n+        this.waitTimeout = waitTimeout;\n@@ -280,0 +552,1 @@\n+        this.waitTimeout = 0;\n@@ -314,1 +587,1 @@\n-                        SuspendWithObjectMonitorWait.threadLock.wait(0);\n+                        SuspendWithObjectMonitorWait.threadLock.wait(waitTimeout);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWait.java","additions":279,"deletions":6,"binary":false,"changes":285,"status":"modified"}]}