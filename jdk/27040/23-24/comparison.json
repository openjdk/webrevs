{"files":[{"patch":"@@ -1932,1 +1932,2 @@\n-    if (JvmtiExport::should_post_monitor_waited() && node.TState != ObjectWaiter::TS_ENTER) {\n+    \/\/ A thread which should post monitor_waited event is never in TS_ENTER state.\n+    if (JvmtiExport::should_post_monitor_waited()) {\n@@ -2049,1 +2050,2 @@\n-      \/\/ Increment counter *before* adding the vthread to the _entry_list.\n+      \/\/ If we will add the vthread to the entry list below then we need to \n+      \/\/ increment the counter *before* doing so.\n@@ -2053,1 +2055,1 @@\n-        \/\/ This is is now conditional as if the monitor_waited even\n+        \/\/ This is is now conditional as if the monitor_waited event\n@@ -2066,1 +2068,1 @@\n-      \/\/ only when it is chosen to become a successor.\n+      \/\/ only when it is chosen to become the successor.\n@@ -2070,8 +2072,4 @@\n-      \/\/ a thread is unpraked immediately and let run. It is not\n-      \/\/ on the entry_list, and thus cannot become a successor.\n-      \/\/ Its state should be TS_RUN, as it is neither on wait_list\n-      \/\/ nor on the entry_list.\n-      \/\/ By not allowing a thread to become a successor we\n-      \/\/ avoid a problem of having a suspension point when posting\n-      \/\/ the monitor_waited JVMTI event, as suspending such a thread\n-      \/\/ is no harm.\n+      \/\/ the thread is set to state TS_RUN and unparked. The thread\n+      \/\/ will then contend directly to reacquire the monitor and\n+      \/\/ avoids being flagged as the successor. This avoids the problem\n+      \/\/ of having a thread suspend whilst it is the successor.\n@@ -2102,2 +2100,1 @@\n-      }\n-      else if (java_lang_VirtualThread::set_onWaitingList(vthread, vthread_list_head())) {\n+      } else if (java_lang_VirtualThread::set_onWaitingList(vthread, vthread_list_head())) {\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"}]}