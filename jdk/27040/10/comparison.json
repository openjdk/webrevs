{"files":[{"patch":"@@ -341,9 +341,0 @@\n-void ObjectMonitor::ClearSuccOnSuspend::operator()(JavaThread* current) {\n-  if (current->is_suspended()) {\n-    if (_om->has_successor(current)) {\n-      _om->clear_successor();\n-      OrderAccess::fence(); \/\/ always do a full fence when successor is cleared\n-    }\n-  }\n-}\n-\n@@ -502,1 +493,1 @@\n-bool ObjectMonitor::enter(JavaThread* current) {\n+bool ObjectMonitor::enter(JavaThread* current, bool post_jvmti_events) {\n@@ -523,1 +514,1 @@\n-  enter_with_contention_mark(current, contention_mark);\n+  enter_with_contention_mark(current, contention_mark, post_jvmti_events);\n@@ -542,1 +533,1 @@\n-void ObjectMonitor::enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark &cm) {\n+void ObjectMonitor::enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark &cm, bool post_jvmti_events) {\n@@ -646,1 +637,1 @@\n-  if (JvmtiExport::should_post_monitor_contended_entered()) {\n+  if (post_jvmti_events && JvmtiExport::should_post_monitor_contended_entered()) {\n@@ -1104,1 +1095,1 @@\n-  assert(current->thread_state() != _thread_blocked, \"invariant\");\n+  assert(current->thread_state() == _thread_blocked, \"invariant\");\n@@ -1108,1 +1099,0 @@\n-  assert_mark_word_consistency();\n@@ -1144,15 +1134,6 @@\n-\n-      assert(current->thread_state() == _thread_in_vm, \"invariant\");\n-\n-      {\n-        ClearSuccOnSuspend csos(this);\n-        ThreadBlockInVMPreprocess<ClearSuccOnSuspend> tbivs(current, csos, true \/* allow_suspend *\/);\n-        if (do_timed_parked) {\n-          current->_ParkEvent->park(recheck_interval);\n-          \/\/ Increase the recheck_interval, but clamp the value.\n-          recheck_interval *= 8;\n-          if (recheck_interval > MAX_RECHECK_INTERVAL) {\n-            recheck_interval = MAX_RECHECK_INTERVAL;\n-          }\n-        } else {\n-          current->_ParkEvent->park();\n+      if (do_timed_parked) {\n+        current->_ParkEvent->park(recheck_interval);\n+        \/\/ Increase the recheck_interval, but clamp the value.\n+        recheck_interval *= 8;\n+        if (recheck_interval > MAX_RECHECK_INTERVAL) {\n+          recheck_interval = MAX_RECHECK_INTERVAL;\n@@ -1160,0 +1141,2 @@\n+      } else {\n+        current->_ParkEvent->park();\n@@ -1186,1 +1169,0 @@\n-  assert_mark_word_consistency();\n@@ -1896,2 +1878,1 @@\n-      ClearSuccOnSuspend csos(this);\n-      ThreadBlockInVMPreprocess<ClearSuccOnSuspend> tbivs(current, csos, true \/* allow_suspend *\/);\n+      ThreadBlockInVM tbivm(current, false \/* allow_suspend *\/);\n@@ -1949,0 +1930,35 @@\n+    OrderAccess::fence();\n+\n+    assert(!has_owner(current), \"invariant\");\n+    ObjectWaiter::TStates v = node.TState;\n+    if (v == ObjectWaiter::TS_RUN) {\n+      \/\/ We use the NoPreemptMark for the very rare case where the previous\n+      \/\/ preempt attempt failed due to OOM. The preempt on monitor contention\n+      \/\/ could succeed but we can't unmount now.\n+      NoPreemptMark npm(current);\n+      enter(current);\n+    } else {\n+      guarantee(v == ObjectWaiter::TS_ENTER, \"invariant\");\n+      ExitOnSuspend eos(this);\n+      {\n+        ThreadBlockInVMPreprocess<ExitOnSuspend> tbivs(current, eos, true \/* allow_suspend *\/);\n+        reenter_internal(current, &node);\n+        \/\/ We can go to a safepoint at the end of this block. If we\n+        \/\/ do a thread dump during that safepoint, then this thread will show\n+        \/\/ as having \"-locked\" the monitor, but the OS and java.lang.Thread\n+        \/\/ states will still report that the thread is blocked trying to\n+        \/\/ acquire it.\n+        \/\/ If there is a suspend request, ExitOnSuspend will exit the OM\n+        \/\/ and set the OM as pending.\n+      }\n+      if (eos.exited()) {\n+        \/\/ ExitOnSuspend exit the OM\n+        assert(!has_owner(current), \"invariant\");\n+        guarantee(node.TState == ObjectWaiter::TS_RUN, \"invariant\");\n+        current->set_current_pending_monitor(nullptr);\n+        enter(current, false \/* post_jvmti_events *\/);\n+      }\n+      assert(has_owner(current), \"invariant\");\n+      node.wait_reenter_end(this);\n+    }\n+\n@@ -1977,16 +1993,0 @@\n-    OrderAccess::fence();\n-\n-    assert(!has_owner(current), \"invariant\");\n-    ObjectWaiter::TStates v = node.TState;\n-    if (v == ObjectWaiter::TS_RUN) {\n-      \/\/ We use the NoPreemptMark for the very rare case where the previous\n-      \/\/ preempt attempt failed due to OOM. The preempt on monitor contention\n-      \/\/ could succeed but we can't unmount now.\n-      NoPreemptMark npm(current);\n-      enter(current);\n-    } else {\n-      guarantee(v == ObjectWaiter::TS_ENTER, \"invariant\");\n-      reenter_internal(current, &node);\n-      node.wait_reenter_end(this);\n-    }\n-\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":49,"deletions":49,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -365,7 +365,0 @@\n-  class ClearSuccOnSuspend {\n-   protected:\n-    ObjectMonitor* _om;\n-   public:\n-    ClearSuccOnSuspend(ObjectMonitor* om) : _om(om)  {}\n-    void operator()(JavaThread* current);\n-  };\n@@ -378,1 +371,1 @@\n-  bool      enter(JavaThread* current);\n+  bool      enter(JavaThread* current, bool post_jvmti_events = true);\n@@ -381,1 +374,1 @@\n-  void      enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark& contention_mark);\n+  void      enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark& contention_mark, bool post_jvmti_events = true);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,371 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4413752 8262881\n- * @summary Test SuspendThread with ObjectMonitor wait.\n- * @requires vm.jvmti\n- * @library \/test\/lib\n- * @compile SuspendWithObjectMonitorWait.java\n- * @run main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait\n- *\/\n-\n-import java.io.PrintStream;\n-\n-\/\/\n-\/\/ main               waiter              resumer\n-\/\/ =================  ==================  ===================\n-\/\/ launch waiter\n-\/\/ <launch returns>   waiter running\n-\/\/ launch resumer     enter threadLock\n-\/\/ <launch returns>   threadLock.wait()   resumer running\n-\/\/ enter threadLock   :                   wait for notify\n-\/\/ threadLock.notify  wait finishes       :\n-\/\/ :                  reenter blocks      :\n-\/\/ suspend waiter     <suspended>         :\n-\/\/ exit threadLock    :                   :\n-\/\/ <ready to test>    :                   :\n-\/\/ :                  :                   :\n-\/\/ notify resumer     :                   wait finishes\n-\/\/ join resumer       :                   enter threadLock\n-\/\/ :                  <resumed>           resume waiter\n-\/\/ :                  :                   exit threadLock\n-\/\/ :                  reenter threadLock  :\n-\/\/ <join returns>     :                   resumer exits\n-\/\/ join waiter        :\n-\/\/ <join returns>     waiter exits\n-\/\/\n-\n-public class SuspendWithObjectMonitorWait {\n-    private static final String AGENT_LIB = \"SuspendWithObjectMonitorWait\";\n-    private static final int exit_delta   = 95;\n-\n-    private static final int DEF_TIME_MAX = 60;    \/\/ default max # secs to test\n-    private static final int JOIN_MAX     = 30;    \/\/ max # secs to wait for join\n-\n-    public static final int TS_INIT            = 1;  \/\/ initial testState\n-    public static final int TS_WAITER_RUNNING  = 2;  \/\/ waiter is running\n-    public static final int TS_RESUMER_RUNNING = 3;  \/\/ resumer is running\n-    public static final int TS_READY_TO_NOTIFY = 4;  \/\/ ready to notify threadLock\n-    public static final int TS_CALL_SUSPEND    = 5;  \/\/ call suspend on contender\n-    public static final int TS_READY_TO_RESUME = 6;  \/\/ ready to resume waiter\n-    public static final int TS_CALL_RESUME     = 7;  \/\/ call resume on waiter\n-    public static final int TS_WAITER_DONE     = 8;  \/\/ waiter has run; done\n-\n-    public static Object barrierLaunch = new Object();   \/\/ controls thread launch\n-    public static Object barrierResumer = new Object();  \/\/ controls resumer\n-    public static Object threadLock = new Object();      \/\/ testing object\n-\n-    public static long count = 0;\n-    public static boolean printDebug = false;\n-    public volatile static int testState;\n-\n-    private static void log(String msg) { System.out.println(msg); }\n-\n-    native static int suspendThread(SuspendWithObjectMonitorWaitWorker thr);\n-    native static int wait4ContendedEnter(SuspendWithObjectMonitorWaitWorker thr);\n-\n-    public static void main(String[] args) throws Exception {\n-        try {\n-            System.loadLibrary(AGENT_LIB);\n-            log(\"Loaded library: \" + AGENT_LIB);\n-        } catch (UnsatisfiedLinkError ule) {\n-            log(\"Failed to load library: \" + AGENT_LIB);\n-            log(\"java.library.path: \" + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-\n-        int timeMax = 0;\n-        if (args.length == 0) {\n-            timeMax = DEF_TIME_MAX;\n-        } else {\n-            int argIndex = 0;\n-            int argsLeft = args.length;\n-            if (args[0].equals(\"-p\")) {\n-                printDebug = true;\n-                argIndex = 1;\n-                argsLeft--;\n-            }\n-            if (argsLeft == 0) {\n-                timeMax = DEF_TIME_MAX;\n-            } else if (argsLeft == 1) {\n-                try {\n-                    timeMax = Integer.parseUnsignedInt(args[argIndex]);\n-                } catch (NumberFormatException nfe) {\n-                    System.err.println(\"'\" + args[argIndex] +\n-                                       \"': invalid timeMax value.\");\n-                    usage();\n-                }\n-            } else {\n-                usage();\n-            }\n-        }\n-\n-        System.exit(run(timeMax, System.out) + exit_delta);\n-    }\n-\n-    public static void logDebug(String mesg) {\n-        if (printDebug) {\n-            System.err.println(Thread.currentThread().getName() + \": \" + mesg);\n-        }\n-    }\n-\n-    public static void usage() {\n-        System.err.println(\"Usage: \" + AGENT_LIB + \" [-p][time_max]\");\n-        System.err.println(\"where:\");\n-        System.err.println(\"    -p       ::= print debug info\");\n-        System.err.println(\"    time_max ::= max looping time in seconds\");\n-        System.err.println(\"                 (default is \" + DEF_TIME_MAX +\n-                           \" seconds)\");\n-        System.exit(1);\n-    }\n-\n-    public static int run(int timeMax, PrintStream out) {\n-        return (new SuspendWithObjectMonitorWait()).doWork(timeMax, out);\n-    }\n-\n-    public static void checkTestState(int exp) {\n-        if (testState != exp) {\n-            System.err.println(\"Failure at \" + count + \" loops.\");\n-            throw new InternalError(\"Unexpected test state value: \"\n-                + \"expected=\" + exp + \" actual=\" + testState);\n-        }\n-    }\n-\n-    public int doWork(int timeMax, PrintStream out) {\n-        SuspendWithObjectMonitorWaitWorker waiter;    \/\/ waiter thread\n-        SuspendWithObjectMonitorWaitWorker resumer;    \/\/ resumer thread\n-\n-        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n-\n-        long start_time = System.currentTimeMillis();\n-        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n-            count++;\n-            testState = TS_INIT;  \/\/ starting the test loop\n-\n-            \/\/ launch the waiter thread\n-            synchronized (barrierLaunch) {\n-                waiter = new SuspendWithObjectMonitorWaitWorker(\"waiter\");\n-                waiter.start();\n-\n-                while (testState != TS_WAITER_RUNNING) {\n-                    try {\n-                        barrierLaunch.wait(0);  \/\/ wait until it is running\n-                    } catch (InterruptedException ex) {\n-                    }\n-                }\n-            }\n-\n-            \/\/ launch the resumer thread\n-            synchronized (barrierLaunch) {\n-                resumer = new SuspendWithObjectMonitorWaitWorker(\"resumer\", waiter);\n-                resumer.start();\n-\n-                while (testState != TS_RESUMER_RUNNING) {\n-                    try {\n-                        barrierLaunch.wait(0);  \/\/ wait until it is running\n-                    } catch (InterruptedException ex) {\n-                    }\n-                }\n-            }\n-\n-            checkTestState(TS_RESUMER_RUNNING);\n-\n-            \/\/ The waiter thread was synchronized on threadLock before it\n-            \/\/ set TS_WAITER_RUNNING and notified barrierLaunch above so\n-            \/\/ we cannot enter threadLock until the waiter thread calls\n-            \/\/ threadLock.wait().\n-            synchronized (threadLock) {\n-                \/\/ notify waiter thread so it can try to reenter threadLock\n-                testState = TS_READY_TO_NOTIFY;\n-                threadLock.notify();\n-\n-                \/\/ wait for the waiter thread to block\n-                logDebug(\"before contended enter wait\");\n-                int retCode = wait4ContendedEnter(waiter);\n-                if (retCode != 0) {\n-                    throw new RuntimeException(\"error in JVMTI GetThreadState: \"\n-                                               + \"retCode=\" + retCode);\n-                }\n-                logDebug(\"done contended enter wait\");\n-\n-                checkTestState(TS_READY_TO_NOTIFY);\n-                testState = TS_CALL_SUSPEND;\n-                logDebug(\"before suspend thread\");\n-                retCode = suspendThread(waiter);\n-                if (retCode != 0) {\n-                    throw new RuntimeException(\"error in JVMTI SuspendThread: \"\n-                                               + \"retCode=\" + retCode);\n-                }\n-                logDebug(\"suspended thread\");\n-            }\n-\n-            \/\/\n-            \/\/ At this point, all of the child threads are running\n-            \/\/ and we can get to meat of the test:\n-            \/\/\n-            \/\/ - suspended threadLock waiter (trying to reenter)\n-            \/\/ - a threadLock enter in the resumer thread\n-            \/\/ - resumption of the waiter thread\n-            \/\/ - a threadLock enter in the freshly resumed waiter thread\n-            \/\/\n-\n-            synchronized (barrierResumer) {\n-                checkTestState(TS_CALL_SUSPEND);\n-\n-                \/\/ tell resumer thread to resume waiter thread\n-                testState = TS_READY_TO_RESUME;\n-                barrierResumer.notify();\n-\n-                \/\/ Can't call checkTestState() here because the\n-                \/\/ resumer thread may have already resumed the\n-                \/\/ waiter thread.\n-            }\n-\n-            try {\n-                resumer.join(JOIN_MAX * 1000);\n-                if (resumer.isAlive()) {\n-                    System.err.println(\"Failure at \" + count + \" loops.\");\n-                    throw new InternalError(\"resumer thread is stuck\");\n-                }\n-                waiter.join(JOIN_MAX * 1000);\n-                if (waiter.isAlive()) {\n-                    System.err.println(\"Failure at \" + count + \" loops.\");\n-                    throw new InternalError(\"waiter thread is stuck\");\n-                }\n-            } catch (InterruptedException ex) {\n-            }\n-\n-            checkTestState(TS_WAITER_DONE);\n-        }\n-\n-        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n-                           \" seconds.\");\n-\n-        return 0;\n-    }\n-}\n-\n-class SuspendWithObjectMonitorWaitWorker extends Thread {\n-    private SuspendWithObjectMonitorWaitWorker target;  \/\/ target for resume operation\n-\n-    public SuspendWithObjectMonitorWaitWorker(String name) {\n-        super(name);\n-    }\n-\n-    public SuspendWithObjectMonitorWaitWorker(String name, SuspendWithObjectMonitorWaitWorker target) {\n-        super(name);\n-        this.target = target;\n-    }\n-\n-    native static int resumeThread(SuspendWithObjectMonitorWaitWorker thr);\n-\n-    public void run() {\n-        SuspendWithObjectMonitorWait.logDebug(\"thread running\");\n-\n-        \/\/\n-        \/\/ Launch the waiter thread:\n-        \/\/ - grab the threadLock\n-        \/\/ - threadLock.wait()\n-        \/\/ - releases threadLock\n-        \/\/\n-        if (getName().equals(\"waiter\")) {\n-            \/\/ grab threadLock before we tell main we are running\n-            SuspendWithObjectMonitorWait.logDebug(\"before enter threadLock\");\n-            synchronized(SuspendWithObjectMonitorWait.threadLock) {\n-                SuspendWithObjectMonitorWait.logDebug(\"enter threadLock\");\n-\n-                SuspendWithObjectMonitorWait.checkTestState(SuspendWithObjectMonitorWait.TS_INIT);\n-\n-                synchronized(SuspendWithObjectMonitorWait.barrierLaunch) {\n-                    \/\/ tell main we are running\n-                    SuspendWithObjectMonitorWait.testState = SuspendWithObjectMonitorWait.TS_WAITER_RUNNING;\n-                    SuspendWithObjectMonitorWait.barrierLaunch.notify();\n-                }\n-\n-                SuspendWithObjectMonitorWait.logDebug(\"before wait\");\n-\n-                \/\/ TS_READY_TO_NOTIFY is set after the main thread has\n-                \/\/ entered threadLock so a spurious wakeup can't get the\n-                \/\/ waiter thread out of this threadLock.wait(0) call:\n-                while (SuspendWithObjectMonitorWait.testState <= SuspendWithObjectMonitorWait.TS_READY_TO_NOTIFY) {\n-                    try {\n-                        SuspendWithObjectMonitorWait.threadLock.wait(0);\n-                    } catch (InterruptedException ex) {\n-                    }\n-                }\n-\n-                SuspendWithObjectMonitorWait.logDebug(\"after wait\");\n-\n-                SuspendWithObjectMonitorWait.checkTestState(SuspendWithObjectMonitorWait.TS_CALL_RESUME);\n-                SuspendWithObjectMonitorWait.testState = SuspendWithObjectMonitorWait.TS_WAITER_DONE;\n-\n-                SuspendWithObjectMonitorWait.logDebug(\"exit threadLock\");\n-            }\n-        }\n-        \/\/\n-        \/\/ Launch the resumer thread:\n-        \/\/ - tries to grab the threadLock (should not block!)\n-        \/\/ - grabs threadLock\n-        \/\/ - resumes the waiter thread\n-        \/\/ - releases threadLock\n-        \/\/\n-        else if (getName().equals(\"resumer\")) {\n-            synchronized(SuspendWithObjectMonitorWait.barrierResumer) {\n-                synchronized(SuspendWithObjectMonitorWait.barrierLaunch) {\n-                    \/\/ tell main we are running\n-                    SuspendWithObjectMonitorWait.testState = SuspendWithObjectMonitorWait.TS_RESUMER_RUNNING;\n-                    SuspendWithObjectMonitorWait.barrierLaunch.notify();\n-                }\n-                SuspendWithObjectMonitorWait.logDebug(\"thread waiting\");\n-                while (SuspendWithObjectMonitorWait.testState != SuspendWithObjectMonitorWait.TS_READY_TO_RESUME) {\n-                    try {\n-                        \/\/ wait for main to tell us when to continue\n-                        SuspendWithObjectMonitorWait.barrierResumer.wait(0);\n-                    } catch (InterruptedException ex) {\n-                    }\n-                }\n-            }\n-\n-            SuspendWithObjectMonitorWait.logDebug(\"before enter threadLock\");\n-            synchronized(SuspendWithObjectMonitorWait.threadLock) {\n-                SuspendWithObjectMonitorWait.logDebug(\"enter threadLock\");\n-\n-                SuspendWithObjectMonitorWait.checkTestState(SuspendWithObjectMonitorWait.TS_READY_TO_RESUME);\n-                SuspendWithObjectMonitorWait.testState = SuspendWithObjectMonitorWait.TS_CALL_RESUME;\n-\n-                \/\/ resume the waiter thread so waiter.join() can work\n-                SuspendWithObjectMonitorWait.logDebug(\"before resume thread\");\n-                int retCode = resumeThread(target);\n-                if (retCode != 0) {\n-                    throw new RuntimeException(\"error in JVMTI ResumeThread: \" +\n-                                               \"retCode=\" + retCode);\n-                }\n-                SuspendWithObjectMonitorWait.logDebug(\"resumed thread\");\n-\n-                SuspendWithObjectMonitorWait.logDebug(\"exit threadLock\");\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWait.java","additions":0,"deletions":371,"binary":false,"changes":371,"status":"deleted"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4413752 8262881\n+ * @summary Test SuspendThread with ObjectMonitor wait.\n+ * @requires vm.jvmti\n+ * @library \/test\/lib\n+ * @compile SuspendWithObjectMonitorWait1.java\n+ * @run main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait1\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+\/\/\n+\/\/ doWork1 algorithm:\n+\/\/ main               waiter              resumer\n+\/\/ =================  ==================  ===================\n+\/\/ launch waiter\n+\/\/ <launch returns>   waiter running\n+\/\/ launch resumer     enter threadLock\n+\/\/ <launch returns>   threadLock.wait()   resumer running\n+\/\/ enter threadLock   :                   wait for notify\n+\/\/ threadLock.notify  wait finishes       :\n+\/\/ :                  reenter blocks      :\n+\/\/ suspend waiter     <suspended>         :\n+\/\/ exit threadLock    :                   :\n+\/\/ <ready to test>    :                   :\n+\/\/ :                  :                   :\n+\/\/ notify resumer     :                   wait finishes\n+\/\/ join resumer       :                   enter threadLock\n+\/\/ :                  <resumed>           resume waiter\n+\/\/ :                  :                   exit threadLock\n+\/\/ :                  reenter threadLock  :\n+\/\/ <join returns>     :                   resumer exits\n+\/\/ join waiter        :\n+\/\/ <join returns>     waiter exits\n+\/\/\n+\n+public class SuspendWithObjectMonitorWait1 extends SuspendWithObjectMonitorWaitBase {\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length > 2) {\n+            System.err.println(\"Invalid number of arguments, there are too many arguments.\");\n+            usage();\n+        }\n+\n+        try {\n+            System.loadLibrary(AGENT_LIB);\n+            log(\"Loaded library: \" + AGENT_LIB);\n+        } catch (UnsatisfiedLinkError ule) {\n+            log(\"Failed to load library: \" + AGENT_LIB);\n+            log(\"java.library.path: \" + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+\n+        int timeMax = 0;\n+        for (int argIndex = 0; argIndex < args.length; argIndex++) {\n+            if (\"-p\".equals(args[argIndex])) {\n+                \/\/ Handle optional -p arg regardless of position.\n+                printDebug = true;\n+                continue;\n+            }\n+\n+            if (argIndex < args.length) {\n+                \/\/ timeMax is an optional arg.\n+                try {\n+                    timeMax = Integer.parseUnsignedInt(args[argIndex]);\n+                } catch (NumberFormatException nfe) {\n+                    System.err.println(\"'\" + args[argIndex] +\n+                            \"': invalid time_max value.\");\n+                    usage();\n+                }\n+            } else {\n+                timeMax = DEF_TIME_MAX;\n+            }\n+        }\n+        System.exit(run(timeMax, System.out) + exit_delta);\n+    }\n+\n+    public static int run(int timeMax, PrintStream out) {\n+        return (new SuspendWithObjectMonitorWait1()).doWork1(timeMax, out);\n+    }\n+\n+    \/\/ Default scenario, the resumer thread is always able to grab the threadLock once notified by the main thread.\n+    public int doWork1(int timeMax, PrintStream out) {\n+        SuspendWithObjectMonitorWaitWorker waiter;    \/\/ waiter thread\n+        SuspendWithObjectMonitorWaitWorker resumer;    \/\/ resumer thread\n+\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n+            testState = TS_INIT;  \/\/ starting the test loop\n+\n+            \/\/ launch the waiter thread\n+            synchronized (barrierLaunch) {\n+                waiter = new SuspendWithObjectMonitorWaitWorker(\"waiter\");\n+                waiter.start();\n+\n+                while (testState != TS_WAITER_RUNNING) {\n+                    try {\n+                        barrierLaunch.wait(0);  \/\/ wait until it is running\n+                    } catch (InterruptedException ex) {\n+                    }\n+                }\n+            }\n+\n+            \/\/ launch the resumer thread\n+            synchronized (barrierLaunch) {\n+                resumer = new SuspendWithObjectMonitorWaitWorker(\"resumer\", waiter);\n+                resumer.start();\n+\n+                while (testState != TS_RESUMER_RUNNING) {\n+                    try {\n+                        barrierLaunch.wait(0);  \/\/ wait until it is running\n+                    } catch (InterruptedException ex) {\n+                    }\n+                }\n+            }\n+\n+            checkTestState(TS_RESUMER_RUNNING);\n+\n+            \/\/ The waiter thread was synchronized on threadLock before it\n+            \/\/ set TS_WAITER_RUNNING and notified barrierLaunch above so\n+            \/\/ we cannot enter threadLock until the waiter thread calls\n+            \/\/ threadLock.wait().\n+            synchronized (threadLock) {\n+                \/\/ notify waiter thread so it can try to reenter threadLock\n+                testState = TS_READY_TO_NOTIFY;\n+                threadLock.notify();\n+\n+                \/\/ wait for the waiter thread to block\n+                logDebug(\"before contended enter wait\");\n+                int retCode = wait4ContendedEnter(waiter);\n+                if (retCode != 0) {\n+                    throw new RuntimeException(\"error in JVMTI GetThreadState: \"\n+                                               + \"retCode=\" + retCode);\n+                }\n+                logDebug(\"done contended enter wait\");\n+\n+                checkTestState(TS_READY_TO_NOTIFY);\n+                testState = TS_CALL_SUSPEND;\n+                logDebug(\"before suspend thread\");\n+                retCode = suspendThread(waiter);\n+                if (retCode != 0) {\n+                    throw new RuntimeException(\"error in JVMTI SuspendThread: \"\n+                                               + \"retCode=\" + retCode);\n+                }\n+                logDebug(\"suspended thread\");\n+            }\n+\n+            \/\/\n+            \/\/ At this point, all of the child threads are running\n+            \/\/ and we can get to meat of the test:\n+            \/\/\n+            \/\/ - suspended threadLock waiter (trying to reenter)\n+            \/\/ - a threadLock enter in the resumer thread\n+            \/\/ - resumption of the waiter thread\n+            \/\/ - a threadLock enter in the freshly resumed waiter thread\n+            \/\/\n+\n+            synchronized (barrierResumer) {\n+                checkTestState(TS_CALL_SUSPEND);\n+\n+                \/\/ tell resumer thread to resume waiter thread\n+                testState = TS_READY_TO_RESUME;\n+                barrierResumer.notify();\n+\n+                \/\/ Can't call checkTestState() here because the\n+                \/\/ resumer thread may have already resumed the\n+                \/\/ waiter thread.\n+            }\n+\n+            try {\n+                resumer.join(JOIN_MAX * 1000);\n+                if (resumer.isAlive()) {\n+                    System.err.println(\"Failure at \" + count + \" loops.\");\n+                    throw new InternalError(\"resumer thread is stuck\");\n+                }\n+                waiter.join(JOIN_MAX * 1000);\n+                if (waiter.isAlive()) {\n+                    System.err.println(\"Failure at \" + count + \" loops.\");\n+                    throw new InternalError(\"waiter thread is stuck\");\n+                }\n+            } catch (InterruptedException ex) {\n+            }\n+\n+            checkTestState(TS_WAITER_DONE);\n+        }\n+\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                           \" seconds.\");\n+\n+        return 0;\n+    }\n+}\n+\n+\n+\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWait1.java","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -0,0 +1,239 @@\n+\/*\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4413752 8262881\n+ * @summary Test SuspendThread with ObjectMonitor wait.\n+ * @requires vm.jvmti\n+ * @library \/test\/lib\n+ * @compile SuspendWithObjectMonitorWait2.java\n+ * @run main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait2\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+\/\/\n+\/\/ doWork2 algorithm:\n+\/\/\n+\/\/ main               waiter              resumer\n+\/\/ =================  ==================  ===================\n+\/\/ launch waiter\n+\/\/ <launch returns>   waiter running\n+\/\/ launch resumer     enter threadLock\n+\/\/ <launch returns>   threadLock.wait()   resumer running\n+\/\/ enter threadLock   :                   wait for notify\n+\/\/ threadLock.notify  wait finishes       :\n+\/\/ :                  reenter blocks      :\n+\/\/ suspend waiter     <suspended>         :\n+\/\/ <ready to test>    :                   :\n+\/\/ :                  :                   :\n+\/\/ notify resumer     :                   wait finishes\n+\/\/ delay 1-second     :                   :\n+\/\/ exit threadLock    :                   :\n+\/\/ join resumer       :                   enter threadLock\n+\/\/ :                  <resumed>           resume waiter\n+\/\/ :                  :                   exit threadLock\n+\/\/ :                  reenter threadLock  :\n+\/\/ <join returns>     :                   resumer exits\n+\/\/ join waiter        :\n+\/\/ <join returns>     waiter exits\n+\/\/\n+\/\/ Note: The sleep(1-second) in main along with the delayed exit\n+\/\/       of threadLock in main forces the resumer thread to reach\n+\/\/       \"enter threadLock\" and block. This difference from doWork1\n+\/\/       forces the resumer thread to be contending for threadLock\n+\/\/       while the waiter thread is in threadLock.wait() increasing\n+\/\/       stress on the monitor sub-system.\n+\/\/\n+\n+public class SuspendWithObjectMonitorWait2 extends SuspendWithObjectMonitorWaitBase {\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length > 2) {\n+            System.err.println(\"Invalid number of arguments, there are too many arguments.\");\n+            usage();\n+        }\n+\n+        try {\n+            System.loadLibrary(AGENT_LIB);\n+            log(\"Loaded library: \" + AGENT_LIB);\n+        } catch (UnsatisfiedLinkError ule) {\n+            log(\"Failed to load library: \" + AGENT_LIB);\n+            log(\"java.library.path: \" + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+\n+        int timeMax = 0;\n+        for (int argIndex = 0; argIndex < args.length; argIndex++) {\n+            if (\"-p\".equals(args[argIndex])) {\n+                \/\/ Handle optional -p arg regardless of position.\n+                printDebug = true;\n+                continue;\n+            }\n+\n+            if (argIndex < args.length) {\n+                \/\/ timeMax is an optional arg.\n+                try {\n+                    timeMax = Integer.parseUnsignedInt(args[argIndex]);\n+                } catch (NumberFormatException nfe) {\n+                    System.err.println(\"'\" + args[argIndex] +\n+                                       \"': invalid time_max value.\");\n+                    usage();\n+                }\n+            } else {\n+                timeMax = DEF_TIME_MAX;\n+            }\n+        }\n+\n+        System.exit(run(timeMax, System.out) + exit_delta);\n+    }\n+\n+    public static int run(int timeMax, PrintStream out) {\n+        return (new SuspendWithObjectMonitorWait2()).doWork2(timeMax, out);\n+    }\n+\n+    \/\/ Notify the resumer while holding the threadLock.\n+    public int doWork2(int timeMax, PrintStream out) {\n+        SuspendWithObjectMonitorWaitWorker waiter;    \/\/ waiter thread\n+        SuspendWithObjectMonitorWaitWorker resumer;    \/\/ resumer thread\n+\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n+            testState = TS_INIT;  \/\/ starting the test loop\n+\n+            \/\/ launch the waiter thread\n+            synchronized (barrierLaunch) {\n+                waiter = new SuspendWithObjectMonitorWaitWorker(\"waiter\");\n+                waiter.start();\n+\n+                while (testState != TS_WAITER_RUNNING) {\n+                    try {\n+                        barrierLaunch.wait(0);  \/\/ wait until it is running\n+                    } catch (InterruptedException ex) {\n+                    }\n+                }\n+            }\n+\n+            \/\/ launch the resumer thread\n+            synchronized (barrierLaunch) {\n+                resumer = new SuspendWithObjectMonitorWaitWorker(\"resumer\", waiter);\n+                resumer.start();\n+\n+                while (testState != TS_RESUMER_RUNNING) {\n+                    try {\n+                        barrierLaunch.wait(0);  \/\/ wait until it is running\n+                    } catch (InterruptedException ex) {\n+                    }\n+                }\n+            }\n+\n+            checkTestState(TS_RESUMER_RUNNING);\n+\n+            \/\/ The waiter thread was synchronized on threadLock before it\n+            \/\/ set TS_WAITER_RUNNING and notified barrierLaunch above so\n+            \/\/ we cannot enter threadLock until the waiter thread calls\n+            \/\/ threadLock.wait().\n+            synchronized (threadLock) {\n+                \/\/ notify waiter thread so it can try to reenter threadLock\n+                testState = TS_READY_TO_NOTIFY;\n+                threadLock.notify();\n+\n+                \/\/ wait for the waiter thread to block\n+                logDebug(\"before contended enter wait\");\n+                int retCode = wait4ContendedEnter(waiter);\n+                if (retCode != 0) {\n+                    throw new RuntimeException(\"error in JVMTI GetThreadState: \"\n+                            + \"retCode=\" + retCode);\n+                }\n+                logDebug(\"done contended enter wait\");\n+\n+                checkTestState(TS_READY_TO_NOTIFY);\n+                testState = TS_CALL_SUSPEND;\n+                logDebug(\"before suspend thread\");\n+                retCode = suspendThread(waiter);\n+                if (retCode != 0) {\n+                    throw new RuntimeException(\"error in JVMTI SuspendThread: \"\n+                            + \"retCode=\" + retCode);\n+                }\n+                logDebug(\"suspended thread\");\n+\n+                \/\/\n+                \/\/ At this point, all of the child threads are running\n+                \/\/ and we can get to meat of the test:\n+                \/\/\n+                \/\/ - suspended threadLock waiter (trying to reenter)\n+                \/\/ - a blocked threadLock enter in the resumer thread while the\n+                \/\/   threadLock is held by the main thread.\n+                \/\/ - resumption of the waiter thread\n+                \/\/ - a threadLock enter in the freshly resumed waiter thread\n+                \/\/\n+\n+                synchronized (barrierResumer) {\n+                    checkTestState(TS_CALL_SUSPEND);\n+\n+                    \/\/ tell resumer thread to resume waiter thread\n+                    testState = TS_READY_TO_RESUME;\n+                    barrierResumer.notify();\n+\n+                    \/\/ Can't call checkTestState() here because the\n+                    \/\/ resumer thread may have already resumed the\n+                    \/\/ waiter thread.\n+                }\n+                try {\n+                    \/\/ Delay for 1-second while holding the threadLock to force the\n+                    \/\/ resumer thread to block on entering the threadLock.\n+                    Thread.sleep(1000);\n+                } catch(Exception e) {}\n+            }\n+\n+            try {\n+                resumer.join(JOIN_MAX * 1000);\n+                if (resumer.isAlive()) {\n+                    System.err.println(\"Failure at \" + count + \" loops.\");\n+                    throw new InternalError(\"resumer thread is stuck\");\n+                }\n+                waiter.join(JOIN_MAX * 1000);\n+                if (waiter.isAlive()) {\n+                    System.err.println(\"Failure at \" + count + \" loops.\");\n+                    throw new InternalError(\"waiter thread is stuck\");\n+                }\n+            } catch (InterruptedException ex) {\n+            }\n+\n+            checkTestState(TS_WAITER_DONE);\n+        }\n+\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                \" seconds.\");\n+\n+        return 0;\n+    }\n+}\n+\n+\n+\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWait2.java","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"},{"patch":"@@ -0,0 +1,249 @@\n+\/*\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4413752 8262881\n+ * @summary Test SuspendThread with ObjectMonitor wait.\n+ * @requires vm.jvmti\n+ * @library \/test\/lib\n+ * @compile SuspendWithObjectMonitorWait3.java\n+ * @run main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait3\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+\/\/\n+\/\/ doWork3 algorithm:\n+\/\/\n+\/\/ main                 waiter                  resumer\n+\/\/ ===================  ======================  ===================\n+\/\/ launch waiter\n+\/\/ <launch returns>     waiter running\n+\/\/ launch resumer       enter threadLock\n+\/\/ <launch returns>     while !READY_TO_NOTIFY  resumer running\n+\/\/ :                      threadLock.wait(1)    wait for notify\n+\/\/ enter threadLock     :                       :\n+\/\/ set READY_TO_NOTIFY  :\n+\/\/ threadLock.notify    wait finishes           :\n+\/\/ : delay 200ms        reenter blocks          :\n+\/\/ suspend waiter       <suspended>             :\n+\/\/ <ready to test>      :                       :\n+\/\/ :                    :                       :\n+\/\/ notify resumer       :                       wait finishes\n+\/\/ delay 1-second       :                       :\n+\/\/ exit threadLock      :                       :\n+\/\/ join resumer         :                       enter threadLock\n+\/\/ :                    <resumed>               resume waiter\n+\/\/ :                    :                       exit threadLock\n+\/\/ :                    reenter threadLock      :\n+\/\/ <join returns>       :                       resumer exits\n+\/\/ join waiter          :\n+\/\/ <join returns>       waiter exits\n+\/\/\n+\/\/ Note: The sleep(1-second) in main along with the delayed exit\n+\/\/       of threadLock in main forces the resumer thread to reach\n+\/\/       \"enter threadLock\" and block. This difference from doWork1\n+\/\/       forces the resumer thread to be contending for threadLock\n+\/\/       while the waiter thread is in the threadLock.wait(1) tight\n+\/\/       loop increasing stress on the monitor sub-system.\n+\/\/\n+\/\/ Note: sleep(200ms) here while holding the threadLock to allow the\n+\/\/       waiter thread's timed wait to finish before we attempt to\n+\/\/       suspend the waiter thread.\n+\/\/\n+\n+public class SuspendWithObjectMonitorWait3 extends SuspendWithObjectMonitorWaitBase {\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length > 2) {\n+            System.err.println(\"Invalid number of arguments, there are too many arguments.\");\n+            usage();\n+        }\n+\n+        try {\n+            System.loadLibrary(AGENT_LIB);\n+            log(\"Loaded library: \" + AGENT_LIB);\n+        } catch (UnsatisfiedLinkError ule) {\n+            log(\"Failed to load library: \" + AGENT_LIB);\n+            log(\"java.library.path: \" + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+\n+        int timeMax = 0;\n+        for (int argIndex = 0; argIndex < args.length; argIndex++) {\n+            if (\"-p\".equals(args[argIndex])) {\n+                \/\/ Handle optional -p arg regardless of position.\n+                printDebug = true;\n+                continue;\n+            }\n+\n+            if (argIndex < args.length) {\n+                \/\/ timeMax is an optional arg.\n+                try {\n+                    timeMax = Integer.parseUnsignedInt(args[argIndex]);\n+                } catch (NumberFormatException nfe) {\n+                    System.err.println(\"'\" + args[argIndex] +\n+                                       \"': invalid time_max value.\");\n+                    usage();\n+                }\n+            } else {\n+                timeMax = DEF_TIME_MAX;\n+            }\n+        }\n+\n+        System.exit(run(timeMax, System.out) + exit_delta);\n+    }\n+\n+    public static int run(int timeMax, PrintStream out) {\n+        return (new SuspendWithObjectMonitorWait3()).doWork3(timeMax, out);\n+    }\n+\n+    \/\/ Suspend on the re-entry path of wait.\n+    public int doWork3(int timeMax, PrintStream out) {\n+        SuspendWithObjectMonitorWaitWorker waiter;    \/\/ waiter thread\n+        SuspendWithObjectMonitorWaitWorker resumer;    \/\/ resumer thread\n+\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n+            testState = TS_INIT;  \/\/ starting the test loop\n+\n+            \/\/ launch the waiter thread\n+            synchronized (barrierLaunch) {\n+                waiter = new SuspendWithObjectMonitorWaitWorker(\"waiter\", 100);\n+                waiter.start();\n+\n+                while (testState != TS_WAITER_RUNNING) {\n+                    try {\n+                        barrierLaunch.wait(0);  \/\/ wait until it is running\n+                    } catch (InterruptedException ex) {\n+                    }\n+                }\n+            }\n+\n+            \/\/ launch the resumer thread\n+            synchronized (barrierLaunch) {\n+                resumer = new SuspendWithObjectMonitorWaitWorker(\"resumer\", waiter);\n+                resumer.start();\n+\n+                while (testState != TS_RESUMER_RUNNING) {\n+                    try {\n+                        barrierLaunch.wait(0);  \/\/ wait until it is running\n+                    } catch (InterruptedException ex) {\n+                    }\n+                }\n+            }\n+\n+            checkTestState(TS_RESUMER_RUNNING);\n+\n+            \/\/ The waiter thread was synchronized on threadLock before it\n+            \/\/ set TS_WAITER_RUNNING and notified barrierLaunch above so\n+            \/\/ we cannot enter threadLock until the waiter thread calls\n+            \/\/ threadLock.wait().\n+            synchronized (threadLock) {\n+                \/\/ notify waiter thread so it can try to reenter threadLock\n+                testState = TS_READY_TO_NOTIFY;\n+                threadLock.notify();\n+\n+                try {\n+                    Thread.sleep(200);\n+                } catch (Exception e) {}\n+\n+                \/\/ wait for the waiter thread to block\n+                logDebug(\"before contended enter wait\");\n+                int retCode = wait4ContendedEnter(waiter);\n+                if (retCode != 0) {\n+                    throw new RuntimeException(\"error in JVMTI GetThreadState: \"\n+                            + \"retCode=\" + retCode);\n+                }\n+                logDebug(\"done contended enter wait\");\n+\n+                checkTestState(TS_READY_TO_NOTIFY);\n+                testState = TS_CALL_SUSPEND;\n+                logDebug(\"before suspend thread\");\n+                retCode = suspendThread(waiter);\n+                if (retCode != 0) {\n+                    throw new RuntimeException(\"error in JVMTI SuspendThread: \"\n+                            + \"retCode=\" + retCode);\n+                }\n+                logDebug(\"suspended thread\");\n+\n+                \/\/\n+                \/\/ At this point, all of the child threads are running\n+                \/\/ and we can get to meat of the test:\n+                \/\/\n+                \/\/ - suspended threadLock waiter (trying to reenter)\n+                \/\/ - a blocked threadLock enter in the resumer thread while the\n+                \/\/   threadLock is held by the main thread.\n+                \/\/ - resumption of the waiter thread\n+                \/\/ - a threadLock enter in the freshly resumed waiter thread\n+                \/\/\n+\n+                synchronized (barrierResumer) {\n+                    checkTestState(TS_CALL_SUSPEND);\n+\n+                    \/\/ tell resumer thread to resume waiter thread\n+                    testState = TS_READY_TO_RESUME;\n+                    barrierResumer.notify();\n+\n+                    \/\/ Can't call checkTestState() here because the\n+                    \/\/ resumer thread may have already resumed the\n+                    \/\/ waiter thread.\n+                }\n+                try {\n+                    \/\/ Delay for 1-second while holding the threadLock to force the\n+                    \/\/ resumer thread to block on entering the threadLock.\n+                    Thread.sleep(1000);\n+                } catch (Exception e) {}\n+            }\n+\n+            try {\n+                resumer.join(JOIN_MAX * 1000);\n+                if (resumer.isAlive()) {\n+                    System.err.println(\"Failure at \" + count + \" loops.\");\n+                    throw new InternalError(\"resumer thread is stuck\");\n+                }\n+                waiter.join(JOIN_MAX * 1000);\n+                if (waiter.isAlive()) {\n+                    System.err.println(\"Failure at \" + count + \" loops.\");\n+                    throw new InternalError(\"waiter thread is stuck\");\n+                }\n+            } catch (InterruptedException ex) {\n+            }\n+\n+            checkTestState(TS_WAITER_DONE);\n+        }\n+\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                \" seconds.\");\n+\n+        return 0;\n+    }\n+}\n+\n+\n+\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWait3.java","additions":249,"deletions":0,"binary":false,"changes":249,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class SuspendWithObjectMonitorWaitBase {\n+    protected static final String AGENT_LIB = \"SuspendWithObjectMonitorWait\";\n+    protected static final int exit_delta   = 95;\n+\n+    protected static final int DEF_TIME_MAX = 60;    \/\/ default max # secs to test\n+    protected static final int JOIN_MAX     = 30;    \/\/ max # secs to wait for join\n+\n+    public static final int TS_INIT            = 1;  \/\/ initial testState\n+    public static final int TS_WAITER_RUNNING  = 2;  \/\/ waiter is running\n+    public static final int TS_RESUMER_RUNNING = 3;  \/\/ resumer is running\n+    public static final int TS_READY_TO_NOTIFY = 4;  \/\/ ready to notify threadLock\n+    public static final int TS_CALL_SUSPEND    = 5;  \/\/ call suspend on contender\n+    public static final int TS_READY_TO_RESUME = 6;  \/\/ ready to resume waiter\n+    public static final int TS_CALL_RESUME     = 7;  \/\/ call resume on waiter\n+    public static final int TS_WAITER_DONE     = 8;  \/\/ waiter has run; done\n+\n+    public static Object barrierLaunch = new Object();   \/\/ controls thread launch\n+    public static Object barrierResumer = new Object();  \/\/ controls resumer\n+    public static Object threadLock = new Object();      \/\/ testing object\n+\n+    public static long count = 0;\n+    public static boolean printDebug = false;\n+    public volatile static int testState;\n+\n+    protected static void log(String msg) { System.out.println(msg); }\n+\n+    native static int suspendThread(SuspendWithObjectMonitorWaitWorker thr);\n+    native static int wait4ContendedEnter(SuspendWithObjectMonitorWaitWorker thr);\n+\n+    public static void logDebug(String mesg) {\n+        if (printDebug) {\n+            System.err.println(Thread.currentThread().getName() + \": \" + mesg);\n+        }\n+    }\n+\n+    public static void usage() {\n+        System.err.println(\"Usage: \" + AGENT_LIB + \" test_case [-p] [time_max]\");\n+        System.err.println(\"where:\");\n+        System.err.println(\"    test_case ::= 1 | 2 | 3\");\n+        System.err.println(\"    -p        ::= print debug info\");\n+        System.err.println(\"    time_max  ::= max looping time in seconds\");\n+        System.err.println(\"                  (default is \" + DEF_TIME_MAX +\n+                \" seconds)\");\n+        System.exit(1);\n+    }\n+\n+    public static void checkTestState(int exp) {\n+        if (testState != exp) {\n+            System.err.println(\"Failure at \" + count + \" loops.\");\n+            throw new InternalError(\"Unexpected test state value: \"\n+                    + \"expected=\" + exp + \" actual=\" + testState);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWaitBase.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+class SuspendWithObjectMonitorWaitWorker extends Thread {\n+    private SuspendWithObjectMonitorWaitWorker target;  \/\/ target for resume operation\n+    private final long waitTimeout;\n+\n+    public SuspendWithObjectMonitorWaitWorker(String name) {\n+        super(name);\n+        this.waitTimeout = 0;\n+    }\n+\n+    public SuspendWithObjectMonitorWaitWorker(String name, long waitTimeout) {\n+        super(name);\n+        this.waitTimeout = waitTimeout;\n+    }\n+\n+    public SuspendWithObjectMonitorWaitWorker(String name, SuspendWithObjectMonitorWaitWorker target) {\n+        super(name);\n+        this.target = target;\n+        this.waitTimeout = 0;\n+    }\n+\n+    native static int resumeThread(SuspendWithObjectMonitorWaitWorker thr);\n+\n+    public void run() {\n+        SuspendWithObjectMonitorWait1.logDebug(\"thread running\");\n+\n+        \/\/\n+        \/\/ Launch the waiter thread:\n+        \/\/ - grab the threadLock\n+        \/\/ - threadLock.wait()\n+        \/\/ - releases threadLock\n+        \/\/\n+        if (getName().equals(\"waiter\")) {\n+            \/\/ grab threadLock before we tell main we are running\n+            SuspendWithObjectMonitorWait1.logDebug(\"before enter threadLock\");\n+            synchronized(SuspendWithObjectMonitorWait1.threadLock) {\n+                SuspendWithObjectMonitorWait1.logDebug(\"enter threadLock\");\n+\n+                SuspendWithObjectMonitorWait1.checkTestState(SuspendWithObjectMonitorWait1.TS_INIT);\n+\n+                synchronized(SuspendWithObjectMonitorWait1.barrierLaunch) {\n+                    \/\/ tell main we are running\n+                    SuspendWithObjectMonitorWait1.testState = SuspendWithObjectMonitorWait1.TS_WAITER_RUNNING;\n+                    SuspendWithObjectMonitorWait1.barrierLaunch.notify();\n+                }\n+\n+                SuspendWithObjectMonitorWait1.logDebug(\"before wait\");\n+\n+                \/\/ TS_READY_TO_NOTIFY is set after the main thread has\n+                \/\/ entered threadLock so a spurious wakeup can't get the\n+                \/\/ waiter thread out of this threadLock.wait(0) call:\n+                while (SuspendWithObjectMonitorWait1.testState <= SuspendWithObjectMonitorWait1.TS_READY_TO_NOTIFY) {\n+                    try {\n+                        SuspendWithObjectMonitorWait1.threadLock.wait(waitTimeout);\n+                    } catch (InterruptedException ex) {\n+                    }\n+                }\n+\n+                SuspendWithObjectMonitorWait1.logDebug(\"after wait\");\n+\n+                SuspendWithObjectMonitorWait1.checkTestState(SuspendWithObjectMonitorWait1.TS_CALL_RESUME);\n+                SuspendWithObjectMonitorWait1.testState = SuspendWithObjectMonitorWait1.TS_WAITER_DONE;\n+\n+                SuspendWithObjectMonitorWait1.logDebug(\"exit threadLock\");\n+            }\n+        }\n+        \/\/\n+        \/\/ Launch the resumer thread:\n+        \/\/ - tries to grab the threadLock (should not block with doWork1!)\n+        \/\/ - grabs threadLock\n+        \/\/ - resumes the waiter thread\n+        \/\/ - releases threadLock\n+        \/\/\n+        else if (getName().equals(\"resumer\")) {\n+            synchronized(SuspendWithObjectMonitorWait1.barrierResumer) {\n+                synchronized(SuspendWithObjectMonitorWait1.barrierLaunch) {\n+                    \/\/ tell main we are running\n+                    SuspendWithObjectMonitorWait1.testState = SuspendWithObjectMonitorWait1.TS_RESUMER_RUNNING;\n+                    SuspendWithObjectMonitorWait1.barrierLaunch.notify();\n+                }\n+                SuspendWithObjectMonitorWait1.logDebug(\"thread waiting\");\n+                while (SuspendWithObjectMonitorWait1.testState != SuspendWithObjectMonitorWait1.TS_READY_TO_RESUME) {\n+                    try {\n+                        \/\/ wait for main to tell us when to continue\n+                        SuspendWithObjectMonitorWait1.barrierResumer.wait(0);\n+                    } catch (InterruptedException ex) {\n+                    }\n+                }\n+            }\n+\n+            SuspendWithObjectMonitorWait1.logDebug(\"before enter threadLock\");\n+            synchronized(SuspendWithObjectMonitorWait1.threadLock) {\n+                SuspendWithObjectMonitorWait1.logDebug(\"enter threadLock\");\n+\n+                SuspendWithObjectMonitorWait1.checkTestState(SuspendWithObjectMonitorWait1.TS_READY_TO_RESUME);\n+                SuspendWithObjectMonitorWait1.testState = SuspendWithObjectMonitorWait1.TS_CALL_RESUME;\n+\n+                \/\/ resume the waiter thread so waiter.join() can work\n+                SuspendWithObjectMonitorWait1.logDebug(\"before resume thread\");\n+                int retCode = resumeThread(target);\n+                if (retCode != 0) {\n+                    throw new RuntimeException(\"error in JVMTI ResumeThread: \" +\n+                            \"retCode=\" + retCode);\n+                }\n+                SuspendWithObjectMonitorWait1.logDebug(\"resumed thread\");\n+\n+                SuspendWithObjectMonitorWait1.logDebug(\"exit threadLock\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWaitWorker.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -39,1 +39,1 @@\n-Java_SuspendWithObjectMonitorWait_suspendThread(JNIEnv *jni, jclass cls, jthread thr) {\n+Java_SuspendWithObjectMonitorWaitBase_suspendThread(JNIEnv *jni, jclass cls, jthread thr) {\n@@ -49,1 +49,1 @@\n-Java_SuspendWithObjectMonitorWait_wait4ContendedEnter(JNIEnv *jni, jclass cls, jthread thr) {\n+Java_SuspendWithObjectMonitorWaitBase_wait4ContendedEnter(JNIEnv *jni, jclass cls, jthread thr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/libSuspendWithObjectMonitorWait.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}