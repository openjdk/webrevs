{"files":[{"patch":"@@ -63,41 +63,3 @@\n-    public static void main(String[] args) throws Exception {\n-        if (args.length > 2) {\n-            System.err.println(\"Invalid number of arguments, there are too many arguments.\");\n-            usage();\n-        }\n-\n-        try {\n-            System.loadLibrary(AGENT_LIB);\n-            log(\"Loaded library: \" + AGENT_LIB);\n-        } catch (UnsatisfiedLinkError ule) {\n-            log(\"Failed to load library: \" + AGENT_LIB);\n-            log(\"java.library.path: \" + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-\n-        int timeMax = 0;\n-        for (int argIndex = 0; argIndex < args.length; argIndex++) {\n-            if (\"-p\".equals(args[argIndex])) {\n-                \/\/ Handle optional -p arg regardless of position.\n-                printDebug = true;\n-                continue;\n-            }\n-\n-            if (argIndex < args.length) {\n-                \/\/ timeMax is an optional arg.\n-                try {\n-                    timeMax = Integer.parseUnsignedInt(args[argIndex]);\n-                } catch (NumberFormatException nfe) {\n-                    System.err.println(\"'\" + args[argIndex] +\n-                            \"': invalid time_max value.\");\n-                    usage();\n-                }\n-            } else {\n-                timeMax = DEF_TIME_MAX;\n-            }\n-        }\n-        System.exit(run(timeMax, System.out) + exit_delta);\n-    }\n-\n-    public static int run(int timeMax, PrintStream out) {\n-        return (new SuspendWithObjectMonitorWait1()).doWork1(timeMax, out);\n+    @Override\n+    public int run(int timeMax, PrintStream out) {\n+        return doWork1(timeMax, out);\n@@ -119,11 +81,1 @@\n-            synchronized (barrierLaunch) {\n-                waiter = new SuspendWithObjectMonitorWaitWorker(\"waiter\");\n-                waiter.start();\n-\n-                while (testState != TS_WAITER_RUNNING) {\n-                    try {\n-                        barrierLaunch.wait(0);  \/\/ wait until it is running\n-                    } catch (InterruptedException ex) {\n-                    }\n-                }\n-            }\n+            waiter = launchWaiter(0);\n@@ -132,11 +84,1 @@\n-            synchronized (barrierLaunch) {\n-                resumer = new SuspendWithObjectMonitorWaitWorker(\"resumer\", waiter);\n-                resumer.start();\n-\n-                while (testState != TS_RESUMER_RUNNING) {\n-                    try {\n-                        barrierLaunch.wait(0);  \/\/ wait until it is running\n-                    } catch (InterruptedException ex) {\n-                    }\n-                }\n-            }\n+            resumer = launchResumer(waiter);\n@@ -184,0 +126,1 @@\n+            barrierResumerNotify();\n@@ -185,26 +128,1 @@\n-            synchronized (barrierResumer) {\n-                checkTestState(TS_CALL_SUSPEND);\n-\n-                \/\/ tell resumer thread to resume waiter thread\n-                testState = TS_READY_TO_RESUME;\n-                barrierResumer.notify();\n-\n-                \/\/ Can't call checkTestState() here because the\n-                \/\/ resumer thread may have already resumed the\n-                \/\/ waiter thread.\n-            }\n-\n-            try {\n-                resumer.join(JOIN_MAX * 1000);\n-                if (resumer.isAlive()) {\n-                    System.err.println(\"Failure at \" + count + \" loops.\");\n-                    throw new InternalError(\"resumer thread is stuck\");\n-                }\n-                waiter.join(JOIN_MAX * 1000);\n-                if (waiter.isAlive()) {\n-                    System.err.println(\"Failure at \" + count + \" loops.\");\n-                    throw new InternalError(\"waiter thread is stuck\");\n-                }\n-            } catch (InterruptedException ex) {\n-            }\n-\n+            shutDown(waiter ,resumer);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWait1.java","additions":7,"deletions":89,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -72,42 +72,3 @@\n-    public static void main(String[] args) throws Exception {\n-        if (args.length > 2) {\n-            System.err.println(\"Invalid number of arguments, there are too many arguments.\");\n-            usage();\n-        }\n-\n-        try {\n-            System.loadLibrary(AGENT_LIB);\n-            log(\"Loaded library: \" + AGENT_LIB);\n-        } catch (UnsatisfiedLinkError ule) {\n-            log(\"Failed to load library: \" + AGENT_LIB);\n-            log(\"java.library.path: \" + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-\n-        int timeMax = 0;\n-        for (int argIndex = 0; argIndex < args.length; argIndex++) {\n-            if (\"-p\".equals(args[argIndex])) {\n-                \/\/ Handle optional -p arg regardless of position.\n-                printDebug = true;\n-                continue;\n-            }\n-\n-            if (argIndex < args.length) {\n-                \/\/ timeMax is an optional arg.\n-                try {\n-                    timeMax = Integer.parseUnsignedInt(args[argIndex]);\n-                } catch (NumberFormatException nfe) {\n-                    System.err.println(\"'\" + args[argIndex] +\n-                                       \"': invalid time_max value.\");\n-                    usage();\n-                }\n-            } else {\n-                timeMax = DEF_TIME_MAX;\n-            }\n-        }\n-\n-        System.exit(run(timeMax, System.out) + exit_delta);\n-    }\n-\n-    public static int run(int timeMax, PrintStream out) {\n-        return (new SuspendWithObjectMonitorWait2()).doWork2(timeMax, out);\n+    @Override\n+    public int run(int timeMax, PrintStream out) {\n+        return doWork2(timeMax, out);\n@@ -129,11 +90,1 @@\n-            synchronized (barrierLaunch) {\n-                waiter = new SuspendWithObjectMonitorWaitWorker(\"waiter\");\n-                waiter.start();\n-\n-                while (testState != TS_WAITER_RUNNING) {\n-                    try {\n-                        barrierLaunch.wait(0);  \/\/ wait until it is running\n-                    } catch (InterruptedException ex) {\n-                    }\n-                }\n-            }\n+            waiter = launchWaiter(0);\n@@ -142,11 +93,1 @@\n-            synchronized (barrierLaunch) {\n-                resumer = new SuspendWithObjectMonitorWaitWorker(\"resumer\", waiter);\n-                resumer.start();\n-\n-                while (testState != TS_RESUMER_RUNNING) {\n-                    try {\n-                        barrierLaunch.wait(0);  \/\/ wait until it is running\n-                    } catch (InterruptedException ex) {\n-                    }\n-                }\n-            }\n+            resumer = launchResumer(waiter);\n@@ -194,12 +135,1 @@\n-\n-                synchronized (barrierResumer) {\n-                    checkTestState(TS_CALL_SUSPEND);\n-\n-                    \/\/ tell resumer thread to resume waiter thread\n-                    testState = TS_READY_TO_RESUME;\n-                    barrierResumer.notify();\n-\n-                    \/\/ Can't call checkTestState() here because the\n-                    \/\/ resumer thread may have already resumed the\n-                    \/\/ waiter thread.\n-                }\n+                barrierResumerNotify();\n@@ -210,15 +140,1 @@\n-                } catch(Exception e) {}\n-            }\n-\n-            try {\n-                resumer.join(JOIN_MAX * 1000);\n-                if (resumer.isAlive()) {\n-                    System.err.println(\"Failure at \" + count + \" loops.\");\n-                    throw new InternalError(\"resumer thread is stuck\");\n-                }\n-                waiter.join(JOIN_MAX * 1000);\n-                if (waiter.isAlive()) {\n-                    System.err.println(\"Failure at \" + count + \" loops.\");\n-                    throw new InternalError(\"waiter thread is stuck\");\n-                }\n-            } catch (InterruptedException ex) {\n+                } catch (Exception e) {}\n@@ -227,0 +143,1 @@\n+            shutDown(waiter ,resumer);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWait2.java","additions":8,"deletions":91,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -78,42 +78,3 @@\n-    public static void main(String[] args) throws Exception {\n-        if (args.length > 2) {\n-            System.err.println(\"Invalid number of arguments, there are too many arguments.\");\n-            usage();\n-        }\n-\n-        try {\n-            System.loadLibrary(AGENT_LIB);\n-            log(\"Loaded library: \" + AGENT_LIB);\n-        } catch (UnsatisfiedLinkError ule) {\n-            log(\"Failed to load library: \" + AGENT_LIB);\n-            log(\"java.library.path: \" + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-\n-        int timeMax = 0;\n-        for (int argIndex = 0; argIndex < args.length; argIndex++) {\n-            if (\"-p\".equals(args[argIndex])) {\n-                \/\/ Handle optional -p arg regardless of position.\n-                printDebug = true;\n-                continue;\n-            }\n-\n-            if (argIndex < args.length) {\n-                \/\/ timeMax is an optional arg.\n-                try {\n-                    timeMax = Integer.parseUnsignedInt(args[argIndex]);\n-                } catch (NumberFormatException nfe) {\n-                    System.err.println(\"'\" + args[argIndex] +\n-                                       \"': invalid time_max value.\");\n-                    usage();\n-                }\n-            } else {\n-                timeMax = DEF_TIME_MAX;\n-            }\n-        }\n-\n-        System.exit(run(timeMax, System.out) + exit_delta);\n-    }\n-\n-    public static int run(int timeMax, PrintStream out) {\n-        return (new SuspendWithObjectMonitorWait3()).doWork3(timeMax, out);\n+    @Override\n+    public int run(int timeMax, PrintStream out) {\n+        return doWork3(timeMax, out);\n@@ -135,11 +96,1 @@\n-            synchronized (barrierLaunch) {\n-                waiter = new SuspendWithObjectMonitorWaitWorker(\"waiter\", 100);\n-                waiter.start();\n-\n-                while (testState != TS_WAITER_RUNNING) {\n-                    try {\n-                        barrierLaunch.wait(0);  \/\/ wait until it is running\n-                    } catch (InterruptedException ex) {\n-                    }\n-                }\n-            }\n+            waiter = launchWaiter(100);\n@@ -148,11 +99,1 @@\n-            synchronized (barrierLaunch) {\n-                resumer = new SuspendWithObjectMonitorWaitWorker(\"resumer\", waiter);\n-                resumer.start();\n-\n-                while (testState != TS_RESUMER_RUNNING) {\n-                    try {\n-                        barrierLaunch.wait(0);  \/\/ wait until it is running\n-                    } catch (InterruptedException ex) {\n-                    }\n-                }\n-            }\n+            resumer = launchResumer(waiter);\n@@ -204,12 +145,1 @@\n-\n-                synchronized (barrierResumer) {\n-                    checkTestState(TS_CALL_SUSPEND);\n-\n-                    \/\/ tell resumer thread to resume waiter thread\n-                    testState = TS_READY_TO_RESUME;\n-                    barrierResumer.notify();\n-\n-                    \/\/ Can't call checkTestState() here because the\n-                    \/\/ resumer thread may have already resumed the\n-                    \/\/ waiter thread.\n-                }\n+                barrierResumerNotify();\n@@ -223,14 +153,1 @@\n-            try {\n-                resumer.join(JOIN_MAX * 1000);\n-                if (resumer.isAlive()) {\n-                    System.err.println(\"Failure at \" + count + \" loops.\");\n-                    throw new InternalError(\"resumer thread is stuck\");\n-                }\n-                waiter.join(JOIN_MAX * 1000);\n-                if (waiter.isAlive()) {\n-                    System.err.println(\"Failure at \" + count + \" loops.\");\n-                    throw new InternalError(\"waiter thread is stuck\");\n-                }\n-            } catch (InterruptedException ex) {\n-            }\n-\n+            shutDown(waiter ,resumer);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWait3.java","additions":7,"deletions":90,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import java.io.PrintStream;\n+\n@@ -77,0 +79,108 @@\n+\n+    public SuspendWithObjectMonitorWaitWorker launchWaiter(long waitTimeout) {\n+        SuspendWithObjectMonitorWaitWorker waiter;\n+        \/\/ launch the waiter thread\n+        synchronized (barrierLaunch) {\n+            waiter = new SuspendWithObjectMonitorWaitWorker(\"waiter\", waitTimeout);\n+            waiter.start();\n+\n+            while (testState != TS_WAITER_RUNNING) {\n+                try {\n+                    barrierLaunch.wait(0);  \/\/ wait until it is running\n+                } catch (InterruptedException ex) {\n+                }\n+            }\n+        }\n+        return waiter;\n+    }\n+\n+    public SuspendWithObjectMonitorWaitWorker launchResumer(SuspendWithObjectMonitorWaitWorker waiter) {\n+        SuspendWithObjectMonitorWaitWorker resumer;\n+        synchronized (barrierLaunch) {\n+            resumer = new SuspendWithObjectMonitorWaitWorker(\"resumer\", waiter);\n+            resumer.start();\n+\n+            while (testState != TS_RESUMER_RUNNING) {\n+                try {\n+                    barrierLaunch.wait(0);  \/\/ wait until it is running\n+                } catch (InterruptedException ex) {\n+                }\n+            }\n+        }\n+        return resumer;\n+    }\n+\n+    public void barrierResumerNotify() {\n+        synchronized (barrierResumer) {\n+            checkTestState(TS_CALL_SUSPEND);\n+\n+            \/\/ tell resumer thread to resume waiter thread\n+            testState = TS_READY_TO_RESUME;\n+            barrierResumer.notify();\n+\n+            \/\/ Can't call checkTestState() here because the\n+            \/\/ resumer thread may have already resumed the\n+            \/\/ waiter thread.\n+        }\n+    }\n+\n+    public void shutDown(SuspendWithObjectMonitorWaitWorker resumer, SuspendWithObjectMonitorWaitWorker waiter) {\n+        try {\n+            resumer.join(JOIN_MAX * 1000);\n+            if (resumer.isAlive()) {\n+                System.err.println(\"Failure at \" + count + \" loops.\");\n+                throw new InternalError(\"resumer thread is stuck\");\n+            }\n+            waiter.join(JOIN_MAX * 1000);\n+            if (waiter.isAlive()) {\n+                System.err.println(\"Failure at \" + count + \" loops.\");\n+                throw new InternalError(\"waiter thread is stuck\");\n+            }\n+        } catch (InterruptedException ex) {\n+        }\n+    }\n+\n+    public int run(int timeMax, PrintStream out) {\n+        return 0;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length > 2) {\n+            System.err.println(\"Invalid number of arguments, there are too many arguments.\");\n+            usage();\n+        }\n+\n+        try {\n+            System.loadLibrary(AGENT_LIB);\n+            log(\"Loaded library: \" + AGENT_LIB);\n+        } catch (UnsatisfiedLinkError ule) {\n+            log(\"Failed to load library: \" + AGENT_LIB);\n+            log(\"java.library.path: \" + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+\n+        int timeMax = 0;\n+        for (int argIndex = 0; argIndex < args.length; argIndex++) {\n+            if (\"-p\".equals(args[argIndex])) {\n+                \/\/ Handle optional -p arg regardless of position.\n+                printDebug = true;\n+                continue;\n+            }\n+\n+            if (argIndex < args.length) {\n+                \/\/ timeMax is an optional arg.\n+                try {\n+                    timeMax = Integer.parseUnsignedInt(args[argIndex]);\n+                } catch (NumberFormatException nfe) {\n+                    System.err.println(\"'\" + args[argIndex] +\n+                            \"': invalid time_max value.\");\n+                    usage();\n+                }\n+            } else {\n+                timeMax = DEF_TIME_MAX;\n+            }\n+        }\n+        SuspendWithObjectMonitorWaitBase test = new SuspendWithObjectMonitorWaitBase();\n+        int result = test.run(timeMax, System.out);\n+        System.exit(result + exit_delta);\n+    }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWaitBase.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-class SuspendWithObjectMonitorWaitWorker extends Thread {\n+public class SuspendWithObjectMonitorWaitWorker extends Thread {\n@@ -28,5 +28,0 @@\n-    public SuspendWithObjectMonitorWaitWorker(String name) {\n-        super(name);\n-        this.waitTimeout = 0;\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWaitWorker.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"}]}