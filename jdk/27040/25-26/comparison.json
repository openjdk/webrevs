{"files":[{"patch":"@@ -567,1 +567,1 @@\n-        if (JvmtiExport::should_post_monitor_contended_entered()) {\n+        if (post_jvmti_events && JvmtiExport::should_post_monitor_contended_entered()) {\n@@ -1869,1 +1869,1 @@\n-  bool was_notified = true;\n+  bool was_notified = false;\n@@ -1883,1 +1883,1 @@\n-        was_notified = false;\n+        \/\/ Intentionally empty\n@@ -1907,1 +1907,1 @@\n-\n+    was_notified = true;\n@@ -1932,2 +1932,2 @@\n-    \/\/ A thread which should post monitor_waited event is never in TS_ENTER state.\n-    if (JvmtiExport::should_post_monitor_waited()) {\n+    \/\/ An event could have been enabled after notification, need to check the state.\n+    if (JvmtiExport::should_post_monitor_waited() && node.TState != ObjectWaiter::TS_ENTER) {\n@@ -2035,0 +2035,2 @@\n+    iterator->_notifier_tid = JFR_THREAD_ID(current);\n+    did_notify = true;\n@@ -2050,4 +2052,0 @@\n-      \/\/ If we will add the vthread to the entry list below then we need to\n-      \/\/ increment the counter *before* doing so.\n-      \/\/ Adding to _entry_list uses Atomic::cmpxchg() which already provides\n-      \/\/ a fence that prevents reordering of the stores.\n@@ -2055,3 +2053,3 @@\n-        \/\/ This is is now conditional as if the monitor_waited event\n-        \/\/ is allowed, then a thread, even virtual, should not be moved to\n-        \/\/ the entry_list, but rather unparked and let run. See the comment below.\n+        \/\/ Increment counter *before* adding the vthread to the _entry_list.\n+        \/\/ Adding to _entry_list uses Atomic::cmpxchg() which already provides\n+        \/\/ a fence that prevents reordering of the stores.\n@@ -2059,0 +2057,7 @@\n+        add_to_entry_list(current, iterator);\n+      } else {\n+        iterator->TState = ObjectWaiter::TS_RUN;\n+        if (java_lang_VirtualThread::set_onWaitingList(vthread, vthread_list_head())) {\n+          ParkEvent* pe = ObjectMonitor::vthread_unparker_ParkEvent();\n+          pe->unpark();\n+        }\n@@ -2060,10 +2065,0 @@\n-    }\n-\n-    iterator->_notifier_tid = JFR_THREAD_ID(current);\n-    did_notify = true;\n-\n-    if (!JvmtiExport::should_post_monitor_waited()) {\n-      \/\/ If the monitor_waited JVMTI event is not allowed, a thread is\n-      \/\/ transferred to the entry_list, and it will eventually be unparked\n-      \/\/ only when it is chosen to become the successor.\n-      add_to_entry_list(current, iterator);\n@@ -2071,14 +2066,5 @@\n-      \/\/ However, if the monitor_waited event is allowed, then\n-      \/\/ the thread is set to state TS_RUN and unparked. The thread\n-      \/\/ will then contend directly to reacquire the monitor and\n-      \/\/ avoids being flagged as the successor. This avoids the problem\n-      \/\/ of having a thread suspend whilst it is the successor.\n-\n-      iterator->TState = ObjectWaiter::TS_RUN;\n-\n-      OrderAccess::fence();\n-\n-      oop vthread = nullptr;\n-      ParkEvent* evt;\n-      if (!iterator->is_vthread()) {\n-        iterator->wait_reenter_begin(this);\n+      if (!JvmtiExport::should_post_monitor_waited()) {\n+        add_to_entry_list(current, iterator);\n+        \/\/ Read counter *after* adding the thread to the _entry_list.\n+        \/\/ Adding to _entry_list uses Atomic::cmpxchg() which already provides\n+        \/\/ a fence that prevents this load from floating up previous store.\n@@ -2086,0 +2072,9 @@\n+          \/\/ Wake up the thread to alleviate some deadlock cases where the successor\n+          \/\/ that will be picked up when this thread releases the monitor is an unmounted\n+          \/\/ virtual thread that cannot run due to having run out of carriers. Upon waking\n+          \/\/ up, the thread will call reenter_internal() which will use timed-park in case\n+          \/\/ there is contention and there are still vthreads in the _entry_list.\n+          \/\/ If the target was interrupted or the wait timed-out at the same time, it could\n+          \/\/ have reached reenter_internal and read a false value of has_unmounted_vthreads()\n+          \/\/ before we added it to the _entry_list above. To deal with that case, we set _do_timed_park\n+          \/\/ which will be read by the target on the next loop iteration in reenter_internal.\n@@ -2087,0 +2082,2 @@\n+          JavaThread* t = iterator->thread();\n+          t->_ParkEvent->unpark();\n@@ -2088,0 +2085,3 @@\n+        iterator->wait_reenter_begin(this);\n+      } else {\n+        iterator->TState = ObjectWaiter::TS_RUN;\n@@ -2090,13 +2090,1 @@\n-        evt = t->_ParkEvent;\n-      } else {\n-        vthread = iterator->vthread();\n-        assert(vthread != nullptr, \"\");\n-        evt = ObjectMonitor::vthread_unparker_ParkEvent();\n-      }\n-\n-      if (vthread == nullptr) {\n-        \/\/ Platform thread case.\n-        evt->unpark();\n-      } else if (java_lang_VirtualThread::set_onWaitingList(vthread, vthread_list_head())) {\n-        \/\/ Virtual thread case.\n-        evt->unpark();\n+        t->_ParkEvent->unpark();\n@@ -2104,1 +2092,0 @@\n-      return did_notify;\n@@ -2114,22 +2101,0 @@\n-\n-    if (!iterator->is_vthread()) {\n-      iterator->wait_reenter_begin(this);\n-\n-      \/\/ Read counter *after* adding the thread to the _entry_list.\n-      \/\/ Adding to _entry_list uses Atomic::cmpxchg() which already provides\n-      \/\/ a fence that prevents this load from floating up previous store.\n-      if (has_unmounted_vthreads()) {\n-        \/\/ Wake up the thread to alleviate some deadlock cases where the successor\n-        \/\/ that will be picked up when this thread releases the monitor is an unmounted\n-        \/\/ virtual thread that cannot run due to having run out of carriers. Upon waking\n-        \/\/ up, the thread will call reenter_internal() which will use timed-park in case\n-        \/\/ there is contention and there are still vthreads in the _entry_list.\n-        \/\/ If the target was interrupted or the wait timed-out at the same time, it could\n-        \/\/ have reached reenter_internal and read a false value of has_unmounted_vthreads()\n-        \/\/ before we added it to the _entry_list above. To deal with that case, we set _do_timed_park\n-        \/\/ which will be read by the target on the next loop iteration in reenter_internal.\n-        iterator->_do_timed_park = true;\n-        JavaThread* t = iterator->thread();\n-        t->_ParkEvent->unpark();\n-      }\n-    }\n@@ -2288,4 +2253,3 @@\n-  \/\/ We check against the state, rather than if was_notified,\n-  \/\/ because, if monitor_waited JVMTI event is allowed, there can be a vthead which\n-  \/\/ is not on the entry_list, but has been notified in the sense that it has been\n-  \/\/ unparked directly in notify_internal(). Its state is then TS_RUN.\n+  \/\/ We check the state rather than was_notified because, when JVMTI\n+  \/\/ monitor_waited event is enabled, the notifier only unparks the waiter\n+  \/\/ without adding it to the entry_list.\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":41,"deletions":77,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -367,1 +367,0 @@\n-  void      post_waited_event(JavaThread* current, EventJavaMonitorWait* wait_event, bool was_notified, ObjectWaiter* node, jlong millis, int ret);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}