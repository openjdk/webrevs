{"files":[{"patch":"@@ -1935,0 +1935,6 @@\n+      \/\/ This means the thread has been un-parked, but not added to the entry list\n+      \/\/ i.e. has timed-out waiting.\n+\n+      \/\/ Done waiting, post the corresponding event\n+      post_waited_event(current, &wait_event, was_notified, &node, millis, ret);\n+  \n@@ -1941,0 +1947,2 @@\n+      \/\/ This means the thread has been un-parked and added to the entry_list\n+      \/\/ in notify_internal, i.e. notified while waiting.\n@@ -1954,0 +1962,2 @@\n+      \/\/ Done waiting, post the corresponding event\n+      post_waited_event(current, &wait_event, was_notified, &node, millis, ret);\n@@ -1965,28 +1975,0 @@\n-    \/\/ post monitor waited event. Note that this is past-tense, we are done waiting.\n-    if (JvmtiExport::should_post_monitor_waited()) {\n-      JvmtiExport::post_monitor_waited(current, this, ret == OS_TIMEOUT);\n-\n-      if (was_notified && has_successor(current)) {\n-        \/\/ In this part of the monitor wait-notify-reenter protocol it\n-        \/\/ is possible (and normal) for another thread to do a fastpath\n-        \/\/ monitor enter-exit while this thread is still trying to get\n-        \/\/ to the reenter portion of the protocol.\n-        \/\/\n-        \/\/ The ObjectMonitor was notified and the current thread is\n-        \/\/ the successor which also means that an unpark() has already\n-        \/\/ been done. The JVMTI_EVENT_MONITOR_WAITED event handler can\n-        \/\/ consume the unpark() that was done when the successor was\n-        \/\/ set because the same ParkEvent is shared between Java\n-        \/\/ monitors and JVM\/TI RawMonitors (for now).\n-        \/\/\n-        \/\/ We redo the unpark() to ensure forward progress, i.e., we\n-        \/\/ don't want all pending threads hanging (parked) with none\n-        \/\/ entering the unlocked monitor.\n-        current->_ParkEvent->unpark();\n-      }\n-    }\n-\n-    if (wait_event.should_commit()) {\n-      post_monitor_wait_event(&wait_event, this, node._notifier_tid, millis, ret == OS_TIMEOUT);\n-    }\n-\n@@ -2032,0 +2014,30 @@\n+void ObjectMonitor::post_waited_event(JavaThread* current, EventJavaMonitorWait* wait_event, bool was_notified, ObjectWaiter* node, jlong millis, int ret) {\n+  \/\/ post monitor waited event. Note that this is past-tense, we are done waiting.\n+  if (JvmtiExport::should_post_monitor_waited()) {\n+    JvmtiExport::post_monitor_waited(current, this, ret == OS_TIMEOUT);\n+\n+    if (was_notified && has_successor(current)) {\n+      \/\/ In this part of the monitor wait-notify-reenter protocol it\n+      \/\/ is possible (and normal) for another thread to do a fastpath\n+      \/\/ monitor enter-exit while this thread is still trying to get\n+      \/\/ to the reenter portion of the protocol.\n+      \/\/\n+      \/\/ The ObjectMonitor was notified and the current thread is\n+      \/\/ the successor which also means that an unpark() has already\n+      \/\/ been done. The JVMTI_EVENT_MONITOR_WAITED event handler can\n+      \/\/ consume the unpark() that was done when the successor was\n+      \/\/ set because the same ParkEvent is shared between Java\n+      \/\/ monitors and JVM\/TI RawMonitors (for now).\n+      \/\/\n+      \/\/ We redo the unpark() to ensure forward progress, i.e., we\n+      \/\/ don't want all pending threads hanging (parked) with none\n+      \/\/ entering the unlocked monitor.\n+      current->_ParkEvent->unpark();\n+    }\n+  }\n+\n+  if (wait_event->should_commit()) {\n+    post_monitor_wait_event(wait_event, this, node->_notifier_tid, millis, ret == OS_TIMEOUT);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":40,"deletions":28,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-\n+class EventJavaMonitorWait;\n@@ -368,0 +368,1 @@\n+  void      post_waited_event(JavaThread* current, EventJavaMonitorWait* wait_event, bool was_notified, ObjectWaiter* node, jlong millis, int ret);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWait1.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWait2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -187,1 +187,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWaitBase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWaitWorker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}