{"files":[{"patch":"@@ -341,9 +341,0 @@\n-void ObjectMonitor::ClearSuccOnSuspend::operator()(JavaThread* current) {\n-  if (current->is_suspended()) {\n-    if (_om->has_successor(current)) {\n-      _om->clear_successor();\n-      OrderAccess::fence(); \/\/ always do a full fence when successor is cleared\n-    }\n-  }\n-}\n-\n@@ -502,1 +493,1 @@\n-bool ObjectMonitor::enter(JavaThread* current) {\n+bool ObjectMonitor::enter(JavaThread* current, bool post_jvmti_events) {\n@@ -523,1 +514,1 @@\n-  enter_with_contention_mark(current, contention_mark);\n+  enter_with_contention_mark(current, contention_mark, post_jvmti_events);\n@@ -542,1 +533,1 @@\n-void ObjectMonitor::enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark &cm) {\n+void ObjectMonitor::enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark &cm, bool post_jvmti_events) {\n@@ -646,1 +637,1 @@\n-  if (JvmtiExport::should_post_monitor_contended_entered()) {\n+  if (post_jvmti_events && JvmtiExport::should_post_monitor_contended_entered()) {\n@@ -1104,1 +1095,1 @@\n-  assert(current->thread_state() != _thread_blocked, \"invariant\");\n+  assert(current->thread_state() == _thread_blocked, \"invariant\");\n@@ -1108,1 +1099,0 @@\n-  assert_mark_word_consistency();\n@@ -1144,15 +1134,6 @@\n-\n-      assert(current->thread_state() == _thread_in_vm, \"invariant\");\n-\n-      {\n-        ClearSuccOnSuspend csos(this);\n-        ThreadBlockInVMPreprocess<ClearSuccOnSuspend> tbivs(current, csos, true \/* allow_suspend *\/);\n-        if (do_timed_parked) {\n-          current->_ParkEvent->park(recheck_interval);\n-          \/\/ Increase the recheck_interval, but clamp the value.\n-          recheck_interval *= 8;\n-          if (recheck_interval > MAX_RECHECK_INTERVAL) {\n-            recheck_interval = MAX_RECHECK_INTERVAL;\n-          }\n-        } else {\n-          current->_ParkEvent->park();\n+      if (do_timed_parked) {\n+        current->_ParkEvent->park(recheck_interval);\n+        \/\/ Increase the recheck_interval, but clamp the value.\n+        recheck_interval *= 8;\n+        if (recheck_interval > MAX_RECHECK_INTERVAL) {\n+          recheck_interval = MAX_RECHECK_INTERVAL;\n@@ -1160,0 +1141,2 @@\n+      } else {\n+        current->_ParkEvent->park();\n@@ -1186,1 +1169,0 @@\n-  assert_mark_word_consistency();\n@@ -1896,2 +1878,1 @@\n-      ClearSuccOnSuspend csos(this);\n-      ThreadBlockInVMPreprocess<ClearSuccOnSuspend> tbivs(current, csos, true \/* allow_suspend *\/);\n+      ThreadBlockInVM tbivm(current, false \/* allow_suspend *\/);\n@@ -1949,0 +1930,35 @@\n+    OrderAccess::fence();\n+\n+    assert(!has_owner(current), \"invariant\");\n+    ObjectWaiter::TStates v = node.TState;\n+    if (v == ObjectWaiter::TS_RUN) {\n+      \/\/ We use the NoPreemptMark for the very rare case where the previous\n+      \/\/ preempt attempt failed due to OOM. The preempt on monitor contention\n+      \/\/ could succeed but we can't unmount now.\n+      NoPreemptMark npm(current);\n+      enter(current);\n+    } else {\n+      guarantee(v == ObjectWaiter::TS_ENTER, \"invariant\");\n+      ExitOnSuspend eos(this);\n+      {\n+        ThreadBlockInVMPreprocess<ExitOnSuspend> tbivs(current, eos, true \/* allow_suspend *\/);\n+        reenter_internal(current, &node);\n+        \/\/ We can go to a safepoint at the end of this block. If we\n+        \/\/ do a thread dump during that safepoint, then this thread will show\n+        \/\/ as having \"-locked\" the monitor, but the OS and java.lang.Thread\n+        \/\/ states will still report that the thread is blocked trying to\n+        \/\/ acquire it.\n+        \/\/ If there is a suspend request, ExitOnSuspend will exit the OM\n+        \/\/ and set the OM as pending.\n+      }\n+      if (eos.exited()) {\n+        \/\/ ExitOnSuspend exit the OM\n+        assert(!has_owner(current), \"invariant\");\n+        guarantee(node.TState == ObjectWaiter::TS_RUN, \"invariant\");\n+        current->set_current_pending_monitor(nullptr);\n+        enter(current, false \/* post_jvmti_events *\/);\n+      }\n+      assert(has_owner(current), \"invariant\");\n+      node.wait_reenter_end(this);\n+    }\n+\n@@ -1977,16 +1993,0 @@\n-    OrderAccess::fence();\n-\n-    assert(!has_owner(current), \"invariant\");\n-    ObjectWaiter::TStates v = node.TState;\n-    if (v == ObjectWaiter::TS_RUN) {\n-      \/\/ We use the NoPreemptMark for the very rare case where the previous\n-      \/\/ preempt attempt failed due to OOM. The preempt on monitor contention\n-      \/\/ could succeed but we can't unmount now.\n-      NoPreemptMark npm(current);\n-      enter(current);\n-    } else {\n-      guarantee(v == ObjectWaiter::TS_ENTER, \"invariant\");\n-      reenter_internal(current, &node);\n-      node.wait_reenter_end(this);\n-    }\n-\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":49,"deletions":49,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -365,7 +365,0 @@\n-  class ClearSuccOnSuspend {\n-   protected:\n-    ObjectMonitor* _om;\n-   public:\n-    ClearSuccOnSuspend(ObjectMonitor* om) : _om(om)  {}\n-    void operator()(JavaThread* current);\n-  };\n@@ -378,1 +371,1 @@\n-  bool      enter(JavaThread* current);\n+  bool      enter(JavaThread* current, bool post_jvmti_events = true);\n@@ -381,1 +374,1 @@\n-  void      enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark& contention_mark);\n+  void      enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark& contention_mark, bool post_jvmti_events = true);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,37 @@\n- * @run main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait\n+ * @run main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait 1\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4413752 8262881\n+ * @summary Test SuspendThread with ObjectMonitor wait.\n+ * @requires vm.jvmti\n+ * @library \/test\/lib\n+ * @compile SuspendWithObjectMonitorWait.java\n+ * @run main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait 2\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4413752 8262881\n+ * @summary Test SuspendThread with ObjectMonitor wait.\n+ * @requires vm.jvmti\n+ * @library \/test\/lib\n+ * @compile SuspendWithObjectMonitorWait.java\n+ * @run main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait 3\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test options parser test cases\n+ * @requires vm.jvmti\n+ * @library \/test\/lib\n+ * @compile SuspendWithObjectMonitorWait.java\n+ * @comment main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait\n+ * @comment main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait -p\n+ * @comment main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait 1 -p 5 junk\n+ * @comment main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait junk\n+ * @comment main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait 1 junk\n+ * @comment main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait -p 1 junk\n+ * @comment main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait 1 -p junk\n+ * @comment main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait 1 junk -p\n@@ -37,0 +73,1 @@\n+\/\/ doWork1 algorithm:\n@@ -60,0 +97,74 @@\n+\/\/\n+\/\/ doWork2 algorithm:\n+\/\/\n+\/\/ main               waiter              resumer\n+\/\/ =================  ==================  ===================\n+\/\/ launch waiter\n+\/\/ <launch returns>   waiter running\n+\/\/ launch resumer     enter threadLock\n+\/\/ <launch returns>   threadLock.wait()   resumer running\n+\/\/ enter threadLock   :                   wait for notify\n+\/\/ threadLock.notify  wait finishes       :\n+\/\/ :                  reenter blocks      :\n+\/\/ suspend waiter     <suspended>         :\n+\/\/ <ready to test>    :                   :\n+\/\/ :                  :                   :\n+\/\/ notify resumer     :                   wait finishes\n+\/\/ delay 1-second     :                   :\n+\/\/ exit threadLock    :                   :\n+\/\/ join resumer       :                   enter threadLock\n+\/\/ :                  <resumed>           resume waiter\n+\/\/ :                  :                   exit threadLock\n+\/\/ :                  reenter threadLock  :\n+\/\/ <join returns>     :                   resumer exits\n+\/\/ join waiter        :\n+\/\/ <join returns>     waiter exits\n+\/\/\n+\/\/ Note: The sleep(1-second) in main along with the delayed exit\n+\/\/       of threadLock in main forces the resumer thread to reach\n+\/\/       \"enter threadLock\" and block. This difference from doWork1\n+\/\/       forces the resumer thread to be contending for threadLock\n+\/\/       while the waiter thread is in threadLock.wait() increasing\n+\/\/       stress on the monitor sub-system.\n+\/\/\n+\n+\/\/\n+\/\/ doWork3 algorithm:\n+\/\/\n+\/\/ main                 waiter                  resumer\n+\/\/ ===================  ======================  ===================\n+\/\/ launch waiter\n+\/\/ <launch returns>     waiter running\n+\/\/ launch resumer       enter threadLock\n+\/\/ <launch returns>     while !READY_TO_NOTIFY  resumer running\n+\/\/ :                      threadLock.wait(1)    wait for notify\n+\/\/ enter threadLock     :                       :\n+\/\/ set READY_TO_NOTIFY  :\n+\/\/ threadLock.notify    wait finishes           :\n+\/\/ : delay 200ms        reenter blocks          :\n+\/\/ suspend waiter       <suspended>             :\n+\/\/ <ready to test>      :                       :\n+\/\/ :                    :                       :\n+\/\/ notify resumer       :                       wait finishes\n+\/\/ delay 1-second       :                       :\n+\/\/ exit threadLock      :                       :\n+\/\/ join resumer         :                       enter threadLock\n+\/\/ :                    <resumed>               resume waiter\n+\/\/ :                    :                       exit threadLock\n+\/\/ :                    reenter threadLock      :\n+\/\/ <join returns>       :                       resumer exits\n+\/\/ join waiter          :\n+\/\/ <join returns>       waiter exits\n+\/\/\n+\/\/ Note: The sleep(1-second) in main along with the delayed exit\n+\/\/       of threadLock in main forces the resumer thread to reach\n+\/\/       \"enter threadLock\" and block. This difference from doWork1\n+\/\/       forces the resumer thread to be contending for threadLock\n+\/\/       while the waiter thread is in the threadLock.wait(1) tight\n+\/\/       loop increasing stress on the monitor sub-system.\n+\/\/\n+\/\/ Note: sleep(200ms) here while holding the threadLock to allow the\n+\/\/       waiter thread's timed wait to finish before we attempt to\n+\/\/       suspend the waiter thread.\n+\/\/\n+\n@@ -90,0 +201,10 @@\n+        if (args.length == 0) {\n+            System.err.println(\"Invalid number of arguments, there should be at least a test_case given.\");\n+            usage();\n+        }\n+\n+        if (args.length > 3) {\n+            System.err.println(\"Invalid number of arguments, there are too many arguments.\");\n+            usage();\n+        }\n+\n@@ -99,0 +220,1 @@\n+        int testCase = 0;\n@@ -100,6 +222,3 @@\n-        if (args.length == 0) {\n-            timeMax = DEF_TIME_MAX;\n-        } else {\n-            int argIndex = 0;\n-            int argsLeft = args.length;\n-            if (args[0].equals(\"-p\")) {\n+        for (int argIndex = 0; argIndex < args.length; argIndex++) {\n+            if (args[argIndex].equals(\"-p\")) {\n+                \/\/ Handle optional -p arg regardless of position.\n@@ -107,2 +226,1 @@\n-                argIndex = 1;\n-                argsLeft--;\n+                continue;\n@@ -110,3 +228,19 @@\n-            if (argsLeft == 0) {\n-                timeMax = DEF_TIME_MAX;\n-            } else if (argsLeft == 1) {\n+\n+            if (testCase == 0) {\n+                try {\n+                    \/\/ testCase must be the first non-optional arg.\n+                    testCase = Integer.parseUnsignedInt(args[argIndex]);\n+                } catch (NumberFormatException nfe) {\n+                    System.err.println(\"'\" + args[argIndex] +\n+                                       \"': invalid test_case value.\");\n+                    usage();\n+                }\n+                if (testCase < 1 || testCase > 3) {\n+                    System.err.println(\"Invalid test_case value: '\" + testCase + \"'\");\n+                    usage();\n+                }\n+                continue;\n+            }\n+\n+            if (argIndex < args.length) {\n+                \/\/ timeMax is an optional arg.\n@@ -117,1 +251,1 @@\n-                                       \"': invalid timeMax value.\");\n+                                       \"': invalid time_max value.\");\n@@ -121,1 +255,1 @@\n-                usage();\n+                timeMax = DEF_TIME_MAX;\n@@ -125,1 +259,7 @@\n-        System.exit(run(timeMax, System.out) + exit_delta);\n+        if (testCase == 0) {\n+            \/\/ Just -p was given.\n+            System.err.println(\"Invalid number of arguments, no test_case given.\");\n+            usage();\n+        }\n+\n+        System.exit(run(timeMax, System.out, testCase) + exit_delta);\n@@ -135,1 +275,1 @@\n-        System.err.println(\"Usage: \" + AGENT_LIB + \" [-p][time_max]\");\n+        System.err.println(\"Usage: \" + AGENT_LIB + \" test_case [-p] [time_max]\");\n@@ -137,4 +277,5 @@\n-        System.err.println(\"    -p       ::= print debug info\");\n-        System.err.println(\"    time_max ::= max looping time in seconds\");\n-        System.err.println(\"                 (default is \" + DEF_TIME_MAX +\n-                           \" seconds)\");\n+        System.err.println(\"    test_case ::= 1 | 2 | 3\");\n+        System.err.println(\"    -p        ::= print debug info\");\n+        System.err.println(\"    time_max  ::= max looping time in seconds\");\n+        System.err.println(\"                  (default is \" + DEF_TIME_MAX +\n+                \" seconds)\");\n@@ -144,2 +285,8 @@\n-    public static int run(int timeMax, PrintStream out) {\n-        return (new SuspendWithObjectMonitorWait()).doWork(timeMax, out);\n+    public static int run(int timeMax, PrintStream out, int testCase) {\n+        switch (testCase) {\n+            case 1: return (new SuspendWithObjectMonitorWait()).doWork1(timeMax, out);\n+            case 2: return (new SuspendWithObjectMonitorWait()).doWork2(timeMax, out);\n+            case 3: return (new SuspendWithObjectMonitorWait()).doWork3(timeMax, out);\n+            default: throw new RuntimeException(\"Unknown test_case: \" + testCase);\n+        }\n+\n@@ -156,1 +303,2 @@\n-    public int doWork(int timeMax, PrintStream out) {\n+    \/\/ Default scenario, the resumer thread is always able to grab the threadLock once notified by the main thread.\n+    public int doWork1(int timeMax, PrintStream out) {\n@@ -268,0 +416,244 @@\n+\n+    \/\/ Notify the resumer while holding the threadLock.\n+    public int doWork2(int timeMax, PrintStream out) {\n+        SuspendWithObjectMonitorWaitWorker waiter;    \/\/ waiter thread\n+        SuspendWithObjectMonitorWaitWorker resumer;    \/\/ resumer thread\n+\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n+            testState = TS_INIT;  \/\/ starting the test loop\n+\n+            \/\/ launch the waiter thread\n+            synchronized (barrierLaunch) {\n+                waiter = new SuspendWithObjectMonitorWaitWorker(\"waiter\");\n+                waiter.start();\n+\n+                while (testState != TS_WAITER_RUNNING) {\n+                    try {\n+                        barrierLaunch.wait(0);  \/\/ wait until it is running\n+                    } catch (InterruptedException ex) {\n+                    }\n+                }\n+            }\n+\n+            \/\/ launch the resumer thread\n+            synchronized (barrierLaunch) {\n+                resumer = new SuspendWithObjectMonitorWaitWorker(\"resumer\", waiter);\n+                resumer.start();\n+\n+                while (testState != TS_RESUMER_RUNNING) {\n+                    try {\n+                        barrierLaunch.wait(0);  \/\/ wait until it is running\n+                    } catch (InterruptedException ex) {\n+                    }\n+                }\n+            }\n+\n+            checkTestState(TS_RESUMER_RUNNING);\n+\n+            \/\/ The waiter thread was synchronized on threadLock before it\n+            \/\/ set TS_WAITER_RUNNING and notified barrierLaunch above so\n+            \/\/ we cannot enter threadLock until the waiter thread calls\n+            \/\/ threadLock.wait().\n+            synchronized (threadLock) {\n+                \/\/ notify waiter thread so it can try to reenter threadLock\n+                testState = TS_READY_TO_NOTIFY;\n+                threadLock.notify();\n+\n+                \/\/ wait for the waiter thread to block\n+                logDebug(\"before contended enter wait\");\n+                int retCode = wait4ContendedEnter(waiter);\n+                if (retCode != 0) {\n+                    throw new RuntimeException(\"error in JVMTI GetThreadState: \"\n+                                                + \"retCode=\" + retCode);\n+                }\n+                logDebug(\"done contended enter wait\");\n+\n+                checkTestState(TS_READY_TO_NOTIFY);\n+                testState = TS_CALL_SUSPEND;\n+                logDebug(\"before suspend thread\");\n+                retCode = suspendThread(waiter);\n+                if (retCode != 0) {\n+                    throw new RuntimeException(\"error in JVMTI SuspendThread: \"\n+                                                + \"retCode=\" + retCode);\n+                }\n+                logDebug(\"suspended thread\");\n+\n+                \/\/\n+                \/\/ At this point, all of the child threads are running\n+                \/\/ and we can get to meat of the test:\n+                \/\/\n+                \/\/ - suspended threadLock waiter (trying to reenter)\n+                \/\/ - a blocked threadLock enter in the resumer thread while the\n+                \/\/   threadLock is held by the main thread.\n+                \/\/ - resumption of the waiter thread\n+                \/\/ - a threadLock enter in the freshly resumed waiter thread\n+                \/\/\n+\n+                synchronized (barrierResumer) {\n+                    checkTestState(TS_CALL_SUSPEND);\n+\n+                    \/\/ tell resumer thread to resume waiter thread\n+                    testState = TS_READY_TO_RESUME;\n+                    barrierResumer.notify();\n+\n+                    \/\/ Can't call checkTestState() here because the\n+                    \/\/ resumer thread may have already resumed the\n+                    \/\/ waiter thread.\n+                }\n+                try {\n+                    \/\/ Delay for 1-second while holding the threadLock to force the\n+                    \/\/ resumer thread to block on entering the threadLock.\n+                    Thread.sleep(1000);\n+                } catch(Exception e) {}\n+            }\n+\n+            try {\n+                resumer.join(JOIN_MAX * 1000);\n+                if (resumer.isAlive()) {\n+                    System.err.println(\"Failure at \" + count + \" loops.\");\n+                    throw new InternalError(\"resumer thread is stuck\");\n+                }\n+                waiter.join(JOIN_MAX * 1000);\n+                if (waiter.isAlive()) {\n+                    System.err.println(\"Failure at \" + count + \" loops.\");\n+                    throw new InternalError(\"waiter thread is stuck\");\n+                }\n+            } catch (InterruptedException ex) {\n+            }\n+\n+            checkTestState(TS_WAITER_DONE);\n+        }\n+\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                \" seconds.\");\n+\n+        return 0;\n+    }\n+\n+    \/\/ Suspend on the re-entry path of wait.\n+    public int doWork3(int timeMax, PrintStream out) {\n+        SuspendWithObjectMonitorWaitWorker waiter;    \/\/ waiter thread\n+        SuspendWithObjectMonitorWaitWorker resumer;    \/\/ resumer thread\n+\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n+            testState = TS_INIT;  \/\/ starting the test loop\n+\n+            \/\/ launch the waiter thread\n+            synchronized (barrierLaunch) {\n+                waiter = new SuspendWithObjectMonitorWaitWorker(\"waiter\", 100);\n+                waiter.start();\n+\n+                while (testState != TS_WAITER_RUNNING) {\n+                    try {\n+                        barrierLaunch.wait(0);  \/\/ wait until it is running\n+                    } catch (InterruptedException ex) {\n+                    }\n+                }\n+            }\n+\n+            \/\/ launch the resumer thread\n+            synchronized (barrierLaunch) {\n+                resumer = new SuspendWithObjectMonitorWaitWorker(\"resumer\", waiter);\n+                resumer.start();\n+\n+                while (testState != TS_RESUMER_RUNNING) {\n+                    try {\n+                        barrierLaunch.wait(0);  \/\/ wait until it is running\n+                    } catch (InterruptedException ex) {\n+                    }\n+                }\n+            }\n+\n+            checkTestState(TS_RESUMER_RUNNING);\n+\n+            \/\/ The waiter thread was synchronized on threadLock before it\n+            \/\/ set TS_WAITER_RUNNING and notified barrierLaunch above so\n+            \/\/ we cannot enter threadLock until the waiter thread calls\n+            \/\/ threadLock.wait().\n+            synchronized (threadLock) {\n+                \/\/ notify waiter thread so it can try to reenter threadLock\n+                testState = TS_READY_TO_NOTIFY;\n+                threadLock.notify();\n+\n+                try {\n+                    Thread.sleep(200);\n+                } catch (Exception e) {}\n+\n+                \/\/ wait for the waiter thread to block\n+                logDebug(\"before contended enter wait\");\n+                int retCode = wait4ContendedEnter(waiter);\n+                if (retCode != 0) {\n+                    throw new RuntimeException(\"error in JVMTI GetThreadState: \"\n+                                                 + \"retCode=\" + retCode);\n+                }\n+                logDebug(\"done contended enter wait\");\n+\n+                checkTestState(TS_READY_TO_NOTIFY);\n+                testState = TS_CALL_SUSPEND;\n+                logDebug(\"before suspend thread\");\n+                retCode = suspendThread(waiter);\n+                if (retCode != 0) {\n+                    throw new RuntimeException(\"error in JVMTI SuspendThread: \"\n+                                                + \"retCode=\" + retCode);\n+                }\n+                logDebug(\"suspended thread\");\n+\n+                \/\/\n+                \/\/ At this point, all of the child threads are running\n+                \/\/ and we can get to meat of the test:\n+                \/\/\n+                \/\/ - suspended threadLock waiter (trying to reenter)\n+                \/\/ - a blocked threadLock enter in the resumer thread while the\n+                \/\/   threadLock is held by the main thread.\n+                \/\/ - resumption of the waiter thread\n+                \/\/ - a threadLock enter in the freshly resumed waiter thread\n+                \/\/\n+\n+                synchronized (barrierResumer) {\n+                    checkTestState(TS_CALL_SUSPEND);\n+\n+                    \/\/ tell resumer thread to resume waiter thread\n+                    testState = TS_READY_TO_RESUME;\n+                    barrierResumer.notify();\n+\n+                    \/\/ Can't call checkTestState() here because the\n+                    \/\/ resumer thread may have already resumed the\n+                    \/\/ waiter thread.\n+                }\n+                try {\n+                    \/\/ Delay for 1-second while holding the threadLock to force the\n+                    \/\/ resumer thread to block on entering the threadLock.\n+                    Thread.sleep(1000);\n+                } catch (Exception e) {}\n+            }\n+\n+            try {\n+                resumer.join(JOIN_MAX * 1000);\n+                if (resumer.isAlive()) {\n+                    System.err.println(\"Failure at \" + count + \" loops.\");\n+                    throw new InternalError(\"resumer thread is stuck\");\n+                }\n+                waiter.join(JOIN_MAX * 1000);\n+                if (waiter.isAlive()) {\n+                    System.err.println(\"Failure at \" + count + \" loops.\");\n+                    throw new InternalError(\"waiter thread is stuck\");\n+                }\n+            } catch (InterruptedException ex) {\n+            }\n+\n+            checkTestState(TS_WAITER_DONE);\n+        }\n+\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                \" seconds.\");\n+\n+        return 0;\n+    }\n@@ -270,0 +662,2 @@\n+\n+\n@@ -272,0 +666,1 @@\n+    private final long waitTimeout;\n@@ -275,0 +670,6 @@\n+        this.waitTimeout = 0;\n+    }\n+\n+    public SuspendWithObjectMonitorWaitWorker(String name, long waitTimeout) {\n+        super(name);\n+        this.waitTimeout = waitTimeout;\n@@ -280,0 +681,1 @@\n+        this.waitTimeout = 0;\n@@ -314,1 +716,1 @@\n-                        SuspendWithObjectMonitorWait.threadLock.wait(0);\n+                        SuspendWithObjectMonitorWait.threadLock.wait(waitTimeout);\n@@ -329,1 +731,1 @@\n-        \/\/ - tries to grab the threadLock (should not block!)\n+        \/\/ - tries to grab the threadLock (should not block with doWork1!)\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWait.java","additions":428,"deletions":26,"binary":false,"changes":454,"status":"modified"}]}