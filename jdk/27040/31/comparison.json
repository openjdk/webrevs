{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -342,9 +342,0 @@\n-void ObjectMonitor::ClearSuccOnSuspend::operator()(JavaThread* current) {\n-  if (current->is_suspended()) {\n-    if (_om->has_successor(current)) {\n-      _om->clear_successor();\n-      OrderAccess::fence(); \/\/ always do a full fence when successor is cleared\n-    }\n-  }\n-}\n-\n@@ -503,1 +494,1 @@\n-bool ObjectMonitor::enter(JavaThread* current) {\n+bool ObjectMonitor::enter(JavaThread* current, bool post_jvmti_events) {\n@@ -524,1 +515,1 @@\n-  enter_with_contention_mark(current, contention_mark);\n+  enter_with_contention_mark(current, contention_mark, post_jvmti_events);\n@@ -528,1 +519,1 @@\n-void ObjectMonitor::notify_contended_enter(JavaThread* current) {\n+void ObjectMonitor::notify_contended_enter(JavaThread* current, bool post_jvmti_events) {\n@@ -532,1 +523,1 @@\n-  if (JvmtiExport::should_post_monitor_contended_enter()) {\n+  if (post_jvmti_events && JvmtiExport::should_post_monitor_contended_enter()) {\n@@ -543,1 +534,1 @@\n-void ObjectMonitor::enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark &cm) {\n+void ObjectMonitor::enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark &cm, bool post_jvmti_events) {\n@@ -567,1 +558,1 @@\n-    notify_contended_enter(current);\n+    notify_contended_enter(current, post_jvmti_events);\n@@ -576,1 +567,1 @@\n-        if (JvmtiExport::should_post_monitor_contended_entered()) {\n+        if (post_jvmti_events && JvmtiExport::should_post_monitor_contended_entered()) {\n@@ -613,1 +604,2 @@\n-        \/\/ and set the OM as pending.\n+        \/\/ and set the OM as pending, the thread will not be reported as\n+        \/\/ having \"-locked\" the monitor.\n@@ -647,1 +639,1 @@\n-  if (JvmtiExport::should_post_monitor_contended_entered()) {\n+  if (post_jvmti_events && JvmtiExport::should_post_monitor_contended_entered()) {\n@@ -1105,1 +1097,1 @@\n-  assert(current->thread_state() != _thread_blocked, \"invariant\");\n+  assert(current->thread_state() == _thread_blocked, \"invariant\");\n@@ -1109,1 +1101,0 @@\n-  assert_mark_word_consistency();\n@@ -1145,15 +1136,6 @@\n-\n-      assert(current->thread_state() == _thread_in_vm, \"invariant\");\n-\n-      {\n-        ClearSuccOnSuspend csos(this);\n-        ThreadBlockInVMPreprocess<ClearSuccOnSuspend> tbivs(current, csos, true \/* allow_suspend *\/);\n-        if (do_timed_parked) {\n-          current->_ParkEvent->park(recheck_interval);\n-          \/\/ Increase the recheck_interval, but clamp the value.\n-          recheck_interval *= 8;\n-          if (recheck_interval > MAX_RECHECK_INTERVAL) {\n-            recheck_interval = MAX_RECHECK_INTERVAL;\n-          }\n-        } else {\n-          current->_ParkEvent->park();\n+      if (do_timed_parked) {\n+        current->_ParkEvent->park(recheck_interval);\n+        \/\/ Increase the recheck_interval, but clamp the value.\n+        recheck_interval *= 8;\n+        if (recheck_interval > MAX_RECHECK_INTERVAL) {\n+          recheck_interval = MAX_RECHECK_INTERVAL;\n@@ -1161,0 +1143,2 @@\n+      } else {\n+        current->_ParkEvent->park();\n@@ -1187,1 +1171,0 @@\n-  assert_mark_word_consistency();\n@@ -1886,1 +1869,1 @@\n-  bool was_notified = false;\n+  bool was_notified = true;\n@@ -1898,2 +1881,1 @@\n-      ClearSuccOnSuspend csos(this);\n-      ThreadBlockInVMPreprocess<ClearSuccOnSuspend> tbivs(current, csos, true \/* allow_suspend *\/);\n+      ThreadBlockInVM tbivm(current, false \/* allow_suspend *\/);\n@@ -1931,0 +1913,1 @@\n+        was_notified = false;\n@@ -1933,2 +1916,1 @@\n-\n-    \/\/ The thread is now either on off-list (TS_RUN),\n+    \/\/ The thread is now either off-list (TS_RUN),\n@@ -1941,1 +1923,0 @@\n-    was_notified = node.TState == ObjectWaiter::TS_ENTER;\n@@ -1950,3 +1931,5 @@\n-    \/\/ post monitor waited event. Note that this is past-tense, we are done waiting.\n-    if (JvmtiExport::should_post_monitor_waited()) {\n-      JvmtiExport::post_monitor_waited(current, this, ret == OS_TIMEOUT);\n+    \/\/ Post monitor waited event. Note that this is past-tense, we are done waiting.\n+    \/\/ An event could have been enabled after notification, in this case\n+    \/\/ a thread will have TS_ENTER state and posting the event may hit a suspension point.\n+    \/\/ From a debugging perspective, it is more important to have no missing events.\n+    if (interruptible && JvmtiExport::should_post_monitor_waited() && node.TState != ObjectWaiter::TS_ENTER) {\n@@ -1954,17 +1937,3 @@\n-      if (was_notified && has_successor(current)) {\n-        \/\/ In this part of the monitor wait-notify-reenter protocol it\n-        \/\/ is possible (and normal) for another thread to do a fastpath\n-        \/\/ monitor enter-exit while this thread is still trying to get\n-        \/\/ to the reenter portion of the protocol.\n-        \/\/\n-        \/\/ The ObjectMonitor was notified and the current thread is\n-        \/\/ the successor which also means that an unpark() has already\n-        \/\/ been done. The JVMTI_EVENT_MONITOR_WAITED event handler can\n-        \/\/ consume the unpark() that was done when the successor was\n-        \/\/ set because the same ParkEvent is shared between Java\n-        \/\/ monitors and JVM\/TI RawMonitors (for now).\n-        \/\/\n-        \/\/ We redo the unpark() to ensure forward progress, i.e., we\n-        \/\/ don't want all pending threads hanging (parked) with none\n-        \/\/ entering the unlocked monitor.\n-        current->_ParkEvent->unpark();\n+      \/\/ Process suspend requests now if any, before posting the event.\n+      {\n+        ThreadBlockInVM tbvm(current, true);\n@@ -1972,0 +1941,2 @@\n+\n+      JvmtiExport::post_monitor_waited(current, this, ret == OS_TIMEOUT);\n@@ -1989,0 +1960,2 @@\n+      \/\/ This means the thread has been un-parked and added to the entry_list\n+      \/\/ in notify_internal, i.e. notified while waiting.\n@@ -1990,1 +1963,21 @@\n-      reenter_internal(current, &node);\n+      ExitOnSuspend eos(this);\n+      {\n+        ThreadBlockInVMPreprocess<ExitOnSuspend> tbivs(current, eos, true \/* allow_suspend *\/);\n+        reenter_internal(current, &node);\n+        \/\/ We can go to a safepoint at the end of this block. If we\n+        \/\/ do a thread dump during that safepoint, then this thread will show\n+        \/\/ as having \"-locked\" the monitor, but the OS and java.lang.Thread\n+        \/\/ states will still report that the thread is blocked trying to\n+        \/\/ acquire it.\n+        \/\/ If there is a suspend request, ExitOnSuspend will exit the OM\n+        \/\/ and set the OM as pending, the thread will not be reported as\n+        \/\/ having \"-locked\" the monitor.\n+      }\n+      if (eos.exited()) {\n+        \/\/ ExitOnSuspend exit the OM\n+        assert(!has_owner(current), \"invariant\");\n+        guarantee(node.TState == ObjectWaiter::TS_RUN, \"invariant\");\n+        current->set_current_pending_monitor(nullptr);\n+        enter(current, false \/* post_jvmti_events *\/);\n+      }\n+      assert(has_owner(current), \"invariant\");\n@@ -2044,0 +2037,2 @@\n+    iterator->_notifier_tid = JFR_THREAD_ID(current);\n+    did_notify = true;\n@@ -2059,4 +2054,40 @@\n-      \/\/ Increment counter *before* adding the vthread to the _entry_list.\n-      \/\/ Adding to _entry_list uses Atomic::cmpxchg() which already provides\n-      \/\/ a fence that prevents reordering of the stores.\n-      inc_unmounted_vthreads();\n+      if (!JvmtiExport::should_post_monitor_waited()) {\n+        \/\/ Increment counter *before* adding the vthread to the _entry_list.\n+        \/\/ Adding to _entry_list uses Atomic::cmpxchg() which already provides\n+        \/\/ a fence that prevents reordering of the stores.\n+        inc_unmounted_vthreads();\n+        add_to_entry_list(current, iterator);\n+      } else {\n+        iterator->TState = ObjectWaiter::TS_RUN;\n+        if (java_lang_VirtualThread::set_onWaitingList(vthread, vthread_list_head())) {\n+          ParkEvent* pe = ObjectMonitor::vthread_unparker_ParkEvent();\n+          pe->unpark();\n+        }\n+      }\n+    } else {\n+      if (!JvmtiExport::should_post_monitor_waited()) {\n+        add_to_entry_list(current, iterator);\n+        \/\/ Read counter *after* adding the thread to the _entry_list.\n+        \/\/ Adding to _entry_list uses Atomic::cmpxchg() which already provides\n+        \/\/ a fence that prevents this load from floating up previous store.\n+        if (has_unmounted_vthreads()) {\n+          \/\/ Wake up the thread to alleviate some deadlock cases where the successor\n+          \/\/ that will be picked up when this thread releases the monitor is an unmounted\n+          \/\/ virtual thread that cannot run due to having run out of carriers. Upon waking\n+          \/\/ up, the thread will call reenter_internal() which will use timed-park in case\n+          \/\/ there is contention and there are still vthreads in the _entry_list.\n+          \/\/ If the target was interrupted or the wait timed-out at the same time, it could\n+          \/\/ have reached reenter_internal and read a false value of has_unmounted_vthreads()\n+          \/\/ before we added it to the _entry_list above. To deal with that case, we set _do_timed_park\n+          \/\/ which will be read by the target on the next loop iteration in reenter_internal.\n+          iterator->_do_timed_park = true;\n+          JavaThread* t = iterator->thread();\n+          t->_ParkEvent->unpark();\n+        }\n+        iterator->wait_reenter_begin(this);\n+      } else {\n+        iterator->TState = ObjectWaiter::TS_RUN;\n+        JavaThread* t = iterator->thread();\n+        assert(t != nullptr, \"\");\n+        t->_ParkEvent->unpark();\n+      }\n@@ -2065,4 +2096,0 @@\n-    iterator->_notifier_tid = JFR_THREAD_ID(current);\n-    did_notify = true;\n-    add_to_entry_list(current, iterator);\n-\n@@ -2072,1 +2099,1 @@\n-    \/\/ exception of  wait() timeouts and interrupts the monitor owner\n+    \/\/ exception of wait() timeouts and interrupts the monitor owner\n@@ -2076,22 +2103,0 @@\n-\n-    if (!iterator->is_vthread()) {\n-      iterator->wait_reenter_begin(this);\n-\n-      \/\/ Read counter *after* adding the thread to the _entry_list.\n-      \/\/ Adding to _entry_list uses Atomic::cmpxchg() which already provides\n-      \/\/ a fence that prevents this load from floating up previous store.\n-      if (has_unmounted_vthreads()) {\n-        \/\/ Wake up the thread to alleviate some deadlock cases where the successor\n-        \/\/ that will be picked up when this thread releases the monitor is an unmounted\n-        \/\/ virtual thread that cannot run due to having run out of carriers. Upon waking\n-        \/\/ up, the thread will call reenter_internal() which will use timed-park in case\n-        \/\/ there is contention and there are still vthreads in the _entry_list.\n-        \/\/ If the target was interrupted or the wait timed-out at the same time, it could\n-        \/\/ have reached reenter_internal and read a false value of has_unmounted_vthreads()\n-        \/\/ before we added it to the _entry_list above. To deal with that case, we set _do_timed_park\n-        \/\/ which will be read by the target on the next loop iteration in reenter_internal.\n-        iterator->_do_timed_park = true;\n-        JavaThread* t = iterator->thread();\n-        t->_ParkEvent->unpark();\n-      }\n-    }\n@@ -2224,0 +2229,1 @@\n+  bool was_notified = true;\n@@ -2229,0 +2235,1 @@\n+      was_notified = false;\n@@ -2235,2 +2242,3 @@\n-  bool was_notified = state == ObjectWaiter::TS_ENTER;\n-  assert(was_notified || state == ObjectWaiter::TS_RUN, \"\");\n+  assert(was_notified || state == ObjectWaiter::TS_RUN,\n+    \"was not notified and is not in the right state: was_notified = %s, state = %s\",\n+    was_notified ? \"true\" : \"false\", node->getTStateName(state));\n@@ -2249,1 +2257,4 @@\n-  if (!was_notified) {\n+  \/\/ We check the state rather than was_notified because, when JVMTI\n+  \/\/ monitor_waited event is enabled, the notifier only unparks the waiter\n+  \/\/ without adding it to the entry_list.\n+  if (state == ObjectWaiter::TS_RUN) {\n@@ -2540,0 +2551,17 @@\n+const char* ObjectWaiter::getTStateName(ObjectWaiter::TStates state) {\n+  switch (state) {\n+  case ObjectWaiter::TS_UNDEF:\n+    return \"TS_UNDEF\";\n+  case ObjectWaiter::TS_READY:\n+    return \"TS_READY\";\n+  case ObjectWaiter::TS_RUN:\n+    return \"TS_RUN\";\n+  case ObjectWaiter::TS_WAIT:\n+    return \"TS_WAIT\";\n+  case ObjectWaiter::TS_ENTER:\n+    return \"TS_ENTER\";\n+  default:\n+    ShouldNotReachHere();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":126,"deletions":98,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-\n@@ -75,1 +74,1 @@\n-\n+  const char* getTStateName(TStates state);\n@@ -355,1 +354,0 @@\n- private:\n@@ -365,7 +363,0 @@\n-  class ClearSuccOnSuspend {\n-   protected:\n-    ObjectMonitor* _om;\n-   public:\n-    ClearSuccOnSuspend(ObjectMonitor* om) : _om(om)  {}\n-    void operator()(JavaThread* current);\n-  };\n@@ -374,1 +365,1 @@\n-  void      notify_contended_enter(JavaThread *current);\n+  void      notify_contended_enter(JavaThread *current, bool post_jvmti_events = true);\n@@ -378,1 +369,1 @@\n-  bool      enter(JavaThread* current);\n+  bool      enter(JavaThread* current, bool post_jvmti_events = true);\n@@ -381,1 +372,1 @@\n-  void      enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark& contention_mark);\n+  void      enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark& contention_mark, bool post_jvmti_events = true);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1,371 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4413752 8262881\n- * @summary Test SuspendThread with ObjectMonitor wait.\n- * @requires vm.jvmti\n- * @library \/test\/lib\n- * @compile SuspendWithObjectMonitorWait.java\n- * @run main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWait\n- *\/\n-\n-import java.io.PrintStream;\n-\n-\/\/\n-\/\/ main               waiter              resumer\n-\/\/ =================  ==================  ===================\n-\/\/ launch waiter\n-\/\/ <launch returns>   waiter running\n-\/\/ launch resumer     enter threadLock\n-\/\/ <launch returns>   threadLock.wait()   resumer running\n-\/\/ enter threadLock   :                   wait for notify\n-\/\/ threadLock.notify  wait finishes       :\n-\/\/ :                  reenter blocks      :\n-\/\/ suspend waiter     <suspended>         :\n-\/\/ exit threadLock    :                   :\n-\/\/ <ready to test>    :                   :\n-\/\/ :                  :                   :\n-\/\/ notify resumer     :                   wait finishes\n-\/\/ join resumer       :                   enter threadLock\n-\/\/ :                  <resumed>           resume waiter\n-\/\/ :                  :                   exit threadLock\n-\/\/ :                  reenter threadLock  :\n-\/\/ <join returns>     :                   resumer exits\n-\/\/ join waiter        :\n-\/\/ <join returns>     waiter exits\n-\/\/\n-\n-public class SuspendWithObjectMonitorWait {\n-    private static final String AGENT_LIB = \"SuspendWithObjectMonitorWait\";\n-    private static final int exit_delta   = 95;\n-\n-    private static final int DEF_TIME_MAX = 60;    \/\/ default max # secs to test\n-    private static final int JOIN_MAX     = 30;    \/\/ max # secs to wait for join\n-\n-    public static final int TS_INIT            = 1;  \/\/ initial testState\n-    public static final int TS_WAITER_RUNNING  = 2;  \/\/ waiter is running\n-    public static final int TS_RESUMER_RUNNING = 3;  \/\/ resumer is running\n-    public static final int TS_READY_TO_NOTIFY = 4;  \/\/ ready to notify threadLock\n-    public static final int TS_CALL_SUSPEND    = 5;  \/\/ call suspend on contender\n-    public static final int TS_READY_TO_RESUME = 6;  \/\/ ready to resume waiter\n-    public static final int TS_CALL_RESUME     = 7;  \/\/ call resume on waiter\n-    public static final int TS_WAITER_DONE     = 8;  \/\/ waiter has run; done\n-\n-    public static Object barrierLaunch = new Object();   \/\/ controls thread launch\n-    public static Object barrierResumer = new Object();  \/\/ controls resumer\n-    public static Object threadLock = new Object();      \/\/ testing object\n-\n-    public static long count = 0;\n-    public static boolean printDebug = false;\n-    public volatile static int testState;\n-\n-    private static void log(String msg) { System.out.println(msg); }\n-\n-    native static int suspendThread(SuspendWithObjectMonitorWaitWorker thr);\n-    native static int wait4ContendedEnter(SuspendWithObjectMonitorWaitWorker thr);\n-\n-    public static void main(String[] args) throws Exception {\n-        try {\n-            System.loadLibrary(AGENT_LIB);\n-            log(\"Loaded library: \" + AGENT_LIB);\n-        } catch (UnsatisfiedLinkError ule) {\n-            log(\"Failed to load library: \" + AGENT_LIB);\n-            log(\"java.library.path: \" + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-\n-        int timeMax = 0;\n-        if (args.length == 0) {\n-            timeMax = DEF_TIME_MAX;\n-        } else {\n-            int argIndex = 0;\n-            int argsLeft = args.length;\n-            if (args[0].equals(\"-p\")) {\n-                printDebug = true;\n-                argIndex = 1;\n-                argsLeft--;\n-            }\n-            if (argsLeft == 0) {\n-                timeMax = DEF_TIME_MAX;\n-            } else if (argsLeft == 1) {\n-                try {\n-                    timeMax = Integer.parseUnsignedInt(args[argIndex]);\n-                } catch (NumberFormatException nfe) {\n-                    System.err.println(\"'\" + args[argIndex] +\n-                                       \"': invalid timeMax value.\");\n-                    usage();\n-                }\n-            } else {\n-                usage();\n-            }\n-        }\n-\n-        System.exit(run(timeMax, System.out) + exit_delta);\n-    }\n-\n-    public static void logDebug(String mesg) {\n-        if (printDebug) {\n-            System.err.println(Thread.currentThread().getName() + \": \" + mesg);\n-        }\n-    }\n-\n-    public static void usage() {\n-        System.err.println(\"Usage: \" + AGENT_LIB + \" [-p][time_max]\");\n-        System.err.println(\"where:\");\n-        System.err.println(\"    -p       ::= print debug info\");\n-        System.err.println(\"    time_max ::= max looping time in seconds\");\n-        System.err.println(\"                 (default is \" + DEF_TIME_MAX +\n-                           \" seconds)\");\n-        System.exit(1);\n-    }\n-\n-    public static int run(int timeMax, PrintStream out) {\n-        return (new SuspendWithObjectMonitorWait()).doWork(timeMax, out);\n-    }\n-\n-    public static void checkTestState(int exp) {\n-        if (testState != exp) {\n-            System.err.println(\"Failure at \" + count + \" loops.\");\n-            throw new InternalError(\"Unexpected test state value: \"\n-                + \"expected=\" + exp + \" actual=\" + testState);\n-        }\n-    }\n-\n-    public int doWork(int timeMax, PrintStream out) {\n-        SuspendWithObjectMonitorWaitWorker waiter;    \/\/ waiter thread\n-        SuspendWithObjectMonitorWaitWorker resumer;    \/\/ resumer thread\n-\n-        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n-\n-        long start_time = System.currentTimeMillis();\n-        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n-            count++;\n-            testState = TS_INIT;  \/\/ starting the test loop\n-\n-            \/\/ launch the waiter thread\n-            synchronized (barrierLaunch) {\n-                waiter = new SuspendWithObjectMonitorWaitWorker(\"waiter\");\n-                waiter.start();\n-\n-                while (testState != TS_WAITER_RUNNING) {\n-                    try {\n-                        barrierLaunch.wait(0);  \/\/ wait until it is running\n-                    } catch (InterruptedException ex) {\n-                    }\n-                }\n-            }\n-\n-            \/\/ launch the resumer thread\n-            synchronized (barrierLaunch) {\n-                resumer = new SuspendWithObjectMonitorWaitWorker(\"resumer\", waiter);\n-                resumer.start();\n-\n-                while (testState != TS_RESUMER_RUNNING) {\n-                    try {\n-                        barrierLaunch.wait(0);  \/\/ wait until it is running\n-                    } catch (InterruptedException ex) {\n-                    }\n-                }\n-            }\n-\n-            checkTestState(TS_RESUMER_RUNNING);\n-\n-            \/\/ The waiter thread was synchronized on threadLock before it\n-            \/\/ set TS_WAITER_RUNNING and notified barrierLaunch above so\n-            \/\/ we cannot enter threadLock until the waiter thread calls\n-            \/\/ threadLock.wait().\n-            synchronized (threadLock) {\n-                \/\/ notify waiter thread so it can try to reenter threadLock\n-                testState = TS_READY_TO_NOTIFY;\n-                threadLock.notify();\n-\n-                \/\/ wait for the waiter thread to block\n-                logDebug(\"before contended enter wait\");\n-                int retCode = wait4ContendedEnter(waiter);\n-                if (retCode != 0) {\n-                    throw new RuntimeException(\"error in JVMTI GetThreadState: \"\n-                                               + \"retCode=\" + retCode);\n-                }\n-                logDebug(\"done contended enter wait\");\n-\n-                checkTestState(TS_READY_TO_NOTIFY);\n-                testState = TS_CALL_SUSPEND;\n-                logDebug(\"before suspend thread\");\n-                retCode = suspendThread(waiter);\n-                if (retCode != 0) {\n-                    throw new RuntimeException(\"error in JVMTI SuspendThread: \"\n-                                               + \"retCode=\" + retCode);\n-                }\n-                logDebug(\"suspended thread\");\n-            }\n-\n-            \/\/\n-            \/\/ At this point, all of the child threads are running\n-            \/\/ and we can get to meat of the test:\n-            \/\/\n-            \/\/ - suspended threadLock waiter (trying to reenter)\n-            \/\/ - a threadLock enter in the resumer thread\n-            \/\/ - resumption of the waiter thread\n-            \/\/ - a threadLock enter in the freshly resumed waiter thread\n-            \/\/\n-\n-            synchronized (barrierResumer) {\n-                checkTestState(TS_CALL_SUSPEND);\n-\n-                \/\/ tell resumer thread to resume waiter thread\n-                testState = TS_READY_TO_RESUME;\n-                barrierResumer.notify();\n-\n-                \/\/ Can't call checkTestState() here because the\n-                \/\/ resumer thread may have already resumed the\n-                \/\/ waiter thread.\n-            }\n-\n-            try {\n-                resumer.join(JOIN_MAX * 1000);\n-                if (resumer.isAlive()) {\n-                    System.err.println(\"Failure at \" + count + \" loops.\");\n-                    throw new InternalError(\"resumer thread is stuck\");\n-                }\n-                waiter.join(JOIN_MAX * 1000);\n-                if (waiter.isAlive()) {\n-                    System.err.println(\"Failure at \" + count + \" loops.\");\n-                    throw new InternalError(\"waiter thread is stuck\");\n-                }\n-            } catch (InterruptedException ex) {\n-            }\n-\n-            checkTestState(TS_WAITER_DONE);\n-        }\n-\n-        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n-                           \" seconds.\");\n-\n-        return 0;\n-    }\n-}\n-\n-class SuspendWithObjectMonitorWaitWorker extends Thread {\n-    private SuspendWithObjectMonitorWaitWorker target;  \/\/ target for resume operation\n-\n-    public SuspendWithObjectMonitorWaitWorker(String name) {\n-        super(name);\n-    }\n-\n-    public SuspendWithObjectMonitorWaitWorker(String name, SuspendWithObjectMonitorWaitWorker target) {\n-        super(name);\n-        this.target = target;\n-    }\n-\n-    native static int resumeThread(SuspendWithObjectMonitorWaitWorker thr);\n-\n-    public void run() {\n-        SuspendWithObjectMonitorWait.logDebug(\"thread running\");\n-\n-        \/\/\n-        \/\/ Launch the waiter thread:\n-        \/\/ - grab the threadLock\n-        \/\/ - threadLock.wait()\n-        \/\/ - releases threadLock\n-        \/\/\n-        if (getName().equals(\"waiter\")) {\n-            \/\/ grab threadLock before we tell main we are running\n-            SuspendWithObjectMonitorWait.logDebug(\"before enter threadLock\");\n-            synchronized(SuspendWithObjectMonitorWait.threadLock) {\n-                SuspendWithObjectMonitorWait.logDebug(\"enter threadLock\");\n-\n-                SuspendWithObjectMonitorWait.checkTestState(SuspendWithObjectMonitorWait.TS_INIT);\n-\n-                synchronized(SuspendWithObjectMonitorWait.barrierLaunch) {\n-                    \/\/ tell main we are running\n-                    SuspendWithObjectMonitorWait.testState = SuspendWithObjectMonitorWait.TS_WAITER_RUNNING;\n-                    SuspendWithObjectMonitorWait.barrierLaunch.notify();\n-                }\n-\n-                SuspendWithObjectMonitorWait.logDebug(\"before wait\");\n-\n-                \/\/ TS_READY_TO_NOTIFY is set after the main thread has\n-                \/\/ entered threadLock so a spurious wakeup can't get the\n-                \/\/ waiter thread out of this threadLock.wait(0) call:\n-                while (SuspendWithObjectMonitorWait.testState <= SuspendWithObjectMonitorWait.TS_READY_TO_NOTIFY) {\n-                    try {\n-                        SuspendWithObjectMonitorWait.threadLock.wait(0);\n-                    } catch (InterruptedException ex) {\n-                    }\n-                }\n-\n-                SuspendWithObjectMonitorWait.logDebug(\"after wait\");\n-\n-                SuspendWithObjectMonitorWait.checkTestState(SuspendWithObjectMonitorWait.TS_CALL_RESUME);\n-                SuspendWithObjectMonitorWait.testState = SuspendWithObjectMonitorWait.TS_WAITER_DONE;\n-\n-                SuspendWithObjectMonitorWait.logDebug(\"exit threadLock\");\n-            }\n-        }\n-        \/\/\n-        \/\/ Launch the resumer thread:\n-        \/\/ - tries to grab the threadLock (should not block!)\n-        \/\/ - grabs threadLock\n-        \/\/ - resumes the waiter thread\n-        \/\/ - releases threadLock\n-        \/\/\n-        else if (getName().equals(\"resumer\")) {\n-            synchronized(SuspendWithObjectMonitorWait.barrierResumer) {\n-                synchronized(SuspendWithObjectMonitorWait.barrierLaunch) {\n-                    \/\/ tell main we are running\n-                    SuspendWithObjectMonitorWait.testState = SuspendWithObjectMonitorWait.TS_RESUMER_RUNNING;\n-                    SuspendWithObjectMonitorWait.barrierLaunch.notify();\n-                }\n-                SuspendWithObjectMonitorWait.logDebug(\"thread waiting\");\n-                while (SuspendWithObjectMonitorWait.testState != SuspendWithObjectMonitorWait.TS_READY_TO_RESUME) {\n-                    try {\n-                        \/\/ wait for main to tell us when to continue\n-                        SuspendWithObjectMonitorWait.barrierResumer.wait(0);\n-                    } catch (InterruptedException ex) {\n-                    }\n-                }\n-            }\n-\n-            SuspendWithObjectMonitorWait.logDebug(\"before enter threadLock\");\n-            synchronized(SuspendWithObjectMonitorWait.threadLock) {\n-                SuspendWithObjectMonitorWait.logDebug(\"enter threadLock\");\n-\n-                SuspendWithObjectMonitorWait.checkTestState(SuspendWithObjectMonitorWait.TS_READY_TO_RESUME);\n-                SuspendWithObjectMonitorWait.testState = SuspendWithObjectMonitorWait.TS_CALL_RESUME;\n-\n-                \/\/ resume the waiter thread so waiter.join() can work\n-                SuspendWithObjectMonitorWait.logDebug(\"before resume thread\");\n-                int retCode = resumeThread(target);\n-                if (retCode != 0) {\n-                    throw new RuntimeException(\"error in JVMTI ResumeThread: \" +\n-                                               \"retCode=\" + retCode);\n-                }\n-                SuspendWithObjectMonitorWait.logDebug(\"resumed thread\");\n-\n-                SuspendWithObjectMonitorWait.logDebug(\"exit threadLock\");\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWait.java","additions":0,"deletions":371,"binary":false,"changes":371,"status":"deleted"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+public class SuspendWithObjectMonitorWaitBase {\n+    protected static final String AGENT_LIB = \"SuspendWithObjectMonitorWait\";\n+    protected static final int exit_delta   = 95;\n+\n+    protected static final int DEF_TIME_MAX = 60;    \/\/ default max # secs to test\n+    protected static final int JOIN_MAX     = 30;    \/\/ max # secs to wait for join\n+\n+    public static final int TS_INIT            = 1;  \/\/ initial testState\n+    public static final int TS_WAITER_RUNNING  = 2;  \/\/ waiter is running\n+    public static final int TS_RESUMER_RUNNING = 3;  \/\/ resumer is running\n+    public static final int TS_READY_TO_NOTIFY = 4;  \/\/ ready to notify threadLock\n+    public static final int TS_CALL_SUSPEND    = 5;  \/\/ call suspend on contender\n+    public static final int TS_READY_TO_RESUME = 6;  \/\/ ready to resume waiter\n+    public static final int TS_CALL_RESUME     = 7;  \/\/ call resume on waiter\n+    public static final int TS_WAITER_DONE     = 8;  \/\/ waiter has run; done\n+\n+    public static Object barrierLaunch = new Object();   \/\/ controls thread launch\n+    public static Object barrierResumer = new Object();  \/\/ controls resumer\n+    public static Object threadLock = new Object();      \/\/ testing object\n+\n+    public static long count = 0;\n+    public static boolean printDebug = false;\n+    public volatile static int testState;\n+\n+    protected static void log(String msg) { System.out.println(msg); }\n+\n+    native static int suspendThread(SuspendWithObjectMonitorWaitWorker thr);\n+    native static int wait4ContendedEnter(SuspendWithObjectMonitorWaitWorker thr);\n+\n+    public static void logDebug(String mesg) {\n+        if (printDebug) {\n+            System.err.println(Thread.currentThread().getName() + \": \" + mesg);\n+        }\n+    }\n+\n+    public static void usage() {\n+        System.err.println(\"Usage: \" + AGENT_LIB + \" test_case [-p] [time_max]\");\n+        System.err.println(\"where:\");\n+        System.err.println(\"    test_case ::= 1 | 2 | 3\");\n+        System.err.println(\"    -p        ::= print debug info\");\n+        System.err.println(\"    time_max  ::= max looping time in seconds\");\n+        System.err.println(\"                  (default is \" + DEF_TIME_MAX +\n+                \" seconds)\");\n+        System.exit(1);\n+    }\n+\n+    public static void checkTestState(int exp) {\n+        if (testState != exp) {\n+            System.err.println(\"Failure at \" + count + \" loops.\");\n+            throw new InternalError(\"Unexpected test state value: \"\n+                    + \"expected=\" + exp + \" actual=\" + testState);\n+        }\n+    }\n+\n+    public SuspendWithObjectMonitorWaitWorker launchWaiter(long waitTimeout) {\n+        SuspendWithObjectMonitorWaitWorker waiter;\n+        \/\/ launch the waiter thread\n+        synchronized (barrierLaunch) {\n+            waiter = new SuspendWithObjectMonitorWaitWorker(\"waiter\", waitTimeout);\n+            waiter.start();\n+\n+            while (testState != TS_WAITER_RUNNING) {\n+                try {\n+                    barrierLaunch.wait(0);  \/\/ wait until it is running\n+                } catch (InterruptedException ex) {\n+                }\n+            }\n+        }\n+        return waiter;\n+    }\n+\n+    public SuspendWithObjectMonitorWaitWorker launchResumer(SuspendWithObjectMonitorWaitWorker waiter) {\n+        SuspendWithObjectMonitorWaitWorker resumer;\n+        synchronized (barrierLaunch) {\n+            resumer = new SuspendWithObjectMonitorWaitWorker(\"resumer\", waiter);\n+            resumer.start();\n+\n+            while (testState != TS_RESUMER_RUNNING) {\n+                try {\n+                    barrierLaunch.wait(0);  \/\/ wait until it is running\n+                } catch (InterruptedException ex) {\n+                }\n+            }\n+        }\n+        return resumer;\n+    }\n+\n+    public void barrierResumerNotify() {\n+        synchronized (barrierResumer) {\n+            checkTestState(TS_CALL_SUSPEND);\n+\n+            \/\/ tell resumer thread to resume waiter thread\n+            testState = TS_READY_TO_RESUME;\n+            barrierResumer.notify();\n+\n+            \/\/ Can't call checkTestState() here because the\n+            \/\/ resumer thread may have already resumed the\n+            \/\/ waiter thread.\n+        }\n+    }\n+\n+    public void shutDown(SuspendWithObjectMonitorWaitWorker resumer, SuspendWithObjectMonitorWaitWorker waiter) {\n+        try {\n+            resumer.join(JOIN_MAX * 1000);\n+            if (resumer.isAlive()) {\n+                System.err.println(\"Failure at \" + count + \" loops.\");\n+                throw new InternalError(\"resumer thread is stuck\");\n+            }\n+            waiter.join(JOIN_MAX * 1000);\n+            if (waiter.isAlive()) {\n+                System.err.println(\"Failure at \" + count + \" loops.\");\n+                throw new InternalError(\"waiter thread is stuck\");\n+            }\n+        } catch (InterruptedException ex) {\n+        }\n+    }\n+\n+    public int run(int timeMax, PrintStream out) {\n+        return 0;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            System.err.println(\"Invalid number of arguments, there should be at least a test_case given.\");\n+            usage();\n+        }\n+\n+        if (args.length > 3) {\n+            System.err.println(\"Invalid number of arguments, there are too many arguments.\");\n+            usage();\n+        }\n+\n+        try {\n+            System.loadLibrary(AGENT_LIB);\n+            log(\"Loaded library: \" + AGENT_LIB);\n+        } catch (UnsatisfiedLinkError ule) {\n+            log(\"Failed to load library: \" + AGENT_LIB);\n+            log(\"java.library.path: \" + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+\n+        int testCase = 0;\n+        int timeMax = 0;\n+        for (int argIndex = 0; argIndex < args.length; argIndex++) {\n+            if (args[argIndex].equals(\"-p\")) {\n+                \/\/ Handle optional -p arg regardless of position.\n+                printDebug = true;\n+                continue;\n+            }\n+\n+            if (testCase == 0) {\n+                try {\n+                    \/\/ testCase must be the first non-optional arg.\n+                    testCase = Integer.parseUnsignedInt(args[argIndex]);\n+                    log(\"testCase = \" + testCase);\n+                } catch (NumberFormatException nfe) {\n+                    System.err.println(\"'\" + args[argIndex] +\n+                            \"': invalid test_case value.\");\n+                    usage();\n+                }\n+                if (testCase < 1 || testCase > 3) {\n+                    System.err.println(\"Invalid test_case value: '\" + testCase + \"'\");\n+                    usage();\n+                }\n+                continue;\n+            }\n+\n+            if (argIndex < args.length) {\n+                \/\/ timeMax is an optional arg.\n+                try {\n+                    timeMax = Integer.parseUnsignedInt(args[argIndex]);\n+                } catch (NumberFormatException nfe) {\n+                    System.err.println(\"'\" + args[argIndex] +\n+                            \"': invalid time_max value.\");\n+                    usage();\n+                }\n+            } else {\n+                timeMax = DEF_TIME_MAX;\n+            }\n+        }\n+\n+        if (timeMax == 0) {\n+            timeMax = DEF_TIME_MAX;\n+        }\n+        log(\"timeMax = \" + timeMax);\n+\n+        if (testCase == 0) {\n+            \/\/ Just -p was given.\n+            System.err.println(\"Invalid number of arguments, no test_case given.\");\n+            usage();\n+        }\n+\n+        SuspendWithObjectMonitorWaitBase test = null;\n+        switch (testCase) {\n+            case 1:\n+                test = new SuspendWithObjectMonitorWaitDefault();\n+                break;\n+            case 2:\n+                test = new SuspendWithObjectMonitorWaitReentryPartFirst();\n+                break;\n+            case 3:\n+                test = new SuspendWithObjectMonitorWaitReentryPartSecond();\n+                break;\n+            default:\n+                \/\/ Impossible\n+                break;\n+        }\n+        int result = test.run(timeMax, System.out);\n+        System.exit(result + exit_delta);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWaitBase.java","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4413752 8262881\n+ * @summary Test SuspendThread with ObjectMonitor wait.\n+ * @requires vm.jvmti\n+ * @library \/test\/lib\n+ * @compile SuspendWithObjectMonitorWaitDefault.java\n+ * @run main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWaitDefault 1\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+\/\/\n+\/\/ SuspendWithObjectMonitorWaitDefault algorithm:\n+\/\/\n+\/\/ main               waiter              resumer\n+\/\/ =================  ==================  ===================\n+\/\/ launch waiter\n+\/\/ <launch returns>   waiter running\n+\/\/ launch resumer     enter threadLock\n+\/\/ <launch returns>   threadLock.wait()   resumer running\n+\/\/ enter threadLock   :                   wait for notify\n+\/\/ threadLock.notify  wait finishes       :\n+\/\/ :                  reenter blocks      :\n+\/\/ suspend waiter     <suspended>         :\n+\/\/ exit threadLock    :                   :\n+\/\/ <ready to test>    :                   :\n+\/\/ :                  :                   :\n+\/\/ notify resumer     :                   wait finishes\n+\/\/ join resumer       :                   enter threadLock\n+\/\/ :                  <resumed>           resume waiter\n+\/\/ :                  :                   exit threadLock\n+\/\/ :                  reenter threadLock  :\n+\/\/ <join returns>     :                   resumer exits\n+\/\/ join waiter        :\n+\/\/ <join returns>     waiter exits\n+\/\/\n+\n+public class SuspendWithObjectMonitorWaitDefault extends SuspendWithObjectMonitorWaitBase {\n+\n+    @Override\n+    public int run(int timeMax, PrintStream out) {\n+        return doWork1(timeMax, out);\n+    }\n+\n+    \/\/ Default scenario, the resumer thread is always able to grab the threadLock once notified by the main thread.\n+    public int doWork1(int timeMax, PrintStream out) {\n+        SuspendWithObjectMonitorWaitWorker waiter;    \/\/ waiter thread\n+        SuspendWithObjectMonitorWaitWorker resumer;   \/\/ resumer thread\n+\n+        System.out.println(\"Test 1: About to execute for \" + timeMax + \" seconds.\");\n+\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n+            testState = TS_INIT;  \/\/ starting the test loop\n+\n+            \/\/ launch the waiter thread\n+            waiter = launchWaiter(0);\n+\n+            \/\/ launch the resumer thread\n+            resumer = launchResumer(waiter);\n+\n+            checkTestState(TS_RESUMER_RUNNING);\n+\n+            \/\/ The waiter thread was synchronized on threadLock before it\n+            \/\/ set TS_WAITER_RUNNING and notified barrierLaunch above so\n+            \/\/ we cannot enter threadLock until the waiter thread calls\n+            \/\/ threadLock.wait().\n+            synchronized (threadLock) {\n+                \/\/ notify waiter thread so it can try to reenter threadLock\n+                testState = TS_READY_TO_NOTIFY;\n+                threadLock.notify();\n+\n+                \/\/ wait for the waiter thread to block\n+                logDebug(\"before contended enter wait\");\n+                int retCode = wait4ContendedEnter(waiter);\n+                if (retCode != 0) {\n+                    throw new RuntimeException(\"error in JVMTI GetThreadState: \"\n+                                               + \"retCode=\" + retCode);\n+                }\n+                logDebug(\"done contended enter wait\");\n+\n+                checkTestState(TS_READY_TO_NOTIFY);\n+                testState = TS_CALL_SUSPEND;\n+                logDebug(\"before suspend thread\");\n+                retCode = suspendThread(waiter);\n+                if (retCode != 0) {\n+                    throw new RuntimeException(\"error in JVMTI SuspendThread: \"\n+                                               + \"retCode=\" + retCode);\n+                }\n+                logDebug(\"suspended thread\");\n+            }\n+\n+            \/\/\n+            \/\/ At this point, all of the child threads are running\n+            \/\/ and we can get to meat of the test:\n+            \/\/\n+            \/\/ - suspended threadLock waiter (trying to reenter)\n+            \/\/ - a threadLock enter in the resumer thread\n+            \/\/ - resumption of the waiter thread\n+            \/\/ - a threadLock enter in the freshly resumed waiter thread\n+            \/\/\n+            barrierResumerNotify();\n+\n+            shutDown(waiter ,resumer);\n+            checkTestState(TS_WAITER_DONE);\n+        }\n+\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                           \" seconds.\");\n+\n+        return 0;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWaitDefault.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4413752 8262881\n+ * @summary Test SuspendThread with ObjectMonitor wait.\n+ * @requires vm.jvmti\n+ * @library \/test\/lib\n+ * @compile SuspendWithObjectMonitorWaitReentryPartFirst.java\n+ * @run main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWaitReentryPartFirst 2\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+\/\/\n+\/\/ SuspendWithObjectMonitorWaitReentryPartFirst algorithm:\n+\/\/\n+\/\/ main               waiter              resumer\n+\/\/ =================  ==================  ===================\n+\/\/ launch waiter\n+\/\/ <launch returns>   waiter running\n+\/\/ launch resumer     enter threadLock\n+\/\/ <launch returns>   threadLock.wait()   resumer running\n+\/\/ enter threadLock   :                   wait for notify\n+\/\/ threadLock.notify  wait finishes       :\n+\/\/ :                  reenter blocks      :\n+\/\/ suspend waiter     <suspended>         :\n+\/\/ <ready to test>    :                   :\n+\/\/ :                  :                   :\n+\/\/ notify resumer     :                   wait finishes\n+\/\/ delay 1-second     :                   :\n+\/\/ exit threadLock    :                   :\n+\/\/ join resumer       :                   enter threadLock\n+\/\/ :                  <resumed>           resume waiter\n+\/\/ :                  :                   exit threadLock\n+\/\/ :                  reenter threadLock  :\n+\/\/ <join returns>     :                   resumer exits\n+\/\/ join waiter        :\n+\/\/ <join returns>     waiter exits\n+\/\/\n+\/\/ Note: The sleep(1-second) in main along with the delayed exit\n+\/\/       of threadLock in main forces the resumer thread to reach\n+\/\/       \"enter threadLock\" and block. This difference from the default scenario\n+\/\/       forces the resumer thread to be contending for threadLock\n+\/\/       while the waiter thread is in threadLock.wait() increasing\n+\/\/       stress on the monitor sub-system.\n+\/\/\n+\n+public class SuspendWithObjectMonitorWaitReentryPartFirst extends SuspendWithObjectMonitorWaitBase {\n+\n+    @Override\n+    public int run(int timeMax, PrintStream out) {\n+        return doWork2(timeMax, out);\n+    }\n+\n+    \/\/ Notify the resumer while holding the threadLock.\n+    public int doWork2(int timeMax, PrintStream out) {\n+        SuspendWithObjectMonitorWaitWorker waiter;    \/\/ waiter thread\n+        SuspendWithObjectMonitorWaitWorker resumer;   \/\/ resumer thread\n+\n+        System.out.println(\"Test 2: About to execute for \" + timeMax + \" seconds.\");\n+\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n+            testState = TS_INIT;  \/\/ starting the test loop\n+\n+            \/\/ launch the waiter thread\n+            waiter = launchWaiter(0);\n+\n+            \/\/ launch the resumer thread\n+            resumer = launchResumer(waiter);\n+\n+            checkTestState(TS_RESUMER_RUNNING);\n+\n+            \/\/ The waiter thread was synchronized on threadLock before it\n+            \/\/ set TS_WAITER_RUNNING and notified barrierLaunch above so\n+            \/\/ we cannot enter threadLock until the waiter thread calls\n+            \/\/ threadLock.wait().\n+            synchronized (threadLock) {\n+                \/\/ notify waiter thread so it can try to reenter threadLock\n+                testState = TS_READY_TO_NOTIFY;\n+                threadLock.notify();\n+\n+                \/\/ wait for the waiter thread to block\n+                logDebug(\"before contended enter wait\");\n+                int retCode = wait4ContendedEnter(waiter);\n+                if (retCode != 0) {\n+                    throw new RuntimeException(\"error in JVMTI GetThreadState: \"\n+                            + \"retCode=\" + retCode);\n+                }\n+                logDebug(\"done contended enter wait\");\n+\n+                checkTestState(TS_READY_TO_NOTIFY);\n+                testState = TS_CALL_SUSPEND;\n+                logDebug(\"before suspend thread\");\n+                retCode = suspendThread(waiter);\n+                if (retCode != 0) {\n+                    throw new RuntimeException(\"error in JVMTI SuspendThread: \"\n+                            + \"retCode=\" + retCode);\n+                }\n+                logDebug(\"suspended thread\");\n+\n+                \/\/\n+                \/\/ At this point, all of the child threads are running\n+                \/\/ and we can get to meat of the test:\n+                \/\/\n+                \/\/ - suspended threadLock waiter (trying to reenter)\n+                \/\/ - a blocked threadLock enter in the resumer thread while the\n+                \/\/   threadLock is held by the main thread.\n+                \/\/ - resumption of the waiter thread\n+                \/\/ - a threadLock enter in the freshly resumed waiter thread\n+                \/\/\n+                barrierResumerNotify();\n+                try {\n+                    \/\/ Delay for 1-second while holding the threadLock to force the\n+                    \/\/ resumer thread to block on entering the threadLock.\n+                    Thread.sleep(1000);\n+                } catch (Exception e) {}\n+            }\n+\n+            shutDown(waiter ,resumer);\n+            checkTestState(TS_WAITER_DONE);\n+        }\n+\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                \" seconds.\");\n+\n+        return 0;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWaitReentryPartFirst.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4413752 8262881\n+ * @summary Test SuspendThread with ObjectMonitor wait.\n+ * @requires vm.jvmti\n+ * @library \/test\/lib\n+ * @compile SuspendWithObjectMonitorWaitReentryPartSecond.java\n+ * @run main\/othervm\/native -agentlib:SuspendWithObjectMonitorWait SuspendWithObjectMonitorWaitReentryPartSecond 3\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+\/\/\n+\/\/ SuspendWithObjectMonitorWaitReentryPartSecond algorithm:\n+\/\/\n+\/\/ main                 waiter                  resumer\n+\/\/ ===================  ======================  ===================\n+\/\/ launch waiter\n+\/\/ <launch returns>     waiter running\n+\/\/ launch resumer       enter threadLock\n+\/\/ <launch returns>     while !READY_TO_NOTIFY  resumer running\n+\/\/ :                      threadLock.wait(1)    wait for notify\n+\/\/ enter threadLock     :                       :\n+\/\/ set READY_TO_NOTIFY  :\n+\/\/ threadLock.notify    wait finishes           :\n+\/\/ : delay 200ms        reenter blocks          :\n+\/\/ suspend waiter       <suspended>             :\n+\/\/ <ready to test>      :                       :\n+\/\/ :                    :                       :\n+\/\/ notify resumer       :                       wait finishes\n+\/\/ delay 1-second       :                       :\n+\/\/ exit threadLock      :                       :\n+\/\/ join resumer         :                       enter threadLock\n+\/\/ :                    <resumed>               resume waiter\n+\/\/ :                    :                       exit threadLock\n+\/\/ :                    reenter threadLock      :\n+\/\/ <join returns>       :                       resumer exits\n+\/\/ join waiter          :\n+\/\/ <join returns>       waiter exits\n+\/\/\n+\/\/ Note: The sleep(1-second) in main along with the delayed exit\n+\/\/       of threadLock in main forces the resumer thread to reach\n+\/\/       \"enter threadLock\" and block. This difference from the default scenario\n+\/\/       forces the resumer thread to be contending for threadLock\n+\/\/       while the waiter thread is in the threadLock.wait(1) tight\n+\/\/       loop increasing stress on the monitor sub-system.\n+\/\/\n+\/\/ Note: sleep(200ms) here while holding the threadLock to allow the\n+\/\/       waiter thread's timed wait to finish before we attempt to\n+\/\/       suspend the waiter thread.\n+\/\/\n+\n+public class SuspendWithObjectMonitorWaitReentryPartSecond extends SuspendWithObjectMonitorWaitBase {\n+\n+    @Override\n+    public int run(int timeMax, PrintStream out) {\n+        return doWork3(timeMax, out);\n+    }\n+\n+    \/\/ Suspend on the re-entry path of wait.\n+    public int doWork3(int timeMax, PrintStream out) {\n+        SuspendWithObjectMonitorWaitWorker waiter;    \/\/ waiter thread\n+        SuspendWithObjectMonitorWaitWorker resumer;   \/\/ resumer thread\n+\n+        System.out.println(\"Test 3: About to execute for \" + timeMax + \" seconds.\");\n+\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n+            testState = TS_INIT;  \/\/ starting the test loop\n+\n+            \/\/ launch the waiter thread\n+            waiter = launchWaiter(100);\n+\n+            \/\/ launch the resumer thread\n+            resumer = launchResumer(waiter);\n+\n+            checkTestState(TS_RESUMER_RUNNING);\n+\n+            \/\/ The waiter thread was synchronized on threadLock before it\n+            \/\/ set TS_WAITER_RUNNING and notified barrierLaunch above so\n+            \/\/ we cannot enter threadLock until the waiter thread calls\n+            \/\/ threadLock.wait().\n+            synchronized (threadLock) {\n+                \/\/ notify waiter thread so it can try to reenter threadLock\n+                testState = TS_READY_TO_NOTIFY;\n+                threadLock.notify();\n+\n+                try {\n+                    Thread.sleep(200);\n+                } catch (Exception e) {}\n+\n+                \/\/ wait for the waiter thread to block\n+                logDebug(\"before contended enter wait\");\n+                int retCode = wait4ContendedEnter(waiter);\n+                if (retCode != 0) {\n+                    throw new RuntimeException(\"error in JVMTI GetThreadState: \"\n+                            + \"retCode=\" + retCode);\n+                }\n+                logDebug(\"done contended enter wait\");\n+\n+                checkTestState(TS_READY_TO_NOTIFY);\n+                testState = TS_CALL_SUSPEND;\n+                logDebug(\"before suspend thread\");\n+                retCode = suspendThread(waiter);\n+                if (retCode != 0) {\n+                    throw new RuntimeException(\"error in JVMTI SuspendThread: \"\n+                            + \"retCode=\" + retCode);\n+                }\n+                logDebug(\"suspended thread\");\n+\n+                \/\/\n+                \/\/ At this point, all of the child threads are running\n+                \/\/ and we can get to meat of the test:\n+                \/\/\n+                \/\/ - suspended threadLock waiter (trying to reenter)\n+                \/\/ - a blocked threadLock enter in the resumer thread while the\n+                \/\/   threadLock is held by the main thread.\n+                \/\/ - resumption of the waiter thread\n+                \/\/ - a threadLock enter in the freshly resumed waiter thread\n+                \/\/\n+                barrierResumerNotify();\n+                try {\n+                    \/\/ Delay for 1-second while holding the threadLock to force the\n+                    \/\/ resumer thread to block on entering the threadLock.\n+                    Thread.sleep(1000);\n+                } catch (Exception e) {}\n+            }\n+\n+            shutDown(waiter ,resumer);\n+            checkTestState(TS_WAITER_DONE);\n+        }\n+\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                \" seconds.\");\n+\n+        return 0;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWaitReentryPartSecond.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class SuspendWithObjectMonitorWaitWorker extends Thread {\n+    private SuspendWithObjectMonitorWaitWorker target;  \/\/ target for resume operation\n+    private final long waitTimeout;\n+\n+    public SuspendWithObjectMonitorWaitWorker(String name, long waitTimeout) {\n+        super(name);\n+        this.waitTimeout = waitTimeout;\n+    }\n+\n+    public SuspendWithObjectMonitorWaitWorker(String name, SuspendWithObjectMonitorWaitWorker target) {\n+        super(name);\n+        this.target = target;\n+        this.waitTimeout = 0;\n+    }\n+\n+    native static int resumeThread(SuspendWithObjectMonitorWaitWorker thr);\n+\n+    public void run() {\n+        SuspendWithObjectMonitorWaitBase.logDebug(\"thread running\");\n+\n+        \/\/\n+        \/\/ Launch the waiter thread:\n+        \/\/ - grab the threadLock\n+        \/\/ - threadLock.wait()\n+        \/\/ - releases threadLock\n+        \/\/\n+        if (getName().equals(\"waiter\")) {\n+            \/\/ grab threadLock before we tell main we are running\n+            SuspendWithObjectMonitorWaitBase.logDebug(\"before enter threadLock\");\n+            synchronized(SuspendWithObjectMonitorWaitBase.threadLock) {\n+                SuspendWithObjectMonitorWaitBase.logDebug(\"enter threadLock\");\n+\n+                SuspendWithObjectMonitorWaitBase.checkTestState(SuspendWithObjectMonitorWaitBase.TS_INIT);\n+\n+                synchronized(SuspendWithObjectMonitorWaitBase.barrierLaunch) {\n+                    \/\/ tell main we are running\n+                    SuspendWithObjectMonitorWaitBase.testState = SuspendWithObjectMonitorWaitBase.TS_WAITER_RUNNING;\n+                    SuspendWithObjectMonitorWaitBase.barrierLaunch.notify();\n+                }\n+\n+                SuspendWithObjectMonitorWaitBase.logDebug(\"before wait\");\n+\n+                \/\/ TS_READY_TO_NOTIFY is set after the main thread has\n+                \/\/ entered threadLock so a spurious wakeup can't get the\n+                \/\/ waiter thread out of this threadLock.wait(0) call:\n+                while (SuspendWithObjectMonitorWaitBase.testState <= SuspendWithObjectMonitorWaitBase.TS_READY_TO_NOTIFY) {\n+                    try {\n+                        SuspendWithObjectMonitorWaitBase.threadLock.wait(waitTimeout);\n+                    } catch (InterruptedException ex) {\n+                    }\n+                }\n+\n+                SuspendWithObjectMonitorWaitBase.logDebug(\"after wait\");\n+\n+                SuspendWithObjectMonitorWaitBase.checkTestState(SuspendWithObjectMonitorWaitBase.TS_CALL_RESUME);\n+                SuspendWithObjectMonitorWaitBase.testState = SuspendWithObjectMonitorWaitBase.TS_WAITER_DONE;\n+\n+                SuspendWithObjectMonitorWaitBase.logDebug(\"exit threadLock\");\n+            }\n+        }\n+        \/\/\n+        \/\/ Launch the resumer thread:\n+        \/\/ - tries to grab the threadLock (should not block with doWork1!)\n+        \/\/ - grabs threadLock\n+        \/\/ - resumes the waiter thread\n+        \/\/ - releases threadLock\n+        \/\/\n+        else if (getName().equals(\"resumer\")) {\n+            synchronized(SuspendWithObjectMonitorWaitBase.barrierResumer) {\n+                synchronized(SuspendWithObjectMonitorWaitBase.barrierLaunch) {\n+                    \/\/ tell main we are running\n+                    SuspendWithObjectMonitorWaitBase.testState = SuspendWithObjectMonitorWaitBase.TS_RESUMER_RUNNING;\n+                    SuspendWithObjectMonitorWaitBase.barrierLaunch.notify();\n+                }\n+                SuspendWithObjectMonitorWaitBase.logDebug(\"thread waiting\");\n+                while (SuspendWithObjectMonitorWaitBase.testState != SuspendWithObjectMonitorWaitBase.TS_READY_TO_RESUME) {\n+                    try {\n+                        \/\/ wait for main to tell us when to continue\n+                        SuspendWithObjectMonitorWaitBase.barrierResumer.wait(0);\n+                    } catch (InterruptedException ex) {\n+                    }\n+                }\n+            }\n+\n+            SuspendWithObjectMonitorWaitBase.logDebug(\"before enter threadLock\");\n+            synchronized(SuspendWithObjectMonitorWaitBase.threadLock) {\n+                SuspendWithObjectMonitorWaitBase.logDebug(\"enter threadLock\");\n+\n+                SuspendWithObjectMonitorWaitBase.checkTestState(SuspendWithObjectMonitorWaitBase.TS_READY_TO_RESUME);\n+                SuspendWithObjectMonitorWaitBase.testState = SuspendWithObjectMonitorWaitBase.TS_CALL_RESUME;\n+\n+                \/\/ resume the waiter thread so waiter.join() can work\n+                SuspendWithObjectMonitorWaitBase.logDebug(\"before resume thread\");\n+                int retCode = resumeThread(target);\n+                if (retCode != 0) {\n+                    throw new RuntimeException(\"error in JVMTI ResumeThread: \" +\n+                            \"retCode=\" + retCode);\n+                }\n+                SuspendWithObjectMonitorWaitBase.logDebug(\"resumed thread\");\n+\n+                SuspendWithObjectMonitorWaitBase.logDebug(\"exit threadLock\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/SuspendWithObjectMonitorWaitWorker.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-Java_SuspendWithObjectMonitorWait_suspendThread(JNIEnv *jni, jclass cls, jthread thr) {\n+Java_SuspendWithObjectMonitorWaitBase_suspendThread(JNIEnv *jni, jclass cls, jthread thr) {\n@@ -49,1 +49,1 @@\n-Java_SuspendWithObjectMonitorWait_wait4ContendedEnter(JNIEnv *jni, jclass cls, jthread thr) {\n+Java_SuspendWithObjectMonitorWaitBase_wait4ContendedEnter(JNIEnv *jni, jclass cls, jthread thr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/libSuspendWithObjectMonitorWait.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}