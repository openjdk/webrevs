{"files":[{"patch":"@@ -429,1 +429,1 @@\n-        ASAN_CFLAGS=\"-fsanitize=address -Wno-stringop-truncation -fno-omit-frame-pointer -DADDRESS_SANITIZER\"\n+        ASAN_CFLAGS=\"-fsanitize=address -Wno-stringop-truncation -fno-omit-frame-pointer -fno-common -DADDRESS_SANITIZER\"\n","filename":"make\/autoconf\/jdk-options.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"sanitizers\/address.h\"\n@@ -110,0 +111,17 @@\n+Metachunk* ChunkManager::get_chunk(chunklevel_t preferred_level, chunklevel_t max_level, size_t min_committed_words) {\n+  assert(preferred_level <= max_level, \"Sanity\");\n+  assert(chunklevel::level_fitting_word_size(min_committed_words) >= max_level, \"Sanity\");\n+\n+  Metachunk* c;\n+  {\n+    MutexLocker fcl(Metaspace_lock, Mutex::_no_safepoint_check_flag);\n+    c = get_chunk_locked(preferred_level, max_level, min_committed_words);\n+  }\n+\n+  if (c != nullptr) {\n+    ASAN_UNPOISON_MEMORY_REGION(c->base(), c->word_size() * BytesPerWord);\n+  }\n+\n+  return c;\n+}\n+\n@@ -119,6 +137,2 @@\n-Metachunk* ChunkManager::get_chunk(chunklevel_t preferred_level, chunklevel_t max_level, size_t min_committed_words) {\n-  assert(preferred_level <= max_level, \"Sanity\");\n-  assert(chunklevel::level_fitting_word_size(min_committed_words) >= max_level, \"Sanity\");\n-\n-  MutexLocker fcl(Metaspace_lock, Mutex::_no_safepoint_check_flag);\n-\n+Metachunk* ChunkManager::get_chunk_locked(chunklevel_t preferred_level, chunklevel_t max_level, size_t min_committed_words) {\n+  assert_lock_strong(Metaspace_lock);\n@@ -234,0 +248,3 @@\n+  \/\/ It is valid to poison the chunk payload area at this point since its physically separated from\n+  \/\/ the chunk meta info.\n+  ASAN_POISON_MEMORY_REGION(c->base(), c->word_size() * BytesPerWord);\n@@ -282,2 +299,14 @@\n-  MutexLocker fcl(Metaspace_lock, Mutex::_no_safepoint_check_flag);\n-  return c->vsnode()->attempt_enlarge_chunk(c, &_chunks);\n+  bool enlarged;\n+  size_t old_word_size;\n+\n+  {\n+    MutexLocker fcl(Metaspace_lock, Mutex::_no_safepoint_check_flag);\n+    old_word_size = c->word_size();\n+    enlarged = c->vsnode()->attempt_enlarge_chunk(c, &_chunks);\n+  }\n+\n+  if (enlarged) {\n+    ASAN_UNPOISON_MEMORY_REGION(c->base() + old_word_size, (c->word_size() - old_word_size) * BytesPerWord);\n+  }\n+\n+  return enlarged;\n","filename":"src\/hotspot\/share\/memory\/metaspace\/chunkManager.cpp","additions":37,"deletions":8,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -98,0 +98,2 @@\n+  Metachunk* get_chunk_locked(chunklevel_t preferred_level, chunklevel_t max_level, size_t min_committed_words);\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace\/chunkManager.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"sanitizers\/address.h\"\n@@ -237,0 +238,4 @@\n+\n+  \/\/ Poison the memory region. It will be unpoisoned later on a per-chunk base for chunks that are\n+  \/\/ handed to arenas.\n+  ASAN_POISON_MEMORY_REGION(rs.base(), rs.size());\n@@ -268,0 +273,4 @@\n+  \/\/ Undo the poisoning before potentially unmapping memory. This ensures that future mappings at\n+  \/\/ the same address do not unexpectedly fail with use-after-poison.\n+  ASAN_UNPOISON_MEMORY_REGION(_rs.base(), _rs.size());\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace\/virtualSpaceNode.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2023, Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SANITIZERS_ADDRESS_HPP\n+#define SHARE_SANITIZERS_ADDRESS_HPP\n+\n+#ifdef ADDRESS_SANITIZER\n+#include <sanitizer\/asan_interface.h>\n+#endif\n+\n+\/\/ ASAN_POISON_MEMORY_REGION()\/ASAN_UNPOISON_MEMORY_REGION()\n+\/\/\n+\/\/ Poisons\/unpoisons the specified memory region. When ASan is available this is the macro of the\n+\/\/ same name from <sanitizer\/asan_interface.h>. When ASan is not available this macro is a NOOP\n+\/\/ which preserves the arguments, ensuring they still compile, but ensures they are stripped due to\n+\/\/ being unreachable. This helps ensure developers do not accidently break ASan builds.\n+#ifdef ADDRESS_SANITIZER\n+\/\/ ASAN_POISON_MEMORY_REGION is defined in <sanitizer\/asan_interface.h>\n+\/\/ ASAN_UNPOISON_MEMORY_REGION is defined in <sanitizer\/asan_interface.h>\n+#else\n+#define ASAN_POISON_MEMORY_REGION(addr, size) \\\n+  do {                                        \\\n+    if (false) {                              \\\n+      ((void) (addr));                        \\\n+      ((void) (size));                        \\\n+    }                                         \\\n+  } while (false)\n+#define ASAN_UNPOISON_MEMORY_REGION(addr, size) \\\n+  do {                                          \\\n+    if (false) {                                \\\n+      ((void) (addr));                          \\\n+      ((void) (size));                          \\\n+    }                                           \\\n+  } while (false)\n+#endif\n+\n+#endif \/\/ SHARE_SANITIZERS_ADDRESS_HPP\n","filename":"src\/hotspot\/share\/sanitizers\/address.h","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"sanitizers\/address.h\"\n@@ -381,0 +382,1 @@\n+        ASAN_UNPOISON_MEMORY_REGION(c->base() + r.start(), r.size() * BytesPerWord);\n@@ -382,0 +384,1 @@\n+        ASAN_POISON_MEMORY_REGION(c->base() + r.start(), r.size() * BytesPerWord);\n@@ -513,0 +516,1 @@\n+  ASAN_UNPOISON_MEMORY_REGION(node->base(), node->word_size() * BytesPerWord);\n@@ -514,0 +518,1 @@\n+  ASAN_POISON_MEMORY_REGION(node->base(), node->word_size() * BytesPerWord);\n@@ -527,0 +532,1 @@\n+    ASAN_UNPOISON_MEMORY_REGION(node->base(), i * Settings::commit_granule_words() * BytesPerWord);\n@@ -528,0 +534,1 @@\n+    ASAN_POISON_MEMORY_REGION(node->base(), i * Settings::commit_granule_words() * BytesPerWord);\n@@ -534,1 +541,0 @@\n-\n","filename":"test\/hotspot\/gtest\/metaspace\/test_virtualspacenode.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"}]}