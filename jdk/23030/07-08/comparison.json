{"files":[{"patch":"@@ -3253,0 +3253,1 @@\n+    NOT_PRODUCT( if (is_trace_basic()) { tty->print_cr(\"[TraceMergeStores] Value is con: %ld\", con); })\n@@ -3265,6 +3266,2 @@\n-    if (_value_order == ValueOrder::Reverse) {\n-      swap(hi, lo);\n-    }\n-    Node const* hi_base;\n-    jint hi_shift;\n-    merged_input_value = lo;\n+    Node const* hi_base, *lo_base, *base;\n+    jint hi_shift, lo_shift;\n@@ -3273,1 +3270,20 @@\n-    if (merged_input_value != hi_base && merged_input_value->Opcode() == Op_ConvL2I) {\n+    is_true = is_con_RShift(lo, lo_base, lo_shift, _phase);\n+    assert(is_true, \"must detect con RShift\");\n+    if (lo_base != hi_base) {\n+      \/\/ different base\n+      NOT_PRODUCT( if (is_trace_basic()) { tty->print_cr(\"[TraceMergeStores] fail: Input values are based different\"); hi_base->dump(); lo_base->dump(); tty->cr(); })\n+      return nullptr;\n+    }\n+    if (_value_order == ValueOrder::Reverse) {\n+      \/\/ Pattern of Reverse order (LE)\n+      \/\/ a[0] = (byte)(vL >> 24)    <--  first, lo\n+      \/\/ a[1] = (byte)(vL >> 16)\n+      \/\/ a[2] = (byte)(vL >>  8)\n+      \/\/ a[3] = (byte)(vL >>  0)    <-- _store, hi\n+      merged_input_value = hi;\n+      base = hi_base;\n+    } else {\n+      merged_input_value = lo;\n+      base = lo_base;\n+    }\n+    if (merged_input_value != base && merged_input_value->Opcode() == Op_ConvL2I) {\n@@ -3277,4 +3293,0 @@\n-    if (merged_input_value != hi_base) {\n-      \/\/ merged_input_value is not the base\n-      return nullptr;\n-    }\n@@ -3308,0 +3320,1 @@\n+  NOT_PRODUCT( if (is_trace_basic()) { tty->print(\"[TraceMergeStores] Merged value:\"); merged_input_value->dump(); tty->cr(); })\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":24,"deletions":11,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1137,0 +1137,6 @@\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n@@ -1140,1 +1146,2 @@\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -1157,2 +1164,2 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\",\n-                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n@@ -1160,1 +1167,10 @@\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.REVERSE_BYTES_S, \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})  \/\/ Exclude RISCV64 because ReverseBytes are not supported\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -1826,0 +1842,6 @@\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n@@ -1829,1 +1851,2 @@\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -1854,0 +1877,6 @@\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n@@ -1857,1 +1886,2 @@\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -1948,2 +1978,2 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"7\",\n-                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n@@ -1952,1 +1982,1 @@\n-                  IRNode.REVERSE_BYTES_S, \"1\"},\n+                  IRNode.REVERSE_BYTES_S, \"4\"},\n@@ -1955,2 +1985,2 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"7\",\n-                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n@@ -1985,2 +2015,2 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"7\",\n-                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n@@ -1989,1 +2019,1 @@\n-                  IRNode.REVERSE_BYTES_S, \"1\"},\n+                  IRNode.REVERSE_BYTES_S, \"4\"},\n@@ -2159,0 +2189,6 @@\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\"})\n@@ -2162,1 +2198,2 @@\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatformAnd = {\"big-endian\", \"true\"})\n@@ -2167,5 +2204,5 @@\n-        a[offset + 0] = (byte)(v >> 0);  \/\/ Removed from candidate list\n-        a[offset + 1] = (byte)(v >> 8);  \/\/ Removed from candidate list\n-        a[offset + 2] = (byte)(v >> 16); \/\/ The 4 following stores are on the candidate list.\n-        a[offset + 3] = (byte)(v >> 24); \/\/ The current logic does not merge them\n-        a[offset + 4] = (byte)(v >> 32); \/\/ since it would require shifting the input.\n+        a[offset + 0] = (byte)(v >> 0);\n+        a[offset + 1] = (byte)(v >> 8);\n+        a[offset + 2] = (byte)(v >> 16);\n+        a[offset + 3] = (byte)(v >> 24);\n+        a[offset + 4] = (byte)(v >> 32);\n@@ -2188,2 +2225,2 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n-                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n@@ -2192,1 +2229,2 @@\n-                  IRNode.REVERSE_BYTES_I, \"1\"},\n+                  IRNode.REVERSE_BYTES_I, \"1\",\n+                  IRNode.REVERSE_BYTES_S, \"1\"},\n@@ -2195,2 +2233,2 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n-                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n@@ -2205,4 +2243,4 @@\n-        a[offset + 0] = (byte)(v >> 40); \/\/ Removed from candidate list\n-        a[offset + 1] = (byte)(v >> 32); \/\/ Removed from candidate list\n-        a[offset + 2] = (byte)(v >> 24); \/\/ The 4 following stores are on the candidate list\n-        a[offset + 3] = (byte)(v >> 16); \/\/ and they are successfully merged on big endian platforms.\n+        a[offset + 0] = (byte)(v >> 40);\n+        a[offset + 1] = (byte)(v >> 32);\n+        a[offset + 2] = (byte)(v >> 24);\n+        a[offset + 3] = (byte)(v >> 16);\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStores.java","additions":67,"deletions":29,"binary":false,"changes":96,"status":"modified"}]}