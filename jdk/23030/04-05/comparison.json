{"files":[{"patch":"@@ -2792,5 +2792,18 @@\n-  \/\/   Unknown  -> Forward\n-  \/\/   Unknown  -> Backward\n-  \/\/   Forward  -> Forward\n-  \/\/   Backward -> Backward\n-  enum ValueOrder : uint8_t { Unknown, Forward, Backward };\n+  \/\/   Unknown     -> Const\n+  \/\/   Unknown     -> Platform\n+  \/\/   Unknown     -> Reverse\n+  \/\/   Unknown     -> NotAdjacent\n+  \/\/   Const       -> Const\n+  \/\/   Const       -> NotAdjacent\n+  \/\/   Platform    -> Platform\n+  \/\/   Platform    -> NotAdjacent\n+  \/\/   Reverse     -> Reverse\n+  \/\/   Reverse     -> NotAdjacent\n+  \/\/   NotAdjacent -> NotAdjacent\n+  enum ValueOrder : uint8_t {\n+    Unknown,     \/\/ Initial state\n+    Const,       \/\/ Input values are const\n+    Platform,    \/\/ Platform order\n+    Reverse,     \/\/ Reverse platform order\n+    NotAdjacent  \/\/ Not adjacent\n+  };\n@@ -2811,2 +2824,2 @@\n-  bool is_adjacent_pair(const StoreNode* use_store, const StoreNode* def_store);\n-  bool is_adjacent_input_pair(const Node* n1, const Node* n2, const int memory_size);\n+  bool is_adjacent_pair(const StoreNode* use_store, const StoreNode* def_store) const;\n+  bool is_adjacent_input_pair(const Node* n1, const Node* n2, const int memory_size) const;\n@@ -2849,2 +2862,3 @@\n-  Status find_adjacent_use_store(const StoreNode* def_store);\n-  Status find_adjacent_def_store(const StoreNode* use_store);\n+  enum ValueOrder find_adjacent_input_value_order(const Node* n1, const Node* n2, const int memory_size) const;\n+  Status find_adjacent_use_store(const StoreNode* def_store) const;\n+  Status find_adjacent_def_store(const StoreNode* use_store) const;\n@@ -2856,1 +2870,1 @@\n-  void collect_merge_list(Node_List& merge_list);\n+  void collect_merge_list(Node_List& merge_list) const;\n@@ -2910,1 +2924,2 @@\n-  if (status_def.found_store() == nullptr) {\n+  Node* def_store = status_def.found_store();\n+  if (def_store == nullptr) {\n@@ -2914,0 +2929,6 @@\n+  \/\/ Initialize value order\n+  _value_order = find_adjacent_input_value_order(def_store->in(MemNode::ValueIn),\n+                                                 _store->in(MemNode::ValueIn),\n+                                                 _store->memory_size());\n+  assert(_value_order != ValueOrder::NotAdjacent && _value_order != ValueOrder::Unknown, \"Order should be checked\");\n+\n@@ -2941,1 +2962,1 @@\n-bool MergePrimitiveStores::is_adjacent_pair(const StoreNode* use_store, const StoreNode* def_store) {\n+bool MergePrimitiveStores::is_adjacent_pair(const StoreNode* use_store, const StoreNode* def_store) const {\n@@ -2959,1 +2980,3 @@\n-bool MergePrimitiveStores::is_adjacent_input_pair(const Node* n1, const Node* n2, const int memory_size) {\n+\/\/ Check input values n1 and n2 can be merged and return the value order\n+MergePrimitiveStores::ValueOrder MergePrimitiveStores::find_adjacent_input_value_order(const Node* n1, const Node* n2,\n+                                                                                       const int memory_size) const {\n@@ -2961,2 +2984,2 @@\n-  if (n1->Opcode() == Op_ConI) {\n-    return n2->Opcode() == Op_ConI;\n+  if (n1->Opcode() == Op_ConI && n2->Opcode() == Op_ConI) {\n+    return ValueOrder::Const;\n@@ -2965,7 +2988,1 @@\n-  \/\/ Pattern: [n1 = base >> shift, n2 = base >> (shift + memory_size)]\n-#ifndef VM_LITTLE_ENDIAN\n-  \/\/ Pattern: [n1 = base >> (shift + memory_size), n2 = base >> shift]\n-  \/\/ Swapping n1 with n2 gives same pattern as on little endian platforms.\n-  swap(n1, n2);\n-#endif \/\/ !VM_LITTLE_ENDIAN\n-  Node const* base_n2;\n+  Node const *base_n2;\n@@ -2974,5 +2991,1 @@\n-    return false;\n-  }\n-  if (n1->Opcode() == Op_ConvL2I) {\n-    \/\/ look through\n-    n1 = n1->in(1);\n+    return ValueOrder::NotAdjacent;\n@@ -2980,1 +2993,1 @@\n-  Node const* base_n1;\n+  Node const *base_n1;\n@@ -2982,6 +2995,2 @@\n-  if (n1 == base_n2) {\n-    \/\/ n1 = base = base >> 0\n-    base_n1 = n1;\n-    shift_n1 = 0;\n-  } else if (!is_con_RShift(n1, base_n1, shift_n1, _phase)) {\n-    return false;\n+  if (!is_con_RShift(n1, base_n1, shift_n1, _phase)) {\n+    return ValueOrder::NotAdjacent;\n@@ -2989,0 +2998,1 @@\n+\n@@ -2993,1 +3003,2 @@\n-    return false;\n+    \/\/ Values are not adjacent\n+    return ValueOrder::NotAdjacent;\n@@ -2996,4 +3007,1 @@\n-  \/\/ Initial state \"Unknown\": check for transition to Forward or Backward.\n-  if (_value_order == ValueOrder::Unknown) {\n-    if (shift_n1 < shift_n2) {\n-      _value_order = ValueOrder::Forward; \/\/ First pair has Forward order\n+  \/\/ Detect value order\n@@ -3001,4 +3009,5 @@\n-    } else if (memory_size == 1 &&\n-               Matcher::match_rule_supported(Op_ReverseBytesI) &&\n-               Matcher::match_rule_supported(Op_ReverseBytesL)) {\n-      _value_order = ValueOrder::Backward;  \/\/ only support reverse bytes\n+  return shift_n1 < shift_n2 ? ValueOrder::Platform     \/\/ Pattern: [n1 = base >> shift, n2 = base >> (shift + memory_size)]\n+                             : ValueOrder::Reverse;     \/\/ Pattern: [n1 = base >> (shift + memory_size), n2 = base >> shift]\n+#else\n+  return shift_n1 > shift_n2 ? ValueOrder::Platform     \/\/ Pattern: [n1 = base >> (shift + memory_size), n2 = base >> shift]\n+                             : ValueOrder::NotAdjacent; \/\/ TODO: Reverse order in BE machine not tested\n@@ -3006,3 +3015,7 @@\n-    } else {\n-      return false;\n-    }\n+}\n+\n+bool MergePrimitiveStores::is_adjacent_input_pair(const Node* n1, const Node* n2, const int memory_size) const {\n+  ValueOrder input_value_order = find_adjacent_input_value_order(n1, n2, memory_size);\n+\n+  if (input_value_order == ValueOrder::NotAdjacent) {\n+    return false;\n@@ -3011,3 +3024,7 @@\n-  if ((_value_order == ValueOrder::Forward  && shift_n1 > shift_n2) ||\n-      (_value_order == ValueOrder::Backward && shift_n1 < shift_n2)) {\n-    \/\/ Wrong order: mixed Forward and Backward not allowed.\n+  if (input_value_order == ValueOrder::Reverse &&\n+      (memory_size != 1 ||\n+       !Matcher::match_rule_supported(Op_ReverseBytesI) ||\n+       !Matcher::match_rule_supported(Op_ReverseBytesL) ||\n+       !Matcher::match_rule_supported(Op_ReverseBytesS)\n+      )) {\n+    \/\/ ReverseBytes are not supported by platform\n@@ -3017,2 +3034,7 @@\n-  \/\/ both load from same value with correct shift\n-  return true;\n+  if (_value_order == ValueOrder::Unknown) {\n+    \/\/ Initial state is Unknown, and we find a valid input value order\n+    return true;\n+  }\n+\n+  \/\/ The value order can not be changed\n+  return _value_order == input_value_order;\n@@ -3044,0 +3066,1 @@\n+    \/\/ (base >> 0)\n@@ -3097,1 +3120,1 @@\n-MergePrimitiveStores::Status MergePrimitiveStores::find_adjacent_use_store(const StoreNode* def_store) {\n+MergePrimitiveStores::Status MergePrimitiveStores::find_adjacent_use_store(const StoreNode* def_store) const {\n@@ -3106,1 +3129,1 @@\n-MergePrimitiveStores::Status MergePrimitiveStores::find_adjacent_def_store(const StoreNode* use_store) {\n+MergePrimitiveStores::Status MergePrimitiveStores::find_adjacent_def_store(const StoreNode* use_store) const {\n@@ -3171,1 +3194,1 @@\n-void MergePrimitiveStores::collect_merge_list(Node_List& merge_list) {\n+void MergePrimitiveStores::collect_merge_list(Node_List& merge_list) const {\n@@ -3214,0 +3237,1 @@\n+    assert(_value_order == ValueOrder::Const, \"must match\");\n@@ -3230,0 +3254,1 @@\n+    assert(_value_order == ValueOrder::Platform || _value_order == ValueOrder::Reverse, \"must match\");\n@@ -3241,1 +3266,1 @@\n-    if (_value_order == ValueOrder::Backward) {\n+    if (_value_order == ValueOrder::Reverse) {\n@@ -3273,1 +3298,1 @@\n-  if (_value_order == ValueOrder::Backward) {\n+  if (_value_order == ValueOrder::Reverse) {\n@@ -3280,1 +3305,2 @@\n-      return nullptr;\n+      assert(new_memory_size == 2, \"sanity check\");\n+      merged_input_value = _phase->transform(new ReverseBytesSNode(merged_input_value));\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":83,"deletions":57,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -800,1 +800,4 @@\n-    @IR(counts = { IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+    @IR(counts = { IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                   IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                   IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                   IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n@@ -803,1 +806,1 @@\n-        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISV64 because ReverseBytesI\/L are not supported\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISCV64 because ReverseBytes are not supported\n@@ -830,1 +833,4 @@\n-    @IR(counts = { IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+    @IR(counts = { IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                   IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                   IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                   IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n@@ -833,1 +839,1 @@\n-        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISV64 because ReverseBytesI\/L are not supported\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISCV64 because ReverseBytes are not supported\n@@ -874,1 +880,4 @@\n-    @IR(counts = {IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\"},\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n@@ -876,1 +885,1 @@\n-        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISV64 because ReverseBytesI\/L are not supported\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n@@ -908,1 +917,4 @@\n-    @IR(counts = {IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n@@ -911,1 +923,1 @@\n-        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISV64 because ReverseBytesI\/L are not supported\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISCV64 because ReverseBytes are not supported\n@@ -1006,3 +1018,3 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n-                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",  \/\/ Stores of constants can be merged\n-                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",  \/\/ Unmerged stores: offset + (2,3,16) , and 1 for uncommon trap\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\",  \/\/ 1([+0,+1]) for platform order and 2([+4,+5], [+14,+15]) for reverse order\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",  \/\/ 1([+6,+9]) for platform order and 1([+10,+13]) for reverse order  \n@@ -1010,1 +1022,2 @@\n-                  IRNode.REVERSE_BYTES_I, \"1\"},\n+                  IRNode.REVERSE_BYTES_I, \"1\",\n+                  IRNode.REVERSE_BYTES_S, \"2\"},\n@@ -1012,1 +1025,1 @@\n-        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISV64 because ReverseBytesI\/L are not supported\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISCV64 because ReverseBytes are not supported\n@@ -1904,1 +1917,1 @@\n-        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISV64 because ReverseBytesI\/L are not supported\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISCV64 because ReverseBytes are not supported\n@@ -1935,2 +1948,2 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n-                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"7\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n@@ -1938,2 +1951,4 @@\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n-        applyIfPlatform = {\"little-endian\", \"true\"})\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.REVERSE_BYTES_S, \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISCV64 because ReverseBytes are not supported\n@@ -1970,2 +1985,2 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n-                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"7\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n@@ -1973,2 +1988,4 @@\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n-        applyIfPlatform = {\"little-endian\", \"true\"})\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.REVERSE_BYTES_S, \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISCV64 because ReverseBytes are not supported\n@@ -2177,1 +2194,1 @@\n-        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISV64 because ReverseBytesI\/L are not supported\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISCV64 because ReverseBytesI\/L are not supported\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStores.java","additions":40,"deletions":23,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -1468,0 +1468,10 @@\n+    public static final String REVERSE_BYTES_S = PREFIX + \"REVERSE_BYTES_S\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REVERSE_BYTES_S, \"ReverseBytesS\");\n+    }\n+\n+    public static final String REVERSE_BYTES_US = PREFIX + \"REVERSE_BYTES_US\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REVERSE_BYTES_US, \"ReverseBytesUS\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}