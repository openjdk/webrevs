{"files":[{"patch":"@@ -2790,0 +2790,21 @@\n+  \/\/ State machine with initial state Unknown\n+  \/\/ Allowed transitions:\n+  \/\/   Unknown     -> Const\n+  \/\/   Unknown     -> Platform\n+  \/\/   Unknown     -> Reverse\n+  \/\/   Unknown     -> NotAdjacent\n+  \/\/   Const       -> Const\n+  \/\/   Const       -> NotAdjacent\n+  \/\/   Platform    -> Platform\n+  \/\/   Platform    -> NotAdjacent\n+  \/\/   Reverse     -> Reverse\n+  \/\/   Reverse     -> NotAdjacent\n+  \/\/   NotAdjacent -> NotAdjacent\n+  enum ValueOrder : uint8_t {\n+    Unknown,     \/\/ Initial state\n+    Const,       \/\/ Input values are const\n+    Platform,    \/\/ Platform order\n+    Reverse,     \/\/ Reverse platform order\n+    NotAdjacent  \/\/ Not adjacent\n+  };\n+  ValueOrder  _value_order;\n@@ -2795,1 +2816,1 @@\n-    _phase(phase), _store(store)\n+    _phase(phase), _store(store), _value_order(ValueOrder::Unknown)\n@@ -2805,1 +2826,1 @@\n-  static bool is_con_RShift(const Node* n, Node const*& base_out, jint& shift_out);\n+  static bool is_con_RShift(const Node* n, Node const*& base_out, jint& shift_out, PhaseGVN* phase);\n@@ -2841,0 +2862,1 @@\n+  enum ValueOrder find_adjacent_input_value_order(const Node* n1, const Node* n2, const int memory_size) const;\n@@ -2902,1 +2924,2 @@\n-  if (status_def.found_store() == nullptr) {\n+  Node* def_store = status_def.found_store();\n+  if (def_store == nullptr) {\n@@ -2906,0 +2929,6 @@\n+  \/\/ Initialize value order\n+  _value_order = find_adjacent_input_value_order(def_store->in(MemNode::ValueIn),\n+                                                 _store->in(MemNode::ValueIn),\n+                                                 _store->memory_size());\n+  assert(_value_order != ValueOrder::NotAdjacent && _value_order != ValueOrder::Unknown, \"Order should be checked\");\n+\n@@ -2951,1 +2980,3 @@\n-bool MergePrimitiveStores::is_adjacent_input_pair(const Node* n1, const Node* n2, const int memory_size) const {\n+\/\/ Check input values n1 and n2 can be merged and return the value order\n+MergePrimitiveStores::ValueOrder MergePrimitiveStores::find_adjacent_input_value_order(const Node* n1, const Node* n2,\n+                                                                                       const int memory_size) const {\n@@ -2953,2 +2984,2 @@\n-  if (n1->Opcode() == Op_ConI) {\n-    return n2->Opcode() == Op_ConI;\n+  if (n1->Opcode() == Op_ConI && n2->Opcode() == Op_ConI) {\n+    return ValueOrder::Const;\n@@ -2957,7 +2988,1 @@\n-  \/\/ Pattern: [n1 = base >> shift, n2 = base >> (shift + memory_size)]\n-#ifndef VM_LITTLE_ENDIAN\n-  \/\/ Pattern: [n1 = base >> (shift + memory_size), n2 = base >> shift]\n-  \/\/ Swapping n1 with n2 gives same pattern as on little endian platforms.\n-  swap(n1, n2);\n-#endif \/\/ !VM_LITTLE_ENDIAN\n-  Node const* base_n2;\n+  Node const *base_n2;\n@@ -2965,6 +2990,2 @@\n-  if (!is_con_RShift(n2, base_n2, shift_n2)) {\n-    return false;\n-  }\n-  if (n1->Opcode() == Op_ConvL2I) {\n-    \/\/ look through\n-    n1 = n1->in(1);\n+  if (!is_con_RShift(n2, base_n2, shift_n2, _phase)) {\n+    return ValueOrder::NotAdjacent;\n@@ -2972,1 +2993,1 @@\n-  Node const* base_n1;\n+  Node const *base_n1;\n@@ -2974,6 +2995,2 @@\n-  if (n1 == base_n2) {\n-    \/\/ n1 = base = base >> 0\n-    base_n1 = n1;\n-    shift_n1 = 0;\n-  } else if (!is_con_RShift(n1, base_n1, shift_n1)) {\n-    return false;\n+  if (!is_con_RShift(n1, base_n1, shift_n1, _phase)) {\n+    return ValueOrder::NotAdjacent;\n@@ -2981,0 +2998,1 @@\n+\n@@ -2983,1 +3001,1 @@\n-      shift_n1 + bits_per_store != shift_n2 ||\n+      abs(shift_n1 - shift_n2) != bits_per_store ||\n@@ -2985,0 +3003,18 @@\n+    \/\/ Values are not adjacent\n+    return ValueOrder::NotAdjacent;\n+  }\n+\n+  \/\/ Detect value order\n+#ifdef VM_LITTLE_ENDIAN\n+  return shift_n1 < shift_n2 ? ValueOrder::Platform     \/\/ Pattern: [n1 = base >> shift, n2 = base >> (shift + memory_size)]\n+                             : ValueOrder::Reverse;     \/\/ Pattern: [n1 = base >> (shift + memory_size), n2 = base >> shift]\n+#else\n+  return shift_n1 > shift_n2 ? ValueOrder::Platform     \/\/ Pattern: [n1 = base >> (shift + memory_size), n2 = base >> shift]\n+                             : ValueOrder::NotAdjacent; \/\/ TODO: Reverse order in BE machine not tested\n+#endif\n+}\n+\n+bool MergePrimitiveStores::is_adjacent_input_pair(const Node* n1, const Node* n2, const int memory_size) const {\n+  ValueOrder input_value_order = find_adjacent_input_value_order(n1, n2, memory_size);\n+\n+  if (input_value_order == ValueOrder::NotAdjacent) {\n@@ -2988,2 +3024,17 @@\n-  \/\/ both load from same value with correct shift\n-  return true;\n+  if (input_value_order == ValueOrder::Reverse &&\n+      (memory_size != 1 ||\n+       !Matcher::match_rule_supported(Op_ReverseBytesI) ||\n+       !Matcher::match_rule_supported(Op_ReverseBytesL) ||\n+       !Matcher::match_rule_supported(Op_ReverseBytesS)\n+      )) {\n+    \/\/ ReverseBytes are not supported by platform\n+    return false;\n+  }\n+\n+  if (_value_order == ValueOrder::Unknown) {\n+    \/\/ Initial state is Unknown, and we find a valid input value order\n+    return true;\n+  }\n+\n+  \/\/ The value order can not be changed\n+  return _value_order == input_value_order;\n@@ -2993,1 +3044,1 @@\n-bool MergePrimitiveStores::is_con_RShift(const Node* n, Node const*& base_out, jint& shift_out) {\n+bool MergePrimitiveStores::is_con_RShift(const Node* n, Node const*& base_out, jint& shift_out, PhaseGVN* phase) {\n@@ -3012,0 +3063,8 @@\n+\n+  if (phase->type(n)->isa_int()  != nullptr ||\n+      phase->type(n)->isa_long() != nullptr) {\n+    \/\/ (base >> 0)\n+    base_out = n;\n+    shift_out = 0;\n+    return true;\n+  }\n@@ -3178,0 +3237,1 @@\n+    assert(_value_order == ValueOrder::Const, \"must match\");\n@@ -3193,0 +3253,1 @@\n+    NOT_PRODUCT( if (is_trace_basic()) { tty->print_cr(\"[TraceMergeStores] Value is con: %ld\", con); })\n@@ -3194,0 +3255,1 @@\n+    assert(_value_order == ValueOrder::Platform || _value_order == ValueOrder::Reverse, \"must match\");\n@@ -3204,4 +3266,5 @@\n-    Node const* hi_base;\n-    jint hi_shift;\n-    merged_input_value = lo;\n-    bool is_true = is_con_RShift(hi, hi_base, hi_shift);\n+    Node const* hi_base, *lo_base, *base;\n+    jint hi_shift, lo_shift;\n+    bool is_true = is_con_RShift(hi, hi_base, hi_shift, _phase);\n+    assert(is_true, \"must detect con RShift\");\n+    is_true = is_con_RShift(lo, lo_base, lo_shift, _phase);\n@@ -3209,1 +3272,18 @@\n-    if (merged_input_value != hi_base && merged_input_value->Opcode() == Op_ConvL2I) {\n+    if (lo_base != hi_base) {\n+      \/\/ different base\n+      NOT_PRODUCT( if (is_trace_basic()) { tty->print_cr(\"[TraceMergeStores] fail: Input values are based different\"); hi_base->dump(); lo_base->dump(); tty->cr(); })\n+      return nullptr;\n+    }\n+    if (_value_order == ValueOrder::Reverse) {\n+      \/\/ Pattern of Reverse order (LE)\n+      \/\/ a[0] = (byte)(vL >> 24)    <--  first, lo\n+      \/\/ a[1] = (byte)(vL >> 16)\n+      \/\/ a[2] = (byte)(vL >>  8)\n+      \/\/ a[3] = (byte)(vL >>  0)    <-- _store, hi\n+      merged_input_value = hi;\n+      base = hi_base;\n+    } else {\n+      merged_input_value = lo;\n+      base = lo_base;\n+    }\n+    if (merged_input_value != base && merged_input_value->Opcode() == Op_ConvL2I) {\n@@ -3213,4 +3293,0 @@\n-    if (merged_input_value != hi_base) {\n-      \/\/ merged_input_value is not the base\n-      return nullptr;\n-    }\n@@ -3233,0 +3309,12 @@\n+  if (_value_order == ValueOrder::Reverse) {\n+    assert(_store->memory_size() == 1, \"only implemented for bytes\");\n+    if (new_memory_size == 8) {\n+      merged_input_value = _phase->transform(new ReverseBytesLNode(merged_input_value));\n+    } else if (new_memory_size == 4) {\n+      merged_input_value = _phase->transform(new ReverseBytesINode(merged_input_value));\n+    } else {\n+      assert(new_memory_size == 2, \"sanity check\");\n+      merged_input_value = _phase->transform(new ReverseBytesSNode(merged_input_value));\n+    }\n+  }\n+  NOT_PRODUCT( if (is_trace_basic()) { tty->print(\"[TraceMergeStores] Merged value:\"); merged_input_value->dump(); tty->cr(); })\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":127,"deletions":39,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -800,5 +800,7 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n-                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n-                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n-        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = { IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                   IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                   IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                   IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                   IRNode.REVERSE_BYTES_L, \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISCV64 because ReverseBytes are not supported\n@@ -831,5 +833,7 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n-                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n-                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n-        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = { IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                   IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                   IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                   IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                   IRNode.REVERSE_BYTES_L, \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISCV64 because ReverseBytes are not supported\n@@ -876,1 +880,4 @@\n-    @IR(counts = {IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\"},\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n@@ -910,1 +917,1 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n@@ -912,3 +919,5 @@\n-                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n-        applyIfPlatform = {\"little-endian\", \"true\"})\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.REVERSE_BYTES_I, \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISCV64 because ReverseBytes are not supported\n@@ -1009,4 +1018,6 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"12\",\n-                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",  \/\/ Stores of constants can be merged\n-                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",  \/\/ Unmerged stores: offset + (2,3,16) , and 1 for uncommon trap\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\",  \/\/ 1([+0,+1]) for platform order and 2([+4,+5], [+14,+15]) for reverse order\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",  \/\/ 1([+6,+9]) for platform order and 1([+10,+13]) for reverse order\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.REVERSE_BYTES_I, \"1\",\n+                  IRNode.REVERSE_BYTES_S, \"2\"},\n@@ -1014,1 +1025,1 @@\n-        applyIfPlatform = {\"little-endian\", \"true\"})\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISCV64 because ReverseBytes are not supported\n@@ -1126,0 +1137,6 @@\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n@@ -1129,1 +1146,2 @@\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -1146,2 +1164,2 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\",\n-                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n@@ -1149,1 +1167,10 @@\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.REVERSE_BYTES_S, \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})  \/\/ Exclude RISCV64 because ReverseBytes are not supported\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -1815,0 +1842,6 @@\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n@@ -1818,1 +1851,2 @@\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -1843,0 +1877,6 @@\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n@@ -1846,1 +1886,2 @@\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -1900,1 +1941,1 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\", \/\/ for RangeCheck trap\n@@ -1903,2 +1944,4 @@\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n-        applyIfPlatform = {\"little-endian\", \"true\"})\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\", \/\/ expect merged\n+                  IRNode.REVERSE_BYTES_L, \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISCV64 because ReverseBytes are not supported\n@@ -1935,2 +1978,2 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n-                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n@@ -1938,4 +1981,6 @@\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n-        applyIfPlatform = {\"little-endian\", \"true\"})\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"7\",\n-                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.REVERSE_BYTES_S, \"4\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISCV64 because ReverseBytes are not supported\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n@@ -1970,2 +2015,2 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n-                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n@@ -1973,2 +2018,4 @@\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n-        applyIfPlatform = {\"little-endian\", \"true\"})\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.REVERSE_BYTES_S, \"4\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISCV64 because ReverseBytes are not supported\n@@ -2142,0 +2189,6 @@\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\"})\n@@ -2145,1 +2198,2 @@\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatformAnd = {\"big-endian\", \"true\"})\n@@ -2150,5 +2204,5 @@\n-        a[offset + 0] = (byte)(v >> 0);  \/\/ Removed from candidate list\n-        a[offset + 1] = (byte)(v >> 8);  \/\/ Removed from candidate list\n-        a[offset + 2] = (byte)(v >> 16); \/\/ The 4 following stores are on the candidate list.\n-        a[offset + 3] = (byte)(v >> 24); \/\/ The current logic does not merge them\n-        a[offset + 4] = (byte)(v >> 32); \/\/ since it would require shifting the input.\n+        a[offset + 0] = (byte)(v >> 0);\n+        a[offset + 1] = (byte)(v >> 8);\n+        a[offset + 2] = (byte)(v >> 16);\n+        a[offset + 3] = (byte)(v >> 24);\n+        a[offset + 4] = (byte)(v >> 32);\n@@ -2171,7 +2225,10 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"6\",\n-                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n-                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n-        applyIfPlatform = {\"little-endian\", \"true\"})\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n-                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.REVERSE_BYTES_I, \"1\",\n+                  IRNode.REVERSE_BYTES_S, \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISCV64 because ReverseBytesI\/L are not supported\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n@@ -2186,4 +2243,4 @@\n-        a[offset + 0] = (byte)(v >> 40); \/\/ Removed from candidate list\n-        a[offset + 1] = (byte)(v >> 32); \/\/ Removed from candidate list\n-        a[offset + 2] = (byte)(v >> 24); \/\/ The 4 following stores are on the candidate list\n-        a[offset + 3] = (byte)(v >> 16); \/\/ and they are successfully merged on big endian platforms.\n+        a[offset + 0] = (byte)(v >> 40);\n+        a[offset + 1] = (byte)(v >> 32);\n+        a[offset + 2] = (byte)(v >> 24);\n+        a[offset + 3] = (byte)(v >> 16);\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStores.java","additions":113,"deletions":56,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -1458,0 +1458,20 @@\n+    public static final String REVERSE_BYTES_I = PREFIX + \"REVERSE_BYTES_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REVERSE_BYTES_I, \"ReverseBytesI\");\n+    }\n+\n+    public static final String REVERSE_BYTES_L = PREFIX + \"REVERSE_BYTES_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REVERSE_BYTES_L, \"ReverseBytesL\");\n+    }\n+\n+    public static final String REVERSE_BYTES_S = PREFIX + \"REVERSE_BYTES_S\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REVERSE_BYTES_S, \"ReverseBytesS\");\n+    }\n+\n+    public static final String REVERSE_BYTES_US = PREFIX + \"REVERSE_BYTES_US\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REVERSE_BYTES_US, \"ReverseBytesUS\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"}]}