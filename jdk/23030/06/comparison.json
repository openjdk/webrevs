{"files":[{"patch":"@@ -2790,0 +2790,21 @@\n+  \/\/ State machine with initial state Unknown\n+  \/\/ Allowed transitions:\n+  \/\/   Unknown     -> Const\n+  \/\/   Unknown     -> Platform\n+  \/\/   Unknown     -> Reverse\n+  \/\/   Unknown     -> NotAdjacent\n+  \/\/   Const       -> Const\n+  \/\/   Const       -> NotAdjacent\n+  \/\/   Platform    -> Platform\n+  \/\/   Platform    -> NotAdjacent\n+  \/\/   Reverse     -> Reverse\n+  \/\/   Reverse     -> NotAdjacent\n+  \/\/   NotAdjacent -> NotAdjacent\n+  enum ValueOrder : uint8_t {\n+    Unknown,     \/\/ Initial state\n+    Const,       \/\/ Input values are const\n+    Platform,    \/\/ Platform order\n+    Reverse,     \/\/ Reverse platform order\n+    NotAdjacent  \/\/ Not adjacent\n+  };\n+  ValueOrder  _value_order;\n@@ -2795,1 +2816,1 @@\n-    _phase(phase), _store(store)\n+    _phase(phase), _store(store), _value_order(ValueOrder::Unknown)\n@@ -2805,1 +2826,1 @@\n-  static bool is_con_RShift(const Node* n, Node const*& base_out, jint& shift_out);\n+  static bool is_con_RShift(const Node* n, Node const*& base_out, jint& shift_out, PhaseGVN* phase);\n@@ -2841,0 +2862,1 @@\n+  enum ValueOrder find_adjacent_input_value_order(const Node* n1, const Node* n2, const int memory_size) const;\n@@ -2902,1 +2924,2 @@\n-  if (status_def.found_store() == nullptr) {\n+  Node* def_store = status_def.found_store();\n+  if (def_store == nullptr) {\n@@ -2906,0 +2929,6 @@\n+  \/\/ Initialize value order\n+  _value_order = find_adjacent_input_value_order(def_store->in(MemNode::ValueIn),\n+                                                 _store->in(MemNode::ValueIn),\n+                                                 _store->memory_size());\n+  assert(_value_order != ValueOrder::NotAdjacent && _value_order != ValueOrder::Unknown, \"Order should be checked\");\n+\n@@ -2951,1 +2980,3 @@\n-bool MergePrimitiveStores::is_adjacent_input_pair(const Node* n1, const Node* n2, const int memory_size) const {\n+\/\/ Check input values n1 and n2 can be merged and return the value order\n+MergePrimitiveStores::ValueOrder MergePrimitiveStores::find_adjacent_input_value_order(const Node* n1, const Node* n2,\n+                                                                                       const int memory_size) const {\n@@ -2953,2 +2984,2 @@\n-  if (n1->Opcode() == Op_ConI) {\n-    return n2->Opcode() == Op_ConI;\n+  if (n1->Opcode() == Op_ConI && n2->Opcode() == Op_ConI) {\n+    return ValueOrder::Const;\n@@ -2957,7 +2988,1 @@\n-  \/\/ Pattern: [n1 = base >> shift, n2 = base >> (shift + memory_size)]\n-#ifndef VM_LITTLE_ENDIAN\n-  \/\/ Pattern: [n1 = base >> (shift + memory_size), n2 = base >> shift]\n-  \/\/ Swapping n1 with n2 gives same pattern as on little endian platforms.\n-  swap(n1, n2);\n-#endif \/\/ !VM_LITTLE_ENDIAN\n-  Node const* base_n2;\n+  Node const *base_n2;\n@@ -2965,2 +2990,2 @@\n-  if (!is_con_RShift(n2, base_n2, shift_n2)) {\n-    return false;\n+  if (!is_con_RShift(n2, base_n2, shift_n2, _phase)) {\n+    return ValueOrder::NotAdjacent;\n@@ -2968,5 +2993,1 @@\n-  if (n1->Opcode() == Op_ConvL2I) {\n-    \/\/ look through\n-    n1 = n1->in(1);\n-  }\n-  Node const* base_n1;\n+  Node const *base_n1;\n@@ -2974,6 +2995,2 @@\n-  if (n1 == base_n2) {\n-    \/\/ n1 = base = base >> 0\n-    base_n1 = n1;\n-    shift_n1 = 0;\n-  } else if (!is_con_RShift(n1, base_n1, shift_n1)) {\n-    return false;\n+  if (!is_con_RShift(n1, base_n1, shift_n1, _phase)) {\n+    return ValueOrder::NotAdjacent;\n@@ -2981,0 +2998,1 @@\n+\n@@ -2983,1 +3001,1 @@\n-      shift_n1 + bits_per_store != shift_n2 ||\n+      abs(shift_n1 - shift_n2) != bits_per_store ||\n@@ -2985,0 +3003,18 @@\n+    \/\/ Values are not adjacent\n+    return ValueOrder::NotAdjacent;\n+  }\n+\n+  \/\/ Detect value order\n+#ifdef VM_LITTLE_ENDIAN\n+  return shift_n1 < shift_n2 ? ValueOrder::Platform     \/\/ Pattern: [n1 = base >> shift, n2 = base >> (shift + memory_size)]\n+                             : ValueOrder::Reverse;     \/\/ Pattern: [n1 = base >> (shift + memory_size), n2 = base >> shift]\n+#else\n+  return shift_n1 > shift_n2 ? ValueOrder::Platform     \/\/ Pattern: [n1 = base >> (shift + memory_size), n2 = base >> shift]\n+                             : ValueOrder::NotAdjacent; \/\/ TODO: Reverse order in BE machine not tested\n+#endif\n+}\n+\n+bool MergePrimitiveStores::is_adjacent_input_pair(const Node* n1, const Node* n2, const int memory_size) const {\n+  ValueOrder input_value_order = find_adjacent_input_value_order(n1, n2, memory_size);\n+\n+  if (input_value_order == ValueOrder::NotAdjacent) {\n@@ -2988,2 +3024,17 @@\n-  \/\/ both load from same value with correct shift\n-  return true;\n+  if (input_value_order == ValueOrder::Reverse &&\n+      (memory_size != 1 ||\n+       !Matcher::match_rule_supported(Op_ReverseBytesI) ||\n+       !Matcher::match_rule_supported(Op_ReverseBytesL) ||\n+       !Matcher::match_rule_supported(Op_ReverseBytesS)\n+      )) {\n+    \/\/ ReverseBytes are not supported by platform\n+    return false;\n+  }\n+\n+  if (_value_order == ValueOrder::Unknown) {\n+    \/\/ Initial state is Unknown, and we find a valid input value order\n+    return true;\n+  }\n+\n+  \/\/ The value order can not be changed\n+  return _value_order == input_value_order;\n@@ -2993,1 +3044,1 @@\n-bool MergePrimitiveStores::is_con_RShift(const Node* n, Node const*& base_out, jint& shift_out) {\n+bool MergePrimitiveStores::is_con_RShift(const Node* n, Node const*& base_out, jint& shift_out, PhaseGVN* phase) {\n@@ -3012,0 +3063,8 @@\n+\n+  if (phase->type(n)->isa_int()  != nullptr ||\n+      phase->type(n)->isa_long() != nullptr) {\n+    \/\/ (base >> 0)\n+    base_out = n;\n+    shift_out = 0;\n+    return true;\n+  }\n@@ -3178,0 +3237,1 @@\n+    assert(_value_order == ValueOrder::Const, \"must match\");\n@@ -3194,0 +3254,1 @@\n+    assert(_value_order == ValueOrder::Platform || _value_order == ValueOrder::Reverse, \"must match\");\n@@ -3198,0 +3259,1 @@\n+    assert(_value_order != ValueOrder::Unknown, \"sanity\");\n@@ -3204,0 +3266,3 @@\n+    if (_value_order == ValueOrder::Reverse) {\n+      swap(hi, lo);\n+    }\n@@ -3207,1 +3272,1 @@\n-    bool is_true = is_con_RShift(hi, hi_base, hi_shift);\n+    bool is_true = is_con_RShift(hi, hi_base, hi_shift, _phase);\n@@ -3233,0 +3298,11 @@\n+  if (_value_order == ValueOrder::Reverse) {\n+    assert(_store->memory_size() == 1, \"only implemented for bytes\");\n+    if (new_memory_size == 8) {\n+      merged_input_value = _phase->transform(new ReverseBytesLNode(merged_input_value));\n+    } else if (new_memory_size == 4) {\n+      merged_input_value = _phase->transform(new ReverseBytesINode(merged_input_value));\n+    } else {\n+      assert(new_memory_size == 2, \"sanity check\");\n+      merged_input_value = _phase->transform(new ReverseBytesSNode(merged_input_value));\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":107,"deletions":31,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -800,5 +800,7 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n-                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n-                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n-        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = { IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                   IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                   IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                   IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                   IRNode.REVERSE_BYTES_L, \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISCV64 because ReverseBytes are not supported\n@@ -831,5 +833,7 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n-                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n-                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n-        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = { IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                   IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                   IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                   IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                   IRNode.REVERSE_BYTES_L, \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISCV64 because ReverseBytes are not supported\n@@ -876,1 +880,4 @@\n-    @IR(counts = {IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\"},\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n@@ -910,1 +917,1 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n@@ -912,3 +919,5 @@\n-                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n-        applyIfPlatform = {\"little-endian\", \"true\"})\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.REVERSE_BYTES_I, \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISCV64 because ReverseBytes are not supported\n@@ -1009,4 +1018,6 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"12\",\n-                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",  \/\/ Stores of constants can be merged\n-                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",  \/\/ Unmerged stores: offset + (2,3,16) , and 1 for uncommon trap\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\",  \/\/ 1([+0,+1]) for platform order and 2([+4,+5], [+14,+15]) for reverse order\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",  \/\/ 1([+6,+9]) for platform order and 1([+10,+13]) for reverse order\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.REVERSE_BYTES_I, \"1\",\n+                  IRNode.REVERSE_BYTES_S, \"2\"},\n@@ -1014,1 +1025,1 @@\n-        applyIfPlatform = {\"little-endian\", \"true\"})\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISCV64 because ReverseBytes are not supported\n@@ -1900,1 +1911,1 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\", \/\/ for RangeCheck trap\n@@ -1903,2 +1914,4 @@\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n-        applyIfPlatform = {\"little-endian\", \"true\"})\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\", \/\/ expect merged\n+                  IRNode.REVERSE_BYTES_L, \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISCV64 because ReverseBytes are not supported\n@@ -1935,2 +1948,2 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n-                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"7\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n@@ -1938,2 +1951,4 @@\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n-        applyIfPlatform = {\"little-endian\", \"true\"})\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.REVERSE_BYTES_S, \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISCV64 because ReverseBytes are not supported\n@@ -1970,2 +1985,2 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n-                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"7\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n@@ -1973,2 +1988,4 @@\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n-        applyIfPlatform = {\"little-endian\", \"true\"})\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.REVERSE_BYTES_S, \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISCV64 because ReverseBytes are not supported\n@@ -2171,1 +2188,1 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"6\",\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n@@ -2173,3 +2190,5 @@\n-                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n-        applyIfPlatform = {\"little-endian\", \"true\"})\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.REVERSE_BYTES_I, \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})   \/\/ Exclude RISCV64 because ReverseBytesI\/L are not supported\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStores.java","additions":54,"deletions":35,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -1458,0 +1458,20 @@\n+    public static final String REVERSE_BYTES_I = PREFIX + \"REVERSE_BYTES_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REVERSE_BYTES_I, \"ReverseBytesI\");\n+    }\n+\n+    public static final String REVERSE_BYTES_L = PREFIX + \"REVERSE_BYTES_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REVERSE_BYTES_L, \"ReverseBytesL\");\n+    }\n+\n+    public static final String REVERSE_BYTES_S = PREFIX + \"REVERSE_BYTES_S\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REVERSE_BYTES_S, \"ReverseBytesS\");\n+    }\n+\n+    public static final String REVERSE_BYTES_US = PREFIX + \"REVERSE_BYTES_US\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REVERSE_BYTES_US, \"ReverseBytesUS\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"}]}