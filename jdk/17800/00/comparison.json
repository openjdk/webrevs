{"files":[{"patch":"@@ -4483,1 +4483,1 @@\n-  predicate(UseAVX > 0 && !SuperWord::is_reduction(n));\n+  predicate(UseAVX > 0 && !VLoopReductions::is_reduction(n));\n@@ -4494,1 +4494,1 @@\n-  predicate(UseAVX > 0 && SuperWord::is_reduction(n));\n+  predicate(UseAVX > 0 && VLoopReductions::is_reduction(n));\n@@ -4508,1 +4508,1 @@\n-  predicate(UseAVX > 0 && !SuperWord::is_reduction(n));\n+  predicate(UseAVX > 0 && !VLoopReductions::is_reduction(n));\n@@ -4519,1 +4519,1 @@\n-  predicate(UseAVX > 0 && SuperWord::is_reduction(n));\n+  predicate(UseAVX > 0 && VLoopReductions::is_reduction(n));\n@@ -4533,1 +4533,1 @@\n-  predicate(UseAVX > 0 && !SuperWord::is_reduction(n));\n+  predicate(UseAVX > 0 && !VLoopReductions::is_reduction(n));\n@@ -4544,1 +4544,1 @@\n-  predicate(UseAVX > 0 && SuperWord::is_reduction(n));\n+  predicate(UseAVX > 0 && VLoopReductions::is_reduction(n));\n@@ -4558,1 +4558,1 @@\n-  predicate(UseAVX > 0 && !SuperWord::is_reduction(n));\n+  predicate(UseAVX > 0 && !VLoopReductions::is_reduction(n));\n@@ -4569,1 +4569,1 @@\n-  predicate(UseAVX > 0 && SuperWord::is_reduction(n));\n+  predicate(UseAVX > 0 && VLoopReductions::is_reduction(n));\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -4235,1 +4235,6 @@\n-  SuperWord sw(vloop, vshared);\n+  const VLoopAnalyzer vloop_analyzer(vloop, vshared);\n+  if (!vloop_analyzer.success()) {\n+    return AutoVectorizeStatus::TriedAndFailed;\n+  }\n+\n+  SuperWord sw(vloop_analyzer);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,2 +41,2 @@\n-SuperWord::SuperWord(const VLoop &vloop, VSharedData &vshared) :\n-  _vloop(vloop),\n+SuperWord::SuperWord(const VLoopAnalyzer &vloop_analyzer) :\n+  _vloop_analyzer(vloop_analyzer),\n@@ -45,5 +45,1 @@\n-  _bb_idx(vshared.node_idx_to_loop_body_idx()),             \/\/ node idx to index in bb\n-  _block(arena(), vloop.estimated_body_length(), 0, nullptr), \/\/ nodes in current block\n-  _mem_slice_head(arena(), 8,  0, nullptr),                 \/\/ memory slice heads\n-  _mem_slice_tail(arena(), 8,  0, nullptr),                 \/\/ memory slice tails\n-  _node_info(arena(), vloop.estimated_body_length(), 0, SWNodeInfo::initial), \/\/ info needed per node\n+  _node_info(arena(), vloop().estimated_body_length(), 0, SWNodeInfo::initial), \/\/ info needed per node\n@@ -53,2 +49,0 @@\n-  _nlist(arena(), vloop.estimated_body_length(), 0, nullptr), \/\/ scratch list of nodes\n-  _loop_reductions(arena()),                                \/\/ reduction nodes in the current loop\n@@ -258,1 +252,1 @@\n-bool SuperWord::is_reduction(const Node* n) {\n+bool VLoopReductions::is_reduction(const Node* n) {\n@@ -272,1 +266,1 @@\n-bool SuperWord::is_reduction_operator(const Node* n) {\n+bool VLoopReductions::is_reduction_operator(const Node* n) {\n@@ -277,1 +271,1 @@\n-bool SuperWord::in_reduction_cycle(const Node* n, uint input) {\n+bool VLoopReductions::in_reduction_cycle(const Node* n, uint input) {\n@@ -294,1 +288,1 @@\n-Node* SuperWord::original_input(const Node* n, uint i) {\n+Node* VLoopReductions::original_input(const Node* n, uint i) {\n@@ -306,3 +300,3 @@\n-void SuperWord::mark_reductions() {\n-\n-  _loop_reductions.clear();\n+void VLoopReductions::mark_reductions() {\n+  assert(_loop_reductions.is_empty(), \"must not yet be computed\");\n+  CountedLoopNode* cl = vloop().cl();\n@@ -312,2 +306,2 @@\n-  for (DUIterator_Fast imax, i = cl()->fast_outs(imax); i < imax; i++) {\n-    const Node* phi = cl()->fast_out(i);\n+  for (DUIterator_Fast imax, i = cl->fast_outs(imax); i < imax; i++) {\n+    const Node* phi = cl->fast_out(i);\n@@ -320,1 +314,1 @@\n-    if (phi == iv()) {\n+    if (phi == vloop().iv()) {\n@@ -344,2 +338,3 @@\n-          first, input, lpt()->_body.size(),\n-          [&](const Node* n) { return n->Opcode() == first->Opcode() && in_bb(n); },\n+          first, input, vloop().lpt()->_body.size(),\n+          [&](const Node* n) { return n->Opcode() == first->Opcode() &&\n+                                      vloop().in_bb(n); },\n@@ -364,1 +359,1 @@\n-        if (!in_bb(u)) {\n+        if (!vloop().in_bb(u)) {\n@@ -402,10 +397,0 @@\n-  \/\/ Skip any loop that has not been assigned max unroll by analysis\n-  if (SuperWordLoopUnrollAnalysis && vloop().cl()->slp_max_unroll() == 0) {\n-#ifndef PRODUCT\n-    if (is_trace_superword_any()) {\n-      tty->print_cr(\"\\nSuperWord::transform_loop failed: slp max unroll analysis was not already done\");\n-    }\n-#endif\n-    return false;\n-  }\n-\n@@ -466,29 +451,0 @@\n-  if (SuperWordReductions) {\n-    mark_reductions();\n-  }\n-\n-  \/\/ Find memory slices\n-  find_memory_slices();\n-\n-  if (!is_marked_reduction_loop() &&\n-      _mem_slice_head.is_empty()) {\n-#ifndef PRODUCT\n-    if (is_trace_superword_any()) {\n-      tty->print_cr(\"\\nNo reductions or memory slices found, abort SuperWord.\");\n-      tty->cr();\n-    }\n-#endif\n-    return false;\n-  }\n-\n-  \/\/ Ready the block\n-  if (!construct_bb()) {\n-#ifndef PRODUCT\n-    if (is_trace_superword_any()) {\n-      tty->print_cr(\"\\nSuperWord::construct_bb failed: abort SuperWord\");\n-      tty->cr();\n-    }\n-#endif\n-    return false;\n-  }\n-\n@@ -504,3 +460,0 @@\n-  \/\/ Compute vector element types\n-  compute_vector_element_type();\n-\n@@ -545,2 +498,2 @@\n-  for (int i = 0; i < _block.length(); i++) {\n-    Node* n = _block.at(i);\n+  for (int i = 0; i < body().length(); i++) {\n+    Node* n = body().at(i);\n@@ -803,2 +756,2 @@\n-  for (int i = 0; i < _block.length(); i++ ) {\n-    Node *n = _block.at(i);\n+  for (int i = 0; i < body().length(); i++ ) {\n+    Node *n = body().at(i);\n@@ -810,0 +763,6 @@\n+  const GrowableArray<PhiNode*> &mem_slice_head = vloop_analyzer().memory_slices().heads();\n+  const GrowableArray<MemNode*> &mem_slice_tail = vloop_analyzer().memory_slices().tails();\n+\n+  ResourceMark rm;\n+  GrowableArray<Node*> slice_nodes;\n+\n@@ -811,3 +770,3 @@\n-  for (int i = 0; i < _mem_slice_head.length(); i++) {\n-    Node* n      = _mem_slice_head.at(i);\n-    Node* n_tail = _mem_slice_tail.at(i);\n+  for (int i = 0; i < mem_slice_head.length(); i++) {\n+    PhiNode* head = mem_slice_head.at(i);\n+    MemNode* tail = mem_slice_tail.at(i);\n@@ -816,1 +775,1 @@\n-    mem_slice_preds(n_tail, n, _nlist);\n+    vloop_analyzer().memory_slices().get_slice(head, tail, slice_nodes);\n@@ -819,1 +778,1 @@\n-    DepMem* slice = _dg.dep(n);\n+    DepMem* slice = _dg.dep(head);\n@@ -827,2 +786,2 @@\n-    for (int j = _nlist.length() - 1; j >= 0 ; j--) {\n-      Node* s1 = _nlist.at(j);\n+    for (int j = slice_nodes.length() - 1; j >= 0 ; j--) {\n+      Node* s1 = slice_nodes.at(j);\n@@ -837,1 +796,1 @@\n-        Node* s2 = _nlist.at(k);\n+        Node* s2 = slice_nodes.at(k);\n@@ -856,3 +815,3 @@\n-      tty->print_cr(\"\\nDependence graph for slice: %d\", n->_idx);\n-      for (int q = 0; q < _nlist.length(); q++) {\n-        _dg.print(_nlist.at(q));\n+      tty->print_cr(\"\\nDependence graph for slice: %d\", head->_idx);\n+      for (int q = 0; q < slice_nodes.length(); q++) {\n+        _dg.print(slice_nodes.at(q));\n@@ -864,1 +823,1 @@\n-    _nlist.clear();\n+    slice_nodes.clear();\n@@ -868,3 +827,4 @@\n-void SuperWord::find_memory_slices() {\n-  assert(_mem_slice_head.length() == 0, \"mem_slice_head is empty\");\n-  assert(_mem_slice_tail.length() == 0, \"mem_slice_tail is empty\");\n+void VLoopMemorySlices::find_memory_slices() {\n+  assert(_heads.is_empty(), \"not yet computed\");\n+  assert(_tails.is_empty(), \"not yet computed\");\n+  CountedLoopNode* cl = vloop().cl();\n@@ -873,3 +833,3 @@\n-  for (DUIterator_Fast imax, i = cl()->fast_outs(imax); i < imax; i++) {\n-    PhiNode* phi = cl()->fast_out(i)->isa_Phi();\n-    if (phi != nullptr && in_bb(phi) && phi->is_memory_phi()) {\n+  for (DUIterator_Fast imax, i = cl->fast_outs(imax); i < imax; i++) {\n+    PhiNode* phi = cl->fast_out(i)->isa_Phi();\n+    if (phi != nullptr && vloop().in_bb(phi) && phi->is_memory_phi()) {\n@@ -878,2 +838,2 @@\n-        _mem_slice_head.push(phi);\n-        _mem_slice_tail.push(phi_tail->as_Mem());\n+        _heads.push(phi);\n+        _tails.push(phi_tail->as_Mem());\n@@ -884,1 +844,1 @@\n-  NOT_PRODUCT( if (is_trace_superword_memory_slices()) { print_memory_slices(); } )\n+  NOT_PRODUCT( if (vloop().is_trace_memory_slices()) { print(); } )\n@@ -888,6 +848,6 @@\n-void SuperWord::print_memory_slices() {\n-  tty->print_cr(\"\\nSuperWord::print_memory_slices: %s\",\n-                _mem_slice_head.length() > 0 ? \"\" : \"NONE\");\n-  for (int m = 0; m < _mem_slice_head.length(); m++) {\n-    tty->print(\"%6d \", m);  _mem_slice_head.at(m)->dump();\n-    tty->print(\"       \");  _mem_slice_tail.at(m)->dump();\n+void VLoopMemorySlices::print() const {\n+  tty->print_cr(\"\\nVLoopMemorySlices::print: %s\",\n+                heads().length() > 0 ? \"\" : \"NONE\");\n+  for (int m = 0; m < heads().length(); m++) {\n+    tty->print(\"%6d \", m);  heads().at(m)->dump();\n+    tty->print(\"       \");  tails().at(m)->dump();\n@@ -898,5 +858,4 @@\n-\/\/---------------------------mem_slice_preds---------------------------\n-\/\/ Return a memory slice (node list) in predecessor order starting at \"start\"\n-void SuperWord::mem_slice_preds(Node* start, Node* stop, GrowableArray<Node*> &preds) {\n-  assert(preds.length() == 0, \"start empty\");\n-  Node* n = start;\n+\/\/ Get all memory nodes of a slice, in reverse order\n+void VLoopMemorySlices::get_slice(PhiNode* head, MemNode* tail, GrowableArray<Node*> &slice) const {\n+  assert(slice.length() == 0, \"start empty\");\n+  Node* n = tail;\n@@ -905,1 +864,1 @@\n-    assert(in_bb(n), \"must be in block\");\n+    assert(vloop().in_bb(n), \"must be in block\");\n@@ -909,2 +868,2 @@\n-        if (in_bb(out)) {\n-          preds.push(out);\n+        if (vloop().in_bb(out)) {\n+          slice.push(out);\n@@ -914,1 +873,1 @@\n-        if (out->is_MergeMem() && !in_bb(out)) {\n+        if (out->is_MergeMem() && !vloop().in_bb(out)) {\n@@ -917,1 +876,1 @@\n-        } else if (out->is_memory_phi() && !in_bb(out)) {\n+        } else if (out->is_memory_phi() && !vloop().in_bb(out)) {\n@@ -927,2 +886,2 @@\n-    if (n == stop) break;\n-    preds.push(n);\n+    if (n == head) { break; }\n+    slice.push(n);\n@@ -935,5 +894,5 @@\n-  if (is_trace_superword_memory_slices()) {\n-    tty->print_cr(\"\\nSuperWord::mem_slice_preds:\");\n-    stop->dump();\n-    for (int j = preds.length() - 1; j >= 0 ; j--) {\n-      preds.at(j)->dump();\n+  if (vloop().is_trace_memory_slices()) {\n+    tty->print_cr(\"\\nVLoopMemorySlices::get_slice:\");\n+    head->dump();\n+    for (int j = slice.length() - 1; j >= 0 ; j--) {\n+      slice.at(j)->dump();\n@@ -1133,15 +1092,9 @@\n-\/\/------------------------------reduction---------------------------\n-\/\/ Is there a data path between s1 and s2 and the nodes reductions?\n-bool SuperWord::reduction(Node* s1, Node* s2) {\n-  bool retValue = false;\n-  int d1 = depth(s1);\n-  int d2 = depth(s2);\n-  if (d2 > d1) {\n-    if (is_marked_reduction(s1) && is_marked_reduction(s2)) {\n-      \/\/ This is an ordered set, so s1 should define s2\n-      for (DUIterator_Fast imax, i = s1->fast_outs(imax); i < imax; i++) {\n-        Node* t1 = s1->fast_out(i);\n-        if (t1 == s2) {\n-          \/\/ both nodes are reductions and connected\n-          retValue = true;\n-        }\n+bool VLoopReductions::is_marked_reduction_pair(Node* s1, Node* s2) const {\n+  if (is_marked_reduction(s1) &&\n+      is_marked_reduction(s2)) {\n+    \/\/ This is an ordered set, so s1 should define s2\n+    for (DUIterator_Fast imax, i = s1->fast_outs(imax); i < imax; i++) {\n+      Node* t1 = s1->fast_out(i);\n+      if (t1 == s2) {\n+        \/\/ both nodes are reductions and connected\n+        return true;\n@@ -1151,2 +1104,1 @@\n-\n-  return retValue;\n+  return false;\n@@ -1165,7 +1117,0 @@\n-\/\/------------------------------data_size---------------------------\n-int SuperWord::data_size(Node* s) {\n-  int bsize = type2aelembytes(velt_basic_type(s));\n-  assert(bsize != 0, \"valid size\");\n-  return bsize;\n-}\n-\n@@ -1889,1 +1834,1 @@\n-      \/\/ Unmark reduction if no parent pack or if not enough work\n+      \/\/ No parent pack or not enough work\n@@ -1891,1 +1836,0 @@\n-      _loop_reductions.remove(p0->_idx);\n@@ -1994,2 +1938,2 @@\n-  for (int i = 0; i < _block.length(); i++) {\n-    Node* n = _block.at(i);\n+  for (int i = 0; i < body().length(); i++) {\n+    Node* n = body().at(i);\n@@ -2078,3 +2022,3 @@\n-    const GrowableArray<Node_List*> &packset = _slp->packset();\n-    const GrowableArray<Node*> &block = _slp->block();\n-    const DepGraph &dg = _slp->dg();\n+    const GrowableArray<Node_List*>& packset = _slp->packset();\n+    const GrowableArray<Node*>& body = _slp->body();\n+    const DepGraph& dg = _slp->dg();\n@@ -2095,2 +2039,2 @@\n-    for (int i = 0; i < block.length(); i++) {\n-      Node* n = block.at(i);\n+    for (int i = 0; i < body.length(); i++) {\n+      Node* n = body.at(i);\n@@ -2123,1 +2067,1 @@\n-          \/\/ Only add edges once, and only for mapped nodes (in block)\n+          \/\/ Only add edges once, and only for mapped nodes (in body)\n@@ -2133,2 +2077,2 @@\n-    for (int i = 0; i < block.length(); i++) {\n-      Node* n = block.at(i);\n+    for (int i = 0; i < body.length(); i++) {\n+      Node* n = body.at(i);\n@@ -2142,1 +2086,1 @@\n-        \/\/ Only add edges for mapped nodes (in block)\n+        \/\/ Only add edges for mapped nodes (in body)\n@@ -2203,1 +2147,1 @@\n-    const GrowableArray<Node*> &block = _slp->block();\n+    const GrowableArray<Node*> &body = _slp->body();\n@@ -2216,2 +2160,2 @@\n-        for (int i = 0; i < block.length(); i++) {\n-          Node* n = block.at(i);\n+        for (int i = 0; i < body.length(); i++) {\n+          Node* n = body.at(i);\n@@ -2295,0 +2239,2 @@\n+  const GrowableArray<PhiNode*> &mem_slice_head = vloop_analyzer().memory_slices().heads();\n+\n@@ -2296,2 +2242,2 @@\n-  for (int i = 0; i < _mem_slice_head.length(); i++) {\n-    Node* phi  = _mem_slice_head.at(i);\n+  for (int i = 0; i < mem_slice_head.length(); i++) {\n+    Node* phi  = mem_slice_head.at(i);\n@@ -2332,2 +2278,2 @@\n-  for (int i = 0; i < _mem_slice_head.length(); i++) {\n-    Node* phi  = _mem_slice_head.at(i);\n+  for (int i = 0; i < mem_slice_head.length(); i++) {\n+    Node* phi  = mem_slice_head.at(i);\n@@ -2395,2 +2341,2 @@\n-  for (int i = 0; i < _block.length(); i++) {\n-    Node* n = _block.at(i);\n+  for (int i = 0; i < body().length(); i++) {\n+    Node* n = body().at(i);\n@@ -2668,1 +2614,0 @@\n-      _block.at_put(i, vn);\n@@ -2685,1 +2630,1 @@\n-  }\/\/for (int i = 0; i < _block.length(); i++)\n+  }\/\/for (int i = 0; i < body().length(); i++)\n@@ -2949,4 +2894,3 @@\n-\/\/------------------------------construct_bb---------------------------\n-\/\/ Construct reverse postorder list of block members\n-bool SuperWord::construct_bb() {\n-  assert(_block.length() == 0,          \"block is empty\");\n+\/\/ Return nullptr if success, else failure message\n+const char* VLoopBody::construct() {\n+  assert(_body.length() == 0, \"body is empty\");\n@@ -2958,3 +2902,3 @@\n-  int block_count = 0;\n-  for (uint i = 0; i < lpt()->_body.size(); i++) {\n-    Node* n = lpt()->_body.at(i);\n+  int body_count = 0;\n+  for (uint i = 0; i < vloop().lpt()->_body.size(); i++) {\n+    Node* n = vloop().lpt()->_body.at(i);\n@@ -2962,2 +2906,2 @@\n-    if (in_bb(n)) {\n-      block_count++;\n+    if (vloop().in_bb(n)) {\n+      body_count++;\n@@ -2970,2 +2914,2 @@\n-        if (is_trace_superword_any()) {\n-          tty->print_cr(\"SuperWord::construct_bb: fails because of unhandled node:\");\n+        if (vloop().is_trace_body()) {\n+          tty->print_cr(\"VLoopBody::construct: fails because of unhandled node:\");\n@@ -2975,1 +2919,1 @@\n-        return false;\n+        return VLoopBody::FAILURE_NODE_NOT_ALLOWED;\n@@ -2983,1 +2927,1 @@\n-          if (def != nullptr && in_bb(def)) {\n+          if (def != nullptr && vloop().in_bb(def)) {\n@@ -2994,1 +2938,1 @@\n-  \/\/ Create a reverse-post-order list of nodes in block\n+  \/\/ Create a reverse-post-order list of nodes in body\n@@ -3000,2 +2944,2 @@\n-  visited.set(bb_idx(cl()));\n-  stack.push(cl());\n+  visited.set(bb_idx(vloop().cl()));\n+  stack.push(vloop().cl());\n@@ -3004,1 +2948,1 @@\n-  int rpo_idx = block_count - 1;\n+  int rpo_idx = body_count - 1;\n@@ -3014,1 +2958,1 @@\n-        if (in_bb(use) && !visited.test(bb_idx(use)) &&\n+        if (vloop().in_bb(use) && !visited.test(bb_idx(use)) &&\n@@ -3016,1 +2960,1 @@\n-            (!use->is_Phi() || n == cl())) {\n+            (!use->is_Phi() || n == vloop().cl())) {\n@@ -3024,1 +2968,1 @@\n-        _block.at_put_grow(rpo_idx, n);\n+        _body.at_put_grow(rpo_idx, n);\n@@ -3034,3 +2978,3 @@\n-  \/\/ Create real map of block indices for nodes\n-  for (int j = 0; j < _block.length(); j++) {\n-    Node* n = _block.at(j);\n+  \/\/ Create real map of body indices for nodes\n+  for (int j = 0; j < _body.length(); j++) {\n+    Node* n = _body.at(j);\n@@ -3041,2 +2985,2 @@\n-  if (is_trace_superword_info()) {\n-    print_bb();\n+  if (vloop().is_trace_body()) {\n+    print();\n@@ -3046,2 +2990,2 @@\n-  assert(rpo_idx == -1 && block_count == _block.length(), \"all block members found\");\n-  return true;\n+  assert(rpo_idx == -1 && body_count == _body.length(), \"all body members found\");\n+  return nullptr; \/\/ success\n@@ -3052,1 +2996,1 @@\n-  Node* last = _block.at(_block.length() - 1);\n+  Node* last = body().at(body().length() - 1);\n@@ -3064,2 +3008,2 @@\n-    for (int i = 0; i < _block.length(); i++) {\n-      Node* n = _block.at(i);\n+    for (int i = 0; i < body().length(); i++) {\n+      Node* n = body().at(i);\n@@ -3140,8 +3084,1 @@\n-\/\/-------------------------compute_vector_element_type-----------------------\n-\/\/ Compute necessary vector element type for expressions\n-\/\/ This propagates backwards a narrower integer type when the\n-\/\/ upper bits of the value are not needed.\n-\/\/ Example:  char a,b,c;  a = b + c;\n-\/\/ Normally the type of the add is integer, but for packed character\n-\/\/ operations the type of the add needs to be char.\n-void SuperWord::compute_vector_element_type() {\n+void VLoopTypes::compute_vector_element_type() {\n@@ -3149,2 +3086,2 @@\n-  if (is_trace_superword_vector_element_type()) {\n-    tty->print_cr(\"\\ncompute_velt_type:\");\n+  if (vloop().is_trace_vector_element_type()) {\n+    tty->print_cr(\"\\nVLoopTypes::compute_vector_element_type:\");\n@@ -3154,0 +3091,6 @@\n+  const GrowableArray<Node*>& body = _body.body();\n+\n+  assert(_velt_type.is_empty(), \"must not yet be computed\");\n+  \/\/ reserve space\n+  _velt_type.at_put_grow(body.length()-1, nullptr);\n+\n@@ -3155,2 +3098,2 @@\n-  for (int i = 0; i < _block.length(); i++) {\n-    Node* n = _block.at(i);\n+  for (int i = 0; i < body.length(); i++) {\n+    Node* n = body.at(i);\n@@ -3162,2 +3105,2 @@\n-  for (int i = _block.length() - 1; i >= 0; i--) {\n-    Node* n = _block.at(i);\n+  for (int i = body.length() - 1; i >= 0; i--) {\n+    Node* n = body.at(i);\n@@ -3173,1 +3116,3 @@\n-        if (!in->is_Mem() && in_bb(in) && velt_type(in)->basic_type() == T_INT &&\n+        if (!in->is_Mem() &&\n+            vloop().in_bb(in) &&\n+            velt_type(in)->basic_type() == T_INT &&\n@@ -3178,1 +3123,1 @@\n-            if (!in_bb(use) || !same_velt_type(use, n)) {\n+            if (!vloop().in_bb(use) || !same_velt_type(use, n)) {\n@@ -3195,1 +3140,3 @@\n-              if (load->is_Load() && in_bb(load) && (velt_type(load)->basic_type() == T_INT)) {\n+              if (load->is_Load() &&\n+                  vloop().in_bb(load) &&\n+                  (velt_type(load)->basic_type() == T_INT)) {\n@@ -3211,2 +3158,2 @@\n-  for (int i = 0; i < _block.length(); i++) {\n-    Node* n = _block.at(i);\n+  for (int i = 0; i < body.length(); i++) {\n+    Node* n = body.at(i);\n@@ -3219,2 +3166,3 @@\n-      assert(in_bb(nn->in(1)) || in_bb(nn->in(2)), \"one of the inputs must be in the loop too\");\n-      if (in_bb(nn->in(1))) {\n+      assert(vloop().in_bb(nn->in(1)) || vloop().in_bb(nn->in(2)),\n+             \"one of the inputs must be in the loop too\");\n+      if (vloop().in_bb(nn->in(1))) {\n@@ -3228,3 +3176,3 @@\n-  if (is_trace_superword_vector_element_type()) {\n-    for (int i = 0; i < _block.length(); i++) {\n-      Node* n = _block.at(i);\n+  if (vloop().is_trace_vector_element_type()) {\n+    for (int i = 0; i < body.length(); i++) {\n+      Node* n = body.at(i);\n@@ -3269,1 +3217,0 @@\n-\/\/---------------------------container_type---------------------------\n@@ -3271,1 +3218,1 @@\n-const Type* SuperWord::container_type(Node* n) {\n+const Type* VLoopTypes::container_type(Node* n) const {\n@@ -3288,1 +3235,1 @@\n-  const Type* t = igvn().type(n);\n+  const Type* t = vloop().phase()->igvn().type(n);\n@@ -3297,12 +3244,3 @@\n-bool SuperWord::same_velt_type(Node* n1, Node* n2) {\n-  const Type* vt1 = velt_type(n1);\n-  const Type* vt2 = velt_type(n2);\n-  if (vt1->basic_type() == T_INT && vt2->basic_type() == T_INT) {\n-    \/\/ Compare vectors element sizes for integer types.\n-    return data_size(n1) == data_size(n2);\n-  }\n-  return vt1 == vt2;\n-}\n-\n-bool SuperWord::same_memory_slice(MemNode* best_align_to_mem_ref, MemNode* mem_ref) const {\n-  return phase()->C->get_alias_index(mem_ref->adr_type()) == phase()->C->get_alias_index(best_align_to_mem_ref->adr_type());\n+bool VLoopMemorySlices::same_memory_slice(MemNode* m1, MemNode* m2) const {\n+  return vloop().phase()->C->get_alias_index(m1->adr_type()) ==\n+         vloop().phase()->C->get_alias_index(m2->adr_type());\n@@ -3729,2 +3667,0 @@\n-\/\/------------------------------print_bb---------------------------\n-void SuperWord::print_bb() {\n@@ -3732,0 +3668,1 @@\n+void VLoopBody::print() const {\n@@ -3733,2 +3670,2 @@\n-  for (int i = 0; i < _block.length(); i++) {\n-    Node* n = _block.at(i);\n+  for (int i = 0; i < body().length(); i++) {\n+    Node* n = body().at(i);\n@@ -3736,1 +3673,1 @@\n-    if (n) {\n+    if (n != nullptr) {\n@@ -3740,1 +3677,0 @@\n-#endif\n@@ -3742,0 +3678,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":172,"deletions":235,"binary":false,"changes":407,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"utilities\/pair.hpp\"\n@@ -191,1 +190,0 @@\n-  const Type* _velt_type; \/\/ vector element type\n@@ -194,1 +192,1 @@\n-  SWNodeInfo() : _alignment(-1), _depth(0), _velt_type(nullptr), _my_pack(nullptr) {}\n+  SWNodeInfo() : _alignment(-1), _depth(0), _my_pack(nullptr) {}\n@@ -202,1 +200,1 @@\n-  const VLoop& _vloop;\n+  const VLoopAnalyzer& _vloop_analyzer;\n@@ -212,5 +210,0 @@\n-  GrowableArray<int> &_bb_idx;           \/\/ Map from Node _idx to index within block\n-\n-  GrowableArray<Node*> _block;           \/\/ Nodes in current block\n-  GrowableArray<PhiNode*> _mem_slice_head; \/\/ Memory slice head nodes\n-  GrowableArray<MemNode*> _mem_slice_tail; \/\/ Memory slice tail nodes\n@@ -223,3 +216,0 @@\n-  \/\/ Scratch pads\n-  GrowableArray<Node*> _nlist; \/\/ List of nodes\n-\n@@ -227,1 +217,1 @@\n-  SuperWord(const VLoop &vloop, VSharedData &vshared);\n+  SuperWord(const VLoopAnalyzer &vloop_analyzer);\n@@ -235,0 +225,3 @@\n+  \/\/ VLoopAnalyzer Accessors\n+  const VLoopAnalyzer& vloop_analyzer() const { return _vloop_analyzer; }\n+\n@@ -236,8 +229,13 @@\n-  const VLoop& vloop()        const { return _vloop; }\n-  PhaseIdealLoop* phase()     const { return vloop().phase(); }\n-  PhaseIterGVN& igvn()        const { return vloop().phase()->igvn(); }\n-  IdealLoopTree* lpt()        const { return vloop().lpt(); }\n-  CountedLoopNode* cl()       const { return vloop().cl(); }\n-  PhiNode* iv()               const { return vloop().iv(); }\n-  int iv_stride()             const { return cl()->stride_con(); }\n-  bool in_bb(const Node* n)   const { return vloop().in_bb(n); }\n+  const VLoop& vloop()                  const { return vloop_analyzer().vloop(); }\n+  PhaseIdealLoop* phase()               const { return vloop().phase(); }\n+  PhaseIterGVN& igvn()                  const { return vloop().phase()->igvn(); }\n+  IdealLoopTree* lpt()                  const { return vloop().lpt(); }\n+  CountedLoopNode* cl()                 const { return vloop().cl(); }\n+  PhiNode* iv()                         const { return vloop().iv(); }\n+  int iv_stride()                       const { return cl()->stride_con(); }\n+  bool in_bb(const Node* n)             const { return vloop().in_bb(n); }\n+\n+  \/\/ VLoopReductions Accessors\n+  bool is_marked_reduction(const Node* n) const {\n+    return vloop_analyzer().reductions().is_marked_reduction(n);\n+  }\n@@ -245,5 +243,33 @@\n-#ifndef PRODUCT\n-  \/\/ TraceAutoVectorization and TraceSuperWord\n-  bool is_trace_superword_vector_element_type() const {\n-    \/\/ Too verbose for TraceSuperWord\n-    return vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_TYPES);\n+  bool reduction(Node* n1, Node* n2) const {\n+    return vloop_analyzer().reductions().is_marked_reduction_pair(n1, n2);\n+  }\n+\n+  \/\/ VLoopMemorySlices Accessors\n+  bool same_memory_slice(MemNode* n1, MemNode* n2) const {\n+    return vloop_analyzer().memory_slices().same_memory_slice(n1, n2);\n+  }\n+\n+  \/\/ VLoopBody Accessors\n+  const GrowableArray<Node*>& body() const {\n+    return vloop_analyzer().body().body();\n+  }\n+\n+  int bb_idx(const Node* n) const     {\n+    return vloop_analyzer().body().bb_idx(n);\n+  }\n+\n+  \/\/ VLoopTypes Accessors\n+  const Type* velt_type(Node* n) const {\n+    return vloop_analyzer().types().velt_type(n);\n+  }\n+\n+  BasicType velt_basic_type(Node* n) const {\n+    return vloop_analyzer().types().velt_basic_type(n);\n+  }\n+\n+  bool same_velt_type(Node* n1, Node* n2) const {\n+    return vloop_analyzer().types().same_velt_type(n1, n2);\n+  }\n+\n+  int data_size(Node* n) const {\n+    return vloop_analyzer().types().data_size(n);\n@@ -252,0 +278,10 @@\n+  int vector_width(Node* n) const {\n+    return vloop_analyzer().types().vector_width(n);\n+  }\n+\n+  int vector_width_in_bytes(const Node* n) const {\n+    return vloop_analyzer().types().vector_width_in_bytes(n);\n+  }\n+\n+#ifndef PRODUCT\n+  \/\/ TraceAutoVectorization and TraceSuperWord\n@@ -257,5 +293,0 @@\n-  bool is_trace_superword_memory_slices() const {\n-    return TraceSuperWord ||\n-           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_MEMORY_SLICES);\n-  }\n-\n@@ -295,1 +326,0 @@\n-           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_TYPES) ||\n@@ -297,1 +327,0 @@\n-           vloop().vtrace().is_trace(TraceAutoVectorizationTag::SW_MEMORY_SLICES) ||\n@@ -315,1 +344,0 @@\n-  const GrowableArray<Node*>&      block()   const { return _block; }\n@@ -318,1 +346,0 @@\n-  VectorSet      _loop_reductions; \/\/ Reduction nodes in the current loop\n@@ -327,8 +354,0 @@\n-  int vector_width(const Node* n) const {\n-    BasicType bt = velt_basic_type(n);\n-    return MIN2(ABS(iv_stride()), Matcher::max_vector_size(bt));\n-  }\n-  int vector_width_in_bytes(const Node* n) const {\n-    BasicType bt = velt_basic_type(n);\n-    return vector_width(n)*type2aelembytes(bt);\n-  }\n@@ -339,6 +358,0 @@\n-  \/\/ block accessors\n- public:\n-  int  bb_idx(const Node* n) const { assert(in_bb(n), \"must be\"); return _bb_idx.at(n->_idx); }\n- private:\n-  void set_bb_idx(Node* n, int i)  { _bb_idx.at_put_grow(n->_idx, i); }\n-\n@@ -359,7 +372,0 @@\n-  \/\/ vector element type\n-  const Type* velt_type(const Node* n) const { return _node_info.adr_at(bb_idx(n))->_velt_type; }\n-  BasicType velt_basic_type(const Node* n) const { return velt_type(n)->array_element_basic_type(); }\n-  void set_velt_type(Node* n, const Type* t) { int i = bb_idx(n); grow_node_info(i); _node_info.adr_at(i)->_velt_type = t; }\n-  bool same_velt_type(Node* n1, Node* n2);\n-  bool same_memory_slice(MemNode* best_align_to_mem_ref, MemNode* mem_ref) const;\n-\n@@ -379,44 +385,0 @@\n-  \/\/ methods\n-\n-  typedef const Pair<const Node*, int> PathEnd;\n-\n-  \/\/ Search for a path P = (n_1, n_2, ..., n_k) such that:\n-  \/\/ - original_input(n_i, input) = n_i+1 for all 1 <= i < k,\n-  \/\/ - path(n) for all n in P,\n-  \/\/ - k <= max, and\n-  \/\/ - there exists a node e such that original_input(n_k, input) = e and end(e).\n-  \/\/ Return <e, k>, if P is found, or <nullptr, -1> otherwise.\n-  \/\/ Note that original_input(n, i) has the same behavior as n->in(i) except\n-  \/\/ that it commutes the inputs of binary nodes whose edges have been swapped.\n-  template <typename NodePredicate1, typename NodePredicate2>\n-  static PathEnd find_in_path(const Node *n1, uint input, int max,\n-                              NodePredicate1 path, NodePredicate2 end) {\n-    const PathEnd no_path(nullptr, -1);\n-    const Node* current = n1;\n-    int k = 0;\n-    for (int i = 0; i <= max; i++) {\n-      if (current == nullptr) {\n-        return no_path;\n-      }\n-      if (end(current)) {\n-        return PathEnd(current, k);\n-      }\n-      if (!path(current)) {\n-        return no_path;\n-      }\n-      current = original_input(current, input);\n-      k++;\n-    }\n-    return no_path;\n-  }\n-\n-public:\n-  \/\/ Whether n is a reduction operator and part of a reduction cycle.\n-  \/\/ This function can be used for individual queries outside the SLP analysis,\n-  \/\/ e.g. to inform matching in target-specific code. Otherwise, the\n-  \/\/ almost-equivalent but faster SuperWord::mark_reductions() is preferable.\n-  static bool is_reduction(const Node* n);\n-  \/\/ Whether n is marked as a reduction node.\n-  bool is_marked_reduction(Node* n) { return _loop_reductions.test(n->_idx); }\n-  \/\/ Whether the current loop has any reduction node.\n-  bool is_marked_reduction_loop() { return !_loop_reductions.is_empty(); }\n@@ -424,14 +386,0 @@\n-  \/\/ Whether n is a standard reduction operator.\n-  static bool is_reduction_operator(const Node* n);\n-  \/\/ Whether n is part of a reduction cycle via the 'input' edge index. To bound\n-  \/\/ the search, constrain the size of reduction cycles to LoopMaxUnroll.\n-  static bool in_reduction_cycle(const Node* n, uint input);\n-  \/\/ Reference to the i'th input node of n, commuting the inputs of binary nodes\n-  \/\/ whose edges have been swapped. Assumes n is a commutative operation.\n-  static Node* original_input(const Node* n, uint i);\n-  \/\/ Find and mark reductions in a loop. Running mark_reductions() is similar to\n-  \/\/ querying is_reduction(n) for every n in the SuperWord loop, but stricter in\n-  \/\/ that it assumes counted loops and requires that reduction nodes are not\n-  \/\/ used within the loop except by their reduction cycle predecessors.\n-  void mark_reductions();\n-  \/\/ Extract the superword level parallelism\n@@ -448,6 +396,0 @@\n-  \/\/ Analyze the memory slices\n-  void find_memory_slices();\n-  NOT_PRODUCT( void print_memory_slices(); )\n-  \/\/ Return a memory slice (node list) in predecessor order starting at \"start\"\n-  void mem_slice_preds(Node* start, Node* stop, GrowableArray<Node*> &preds);\n-\n@@ -469,2 +411,0 @@\n-  \/\/ Is there a data path between s1 and s2 and both are reductions?\n-  bool reduction(Node* s1, Node* s2);\n@@ -472,1 +412,0 @@\n-  int data_size(Node* s);\n@@ -519,2 +458,0 @@\n-  \/\/ Construct reverse postorder list of block members\n-  bool construct_bb();\n@@ -529,2 +466,0 @@\n-  \/\/ Compute necessary vector element type for expressions\n-  void compute_vector_element_type();\n@@ -538,2 +473,0 @@\n-  \/\/ Smallest type containing range of values\n-  const Type* container_type(Node* n);\n@@ -548,1 +481,0 @@\n-  void print_bb();\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":62,"deletions":130,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -34,1 +34,4 @@\n-  flags(SW_TYPES,             \"Trace SuperWord::compute_vector_element_type\") \\\n+  flags(LOOP_ANALYZER,        \"Trace VLoopAnalyzer::setup_submodules\") \\\n+  flags(MEMORY_SLICES,        \"Trace VLoopMemorySlices\") \\\n+  flags(BODY,                 \"Trace VLoopBody\") \\\n+  flags(TYPES,                \"Trace VLoopTypes\") \\\n@@ -36,1 +39,0 @@\n-  flags(SW_MEMORY_SLICES,     \"Trace SuperWord memory slices\") \\\n@@ -115,1 +117,0 @@\n-        _tags.at_put(SW_TYPES, set_bit);\n@@ -117,1 +118,0 @@\n-        _tags.at_put(SW_MEMORY_SLICES, set_bit);\n@@ -125,1 +125,0 @@\n-        _tags.at_put(SW_MEMORY_SLICES, set_bit);\n","filename":"src\/hotspot\/share\/opto\/traceAutoVectorizationTag.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -117,0 +117,54 @@\n+\/\/ Return true iff all submodules are loaded successfully\n+bool VLoopAnalyzer::setup_submodules() {\n+#ifndef PRODUCT\n+  if (vloop().is_trace_loop_analyzer()) {\n+    tty->print_cr(\"\\nVLoopAnalyzer::setup_submodules\");\n+    vloop().lpt()->dump_head();\n+    vloop().cl()->dump();\n+  }\n+#endif\n+\n+  const char* state = setup_submodules_helper();\n+    if (state == VLoopAnalyzer::SUCCESS) {\n+    return true; \/\/ success\n+  }\n+\n+#ifndef PRODUCT\n+  if (vloop().is_trace_loop_analyzer()) {\n+    tty->print_cr(\"\\nVLoopAnalyze::setup_submodules: failed: %s\", state);\n+  }\n+#endif\n+  return false; \/\/ failed\n+}\n+\n+\/\/ Return SUCCESS string iff all submodules are setup successfully\n+const char* VLoopAnalyzer::setup_submodules_helper() {\n+  \/\/ Skip any loop that has not been assigned max unroll by analysis.\n+  if (SuperWordLoopUnrollAnalysis && vloop().cl()->slp_max_unroll() == 0) {\n+    return VLoopAnalyzer::FAILURE_NO_MAX_UNROLL;\n+  }\n+\n+  if (SuperWordReductions) {\n+    _reductions.mark_reductions();\n+  }\n+\n+  _memory_slices.find_memory_slices();\n+\n+  \/\/ If there is no memory slice detected, that means there is no store.\n+  \/\/ If there is no reduction and no store, then we give up, because\n+  \/\/ vectorization is not possible anyway (given current limitations).\n+  if (!reductions().is_marked_reduction_loop() &&\n+      _memory_slices.heads().is_empty()) {\n+    return VLoopAnalyzer::FAILURE_NO_REDUCTION_OR_STORE;\n+  }\n+\n+  const char* body_failure = _body.construct();\n+  if (body_failure != nullptr) {\n+    return body_failure;\n+  }\n+\n+  _types.compute_vector_element_type();\n+\n+  return VLoopAnalyzer::SUCCESS;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/pair.hpp\"\n@@ -114,0 +115,16 @@\n+  bool is_trace_loop_analyzer() const {\n+    return vtrace().is_trace(TraceAutoVectorizationTag::LOOP_ANALYZER);\n+  }\n+\n+  bool is_trace_memory_slices() const {\n+    return vtrace().is_trace(TraceAutoVectorizationTag::MEMORY_SLICES);\n+  }\n+\n+  bool is_trace_body() const {\n+    return vtrace().is_trace(TraceAutoVectorizationTag::BODY);\n+  }\n+\n+  bool is_trace_vector_element_type() const {\n+    return vtrace().is_trace(TraceAutoVectorizationTag::TYPES);\n+  }\n+\n@@ -169,0 +186,291 @@\n+\/\/ Submodule of VLoopAnalyzer.\n+\/\/ Identify and mark all reductions in the loop.\n+class VLoopReductions : public StackObj {\n+private:\n+  typedef const Pair<const Node*, int> PathEnd;\n+\n+  const VLoop& _vloop;\n+  VectorSet _loop_reductions;\n+\n+public:\n+  VLoopReductions(Arena* arena, const VLoop& vloop) :\n+    _vloop(vloop),\n+    _loop_reductions(arena){};\n+\n+  NONCOPYABLE(VLoopReductions);\n+\n+private:\n+  const VLoop& vloop() const { return _vloop; }\n+  \/\/ Search for a path P = (n_1, n_2, ..., n_k) such that:\n+  \/\/ - original_input(n_i, input) = n_i+1 for all 1 <= i < k,\n+  \/\/ - path(n) for all n in P,\n+  \/\/ - k <= max, and\n+  \/\/ - there exists a node e such that original_input(n_k, input) = e and end(e).\n+  \/\/ Return <e, k>, if P is found, or <nullptr, -1> otherwise.\n+  \/\/ Note that original_input(n, i) has the same behavior as n->in(i) except\n+  \/\/ that it commutes the inputs of binary nodes whose edges have been swapped.\n+  template <typename NodePredicate1, typename NodePredicate2>\n+  static PathEnd find_in_path(const Node* n1, uint input, int max,\n+                              NodePredicate1 path, NodePredicate2 end) {\n+    const PathEnd no_path(nullptr, -1);\n+    const Node* current = n1;\n+    int k = 0;\n+    for (int i = 0; i <= max; i++) {\n+      if (current == nullptr) {\n+        return no_path;\n+      }\n+      if (end(current)) {\n+        return PathEnd(current, k);\n+      }\n+      if (!path(current)) {\n+        return no_path;\n+      }\n+      current = original_input(current, input);\n+      k++;\n+    }\n+    return no_path;\n+  }\n+\n+public:\n+  \/\/ Find and mark reductions in a loop. Running mark_reductions() is similar to\n+  \/\/ querying is_reduction(n) for every node in the loop, but stricter in\n+  \/\/ that it assumes counted loops and requires that reduction nodes are not\n+  \/\/ used within the loop except by their reduction cycle predecessors.\n+  void mark_reductions();\n+  \/\/ Whether n is a reduction operator and part of a reduction cycle.\n+  \/\/ This function can be used for individual queries outside auto-vectorization,\n+  \/\/ e.g. to inform matching in target-specific code. Otherwise, the\n+  \/\/ almost-equivalent but faster mark_reductions() is preferable.\n+  static bool is_reduction(const Node* n);\n+  \/\/ Whether n is marked as a reduction node.\n+  bool is_marked_reduction(const Node* n) const { return _loop_reductions.test(n->_idx); }\n+  bool is_marked_reduction_loop() const { return !_loop_reductions.is_empty(); }\n+  \/\/ Are s1 and s2 reductions with a data path between them?\n+  bool is_marked_reduction_pair(Node* s1, Node* s2) const;\n+\n+private:\n+  \/\/ Whether n is a standard reduction operator.\n+  static bool is_reduction_operator(const Node* n);\n+  \/\/ Whether n is part of a reduction cycle via the 'input' edge index. To bound\n+  \/\/ the search, constrain the size of reduction cycles to LoopMaxUnroll.\n+  static bool in_reduction_cycle(const Node* n, uint input);\n+  \/\/ Reference to the i'th input node of n, commuting the inputs of binary nodes\n+  \/\/ whose edges have been swapped. Assumes n is a commutative operation.\n+  static Node* original_input(const Node* n, uint i);\n+};\n+\n+\/\/ Submodule of VLoopAnalyzer.\n+\/\/ Find the memory slices in the loop.\n+class VLoopMemorySlices : public StackObj {\n+private:\n+  const VLoop& _vloop;\n+\n+  GrowableArray<PhiNode*> _heads;\n+  GrowableArray<MemNode*> _tails;\n+\n+  const VLoop& vloop() const { return _vloop; }\n+\n+public:\n+  VLoopMemorySlices(Arena* arena, const VLoop& vloop) :\n+    _vloop(vloop),\n+    _heads(arena, 8, 0, nullptr),\n+    _tails(arena, 8, 0, nullptr) {};\n+  NONCOPYABLE(VLoopMemorySlices);\n+\n+  void find_memory_slices();\n+\n+  const GrowableArray<PhiNode*> &heads() const { return _heads; }\n+  const GrowableArray<MemNode*> &tails() const { return _tails; }\n+\n+  \/\/ Get all memory nodes of a slice, in reverse order\n+  void get_slice(PhiNode* head, MemNode* tail, GrowableArray<Node*> &slice) const;\n+\n+  bool same_memory_slice(MemNode* m1, MemNode* m2) const;\n+\n+#ifndef PRODUCT\n+  void print() const;\n+#endif\n+};\n+\n+\/\/ Submodule of VLoopAnalyzer.\n+\/\/ Finds all nodes in the body, and creates a mapping node->_idx to a body_idx.\n+\/\/ This mapping is used so that subsequent datastructures sizes only grow with\n+\/\/ the body size, and not the number of all nodes in the compilation.\n+class VLoopBody : public StackObj {\n+private:\n+  static constexpr char const* FAILURE_NODE_NOT_ALLOWED = \"encontered unhandled node\";\n+\n+  const VLoop& _vloop;\n+\n+  \/\/ Mapping body_idx -> Node*\n+  GrowableArray<Node*> _body;\n+\n+  \/\/ Mapping node->_idx -> body_idx\n+  \/\/ Can be very large, and thus lives in VSharedData\n+  GrowableArray<int>&  _body_idx;\n+\n+  const VLoop& vloop() const { return _vloop; }\n+\n+public:\n+  VLoopBody(Arena* arena, const VLoop& vloop, VSharedData& vshared) :\n+    _vloop(vloop),\n+    _body(arena, vloop.estimated_body_length(), 0, nullptr),\n+    _body_idx(vshared.node_idx_to_loop_body_idx()) {}\n+\n+  NONCOPYABLE(VLoopBody);\n+\n+  const char* construct();\n+  const GrowableArray<Node*>& body() const { return _body; }\n+  NOT_PRODUCT( void print() const; )\n+\n+  int bb_idx(const Node* n) const {\n+    assert(_vloop.in_bb(n), \"must be in basic block\");\n+    return _body_idx.at(n->_idx);\n+  }\n+\n+private:\n+  void set_bb_idx(Node* n, int i) {\n+    _body_idx.at_put_grow(n->_idx, i);\n+  }\n+};\n+\n+\/\/ Submodule of VLoopAnalyzer.\n+\/\/ Compute the vector element type for every node in the loop body.\n+\/\/ We need to do this to be able to vectorize the narrower integer\n+\/\/ types (byte, char, short). In the C2 IR, their operations are\n+\/\/ done with full int type with 4 byte precision (e.g. AddI, MulI).\n+\/\/ Example:  char a,b,c;  a = (char)(b + c);\n+\/\/ However, if we can prove the the upper bits are only truncated,\n+\/\/ and the lower bits for the narrower type computed correctly, we\n+\/\/ can compute the operations in the narrower type directly (e.g we\n+\/\/ perform the AddI or MulI with 1 or 2 bytes). This allows us to\n+\/\/ fit more operations in a vector, and can remove the otherwise\n+\/\/ required conversion (int <-> narrower type).\n+\/\/ We compute the types backwards (use-to-def): If all use nodes\n+\/\/ only require the lower bits, then the def node can do the operation\n+\/\/ with only the lower bits, and we propagate the narrower type to it.\n+class VLoopTypes : public StackObj {\n+private:\n+  const VLoop&     _vloop;\n+  const VLoopBody& _body;\n+\n+  \/\/ bb_idx -> vector element type\n+  GrowableArray<const Type*> _velt_type;\n+\n+  const VLoop& vloop() const    { return _vloop; }\n+  const VLoopBody& body() const { return _body; }\n+\n+public:\n+  VLoopTypes(Arena* arena,\n+             const VLoop& vloop,\n+             const VLoopBody& body) :\n+    _vloop(vloop),\n+    _body(body),\n+    _velt_type(arena, vloop.estimated_body_length(), 0, nullptr) {}\n+  NONCOPYABLE(VLoopTypes);\n+\n+  void compute_vector_element_type();\n+  NOT_PRODUCT( void print() const; )\n+\n+  const Type* velt_type(const Node* n) const {\n+    assert(vloop().in_bb(n), \"only call on nodes in loop\");\n+    const Type* t = _velt_type.at(body().bb_idx(n));\n+    assert(t != nullptr, \"must have type\");\n+    return t;\n+  }\n+\n+  BasicType velt_basic_type(const Node* n) const {\n+    return velt_type(n)->array_element_basic_type();\n+  }\n+\n+  int data_size(Node* s) const {\n+    int bsize = type2aelembytes(velt_basic_type(s));\n+    assert(bsize != 0, \"valid size\");\n+    return bsize;\n+  }\n+\n+  bool same_velt_type(Node* n1, Node* n2) const {\n+    const Type* vt1 = velt_type(n1);\n+    const Type* vt2 = velt_type(n2);\n+    if (vt1->basic_type() == T_INT && vt2->basic_type() == T_INT) {\n+      \/\/ Compare vectors element sizes for integer types.\n+      return data_size(n1) == data_size(n2);\n+    }\n+    return vt1 == vt2;\n+  }\n+\n+  int vector_width(const Node* n) const {\n+    BasicType bt = velt_basic_type(n);\n+    return MIN2(ABS(_vloop.iv_stride()), Matcher::max_vector_size(bt));\n+  }\n+\n+  int vector_width_in_bytes(const Node* n) const {\n+    BasicType bt = velt_basic_type(n);\n+    return vector_width(n) * type2aelembytes(bt);\n+  }\n+\n+private:\n+  void set_velt_type(Node* n, const Type* t) {\n+    assert(t != nullptr, \"cannot set nullptr\");\n+    assert(vloop().in_bb(n), \"only call on nodes in loop\");\n+    _velt_type.at_put(body().bb_idx(n), t);\n+  }\n+\n+  \/\/ Smallest type containing range of values\n+  const Type* container_type(Node* n) const;\n+};\n+\n+\/\/ Analyze the loop in preparation for auto-vectorization. This class is\n+\/\/ deliberately structured into many submodules, which are as independent\n+\/\/ as possible, though some submodules do require other submodules.\n+class VLoopAnalyzer : StackObj {\n+private:\n+  static constexpr char const* SUCCESS                       = \"success\";\n+  static constexpr char const* FAILURE_NO_MAX_UNROLL         = \"slp max unroll analysis required\";\n+  static constexpr char const* FAILURE_NO_REDUCTION_OR_STORE = \"no reduction and no store in loop\";\n+\n+  const VLoop&         _vloop;\n+\n+  \/\/ Arena for all submodules\n+  Arena                _arena;\n+\n+  \/\/ If all submodules are setup successfully, we set this flag at the\n+  \/\/ end of the constructor\n+  bool                 _success;\n+\n+  \/\/ Submodules\n+  VLoopReductions      _reductions;\n+  VLoopMemorySlices    _memory_slices;\n+  VLoopBody            _body;\n+  VLoopTypes           _types;\n+\n+public:\n+  VLoopAnalyzer(const VLoop& vloop, VSharedData &vshared) :\n+    _vloop(vloop),\n+    _arena(mtCompiler),\n+    _success(false),\n+    _reductions      (&_arena, vloop),\n+    _memory_slices   (&_arena, vloop),\n+    _body            (&_arena, vloop, vshared),\n+    _types           (&_arena, vloop, body())\n+  {\n+    _success = setup_submodules();\n+  }\n+  NONCOPYABLE(VLoopAnalyzer);\n+\n+  bool success() const { return _success; }\n+\n+  Arena* arena()       { return &_arena; }\n+\n+  \/\/ Read-only accessors for submodules\n+  const VLoop& vloop()                           const { return _vloop; }\n+  const VLoopReductions& reductions()            const { return _reductions; }\n+  const VLoopMemorySlices& memory_slices()       const { return _memory_slices; }\n+  const VLoopBody& body()                        const { return _body; }\n+  const VLoopTypes& types()                      const { return _types; }\n+\n+private:\n+  bool setup_submodules();\n+  const char* setup_submodules_helper();\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":308,"deletions":0,"binary":false,"changes":308,"status":"modified"}]}