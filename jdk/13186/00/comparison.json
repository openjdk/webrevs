{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n@@ -39,0 +37,1 @@\n+    public static final ClassDesc[] EMPTY_CLASSDESC = new ClassDesc[0];\n@@ -129,35 +128,0 @@\n-    \/**\n-     * Parses a method descriptor string, and return a list of field descriptor\n-     * strings, return type first, then parameter types\n-     *\n-     * @param descriptor the descriptor string\n-     * @return the list of types\n-     * @throws IllegalArgumentException if the descriptor string is not valid\n-     *\/\n-    static List<String> parseMethodDescriptor(String descriptor) {\n-        int cur = 0, end = descriptor.length();\n-        ArrayList<String> ptypes = new ArrayList<>();\n-        ptypes.add(null); \/\/placeholder for return type\n-\n-        if (cur >= end || descriptor.charAt(cur) != '(')\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-\n-        ++cur;  \/\/ skip '('\n-        while (cur < end && descriptor.charAt(cur) != ')') {\n-            int len = skipOverFieldSignature(descriptor, cur, end, false);\n-            if (len == 0)\n-                throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-            ptypes.add(descriptor.substring(cur, cur + len));\n-            cur += len;\n-        }\n-        if (cur >= end)\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-        ++cur;  \/\/ skip ')'\n-\n-        int rLen = skipOverFieldSignature(descriptor, cur, end, true);\n-        if (rLen == 0 || cur + rLen != end)\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-        ptypes.set(0, descriptor.substring(cur, cur + rLen));\n-        return ptypes;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantUtils.java","additions":2,"deletions":38,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-        return new MethodTypeDescImpl(returnDesc, paramDescs);\n+        return new MethodTypeDescImpl(returnDesc, List.of(paramDescs));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodTypeDesc.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,3 @@\n+import jdk.internal.access.JavaUtilCollectionAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -31,1 +34,1 @@\n-import java.util.Arrays;\n+import java.util.ArrayList;\n@@ -35,0 +38,1 @@\n+import static java.lang.constant.ConstantUtils.*;\n@@ -43,0 +47,2 @@\n+    private static final JavaUtilCollectionAccess JUCA = SharedSecrets.getJavaUtilCollectionAccess();\n+\n@@ -44,1 +50,1 @@\n-    private final ClassDesc[] argTypes;\n+    private final List<ClassDesc> argTypes;\n@@ -51,1 +57,1 @@\n-     * @param argTypes {@link ClassDesc}s describing the parameter types\n+     * @param trustedArgTypes trusted list of {@link ClassDesc}s describing the parameter types\n@@ -53,1 +59,1 @@\n-    MethodTypeDescImpl(ClassDesc returnType, ClassDesc[] argTypes) {\n+    MethodTypeDescImpl(ClassDesc returnType, List<ClassDesc> trustedArgTypes) {\n@@ -55,1 +61,1 @@\n-        this.argTypes = requireNonNull(argTypes);\n+        this.argTypes = requireNonNull(trustedArgTypes);\n@@ -57,1 +63,1 @@\n-        for (ClassDesc cr : argTypes)\n+        for (ClassDesc cr : trustedArgTypes) {\n@@ -60,0 +66,1 @@\n+        }\n@@ -72,4 +79,33 @@\n-        requireNonNull(descriptor);\n-        List<String> types = ConstantUtils.parseMethodDescriptor(descriptor);\n-        ClassDesc[] paramTypes = types.stream().skip(1).map(ClassDesc::ofDescriptor).toArray(ClassDesc[]::new);\n-        return new MethodTypeDescImpl(ClassDesc.ofDescriptor(types.get(0)), paramTypes);\n+        int cur = 0, end = descriptor.length(); \/\/ implicit null check\n+\n+        if (end == 0 || descriptor.charAt(0) != '(')\n+            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+        cur++; \/\/ skip '('\n+        if (cur >= end) {\n+            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+        }\n+        ArrayList<ClassDesc> ptypes;\n+        if (descriptor.charAt(cur) != ')') {\n+            ptypes = new ArrayList<>();\n+            do {\n+                int len = skipOverFieldSignature(descriptor, cur, end, false);\n+                if (len == 0)\n+                    throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+                ptypes.add(ClassDesc.ofDescriptor(descriptor.substring(cur, cur + len)));\n+                cur += len;\n+                if (cur >= end) {\n+                    throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+                }\n+            } while (descriptor.charAt(cur) != ')');\n+        } else {\n+            ptypes = null;\n+        }\n+        cur++; \/\/ skip ')'\n+\n+        int rLen = skipOverFieldSignature(descriptor, cur, end, true);\n+        if (rLen == 0 || cur + rLen != descriptor.length())\n+            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+\n+        ClassDesc retType = ClassDesc.ofDescriptor(descriptor.substring(cur));\n+        List<ClassDesc> types = ptypes == null ? List.of() : JUCA.listFromTrustedArray(ptypes.toArray());\n+        return new MethodTypeDescImpl(retType, types);\n@@ -85,1 +121,1 @@\n-        return argTypes.length;\n+        return argTypes.size();\n@@ -90,1 +126,1 @@\n-        return argTypes[index];\n+        return argTypes.get(index);\n@@ -95,1 +131,1 @@\n-        return List.of(argTypes);\n+        return argTypes;\n@@ -100,1 +136,1 @@\n-        return argTypes.clone();\n+        return argTypes.toArray(EMPTY_CLASSDESC);\n@@ -105,1 +141,1 @@\n-        return MethodTypeDesc.of(returnType, argTypes);\n+        return new MethodTypeDescImpl(returnType, argTypes);\n@@ -110,1 +146,3 @@\n-        ClassDesc[] newArgs = argTypes.clone();\n+        Objects.checkIndex(index, argTypes.size());\n+\n+        ClassDesc[] newArgs = argTypes.toArray(EMPTY_CLASSDESC);\n@@ -112,1 +150,1 @@\n-        return MethodTypeDesc.of(returnType, newArgs);\n+        return MethodTypeDesc.of(returnType, newArgs); \/\/ must be revalidated, nulls etc.\n@@ -117,2 +155,2 @@\n-        Objects.checkIndex(start, argTypes.length);\n-        Objects.checkFromToIndex(start, end, argTypes.length);\n+        Objects.checkFromToIndex(start, end, argTypes.size());\n+        if (start == end) return this;\n@@ -120,1 +158,2 @@\n-        ClassDesc[] newArgs = new ClassDesc[argTypes.length - (end - start)];\n+        ClassDesc[] argTypes = this.argTypes.toArray(EMPTY_CLASSDESC);\n+        Object[] newArgs = new Object[argTypes.length - (end - start)];\n@@ -123,1 +162,1 @@\n-        return MethodTypeDesc.of(returnType, newArgs);\n+        return new MethodTypeDescImpl(returnType, JUCA.listFromTrustedArray(newArgs)); \/\/ can skip revalidation\n@@ -128,4 +167,4 @@\n-        if (pos < 0 || pos > argTypes.length)\n-            throw new IndexOutOfBoundsException(pos);\n-        ClassDesc[] newArgs = new ClassDesc[argTypes.length + paramTypes.length];\n-        System.arraycopy(argTypes, 0, newArgs, 0, pos);\n+        Objects.checkIndex(pos, argTypes.size() + 1);\n+\n+        ClassDesc[] newArgs = argTypes.toArray(new ClassDesc[argTypes.size() + paramTypes.length]);\n+        System.arraycopy(newArgs, pos, newArgs, pos + paramTypes.length, argTypes.size() - pos);\n@@ -133,2 +172,2 @@\n-        System.arraycopy(argTypes, pos, newArgs, pos+paramTypes.length, argTypes.length - pos);\n-        return MethodTypeDesc.of(returnType, newArgs);\n+\n+        return MethodTypeDesc.of(returnType, newArgs); \/\/ must be revalidated, nulls etc.\n@@ -175,1 +214,1 @@\n-               && Arrays.equals(argTypes, constant.argTypes);\n+               && Objects.equals(argTypes, constant.argTypes);\n@@ -181,1 +220,1 @@\n-        result = 31 * result + Arrays.hashCode(argTypes);\n+        result = 31 * result + Objects.hashCode(argTypes);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodTypeDescImpl.java","additions":69,"deletions":30,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.util.ArrayList;\n@@ -34,2 +35,1 @@\n-import static java.lang.constant.ConstantDescs.CD_int;\n-import static java.lang.constant.ConstantDescs.CD_void;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -38,2 +38,1 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.fail;\n+import static org.testng.Assert.*;\n@@ -43,0 +42,1 @@\n+ * @bug 8304932\n@@ -107,1 +107,1 @@\n-        try {\n+        expectThrows(NullPointerException.class, () -> {\n@@ -109,4 +109,1 @@\n-            fail(\"should fail with NPE\");\n-        } catch (NullPointerException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -136,0 +133,9 @@\n+\n+            \/\/ drop multiple params\n+            for (int j = i; j < paramTypes.length; j++) {\n+                var t = new ArrayList<>(Arrays.asList(paramTypes));\n+                t.subList(i, j).clear();\n+                MethodTypeDesc multiDrop = mtDesc.dropParameterTypes(i, j);\n+                assertEquals(multiDrop, MethodTypeDesc.of(returnType, t.toArray(ClassDesc[]::new)));\n+                testMethodTypeDesc(multiDrop, mt.dropParameterTypes(i, j));\n+            }\n@@ -151,0 +157,15 @@\n+\n+            \/\/ add multiple params\n+            ClassDesc[] addition = {CD_int, CD_String};\n+            var a = new ArrayList<>(Arrays.asList(paramTypes));\n+            a.addAll(i, Arrays.asList(addition));\n+\n+            MethodTypeDesc newDesc = mtDesc.insertParameterTypes(i, addition);\n+            assertEquals(newDesc, MethodTypeDesc.of(returnType, a.toArray(ClassDesc[]::new)));\n+            testMethodTypeDesc(newDesc, mt.insertParameterTypes(i, Arrays.stream(addition).map(d -> {\n+                try {\n+                    return (Class<?>) d.resolveConstantDesc(LOOKUP);\n+                } catch (ReflectiveOperationException ex) {\n+                    throw new RuntimeException(ex);\n+                }\n+            }).toArray(Class[]::new)));\n@@ -161,1 +182,1 @@\n-        try {\n+        expectThrows(IndexOutOfBoundsException.class, () -> {\n@@ -163,4 +184,1 @@\n-            fail(\"pos < 0 should have failed\");\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -168,1 +186,1 @@\n-        try {\n+        expectThrows(IndexOutOfBoundsException.class, () -> {\n@@ -170,4 +188,1 @@\n-            fail(\"pos > current arguments length should have failed\");\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -175,1 +190,1 @@\n-        try {\n+        expectThrows(IllegalArgumentException.class, () -> {\n@@ -180,4 +195,1 @@\n-            fail(\"shouldn't allow parameters with class descriptor CD_void\");\n-        } catch (IllegalArgumentException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -185,1 +197,1 @@\n-        try {\n+        expectThrows(NullPointerException.class, () -> {\n@@ -188,4 +200,1 @@\n-            fail(\"should fail with NPE\");\n-        } catch (NullPointerException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -193,1 +202,1 @@\n-        try {\n+        expectThrows(NullPointerException.class, () -> {\n@@ -198,4 +207,1 @@\n-            fail(\"should fail with NPE\");\n-        } catch (NullPointerException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -209,1 +215,2 @@\n-        try {\n+\n+        expectThrows(IndexOutOfBoundsException.class, () -> {\n@@ -211,4 +218,1 @@\n-            fail(\"start index < 0 should have failed\");\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -216,1 +220,1 @@\n-        try {\n+        expectThrows(IndexOutOfBoundsException.class, () -> {\n@@ -218,4 +222,1 @@\n-            fail(\"start index = arguments.length should have failed\");\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -223,1 +224,1 @@\n-        try {\n+        expectThrows(IndexOutOfBoundsException.class, () -> {\n@@ -225,4 +226,1 @@\n-            fail(\"start index > arguments.length should have failed\");\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -230,1 +228,1 @@\n-        try {\n+        expectThrows(IndexOutOfBoundsException.class, () -> {\n@@ -232,4 +230,1 @@\n-            fail(\"end index > arguments.length should have failed\");\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -237,1 +232,1 @@\n-        try {\n+        expectThrows(IndexOutOfBoundsException.class, () -> {\n@@ -239,4 +234,1 @@\n-            fail(\"start index > end index should have failed\");\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -263,1 +255,1 @@\n-            try {\n+            expectThrows(IllegalArgumentException.class, () -> {\n@@ -265,5 +257,1 @@\n-                fail(d);\n-            }\n-            catch (IllegalArgumentException e) {\n-                \/\/ good\n-            }\n+            });\n@@ -273,1 +261,1 @@\n-        try {\n+        expectThrows(NullPointerException.class, () -> {\n@@ -275,4 +263,1 @@\n-            fail(\"should fail with NPE\");\n-        } catch (NullPointerException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -282,1 +267,1 @@\n-        try {\n+        expectThrows(IllegalArgumentException.class, () -> {\n@@ -284,5 +269,1 @@\n-            fail(\"can't reach here\");\n-        }\n-        catch (IllegalArgumentException e) {\n-            \/\/ good\n-        }\n+        });\n@@ -290,1 +271,1 @@\n-        try {\n+        expectThrows(NullPointerException.class, () -> {\n@@ -292,5 +273,1 @@\n-            fail(\"ClassDesc array should not be null\");\n-        }\n-        catch (NullPointerException e) {\n-            \/\/ good\n-        }\n+        });\n@@ -298,1 +275,1 @@\n-        try {\n+        expectThrows(NullPointerException.class, () -> {\n@@ -302,5 +279,12 @@\n-            fail(\"ClassDesc should not be null\");\n-        }\n-        catch (NullPointerException e) {\n-            \/\/ good\n-        }\n+        });\n+    }\n+\n+    public void testImmutability() {\n+        ClassDesc[] args = {CD_Object, CD_int};\n+        var mtd = MethodTypeDesc.of(CD_void, args);\n+\n+        args[1] = CD_void;\n+        assertEquals(mtd, MethodTypeDesc.of(CD_void, CD_Object, CD_int));\n+\n+        mtd.parameterArray()[1] = CD_void;\n+        assertEquals(mtd, MethodTypeDesc.of(CD_void, CD_Object, CD_int));\n","filename":"test\/jdk\/java\/lang\/constant\/MethodTypeDescTest.java","additions":73,"deletions":89,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.constant;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+\n+\/**\n+ * Performance of different MethodTypeDesc factory methods\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 3, time = 2)\n+@Measurement(iterations = 6, time = 1)\n+@Fork(1)\n+@State(Scope.Benchmark)\n+public class MethodTypeDescConstruct {\n+    public enum Kind {\n+        GENERIC(CD_Object, CD_Object, CD_Object),\n+        VOID(CD_void),\n+        NO_PARAM(CD_Class.arrayType()),\n+        ARBITRARY(CD_int, CD_String, CD_String.arrayType(), CD_double.arrayType());\n+\n+        final String desc;\n+        final ClassDesc ret;\n+        final ClassDesc[] args;\n+\n+        Kind(ClassDesc ret, ClassDesc... args) {\n+            this.desc = MethodTypeDesc.of(ret, args).descriptorString();\n+            this.ret = ret;\n+            this.args = args;\n+        }\n+    }\n+\n+    @Param\n+    public Kind kind;\n+\n+    @Benchmark\n+    public MethodTypeDesc ofDescriptorBench() {\n+        return MethodTypeDesc.ofDescriptor(kind.desc);\n+    }\n+\n+    @Benchmark\n+    public MethodTypeDesc ofBench() {\n+        return MethodTypeDesc.of(kind.ret, kind.args);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/constant\/MethodTypeDescConstruct.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"}]}