{"files":[{"patch":"@@ -98,0 +98,1 @@\n+  virtual bool is_arithmetic_cmp() const { return false; }\n@@ -123,1 +124,1 @@\n-\n+  virtual bool is_arithmetic_cmp() const { return false; }\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+  virtual bool is_arithmetic_cmp() const { return false; }\n","filename":"src\/hotspot\/share\/opto\/mathexactnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -621,1 +621,24 @@\n-  return this;\n+  if (!is_arithmetic_cmp()) {\n+    return this; \/\/ No progress\n+  }\n+  \/\/ (Cmp (Cast P1) P2) is identity to (Cmp P1 P2), we use latter form because\n+  \/\/ deduplication is generally profitable than refining type\n+  for (uint i = 1; i < req(); ++i) {\n+    Node* n = in(i);\n+    if (n == nullptr || phase->type(n) == Type::TOP) {\n+      return this; \/\/ Missing inputs are TOP\n+    }\n+    Node* uncast = n->uncast();\n+    if (uncast != n) {\n+      for (DUIterator_Fast kmax, k = uncast->fast_outs(kmax); k < kmax; k++) {\n+        Node* use = uncast->fast_out(k);\n+        if (use->Opcode() == Opcode()) {\n+          uint other_in = i == 1 ? 2 : 1;\n+          if (use->in(other_in) == in(other_in)) {\n+            return use;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return this; \/\/ No progress\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+  virtual bool is_arithmetic_cmp() const { return true; }\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+  virtual bool is_arithmetic_cmp() const { return false; }\n","filename":"src\/hotspot\/share\/opto\/subtypenode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1441,0 +1441,1 @@\n+  virtual bool is_arithmetic_cmp() const { return false; }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -32,1 +33,1 @@\n- * @bug 8278228\n+ * @bug 8278228 8304049\n@@ -60,0 +61,15 @@\n+    @Test\n+    @IR(counts = { IRNode.IF, \"1\" })\n+    public static void test1(int a, int b) {\n+        if (b != 0) {\n+            int_field = 0x42;\n+        } else {\n+            int_field = 42;\n+        }\n+        if (b != 0) {\n+            int_field = 0x42;\n+        } else {\n+            int_field = 42;\n+        }\n+    }\n+\n@@ -65,0 +81,6 @@\n+\n+    @Run(test = \"test1\")\n+    @Warmup(1) \/\/ So C2 can't rely on profile data\n+    public static void test_runner1() {\n+        test1(0, 1);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestBackToBackIfs.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"}]}