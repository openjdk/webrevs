{"files":[{"patch":"@@ -83,0 +83,1 @@\n+        return UseZvbb;\n@@ -85,0 +86,3 @@\n+        if (bt != T_INT && bt != T_LONG) {\n+          return false;\n+        }\n@@ -3416,21 +3420,0 @@\n-\/\/\n-\/\/ Following rotate instruct's are shared by vectorization (in SLP, superword.cpp) and Vector API.\n-\/\/\n-\/\/ Rotate behaviour in vectorization is defined by java API, which includes:\n-\/\/  1. Integer.rorateRight, Integer.rorateLeft.\n-\/\/     `rotation by any multiple of 32 is a no-op, so all but the last five bits of the rotation distance can be ignored`.\n-\/\/  2. Long.rorateRight, Long.rorateLeft.\n-\/\/     `rotation by any multiple of 64 is a no-op, so all but the last six bits of the rotation distance can be ignored`.\n-\/\/\n-\/\/ Rotate behaviour in Vector API is defined as below, e.g.\n-\/\/  1. For Byte ROR, `a ROR b` is: (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))))\n-\/\/  2. For Short ROR, `a ROR b` is: (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))))\n-\/\/  3. For Integer ROR, `a ROR b` is: Integer.rotateRight(a, ((int)b))\n-\/\/  4. For Long ROR, `a ROR b` is: Long.rotateRight(a, ((int)b))\n-\/\/\n-\/\/ Basically, the behaviour between vectorization and Vector API is the same for Long and Integer, except that Vector API\n-\/\/ also supports Byte and Short rotation. But we can still share the intrinsics between vectorization and Vector API.\n-\/\/\n-\/\/ NOTE: As vror.vi encodes 6-bits immediate rotate amount, which is different from other vector-immediate instructions,\n-\/\/       implementation of vector rotation for long and other types can be unified.\n-\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":4,"deletions":21,"binary":false,"changes":25,"status":"modified"}]}