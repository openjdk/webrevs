{"files":[{"patch":"@@ -83,0 +83,1 @@\n+        return UseZvbb;\n@@ -85,0 +86,3 @@\n+        if (bt != T_INT && bt != T_LONG) {\n+          return false;\n+        }\n@@ -3416,21 +3420,0 @@\n-\/\/\n-\/\/ Following rotate instruct's are shared by vectorization (in SLP, superword.cpp) and Vector API.\n-\/\/\n-\/\/ Rotate behaviour in vectorization is defined by java API, which includes:\n-\/\/  1. Integer.rorateRight, Integer.rorateLeft.\n-\/\/     `rotation by any multiple of 32 is a no-op, so all but the last five bits of the rotation distance can be ignored`.\n-\/\/  2. Long.rorateRight, Long.rorateLeft.\n-\/\/     `rotation by any multiple of 64 is a no-op, so all but the last six bits of the rotation distance can be ignored`.\n-\/\/\n-\/\/ Rotate behaviour in Vector API is defined as below, e.g.\n-\/\/  1. For Byte ROR, `a ROR b` is: (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))))\n-\/\/  2. For Short ROR, `a ROR b` is: (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))))\n-\/\/  3. For Integer ROR, `a ROR b` is: Integer.rotateRight(a, ((int)b))\n-\/\/  4. For Long ROR, `a ROR b` is: Long.rotateRight(a, ((int)b))\n-\/\/\n-\/\/ Basically, the behaviour between vectorization and Vector API is the same for Long and Integer, except that Vector API\n-\/\/ also supports Byte and Short rotation. But we can still share the intrinsics between vectorization and Vector API.\n-\/\/\n-\/\/ NOTE: As vror.vi encodes 6-bits immediate rotate amount, which is different from other vector-immediate instructions,\n-\/\/       implementation of vector rotation for long and other types can be unified.\n-\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":4,"deletions":21,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8286847\n+ * @bug 8286847 8353600\n@@ -29,2 +29,2 @@\n- * @library \/test\/lib\n- * @run main\/othervm -XX:-TieredCompilation -XX:CompileCommand=compileonly,TestRotateByteAndShortVector::testRotate* -Xbatch TestRotateByteAndShortVector\n+ * @library \/test\/lib \/\n+ * @run main\/othervm TestRotateByteAndShortVector\n@@ -35,0 +35,1 @@\n+import compiler.lib.ir_framework.*;\n@@ -52,21 +53,1 @@\n-        System.out.println(\"warmup\");\n-        warmup();\n-\n-        System.out.println(\"Testing...\");\n-        runRotateLeftByteTest();\n-        runRotateRightByteTest();\n-        runRotateLeftShortTest();\n-        runRotateRightShortTest();\n-\n-        System.out.println(\"PASSED\");\n-    }\n-\n-    static void warmup() {\n-        random.nextBytes(arrByte);\n-        randomShorts();\n-        for (int i = 0; i < ITERS; i++) {\n-            testRotateLeftByte(rolByte, arrByte, i);\n-            testRotateRightByte(rorByte, arrByte, i);\n-            testRotateLeftShort(rolShort, arrShort, i);\n-            testRotateRightShort(rorShort, arrShort, i);\n-        }\n+        TestFramework.run();\n@@ -81,0 +62,1 @@\n+    @Run(test = { \"testRotateLeftByte\" })\n@@ -94,0 +76,1 @@\n+    @Run(test = { \"testRotateRightByte\" })\n@@ -107,0 +90,1 @@\n+    @Run(test = { \"testRotateLeftShort\" })\n@@ -120,0 +104,1 @@\n+    @Run(test = { \"testRotateRightShort\" })\n@@ -133,0 +118,3 @@\n+    @Test\n+    @IR(failOn = { IRNode.ROTATE_LEFT_V })\n+    @IR(failOn = { IRNode.ROTATE_RIGHT_V })\n@@ -139,0 +127,3 @@\n+    @Test\n+    @IR(failOn = { IRNode.ROTATE_LEFT_V })\n+    @IR(failOn = { IRNode.ROTATE_RIGHT_V })\n@@ -145,0 +136,3 @@\n+    @Test\n+    @IR(failOn = { IRNode.ROTATE_LEFT_V })\n+    @IR(failOn = { IRNode.ROTATE_RIGHT_V })\n@@ -151,0 +145,3 @@\n+    @Test\n+    @IR(failOn = { IRNode.ROTATE_LEFT_V })\n+    @IR(failOn = { IRNode.ROTATE_RIGHT_V })\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRotateByteAndShortVector.java","additions":21,"deletions":24,"binary":false,"changes":45,"status":"modified"}]}