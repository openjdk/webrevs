{"files":[{"patch":"@@ -2288,27 +2288,0 @@\n-\/\/ On Neoverse, MSUB uses the same ALU with other instructions (e.g. SDIV).\n-\/\/ The combination of MUL\/SUB can utilize multiple ALUs,\n-\/\/ and can be somewhat faster than MSUB.\n-void MacroAssembler::msub(Register Rd, Register Rn, Register Rm, Register Ra)\n-{\n-  if (VM_Version::supports_a53mac() && Ra != zr)\n-    nop();\n-  if (VM_Version::is_neoverse()) {\n-    mul(rscratch1, Rn, Rm);\n-    sub(Rd, Ra, rscratch1);\n-  } else {\n-    Assembler::msub(Rd, Rn, Rm, Ra);\n-  }\n-}\n-\n-void MacroAssembler::msubw(Register Rd, Register Rn, Register Rm, Register Ra)\n-{\n-  if (VM_Version::supports_a53mac() && Ra != zr)\n-    nop();\n-  if (VM_Version::is_neoverse()) {\n-    mulw(rscratch1, Rn, Rm);\n-    subw(Rd, Ra, rscratch1);\n-  } else {\n-    Assembler::msubw(Rd, Rn, Rm, Ra);\n-  }\n-}\n-\n@@ -2339,1 +2312,1 @@\n-    msubw(result, scratch, rb, ra);\n+    Assembler::msubw(result, scratch, rb, ra);\n@@ -2369,1 +2342,1 @@\n-    msub(result, scratch, rb, ra);\n+    Assembler::msub(result, scratch, rb, ra);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":2,"deletions":29,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -440,1 +440,1 @@\n-  WRAP(madd) WRAP(maddw)\n+  WRAP(madd) WRAP(msub) WRAP(maddw) WRAP(msubw)\n@@ -445,3 +445,0 @@\n-  void msub(Register Rd, Register Rn, Register Rm, Register Ra);\n-  void msubw(Register Rd, Register Rn, Register Rm, Register Ra);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,1 +215,7 @@\n-  if (is_neoverse()) {\n+  \/\/ Neoverse\n+  \/\/   N1: 0xd0c\n+  \/\/   N2: 0xd49\n+  \/\/   V1: 0xd40\n+  \/\/   V2: 0xd4f\n+  if (_cpu == CPU_ARM && (model_is(0xd0c) || model_is(0xd49) ||\n+                          model_is(0xd40) || model_is(0xd4f))) {\n@@ -244,1 +250,4 @@\n-  if (is_neoverse_v_series()) {\n+  \/\/ Neoverse\n+  \/\/   V1: 0xd40\n+  \/\/   V2: 0xd4f\n+  if (_cpu == CPU_ARM && (model_is(0xd40) || model_is(0xd4f))) {\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -117,7 +117,0 @@\n-enum Neoverse_CPU_Model {\n-    CPU_MODEL_NEOVERSE_N1 = 0xd0c,\n-    CPU_MODEL_NEOVERSE_N2 = 0xd49,\n-    CPU_MODEL_NEOVERSE_V1 = 0xd40,\n-    CPU_MODEL_NEOVERSE_V2 = 0xd4f,\n-};\n-\n@@ -166,17 +159,0 @@\n-\n-  static bool is_neoverse() {\n-    switch(_model) {\n-      case CPU_MODEL_NEOVERSE_N1:\n-      case CPU_MODEL_NEOVERSE_N2:\n-      case CPU_MODEL_NEOVERSE_V1:\n-      case CPU_MODEL_NEOVERSE_V2:\n-        return true;\n-      default:\n-        return false;\n-    }\n-  }\n-\n-  static bool is_neoverse_v_series() {\n-    return (model_is(CPU_MODEL_NEOVERSE_V1) || model_is(CPU_MODEL_NEOVERSE_V2));\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"}]}