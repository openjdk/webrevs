{"files":[{"patch":"@@ -35,0 +35,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -45,0 +46,2 @@\n+  GrowableArray<InstanceKlass*> _klasses;\n+\n@@ -51,4 +54,1 @@\n-    : _class_name_pattern(class_name_pattern),\n-      _method_name_pattern(method_name_pattern),\n-      _method_signature_pattern(method_signature_pattern),\n-      _always_print_class_name(always_print_class_name),\n+    : _always_print_class_name(always_print_class_name),\n@@ -69,0 +69,21 @@\n+\n+    if (has_mode(_flags, PRINT_CLASS_DETAILS)) {\n+      _always_print_class_name = true;\n+    }\n+\n+    _class_name_pattern = copy_pattern(class_name_pattern);\n+    _method_name_pattern = copy_pattern(method_name_pattern);\n+    _method_signature_pattern = copy_pattern(method_signature_pattern);\n+  }\n+\n+  static const char* copy_pattern(const char* pattern) {\n+    if (pattern == nullptr) {\n+      return nullptr;\n+    }\n+    char* copy = ResourceArea::strdup(pattern);\n+    for (char* p = copy; *p; p++) {\n+      if (*p == '.') {\n+        *p = '\/';\n+      }\n+    }\n+    return copy;\n@@ -75,1 +96,1 @@\n-    print_instance_klass(InstanceKlass::cast(k));\n+    _klasses.append(InstanceKlass::cast(k));\n@@ -78,0 +99,8 @@\n+  void print() {\n+    _klasses.sort(compare_klasses_alphadetically);\n+    for (int i = 0; i < _klasses.length(); i++) {\n+      print_instance_klass(_klasses.at(i));\n+    }\n+  }\n+\n+\n@@ -82,0 +111,28 @@\n+  static int compare_klasses_alphadetically(InstanceKlass** a, InstanceKlass** b) {\n+    return compare_symbols_alphadetically((*a)->name(), (*b)->name());\n+  }\n+\n+  static int compare_methods_alphadetically(const void* a, const void* b) {\n+    Method* ma = *(Method**)a;\n+    Method* mb = *(Method**)b;\n+    int n = compare_symbols_alphadetically(ma->name(), mb->name());\n+    if (n == 0) {\n+      n = compare_symbols_alphadetically(ma->signature(), mb->signature());\n+    }\n+    return n;\n+  }\n+\n+  static int compare_symbols_alphadetically(Symbol* a, Symbol *b) {\n+    if (a == b) {\n+      return 0;\n+    }\n+    if (a != nullptr && b == nullptr) {\n+      return 1;\n+    }\n+    if (a == nullptr && b != nullptr) {\n+      return -1;\n+    }\n+\n+    return strcmp(a->as_C_string(), b->as_C_string());\n+  }\n+\n@@ -83,1 +140,2 @@\n-    _st->print(\"[%3d] \" INTPTR_FORMAT \" class %s \", _num++, p2i(ik), ik->name()->as_C_string());\n+    _st->print(\"[%3d] \" INTPTR_FORMAT \" class: %s mirror: \" INTPTR_FORMAT \" \", _num++,\n+               p2i(ik), ik->name()->as_C_string(), p2i(ik->java_mirror()));\n@@ -101,0 +159,10 @@\n+      if (has_mode(_flags, ClassPrinter::PRINT_CLASS_DETAILS)) {\n+        _st->print(\"InstanceKlass: \");\n+        ik->print_on(_st);\n+        oop mirror = ik->java_mirror();\n+        if (mirror != nullptr) {\n+        _st->print(\"\\nJava mirror oop for %s: \", ik->name()->as_C_string());\n+          mirror->print_on(_st);\n+        }\n+      }\n+\n@@ -106,0 +174,1 @@\n+        Method** sorted_methods = NEW_RESOURCE_ARRAY(Method*, len);\n@@ -107,1 +176,7 @@\n-          Method* m = ik->methods()->at(index);\n+          sorted_methods[index] = ik->methods()->at(index);\n+        }\n+\n+        qsort(sorted_methods, len, sizeof(Method*), compare_methods_alphadetically);\n+\n+        for (int index = 0; index < len; index++) {\n+          Method* m = sorted_methods[index];\n@@ -128,1 +203,0 @@\n-    bool print_codes = has_mode(_flags, ClassPrinter::PRINT_BYTECODE);\n@@ -132,1 +206,6 @@\n-    if (print_codes) {\n+\n+    if (has_mode(_flags, ClassPrinter::PRINT_METHOD_DETAILS)) {\n+      m->print_on(_st);\n+    }\n+\n+    if (has_mode(_flags, ClassPrinter::PRINT_BYTECODE)) {\n@@ -145,0 +224,2 @@\n+  os->print_cr(\"   0x%02x  - print details of the C++ and Java objects that represent classes\",  PRINT_CLASS_DETAILS);\n+  os->print_cr(\"   0x%02x  - print details of the C++ objects that represent methods\",  PRINT_METHOD_DETAILS);\n@@ -149,0 +230,1 @@\n+  ResourceMark rm;\n@@ -151,0 +233,1 @@\n+  closure.print();\n@@ -177,0 +260,1 @@\n+  closure.print();\n","filename":"src\/hotspot\/share\/classfile\/classPrinter.cpp","additions":93,"deletions":9,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,2 @@\n+    PRINT_CLASS_DETAILS     = 1 << 5, \/\/ print details of the C++ and Java objects that represent classes\n+    PRINT_METHOD_DETAILS    = 1 << 6, \/\/ print details of the C++ that represent methods\n","filename":"src\/hotspot\/share\/classfile\/classPrinter.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}