{"files":[{"patch":"@@ -31,1 +31,1 @@\n-#include \"oops\/klass.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n@@ -34,0 +34,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -45,0 +46,2 @@\n+  GrowableArray<InstanceKlass*> _klasses;\n+\n@@ -51,4 +54,1 @@\n-    : _class_name_pattern(class_name_pattern),\n-      _method_name_pattern(method_name_pattern),\n-      _method_signature_pattern(method_signature_pattern),\n-      _always_print_class_name(always_print_class_name),\n+    : _always_print_class_name(always_print_class_name),\n@@ -69,0 +69,21 @@\n+\n+    if (has_mode(_flags, PRINT_CLASS_DETAILS)) {\n+      _always_print_class_name = true;\n+    }\n+\n+    _class_name_pattern = copy_pattern(class_name_pattern);\n+    _method_name_pattern = copy_pattern(method_name_pattern);\n+    _method_signature_pattern = copy_pattern(method_signature_pattern);\n+  }\n+\n+  static const char* copy_pattern(const char* pattern) {\n+    if (pattern == nullptr) {\n+      return nullptr;\n+    }\n+    char* copy = ResourceArea::strdup(pattern);\n+    for (char* p = copy; *p; p++) {\n+      if (*p == '.') {\n+        *p = '\/';\n+      }\n+    }\n+    return copy;\n@@ -75,1 +96,4 @@\n-    print_instance_klass(InstanceKlass::cast(k));\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    if (ik->is_loaded() && ik->name()->is_star_match(_class_name_pattern)) {\n+      _klasses.append(ik);\n+    }\n@@ -78,0 +102,8 @@\n+  void print() {\n+    _klasses.sort(compare_klasses_alphabetically);\n+    for (int i = 0; i < _klasses.length(); i++) {\n+      print_instance_klass(_klasses.at(i));\n+    }\n+  }\n+\n+\n@@ -82,0 +114,28 @@\n+  static int compare_klasses_alphabetically(InstanceKlass** a, InstanceKlass** b) {\n+    return compare_symbols_alphabetically((*a)->name(), (*b)->name());\n+  }\n+\n+  static int compare_methods_alphabetically(const void* a, const void* b) {\n+    Method* ma = *(Method**)a;\n+    Method* mb = *(Method**)b;\n+    int n = compare_symbols_alphabetically(ma->name(), mb->name());\n+    if (n == 0) {\n+      n = compare_symbols_alphabetically(ma->signature(), mb->signature());\n+    }\n+    return n;\n+  }\n+\n+  static int compare_symbols_alphabetically(Symbol* a, Symbol *b) {\n+    if (a == b) {\n+      return 0;\n+    }\n+    if (a != nullptr && b == nullptr) {\n+      return 1;\n+    }\n+    if (a == nullptr && b != nullptr) {\n+      return -1;\n+    }\n+\n+    return strcmp(a->as_C_string(), b->as_C_string());\n+  }\n+\n@@ -83,1 +143,2 @@\n-    _st->print(\"[%3d] \" INTPTR_FORMAT \" class %s \", _num++, p2i(ik), ik->name()->as_C_string());\n+    _st->print(\"[%3d] \" INTPTR_FORMAT \" class: %s mirror: \" INTPTR_FORMAT \" \", _num++,\n+               p2i(ik), ik->name()->as_C_string(), p2i(ik->java_mirror()));\n@@ -89,6 +150,18 @@\n-    if (ik->is_loaded() && ik->name()->is_star_match(_class_name_pattern)) {\n-      ResourceMark rm;\n-      if (_has_printed_methods) {\n-        \/\/ We have printed some methods in the previous class.\n-        \/\/ Print a new line to separate the two classes\n-        _st->cr();\n+    ResourceMark rm;\n+    if (_has_printed_methods) {\n+      \/\/ We have printed some methods in the previous class.\n+      \/\/ Print a new line to separate the two classes\n+      _st->cr();\n+    }\n+    _has_printed_methods = false;\n+    if (_always_print_class_name) {\n+      print_klass_name(ik);\n+    }\n+\n+    if (has_mode(_flags, ClassPrinter::PRINT_CLASS_DETAILS)) {\n+      _st->print(\"InstanceKlass: \");\n+      ik->print_on(_st);\n+      oop mirror = ik->java_mirror();\n+      if (mirror != nullptr) {\n+        _st->print(\"\\nJava mirror oop for %s: \", ik->name()->as_C_string());\n+        mirror->print_on(_st);\n@@ -96,3 +169,10 @@\n-      _has_printed_methods = false;\n-      if (_always_print_class_name) {\n-        print_klass_name(ik);\n+    }\n+\n+    if (has_mode(_flags, ClassPrinter::PRINT_METHOD_NAME)) {\n+      bool print_codes = has_mode(_flags, ClassPrinter::PRINT_BYTECODE);\n+      int len = ik->methods()->length();\n+      int num_methods_printed = 0;\n+\n+      Method** sorted_methods = NEW_RESOURCE_ARRAY(Method*, len);\n+      for (int index = 0; index < len; index++) {\n+        sorted_methods[index] = ik->methods()->at(index);\n@@ -101,12 +181,9 @@\n-      if (has_mode(_flags, ClassPrinter::PRINT_METHOD_NAME)) {\n-        bool print_codes = has_mode(_flags, ClassPrinter::PRINT_BYTECODE);\n-        int len = ik->methods()->length();\n-        int num_methods_printed = 0;\n-\n-        for (int index = 0; index < len; index++) {\n-          Method* m = ik->methods()->at(index);\n-          if (match(_method_name_pattern, m->name()) &&\n-              match(_method_signature_pattern, m->signature())) {\n-            if (print_codes && num_methods_printed++ > 0) {\n-              _st->cr();\n-            }\n+      qsort(sorted_methods, len, sizeof(Method*), compare_methods_alphabetically);\n+\n+      for (int index = 0; index < len; index++) {\n+        Method* m = sorted_methods[index];\n+        if (match(_method_name_pattern, m->name()) &&\n+            match(_method_signature_pattern, m->signature())) {\n+          if (print_codes && num_methods_printed++ > 0) {\n+            _st->cr();\n+          }\n@@ -114,5 +191,3 @@\n-            if (_has_printed_methods == false) {\n-              if (!_always_print_class_name) {\n-                print_klass_name(ik);\n-              }\n-              _has_printed_methods = true;\n+          if (_has_printed_methods == false) {\n+            if (!_always_print_class_name) {\n+              print_klass_name(ik);\n@@ -120,1 +195,1 @@\n-            print_method(m);\n+            _has_printed_methods = true;\n@@ -122,0 +197,1 @@\n+          print_method(m);\n@@ -128,1 +204,0 @@\n-    bool print_codes = has_mode(_flags, ClassPrinter::PRINT_BYTECODE);\n@@ -132,1 +207,6 @@\n-    if (print_codes) {\n+\n+    if (has_mode(_flags, ClassPrinter::PRINT_METHOD_DETAILS)) {\n+      m->print_on(_st);\n+    }\n+\n+    if (has_mode(_flags, ClassPrinter::PRINT_BYTECODE)) {\n@@ -145,0 +225,2 @@\n+  os->print_cr(\"   0x%02x  - print details of the C++ and Java objects that represent classes\",  PRINT_CLASS_DETAILS);\n+  os->print_cr(\"   0x%02x  - print details of the C++ objects that represent methods\",  PRINT_METHOD_DETAILS);\n@@ -149,0 +231,1 @@\n+  ResourceMark rm;\n@@ -151,0 +234,1 @@\n+  closure.print();\n@@ -177,0 +261,1 @@\n+  closure.print();\n","filename":"src\/hotspot\/share\/classfile\/classPrinter.cpp","additions":121,"deletions":36,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,2 @@\n+    PRINT_CLASS_DETAILS     = 1 << 5, \/\/ print details of the C++ and Java objects that represent classes\n+    PRINT_METHOD_DETAILS    = 1 << 6, \/\/ print details of the C++ objects that represent methods\n","filename":"src\/hotspot\/share\/classfile\/classPrinter.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+using testing::ContainsRegex;\n@@ -38,3 +39,7 @@\n-  stringStream ss;\n-  ClassPrinter::print_classes(\"java\/lang\/Object\", 0x03, &ss);\n-  const char* output = ss.freeze();\n+  stringStream s1;\n+  ClassPrinter::print_classes(\"java\/lang\/Object\", 0x03, &s1);\n+  const char* o1 = s1.freeze();\n+\n+  ASSERT_THAT(o1, HasSubstr(\"class: java\/lang\/Object mirror:\")) << \"must find java\/lang\/Object\";\n+  ASSERT_THAT(o1, HasSubstr(\"method wait : (J)V\")) << \"must find java\/lang\/Object::wait\";\n+  ASSERT_THAT(o1, HasSubstr(\"method finalize : ()V\\n   0 return\")) << \"must find java\/lang\/Object::finalize and disasm\";\n@@ -42,3 +47,14 @@\n-  ASSERT_THAT(output, HasSubstr(\"class java\/lang\/Object loader data:\")) << \"must find java\/lang\/Object\";\n-  ASSERT_THAT(output, HasSubstr(\"method wait : (J)V\")) << \"must find java\/lang\/Object::wait\";\n-  ASSERT_THAT(output, HasSubstr(\"method finalize : ()V\\n   0 return\")) << \"must find java\/lang\/Object::finalize and disasm\";\n+  \/\/ \".\" should also work as separator in class name\n+  stringStream s2;\n+  ClassPrinter::print_classes(\"java.lang.Object\", 0x03, &s2);\n+  const char* o2 = s2.freeze();\n+  ASSERT_THAT(o2, HasSubstr(\"class: java\/lang\/Object mirror:\")) << \"must find java\/lang\/Object\";\n+\n+  \/\/ 0x20 is PRINT_CLASS_DETAILS\n+  stringStream s3;\n+  ClassPrinter::print_classes(\"java.lang.Integer\", 0x20, &s3);\n+  const char* o3 = s3.freeze();\n+  ASSERT_THAT(o3, HasSubstr(\"class: java\/lang\/Integer mirror:\")) << \"must find java\/lang\/Integer\";\n+  ASSERT_THAT(o3, HasSubstr(\"InstanceKlass: java.lang.Integer {0x\")) << \"must print InstanceKlass\";\n+  ASSERT_THAT(o3, HasSubstr(\"Java mirror oop for java\/lang\/Integer:\")) << \"must print mirror oop\";\n+  ASSERT_THAT(o3, ContainsRegex(\"public static final 'MIN_VALUE' 'I'.* -2147483648 [(]0x80000000[)]\")) << \"must print static fields\";\n@@ -55,1 +71,1 @@\n-  ASSERT_THAT(o1, HasSubstr(\"class java\/lang\/Object loader data:\")) << \"must find java\/lang\/Object\";\n+  ASSERT_THAT(o1, HasSubstr(\"class: java\/lang\/Object mirror:\")) << \"must find java\/lang\/Object\";\n@@ -63,1 +79,1 @@\n-  ASSERT_THAT(o2, HasSubstr(\"class java\/lang\/Object loader data:\")) << \"must find java\/lang\/Object\";\n+  ASSERT_THAT(o2, HasSubstr(\"class: java\/lang\/Object mirror:\")) << \"must find java\/lang\/Object\";\n@@ -67,0 +83,21 @@\n+\n+#ifndef PRODUCT\n+  \/\/ These are available only in debug builds\n+  \/\/\n+  \/\/ 0x02 is PRINT_BYTECODE\n+  \/\/ 0x04 is PRINT_BYTECODE_ADDRESS\n+  \/\/ 0x40 is PRINT_METHOD_DETAILS\n+  stringStream s3;\n+  ClassPrinter::print_methods(\"java.lang.Object\", \"wait:()V\", 0x46, &s3);\n+  const char* o3 = s3.freeze();\n+  ASSERT_THAT(o3, HasSubstr(\"method wait : ()V\")) << \"must find java\/lang\/Object::wait()\";\n+  ASSERT_THAT(o3, HasSubstr(\"{method}\")) << \"must print Method metadata\";\n+  ASSERT_THAT(o3, ContainsRegex(\"method holder:.*'java\/lang\/Object'\")) << \"must print Method metadata\";\n+  ASSERT_THAT(o3, ContainsRegex(\"name: *'wait'\")) << \"must print Method metadata\";\n+\n+  \/\/ Bytecodes: we should have at least one 'return' bytecide for Object.wait()\n+  \/\/ The print out should look like this:\n+  \/\/ 0x000000004adf73ad    5 return\n+  ASSERT_THAT(o3, ContainsRegex(\"0x[0-9a-f]+ +[0-9]+ +return\")) << \"must print return bytecode\";\n+#endif\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_classPrinter.cpp","additions":45,"deletions":8,"binary":false,"changes":53,"status":"modified"}]}