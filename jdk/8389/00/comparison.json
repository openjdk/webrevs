{"files":[{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8167108 8266130 8282704 8283467\n+ * @bug 8167108 8266130 8283467 8285507\n@@ -29,1 +29,0 @@\n- * @modules java.base\/java.lang:open\n@@ -33,1 +32,0 @@\n-import java.lang.reflect.Method;\n@@ -47,4 +45,0 @@\n-    public StopAtExit(ThreadGroup group, Runnable target) {\n-        super(group, target);\n-    }\n-\n@@ -85,2 +79,0 @@\n-        long manualDestroyCnt = 0;\n-        long manualTerminateCnt = 0;\n@@ -91,5 +83,0 @@\n-            \/\/ Use my own ThreadGroup so the thread count is known and make\n-            \/\/ it a daemon ThreadGroup so it is automatically destroyed when\n-            \/\/ the thread is terminated.\n-            ThreadGroup myTG = new ThreadGroup(\"myTG-\" + count);\n-            myTG.setDaemon(true);\n@@ -106,1 +93,1 @@\n-            StopAtExit thread = new StopAtExit(myTG, null);\n+            StopAtExit thread = new StopAtExit();\n@@ -161,32 +148,0 @@\n-            if (myTG.activeCount() != 0) {\n-                \/\/ If the ThreadGroup still has a count, then the thread\n-                \/\/ received the async exception while in exit() so we need\n-                \/\/ to do a manual terminate.\n-                manualTerminateCnt++;\n-                try {\n-                    threadTerminated(myTG, thread);\n-                } catch (Exception e) {\n-                    throw new Error(\"threadTerminated() threw unexpected: \" + e);\n-                }\n-                int activeCount = myTG.activeCount();\n-                if (activeCount != 0) {\n-                    throw new Error(\"threadTerminated() did not clean up \" +\n-                                    \"worker thread: count=\" + activeCount);\n-                }\n-                if (!myTG.isDestroyed()) {\n-                    throw new Error(\"threadTerminated() did not destroy \" +\n-                                    myTG.getName());\n-                }\n-            } else if (!myTG.isDestroyed()) {\n-                \/\/ If the ThreadGroup does not have a count, but is not\n-                \/\/ yet destroyed, then the thread received the async\n-                \/\/ exception while the thread was in the later stages of\n-                \/\/ its threadTerminated() call so we need to do a manual\n-                \/\/ destroy.\n-                manualDestroyCnt++;\n-                try {\n-                    myTG.destroy();\n-                } catch (Exception e) {\n-                    throw new Error(\"myTG.destroy() threw unexpected: \" + e);\n-                }\n-            }\n@@ -195,8 +150,0 @@\n-        if (manualDestroyCnt != 0) {\n-            System.out.println(\"Manually destroyed ThreadGroup \" +\n-                               manualDestroyCnt + \" times.\");\n-        }\n-        if (manualTerminateCnt != 0) {\n-            System.out.println(\"Manually terminated Thread \" +\n-                               manualTerminateCnt + \" times.\");\n-        }\n@@ -213,7 +160,0 @@\n-    static void threadTerminated(ThreadGroup group, Thread thread) throws Exception {\n-        \/\/ ThreadGroup.threadTerminated() is package private:\n-        Method method = ThreadGroup.class.getDeclaredMethod(\"threadTerminated\", Thread.class);\n-        method.setAccessible(true);\n-        method.invoke(group, thread);\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/StopAtExit.java","additions":2,"deletions":62,"binary":false,"changes":64,"status":"modified"}]}