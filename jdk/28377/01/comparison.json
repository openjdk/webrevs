{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,3 +123,2 @@\n-            if (next instanceof ClassMethodTransform cmt)\n-                return new ClassMethodTransform(transform.andThen(cmt.transform),\n-                                                mm -> filter.test(mm) && cmt.filter.test(mm));\n+            if (next instanceof ClassMethodTransform(var nextTransform, var nextFilter) && filter == nextFilter)\n+                return new ClassMethodTransform(transform.andThen(nextTransform), filter);\n@@ -146,3 +145,2 @@\n-            if (next instanceof ClassFieldTransform cft)\n-                return new ClassFieldTransform(transform.andThen(cft.transform),\n-                                               mm -> filter.test(mm) && cft.filter.test(mm));\n+            if (next instanceof ClassFieldTransform(var nextTransform, var nextFilter) && filter == nextFilter)\n+                return new ClassFieldTransform(transform.andThen(nextTransform), filter);\n@@ -211,2 +209,2 @@\n-            return (next instanceof TransformImpl.MethodCodeTransform mct)\n-                   ? new TransformImpl.MethodCodeTransform(xform.andThen(mct.xform))\n+            return (next instanceof MethodCodeTransform(var nextXform))\n+                   ? new TransformImpl.MethodCodeTransform(xform.andThen(nextXform))\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TransformImpl.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8335935 8336588\n+ * @bug 8335935 8336588 8372047\n@@ -31,14 +31,4 @@\n-import java.lang.classfile.ClassBuilder;\n-import java.lang.classfile.ClassElement;\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.ClassModel;\n-import java.lang.classfile.ClassTransform;\n-import java.lang.classfile.CodeBuilder;\n-import java.lang.classfile.CodeElement;\n-import java.lang.classfile.CodeModel;\n-import java.lang.classfile.CodeTransform;\n-import java.lang.classfile.FieldModel;\n-import java.lang.classfile.FieldTransform;\n-import java.lang.classfile.Label;\n-import java.lang.classfile.MethodModel;\n-import java.lang.classfile.MethodTransform;\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.AnnotationDefaultAttribute;\n+import java.lang.classfile.attribute.ConstantValueAttribute;\n+import java.lang.classfile.attribute.SourceDebugExtensionAttribute;\n@@ -57,0 +47,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -59,0 +50,1 @@\n+import jdk.internal.classfile.impl.TransformImpl;\n@@ -337,0 +329,50 @@\n+\n+    @Test\n+    void testFilteringTransformChaining() {\n+        var cf = ClassFile.of();\n+        var clazz = cf.parse(cf.build(ClassDesc.of(\"Test\"), clb -> clb\n+                .withField(\"one\", CD_int, fb -> fb.with(ConstantValueAttribute.of(1)))\n+                .withField(\"two\", CD_int, fb -> fb.with(ConstantValueAttribute.of(2)))\n+                .withMethod(\"one\", MTD_void, 0, mb -> mb.with(AnnotationDefaultAttribute.of(AnnotationValue.ofInt(1))).withCode(CodeBuilder::return_))\n+                .withMethod(\"two\", MTD_void, 0, mb -> mb.with(AnnotationDefaultAttribute.of(AnnotationValue.ofInt(2))).withCode(CodeBuilder::return_))));\n+\n+        AtomicBoolean oneFieldCalled = new AtomicBoolean(false);\n+        var oneFieldTransform = new TransformImpl.ClassFieldTransform((fb, fe) -> {\n+            if (fe instanceof ConstantValueAttribute cv) {\n+                assertEquals(1, ((Integer) cv.constant().constantValue()), \"Should only transform one\");\n+            }\n+            oneFieldCalled.set(true);\n+            fb.with(fe);\n+        }, fm -> fm.fieldName().equalsString(\"one\"));\n+        AtomicBoolean twoFieldCalled = new AtomicBoolean(false);\n+        var twoFieldTransform = new TransformImpl.ClassFieldTransform((fb, fe) -> {\n+            if (fe instanceof ConstantValueAttribute cv) {\n+                assertEquals(2, ((Integer) cv.constant().constantValue()), \"Should only transform two\");\n+            }\n+            twoFieldCalled.set(true);\n+            fb.with(fe);\n+        }, fm -> fm.fieldName().equalsString(\"two\"));\n+        cf.transformClass(clazz, oneFieldTransform.andThen(twoFieldTransform));\n+        assertTrue(oneFieldCalled.get(), \"Field one not transformed\");\n+        assertTrue(twoFieldCalled.get(), \"Field two not transformed\");\n+\n+        AtomicBoolean oneMethodCalled = new AtomicBoolean(false);\n+        var oneMethodTransform = ClassTransform.transformingMethods(mm -> mm.methodName().equalsString(\"one\"), (mb, me) -> {\n+            if (me instanceof AnnotationDefaultAttribute ada) {\n+                assertEquals(1, ((AnnotationValue.OfInt) ada.defaultValue()).intValue(), \"Should only transform one\");\n+            }\n+            oneMethodCalled.set(true);\n+            mb.with(me);\n+        });\n+        AtomicBoolean twoMethodCalled = new AtomicBoolean(false);\n+        var twoMethodTransform = ClassTransform.transformingMethods(mm -> mm.methodName().equalsString(\"two\"), (mb, me) -> {\n+            if (me instanceof AnnotationDefaultAttribute ada) {\n+                assertEquals(2, ((AnnotationValue.OfInt) ada.defaultValue()).intValue(), \"Should only transform two\");\n+            }\n+            twoMethodCalled.set(true);\n+            mb.with(me);\n+        });\n+        cf.transformClass(clazz, oneMethodTransform.andThen(twoMethodTransform));\n+        assertTrue(oneMethodCalled.get(), \"Method one not transformed\");\n+        assertTrue(twoMethodCalled.get(), \"Method two not transformed\");\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/TransformTests.java","additions":58,"deletions":16,"binary":false,"changes":74,"status":"modified"}]}