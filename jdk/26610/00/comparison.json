{"files":[{"patch":"@@ -6244,9 +6244,3 @@\n-  \/\/ Since IEEE 754 floating point format represents mantissa in 1.0 format\n-  \/\/ hence biased exponent can be used to compute leading zero count as per\n-  \/\/ following formula:-\n-  \/\/ LZCNT = 31 - (biased_exp - 127)\n-  \/\/ Special handling has been introduced for Zero, Max_Int and -ve source values.\n-\n-  \/\/ Broadcast 0xFF\n-  vpcmpeqd(xtmp1, xtmp1, xtmp1, vec_enc);\n-  vpsrld(xtmp1, xtmp1, 24, vec_enc);\n+  \/\/ By converting the integer to a float, we can obtain the number of leading zeros based on the exponent of the float.\n+  \/\/ As the float exponent contains a bias of 127 for nonzero values, the bias must be removed before interpreting the\n+  \/\/ exponent as the leading zero count.\n@@ -6257,2 +6251,2 @@\n-  vpsrld(xtmp2, src, 1, vec_enc);\n-  vpandn(xtmp3, xtmp2, src, vec_enc);\n+  vpsrld(dst, src, 1, vec_enc);\n+  vpandn(dst, dst, src, vec_enc);\n@@ -6260,4 +6254,1 @@\n-  \/\/ Extract biased exponent.\n-  vcvtdq2ps(dst, xtmp3, vec_enc);\n-  vpsrld(dst, dst, 23, vec_enc);\n-  vpand(dst, dst, xtmp1, vec_enc);\n+  vcvtdq2ps(dst, dst, vec_enc);\n@@ -6265,4 +6256,2 @@\n-  \/\/ Broadcast 127.\n-  vpsrld(xtmp1, xtmp1, 1, vec_enc);\n-  \/\/ Exponent = biased_exp - 127\n-  vpsubd(dst, dst, xtmp1, vec_enc);\n+  \/\/ By comparing the register to itself, all the bits in the destination are set.\n+  vpcmpeqd(xtmp1, xtmp1, xtmp1, vec_enc);\n@@ -6270,3 +6259,4 @@\n-  \/\/ Exponent_plus_one = Exponent + 1\n-  vpsrld(xtmp3, xtmp1, 6, vec_enc);\n-  vpaddd(dst, dst, xtmp3, vec_enc);\n+  \/\/ Move the biased exponent to the low end of the lane and mask with 0xFF to discard the sign bit.\n+  vpsrld(xtmp2, xtmp1, 24, vec_enc);\n+  vpsrld(dst, dst, 23, vec_enc);\n+  vpand(dst, xtmp2, dst, vec_enc);\n@@ -6274,4 +6264,3 @@\n-  \/\/ Replace -ve exponent with zero, exponent is -ve when src\n-  \/\/ lane contains a zero value.\n-  vpxor(xtmp2, xtmp2, xtmp2, vec_enc);\n-  vblendvps(dst, dst, xtmp2, dst, vec_enc);\n+  \/\/ Subtract 127 from the exponent, which removes the bias from the exponent.\n+  vpsrld(xtmp2, xtmp1, 25, vec_enc);\n+  vpsubd(dst, dst, xtmp2, vec_enc);\n@@ -6279,6 +6268,1 @@\n-  \/\/ Rematerialize broadcast 32.\n-  vpslld(xtmp1, xtmp3, 5, vec_enc);\n-  \/\/ Exponent is 32 if corresponding source lane contains max_int value.\n-  vpcmpeqd(xtmp2, dst, xtmp1, vec_enc);\n-  \/\/ LZCNT = 32 - exponent_plus_one\n-  vpsubd(dst, xtmp1, dst, vec_enc);\n+  vpsrld(xtmp2, xtmp1, 27, vec_enc);\n@@ -6286,3 +6270,3 @@\n-  \/\/ Replace LZCNT with a value 1 if corresponding source lane\n-  \/\/ contains max_int value.\n-  vpblendvb(dst, dst, xtmp3, xtmp2, vec_enc);\n+  \/\/ If the original value is 0 the exponent would not have bias, so the subtraction creates a negative number. If this\n+  \/\/ is found in any of the lanes, replace the lane with -1 from xtmp1.\n+  vblendvps(dst, dst, xtmp1, dst, vec_enc, true, xtmp3);\n@@ -6290,3 +6274,6 @@\n-  \/\/ Replace biased_exp with 0 if source lane value is less than zero.\n-  vpxor(xtmp2, xtmp2, xtmp2, vec_enc);\n-  vblendvps(dst, dst, xtmp2, src, vec_enc);\n+  \/\/ If the original value is negative, replace the lane with 31.\n+  vblendvps(dst, dst, xtmp2, src, vec_enc, true, xtmp3);\n+\n+  \/\/ Subtract the exponent from 31, giving the final result. For 0, the result is 32 as the exponent was replaced with -1,\n+  \/\/ and for negative numbers the result is 0 as the exponent was replaced with 31.\n+  vpsubd(dst, xtmp2, dst, vec_enc);\n@@ -6297,18 +6284,18 @@\n-  vector_count_leading_zeros_short_avx(dst, src, xtmp1, xtmp2, xtmp3, rtmp, vec_enc);\n-  \/\/ Add zero counts of lower word and upper word of a double word if\n-  \/\/ upper word holds a zero value.\n-  vpsrld(xtmp3, src, 16, vec_enc);\n-  \/\/ xtmp1 is set to all zeros by vector_count_leading_zeros_byte_avx.\n-  vpcmpeqd(xtmp3, xtmp1, xtmp3, vec_enc);\n-  vpslld(xtmp2, dst, 16, vec_enc);\n-  vpaddd(xtmp2, xtmp2, dst, vec_enc);\n-  vpblendvb(dst, dst, xtmp2, xtmp3, vec_enc);\n-  vpsrld(dst, dst, 16, vec_enc);\n-  \/\/ Add zero counts of lower doubleword and upper doubleword of a\n-  \/\/ quadword if upper doubleword holds a zero value.\n-  vpsrlq(xtmp3, src, 32, vec_enc);\n-  vpcmpeqq(xtmp3, xtmp1, xtmp3, vec_enc);\n-  vpsllq(xtmp2, dst, 32, vec_enc);\n-  vpaddq(xtmp2, xtmp2, dst, vec_enc);\n-  vpblendvb(dst, dst, xtmp2, xtmp3, vec_enc);\n-  vpsrlq(dst, dst, 32, vec_enc);\n+  \/\/ Find the leading zeros of the top and bottom halves of the long individually.\n+  vector_count_leading_zeros_int_avx(dst, src, xtmp1, xtmp2, xtmp3, vec_enc);\n+\n+  \/\/ Move the top half result to the bottom half of xtmp1, setting the top half to 0.\n+  vpsrlq(xtmp1, dst, 32, vec_enc);\n+  \/\/ By moving the top half result to the right by 6 bytes, if the top half was empty (i.e. 32 is returned) the result bit will\n+  \/\/ be in the most significant position of the bottom half.\n+  vpsrlq(xtmp2, dst, 6, vec_enc);\n+\n+  \/\/ In the bottom half, add the top half and bottom half results.\n+  vpaddq(dst, xtmp1, dst, vec_enc);\n+\n+  \/\/ For the bottom half, choose between the values using the most significant bit of xtmp2.\n+  \/\/ If the MSB is set, then bottom+top in dst is the resulting value. If the top half is less than 32 xtmp1 is chosen,\n+  \/\/ which contains only the top half result.\n+  \/\/ In the top half the MSB is always zero, so the value in xtmp1 is always chosen. This value is always 0, which clears\n+  \/\/ the lane as required.\n+  vblendvps(dst, xtmp1, dst, xtmp2, vec_enc, true, xtmp3);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":43,"deletions":56,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -49,1 +49,2 @@\n-    private static final int[] SPECIAL = { 0x01FFFFFF, 0x03FFFFFE, 0x07FFFFFC, 0x0FFFFFF8, 0x1FFFFFF0, 0x3FFFFFE0, 0xFFFFFFFF };\n+    private static final int[] SPECIAL_INT = { 0, 0x01FFFFFF, 0x03FFFFFE, 0x07FFFFFC, 0x0FFFFFF8, 0x1FFFFFF0, 0x3FFFFFE0, 0xFFFFFFFF };\n+    private static final long[] SPECIAL_LONG = { 0, 0xFF, 0xFFFF, 0x01FFFFFF, 0x03FFFFFE, 0x07FFFFFC, 0x0FFFFFF8, 0x1FFFFFF0, 0x3FFFFFE0, 0xFFFFFFFF, 0xFFFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL };\n@@ -137,1 +138,12 @@\n-            res[i] = SPECIAL[i % SPECIAL.length];\n+            res[i] = SPECIAL_INT[i % SPECIAL_INT.length];\n+        }\n+\n+        return new Object[] { res };\n+    }\n+\n+    @Setup\n+    static Object[] setupSpecialLongArray() {\n+        long[] res = new long[LEN];\n+\n+        for (int i = 0; i < LEN; i++) {\n+            res[i] = SPECIAL_LONG[i % SPECIAL_LONG.length];\n@@ -170,1 +182,29 @@\n-    private static final VectorSpecies<Integer> SPECIES = IntVector.SPECIES_PREFERRED;\n+    @Test\n+    @IR(counts = {IRNode.COUNT_LEADING_ZEROS_VL, \"> 0\"})\n+    @Arguments(setup = \"setupSpecialLongArray\")\n+    public Object[] testSpecialLongLeadingZeros(long[] longs) {\n+        int[] res = new int[LEN];\n+\n+        for (int i = 0; i < LEN; ++i) {\n+            res[i] = Long.numberOfLeadingZeros(longs[i]);\n+        }\n+\n+        return new Object[] { longs, res };\n+    }\n+\n+    @Check(test = \"testSpecialLongLeadingZeros\")\n+    public void checkSpecialLongLeadingZeros(Object[] vals) {\n+        long[] in = (long[]) vals[0];\n+        int[] out = (int[]) vals[1];\n+\n+        for (int i = 0; i < LEN; ++i) {\n+            int value = Long.numberOfLeadingZeros(in[i]);\n+\n+            if (out[i] != value) {\n+                throw new IllegalStateException(\"Expected lzcnt(\" + in[i] + \") to be \" + value + \" but got \" + out[i]);\n+            }\n+        }\n+    }\n+\n+    private static final VectorSpecies<Integer> SPECIES_INT = IntVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Long> SPECIES_LONG = LongVector.SPECIES_PREFERRED;\n@@ -175,1 +215,1 @@\n-    public Object[] checkSpecialIntLeadingZerosVector(int[] ints) {\n+    public Object[] testIntLeadingZerosVector(int[] ints) {\n@@ -178,2 +218,2 @@\n-        for (int i = 0; i < ints.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, ints, i);\n+        for (int i = 0; i < ints.length; i += SPECIES_INT.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES_INT, ints, i);\n@@ -186,1 +226,1 @@\n-    @Check(test = \"checkSpecialIntLeadingZerosVector\")\n+    @Check(test = \"testIntLeadingZerosVector\")\n@@ -195,2 +235,37 @@\n-        for (int i = 0; i < ints.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, ints, i);\n+        for (int i = 0; i < ints.length; i += SPECIES_INT.length()) {\n+            IntVector av = IntVector.fromArray(SPECIES_INT, ints, i);\n+            av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(check, i);\n+        }\n+\n+        for (int i = 0; i < LEN; i++) {\n+            if (res[i] != check[i]) {\n+                throw new IllegalStateException(\"Expected \" + check[i] + \" but got \" + res[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.COUNT_LEADING_ZEROS_VL, \"> 0\"})\n+    @Arguments(setup = \"setupSpecialLongArray\")\n+    public Object[] testLongLeadingZerosVector(long[] longs) {\n+        long[] res = new long[LEN];\n+\n+        for (int i = 0; i < longs.length; i += SPECIES_LONG.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES_LONG, longs, i);\n+            av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(res, i);\n+        }\n+\n+        return new Object[] { longs, res };\n+    }\n+\n+    @Check(test = \"testLongLeadingZerosVector\")\n+    public void checkSpecialLongLeadingZerosVector(Object[] vals) {\n+        long[] longs = (long[]) vals[0];\n+        long[] res = (long[]) vals[1];\n+\n+        \/\/ Verification\n+\n+        long[] check = new long[LEN];\n+\n+        for (int i = 0; i < longs.length; i += SPECIES_LONG.length()) {\n+            LongVector av = LongVector.fromArray(SPECIES_LONG, longs, i);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestNumberOfContinuousZeros.java","additions":84,"deletions":9,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Measurement(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(3)\n+public class LeadingZeros {\n+    private static final int SIZE = 512;\n+\n+    @Benchmark\n+    public void testInt(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            state.result[i] = Integer.numberOfLeadingZeros(state.ints[i]);\n+        }\n+\n+        blackhole.consume(state.result);\n+    }\n+\n+    @Benchmark\n+    public void testLong(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            state.result[i] = Long.numberOfLeadingZeros(state.longs[i]);\n+        }\n+\n+        blackhole.consume(state.result);\n+    }\n+\n+    @State(Scope.Benchmark)\n+    public static class BenchState {\n+        private final int[] ints = new int[SIZE];\n+        private final long[] longs = new long[SIZE];\n+\n+        private final int[] result = new int[SIZE];\n+\n+        private Random random;\n+\n+        public BenchState() {\n+        }\n+\n+        @Setup\n+        public void setup() {\n+            this.random = new Random(1000);\n+\n+            for (int i = 0; i < SIZE; i++) {\n+                ints[i] = this.random.nextInt();\n+\n+                longs[i] = this.random.nextLong();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/LeadingZeros.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"}]}