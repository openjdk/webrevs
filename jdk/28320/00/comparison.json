{"files":[{"patch":"@@ -2609,0 +2609,222 @@\n+  \/\/ Arguments:\n+  \/\/\n+  \/\/ Inputs:\n+  \/\/   c_rarg0   - source byte array address\n+  \/\/   c_rarg1   - destination byte array address\n+  \/\/   c_rarg2   - K (key) in little endian int array\n+  \/\/   c_rarg3   - r vector byte array address\n+  \/\/   c_rarg4   - input length\n+  \/\/\n+  \/\/ Output:\n+  \/\/   x0        - input length\n+  \/\/\n+  address generate_cipherBlockChaining_encryptAESCrypt() {\n+    assert(UseAESIntrinsics, \"need AES instructions (Zvkned extension) support\");\n+    __ align(CodeEntryAlignment);\n+    StubId stub_id = StubId::stubgen_cipherBlockChaining_encryptAESCrypt_id;\n+    StubCodeMark mark(this, stub_id);\n+\n+    const Register from       = c_rarg0;\n+    const Register to         = c_rarg1;\n+    const Register key        = c_rarg2;\n+    const Register iv         = c_rarg3;\n+    const Register input_len  = c_rarg4;\n+\n+    const Register keylen     = x28;\n+    const Register len        = x29;\n+\n+    const unsigned int BLOCK_SIZE = 16;\n+\n+    VectorRegister working_vregs[] = {\n+      v1, v2, v3, v4, v5, v6, v7, v8,\n+      v9, v10, v11, v12, v13, v14, v15\n+    };\n+\n+    address start = __ pc();\n+    __ enter();\n+    __ mv(len, input_len);\n+    \/\/ load init iv\n+    __ vsetivli(x0, 4, Assembler::e32, Assembler::m1);\n+    __ vle32_v(v16, iv);\n+\n+    Label L_aes128, L_aes192, L_aes128_loop, L_aes192_loop, L_aes256_loop;\n+    \/\/ Compute #rounds for AES based on the length of the key array\n+    __ lwu(keylen, Address(key, arrayOopDesc::length_offset_in_bytes() - arrayOopDesc::base_offset_in_bytes(T_INT)));\n+    __ mv(t0, 52);\n+    __ bltu(keylen, t0, L_aes128);\n+    __ beq(keylen, t0, L_aes192);\n+    \/\/ Else we fallthrough to the biggest case (256-bit key size)\n+\n+    \/\/ Note: the following function performs key += 15*16\n+    generate_aes_loadkeys(key, working_vregs, 15);\n+    \/\/ Encrypt from source by block size\n+    __ bind(L_aes256_loop);\n+      __ vle32_v(v17, from);\n+      __ addi(from, from, BLOCK_SIZE);\n+      __ vxor_vv(v16, v16, v17);\n+      generate_aes_encrypt(v16, working_vregs, 15);\n+      __ vse32_v(v16, to);\n+      __ addi(to, to, BLOCK_SIZE);\n+      __ subi(len, len, BLOCK_SIZE);\n+      __ bnez(len, L_aes256_loop);\n+      \/\/ save current iv and return\n+      __ vse32_v(v16, iv);\n+      __ mv(x10, input_len);\n+      __ leave();\n+      __ ret();\n+\n+    \/\/ Note: the following function performs key += 11*16\n+    __ bind(L_aes128);\n+    generate_aes_loadkeys(key, working_vregs, 11);\n+    \/\/ Encrypt from source by block size\n+    __ bind(L_aes128_loop);\n+      __ vle32_v(v17, from);\n+      __ addi(from, from, BLOCK_SIZE);\n+      __ vxor_vv(v16, v16, v17);\n+      generate_aes_encrypt(v16, working_vregs, 11);\n+      __ vse32_v(v16, to);\n+      __ addi(to, to, BLOCK_SIZE);\n+      __ subi(len, len, BLOCK_SIZE);\n+      __ bnez(len, L_aes128_loop);\n+      \/\/ save current iv and return\n+      __ vse32_v(v16, iv);\n+      __ mv(x10, input_len);\n+      __ leave();\n+      __ ret();\n+\n+    \/\/ Note: the following function performs key += 13*16\n+    __ bind(L_aes192);\n+    generate_aes_loadkeys(key, working_vregs, 13);\n+    \/\/ Encrypt from source by block size\n+    __ bind(L_aes192_loop);\n+      __ vle32_v(v17, from);\n+      __ addi(from, from, BLOCK_SIZE);\n+      __ vxor_vv(v16, v16, v17);\n+      generate_aes_encrypt(v16, working_vregs, 13);\n+      __ vse32_v(v16, to);\n+      __ addi(to, to, BLOCK_SIZE);\n+      __ subi(len, len, BLOCK_SIZE);\n+      __ bnez(len, L_aes192_loop);\n+      \/\/ save current iv and return\n+      __ vse32_v(v16, iv);\n+      __ mv(x10, input_len);\n+      __ leave();\n+      __ ret();\n+\n+    return start;\n+  }\n+\n+  \/\/ Arguments:\n+  \/\/\n+  \/\/ Inputs:\n+  \/\/   c_rarg0   - source byte array address\n+  \/\/   c_rarg1   - destination byte array address\n+  \/\/   c_rarg2   - K (key) in little endian int array\n+  \/\/   c_rarg3   - r vector byte array address\n+  \/\/   c_rarg4   - input length\n+  \/\/\n+  \/\/ Output:\n+  \/\/   r0        - input length\n+  \/\/\n+  address generate_cipherBlockChaining_decryptAESCrypt() {\n+    assert(UseAESIntrinsics, \"need AES instructions (Zvkned extension) support\");\n+    __ align(CodeEntryAlignment);\n+    StubId stub_id = StubId::stubgen_cipherBlockChaining_decryptAESCrypt_id;\n+    StubCodeMark mark(this, stub_id);\n+\n+    const Register from        = c_rarg0;\n+    const Register to          = c_rarg1;\n+    const Register key         = c_rarg2;\n+    const Register iv          = c_rarg3;\n+    const Register input_len   = c_rarg4;\n+\n+    const Register keylen      = x28;\n+    const Register len         = x29;\n+\n+    const unsigned int BLOCK_SIZE = 16;\n+\n+    VectorRegister working_vregs[] = {\n+      v1, v2, v3, v4, v5, v6, v7, v8,\n+      v9, v10, v11, v12, v13, v14, v15\n+    };\n+\n+    address start = __ pc();\n+    __ enter();\n+    __ mv(len, input_len);\n+    \/\/ load init iv\n+    __ vsetivli(x0, 4, Assembler::e32, Assembler::m1);\n+    __ vle32_v(v16, iv);\n+\n+    Label L_aes128, L_aes192, L_aes128_loop, L_aes192_loop, L_aes256_loop;\n+    \/\/ Compute #rounds for AES based on the length of the key array\n+    __ lwu(keylen, Address(key, arrayOopDesc::length_offset_in_bytes() - arrayOopDesc::base_offset_in_bytes(T_INT)));\n+    __ mv(t0, 52);\n+    __ bltu(keylen, t0, L_aes128);\n+    __ beq(keylen, t0, L_aes192);\n+    \/\/ Else we fallthrough to the biggest case (256-bit key size)\n+\n+    \/\/ Note: the following function performs key += 15*16\n+    generate_aes_loadkeys(key, working_vregs, 15);\n+    \/\/ Decrypt from source by block size\n+    __ bind(L_aes256_loop);\n+      __ vle32_v(v17, from);\n+      __ addi(from, from, BLOCK_SIZE);\n+      __ vmv_v_v(v18, v17);\n+      generate_aes_decrypt(v17, working_vregs, 15);\n+      __ vxor_vv(v17, v17, v16);\n+      __ vse32_v(v17, to);\n+      __ vmv_v_v(v16, v18);\n+      __ addi(to, to, BLOCK_SIZE);\n+      __ subi(len, len, BLOCK_SIZE);\n+      __ bnez(len, L_aes256_loop);\n+      \/\/ save current iv and return\n+      __ vse32_v(v16, iv);\n+      __ mv(x10, input_len);\n+      __ leave();\n+      __ ret();\n+\n+    \/\/ Note: the following function performs key += 11*16\n+    __ bind(L_aes128);\n+    generate_aes_loadkeys(key, working_vregs, 11);\n+    \/\/ Decrypt from source by block size\n+    __ bind(L_aes128_loop);\n+      __ vle32_v(v17, from);\n+      __ addi(from, from, BLOCK_SIZE);\n+      __ vmv_v_v(v18, v17);\n+      generate_aes_decrypt(v17, working_vregs, 11);\n+      __ vxor_vv(v17, v17, v16);\n+      __ vse32_v(v17, to);\n+      __ vmv_v_v(v16, v18);\n+      __ addi(to, to, BLOCK_SIZE);\n+      __ subi(len, len, BLOCK_SIZE);\n+      __ bnez(len, L_aes128_loop);\n+      \/\/ save current iv and return\n+      __ vse32_v(v16, iv);\n+      __ mv(x10, input_len);\n+      __ leave();\n+      __ ret();\n+\n+    \/\/ Note: the following function performs key += 13*16\n+    __ bind(L_aes192);\n+    generate_aes_loadkeys(key, working_vregs, 13);\n+    \/\/ Decrypt from source by block size\n+    __ bind(L_aes192_loop);\n+      __ vle32_v(v17, from);\n+      __ addi(from, from, BLOCK_SIZE);\n+      __ vmv_v_v(v18, v17);\n+      generate_aes_decrypt(v17, working_vregs, 13);\n+      __ vxor_vv(v17, v17, v16);\n+      __ vse32_v(v17, to);\n+      __ vmv_v_v(v16, v18);\n+      __ addi(to, to, BLOCK_SIZE);\n+      __ subi(len, len, BLOCK_SIZE);\n+      __ bnez(len, L_aes192_loop);\n+      \/\/ save current iv and return\n+      __ vse32_v(v16, iv);\n+      __ mv(x10, input_len);\n+      __ leave();\n+      __ ret();\n+\n+    return start;\n+  }\n+\n@@ -6827,0 +7049,2 @@\n+      StubRoutines::_cipherBlockChaining_encryptAESCrypt = generate_cipherBlockChaining_encryptAESCrypt();\n+      StubRoutines::_cipherBlockChaining_decryptAESCrypt = generate_cipherBlockChaining_decryptAESCrypt();\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":224,"deletions":0,"binary":false,"changes":224,"status":"modified"}]}