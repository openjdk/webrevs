{"files":[{"patch":"@@ -2609,0 +2609,178 @@\n+  void cipherBlockChaining_encryptAESCrypt(int round, Register from, Register to, Register key,\n+                                           Register rvec, Register input_len) {\n+    const Register len = x29;\n+\n+    VectorRegister working_vregs[] = {\n+      v1, v2, v3, v4, v5, v6, v7, v8,\n+      v9, v10, v11, v12, v13, v14, v15\n+    };\n+\n+    const unsigned int BLOCK_SIZE = 16;\n+\n+    __ mv(len, input_len);\n+    \/\/ load init rvec\n+    __ vsetivli(x0, 4, Assembler::e32, Assembler::m1);\n+    __ vle32_v(v16, rvec);\n+\n+    generate_aes_loadkeys(key, working_vregs, round);\n+    Label L_enc_loop;\n+    __ bind(L_enc_loop);\n+    \/\/ Encrypt from source by block size\n+      __ vle32_v(v17, from);\n+      __ addi(from, from, BLOCK_SIZE);\n+      __ vxor_vv(v16, v16, v17);\n+      generate_aes_encrypt(v16, working_vregs, round);\n+      __ vse32_v(v16, to);\n+      __ addi(to, to, BLOCK_SIZE);\n+      __ subi(len, len, BLOCK_SIZE);\n+      __ bnez(len, L_enc_loop);\n+\n+    \/\/ save current rvec and return\n+    __ vse32_v(v16, rvec);\n+    __ mv(x10, input_len);\n+    __ leave();\n+    __ ret();\n+  }\n+\n+  \/\/ Arguments:\n+  \/\/\n+  \/\/ Inputs:\n+  \/\/   c_rarg0   - source byte array address\n+  \/\/   c_rarg1   - destination byte array address\n+  \/\/   c_rarg2   - K (key) in little endian int array\n+  \/\/   c_rarg3   - r vector byte array address\n+  \/\/   c_rarg4   - input length\n+  \/\/\n+  \/\/ Output:\n+  \/\/   x10       - input length\n+  \/\/\n+  address generate_cipherBlockChaining_encryptAESCrypt() {\n+    assert(UseAESIntrinsics, \"Must be\");\n+    assert(UseZvkn, \"need AES instructions (Zvkned extension) support\");\n+    __ align(CodeEntryAlignment);\n+    StubId stub_id = StubId::stubgen_cipherBlockChaining_encryptAESCrypt_id;\n+    StubCodeMark mark(this, stub_id);\n+\n+    const Register from       = c_rarg0;\n+    const Register to         = c_rarg1;\n+    const Register key        = c_rarg2;\n+    const Register rvec       = c_rarg3;\n+    const Register input_len  = c_rarg4;\n+\n+    const Register keylen     = x28;\n+\n+    address start = __ pc();\n+    __ enter();\n+\n+    Label L_aes128, L_aes192;\n+    \/\/ Compute #rounds for AES based on the length of the key array\n+    __ lwu(keylen, Address(key, arrayOopDesc::length_offset_in_bytes() - arrayOopDesc::base_offset_in_bytes(T_INT)));\n+    __ mv(t0, 52);\n+    __ bltu(keylen, t0, L_aes128);\n+    __ beq(keylen, t0, L_aes192);\n+    \/\/ Else we fallthrough to the biggest case (256-bit key size)\n+\n+    \/\/ Note: the following function performs key += 15*16\n+    cipherBlockChaining_encryptAESCrypt(15, from, to, key, rvec, input_len);\n+\n+    \/\/ Note: the following function performs key += 11*16\n+    __ bind(L_aes128);\n+    cipherBlockChaining_encryptAESCrypt(11, from, to, key, rvec, input_len);\n+\n+    \/\/ Note: the following function performs key += 13*16\n+    __ bind(L_aes192);\n+    cipherBlockChaining_encryptAESCrypt(13, from, to, key, rvec, input_len);\n+\n+    return start;\n+  }\n+\n+  void cipherBlockChaining_decryptAESCrypt(int round, Register from, Register to, Register key,\n+                                           Register rvec, Register input_len) {\n+    const Register len = x29;\n+\n+    VectorRegister working_vregs[] = {\n+      v1, v2, v3, v4, v5, v6, v7, v8,\n+      v9, v10, v11, v12, v13, v14, v15\n+    };\n+\n+    const unsigned int BLOCK_SIZE = 16;\n+\n+    __ mv(len, input_len);\n+    \/\/ load init rvec\n+    __ vsetivli(x0, 4, Assembler::e32, Assembler::m1);\n+    __ vle32_v(v16, rvec);\n+\n+    generate_aes_loadkeys(key, working_vregs, round);\n+    Label L_dec_loop;\n+    \/\/ Decrypt from source by block size\n+    __ bind(L_dec_loop);\n+      __ vle32_v(v17, from);\n+      __ addi(from, from, BLOCK_SIZE);\n+      __ vmv_v_v(v18, v17);\n+      generate_aes_decrypt(v17, working_vregs, round);\n+      __ vxor_vv(v17, v17, v16);\n+      __ vse32_v(v17, to);\n+      __ vmv_v_v(v16, v18);\n+      __ addi(to, to, BLOCK_SIZE);\n+      __ subi(len, len, BLOCK_SIZE);\n+      __ bnez(len, L_dec_loop);\n+\n+    \/\/ save current rvec and return\n+    __ vse32_v(v16, rvec);\n+    __ mv(x10, input_len);\n+    __ leave();\n+    __ ret();\n+  }\n+\n+  \/\/ Arguments:\n+  \/\/\n+  \/\/ Inputs:\n+  \/\/   c_rarg0   - source byte array address\n+  \/\/   c_rarg1   - destination byte array address\n+  \/\/   c_rarg2   - K (key) in little endian int array\n+  \/\/   c_rarg3   - r vector byte array address\n+  \/\/   c_rarg4   - input length\n+  \/\/\n+  \/\/ Output:\n+  \/\/   x10       - input length\n+  \/\/\n+  address generate_cipherBlockChaining_decryptAESCrypt() {\n+    assert(UseAESIntrinsics, \"Must be\");\n+    assert(UseZvkn, \"need AES instructions (Zvkned extension) support\");\n+    __ align(CodeEntryAlignment);\n+    StubId stub_id = StubId::stubgen_cipherBlockChaining_decryptAESCrypt_id;\n+    StubCodeMark mark(this, stub_id);\n+\n+    const Register from        = c_rarg0;\n+    const Register to          = c_rarg1;\n+    const Register key         = c_rarg2;\n+    const Register rvec        = c_rarg3;\n+    const Register input_len   = c_rarg4;\n+\n+    const Register keylen      = x28;\n+\n+    address start = __ pc();\n+    __ enter();\n+\n+    Label L_aes128, L_aes192, L_aes128_loop, L_aes192_loop, L_aes256_loop;\n+    \/\/ Compute #rounds for AES based on the length of the key array\n+    __ lwu(keylen, Address(key, arrayOopDesc::length_offset_in_bytes() - arrayOopDesc::base_offset_in_bytes(T_INT)));\n+    __ mv(t0, 52);\n+    __ bltu(keylen, t0, L_aes128);\n+    __ beq(keylen, t0, L_aes192);\n+    \/\/ Else we fallthrough to the biggest case (256-bit key size)\n+\n+    \/\/ Note: the following function performs key += 15*16\n+    cipherBlockChaining_decryptAESCrypt(15, from, to, key, rvec, input_len);\n+\n+    \/\/ Note: the following function performs key += 11*16\n+    __ bind(L_aes128);\n+    cipherBlockChaining_decryptAESCrypt(11, from, to, key, rvec, input_len);\n+\n+    \/\/ Note: the following function performs key += 13*16\n+    __ bind(L_aes192);\n+    cipherBlockChaining_decryptAESCrypt(13, from, to, key, rvec, input_len);\n+\n+    return start;\n+  }\n+\n@@ -2775,0 +2953,1 @@\n+    assert(UseAESCTRIntrinsics, \"Must be\");\n@@ -2776,1 +2955,0 @@\n-    assert(UseAESCTRIntrinsics, \"need AES instructions (Zvkned extension) support\");\n@@ -7044,0 +7222,2 @@\n+      StubRoutines::_cipherBlockChaining_encryptAESCrypt = generate_cipherBlockChaining_encryptAESCrypt();\n+      StubRoutines::_cipherBlockChaining_decryptAESCrypt = generate_cipherBlockChaining_decryptAESCrypt();\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":181,"deletions":1,"binary":false,"changes":182,"status":"modified"}]}