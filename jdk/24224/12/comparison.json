{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,5 @@\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.HashMap;\n+\n@@ -30,3 +35,12 @@\n- * The {@link Verify} class provides a single {@link Verify#checkEQ} static method, which recursively\n- * compares the two {@link Object}s by value. It deconstructs {@link Object[]}, compares boxed primitive\n- * types, and compares the content of arrays and {@link MemorySegment}s.\n+ * The {@link Verify} class provide {@link Verify#checkEQ} and {@link Verify#checkEQWithRawBits},\n+ * which recursively compare the two  {@link Object}s by value. They deconstruct an array of objects,\n+ * compare boxed primitive types, compare the content of arrays and {@link MemorySegment}s, and check\n+ * that the messages of two {@link Exception}s are equal. They also checks for the equivalent content\n+ * in {@code Vector}s from the Vector API.\n+ *\n+ * <p>\n+ * Further, they compare Objects from arbitrary classes, using reflection. We check the fields of the\n+ * Objects, and compare their recursive structure. Since we use reflection, this can be slow.\n+ *\n+ * <p>\n+ * When a comparison fails, then methods print helpful messages, before throwing a {@link VerifyException}.\n@@ -34,1 +48,7 @@\n- * When a comparison fail, then methods print helpful messages, before throwing a {@link VerifyException}.\n+ * <p>\n+ * We have to take special care of {@link Float}s and {@link Double}s, since they both have various\n+ * encodings for NaN values while the Java specification regards them as equal. Hence, we\n+ * have two modes of comparison. With {@link Verify#checkEQ} different NaN values are regarded as equal.\n+ * This applies to the boxed floating types, as well as arrays of floating arrays. With\n+ * {@link Verify#checkEQWithRawBits} we compare the raw bits, and so different NaN encodings are not equal.\n+ * Note: {@link MemorySegment} data is always compared with raw bits.\n@@ -37,0 +57,1 @@\n+    private final boolean isFloatCheckWithRawBits;\n@@ -38,1 +59,14 @@\n-    private Verify() {}\n+    \/**\n+     * When comparing arbitrary classes recursively, we need to remember which\n+     * pairs of objects {@code (a, b)} we have already visited. The maps\n+     * {@code a2b} and {@code b2a} track these edges. Caching which pairs\n+     * we have already visited means the traversal only needs to visit every\n+     * pair once. And should we ever find a pair {@code (a, b')} or {@code (a', b)},\n+     * then we know that the two structures are not structurally equivalent.\n+     *\/\n+    private final HashMap<Object, Object> a2b = new HashMap<>();\n+    private final HashMap<Object, Object> b2a = new HashMap<>();\n+\n+    private Verify(boolean isFloatCheckWithRawBits) {\n+        this.isFloatCheckWithRawBits = isFloatCheckWithRawBits;\n+    }\n@@ -41,1 +75,3 @@\n-     * Verify the content of two Objects, possibly recursively. Only limited types are implemented.\n+     * Verify the contents of two Objects on a raw bit level, possibly recursively.\n+     * Different NaN encodings are considered non-equal, since we compare\n+     * floating numbers by their raw bits.\n@@ -47,2 +83,3 @@\n-    public static void checkEQ(Object a, Object b) {\n-        checkEQ(a, b, \"\");\n+    public static void checkEQWithRawBits(Object a, Object b) {\n+        Verify v = new Verify(true);\n+        v.checkEQdispatch(a, b, \"<root>\", null, null);\n@@ -52,1 +89,6 @@\n-     * Verify the content of two Objects, possibly recursively. Only limited types are implemented.\n+     * Verify the contents of two Objects, possibly recursively.\n+     * Different NaN encodings are considered equal.\n+     *\n+     * @param a First object to be recursively compared with the second.\n+     * @param b Second object to be recursively compared with the first.\n+     * @throws VerifyException If the comparison fails.\n@@ -54,1 +96,6 @@\n-    private static void checkEQ(Object a, Object b, String context) {\n+    public static void checkEQ(Object a, Object b) {\n+        Verify v = new Verify(false);\n+        v.checkEQdispatch(a, b, \"<root>\", null, null);\n+    }\n+\n+    private void checkEQdispatch(Object a, Object b, String field, Object aParent, Object bParent) {\n@@ -62,3 +109,2 @@\n-            System.err.println(\"ERROR: Verify.checkEQ failed: null mismatch\");\n-            print(a, \"a \" + context);\n-            print(b, \"b \" + context);\n+            System.err.println(\"ERROR: Equality matching failed: null mismatch\");\n+            print(a, b, field, aParent, bParent);\n@@ -69,2 +115,2 @@\n-        Class ca = a.getClass();\n-        Class cb = b.getClass();\n+        Class<?> ca = a.getClass();\n+        Class<?> cb = b.getClass();\n@@ -72,1 +118,1 @@\n-            System.err.println(\"ERROR: Verify.checkEQ failed: class mismatch.\");\n+            System.err.println(\"ERROR: Equality matching failed: class mismatch.\");\n@@ -74,2 +120,1 @@\n-            print(a, \"a \" + context);\n-            print(b, \"b \" + context);\n+            print(a, b, field, aParent, bParent);\n@@ -79,0 +124,6 @@\n+        \/\/ Already visited? This makes sure that we are not stuck in cycles, and that we have\n+        \/\/ a mapping of pairs (a, b) for structurally equivalent Objects.\n+        if (checkAlreadyVisited(a, b, field, aParent, bParent)) {\n+            return;\n+        }\n+\n@@ -80,16 +131,19 @@\n-            case Object[]  x -> checkEQimpl(x, (Object[])b,                context);\n-            case Byte      x -> checkEQimpl(x, ((Byte)b).byteValue(),      context);\n-            case Character x -> checkEQimpl(x, ((Character)b).charValue(), context);\n-            case Short     x -> checkEQimpl(x, ((Short)b).shortValue(),    context);\n-            case Integer   x -> checkEQimpl(x, ((Integer)b).intValue(),    context);\n-            case Long      x -> checkEQimpl(x, ((Long)b).longValue(),      context);\n-            case Float     x -> checkEQimpl(x, ((Float)b).floatValue(),    context);\n-            case Double    x -> checkEQimpl(x, ((Double)b).doubleValue(),  context);\n-            case byte[]    x -> checkEQimpl(x, (byte[])b,                  context);\n-            case char[]    x -> checkEQimpl(x, (char[])b,                  context);\n-            case short[]   x -> checkEQimpl(x, (short[])b,                 context);\n-            case int[]     x -> checkEQimpl(x, (int[])b,                   context);\n-            case long[]    x -> checkEQimpl(x, (long[])b,                  context);\n-            case float[]   x -> checkEQimpl(x, (float[])b,                 context);\n-            case double[]  x -> checkEQimpl(x, (double[])b,                context);\n-            case MemorySegment x -> checkEQimpl(x, (MemorySegment) b,      context);\n+            case Object[]  x -> checkEQimpl(x, (Object[])b,                 field, aParent, bParent);\n+            case Byte      x -> checkEQimpl(x, (Byte)b,                     field, aParent, bParent);\n+            case Character x -> checkEQimpl(x, (Character)b,                field, aParent, bParent);\n+            case Short     x -> checkEQimpl(x, (Short)b,                    field, aParent, bParent);\n+            case Integer   x -> checkEQimpl(x, (Integer)b,                  field, aParent, bParent);\n+            case Long      x -> checkEQimpl(x, (Long)b,                     field, aParent, bParent);\n+            case Float     x -> checkEQimpl(x, (Float)b,                    field, aParent, bParent);\n+            case Double    x -> checkEQimpl(x, (Double)b,                   field, aParent, bParent);\n+            case Boolean   x -> checkEQimpl(x, (Boolean)b,                  field, aParent, bParent);\n+            case byte[]    x -> checkEQimpl(x, (byte[])b,                   field, aParent, bParent);\n+            case char[]    x -> checkEQimpl(x, (char[])b,                   field, aParent, bParent);\n+            case short[]   x -> checkEQimpl(x, (short[])b,                  field, aParent, bParent);\n+            case int[]     x -> checkEQimpl(x, (int[])b,                    field, aParent, bParent);\n+            case long[]    x -> checkEQimpl(x, (long[])b,                   field, aParent, bParent);\n+            case float[]   x -> checkEQimpl(x, (float[])b,                  field, aParent, bParent);\n+            case double[]  x -> checkEQimpl(x, (double[])b,                 field, aParent, bParent);\n+            case boolean[] x -> checkEQimpl(x, (boolean[])b,                field, aParent, bParent);\n+            case MemorySegment x -> checkEQimpl(x, (MemorySegment) b,       field, aParent, bParent);\n+            case Exception x -> checkEQimpl(x, (Exception) b,               field, aParent, bParent);\n@@ -97,4 +151,5 @@\n-                System.err.println(\"ERROR: Verify.checkEQ failed: type not supported: \" + ca.getName());\n-                print(a, \"a \" + context);\n-                print(b, \"b \" + context);\n-                throw new VerifyException(\"Object array type not supported: \" + ca.getName());\n+                if (isVectorAPIClass(ca)) {\n+                    checkEQForVectorAPIClass(a, b, field, aParent, bParent);\n+                } else {\n+                    checkEQArbitraryClasses(a, b);\n+                }\n@@ -108,1 +163,1 @@\n-    private static void checkEQimpl(byte a, byte b, String context) {\n+    private void checkEQimpl(byte a, byte b, String field, Object aParent, Object bParent) {\n@@ -110,1 +165,2 @@\n-            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + a + \" vs \" + b + \" for \" + context);\n+            System.err.println(\"ERROR: Equality matching failed: value mismatch: \" + a + \" vs \" + b);\n+            print(a, b, field, aParent, bParent);\n@@ -118,1 +174,1 @@\n-    private static void checkEQimpl(char a, char b, String context) {\n+    private void checkEQimpl(char a, char b, String field, Object aParent, Object bParent) {\n@@ -120,1 +176,4 @@\n-            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + (int)a + \" vs \" + (int)b + \" for \" + context);\n+            \/\/ Note: we need to cast \"(int)a\", otherwise a char of numerical value \"66\" is\n+            \/\/       formatted as character \"B\".\n+            System.err.println(\"ERROR: Equality matching failed: value mismatch: \" + (int)a + \" vs \" + (int)b);\n+            print(a, b, field, aParent, bParent);\n@@ -128,1 +187,1 @@\n-    private static void checkEQimpl(short a, short b, String context) {\n+    private void checkEQimpl(short a, short b, String field, Object aParent, Object bParent) {\n@@ -130,2 +189,3 @@\n-            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + (int)a + \" vs \" + (int)b + \" for \" + context);\n-            throw new VerifyException(\"Value mismatch: \" + (int)a + \" vs \" + (int)b);\n+            System.err.println(\"ERROR: Equality matching failed: value mismatch: \" + a + \" vs \" + b);\n+            print(a, b, field, aParent, bParent);\n+            throw new VerifyException(\"Value mismatch: \" + a + \" vs \" + b);\n@@ -138,1 +198,1 @@\n-    private static void checkEQimpl(int a, int b, String context) {\n+    private void checkEQimpl(int a, int b, String field, Object aParent, Object bParent) {\n@@ -140,1 +200,2 @@\n-            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + a + \" vs \" + b + \" for \" + context);\n+            System.err.println(\"ERROR: Equality matching failed: value mismatch: \" + a + \" vs \" + b);\n+            print(a, b, field, aParent, bParent);\n@@ -148,1 +209,1 @@\n-    private static void checkEQimpl(long a, long b, String context) {\n+    private void checkEQimpl(long a, long b, String field, Object aParent, Object bParent) {\n@@ -150,1 +211,2 @@\n-            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + a + \" vs \" + b + \" for \" + context);\n+            System.err.println(\"ERROR: Equality matching failed: value mismatch: \" + a + \" vs \" + b);\n+            print(a, b, field, aParent, bParent);\n@@ -156,1 +218,8 @@\n-     * Verify that two floats have identical bits.\n+     * There are two comparison modes: one where we compare the raw bits, which sees different NaN\n+     * encodings as different values, and one where we see all NaN encodings as identical.\n+     * Ideally, we would want to assert that the Float.floatToRawIntBits are identical.\n+     * But the Java spec allows us to return different bits for a NaN, which allows swapping the inputs\n+     * of an add or mul (NaN1 * NaN2 does not have same bits as NaN2 * NaN1, because the multiplication\n+     * of two NaN values should always return the first of the two).\n+     * Hence, by default, we pick the non-raw comparison: we verify that we have the same bit\n+     * pattern in all cases, except for NaN we project to the canonical NaN, using Float.floatToIntBits.\n@@ -158,5 +227,22 @@\n-    private static void checkEQimpl(float a, float b, String context) {\n-        if (Float.floatToRawIntBits(a) != Float.floatToRawIntBits(b)) {\n-            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch for \" + context);\n-            System.err.println(\"       Values: \" + a + \" vs \" + b);\n-            System.err.println(\"       Values: \" + Float.floatToRawIntBits(a) + \" vs \" + Float.floatToRawIntBits(b));\n+    private boolean isFloatEQ(float a, float b) {\n+        return isFloatCheckWithRawBits ? Float.floatToRawIntBits(a) == Float.floatToRawIntBits(b)\n+                                       : Float.floatToIntBits(a) == Float.floatToIntBits(b);\n+    }\n+\n+    \/**\n+     * See comments for {@link #isFloatEQ}.\n+     *\/\n+    private boolean isDoubleEQ(double a, double b) {\n+        return isFloatCheckWithRawBits ? Double.doubleToRawLongBits(a) == Double.doubleToRawLongBits(b)\n+                                       : Double.doubleToLongBits(a) == Double.doubleToLongBits(b);\n+    }\n+\n+    \/**\n+     * Check that two floats are equal according to {@link #isFloatEQ}.\n+     *\/\n+    private void checkEQimpl(float a, float b, String field, Object aParent, Object bParent) {\n+        if (!isFloatEQ(a, b)) {\n+            System.err.println(\"ERROR: Equality matching failed: value mismatch. check raw: \" + isFloatCheckWithRawBits);\n+            System.err.println(\"  Values: \" + a + \" vs \" + b);\n+            System.err.println(\"  Raw:    \" + Float.floatToRawIntBits(a) + \" vs \" + Float.floatToRawIntBits(b));\n+            print(a, b, field, aParent, bParent);\n@@ -168,1 +254,1 @@\n-     * Verify that two doubles have identical bits.\n+     * Check that two doubles are equal according to {@link #isDoubleEQ}.\n@@ -170,3 +256,3 @@\n-    private static void checkEQimpl(double a, double b, String context) {\n-        if (Double.doubleToRawLongBits(a) != Double.doubleToRawLongBits(b)) {\n-            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch for \" + context);\n+    private void checkEQimpl(double a, double b, String field, Object aParent, Object bParent) {\n+        if (!isDoubleEQ(a, b)) {\n+            System.err.println(\"ERROR: Equality matching failed: value mismatch. check raw: \" + isFloatCheckWithRawBits);\n@@ -174,1 +260,13 @@\n-            System.err.println(\"       Values: \" + Double.doubleToRawLongBits(a) + \" vs \" + Double.doubleToRawLongBits(b));\n+            System.err.println(\"       Raw:    \" + Double.doubleToRawLongBits(a) + \" vs \" + Double.doubleToRawLongBits(b));\n+            print(a, b, field, aParent, bParent);\n+            throw new VerifyException(\"Value mismatch: \" + a + \" vs \" + b);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that two booleans are identical.\n+     *\/\n+    private void checkEQimpl(boolean a, boolean b, String field, Object aParent, Object bParent) {\n+        if (a != b) {\n+            System.err.println(\"ERROR: Equality matching failed: value mismatch: \" + a + \" vs \" + b);\n+            print(a, b, field, aParent, bParent);\n@@ -180,1 +278,1 @@\n-     * Verify that the content of two MemorySegments is identical. Note: we do not check the\n+     * Verify that the contents of two MemorySegments are identical. Note: we do not check the\n@@ -183,1 +281,1 @@\n-    private static void checkEQimpl(MemorySegment a, MemorySegment b, String context) {\n+    private void checkEQimpl(MemorySegment a, MemorySegment b, String field, Object aParent, Object bParent) {\n@@ -188,1 +286,1 @@\n-        System.err.println(\"ERROR: Verify.checkEQ failed for: \" + context);\n+        System.err.println(\"ERROR: Equality matching failed\");\n@@ -190,2 +288,3 @@\n-        printMemorySegment(a, \"a \" + context);\n-        printMemorySegment(b, \"b \" + context);\n+        print(a, b, field, aParent, bParent);\n+        printMemorySegment(a, \"a\");\n+        printMemorySegment(b, \"b\");\n@@ -206,1 +305,28 @@\n-     * Verify that the content of two byte arrays is identical.\n+     * Verify that two Exceptions have the same message. Messages are not always carried,\n+     * they are often dropped for performance reasons, and that is okay. But if both Exceptions\n+     * have the message, we should compare them.\n+     *\/\n+    private void checkEQimpl(Exception a, Exception b, String field, Object aParent, Object bParent) {\n+        String am = a.getMessage();\n+        String bm = b.getMessage();\n+\n+        \/\/ Missing messages is expected, but if they both have one, they must agree.\n+        if (am == null || bm == null) { return; }\n+        if (am.equals(bm)) { return; }\n+\n+        System.err.println(\"ERROR: Equality matching failed:\");\n+        System.err.println(\"a: \" + a.getMessage());\n+        System.err.println(\"b: \" + b.getMessage());\n+        print(a, b, field, aParent, bParent);\n+        throw new VerifyException(\"Exception message mismatch: \" + a + \" vs \" + b);\n+    }\n+\n+    \/**\n+     * Verify that the contents of two byte arrays are identical.\n+     *\/\n+    private void checkEQimpl(byte[] a, byte[] b, String field, Object aParent, Object bParent) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), field + \" -> to MemorySegment\", aParent, bParent);\n+    }\n+\n+    \/**\n+     * Verify that the contents of two char arrays are identical.\n@@ -208,2 +334,2 @@\n-    private static void checkEQimpl(byte[] a, byte[] b, String context) {\n-        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    private void checkEQimpl(char[] a, char[] b, String field, Object aParent, Object bParent) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), field + \" -> to MemorySegment\", aParent, bParent);\n@@ -213,1 +339,1 @@\n-     * Verify that the content of two char arrays is identical.\n+     * Verify that the contents of two short arrays are identical.\n@@ -215,2 +341,2 @@\n-    private static void checkEQimpl(char[] a, char[] b, String context) {\n-        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    private void checkEQimpl(short[] a, short[] b, String field, Object aParent, Object bParent) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), field + \" -> to MemorySegment\", aParent, bParent);\n@@ -220,1 +346,1 @@\n-     * Verify that the content of two short arrays is identical.\n+     * Verify that the contents of two int arrays are identical.\n@@ -222,2 +348,2 @@\n-    private static void checkEQimpl(short[] a, short[] b, String context) {\n-        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    private void checkEQimpl(int[] a, int[] b, String field, Object aParent, Object bParent) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), field + \" -> to MemorySegment\", aParent, bParent);\n@@ -227,1 +353,1 @@\n-     * Verify that the content of two int arrays is identical.\n+     * Verify that the contents of two long arrays are identical.\n@@ -229,2 +355,2 @@\n-    private static void checkEQimpl(int[] a, int[] b, String context) {\n-        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    private void checkEQimpl(long[] a, long[] b, String field, Object aParent, Object bParent) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), field + \" -> to MemorySegment\", aParent, bParent);\n@@ -234,1 +360,1 @@\n-     * Verify that the content of two long arrays is identical.\n+     * Check that two float arrays are equal according to {@link #isFloatEQ}.\n@@ -236,2 +362,14 @@\n-    private static void checkEQimpl(long[] a, long[] b, String context) {\n-        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    private void checkEQimpl(float[] a, float[] b, String field, Object aParent, Object bParent) {\n+        if (a.length != b.length) {\n+            System.err.println(\"ERROR: Equality matching failed: length mismatch: \" + a.length + \" vs \" + b.length);\n+            print(a, b, field, aParent, bParent);\n+            throw new VerifyException(\"Float array length mismatch.\");\n+        }\n+\n+        for (int i = 0; i < a.length; i++) {\n+            if (!isFloatEQ(a[i], b[i])) {\n+                System.err.println(\"ERROR: Equality matching failed: value mismatch at \" + i + \": \" + a[i] + \" vs \" + b[i] + \". check raw: \" + isFloatCheckWithRawBits);\n+                print(a, b, field, aParent, bParent);\n+                throw new VerifyException(\"Float array value mismatch \" + a[i] + \" vs \" + b[i]);\n+            }\n+        }\n@@ -241,1 +379,1 @@\n-     * Verify that the content of two float arrays is identical.\n+     * Check that two double arrays are equal according to {@link #isDoubleEQ}.\n@@ -243,2 +381,14 @@\n-    private static void checkEQimpl(float[] a, float[] b, String context) {\n-        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    private void checkEQimpl(double[] a, double[] b, String field, Object aParent, Object bParent) {\n+        if (a.length != b.length) {\n+            System.err.println(\"ERROR: Equality matching failed: length mismatch: \" + a.length + \" vs \" + b.length);\n+            print(a, b, field, aParent, bParent);\n+            throw new VerifyException(\"Double array length mismatch.\");\n+        }\n+\n+        for (int i = 0; i < a.length; i++) {\n+            if (!isDoubleEQ(a[i], b[i])) {\n+                System.err.println(\"ERROR: Equality matching failed: value mismatch at \" + i + \": \" + a[i] + \" vs \" + b[i] + \". check raw: \" + isFloatCheckWithRawBits);\n+                print(a, b, field, aParent, bParent);\n+                throw new VerifyException(\"Double array value mismatch \" + a[i] + \" vs \" + b[i]);\n+            }\n+        }\n@@ -248,1 +398,1 @@\n-     * Verify that the content of two double arrays is identical.\n+     * Verify that the contents of two boolean arrays are identical.\n@@ -250,2 +400,14 @@\n-    private static void checkEQimpl(double[] a, double[] b, String context) {\n-        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    private void checkEQimpl(boolean[] a, boolean[] b, String field, Object aParent, Object bParent) {\n+        if (a.length != b.length) {\n+            System.err.println(\"ERROR: Equality matching failed: length mismatch: \" + a.length + \" vs \" + b.length);\n+            print(a, b, field, aParent, bParent);\n+            throw new VerifyException(\"Boolean array length mismatch.\");\n+        }\n+\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] != b[i]) {\n+                System.err.println(\"ERROR: Equality matching failed: value mismatch at \" + i + \": \" + a[i] + \" vs \" + b[i]);\n+                print(a, b, field, aParent, bParent);\n+                throw new VerifyException(\"Boolean array value mismatch.\");\n+            }\n+        }\n@@ -255,1 +417,1 @@\n-     * Verify that the content of two Object arrays is identical, recursively:\n+     * Verify that the contents of two Object arrays are identical, recursively:\n@@ -258,1 +420,1 @@\n-    private static void checkEQimpl(Object[] a, Object[] b, String context) {\n+    private void checkEQimpl(Object[] a, Object[] b, String field, Object aParent, Object bParent) {\n@@ -261,1 +423,2 @@\n-            System.err.println(\"ERROR: Verify.checkEQ failed: length mismatch: \" + a.length + \" vs \" + b.length);\n+            System.err.println(\"ERROR: Equality matching failed: length mismatch: \" + a.length + \" vs \" + b.length);\n+            print(a, b, field, aParent, bParent);\n@@ -267,1 +430,1 @@\n-            checkEQ(a[i], b[i], \"[\" + i + \"]\" + context);\n+            checkEQdispatch(a[i], b[i], \"[\" + i + \"]\", a, b);\n@@ -271,3 +434,84 @@\n-    private static void print(Object a, String context) {\n-        if (a == null) {\n-            System.err.println(\"  \" + context + \": null\");\n+    private static boolean isVectorAPIClass(Class<?> c) {\n+        return c.getName().startsWith(\"jdk.incubator.vector\") &&\n+               c.getName().contains(\"Vector\");\n+    }\n+\n+    \/**\n+     * We do not want to import jdk.incubator.vector explicitly, because it would mean we would also have\n+     * to add \"--add-modules=jdk.incubator.vector\" to the command-line of every test that uses the Verify\n+     * class. So we hack this via reflection.\n+     *\/\n+    private void checkEQForVectorAPIClass(Object a, Object b, String field, Object aParent, Object bParent) {\n+        Class<?> ca = a.getClass();\n+        Object va;\n+        Object vb;\n+        try {\n+            Method m = ca.getMethod(\"toArray\");\n+            m.setAccessible(true);\n+            va = m.invoke(a);\n+            vb = m.invoke(b);\n+        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n+            throw new RuntimeException(\"Could not invoke toArray on \" + ca.getName(), e);\n+        }\n+        checkEQdispatch(va, vb, field + \".toArray\", aParent, bParent);\n+    }\n+\n+    private void checkEQArbitraryClasses(Object a, Object b) {\n+        Class<?> c = a.getClass();\n+        while (c != Object.class) {\n+            for (Field field : c.getDeclaredFields()) {\n+                Object va;\n+                Object vb;\n+                try {\n+                    field.setAccessible(true);\n+                    va = field.get(a);\n+                    vb = field.get(b);\n+                } catch (IllegalAccessException e) {\n+                    throw new VerifyException(\"Failure to access field: \" + field + \" of \" + a);\n+                }\n+                checkEQdispatch(va, vb, field.getName(), a, b);\n+            }\n+            c = c.getSuperclass();\n+        }\n+    }\n+\n+    private void print(Object a, Object b, String field, Object aParent, Object bParent) {\n+        System.err.println(\"  aParent: \" + (aParent != null ? aParent : \"<none>\"));\n+        System.err.println(\"  bParent: \" + (bParent != null ? bParent : \"<none>\"));\n+        System.err.println(\"  field:   \" + field);\n+        System.err.println(\"  a:       \" + a);\n+        System.err.println(\"  b:       \" + b);\n+    }\n+\n+\n+    \/**\n+     * When comparing arbitrary classes recursively, we need to remember which\n+     * pairs of objects {@code (a, b)} we have already visited. The maps\n+     * {@link #a2b} and {@link #b2a} track these edges. Caching which pairs\n+     * we have already visited means the traversal only needs to visit every\n+     * pair once. And should we ever find a pair {@code (a, b')} or {@code (a', b)},\n+     * then we know that the two structures are not structurally equivalent.\n+     *\/\n+    private boolean checkAlreadyVisited(Object a, Object b, String field, Object aParent, Object bParent) {\n+        \/\/ Boxed primitives are not guaranteed to be the same Object for the same primitive value.\n+        \/\/ Hence, we cannot use the mapping below. We test these boxed primitive types by value anyway,\n+        \/\/ and they are no recursive structures, so there is no point in optimizing here anyway.\n+        switch (a) {\n+            case Boolean _,\n+                 Byte _,\n+                 Short _,\n+                 Character _,\n+                 Integer _,\n+                 Long _,\n+                 Float _,\n+                 Double _ -> { return false; }\n+            default -> {}\n+        }\n+\n+        Object bPrevious = a2b.get(a);\n+        Object aPrevious = b2a.get(b);\n+        if (aPrevious == null && bPrevious == null) {\n+            \/\/ Record for next time.\n+            a2b.put(a, b);\n+            b2a.put(b, a);\n+            return false;\n@@ -275,1 +519,8 @@\n-            System.err.println(\"  \" + context + \": \" + a);\n+            if (a != aPrevious || b != bPrevious) {\n+                System.err.println(\"ERROR: Equality matching failed:\");\n+                print(a, b, field, aParent, bParent);\n+                System.err.println(\"  aPrevious: \" + aPrevious);\n+                System.err.println(\"  bPrevious: \" + bPrevious);\n+                throw new VerifyException(\"Mismatch with previous pair.\");\n+            }\n+            return true;\n@@ -279,1 +530,1 @@\n-    private static void printMemorySegment(MemorySegment a, String context) {\n+    private void printMemorySegment(MemorySegment a, String name) {\n@@ -281,1 +532,1 @@\n-        System.err.println(\"  \" + context + \" via MemorySegment:\");\n+        System.err.println(\"  MemorySegment \" + name + \":\");\n@@ -292,1 +543,1 @@\n-    private static void printMemorySegmentValue(MemorySegment a, long offset, int range) {\n+    private void printMemorySegmentValue(MemorySegment a, long offset, int range) {\n@@ -299,1 +550,1 @@\n-        System.err.println(\"\");\n+        System.err.println();\n@@ -307,1 +558,1 @@\n-        System.err.println(\"\");\n+        System.err.println();\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/verify\/Verify.java","additions":351,"deletions":100,"binary":false,"changes":451,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Example test to show Verify.checkEQ with the VectorAPI.\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib \/\n+ * @run main verify.examples.TestWithVectorAPI\n+ *\/\n+\n+package verify.examples;\n+\n+import jdk.incubator.vector.*;\n+\n+import compiler.lib.verify.*;\n+\n+\/**\n+ * Example to show the use of Verify.checkEQ with the VectorAPI.\n+ *\/\n+public class TestWithVectorAPI {\n+    public static void main(String[] args) {\n+        IntVector iv1 = IntVector.broadcast(IntVector.SPECIES_64, 7);\n+        IntVector iv2 = IntVector.broadcast(IntVector.SPECIES_64, 35);\n+        IntVector iv3 = IntVector.broadcast(IntVector.SPECIES_64, 42);\n+        IntVector iv4 = iv1.add(iv2);\n+        Verify.checkEQ(iv3, iv4);\n+\n+        FloatVector fv1 = FloatVector.broadcast(FloatVector.SPECIES_64, 7);\n+        FloatVector fv2 = FloatVector.broadcast(FloatVector.SPECIES_64, 35);\n+        FloatVector fv3 = FloatVector.broadcast(FloatVector.SPECIES_64, 42);\n+        FloatVector fv4 = fv1.add(fv2);\n+        Verify.checkEQ(fv3, fv4);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/verify\/examples\/TestWithVectorAPI.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -53,0 +53,3 @@\n+        testException();\n+\n+        testRawFloat();\n@@ -56,0 +59,2 @@\n+\n+        testArbitraryClasses();\n@@ -293,0 +298,57 @@\n+    public static void testException() {\n+        Exception e1 = new ArithmeticException(\"abc\");\n+        Exception e2 = new ArithmeticException(\"abc\");\n+        Exception e3 = new ArithmeticException();\n+        Exception e4 = new ArithmeticException(\"xyz\");\n+        Exception e5 = new RuntimeException(\"abc\");\n+\n+        Verify.checkEQ(e1, e1);\n+        Verify.checkEQ(e1, e2);\n+        Verify.checkEQ(e3, e3);\n+        Verify.checkEQ(e1, e3); \/\/ one has no message\n+\n+        checkNE(e1, e4);\n+        checkNE(e2, e4);\n+        Verify.checkEQ(e3, e4);\n+\n+        Verify.checkEQ(e5, e5);\n+        checkNE(e1, e5);\n+        checkNE(e2, e5);\n+        checkNE(e3, e5);\n+        checkNE(e4, e5);\n+    }\n+\n+    public static void testRawFloat() {\n+        float nanF1 = Float.intBitsToFloat(0x7f800001);\n+        float nanF2 = Float.intBitsToFloat(0x7fffffff);\n+        double nanD1 = Double.longBitsToDouble(0x7ff0000000000001L);\n+        double nanD2 = Double.longBitsToDouble(0x7fffffffffffffffL);\n+\n+        float[] arrF1 = new float[]{nanF1};\n+        float[] arrF2 = new float[]{nanF2};\n+        double[] arrD1 = new double[]{nanD1};\n+        double[] arrD2 = new double[]{nanD2};\n+\n+        Verify.checkEQ(nanF1, Float.NaN);\n+        Verify.checkEQ(nanF1, nanF1);\n+        Verify.checkEQWithRawBits(nanF1, nanF1);\n+        Verify.checkEQ(nanF1, nanF2);\n+        Verify.checkEQ(nanD1, Double.NaN);\n+        Verify.checkEQ(nanD1, nanD1);\n+        Verify.checkEQWithRawBits(nanD1, nanD1);\n+        Verify.checkEQ(nanD1, nanD2);\n+\n+        Verify.checkEQ(arrF1, arrF1);\n+        Verify.checkEQWithRawBits(arrF1, arrF1);\n+        Verify.checkEQ(arrF1, arrF2);\n+        Verify.checkEQ(arrD1, arrD1);\n+        Verify.checkEQWithRawBits(arrD1, arrD1);\n+        Verify.checkEQ(arrD1, arrD2);\n+\n+        checkNEWithRawBits(nanF1, nanF2);\n+        checkNEWithRawBits(nanD1, nanD2);\n+\n+        checkNEWithRawBits(arrF1, arrF2);\n+        checkNEWithRawBits(arrD1, arrD2);\n+    }\n+\n@@ -403,1 +465,1 @@\n-            checkNE(Float.intBitsToFloat(v1), Float.intBitsToFloat(v2));\n+            checkNEWithRawBits(Float.intBitsToFloat(v1), Float.intBitsToFloat(v2));\n@@ -409,1 +471,23 @@\n-            checkNE(Double.longBitsToDouble(v1), Double.longBitsToDouble(v2));\n+            checkNEWithRawBits(Double.longBitsToDouble(v1), Double.longBitsToDouble(v2));\n+        }\n+    }\n+\n+    static class A {}\n+\n+    static class B {}\n+\n+    static class C extends B {}\n+\n+    static class D {\n+        D(int x) {\n+            this.x = x;\n+        }\n+\n+        private int x;\n+    }\n+\n+    static class E {\n+        E(D d, E e1, E e2) {\n+            this.d = d;\n+            this.e1 = e1;\n+            this.e2 = e2;\n@@ -411,0 +495,184 @@\n+\n+        private D d;\n+        public E e1;\n+        public E e2;\n+    }\n+\n+    static class F {\n+        private int x;\n+\n+        public F(int x) {\n+            this.x = x;\n+        }\n+    }\n+\n+    static class F2 extends F {\n+        private int y;\n+\n+        F2(int x, int y) {\n+            super(x);\n+            this.y = y;\n+        }\n+    }\n+\n+    static class G {\n+        private float x;\n+        private float y;\n+\n+        public G(float x, float y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+    }\n+\n+    public static class H1 {\n+        public boolean bool = true;\n+        public byte b = (byte)242;\n+        public short s = (short)24242;\n+        public char c = (char)24242;\n+        public int i = 1335836768;\n+        public long l = 4242424242L;\n+        public float f = 42.0f;\n+        public double d = 42.0;\n+        public H1() {}\n+    }\n+\n+    public static class H2 extends H1 {\n+        public H1 h1 = new H1();\n+        public H2() {}\n+    }\n+\n+    static record R1() {}\n+    static record R2() {}\n+    static record R3(int x, int y) {}\n+    static record R4(R4 x, R4 y) {}\n+\n+    public static void testArbitraryClasses() {\n+        A a1 = new A();\n+        A a2 = new A();\n+        B b1 = new B();\n+        B b2 = new B();\n+        C c1 = new C();\n+        C c2 = new C();\n+\n+        \/\/ Structurally equivalent.\n+        Verify.checkEQ(a1, a1);\n+        Verify.checkEQ(a1, a2);\n+        Verify.checkEQ(b1, b1);\n+        Verify.checkEQ(b1, b2);\n+        Verify.checkEQ(c1, c1);\n+        Verify.checkEQ(c1, c2);\n+\n+        \/\/ Must fail because of different classes.\n+        checkNE(a1, b1);\n+        checkNE(b1, a1);\n+        checkNE(a1, c1);\n+        checkNE(c1, a1);\n+        checkNE(b1, c1);\n+        checkNE(c1, b1);\n+\n+        \/\/ Objects with primitive values.\n+        D d1 = new D(1);\n+        D d2 = new D(1);\n+        D d3 = new D(2);\n+        Verify.checkEQ(d1, d1);\n+        Verify.checkEQ(d1, d2);\n+        Verify.checkEQ(d2, d1);\n+        checkNE(d1, d3);\n+        checkNE(d3, d1);\n+\n+        \/\/ Object fields, including cycles.\n+        E e1 = new E(d1, null, null);\n+        E e2 = new E(d1, null, null);\n+        E e3 = new E(d3, null, null);\n+        E e4 = new E(d1, e1, null);\n+        E e5 = new E(d1, e2, null);\n+        E e6 = new E(d1, null, null);\n+        e6.e1 = e6;\n+        E e7 = new E(d1, null, null);\n+        e7.e1 = e7;\n+        E e8 = new E(d1, e1, e1);\n+        E e9 = new E(d1, e1, e2);\n+\n+        Verify.checkEQ(e1, e1);\n+        Verify.checkEQ(e1, e2);\n+        Verify.checkEQ(e2, e1);\n+        checkNE(e1, e3);\n+        checkNE(e3, e1);\n+        Verify.checkEQ(e6, e6);\n+        Verify.checkEQ(e6, e7);\n+        Verify.checkEQ(e7, e6);\n+        Verify.checkEQ(e8, e8);\n+        checkNE(e8, e9);\n+        checkNE(e9, e8);\n+\n+        \/\/ Fields from superclass.\n+        F2 f1 = new F2(1, 1);\n+        F2 f2 = new F2(1, 1);\n+        F2 f3 = new F2(2, 1);\n+        F2 f4 = new F2(1, 2);\n+\n+        Verify.checkEQ(f1, f1);\n+        Verify.checkEQ(f1, f2);\n+        Verify.checkEQ(f2, f1);\n+        checkNE(f1, f3);\n+        checkNE(f1, f4);\n+        checkNE(f3, f1);\n+        checkNE(f4, f1);\n+        checkNE(f3, f4);\n+        checkNE(f4, f3);\n+\n+        G g1 = new G(1.0f, 1.0f);\n+        G g2 = new G(1.0f, 1.0f);\n+        G g3 = new G(Float.NaN, Float.NaN);\n+        G g4 = new G(Float.NaN, Float.NaN);\n+\n+        Verify.checkEQ(g1, g1);\n+        Verify.checkEQ(g2, g1);\n+        Verify.checkEQ(g1, g2);\n+        Verify.checkEQ(g3, g3);\n+        Verify.checkEQ(g3, g4);\n+        Verify.checkEQ(g4, g3);\n+        checkNE(g1, g3);\n+        checkNE(g3, g1);\n+\n+        \/\/ Nested class with primitive types, where the boxed types may not be cached,\n+        \/\/ and so they would create different boxed objects.\n+        Verify.checkEQ(new H2(), new H2());\n+\n+        \/\/ Records.\n+        R1 r11 = new R1();\n+        R1 r12 = new R1();\n+        R2 r21 = new R2();\n+        R3 r31 = new R3(1, 1);\n+        R3 r32 = new R3(1, 1);\n+        R3 r33 = new R3(1, 2);\n+        R3 r34 = new R3(2, 1);\n+\n+        Verify.checkEQ(r11, r11);\n+        Verify.checkEQ(r11, r12);\n+        Verify.checkEQ(r12, r11);\n+        checkNE(r11, r21);\n+        Verify.checkEQ(r31, r31);\n+        Verify.checkEQ(r31, r32);\n+        Verify.checkEQ(r32, r31);\n+        checkNE(r31, r33);\n+        checkNE(r33, r31);\n+        checkNE(r31, r34);\n+        checkNE(r34, r31);\n+        checkNE(r33, r34);\n+\n+        R4 r41 = new R4(null, null);\n+        R4 r42 = new R4(null, null);\n+        R4 r43 = new R4(r41, null);\n+        R4 r44 = new R4(r42, null);\n+        R4 r45 = new R4(r43, r41);\n+        R4 r46 = new R4(r44, r42);\n+        R4 r47 = new R4(r44, r41);\n+\n+        Verify.checkEQ(r45, r46);\n+        Verify.checkEQ(r46, r45);\n+        checkNE(r45, r47);\n+        checkNE(r47, r45);\n+        checkNE(r46, r47);\n+        checkNE(r47, r46);\n@@ -416,1 +684,8 @@\n-            throw new RuntimeException(\"Should have thrown\");\n+            throw new RuntimeException(\"Should have thrown: \" + a + \" vs \" + b);\n+        } catch (VerifyException e) {}\n+    }\n+\n+    public static void checkNEWithRawBits(Object a, Object b) {\n+         try {\n+            Verify.checkEQWithRawBits(a, b);\n+            throw new RuntimeException(\"Should have thrown: \" + a + \" vs \" + b);\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/verify\/tests\/TestVerify.java","additions":278,"deletions":3,"binary":false,"changes":281,"status":"modified"}]}