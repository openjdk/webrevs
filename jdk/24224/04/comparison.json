{"files":[{"patch":"@@ -28,0 +28,6 @@\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.HashMap;\n+import java.util.ArrayList;\n+\n@@ -30,3 +36,5 @@\n- * The {@link Verify} class provides a single {@link Verify#checkEQ} static method, which recursively\n- * compares the two {@link Object}s by value. It deconstructs {@link Object[]}, compares boxed primitive\n- * types, and compares the content of arrays and {@link MemorySegment}s.\n+ * The {@link Verify} class provides {@link Verify#checkEQ}, which recursively compares the two\n+ * {@link Object}s by value. It deconstructs {@link Object[]}, compares boxed primitive types,\n+ * compares the content of arrays and {@link MemorySegment}s, and checks that the messages of two\n+ * {@link Exception}s are equal. It also checks for the equivalent content in {@code Vector}s from\n+ * the Vector API.\n@@ -34,0 +42,1 @@\n+ * <p>\n@@ -35,0 +44,13 @@\n+ *\n+ * <p>\n+ * We have to take special care of {@link Float}s and {@link Double}s, since they have both various\n+ * encodings for NaN values, but on Java specification they are to be regarded as equal. Hence, we\n+ * have two modes of comparison. By default, different NaN values are regarded as equal. This applies\n+ * to the boxed floating types, as well as arrays of floating arrays. With {@link Options#enableFloatCheckWithRawBits},\n+ * we compare the raw bits, and so different NaN encodings are not equal.\n+ * Note: {@link MemorySegment} data is always compared with raw bits.\n+ *\n+ * <p>\n+ * By default, we only support comparison of the types mentioned above. However, in some cases one\n+ * might want to compare Objects of arbitrary classes by value, i.e. the recursive structure given\n+ * by their field values. This feature can be enabled with {@link Options#enableCheckWithArbitraryClasses}.\n@@ -38,1 +60,43 @@\n-    private Verify() {}\n+    \/**\n+     * The {@link Options} class allows the specification of further verification options.\n+     *\/\n+    public final static class Options {\n+        boolean isFloatCheckWithRawBits;\n+        boolean isCheckWithArbitraryClasses;\n+\n+        \/**\n+         * Generates a {@link Options} with default settings.\n+         *\/\n+        public Options() {}\n+\n+        \/**\n+         * By default, different NaN values are regarded as equal, but with this option enabled,\n+         * we compare the raw bits, and different NaN encodings are regarded as not equal.\n+         *\n+         * @return The {@code this} reference for chaining.\n+         *\/\n+        public Options enableFloatCheckWithRawBits() {\n+            isFloatCheckWithRawBits = true;\n+            return this;\n+        }\n+\n+        \/**\n+         * By default, we only support the comparison of a limited set of types, but with this option\n+         * enabled, we can compare arbitrary classes by value, and we compare the Objects by\n+         * the recursive structore given by their field values.\n+         *\n+         * @return The {@code this} reference for chaining.\n+         *\/\n+        public Options enableCheckWithArbitraryClasses() {\n+            isCheckWithArbitraryClasses = true;\n+            return this;\n+        }\n+    }\n+\n+    private final Options verifyOptions;\n+    private final HashMap<Object, Object> a2b = new HashMap<>();\n+    private final HashMap<Object, Object> b2a = new HashMap<>();\n+\n+    private Verify(Options verifyOptions) {\n+        this.verifyOptions = verifyOptions;\n+    }\n@@ -41,1 +105,1 @@\n-     * Verify the content of two Objects, possibly recursively. Only limited types are implemented.\n+     * Verify the content of two Objects, possibly recursively.\n@@ -45,0 +109,1 @@\n+     * @param verifyOptions Allows specification of further options.\n@@ -47,2 +112,3 @@\n-    public static void checkEQ(Object a, Object b) {\n-        checkEQ(a, b, \"\");\n+    public static void checkEQ(Object a, Object b, Options verifyOptions) {\n+        Verify v = new Verify(verifyOptions);\n+        v.checkEQdispatch(a, b, \"<root>\", null, null);\n@@ -52,1 +118,7 @@\n-     * Verify the content of two Objects, possibly recursively. Only limited types are implemented.\n+     * Verify the content of two Objects, possibly recursively.\n+     * Only limited types are implemented (no arbitrary classes).\n+     * Different NaN encodins are considered equal.\n+     *\n+     * @param a First object to be recursively compared with the second.\n+     * @param b Second object to be recursively compared with the first.\n+     * @throws VerifyException If the comparison fails.\n@@ -54,1 +126,5 @@\n-    private static void checkEQ(Object a, Object b, String context) {\n+    public static void checkEQ(Object a, Object b) {\n+        checkEQ(a, b, new Options());\n+    }\n+\n+    private void checkEQdispatch(Object a, Object b, String field, Object aParent, Object bParent) {\n@@ -63,2 +139,1 @@\n-            print(a, \"a \" + context);\n-            print(b, \"b \" + context);\n+            print(a, b, field, aParent, bParent);\n@@ -74,2 +149,1 @@\n-            print(a, \"a \" + context);\n-            print(b, \"b \" + context);\n+            print(a, b, field, aParent, bParent);\n@@ -79,0 +153,6 @@\n+        \/\/ Already visited? This makes sure that we are not stuck in cycles, and that we have\n+        \/\/ a mapping of pairs (a, b) for structurally equivalent Objects.\n+        if (checkAlreadyVisited(a, b, field, aParent, bParent)) {\n+            return;\n+        }\n+\n@@ -80,16 +160,19 @@\n-            case Object[]  x -> checkEQimpl(x, (Object[])b,                context);\n-            case Byte      x -> checkEQimpl(x, ((Byte)b).byteValue(),      context);\n-            case Character x -> checkEQimpl(x, ((Character)b).charValue(), context);\n-            case Short     x -> checkEQimpl(x, ((Short)b).shortValue(),    context);\n-            case Integer   x -> checkEQimpl(x, ((Integer)b).intValue(),    context);\n-            case Long      x -> checkEQimpl(x, ((Long)b).longValue(),      context);\n-            case Float     x -> checkEQimpl(x, ((Float)b).floatValue(),    context);\n-            case Double    x -> checkEQimpl(x, ((Double)b).doubleValue(),  context);\n-            case byte[]    x -> checkEQimpl(x, (byte[])b,                  context);\n-            case char[]    x -> checkEQimpl(x, (char[])b,                  context);\n-            case short[]   x -> checkEQimpl(x, (short[])b,                 context);\n-            case int[]     x -> checkEQimpl(x, (int[])b,                   context);\n-            case long[]    x -> checkEQimpl(x, (long[])b,                  context);\n-            case float[]   x -> checkEQimpl(x, (float[])b,                 context);\n-            case double[]  x -> checkEQimpl(x, (double[])b,                context);\n-            case MemorySegment x -> checkEQimpl(x, (MemorySegment) b,      context);\n+            case Object[]  x -> checkEQimpl(x, (Object[])b,                 field, aParent, bParent);\n+            case Byte      x -> checkEQimpl(x, ((Byte)b).byteValue(),       field, aParent, bParent);\n+            case Character x -> checkEQimpl(x, ((Character)b).charValue(),  field, aParent, bParent);\n+            case Short     x -> checkEQimpl(x, ((Short)b).shortValue(),     field, aParent, bParent);\n+            case Integer   x -> checkEQimpl(x, ((Integer)b).intValue(),     field, aParent, bParent);\n+            case Long      x -> checkEQimpl(x, ((Long)b).longValue(),       field, aParent, bParent);\n+            case Float     x -> checkEQimpl(x, ((Float)b).floatValue(),     field, aParent, bParent);\n+            case Double    x -> checkEQimpl(x, ((Double)b).doubleValue(),   field, aParent, bParent);\n+            case Boolean   x -> checkEQimpl(x, ((Boolean)b).booleanValue(), field, aParent, bParent);\n+            case byte[]    x -> checkEQimpl(x, (byte[])b,                   field, aParent, bParent);\n+            case char[]    x -> checkEQimpl(x, (char[])b,                   field, aParent, bParent);\n+            case short[]   x -> checkEQimpl(x, (short[])b,                  field, aParent, bParent);\n+            case int[]     x -> checkEQimpl(x, (int[])b,                    field, aParent, bParent);\n+            case long[]    x -> checkEQimpl(x, (long[])b,                   field, aParent, bParent);\n+            case float[]   x -> checkEQimpl(x, (float[])b,                  field, aParent, bParent);\n+            case double[]  x -> checkEQimpl(x, (double[])b,                 field, aParent, bParent);\n+            case boolean[] x -> checkEQimpl(x, (boolean[])b,                field, aParent, bParent);\n+            case MemorySegment x -> checkEQimpl(x, (MemorySegment) b,       field, aParent, bParent);\n+            case Exception x -> checkEQimpl(x, (Exception) b,               field, aParent, bParent);\n@@ -97,4 +180,30 @@\n-                System.err.println(\"ERROR: Verify.checkEQ failed: type not supported: \" + ca.getName());\n-                print(a, \"a \" + context);\n-                print(b, \"b \" + context);\n-                throw new VerifyException(\"Object array type not supported: \" + ca.getName());\n+                if (ca.getName().startsWith(\"jdk.incubator.vector\") && ca.getName().contains(\"Vector\")) {\n+                    \/\/ We do not want to import jdk.incubator.vector explicitly, because it would mean we would also have\n+                    \/\/ to add \"--add-modules=jdk.incubator.vector\" to the command-line of every test that uses the Verify\n+                    \/\/ class. So we hack this via reflection.\n+                    Object va = null;\n+                    Object vb = null;\n+                    try {\n+                        Method m = ca.getMethod(\"toArray\");\n+                        m.setAccessible(true);\n+                        va = m.invoke(a);\n+                        vb = m.invoke(b);\n+                    } catch (NoSuchMethodException e) {\n+                        throw new RuntimeException(\"Could not invoke toArray on \" + ca.getName(), e);\n+                    } catch (IllegalAccessException e) {\n+                        throw new RuntimeException(\"Could not invoke toArray on \" + ca.getName(), e);\n+                    } catch (InvocationTargetException e) {\n+                        throw new RuntimeException(\"Could not invoke toArray on \" + ca.getName(), e);\n+                    }\n+                    checkEQdispatch(va, vb, field + \".toArray\", aParent, bParent);\n+                    return;\n+                }\n+\n+                if (verifyOptions.isCheckWithArbitraryClasses) {\n+                    checkEQArbitraryClasses(a, b);\n+                    return;\n+                } else {\n+                    System.err.println(\"ERROR: Verify.checkEQ failed: type not supported: \" + ca.getName());\n+                    print(a, b, field, aParent, bParent);\n+                    throw new VerifyException(\"Object type not supported: \" + ca.getName() + \" -- did you mean to 'enableCheckWithArbitraryClasses'?\");\n+                }\n@@ -108,1 +217,1 @@\n-    private static void checkEQimpl(byte a, byte b, String context) {\n+    private void checkEQimpl(byte a, byte b, String field, Object aParent, Object bParent) {\n@@ -110,1 +219,2 @@\n-            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + a + \" vs \" + b + \" for \" + context);\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + a + \" vs \" + b);\n+            print(a, b, field, aParent, bParent);\n@@ -118,1 +228,1 @@\n-    private static void checkEQimpl(char a, char b, String context) {\n+    private void checkEQimpl(char a, char b, String field, Object aParent, Object bParent) {\n@@ -120,1 +230,2 @@\n-            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + (int)a + \" vs \" + (int)b + \" for \" + context);\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + (int)a + \" vs \" + (int)b);\n+            print(a, b, field, aParent, bParent);\n@@ -128,1 +239,1 @@\n-    private static void checkEQimpl(short a, short b, String context) {\n+    private void checkEQimpl(short a, short b, String field, Object aParent, Object bParent) {\n@@ -130,1 +241,2 @@\n-            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + (int)a + \" vs \" + (int)b + \" for \" + context);\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + (int)a + \" vs \" + (int)b);\n+            print(a, b, field, aParent, bParent);\n@@ -138,1 +250,1 @@\n-    private static void checkEQimpl(int a, int b, String context) {\n+    private void checkEQimpl(int a, int b, String field, Object aParent, Object bParent) {\n@@ -140,1 +252,2 @@\n-            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + a + \" vs \" + b + \" for \" + context);\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + a + \" vs \" + b);\n+            print(a, b, field, aParent, bParent);\n@@ -148,1 +261,1 @@\n-    private static void checkEQimpl(long a, long b, String context) {\n+    private void checkEQimpl(long a, long b, String field, Object aParent, Object bParent) {\n@@ -150,1 +263,2 @@\n-            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + a + \" vs \" + b + \" for \" + context);\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + a + \" vs \" + b);\n+            print(a, b, field, aParent, bParent);\n@@ -156,1 +270,8 @@\n-     * Verify that two floats have identical bits.\n+     * There are two comparison modes: one where we compare the raw bits, which sees different NaN\n+     * encodings as different values, and one where we see all NaN encodings as identical.\n+     * Ideally, we would want to assert that the Float.floatToRawIntBits are identical.\n+     * But the Java spec allows us to return different bits for a NaN, which allows swapping the inputs\n+     * of an add or mul (NaN1 * NaN2 does not have same bits as NaN2 * NaN1, because the multiplication\n+     * of two NaN values should always return the first of the two).\n+     * Hence, by default, we pick the non-raw coparison: we verify that we have the same bit\n+     * pattern in all cases, except for NaN we project to the canonical NaN, using Float.floatToIntBits.\n@@ -158,5 +279,22 @@\n-    private static void checkEQimpl(float a, float b, String context) {\n-        if (Float.floatToRawIntBits(a) != Float.floatToRawIntBits(b)) {\n-            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch for \" + context);\n-            System.err.println(\"       Values: \" + a + \" vs \" + b);\n-            System.err.println(\"       Values: \" + Float.floatToRawIntBits(a) + \" vs \" + Float.floatToRawIntBits(b));\n+    private boolean isFloatEQ(float a, float b) {\n+        return verifyOptions.isFloatCheckWithRawBits ? Float.floatToRawIntBits(a) != Float.floatToRawIntBits(b)\n+                                                     : Float.floatToIntBits(a) != Float.floatToIntBits(b);\n+    }\n+\n+    \/**\n+     * See comments for \"isFloatEQ\".\n+     *\/\n+    private boolean isDoubleEQ(double a, double b) {\n+        return verifyOptions.isFloatCheckWithRawBits ? Double.doubleToRawLongBits(a) != Double.doubleToRawLongBits(b)\n+                                                     : Double.doubleToLongBits(a) != Double.doubleToLongBits(b);\n+    }\n+\n+    \/**\n+     * Check that two floats are equal according to \"isFloatEQ\".\n+     *\/\n+    private void checkEQimpl(float a, float b, String field, Object aParent, Object bParent) {\n+        if (isFloatEQ(a, b)) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch. check raw: \" + verifyOptions.isFloatCheckWithRawBits);\n+            System.err.println(\"  Values: \" + a + \" vs \" + b);\n+            System.err.println(\"  Raw:    \" + Float.floatToRawIntBits(a) + \" vs \" + Float.floatToRawIntBits(b));\n+            print(a, b, field, aParent, bParent);\n@@ -168,1 +306,1 @@\n-     * Verify that two doubles have identical bits.\n+     * Check that two doubles are equal according to \"isDoubleEQ\".\n@@ -170,3 +308,3 @@\n-    private static void checkEQimpl(double a, double b, String context) {\n-        if (Double.doubleToRawLongBits(a) != Double.doubleToRawLongBits(b)) {\n-            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch for \" + context);\n+    private void checkEQimpl(double a, double b, String field, Object aParent, Object bParent) {\n+        if (isDoubleEQ(a, b)) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch. check raw: \" + verifyOptions.isFloatCheckWithRawBits);\n@@ -174,1 +312,13 @@\n-            System.err.println(\"       Values: \" + Double.doubleToRawLongBits(a) + \" vs \" + Double.doubleToRawLongBits(b));\n+            System.err.println(\"       Raw:    \" + Double.doubleToRawLongBits(a) + \" vs \" + Double.doubleToRawLongBits(b));\n+            print(a, b, field, aParent, bParent);\n+            throw new VerifyException(\"Value mismatch: \" + a + \" vs \" + b);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that two booleans are identical.\n+     *\/\n+    private void checkEQimpl(boolean a, boolean b, String field, Object aParent, Object bParent) {\n+        if (a != b) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + a + \" vs \" + b);\n+            print(a, b, field, aParent, bParent);\n@@ -183,1 +333,1 @@\n-    private static void checkEQimpl(MemorySegment a, MemorySegment b, String context) {\n+    private void checkEQimpl(MemorySegment a, MemorySegment b, String field, Object aParent, Object bParent) {\n@@ -188,1 +338,1 @@\n-        System.err.println(\"ERROR: Verify.checkEQ failed for: \" + context);\n+        System.err.println(\"ERROR: Verify.checkEQ failed\");\n@@ -190,2 +340,3 @@\n-        printMemorySegment(a, \"a \" + context);\n-        printMemorySegment(b, \"b \" + context);\n+        print(a, b, field, aParent, bParent);\n+        printMemorySegment(a, \"a\");\n+        printMemorySegment(b, \"b\");\n@@ -205,0 +356,19 @@\n+    \/**\n+     * Verify that the content of two MemorySegments is identical. Note: we do not check the\n+     * backing type, only the size and content.\n+     *\/\n+    private void checkEQimpl(Exception a, Exception b, String field, Object aParent, Object bParent) {\n+        String am = a.getMessage();\n+        String bm = b.getMessage();\n+\n+        \/\/ Missing messages is expected, but if they both have one, they must agree.\n+        if (am == null || bm == null) { return; }\n+        if (am.equals(bm)) { return; }\n+\n+        System.err.println(\"ERROR: Verify.checkEQ failed:\");\n+        System.out.println(\"a: \" + a.getMessage());\n+        System.out.println(\"b: \" + b.getMessage());\n+        print(a, b, field, aParent, bParent);\n+        throw new VerifyException(\"Exception message mismatch: \" + a + \" vs \" + b);\n+    }\n+\n@@ -208,2 +378,2 @@\n-    private static void checkEQimpl(byte[] a, byte[] b, String context) {\n-        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    private void checkEQimpl(byte[] a, byte[] b, String field, Object aParent, Object bParent) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), field + \" -> to MemorySegment\", aParent, bParent);\n@@ -215,2 +385,2 @@\n-    private static void checkEQimpl(char[] a, char[] b, String context) {\n-        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    private void checkEQimpl(char[] a, char[] b, String field, Object aParent, Object bParent) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), field + \" -> to MemorySegment\", aParent, bParent);\n@@ -222,2 +392,2 @@\n-    private static void checkEQimpl(short[] a, short[] b, String context) {\n-        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    private void checkEQimpl(short[] a, short[] b, String field, Object aParent, Object bParent) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), field + \" -> to MemorySegment\", aParent, bParent);\n@@ -229,2 +399,2 @@\n-    private static void checkEQimpl(int[] a, int[] b, String context) {\n-        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    private void checkEQimpl(int[] a, int[] b, String field, Object aParent, Object bParent) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), field + \" -> to MemorySegment\", aParent, bParent);\n@@ -236,2 +406,2 @@\n-    private static void checkEQimpl(long[] a, long[] b, String context) {\n-        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    private void checkEQimpl(long[] a, long[] b, String field, Object aParent, Object bParent) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), field + \" -> to MemorySegment\", aParent, bParent);\n@@ -241,1 +411,1 @@\n-     * Verify that the content of two float arrays is identical.\n+     * Check that two float arrays are equal according to \"isFloatEQ\".\n@@ -243,2 +413,14 @@\n-    private static void checkEQimpl(float[] a, float[] b, String context) {\n-        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    private void checkEQimpl(float[] a, float[] b, String field, Object aParent, Object bParent) {\n+        if (a.length != b.length) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: length mismatch: \" + a.length + \" vs \" + b.length);\n+            print(a, b, field, aParent, bParent);\n+            throw new VerifyException(\"Float array length mismatch.\");\n+        }\n+\n+        for (int i = 0; i < a.length; i++) {\n+            if (isFloatEQ(a[i], b[i])) {\n+                System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch at \" + i + \": \" + a[i] + \" vs \" + b[i] + \". check raw: \" + verifyOptions.isFloatCheckWithRawBits);\n+                print(a, b, field, aParent, bParent);\n+                throw new VerifyException(\"Float array value mismatch \" + a[i] + \" vs \" + b[i]);\n+            }\n+        }\n@@ -248,1 +430,1 @@\n-     * Verify that the content of two double arrays is identical.\n+     * Check that two double arrays are equal according to \"isDoubleEQ\".\n@@ -250,2 +432,33 @@\n-    private static void checkEQimpl(double[] a, double[] b, String context) {\n-        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    private void checkEQimpl(double[] a, double[] b, String field, Object aParent, Object bParent) {\n+        if (a.length != b.length) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: length mismatch: \" + a.length + \" vs \" + b.length);\n+            print(a, b, field, aParent, bParent);\n+            throw new VerifyException(\"Double array length mismatch.\");\n+        }\n+\n+        for (int i = 0; i < a.length; i++) {\n+            if (isDoubleEQ(a[i], b[i])) {\n+                System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch at \" + i + \": \" + a[i] + \" vs \" + b[i] + \". check raw: \" + verifyOptions.isFloatCheckWithRawBits);\n+                print(a, b, field, aParent, bParent);\n+                throw new VerifyException(\"Double array value mismatch \" + a[i] + \" vs \" + b[i]);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Verify that the content of two boolean arrays is identical.\n+     *\/\n+    private void checkEQimpl(boolean[] a, boolean[] b, String field, Object aParent, Object bParent) {\n+        if (a.length != b.length) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: length mismatch: \" + a.length + \" vs \" + b.length);\n+            print(a, b, field, aParent, bParent);\n+            throw new VerifyException(\"Boolean array length mismatch.\");\n+        }\n+\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] != b[i]) {\n+                System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch at \" + i + \": \" + a[i] + \" vs \" + b[i]);\n+                print(a, b, field, aParent, bParent);\n+                throw new VerifyException(\"Boolean array value mismatch.\");\n+            }\n+        }\n@@ -258,1 +471,1 @@\n-    private static void checkEQimpl(Object[] a, Object[] b, String context) {\n+    private void checkEQimpl(Object[] a, Object[] b, String field, Object aParent, Object bParent) {\n@@ -262,0 +475,1 @@\n+            print(a, b, field, aParent, bParent);\n@@ -267,1 +481,1 @@\n-            checkEQ(a[i], b[i], \"[\" + i + \"]\" + context);\n+            checkEQdispatch(a[i], b[i], \"[\" + i + \"]\", a, b);\n@@ -271,3 +485,50 @@\n-    private static void print(Object a, String context) {\n-        if (a == null) {\n-            System.err.println(\"  \" + context + \": null\");\n+    private void checkEQArbitraryClasses(Object a, Object b) {\n+        Class c = a.getClass();\n+        while (c != Object.class) {\n+            for (Field field : c.getDeclaredFields()) {\n+                Object va = null;\n+                Object vb = null;\n+                try {\n+                    field.setAccessible(true);\n+                    va = field.get(a);\n+                    vb = field.get(b);\n+                } catch (IllegalAccessException e) {\n+                    throw new VerifyException(\"Failure to access field: \" + field + \" of \" + a);\n+                }\n+                checkEQdispatch(va, vb, field.getName(), a, b);\n+            }\n+            c = c.getSuperclass();\n+        }\n+    }\n+\n+    private void print(Object a, Object b, String field, Object aParent, Object bParent) {\n+        System.err.println(\"  aParent: \" + aParent);\n+        System.err.println(\"  bParent: \" + bParent);\n+        System.err.println(\"  field:   \" + field);\n+        System.err.println(\"  a:       \" + a);\n+        System.err.println(\"  b:       \" + b);\n+    }\n+\n+    private boolean checkAlreadyVisited(Object a, Object b, String field, Object aParent, Object bParent) {\n+        \/\/ Boxed primitives are not guaranteed to be the same Object for the same primitive value.\n+        \/\/ Hence, we cannot use the mapping below. We test these boxed primitive types by value anyway,\n+        \/\/ and they are no recursive structures, so there is no point in optimizing here anyway.\n+        switch(a) {\n+            case Boolean x -> { return false; }\n+            case Byte x -> { return false; }\n+            case Short x -> { return false; }\n+            case Character x -> { return false; }\n+            case Integer x -> { return false; }\n+            case Long x -> { return false; }\n+            case Float x -> { return false; }\n+            case Double x -> { return false; }\n+            default -> {}\n+        }\n+\n+        Object bPrevious = a2b.get(a);\n+        Object aPrevious = b2a.get(b);\n+        if (aPrevious == null && bPrevious == null) {\n+            \/\/ Record for next time.\n+            a2b.put(a, b);\n+            b2a.put(b, a);\n+            return false;\n@@ -275,1 +536,8 @@\n-            System.err.println(\"  \" + context + \": \" + a);\n+            if (a != aPrevious || b != bPrevious) {\n+                System.err.println(\"ERROR: Verify.checkEQ failed:\");\n+                print(a, b, field, aParent, bParent);\n+                System.err.println(\"  aPrevious: \" + aPrevious);\n+                System.err.println(\"  bPrevious: \" + bPrevious);\n+                throw new VerifyException(\"Mismatch with previous pair.\");\n+            }\n+            return true;\n@@ -279,1 +547,1 @@\n-    private static void printMemorySegment(MemorySegment a, String context) {\n+    private void printMemorySegment(MemorySegment a, String name) {\n@@ -281,1 +549,1 @@\n-        System.err.println(\"  \" + context + \" via MemorySegment:\");\n+        System.err.println(\"  MemorySegment \" + name + \":\");\n@@ -292,1 +560,1 @@\n-    private static void printMemorySegmentValue(MemorySegment a, long offset, int range) {\n+    private void printMemorySegmentValue(MemorySegment a, long offset, int range) {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/verify\/Verify.java","additions":351,"deletions":83,"binary":false,"changes":434,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Example test to show Verify.checkEQ with the VectorAPI.\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib \/\n+ * @run main verify.examples.TestWithVectorAPI\n+ *\/\n+\n+package verify.examples;\n+\n+import jdk.incubator.vector.*;\n+\n+import compiler.lib.verify.*;\n+\n+\/**\n+ * Example to show the use of Verify.checkEQ with the VectorAPI.\n+ *\/\n+public class TestWithVectorAPI {\n+    public static void main(String[] args) {\n+        IntVector iv1 = IntVector.broadcast(IntVector.SPECIES_64, 7);\n+        IntVector iv2 = IntVector.broadcast(IntVector.SPECIES_64, 35);\n+        IntVector iv3 = IntVector.broadcast(IntVector.SPECIES_64, 42);\n+        IntVector iv4 = iv1.add(iv2);\n+        Verify.checkEQ(iv3, iv4);\n+\n+        FloatVector fv1 = FloatVector.broadcast(FloatVector.SPECIES_64, 7);\n+        FloatVector fv2 = FloatVector.broadcast(FloatVector.SPECIES_64, 35);\n+        FloatVector fv3 = FloatVector.broadcast(FloatVector.SPECIES_64, 42);\n+        FloatVector fv4 = fv1.add(fv2);\n+        Verify.checkEQ(fv3, fv4);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/verify\/examples\/TestWithVectorAPI.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -53,0 +53,3 @@\n+        testException();\n+\n+        testRawFloat();\n@@ -56,0 +59,2 @@\n+\n+        testArbitraryClasses();\n@@ -293,0 +298,57 @@\n+    public static void testException() {\n+        Exception e1 = new ArithmeticException(\"abc\");\n+        Exception e2 = new ArithmeticException(\"abc\");\n+        Exception e3 = new ArithmeticException();\n+        Exception e4 = new ArithmeticException(\"xyz\");\n+        Exception e5 = new RuntimeException(\"abc\");\n+\n+        Verify.checkEQ(e1, e1);\n+        Verify.checkEQ(e1, e2);\n+        Verify.checkEQ(e3, e3);\n+        Verify.checkEQ(e1, e3); \/\/ one has no message\n+\n+        checkNE(e1, e4);\n+        checkNE(e2, e4);\n+        Verify.checkEQ(e3, e4);\n+\n+        Verify.checkEQ(e5, e5);\n+        checkNE(e1, e5);\n+        checkNE(e2, e5);\n+        checkNE(e3, e5);\n+        checkNE(e4, e5);\n+    }\n+\n+    public static void testRawFloat() {\n+        float nanF1 = Float.intBitsToFloat(0x7f800001);\n+        float nanF2 = Float.intBitsToFloat(0x7fffffff);\n+        double nanD1 = Double.longBitsToDouble(0x7ff0000000000001L);\n+        double nanD2 = Double.longBitsToDouble(0x7fffffffffffffffL);\n+\n+        float[] arrF1 = new float[]{nanF1};\n+        float[] arrF2 = new float[]{nanF2};\n+        double[] arrD1 = new double[]{nanD1};\n+        double[] arrD2 = new double[]{nanD2};\n+\n+        Verify.checkEQ(nanF1, Float.NaN);\n+        Verify.checkEQ(nanF1, nanF1);\n+        Verify.checkEQ(nanF1, nanF1, new Verify.Options().enableFloatCheckWithRawBits());\n+        Verify.checkEQ(nanF1, nanF2);\n+        Verify.checkEQ(nanD1, Double.NaN);\n+        Verify.checkEQ(nanD1, nanD1);\n+        Verify.checkEQ(nanD1, nanD1, new Verify.Options().enableFloatCheckWithRawBits());\n+        Verify.checkEQ(nanD1, nanD2);\n+\n+        Verify.checkEQ(arrF1, arrF1);\n+        Verify.checkEQ(arrF1, arrF1, new Verify.Options().enableFloatCheckWithRawBits());\n+        Verify.checkEQ(arrF1, arrF2);\n+        Verify.checkEQ(arrD1, arrD1);\n+        Verify.checkEQ(arrD1, arrD1, new Verify.Options().enableFloatCheckWithRawBits());\n+        Verify.checkEQ(arrD1, arrD2);\n+\n+        checkNE(nanF1, nanF2, new Verify.Options().enableFloatCheckWithRawBits());\n+        checkNE(nanD1, nanD2, new Verify.Options().enableFloatCheckWithRawBits());\n+\n+        checkNE(arrF1, arrF2, new Verify.Options().enableFloatCheckWithRawBits());\n+        checkNE(arrD1, arrD2, new Verify.Options().enableFloatCheckWithRawBits());\n+    }\n+\n@@ -403,1 +465,1 @@\n-            checkNE(Float.intBitsToFloat(v1), Float.intBitsToFloat(v2));\n+            checkNE(Float.intBitsToFloat(v1), Float.intBitsToFloat(v2), new Verify.Options().enableFloatCheckWithRawBits());\n@@ -409,1 +471,1 @@\n-            checkNE(Double.longBitsToDouble(v1), Double.longBitsToDouble(v2));\n+            checkNE(Double.longBitsToDouble(v1), Double.longBitsToDouble(v2), new Verify.Options().enableFloatCheckWithRawBits());\n@@ -413,1 +475,210 @@\n-    public static void checkNE(Object a, Object b) {\n+    static class A {}\n+\n+    static class B {}\n+\n+    static class C extends B {}\n+\n+    static class D {\n+        D(int x) {\n+            this.x = x;\n+        }\n+\n+        private int x;\n+    }\n+\n+    static class E {\n+        E(D d, E e1, E e2) {\n+            this.d = d;\n+            this.e1 = e1;\n+            this.e2 = e2;\n+        }\n+\n+        private D d;\n+        public E e1;\n+        public E e2;\n+    }\n+\n+    static class F {\n+        private int x;\n+\n+        public F(int x) {\n+            this.x = x;\n+        }\n+    }\n+\n+    static class F2 extends F {\n+        private int y;\n+\n+        F2(int x, int y) {\n+            super(x);\n+            this.y = y;\n+        }\n+    }\n+\n+    static class G {\n+        private float x;\n+        private float y;\n+\n+        public G(float x, float y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+    }\n+\n+    public static class H1  {\n+        public boolean bool = true;\n+        public byte b = (byte)242;\n+        public short s = (short)24242;\n+        public char c = (char)24242;\n+        public int i = 1335836768;\n+        public long l = 4242424242L;\n+        public float f = 42.0f;\n+        public double d = 42.0;\n+        public H1() {}\n+    }\n+\n+    public static class H2 extends H1 {\n+        public H1 h1 = new H1();\n+        public H2() {}\n+    }\n+\n+    static record R1() {}\n+    static record R2() {}\n+    static record R3(int x, int y) {}\n+    static record R4(R4 x, R4 y) {}\n+\n+    public static void testArbitraryClasses() {\n+        A a1 = new A();\n+        A a2 = new A();\n+        B b1 = new B();\n+        B b2 = new B();\n+        C c1 = new C();\n+        C c2 = new C();\n+\n+        \/\/ Throws exception because arbitrary classes are not allowed.\n+        checkNE(a1, a1);\n+\n+        \/\/ Structurally equivalent.\n+        Verify.checkEQ(a1, a1, new Verify.Options().enableCheckWithArbitraryClasses());\n+        Verify.checkEQ(a1, a2, new Verify.Options().enableCheckWithArbitraryClasses());\n+        Verify.checkEQ(b1, b1, new Verify.Options().enableCheckWithArbitraryClasses());\n+        Verify.checkEQ(b1, b2, new Verify.Options().enableCheckWithArbitraryClasses());\n+        Verify.checkEQ(c1, c1, new Verify.Options().enableCheckWithArbitraryClasses());\n+        Verify.checkEQ(c1, c2, new Verify.Options().enableCheckWithArbitraryClasses());\n+\n+        \/\/ Must fail because of different classes.\n+        checkNE(a1, b1, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(b1, a1, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(a1, c1, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(c1, a1, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(b1, c1, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(c1, b1, new Verify.Options().enableCheckWithArbitraryClasses());\n+\n+        \/\/ Objects with primitive values.\n+        D d1 = new D(1);\n+        D d2 = new D(1);\n+        D d3 = new D(2);\n+        Verify.checkEQ(d1, d1, new Verify.Options().enableCheckWithArbitraryClasses());\n+        Verify.checkEQ(d1, d2, new Verify.Options().enableCheckWithArbitraryClasses());\n+        Verify.checkEQ(d2, d1, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(d1, d3, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(d3, d1, new Verify.Options().enableCheckWithArbitraryClasses());\n+\n+        \/\/ Object fields, including cycles.\n+        E e1 = new E(d1, null, null);\n+        E e2 = new E(d1, null, null);\n+        E e3 = new E(d3, null, null);\n+        E e4 = new E(d1, e1, null);\n+        E e5 = new E(d1, e2, null);\n+        E e6 = new E(d1, null, null);\n+        e6.e1 = e6;\n+        E e7 = new E(d1, null, null);\n+        e7.e1 = e7;\n+        E e8 = new E(d1, e1, e1);\n+        E e9 = new E(d1, e1, e2);\n+\n+        Verify.checkEQ(e1, e1, new Verify.Options().enableCheckWithArbitraryClasses());\n+        Verify.checkEQ(e1, e2, new Verify.Options().enableCheckWithArbitraryClasses());\n+        Verify.checkEQ(e2, e1, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(e1, e3, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(e3, e1, new Verify.Options().enableCheckWithArbitraryClasses());\n+        Verify.checkEQ(e6, e6, new Verify.Options().enableCheckWithArbitraryClasses());\n+        Verify.checkEQ(e6, e7, new Verify.Options().enableCheckWithArbitraryClasses());\n+        Verify.checkEQ(e7, e6, new Verify.Options().enableCheckWithArbitraryClasses());\n+        Verify.checkEQ(e8, e8, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(e8, e9, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(e9, e8, new Verify.Options().enableCheckWithArbitraryClasses());\n+\n+        \/\/ Fields from superclass.\n+        F2 f1 = new F2(1, 1);\n+        F2 f2 = new F2(1, 1);\n+        F2 f3 = new F2(2, 1);\n+        F2 f4 = new F2(1, 2);\n+\n+        Verify.checkEQ(f1, f1, new Verify.Options().enableCheckWithArbitraryClasses());\n+        Verify.checkEQ(f1, f2, new Verify.Options().enableCheckWithArbitraryClasses());\n+        Verify.checkEQ(f2, f1, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(f1, f3, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(f1, f4, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(f3, f1, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(f4, f1, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(f3, f4, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(f4, f3, new Verify.Options().enableCheckWithArbitraryClasses());\n+\n+        G g1 = new G(1.0f, 1.0f);\n+        G g2 = new G(1.0f, 1.0f);\n+        G g3 = new G(Float.NaN, Float.NaN);\n+        G g4 = new G(Float.NaN, Float.NaN);\n+\n+        Verify.checkEQ(g1, g1, new Verify.Options().enableCheckWithArbitraryClasses());\n+        Verify.checkEQ(g2, g1, new Verify.Options().enableCheckWithArbitraryClasses());\n+        Verify.checkEQ(g1, g2, new Verify.Options().enableCheckWithArbitraryClasses());\n+        Verify.checkEQ(g3, g3, new Verify.Options().enableCheckWithArbitraryClasses());\n+        Verify.checkEQ(g3, g4, new Verify.Options().enableCheckWithArbitraryClasses());\n+        Verify.checkEQ(g4, g3, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(g1, g3, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(g3, g1, new Verify.Options().enableCheckWithArbitraryClasses());\n+\n+        \/\/ Nested class with primitive types, where the boxed types may not be cached,\n+        \/\/ and so they would create different boxed objects.\n+        Verify.checkEQ(new H2(), new H2(), new Verify.Options().enableCheckWithArbitraryClasses());\n+\n+        \/\/ Records.\n+        R1 r11 = new R1();\n+        R1 r12 = new R1();\n+        R2 r21 = new R2();\n+        R3 r31 = new R3(1, 1);\n+        R3 r32 = new R3(1, 1);\n+        R3 r33 = new R3(1, 2);\n+        R3 r34 = new R3(2, 1);\n+\n+        Verify.checkEQ(r11, r11, new Verify.Options().enableCheckWithArbitraryClasses());\n+        Verify.checkEQ(r11, r12, new Verify.Options().enableCheckWithArbitraryClasses());\n+        Verify.checkEQ(r12, r11, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(r11, r21, new Verify.Options().enableCheckWithArbitraryClasses());\n+        Verify.checkEQ(r31, r31, new Verify.Options().enableCheckWithArbitraryClasses());\n+        Verify.checkEQ(r31, r32, new Verify.Options().enableCheckWithArbitraryClasses());\n+        Verify.checkEQ(r32, r31, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(r31, r33, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(r33, r31, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(r31, r34, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(r34, r31, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(r33, r34, new Verify.Options().enableCheckWithArbitraryClasses());\n+\n+        R4 r41 = new R4(null, null);\n+        R4 r42 = new R4(null, null);\n+        R4 r43 = new R4(r41, null);\n+        R4 r44 = new R4(r42, null);\n+        R4 r45 = new R4(r43, r41);\n+        R4 r46 = new R4(r44, r42);\n+        R4 r47 = new R4(r44, r41);\n+\n+        Verify.checkEQ(r45, r46, new Verify.Options().enableCheckWithArbitraryClasses());\n+        Verify.checkEQ(r46, r45, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(r45, r47, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(r47, r45, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(r46, r47, new Verify.Options().enableCheckWithArbitraryClasses());\n+        checkNE(r47, r46, new Verify.Options().enableCheckWithArbitraryClasses());\n+    }\n+\n+    public static void checkNE(Object a, Object b, Verify.Options verifyOptions) {\n@@ -415,2 +686,2 @@\n-            Verify.checkEQ(a, b);\n-            throw new RuntimeException(\"Should have thrown\");\n+            Verify.checkEQ(a, b, verifyOptions);\n+            throw new RuntimeException(\"Should have thrown: \" + a + \" vs \" + b);\n@@ -419,0 +690,4 @@\n+\n+    public static void checkNE(Object a, Object b) {\n+        checkNE(a, b, new Verify.Options());\n+    }\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/verify\/tests\/TestVerify.java","additions":280,"deletions":5,"binary":false,"changes":285,"status":"modified"}]}