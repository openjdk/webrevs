{"files":[{"patch":"@@ -58,0 +58,9 @@\n+\n+    \/**\n+     * When comparing arbitrary classes recursively, we need to remember which\n+     * pairs of objects {@code (a, b)} we have already visited. The maps\n+     * {@link a2b} and {@link b2a} track these edges. Caching which pairs\n+     * we have already visited means the traversal only needs to visit every\n+     * pair once. And should we ever find a pair {@code (a, b')} or {@code (a', b)},\n+     * then we know that the two structures are not structurally equivalent.\n+     *\/\n@@ -106,2 +115,2 @@\n-        Class ca = a.getClass();\n-        Class cb = b.getClass();\n+        Class<?> ca = a.getClass();\n+        Class<?> cb = b.getClass();\n@@ -123,8 +132,8 @@\n-            case Byte      x -> checkEQimpl(x, ((Byte)b).byteValue(),       field, aParent, bParent);\n-            case Character x -> checkEQimpl(x, ((Character)b).charValue(),  field, aParent, bParent);\n-            case Short     x -> checkEQimpl(x, ((Short)b).shortValue(),     field, aParent, bParent);\n-            case Integer   x -> checkEQimpl(x, ((Integer)b).intValue(),     field, aParent, bParent);\n-            case Long      x -> checkEQimpl(x, ((Long)b).longValue(),       field, aParent, bParent);\n-            case Float     x -> checkEQimpl(x, ((Float)b).floatValue(),     field, aParent, bParent);\n-            case Double    x -> checkEQimpl(x, ((Double)b).doubleValue(),   field, aParent, bParent);\n-            case Boolean   x -> checkEQimpl(x, ((Boolean)b).booleanValue(), field, aParent, bParent);\n+            case Byte      x -> checkEQimpl(x, (Byte)b,                     field, aParent, bParent);\n+            case Character x -> checkEQimpl(x, (Character)b,                field, aParent, bParent);\n+            case Short     x -> checkEQimpl(x, (Short)b,                    field, aParent, bParent);\n+            case Integer   x -> checkEQimpl(x, (Integer)b,                  field, aParent, bParent);\n+            case Long      x -> checkEQimpl(x, (Long)b,                     field, aParent, bParent);\n+            case Float     x -> checkEQimpl(x, (Float)b,                    field, aParent, bParent);\n+            case Double    x -> checkEQimpl(x, (Double)b,                   field, aParent, bParent);\n+            case Boolean   x -> checkEQimpl(x, (Boolean)b,                  field, aParent, bParent);\n@@ -142,16 +151,4 @@\n-                if (ca.getName().startsWith(\"jdk.incubator.vector\") && ca.getName().contains(\"Vector\")) {\n-                    \/\/ We do not want to import jdk.incubator.vector explicitly, because it would mean we would also have\n-                    \/\/ to add \"--add-modules=jdk.incubator.vector\" to the command-line of every test that uses the Verify\n-                    \/\/ class. So we hack this via reflection.\n-                    Object va = null;\n-                    Object vb = null;\n-                    try {\n-                        Method m = ca.getMethod(\"toArray\");\n-                        m.setAccessible(true);\n-                        va = m.invoke(a);\n-                        vb = m.invoke(b);\n-                    } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n-                        throw new RuntimeException(\"Could not invoke toArray on \" + ca.getName(), e);\n-                    }\n-                    checkEQdispatch(va, vb, field + \".toArray\", aParent, bParent);\n-                    return;\n+                if (isVectorAPIClass(ca)) {\n+                    checkEQForVectorAPIClass(a, b, field, aParent, bParent);\n+                } else {\n+                    checkEQArbitraryClasses(a, b);\n@@ -159,3 +156,0 @@\n-\n-                checkEQArbitraryClasses(a, b);\n-                return;\n@@ -182,0 +176,2 @@\n+            \/\/ Note: we need to cast \"(int)a\", otherwise a char of numerical value \"66\" is\n+            \/\/       formatted as character \"B\".\n@@ -193,1 +189,1 @@\n-            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + (int)a + \" vs \" + (int)b);\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + a + \" vs \" + b);\n@@ -195,1 +191,1 @@\n-            throw new VerifyException(\"Value mismatch: \" + (int)a + \" vs \" + (int)b);\n+            throw new VerifyException(\"Value mismatch: \" + a + \" vs \" + b);\n@@ -232,2 +228,2 @@\n-        return isFloatCheckWithRawBits ? Float.floatToRawIntBits(a) != Float.floatToRawIntBits(b)\n-                                       : Float.floatToIntBits(a) != Float.floatToIntBits(b);\n+        return isFloatCheckWithRawBits ? Float.floatToRawIntBits(a) == Float.floatToRawIntBits(b)\n+                                       : Float.floatToIntBits(a) == Float.floatToIntBits(b);\n@@ -240,2 +236,2 @@\n-        return isFloatCheckWithRawBits ? Double.doubleToRawLongBits(a) != Double.doubleToRawLongBits(b)\n-                                       : Double.doubleToLongBits(a) != Double.doubleToLongBits(b);\n+        return isFloatCheckWithRawBits ? Double.doubleToRawLongBits(a) == Double.doubleToRawLongBits(b)\n+                                       : Double.doubleToLongBits(a) == Double.doubleToLongBits(b);\n@@ -248,1 +244,1 @@\n-        if (isFloatEQ(a, b)) {\n+        if (!isFloatEQ(a, b)) {\n@@ -261,1 +257,1 @@\n-        if (isDoubleEQ(a, b)) {\n+        if (!isDoubleEQ(a, b)) {\n@@ -309,2 +305,3 @@\n-     * Verify that the content of two MemorySegments is identical. Note: we do not check the\n-     * backing type, only the size and content.\n+     * Verify that two Exceptions have the same message. Messages are not always carried,\n+     * they are often dropped to performance, and that is ok. But if both Exceptions have\n+     * the message, we should compare them.\n@@ -321,2 +318,2 @@\n-        System.out.println(\"a: \" + a.getMessage());\n-        System.out.println(\"b: \" + b.getMessage());\n+        System.err.println(\"a: \" + a.getMessage());\n+        System.err.println(\"b: \" + b.getMessage());\n@@ -373,1 +370,1 @@\n-            if (isFloatEQ(a[i], b[i])) {\n+            if (!isFloatEQ(a[i], b[i])) {\n@@ -392,1 +389,1 @@\n-            if (isDoubleEQ(a[i], b[i])) {\n+            if (!isDoubleEQ(a[i], b[i])) {\n@@ -437,0 +434,30 @@\n+    \/**\n+     * We do not want to import jdk.incubator.vector explicitly, because it would mean we would also have\n+     * to add \"--add-modules=jdk.incubator.vector\" to the command-line of every test that uses the Verify\n+     * class. So we hack this via reflection.\n+     *\/\n+    private static boolean isVectorAPIClass(Class<?> c) {\n+        return c.getName().startsWith(\"jdk.incubator.vector\") &&\n+               c.getName().contains(\"Vector\");\n+    }\n+\n+    \/**\n+     * We do not want to import jdk.incubator.vector explicitly, because it would mean we would also have\n+     * to add \"--add-modules=jdk.incubator.vector\" to the command-line of every test that uses the Verify\n+     * class. So we hack this via reflection.\n+     *\/\n+    private void checkEQForVectorAPIClass(Object a, Object b, String field, Object aParent, Object bParent) {\n+        Class<?> ca = a.getClass();\n+        Object va;\n+        Object vb;\n+        try {\n+            Method m = ca.getMethod(\"toArray\");\n+            m.setAccessible(true);\n+            va = m.invoke(a);\n+            vb = m.invoke(b);\n+        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n+            throw new RuntimeException(\"Could not invoke toArray on \" + ca.getName(), e);\n+        }\n+        checkEQdispatch(va, vb, field + \".toArray\", aParent, bParent);\n+    }\n+\n@@ -464,0 +491,9 @@\n+\n+    \/**\n+     * When comparing arbitrary classes recursively, we need to remember which\n+     * pairs of objects {@code (a, b)} we have already visited. The maps\n+     * {@link a2b} and {@link b2a} track these edges. Caching which pairs\n+     * we have already visited means the traversal only needs to visit every\n+     * pair once. And should we ever find a pair {@code (a, b')} or {@code (a', b)},\n+     * then we know that the two structures are not structurally equivalent.\n+     *\/\n@@ -519,1 +555,1 @@\n-        System.err.println(\"\");\n+        System.err.println();\n@@ -527,1 +563,1 @@\n-        System.err.println(\"\");\n+        System.err.println();\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/verify\/Verify.java","additions":81,"deletions":45,"binary":false,"changes":126,"status":"modified"}]}