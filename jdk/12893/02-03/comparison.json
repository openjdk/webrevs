{"files":[{"patch":"@@ -46,0 +46,1 @@\n+import com.sun.tools.javac.code.Source;\n@@ -68,0 +69,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.Fragment;\n@@ -193,0 +195,3 @@\n+    \/** UTF-8 validation level, e.g., {@link Convert#UTF8_STRICT}. *\/\n+    int utf8validation;\n+\n@@ -309,0 +314,8 @@\n+        return badClassFile(diagFactory.fragment(key, args));\n+    }\n+\n+    public ClassFinder.BadClassFile badClassFile(Fragment fragment) {\n+        return badClassFile(diagFactory.fragment(fragment));\n+    }\n+\n+    public ClassFinder.BadClassFile badClassFile(JCDiagnostic diagnostic) {\n@@ -312,1 +325,1 @@\n-            diagFactory.fragment(key, args),\n+            diagnostic,\n@@ -337,1 +350,1 @@\n-            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+            throw badClassFile(Fragments.BadClassTruncatedAtOffset(e.getLength()));\n@@ -349,1 +362,1 @@\n-            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+            throw badClassFile(Fragments.BadClassTruncatedAtOffset(e.getLength()));\n@@ -360,1 +373,1 @@\n-            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+            throw badClassFile(Fragments.BadClassTruncatedAtOffset(e.getLength()));\n@@ -660,1 +673,1 @@\n-            sigString = Convert.utf2string(signature, sigp, siglimit - sigp, majorVersion < V48.major);\n+            sigString = Convert.utf2string(signature, sigp, siglimit - sigp, Convert.UTF8_LAX);\n@@ -662,1 +675,1 @@\n-            return diagFactory.fragment(\"bad.utf8.byte.sequence.at\", sigp).toString();\n+            throw new AssertionError(e);\n@@ -768,1 +781,1 @@\n-            return names.fromUtf(buf, off, len, majorVersion < V48.major);\n+            return names.fromUtf(buf, off, len, utf8validation);\n@@ -770,1 +783,6 @@\n-           throw badClassFile(\"bad.utf8.byte.sequence.at\", sigp);\n+            if (Source.DEFAULT == Source.JDK21) {\n+                log.warning(Warnings.InvalidUtf8InClassfile(currentClassFile,\n+                    Fragments.BadUtf8ByteSequenceAt(sigp)));\n+                return names.fromUtfLax(buf, off, len);\n+            }\n+            throw badClassFile(Fragments.BadUtf8ByteSequenceAt(sigp));\n@@ -1225,1 +1243,10 @@\n-                    return names.fromUtf(buf, 0, buf.length, majorVersion < V48.major);\n+                    try {\n+                        return names.fromUtf(buf, 0, buf.length, utf8validation);\n+                    } catch (InvalidUtfException e) {\n+                        if (Source.DEFAULT == Source.JDK21) {\n+                            log.warning(Warnings.InvalidUtf8InClassfile(currentClassFile,\n+                                Fragments.BadUtf8ByteSequenceAt(e.getOffset())));\n+                            return names.fromUtfLax(buf, 0, buf.length);\n+                        }\n+                        throw e;\n+                    }\n@@ -1525,1 +1552,1 @@\n-            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+            throw badClassFile(Fragments.BadClassTruncatedAtOffset(e.getLength()));\n@@ -1819,1 +1846,1 @@\n-            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+            throw badClassFile(Fragments.BadClassTruncatedAtOffset(e.getLength()));\n@@ -2682,0 +2709,1 @@\n+        utf8validation = majorVersion < V48.major ? Convert.UTF8_PREJDK14 : Convert.UTF8_STRICT;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":39,"deletions":11,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import com.sun.tools.javac.util.InvalidUtfException;\n@@ -165,1 +164,1 @@\n-                return Convert.utf2string(buf, 0, buf.length, false);\n+                return Convert.utf2string(buf, 0, buf.length, Convert.UTF8_STRICT);\n@@ -167,1 +166,1 @@\n-            (buf, offset, len) -> Convert.utf2string(buf, offset, len, false);\n+            (buf, offset, len) -> Convert.utf2string(buf, offset, len, Convert.UTF8_STRICT);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ModuleNameReader.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.tools.javac.code.Source;\n@@ -34,0 +35,2 @@\n+import com.sun.tools.javac.resources.CompilerProperties.Fragments;\n+import com.sun.tools.javac.resources.CompilerProperties.Warnings;\n@@ -36,0 +39,1 @@\n+import com.sun.tools.javac.util.Convert;\n@@ -77,1 +81,1 @@\n-    private final boolean lenientUtf8;\n+    private final int utf8validation;\n@@ -94,1 +98,1 @@\n-        this.lenientUtf8 = reader != null && reader.majorVersion < ClassFile.Version.V48.major;\n+        this.utf8validation = reader != null ? reader.utf8validation : Convert.UTF8_LAX;\n@@ -145,1 +149,1 @@\n-            throw reader.badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+            throw reader.badClassFile(Fragments.BadClassTruncatedAtOffset(e.getLength()));\n@@ -171,1 +175,1 @@\n-            throw reader.badClassFile(\"bad.utf8.byte.sequence.at\", Integer.toString(e.getOffset()));\n+            throw reader.badClassFile(Fragments.BadUtf8ByteSequenceAt(e.getOffset()));\n@@ -173,1 +177,1 @@\n-            throw reader.badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+            throw reader.badClassFile(Fragments.BadClassTruncatedAtOffset(e.getLength()));\n@@ -228,1 +232,12 @@\n-                return names.fromUtf(poolbuf.elems, offset + 2, len, lenientUtf8);\n+                try {\n+                    return names.fromUtf(poolbuf.elems, offset + 2, len, utf8validation);\n+                } catch (InvalidUtfException e) {\n+                    if (Source.DEFAULT == Source.JDK21) {\n+                        if (reader != null) {\n+                            reader.log.warning(Warnings.InvalidUtf8InClassfile(\n+                                reader.currentClassFile, Fragments.BadUtf8ByteSequenceAt(e.getOffset())));\n+                        }\n+                        return names.fromUtfLax(poolbuf.elems, offset + 2, len);\n+                    }\n+                    throw e;\n+                }\n@@ -276,1 +291,1 @@\n-            throw reader.badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+            throw reader.badClassFile(Fragments.BadClassTruncatedAtOffset(e.getLength()));\n@@ -376,1 +391,1 @@\n-                    p = (P)resolve(poolbuf, tag(index), offset(index));\n+                    p = (P)resolve(poolbuf, currentTag, offset(index));\n@@ -378,1 +393,1 @@\n-                    throw reader.badClassFile(\"bad.utf8.byte.sequence.at\", Integer.toString(e.getOffset()));\n+                    throw reader.badClassFile(Fragments.BadUtf8ByteSequenceAt(e.getOffset()));\n@@ -380,1 +395,1 @@\n-                    throw reader.badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+                    throw reader.badClassFile(Fragments.BadClassTruncatedAtOffset(e.getLength()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolReader.java","additions":25,"deletions":10,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2031,0 +2031,4 @@\n+# 0: file name, 1: fragment\n+compiler.warn.invalid.utf8.in.classfile=\\\n+    {0}: classfile contains invalid UTF-8: {1}\n+\n@@ -2435,0 +2439,1 @@\n+# 0: number\n@@ -2436,1 +2441,1 @@\n-    bad UTF-8 byte sequence at {1}\n+    bad UTF-8 byte sequence at {0}\n@@ -2441,0 +2446,1 @@\n+# 0: number\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -278,1 +278,1 @@\n-        return names.fromUtf(elems, 0, length, false);\n+        return names.fromUtf(elems, 0, length, Convert.UTF8_STRICT);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/ByteBuffer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,17 @@\n+    \/**\n+     * Do minimum validation of UTF-8, i.e., just enough to decode something\/anything.\n+     * When this value is used, {@link InvalidUtfException} is never thrown.\n+     *\/\n+    public static final int UTF8_LAX = 0;\n+\n+    \/**\n+     * Do validation of UTF-8 corresponding to pre-1.4, i.e., validate strictly except\n+     * allow longer-than-necessary encodings (e.g., three bytes instead of two).\n+     *\/\n+    public static final int UTF8_PREJDK14 = 1;\n+\n+    \/**\n+     * Do strict validation of UTF-8. At this level, each character has only one valid encoding.\n+     *\/\n+    public static final int UTF8_STRICT = 2;\n+\n@@ -103,1 +120,1 @@\n-    \/** Validate the given Modified UTF-8 encoding.\n+    \/** Validate the given Modified UTF-8 encoding using the given validation level.\n@@ -105,0 +122,1 @@\n+     *  Note: there is no point in calling this method with no-op validation {@link #UTF8_LAX}.\n@@ -108,3 +126,3 @@\n-     *  @param lenient    Whether to allow longer-than-necessary encodings\n-     *                    (for obsolete classfile versions &lt; 48)\n-     *  @throws InvalidUtfException if invalid Modified UTF-8 is encountered\n+     *  @param validation Level of validation (e.g., {@link #UTF8_STRICT})\n+     *  @throws InvalidUtfException if {@code validation} is greater than {@link #UTF8_LAX}\n+     *      and invalid Modified UTF-8 is encountered\n@@ -112,2 +130,2 @@\n-    public static void utfValidate(byte[] buf, int off, int len, boolean lenient) throws InvalidUtfException {\n-        utf2chars(buf, off, null, 0, len, lenient);\n+    public static void utfValidate(byte[] buf, int off, int len, int validation) throws InvalidUtfException {\n+        utf2chars(buf, off, null, 0, len, validation);\n@@ -116,1 +134,1 @@\n-    \/** Decode characters encoded in Modified UTF-8 encoding.\n+    \/** Decode characters encoded in Modified UTF-8 encoding using the given validation level.\n@@ -126,3 +144,1 @@\n-     *  @param lenient    Whether to allow longer-than-necessary encodings\n-     *                    (for obsolete classfile versions &lt; 48)\n-     *  @return the index in {@code dst} just after the last copied char\n+     *  @param validation Level of validation (e.g., {@link #UTF8_STRICT})\n@@ -130,0 +146,3 @@\n+     *  @return the index in {@code dst} just after the last copied char\n+     *  @throws InvalidUtfException if {@code validation} is greater than {@link #UTF8_LAX}\n+     *      and invalid Modified UTF-8 is encountered\n@@ -131,1 +150,1 @@\n-    public static int utf2chars(byte[] src, int soff, char[] dst, int doff, int len, boolean lenient)\n+    public static int utf2chars(byte[] src, int soff, char[] dst, int doff, int len, int validation)\n@@ -139,1 +158,6 @@\n-                    if (--len < 0)\n+                    int value2;\n+                    if (len-- > 0)\n+                        value2 = src[soff++];\n+                    else if (validation == UTF8_LAX)\n+                        value2 = 0;\n+                    else\n@@ -141,2 +165,1 @@\n-                    int value2 = src[soff++];\n-                    if ((value2 & 0xc0) != 0x80)\n+                    if (validation >= UTF8_PREJDK14 && (value2 & 0xc0) != 0x80)\n@@ -145,1 +168,1 @@\n-                    if (!lenient && value != 0 && (value & ~0x7f) == 0)\n+                    if (validation >= UTF8_STRICT && value != 0 && (value & ~0x7f) == 0)\n@@ -148,1 +171,9 @@\n-                    if ((len -= 2) < 0)\n+                    int value2;\n+                    int value3;\n+                    if ((len -= 2) >= 0) {\n+                        value2 = src[soff++];\n+                        value3 = src[soff++];\n+                    } else if (validation == UTF8_LAX) {\n+                        value2 = 0;\n+                        value3 = 0;\n+                    } else\n@@ -150,3 +181,2 @@\n-                    int value2 = src[soff++];\n-                    int value3 = src[soff++];\n-                    if ((value2 & 0xc0) != 0x80 || (value3 & 0xc0) != 0x80)\n+                    if (validation >= UTF8_PREJDK14\n+                      && ((value2 & 0xc0) != 0x80 || (value3 & 0xc0) != 0x80))\n@@ -155,1 +185,1 @@\n-                    if (!lenient && (value & ~0x7ff) == 0)\n+                    if (validation >= UTF8_STRICT && (value & ~0x7ff) == 0)\n@@ -157,1 +187,3 @@\n-                } else\n+                } else if (validation == UTF8_LAX)\n+                    value &= 0xff;\n+                else\n@@ -159,2 +191,2 @@\n-            } else if (value == 0)\n-                throw new InvalidUtfException(soff0);   \/\/ 0x0000 must be encoded as two bytes\n+            } else if (validation >= UTF8_PREJDK14 && value == 0)\n+                throw new InvalidUtfException(soff0);           \/\/ 0x0000 must be encoded as two bytes\n@@ -172,2 +204,1 @@\n-     *  @param lenient    Whether to allow longer-than-necessary encodings\n-     *                    (for obsolete classfile versions &lt; 48)\n+     *  @param validation Level of validation (e.g., {@link #UTF8_STRICT})\n@@ -175,1 +206,2 @@\n-     *  @throws InvalidUtfException if invalid Modified UTF-8 is encountered\n+     *  @throws InvalidUtfException if {@code validation} is greater than {@link #UTF8_LAX}\n+     *      and invalid Modified UTF-8 is encountered\n@@ -177,1 +209,1 @@\n-    public static char[] utf2chars(byte[] src, int sindex, int len, boolean lenient)\n+    public static char[] utf2chars(byte[] src, int sindex, int len, int validation)\n@@ -180,1 +212,1 @@\n-        int len1 = utf2chars(src, sindex, dst, 0, len, lenient);\n+        int len1 = utf2chars(src, sindex, dst, 0, len, validation);\n@@ -192,3 +224,3 @@\n-     *  @param lenient    Whether to allow longer-than-necessary encodings\n-     *                    (for obsolete classfile versions &lt; 48)\n-     *  @throws InvalidUtfException if invalid Modified UTF-8 is encountered\n+     *  @param validation Level of validation (e.g., {@link #UTF8_STRICT})\n+     *  @throws InvalidUtfException if {@code validation} is greater than {@link #UTF8_LAX}\n+     *      and invalid Modified UTF-8 is encountered\n@@ -196,1 +228,1 @@\n-    public static String utf2string(byte[] src, int sindex, int len, boolean lenient)\n+    public static String utf2string(byte[] src, int sindex, int len, int validation)\n@@ -199,1 +231,1 @@\n-        int len1 = utf2chars(src, sindex, dst, 0, len, lenient);\n+        int len1 = utf2chars(src, sindex, dst, 0, len, validation);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Convert.java","additions":65,"deletions":33,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-            return table.fromUtf(bs, 0, bs.length, false);\n+            return table.fromUtf(bs, 0, bs.length, Convert.UTF8_LAX);\n@@ -107,1 +107,1 @@\n-            return table.fromUtf(bs, 0, bs.length, false);\n+            return table.fromUtf(bs, 0, bs.length, Convert.UTF8_LAX);\n@@ -161,1 +161,1 @@\n-            return table.fromUtf(getByteArray(), getByteOffset() + start, end - start, false);\n+            return table.fromUtf(getByteArray(), getByteOffset() + start, end - start, Convert.UTF8_LAX);\n@@ -172,1 +172,1 @@\n-            return Convert.utf2string(getByteArray(), getByteOffset(), getByteLength(), false);\n+            return Convert.utf2string(getByteArray(), getByteOffset(), getByteLength(), Convert.UTF8_LAX);\n@@ -245,1 +245,1 @@\n-         *  Assume that bytes are in utf8 format.\n+         *  Assume that bytes are in strictly valid \"Modified UTF-8\" format.\n@@ -248,1 +248,1 @@\n-            return fromUtf(cs, 0, cs.length, false);\n+            return fromUtf(cs, 0, cs.length, Convert.UTF8_STRICT);\n@@ -255,1 +255,1 @@\n-        public abstract Name fromUtf(byte[] cs, int start, int len, boolean lenient)\n+        public abstract Name fromUtf(byte[] cs, int start, int len, int validation)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Name.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -427,2 +427,10 @@\n-    public Name fromUtf(byte[] cs, int start, int len, boolean lenient) throws InvalidUtfException {\n-        return table.fromUtf(cs, start, len, lenient);\n+    public Name fromUtf(byte[] cs, int start, int len, int validation) throws InvalidUtfException {\n+        return table.fromUtf(cs, start, len, validation);\n+    }\n+\n+    public Name fromUtfLax(byte[] cs, int start, int len) {\n+        try {\n+            return table.fromUtf(cs, start, len, Convert.UTF8_LAX);\n+        } catch (InvalidUtfException e) {\n+            throw new AssertionError(e);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -122,2 +122,3 @@\n-    public Name fromUtf(byte[] cs, int start, int len, boolean lenient) throws InvalidUtfException {\n-        Convert.utfValidate(cs, start, len, lenient);\n+    public Name fromUtf(byte[] cs, int start, int len, int validation) throws InvalidUtfException {\n+        if (validation > Convert.UTF8_LAX)\n+            Convert.utfValidate(cs, start, len, validation);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/SharedNameTable.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -88,2 +88,3 @@\n-    public Name fromUtf(byte[] cs, int start, int len, boolean lenient) throws InvalidUtfException {\n-        Convert.utfValidate(cs, start, len, lenient);\n+    public Name fromUtf(byte[] cs, int start, int len, int validation) throws InvalidUtfException {\n+        if (validation > Convert.UTF8_LAX)\n+            Convert.utfValidate(cs, start, len, validation);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/UnsharedNameTable.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @modules jdk.compiler\/com.sun.tools.javac.code\n@@ -30,0 +31,1 @@\n+import com.sun.tools.javac.code.Source;\n@@ -54,1 +56,1 @@\n-        interface Class0 {\n+        interface CLASSNAME {\n@@ -61,1 +63,1 @@\n-        interface Class1 {\n+        interface CLASSNAME {\n@@ -68,1 +70,1 @@\n-        interface Class2 {\n+        interface CLASSNAME {\n@@ -75,1 +77,1 @@\n-        interface Class3 {\n+        interface CLASSNAME {\n@@ -82,1 +84,8 @@\n-        interface Class4 {\n+        interface CLASSNAME {\n+            void ABCD();            \/\/ encodes to: 41 42 43 44\n+        }\n+    \"\"\";\n+\n+    \/\/ We change 43 44 -> e1 80 (illegal truncated three-byte encoding)\n+    private static final String SOURCE_5 = \"\"\"\n+        interface CLASSNAME {\n@@ -93,33 +102,7 @@\n-    private static String[] SOURCES = new String[] {\n-        SOURCE_0,\n-        SOURCE_1,\n-        SOURCE_2,\n-        SOURCE_3,\n-        SOURCE_4,\n-    };\n-    private static String[][] MODIFICATIONS = new String[][] {\n-        {   \"414243c3a8\",\n-            \"414243c3e8\"    },\n-        {   \"414243e18080\",\n-            \"414243e18040\"  },\n-        {   \"414243c480\",\n-            \"414243c181\"    },\n-        {   \"414243e18080\",\n-            \"414243e08480\"  },\n-        {   \"41424344\",\n-            \"41424300\"      },\n-    };\n-\n-    private static File[] SOURCE_FILES = new File[] {\n-        new File(\"Class0.java\"),\n-        new File(\"Class1.java\"),\n-        new File(\"Class2.java\"),\n-        new File(\"Class3.java\"),\n-        new File(\"Class4.java\"),\n-    };\n-    private static File[] CLASS_FILES = new File[] {\n-        new File(\"Class0.class\"),\n-        new File(\"Class1.class\"),\n-        new File(\"Class2.class\"),\n-        new File(\"Class3.class\"),\n-        new File(\"Class4.class\"),\n+    private static TestCase[] TEST_CASES = new TestCase[] {\n+        new TestCase(0, SOURCE_0, \"414243c3a8\",     \"414243c3e8\"),\n+        new TestCase(1, SOURCE_1, \"414243e18080\",   \"414243e18040\"),\n+        new TestCase(2, SOURCE_2, \"414243c480\",     \"414243c181\"),\n+        new TestCase(3, SOURCE_3, \"414243e18080\",   \"414243e08480\"),\n+        new TestCase(4, SOURCE_4, \"41424344\",       \"41424300\"),\n+        new TestCase(5, SOURCE_5, \"41424344\",       \"4142e180\"),\n@@ -161,1 +144,1 @@\n-    private static void compileRefClass(File file, String expectedError) {\n+    private static void compileRefClass(File file, boolean expectSuccess, String expectedError) {\n@@ -171,4 +154,10 @@\n-        if (expectedError != null && ret == 0)\n-            throw new AssertionError(\"compilation succeeded, but expected error \\\"\" + expectedError + \"\\\"\");\n-        else if (expectedError == null && ret != 0)\n-            throw new AssertionError(\"compilation failed, but expected success:\\n\" + diags);\n+        System.err.println(\"exit value: \" + ret);\n+        String output = diags.toString().trim();\n+        if (!output.isEmpty())\n+            System.err.println(\"output:\\n\" + output);\n+        else\n+            System.err.println(\"no output\");\n+        if (!expectSuccess && ret == 0)\n+            throw new AssertionError(\"compilation succeeded, but expected failure\");\n+        else if (expectSuccess && ret != 0)\n+            throw new AssertionError(\"compilation failed, but expected success\");\n@@ -176,1 +165,1 @@\n-            throw new AssertionError(\"error message not found:\\n  expected: \\\"\" + expectedError + \"\\\"\\n  found:\" + diags);\n+            throw new AssertionError(\"expected output \\\"\" + expectedError + \"\\\" not found\");\n@@ -182,2 +171,2 @@\n-        for (int i = 0; i < 5; i++)\n-            createSourceFile(SOURCES[i], SOURCE_FILES[i]);\n+        for (TestCase test : TEST_CASES)\n+            test.createSourceFile();\n@@ -186,3 +175,2 @@\n-        for (int i = 0; i < 5; i++) {\n-            final File sourceFile = SOURCE_FILES[i];\n-            int ret = Main.compile(new String[] { sourceFile.toString() });\n+        for (TestCase test : TEST_CASES) {\n+            int ret = Main.compile(new String[] { test.sourceFile().toString() });\n@@ -190,1 +178,1 @@\n-                throw new AssertionError(\"compilation of \" + sourceFile + \" failed\");\n+                throw new AssertionError(\"compilation of \" + test.sourceFile() + \" failed\");\n@@ -193,0 +181,3 @@\n+        \/\/ We should get warnings in JDK 21 and errors in any later release\n+        final boolean expectSuccess = Source.DEFAULT.compareTo(Source.JDK21) <= 0;\n+\n@@ -196,3 +187,2 @@\n-        for (int i = 0; i < 5; i++) {\n-            final String className = \"Class\" + i;\n-            final File classFile = CLASS_FILES[i];\n+        for (TestCase test : TEST_CASES) {\n+            System.err.println(\"==== TEST \" + test.index() + \" ====\");\n@@ -202,1 +192,1 @@\n-            createSourceFile(REF_SOURCE.replaceAll(\"CLASSNAME\", className), refSource);\n+            createSourceFile(REF_SOURCE.replaceAll(\"CLASSNAME\", test.className()), refSource);\n@@ -205,1 +195,1 @@\n-            compileRefClass(refSource, null);\n+            compileRefClass(refSource, true, null);\n@@ -208,2 +198,2 @@\n-            System.err.println(\"modifying: \" + classFile);\n-            final String[] mod = MODIFICATIONS[i];\n+            System.err.println(\"modifying: \" + test.classFile());\n+            final File classFile = test.classFile();\n@@ -211,3 +201,1 @@\n-            final byte[] data2 = string2bytes(bytes2string(data1).replaceAll(mod[0], mod[1]));\n-            if (Arrays.equals(data2, data1))\n-                throw new AssertionError(\"modification of \" + classFile + \" failed\");\n+            final byte[] data2 = test.modify(data1);\n@@ -217,1 +205,45 @@\n-            compileRefClass(refSource, \"compiler.misc.bad.utf8.byte.sequence.at\");\n+            compileRefClass(refSource, expectSuccess, \"compiler.misc.bad.utf8.byte.sequence.at\");\n+        }\n+    }\n+\n+\/\/ TestCase\n+\n+    static class TestCase {\n+\n+        final int index;\n+        final String source;\n+        final String match;\n+        final String replace;\n+\n+        TestCase(int index, String source, String match, String replace) {\n+            this.index = index;\n+            this.source = source.replaceAll(\"CLASSNAME\", className());\n+            this.match = match;\n+            this.replace = replace;\n+        }\n+\n+        byte[] modify(byte[] input) {\n+            final byte[] output = string2bytes(bytes2string(input).replaceAll(match, replace));\n+            if (Arrays.equals(output, input))\n+                throw new AssertionError(\"modification of \" + classFile() + \" failed\");\n+            return output;\n+        }\n+\n+        int index() {\n+            return index;\n+        }\n+\n+        String className() {\n+            return \"Class\" + index;\n+        }\n+\n+        File sourceFile() {\n+            return new File(className() + \".java\");\n+        }\n+\n+        File classFile() {\n+            return new File(className() + \".class\");\n+        }\n+\n+        void createSourceFile() throws IOException {\n+            InvalidModifiedUtf8Test.createSourceFile(source, sourceFile());\n","filename":"test\/langtools\/tools\/javac\/classreader\/InvalidModifiedUtf8Test.java","additions":93,"deletions":61,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -120,0 +120,1 @@\n+compiler.warn.invalid.utf8.in.classfile                 # bad class file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}