{"files":[{"patch":"@@ -2456,1 +2456,6 @@\n-            Name name = names.fromUtf(ba);\n+            Name name;\n+            try {\n+                name = names.fromUtf(ba);\n+            } catch (InvalidUtfException e) {\n+                throw new AssertionError(e);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -477,1 +477,1 @@\n-                            names.fromUtf(ClassWriter.externalize(forEnum.type.tsym.flatName())).toString()\n+                            ClassWriter.externalize(forEnum.type.tsym.flatName().toString())\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+        V48(48, 0),   \/\/ JDK 1.4\n@@ -168,2 +169,2 @@\n-    public static byte[] internalize(Name name) {\n-        return internalize(name.getByteArray(), name.getByteOffset(), name.getByteLength());\n+    public static Name internalize(Name name) {\n+        return name.table.names.fromString(name.toString().replace('\/', '.'));\n@@ -173,1 +174,1 @@\n-     * Return external representation of buf[offset..offset+len-1], converting '.' to '\/'.\n+     * Return external representation of given name, converting '\/' to '.'.\n@@ -178,8 +179,2 @@\n-    public static byte[] externalize(byte[] buf, int offset, int len) {\n-        byte[] translated = new byte[len];\n-        for (int j = 0; j < len; j++) {\n-            byte b = buf[offset + j];\n-            if (b == '.') translated[j] = (byte) '\/';\n-            else translated[j] = b;\n-        }\n-        return translated;\n+    public static Name externalize(Name name) {\n+        return name.table.names.fromString(externalize(name.toString()));\n@@ -194,2 +189,2 @@\n-    public static byte[] externalize(Name name) {\n-        return externalize(name.getByteArray(), name.getByteOffset(), name.getByteLength());\n+    public static String externalize(String name) {\n+        return name.replace('.', '\/');\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassFile.java","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -457,1 +457,1 @@\n-                : findTypeVar(names.fromUtf(signature, start, sigp - 1 - start));\n+                : findTypeVar(readName(signature, start, sigp - 1 - start));\n@@ -541,2 +541,1 @@\n-            throw badClassFile(\"bad.signature\",\n-                               Convert.utf2string(signature, sigp, 10));\n+            throw badClassFile(\"bad.signature\", quoteBadSignature());\n@@ -552,2 +551,1 @@\n-            throw badClassFile(\"bad.class.signature\",\n-                               Convert.utf2string(signature, sigp, 10));\n+            throw badClassFile(\"bad.class.signature\", quoteBadSignature());\n@@ -563,1 +561,1 @@\n-                ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,\n+                ClassSymbol t = enterClass(readName(signatureBuffer,\n@@ -577,1 +575,1 @@\n-                ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,\n+                ClassSymbol t = enterClass(readName(signatureBuffer,\n@@ -640,1 +638,1 @@\n-                    t = enterClass(names.fromUtf(signatureBuffer,\n+                    t = enterClass(readName(signatureBuffer,\n@@ -657,0 +655,14 @@\n+    \/** Quote a bogus signature for display inside an error message.\n+     *\/\n+    String quoteBadSignature() {\n+        String sigString;\n+        try {\n+            sigString = Convert.utf2string(signature, sigp, siglimit - sigp, majorVersion < V48.major);\n+        } catch (InvalidUtfException e) {\n+            return diagFactory.fragment(\"bad.utf8.byte.sequence.at\", sigp).toString();\n+        }\n+        if (sigString.length() > 32)\n+            sigString = sigString.substring(0, 32) + \"...\";\n+        return \"\\\"\" + sigString + \"\\\"\";\n+    }\n+\n@@ -703,1 +715,1 @@\n-        Name name = names.fromUtf(signature, start, sigp - start);\n+        Name name = readName(signature, start, sigp - start);\n@@ -754,0 +766,8 @@\n+    private Name readName(byte[] buf, int off, int len) {\n+        try {\n+            return names.fromUtf(buf, off, len, majorVersion < V48.major);\n+        } catch (InvalidUtfException e) {\n+           throw badClassFile(\"bad.utf8.byte.sequence.at\", sigp);\n+        }\n+    }\n+\n@@ -1108,1 +1128,1 @@\n-                        Name moduleName = poolReader.peekModuleName(nextChar(), names::fromUtf);\n+                        Name moduleName = poolReader.peekModuleName(nextChar(), ClassReader.this::readName);\n@@ -1203,2 +1223,3 @@\n-                private Name classNameMapper(byte[] arr, int offset, int length) {\n-                    return names.fromUtf(ClassFile.internalize(arr, offset, length));\n+                private Name classNameMapper(byte[] arr, int offset, int length) throws InvalidUtfException {\n+                    byte[] buf = ClassFile.internalize(arr, offset, length);\n+                    return names.fromUtf(buf, 0, buf.length, majorVersion < V48.major);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":33,"deletions":12,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import com.sun.tools.javac.util.InvalidUtfException;\n@@ -160,1 +161,1 @@\n-    NameMapper<String> utf8Mapper(boolean internalize) {\n+    PoolReader.Utf8Mapper<String> utf8Mapper(boolean internalize) {\n@@ -162,3 +163,5 @@\n-                (buf, offset, len) ->\n-                    Convert.utf2string(ClassFile.internalize(buf, offset, len)) :\n-                Convert::utf2string;\n+            (buf, offset, len) -> {\n+                buf = ClassFile.internalize(buf, offset, len);\n+                return Convert.utf2string(buf, 0, buf.length, false);\n+            } :\n+            (buf, offset, len) -> Convert.utf2string(buf, offset, len, false);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ModuleNameReader.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import com.sun.tools.javac.util.InvalidUtfException;\n@@ -37,1 +38,0 @@\n-import com.sun.tools.javac.util.Name.NameMapper;\n@@ -77,0 +77,1 @@\n+    private final boolean lenientUtf8;\n@@ -93,0 +94,1 @@\n+        this.lenientUtf8 = reader != null && reader.majorVersion < ClassFile.Version.V48.major;\n@@ -121,1 +123,1 @@\n-    <Z> Z peekClassName(int index, NameMapper<Z> mapper) {\n+    <Z> Z peekClassName(int index, Utf8Mapper<Z> mapper) {\n@@ -128,1 +130,1 @@\n-    <Z> Z peekPackageName(int index, NameMapper<Z> mapper) {\n+    <Z> Z peekPackageName(int index, Utf8Mapper<Z> mapper) {\n@@ -135,1 +137,1 @@\n-    <Z> Z peekModuleName(int index, NameMapper<Z> mapper) {\n+    <Z> Z peekModuleName(int index, Utf8Mapper<Z> mapper) {\n@@ -139,1 +141,1 @@\n-    private <Z> Z peekItemName(int index, NameMapper<Z> mapper) {\n+    private <Z> Z peekItemName(int index, Utf8Mapper<Z> mapper) {\n@@ -165,1 +167,1 @@\n-    <Z> Z peekName(int index, Name.NameMapper<Z> mapper) {\n+    <Z> Z peekName(int index, Utf8Mapper<Z> mapper) {\n@@ -168,0 +170,2 @@\n+        } catch (InvalidUtfException e) {\n+            throw reader.badClassFile(\"bad.utf8.byte.sequence.at\", Integer.toString(e.getOffset()));\n@@ -205,1 +209,1 @@\n-    private <Z> Z getUtf8(int index, NameMapper<Z> mapper) throws UnderflowException {\n+    private <Z> Z getUtf8(int index, Utf8Mapper<Z> mapper) throws InvalidUtfException, UnderflowException {\n@@ -209,2 +213,4 @@\n-            int len = pool.poolbuf.getChar(offset);\n-            return mapper.map(pool.poolbuf.elems, offset + 2, len);\n+            int utf8len = pool.poolbuf.getChar(offset);\n+            int utf8off = offset + 2;\n+            pool.poolbuf.verifyRange(utf8off, utf8len);\n+            return mapper.map(pool.poolbuf.elems, utf8off, utf8len);\n@@ -218,1 +224,1 @@\n-    private Object resolve(ByteBuffer poolbuf, int tag, int offset) throws UnderflowException {\n+    private Object resolve(ByteBuffer poolbuf, int tag, int offset) throws InvalidUtfException, UnderflowException {\n@@ -222,1 +228,1 @@\n-                return names.fromUtf(poolbuf.elems, offset + 2, len);\n+                return names.fromUtf(poolbuf.elems, offset + 2, len, lenientUtf8);\n@@ -226,1 +232,1 @@\n-                Name name = names.fromUtf(getName(index).map(ClassFile::internalize));\n+                Name name = internalize(getName(index));\n@@ -246,1 +252,1 @@\n-                return syms.enterPackage(reader.currentModule, names.fromUtf(internalize(name)));\n+                return syms.enterPackage(reader.currentModule, internalize(name));\n@@ -264,1 +270,1 @@\n-     * {@link PoolReader#peekClassName(int, NameMapper)}.\n+     * {@link PoolReader#peekClassName(int, Utf8Mapper)}.\n@@ -371,0 +377,2 @@\n+                } catch (InvalidUtfException e) {\n+                    throw reader.badClassFile(\"bad.utf8.byte.sequence.at\", Integer.toString(e.getOffset()));\n@@ -383,0 +391,6 @@\n+\n+\/\/ Utf8Mapper\n+\n+    public interface Utf8Mapper<X> {\n+        X map(byte[] bytes, int offset, int len) throws InvalidUtfException;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolReader.java","additions":28,"deletions":14,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import com.sun.tools.javac.util.InvalidUtfException;\n@@ -327,1 +328,5 @@\n-            return sigbuf.toName(names);\n+            try {\n+                return sigbuf.toName(names);\n+            } catch (InvalidUtfException e) {\n+                throw new AssertionError(e);\n+            }\n@@ -368,1 +373,1 @@\n-                            names.fromUtf(externalize(ct.tsym.flatName()));\n+                            externalize(ct.tsym.flatName());\n@@ -399,1 +404,1 @@\n-                    Name pkgName = names.fromUtf(externalize(pkg.flatName()));\n+                    Name pkgName = externalize(pkg.flatName());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolWriter.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2435,0 +2435,3 @@\n+compiler.misc.bad.utf8.byte.sequence.at=\\\n+    bad UTF-8 byte sequence at {1}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -275,0 +275,1 @@\n+     *  @throws InvalidUtfException if invalid Modified UTF-8 is encountered\n@@ -276,2 +277,2 @@\n-    public Name toName(Names names) {\n-        return names.fromUtf(elems, 0, length);\n+    public Name toName(Names names) throws InvalidUtfException {\n+        return names.fromUtf(elems, 0, length, false);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/ByteBuffer.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -103,3 +103,16 @@\n-    \/** Convert `len' bytes from utf8 to characters.\n-     *  Parameters are as in System.arraycopy\n-     *  Return first index in `dst' past the last copied char.\n+    \/** Validate the given Modified UTF-8 encoding.\n+     *  Reject invalid data by throwing an {@link InvalidUtfException}.\n+     *  @param buf        Buffer containing data\n+     *  @param off        Data starting offset\n+     *  @param len        Data length\n+     *  @param lenient    Whether to allow longer-than-necessary encodings\n+     *                    (for obsolete classfile versions &lt; 48)\n+     *  @throws InvalidUtfException if invalid Modified UTF-8 is encountered\n+     *\/\n+    public static void utfValidate(byte[] buf, int off, int len, boolean lenient) throws InvalidUtfException {\n+        utf2chars(buf, off, null, 0, len, lenient);\n+    }\n+\n+    \/** Decode characters encoded in Modified UTF-8 encoding.\n+     *  Reject any invalid data by throwing an {@link InvalidUtfException}.\n+     *  Parameters are as in System.arraycopy():\n@@ -107,3 +120,4 @@\n-     *  @param sindex     The start index from which bytes are converted.\n-     *  @param dst        The array holding the converted characters..\n-     *  @param dindex     The start index from which converted characters\n+     *  @param soff       The start index from which bytes are converted.\n+     *  @param dst        The array holding the converted characters,\n+     *                    or null to just validate\n+     *  @param doff       The start index from which converted characters\n@@ -112,0 +126,4 @@\n+     *  @param lenient    Whether to allow longer-than-necessary encodings\n+     *                    (for obsolete classfile versions &lt; 48)\n+     *  @return the index in {@code dst} just after the last copied char\n+     *  @throws InvalidUtfException if invalid Modified UTF-8 is encountered\n@@ -113,17 +131,33 @@\n-    public static int utf2chars(byte[] src, int sindex,\n-                                char[] dst, int dindex,\n-                                int len) {\n-        int i = sindex;\n-        int j = dindex;\n-        int limit = sindex + len;\n-        while (i < limit) {\n-            int b = src[i++] & 0xFF;\n-            if (b >= 0xE0) {\n-                b = (b & 0x0F) << 12;\n-                b = b | (src[i++] & 0x3F) << 6;\n-                b = b | (src[i++] & 0x3F);\n-            } else if (b >= 0xC0) {\n-                b = (b & 0x1F) << 6;\n-                b = b | (src[i++] & 0x3F);\n-            }\n-            dst[j++] = (char)b;\n+    public static int utf2chars(byte[] src, int soff, char[] dst, int doff, int len, boolean lenient)\n+      throws InvalidUtfException {\n+        final int doff0 = doff;\n+        while (len-- > 0) {\n+            final int soff0 = soff;\n+            int value = src[soff++];\n+            if (value < 0) {\n+                if ((value & 0xe0) == 0xc0) {\n+                    if (--len < 0)\n+                        throw new InvalidUtfException(soff0);\n+                    int value2 = src[soff++];\n+                    if ((value2 & 0xc0) != 0x80)\n+                        throw new InvalidUtfException(soff0);\n+                    value = ((value & 0x1f) << 6) | (value2 & 0x3f);\n+                    if (!lenient && value != 0 && (value & ~0x7f) == 0)\n+                        throw new InvalidUtfException(soff0);   \/\/ could have been one byte\n+                } else if ((value & 0xf0) == 0xe0) {\n+                    if ((len -= 2) < 0)\n+                        throw new InvalidUtfException(soff0);\n+                    int value2 = src[soff++];\n+                    int value3 = src[soff++];\n+                    if ((value2 & 0xc0) != 0x80 || (value3 & 0xc0) != 0x80)\n+                        throw new InvalidUtfException(soff0);\n+                    value = ((value & 0x0f) << 12) | ((value2 & 0x3f) << 6) | (value3 & 0x3f);\n+                    if (!lenient && (value & ~0x7ff) == 0)\n+                        throw new InvalidUtfException(soff0);   \/\/ could have been two bytes\n+                } else\n+                    throw new InvalidUtfException(soff0);\n+            } else if (value == 0)\n+                throw new InvalidUtfException(soff0);   \/\/ 0x0000 must be encoded as two bytes\n+            if (dst != null)\n+                dst[doff] = (char)value;\n+            doff++;\n@@ -131,1 +165,1 @@\n-        return j;\n+        return doff - doff0;\n@@ -134,1 +168,1 @@\n-    \/** Return bytes in Utf8 representation as an array of characters.\n+    \/** Decode characters encoded in Modified UTF-8 encoding.\n@@ -138,0 +172,4 @@\n+     *  @param lenient    Whether to allow longer-than-necessary encodings\n+     *                    (for obsolete classfile versions &lt; 48)\n+     *  @return           The decoded characters in an array.\n+     *  @throws InvalidUtfException if invalid Modified UTF-8 is encountered\n@@ -139,1 +177,2 @@\n-    public static char[] utf2chars(byte[] src, int sindex, int len) {\n+    public static char[] utf2chars(byte[] src, int sindex, int len, boolean lenient)\n+      throws InvalidUtfException {\n@@ -141,1 +180,3 @@\n-        int len1 = utf2chars(src, sindex, dst, 0, len);\n+        int len1 = utf2chars(src, sindex, dst, 0, len, lenient);\n+        if (len1 == len)\n+            return dst;\n@@ -147,9 +188,1 @@\n-    \/** Return all bytes of a given array in Utf8 representation\n-     *  as an array of characters.\n-     *  @param src        The array holding the bytes.\n-     *\/\n-    public static char[] utf2chars(byte[] src) {\n-        return utf2chars(src, 0, src.length);\n-    }\n-\n-    \/** Return bytes in Utf8 representation as a string.\n+    \/** Decode a {@link String} encoded in Modified UTF-8 encoding.\n@@ -159,0 +192,3 @@\n+     *  @param lenient    Whether to allow longer-than-necessary encodings\n+     *                    (for obsolete classfile versions &lt; 48)\n+     *  @throws InvalidUtfException if invalid Modified UTF-8 is encountered\n@@ -160,1 +196,2 @@\n-    public static String utf2string(byte[] src, int sindex, int len) {\n+    public static String utf2string(byte[] src, int sindex, int len, boolean lenient)\n+      throws InvalidUtfException {\n@@ -162,1 +199,1 @@\n-        int len1 = utf2chars(src, sindex, dst, 0, len);\n+        int len1 = utf2chars(src, sindex, dst, 0, len, lenient);\n@@ -166,8 +203,0 @@\n-    \/** Return all bytes of a given array in Utf8 representation\n-     *  as a string.\n-     *  @param src        The array holding the bytes.\n-     *\/\n-    public static String utf2string(byte[] src) {\n-        return utf2string(src, 0, src.length);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Convert.java","additions":75,"deletions":46,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.util;\n+\n+\/**\n+ * Exception thrown when invalid Modified UTF-8 is encountered.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\n+ * @see Convert#utf2chars\n+ * @see Convert#utfValidate\n+ *\/\n+public class InvalidUtfException extends Exception {\n+\n+    private static final long serialVersionUID = 0;\n+\n+    private final int offset;\n+\n+    public InvalidUtfException(int offset) {\n+        this.offset = offset;\n+    }\n+\n+    \/** Get the {@code byte[]} array offset at which the invalid data was found.\n+     *\/\n+    public int getOffset() {\n+        return offset;\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/InvalidUtfException.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -90,1 +90,5 @@\n-        return table.fromUtf(bs, 0, bs.length);\n+        try {\n+            return table.fromUtf(bs, 0, bs.length, false);\n+        } catch (InvalidUtfException e) {\n+            throw new AssertionError(e);\n+        }\n@@ -102,1 +106,5 @@\n-        return table.fromUtf(bs, 0, bs.length);\n+        try {\n+            return table.fromUtf(bs, 0, bs.length, false);\n+        } catch (InvalidUtfException e) {\n+            throw new AssertionError(e);\n+        }\n@@ -152,1 +160,5 @@\n-        return table.fromUtf(getByteArray(), getByteOffset() + start, end - start);\n+        try {\n+            return table.fromUtf(getByteArray(), getByteOffset() + start, end - start, false);\n+        } catch (InvalidUtfException e) {\n+            throw new AssertionError(e);\n+        }\n@@ -159,1 +171,5 @@\n-        return Convert.utf2string(getByteArray(), getByteOffset(), getByteLength());\n+        try {\n+            return Convert.utf2string(getByteArray(), getByteOffset(), getByteLength(), false);\n+        } catch (InvalidUtfException e) {\n+            throw new AssertionError(e);\n+        }\n@@ -231,2 +247,2 @@\n-        public Name fromUtf(byte[] cs) {\n-            return fromUtf(cs, 0, cs.length);\n+        public Name fromUtf(byte[] cs) throws InvalidUtfException {\n+            return fromUtf(cs, 0, cs.length, false);\n@@ -237,0 +253,1 @@\n+         *  @throws InvalidUtfException if invalid Modified UTF-8 is encountered\n@@ -238,1 +255,2 @@\n-        public abstract Name fromUtf(byte[] cs, int start, int len);\n+        public abstract Name fromUtf(byte[] cs, int start, int len, boolean lenient)\n+            throws InvalidUtfException;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Name.java","additions":25,"deletions":7,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -423,1 +423,1 @@\n-    public Name fromUtf(byte[] cs) {\n+    public Name fromUtf(byte[] cs) throws InvalidUtfException {\n@@ -427,2 +427,2 @@\n-    public Name fromUtf(byte[] cs, int start, int len) {\n-        return table.fromUtf(cs, start, len);\n+    public Name fromUtf(byte[] cs, int start, int len, boolean lenient) throws InvalidUtfException {\n+        return table.fromUtf(cs, start, len, lenient);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -122,1 +122,2 @@\n-    public Name fromUtf(byte[] cs, int start, int len) {\n+    public Name fromUtf(byte[] cs, int start, int len, boolean lenient) throws InvalidUtfException {\n+        Convert.utfValidate(cs, start, len, lenient);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/SharedNameTable.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-        return fromUtf(name, 0, nbytes);\n+        return fromValidUtf(name, 0, nbytes);\n@@ -88,1 +88,6 @@\n-    public Name fromUtf(byte[] cs, int start, int len) {\n+    public Name fromUtf(byte[] cs, int start, int len, boolean lenient) throws InvalidUtfException {\n+        Convert.utfValidate(cs, start, len, lenient);\n+        return fromValidUtf(cs, start, len);\n+    }\n+\n+    private Name fromValidUtf(byte[] cs, int start, int len) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/UnsharedNameTable.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8303623\n+ * @summary Compiler should disallow non-standard UTF-8 string encodings\n+ *\/\n+\n+import com.sun.tools.javac.Main;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.file.Files;\n+import java.util.Arrays;\n+\n+public class InvalidModifiedUtf8Test {\n+\n+    \/\/\n+    \/\/ What this test does (repeatedly):\n+    \/\/  1. Compile a Java source file for ClassX normally\n+    \/\/  2. Modify the UTF-8 inside the ClassX classfile so that it is\n+    \/\/     still valid structurally but uses a non-standard way of\n+    \/\/     encoding some character (according to \"Modified UTF-8\").\n+    \/\/  3. Compile a Java source file for RefClass that references ClassX\n+    \/\/  4. Verify that the compiler gives a \"bad UTF-8\" error\n+    \/\/\n+\n+    \/\/ We change c3 a8 -> c3 e8 (illegal second byte not of the form 0x10xxxxxx)\n+    private static final String SOURCE_0 = \"\"\"\n+        interface Class0 {\n+            void ABC\\u00e8();       \/\/ encodes to: 41 42 43 c3 a8\n+        }\n+    \"\"\";\n+\n+    \/\/ We change e1 80 80 -> e1 80 40 (illegal third byte not of the form 0x10xxxxxx)\n+    private static final String SOURCE_1 = \"\"\"\n+        interface Class1 {\n+            void ABC\\u1000();       \/\/ encodes to: 41 42 43 e1 80 80\n+        }\n+    \"\"\";\n+\n+    \/\/ We change c4 80 -> c1 81 (illegal two-byte encoding for one-byte value)\n+    private static final String SOURCE_2 = \"\"\"\n+        interface Class2 {\n+            void ABC\\u0100();       \/\/ encodes to: 41 42 43 c4 00\n+        }\n+    \"\"\";\n+\n+    \/\/ We change e1 80 80 -> e0 84 80 (illegal three-byte encoding for two-byte value)\n+    private static final String SOURCE_3 = \"\"\"\n+        interface Class3 {\n+            void ABC\\u1000();       \/\/ encodes to: 41 42 43 e1 80 80\n+        }\n+    \"\"\";\n+\n+    \/\/ We change 44 -> 00 (illegal one-byte encoding of 0x0000)\n+    private static final String SOURCE_4 = \"\"\"\n+        interface Class4 {\n+            void ABCD();            \/\/ encodes to: 41 42 43 44\n+        }\n+    \"\"\";\n+\n+    \/\/ This is the source file that references one of the above\n+    private static final String REF_SOURCE = \"\"\"\n+        interface RefClass extends CLASSNAME {\n+        }\n+    \"\"\";\n+\n+    private static String[] SOURCES = new String[] {\n+        SOURCE_0,\n+        SOURCE_1,\n+        SOURCE_2,\n+        SOURCE_3,\n+        SOURCE_4,\n+    };\n+    private static String[][] MODIFICATIONS = new String[][] {\n+        {   \"414243c3a8\",\n+            \"414243c3e8\"    },\n+        {   \"414243e18080\",\n+            \"414243e18040\"  },\n+        {   \"414243c480\",\n+            \"414243c181\"    },\n+        {   \"414243e18080\",\n+            \"414243e08480\"  },\n+        {   \"41424344\",\n+            \"41424300\"      },\n+    };\n+\n+    private static File[] SOURCE_FILES = new File[] {\n+        new File(\"Class0.java\"),\n+        new File(\"Class1.java\"),\n+        new File(\"Class2.java\"),\n+        new File(\"Class3.java\"),\n+        new File(\"Class4.java\"),\n+    };\n+    private static File[] CLASS_FILES = new File[] {\n+        new File(\"Class0.class\"),\n+        new File(\"Class1.class\"),\n+        new File(\"Class2.class\"),\n+        new File(\"Class3.class\"),\n+        new File(\"Class4.class\"),\n+    };\n+\n+    public static String bytes2string(byte[] array) {\n+        char[] buf = new char[array.length * 2];\n+        for (int i = 0; i < array.length; i++) {\n+            int value = array[i] & 0xff;\n+            buf[i * 2] = Character.forDigit(value >> 4, 16);\n+            buf[i * 2 + 1] = Character.forDigit(value & 0xf, 16);\n+        }\n+        return new String(buf);\n+    }\n+\n+    public static byte[] string2bytes(String string) {\n+        byte[] buf = new byte[string.length() \/ 2];\n+        for (int i = 0; i < string.length(); i += 2) {\n+            int value = Integer.parseInt(string.substring(i, i + 2), 16);\n+            buf[i \/ 2] = (byte)value;\n+        }\n+        return buf;\n+    }\n+\n+    private static void createSourceFile(String content, File file) throws IOException {\n+        System.err.println(\"creating: \" + file);\n+        try (PrintStream output = new PrintStream(new FileOutputStream(file))) {\n+            output.println(content);\n+        }\n+    }\n+\n+    private static void writeFile(File file, byte[] content) throws IOException {\n+        System.err.println(\"writing: \" + file);\n+        try (FileOutputStream output = new FileOutputStream(file)) {\n+            Files.write(file.toPath(), content);\n+        }\n+    }\n+\n+    private static void compileRefClass(File file, String expectedError) {\n+        final StringWriter diags = new StringWriter();\n+        final String[] params = new String[] {\n+            \"-classpath\",\n+            \".\",\n+            \"-XDrawDiagnostics\",\n+            file.toString()\n+        };\n+        System.err.println(\"compiling: \" + file);\n+        int ret = Main.compile(params, new PrintWriter(diags, true));\n+        if (expectedError != null && ret == 0)\n+            throw new AssertionError(\"compilation succeeded, but expected error \\\"\" + expectedError + \"\\\"\");\n+        else if (expectedError == null && ret != 0)\n+            throw new AssertionError(\"compilation failed, but expected success:\\n\" + diags);\n+        if (expectedError != null && !diags.toString().contains(expectedError))\n+            throw new AssertionError(\"error message not found:\\n  expected: \\\"\" + expectedError + \"\\\"\\n  found:\" + diags);\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+\n+        \/\/ Create source files\n+        for (int i = 0; i < 5; i++)\n+            createSourceFile(SOURCES[i], SOURCE_FILES[i]);\n+\n+        \/\/ Compile source files\n+        for (int i = 0; i < 5; i++) {\n+            final File sourceFile = SOURCE_FILES[i];\n+            int ret = Main.compile(new String[] { sourceFile.toString() });\n+            if (ret != 0)\n+                throw new AssertionError(\"compilation of \" + sourceFile + \" failed\");\n+        }\n+\n+        \/\/ Now compile REF_SOURCE against each classfile without and then with the modification.\n+        \/\/ When compiling without the modification, everything should be normal.\n+        \/\/ When compiling with the modification, an error should be generated.\n+        for (int i = 0; i < 5; i++) {\n+            final String className = \"Class\" + i;\n+            final File classFile = CLASS_FILES[i];\n+\n+            \/\/ Create reference source file\n+            final File refSource = new File(\"RefClass.java\");\n+            createSourceFile(REF_SOURCE.replaceAll(\"CLASSNAME\", className), refSource);\n+\n+            \/\/ Do a normal compilation\n+            compileRefClass(refSource, null);\n+\n+            \/\/ Now corrupt the class file\n+            System.err.println(\"modifying: \" + classFile);\n+            final String[] mod = MODIFICATIONS[i];\n+            final byte[] data1 = Files.readAllBytes(classFile.toPath());\n+            final byte[] data2 = string2bytes(bytes2string(data1).replaceAll(mod[0], mod[1]));\n+            if (Arrays.equals(data2, data1))\n+                throw new AssertionError(\"modification of \" + classFile + \" failed\");\n+            writeFile(classFile, data2);\n+\n+            \/\/ Do a corrupt compilation\n+            compileRefClass(refSource, \"compiler.misc.bad.utf8.byte.sequence.at\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/classreader\/InvalidModifiedUtf8Test.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -60,0 +60,1 @@\n+compiler.misc.bad.utf8.byte.sequence.at                 # bad class file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}