{"files":[{"patch":"@@ -239,0 +239,1 @@\n+        WARN_ON_ILLEGAL_UTF8(MIN, JDK21),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2456,1 +2456,6 @@\n-            Name name = names.fromUtf(ba);\n+            Name name;\n+            try {\n+                name = names.fromUtf(ba);\n+            } catch (InvalidUtfException e) {\n+                throw new AssertionError(e);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -478,1 +478,1 @@\n-                            names.fromUtf(ClassWriter.externalize(forEnum.type.tsym.flatName())).toString()\n+                            ClassWriter.externalize(forEnum.type.tsym.flatName().toString())\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+        V48(48, 0),   \/\/ JDK 1.4\n@@ -168,2 +169,2 @@\n-    public static byte[] internalize(Name name) {\n-        return internalize(name.getByteArray(), name.getByteOffset(), name.getByteLength());\n+    public static Name internalize(Name name) {\n+        return name.table.names.fromString(name.toString().replace('\/', '.'));\n@@ -173,1 +174,1 @@\n-     * Return external representation of buf[offset..offset+len-1], converting '.' to '\/'.\n+     * Return external representation of given name, converting '\/' to '.'.\n@@ -178,8 +179,2 @@\n-    public static byte[] externalize(byte[] buf, int offset, int len) {\n-        byte[] translated = new byte[len];\n-        for (int j = 0; j < len; j++) {\n-            byte b = buf[offset + j];\n-            if (b == '.') translated[j] = (byte) '\/';\n-            else translated[j] = b;\n-        }\n-        return translated;\n+    public static Name externalize(Name name) {\n+        return name.table.names.fromString(externalize(name.toString()));\n@@ -194,2 +189,2 @@\n-    public static byte[] externalize(Name name) {\n-        return externalize(name.getByteArray(), name.getByteOffset(), name.getByteLength());\n+    public static String externalize(String name) {\n+        return name.replace('.', '\/');\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassFile.java","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import com.sun.tools.javac.code.Source;\n@@ -68,0 +69,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.Fragment;\n@@ -121,0 +123,4 @@\n+    \/** Switch: warn (instead of error) on illegal UTF-8\n+     *\/\n+    boolean warnOnIllegalUtf8;\n+\n@@ -193,0 +199,3 @@\n+    \/** UTF-8 validation level *\/\n+    Convert.Validation utf8validation;\n+\n@@ -284,0 +293,1 @@\n+        warnOnIllegalUtf8 = Feature.WARN_ON_ILLEGAL_UTF8.allowedInSource(source);\n@@ -310,0 +320,8 @@\n+        return badClassFile(diagFactory.fragment(key, args));\n+    }\n+\n+    public ClassFinder.BadClassFile badClassFile(Fragment fragment) {\n+        return badClassFile(diagFactory.fragment(fragment));\n+    }\n+\n+    public ClassFinder.BadClassFile badClassFile(JCDiagnostic diagnostic) {\n@@ -313,1 +331,1 @@\n-            diagFactory.fragment(key, args),\n+            diagnostic,\n@@ -338,1 +356,1 @@\n-            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+            throw badClassFile(Fragments.BadClassTruncatedAtOffset(e.getLength()));\n@@ -350,1 +368,1 @@\n-            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+            throw badClassFile(Fragments.BadClassTruncatedAtOffset(e.getLength()));\n@@ -361,1 +379,1 @@\n-            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+            throw badClassFile(Fragments.BadClassTruncatedAtOffset(e.getLength()));\n@@ -458,1 +476,1 @@\n-                : findTypeVar(names.fromUtf(signature, start, sigp - 1 - start));\n+                : findTypeVar(readName(signature, start, sigp - 1 - start));\n@@ -542,2 +560,1 @@\n-            throw badClassFile(\"bad.signature\",\n-                               Convert.utf2string(signature, sigp, 10));\n+            throw badClassFile(\"bad.signature\", quoteBadSignature());\n@@ -553,2 +570,1 @@\n-            throw badClassFile(\"bad.class.signature\",\n-                               Convert.utf2string(signature, sigp, 10));\n+            throw badClassFile(\"bad.class.signature\", quoteBadSignature());\n@@ -564,1 +580,1 @@\n-                ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,\n+                ClassSymbol t = enterClass(readName(signatureBuffer,\n@@ -578,1 +594,1 @@\n-                ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,\n+                ClassSymbol t = enterClass(readName(signatureBuffer,\n@@ -641,1 +657,1 @@\n-                    t = enterClass(names.fromUtf(signatureBuffer,\n+                    t = enterClass(readName(signatureBuffer,\n@@ -658,0 +674,14 @@\n+    \/** Quote a bogus signature for display inside an error message.\n+     *\/\n+    String quoteBadSignature() {\n+        String sigString;\n+        try {\n+            sigString = Convert.utf2string(signature, sigp, siglimit - sigp, Convert.Validation.NONE);\n+        } catch (InvalidUtfException e) {\n+            throw new AssertionError(e);\n+        }\n+        if (sigString.length() > 32)\n+            sigString = sigString.substring(0, 32) + \"...\";\n+        return \"\\\"\" + sigString + \"\\\"\";\n+    }\n+\n@@ -704,1 +734,1 @@\n-        Name name = names.fromUtf(signature, start, sigp - start);\n+        Name name = readName(signature, start, sigp - start);\n@@ -755,0 +785,13 @@\n+    private Name readName(byte[] buf, int off, int len) {\n+        try {\n+            return names.fromUtf(buf, off, len, utf8validation);\n+        } catch (InvalidUtfException e) {\n+            if (warnOnIllegalUtf8) {\n+                log.warning(Warnings.InvalidUtf8InClassfile(currentClassFile,\n+                    Fragments.BadUtf8ByteSequenceAt(sigp)));\n+                return names.fromUtfLax(buf, off, len);\n+            }\n+            throw badClassFile(Fragments.BadUtf8ByteSequenceAt(sigp));\n+        }\n+    }\n+\n@@ -1109,1 +1152,1 @@\n-                        Name moduleName = poolReader.peekModuleName(nextChar(), names::fromUtf);\n+                        Name moduleName = poolReader.peekModuleName(nextChar(), ClassReader.this::readName);\n@@ -1204,2 +1247,12 @@\n-                private Name classNameMapper(byte[] arr, int offset, int length) {\n-                    return names.fromUtf(ClassFile.internalize(arr, offset, length));\n+                private Name classNameMapper(byte[] arr, int offset, int length) throws InvalidUtfException {\n+                    byte[] buf = ClassFile.internalize(arr, offset, length);\n+                    try {\n+                        return names.fromUtf(buf, 0, buf.length, utf8validation);\n+                    } catch (InvalidUtfException e) {\n+                        if (warnOnIllegalUtf8) {\n+                            log.warning(Warnings.InvalidUtf8InClassfile(currentClassFile,\n+                                Fragments.BadUtf8ByteSequenceAt(e.getOffset())));\n+                            return names.fromUtfLax(buf, 0, buf.length);\n+                        }\n+                        throw e;\n+                    }\n@@ -1505,1 +1558,1 @@\n-            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+            throw badClassFile(Fragments.BadClassTruncatedAtOffset(e.getLength()));\n@@ -1799,1 +1852,1 @@\n-            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+            throw badClassFile(Fragments.BadClassTruncatedAtOffset(e.getLength()));\n@@ -2662,0 +2715,1 @@\n+        utf8validation = majorVersion < V48.major ? Convert.Validation.PREJDK14 : Convert.Validation.STRICT;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":72,"deletions":18,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-    NameMapper<String> utf8Mapper(boolean internalize) {\n+    PoolReader.Utf8Mapper<String> utf8Mapper(boolean internalize) {\n@@ -162,3 +162,5 @@\n-                (buf, offset, len) ->\n-                    Convert.utf2string(ClassFile.internalize(buf, offset, len)) :\n-                Convert::utf2string;\n+            (buf, offset, len) -> {\n+                buf = ClassFile.internalize(buf, offset, len);\n+                return Convert.utf2string(buf, 0, buf.length, Convert.Validation.STRICT);\n+            } :\n+            (buf, offset, len) -> Convert.utf2string(buf, offset, len, Convert.Validation.STRICT);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ModuleNameReader.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.tools.javac.code.Source;\n@@ -34,0 +35,2 @@\n+import com.sun.tools.javac.resources.CompilerProperties.Fragments;\n+import com.sun.tools.javac.resources.CompilerProperties.Warnings;\n@@ -36,0 +39,2 @@\n+import com.sun.tools.javac.util.Convert;\n+import com.sun.tools.javac.util.InvalidUtfException;\n@@ -37,1 +42,0 @@\n-import com.sun.tools.javac.util.Name.NameMapper;\n@@ -77,0 +81,1 @@\n+    private final Convert.Validation utf8validation;\n@@ -93,0 +98,1 @@\n+        this.utf8validation = reader != null ? reader.utf8validation : Convert.Validation.NONE;\n@@ -121,1 +127,1 @@\n-    <Z> Z peekClassName(int index, NameMapper<Z> mapper) {\n+    <Z> Z peekClassName(int index, Utf8Mapper<Z> mapper) {\n@@ -128,1 +134,1 @@\n-    <Z> Z peekPackageName(int index, NameMapper<Z> mapper) {\n+    <Z> Z peekPackageName(int index, Utf8Mapper<Z> mapper) {\n@@ -135,1 +141,1 @@\n-    <Z> Z peekModuleName(int index, NameMapper<Z> mapper) {\n+    <Z> Z peekModuleName(int index, Utf8Mapper<Z> mapper) {\n@@ -139,1 +145,1 @@\n-    private <Z> Z peekItemName(int index, NameMapper<Z> mapper) {\n+    private <Z> Z peekItemName(int index, Utf8Mapper<Z> mapper) {\n@@ -143,1 +149,1 @@\n-            throw reader.badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+            throw reader.badClassFile(Fragments.BadClassTruncatedAtOffset(e.getLength()));\n@@ -165,1 +171,1 @@\n-    <Z> Z peekName(int index, Name.NameMapper<Z> mapper) {\n+    <Z> Z peekName(int index, Utf8Mapper<Z> mapper) {\n@@ -168,0 +174,2 @@\n+        } catch (InvalidUtfException e) {\n+            throw reader.badClassFile(Fragments.BadUtf8ByteSequenceAt(e.getOffset()));\n@@ -169,1 +177,1 @@\n-            throw reader.badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+            throw reader.badClassFile(Fragments.BadClassTruncatedAtOffset(e.getLength()));\n@@ -205,1 +213,1 @@\n-    private <Z> Z getUtf8(int index, NameMapper<Z> mapper) throws UnderflowException {\n+    private <Z> Z getUtf8(int index, Utf8Mapper<Z> mapper) throws InvalidUtfException, UnderflowException {\n@@ -209,2 +217,4 @@\n-            int len = pool.poolbuf.getChar(offset);\n-            return mapper.map(pool.poolbuf.elems, offset + 2, len);\n+            int utf8len = pool.poolbuf.getChar(offset);\n+            int utf8off = offset + 2;\n+            pool.poolbuf.verifyRange(utf8off, utf8len);\n+            return mapper.map(pool.poolbuf.elems, utf8off, utf8len);\n@@ -218,1 +228,1 @@\n-    private Object resolve(ByteBuffer poolbuf, int tag, int offset) throws UnderflowException {\n+    private Object resolve(ByteBuffer poolbuf, int tag, int offset) throws InvalidUtfException, UnderflowException {\n@@ -222,1 +232,12 @@\n-                return names.fromUtf(poolbuf.elems, offset + 2, len);\n+                try {\n+                    return names.fromUtf(poolbuf.elems, offset + 2, len, utf8validation);\n+                } catch (InvalidUtfException e) {\n+                    if (reader == null || reader.warnOnIllegalUtf8) {\n+                        if (reader != null) {\n+                            reader.log.warning(Warnings.InvalidUtf8InClassfile(\n+                                reader.currentClassFile, Fragments.BadUtf8ByteSequenceAt(e.getOffset())));\n+                        }\n+                        return names.fromUtfLax(poolbuf.elems, offset + 2, len);\n+                    }\n+                    throw e;\n+                }\n@@ -226,1 +247,1 @@\n-                Name name = names.fromUtf(getName(index).map(ClassFile::internalize));\n+                Name name = internalize(getName(index));\n@@ -246,1 +267,1 @@\n-                return syms.enterPackage(reader.currentModule, names.fromUtf(internalize(name)));\n+                return syms.enterPackage(reader.currentModule, internalize(name));\n@@ -264,1 +285,1 @@\n-     * {@link PoolReader#peekClassName(int, NameMapper)}.\n+     * {@link PoolReader#peekClassName(int, Utf8Mapper)}.\n@@ -270,1 +291,1 @@\n-            throw reader.badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+            throw reader.badClassFile(Fragments.BadClassTruncatedAtOffset(e.getLength()));\n@@ -370,1 +391,3 @@\n-                    p = (P)resolve(poolbuf, tag(index), offset(index));\n+                    p = (P)resolve(poolbuf, currentTag, offset(index));\n+                } catch (InvalidUtfException e) {\n+                    throw reader.badClassFile(Fragments.BadUtf8ByteSequenceAt(e.getOffset()));\n@@ -372,1 +395,1 @@\n-                    throw reader.badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+                    throw reader.badClassFile(Fragments.BadClassTruncatedAtOffset(e.getLength()));\n@@ -383,0 +406,6 @@\n+\n+\/\/ Utf8Mapper\n+\n+    public interface Utf8Mapper<X> {\n+        X map(byte[] bytes, int offset, int len) throws InvalidUtfException;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolReader.java","additions":48,"deletions":19,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import com.sun.tools.javac.util.InvalidUtfException;\n@@ -327,1 +328,5 @@\n-            return sigbuf.toName(names);\n+            try {\n+                return sigbuf.toName(names);\n+            } catch (InvalidUtfException e) {\n+                throw new AssertionError(e);\n+            }\n@@ -368,1 +373,1 @@\n-                            names.fromUtf(externalize(ct.tsym.flatName()));\n+                            externalize(ct.tsym.flatName());\n@@ -399,1 +404,1 @@\n-                    Name pkgName = names.fromUtf(externalize(pkg.flatName()));\n+                    Name pkgName = externalize(pkg.flatName());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolWriter.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2037,0 +2037,4 @@\n+# 0: file name, 1: fragment\n+compiler.warn.invalid.utf8.in.classfile=\\\n+    {0}: classfile contains invalid UTF-8: {1}\n+\n@@ -2441,0 +2445,4 @@\n+# 0: number\n+compiler.misc.bad.utf8.byte.sequence.at=\\\n+    bad UTF-8 byte sequence at {0}\n+\n@@ -2444,0 +2452,1 @@\n+# 0: number\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -275,0 +275,1 @@\n+     *  @throws InvalidUtfException if invalid Modified UTF-8 is encountered\n@@ -276,2 +277,2 @@\n-    public Name toName(Names names) {\n-        return names.fromUtf(elems, 0, length);\n+    public Name toName(Names names) throws InvalidUtfException {\n+        return names.fromUtf(elems, 0, length, Convert.Validation.STRICT);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/ByteBuffer.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -103,3 +103,17 @@\n-    \/** Convert `len' bytes from utf8 to characters.\n-     *  Parameters are as in System.arraycopy\n-     *  Return first index in `dst' past the last copied char.\n+    \/** Validate the given Modified UTF-8 encoding using the given validation level.\n+     *  Reject invalid data by throwing an {@link InvalidUtfException}.\n+     *  Note: there is no point in calling this method with {@link Validation#NONE}.\n+     *  @param buf        Buffer containing data\n+     *  @param off        Data starting offset\n+     *  @param len        Data length\n+     *  @param validation Level of validation\n+     *  @throws InvalidUtfException if {@code validation} is not {@link Validation#NONE}\n+     *      and invalid Modified UTF-8 is encountered\n+     *\/\n+    public static void utfValidate(byte[] buf, int off, int len, Validation validation) throws InvalidUtfException {\n+        utf2chars(buf, off, null, 0, len, validation);\n+    }\n+\n+    \/** Decode characters encoded in Modified UTF-8 encoding using the given validation level.\n+     *  Reject any invalid data by throwing an {@link InvalidUtfException}.\n+     *  Parameters are as in System.arraycopy():\n@@ -107,3 +121,4 @@\n-     *  @param sindex     The start index from which bytes are converted.\n-     *  @param dst        The array holding the converted characters..\n-     *  @param dindex     The start index from which converted characters\n+     *  @param soff       The start index from which bytes are converted.\n+     *  @param dst        The array holding the converted characters,\n+     *                    or null to just validate\n+     *  @param doff       The start index from which converted characters\n@@ -112,0 +127,5 @@\n+     *  @param validation Level of validation\n+     *  @throws InvalidUtfException if invalid Modified UTF-8 is encountered\n+     *  @return the index in {@code dst} just after the last copied char\n+     *  @throws InvalidUtfException if {@code validation} is not {@link Validation#NONE}\n+     *      and invalid Modified UTF-8 is encountered\n@@ -113,17 +133,45 @@\n-    public static int utf2chars(byte[] src, int sindex,\n-                                char[] dst, int dindex,\n-                                int len) {\n-        int i = sindex;\n-        int j = dindex;\n-        int limit = sindex + len;\n-        while (i < limit) {\n-            int b = src[i++] & 0xFF;\n-            if (b >= 0xE0) {\n-                b = (b & 0x0F) << 12;\n-                b = b | (src[i++] & 0x3F) << 6;\n-                b = b | (src[i++] & 0x3F);\n-            } else if (b >= 0xC0) {\n-                b = (b & 0x1F) << 6;\n-                b = b | (src[i++] & 0x3F);\n-            }\n-            dst[j++] = (char)b;\n+    public static int utf2chars(byte[] src, int soff, char[] dst, int doff, int len, Validation validation)\n+      throws InvalidUtfException {\n+        final int doff0 = doff;\n+        while (len-- > 0) {\n+            final int soff0 = soff;\n+            int value = src[soff++];\n+            if (value < 0) {\n+                if ((value & 0xe0) == 0xc0) {\n+                    int value2;\n+                    if (len-- > 0)\n+                        value2 = src[soff++];\n+                    else if (validation.allowAnything())\n+                        value2 = 0;\n+                    else\n+                        throw new InvalidUtfException(soff0);\n+                    if (!validation.allowAnything() && (value2 & 0xc0) != 0x80)\n+                        throw new InvalidUtfException(soff0);\n+                    value = ((value & 0x1f) << 6) | (value2 & 0x3f);\n+                    if (!validation.allowLongEncoding() && (value & ~0x7f) == 0 && value != 0)\n+                        throw new InvalidUtfException(soff0);   \/\/ could have been one byte\n+                } else if ((value & 0xf0) == 0xe0) {\n+                    int value2;\n+                    int value3;\n+                    if ((len -= 2) >= 0) {\n+                        value2 = src[soff++];\n+                        value3 = src[soff++];\n+                    } else if (validation.allowAnything()) {\n+                        value2 = 0;\n+                        value3 = 0;\n+                    } else\n+                        throw new InvalidUtfException(soff0);\n+                    if (!validation.allowAnything() && ((value2 & 0xc0) != 0x80 || (value3 & 0xc0) != 0x80))\n+                        throw new InvalidUtfException(soff0);\n+                    value = ((value & 0x0f) << 12) | ((value2 & 0x3f) << 6) | (value3 & 0x3f);\n+                    if (!validation.allowLongEncoding() && (value & ~0x7ff) == 0)\n+                        throw new InvalidUtfException(soff0);   \/\/ could have been two bytes\n+                } else if (validation.allowAnything())\n+                    value &= 0xff;\n+                else\n+                    throw new InvalidUtfException(soff0);\n+            } else if (!validation.allowSingleByteNul() && value == 0)\n+                throw new InvalidUtfException(soff0);           \/\/ 0x0000 must be encoded as two bytes\n+            if (dst != null)\n+                dst[doff] = (char)value;\n+            doff++;\n@@ -131,1 +179,1 @@\n-        return j;\n+        return doff - doff0;\n@@ -134,1 +182,1 @@\n-    \/** Return bytes in Utf8 representation as an array of characters.\n+    \/** Decode characters encoded in Modified UTF-8 encoding.\n@@ -138,0 +186,4 @@\n+     *  @param validation Level of validation\n+     *  @return           The decoded characters in an array.\n+     *  @throws InvalidUtfException if {@code validation} is not {@link Validation#NONE}\n+     *      and invalid Modified UTF-8 is encountered\n@@ -139,1 +191,2 @@\n-    public static char[] utf2chars(byte[] src, int sindex, int len) {\n+    public static char[] utf2chars(byte[] src, int sindex, int len, Validation validation)\n+      throws InvalidUtfException {\n@@ -141,1 +194,3 @@\n-        int len1 = utf2chars(src, sindex, dst, 0, len);\n+        int len1 = utf2chars(src, sindex, dst, 0, len, validation);\n+        if (len1 == len)\n+            return dst;\n@@ -147,9 +202,1 @@\n-    \/** Return all bytes of a given array in Utf8 representation\n-     *  as an array of characters.\n-     *  @param src        The array holding the bytes.\n-     *\/\n-    public static char[] utf2chars(byte[] src) {\n-        return utf2chars(src, 0, src.length);\n-    }\n-\n-    \/** Return bytes in Utf8 representation as a string.\n+    \/** Decode a {@link String} encoded in Modified UTF-8 encoding.\n@@ -159,0 +206,3 @@\n+     *  @param validation Level of validation\n+     *  @throws InvalidUtfException if {@code validation} is not {@link Validation#NONE}\n+     *      and invalid Modified UTF-8 is encountered\n@@ -160,1 +210,2 @@\n-    public static String utf2string(byte[] src, int sindex, int len) {\n+    public static String utf2string(byte[] src, int sindex, int len, Validation validation)\n+      throws InvalidUtfException {\n@@ -162,1 +213,1 @@\n-        int len1 = utf2chars(src, sindex, dst, 0, len);\n+        int len1 = utf2chars(src, sindex, dst, 0, len, validation);\n@@ -166,8 +217,0 @@\n-    \/** Return all bytes of a given array in Utf8 representation\n-     *  as a string.\n-     *  @param src        The array holding the bytes.\n-     *\/\n-    public static String utf2string(byte[] src) {\n-        return utf2string(src, 0, src.length);\n-    }\n-\n@@ -361,0 +404,56 @@\n+\n+    \/**\n+     * Modified UTF-8 decoding validation levels.\n+     *\/\n+    public enum Validation {\n+\n+        \/**\n+         * Do zero validation of UTF-8, i.e., always decode something without error.\n+         * When this is used, {@link InvalidUtfException} is never thrown.\n+         *\/\n+        NONE(true, true, true),\n+\n+        \/**\n+         * Do validation in accordance with the pre-JDK 1.4 Java class file format,\n+         * which allows (a) the NUL character {@code &#92;u0000} to be encoded as a single byte\n+         * and (b) longer-than-necessary encodings (e.g., three bytes instead of two).\n+         *\/\n+        PREJDK14(true, true, false),\n+\n+        \/**\n+         * Do strict validation. At this level, each character has only one valid encoding.\n+         *\/\n+        STRICT(false, false, false);\n+\n+        private final boolean allowSingleByteNul;\n+        private final boolean allowLongEncoding;\n+        private final boolean allowAnything;\n+\n+        private Validation(boolean allowSingleByteNul, boolean allowLongEncoding, boolean allowAnything) {\n+            this.allowSingleByteNul = allowSingleByteNul;\n+            this.allowLongEncoding = allowLongEncoding;\n+            this.allowAnything = allowAnything;\n+        }\n+\n+        \/**\n+         * Whether to allow the NUL character {@code &#92;u0000} to be encoded as a single byte.\n+         * Modified UTF-8 specifies that it be encoded in two bytes.\n+         *\/\n+        public boolean allowSingleByteNul() {\n+            return allowSingleByteNul;\n+        }\n+\n+        \/**\n+         * Whether to allow characters to be encoded using more bytes than required.\n+         *\/\n+        public boolean allowLongEncoding() {\n+            return allowLongEncoding;\n+        }\n+\n+        \/**\n+         * Whether to allow anything, including truncated characters and bogus flag bits.\n+         *\/\n+        public boolean allowAnything() {\n+            return allowAnything;\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Convert.java","additions":145,"deletions":46,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.util;\n+\n+\/**\n+ * Exception thrown when invalid Modified UTF-8 is encountered.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\n+ * @see Convert#utf2chars\n+ * @see Convert#utfValidate\n+ *\/\n+public class InvalidUtfException extends Exception {\n+\n+    private static final long serialVersionUID = 0;\n+\n+    private final int offset;\n+\n+    public InvalidUtfException(int offset) {\n+        this.offset = offset;\n+    }\n+\n+    \/** Get the {@code byte[]} array offset at which the invalid data was found.\n+     *\/\n+    public int getOffset() {\n+        return offset;\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/InvalidUtfException.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -90,1 +90,5 @@\n-        return table.fromUtf(bs, 0, bs.length);\n+        try {\n+            return table.fromUtf(bs, 0, bs.length, Convert.Validation.NONE);\n+        } catch (InvalidUtfException e) {\n+            throw new AssertionError(e);\n+        }\n@@ -102,1 +106,5 @@\n-        return table.fromUtf(bs, 0, bs.length);\n+        try {\n+            return table.fromUtf(bs, 0, bs.length, Convert.Validation.NONE);\n+        } catch (InvalidUtfException e) {\n+            throw new AssertionError(e);\n+        }\n@@ -152,1 +160,5 @@\n-        return table.fromUtf(getByteArray(), getByteOffset() + start, end - start);\n+        try {\n+            return table.fromUtf(getByteArray(), getByteOffset() + start, end - start, Convert.Validation.NONE);\n+        } catch (InvalidUtfException e) {\n+            throw new AssertionError(e);\n+        }\n@@ -159,1 +171,5 @@\n-        return Convert.utf2string(getByteArray(), getByteOffset(), getByteLength());\n+        try {\n+            return Convert.utf2string(getByteArray(), getByteOffset(), getByteLength(), Convert.Validation.NONE);\n+        } catch (InvalidUtfException e) {\n+            throw new AssertionError(e);\n+        }\n@@ -229,1 +245,1 @@\n-         *  Assume that bytes are in utf8 format.\n+         *  Assume that bytes are in strictly valid \"Modified UTF-8\" format.\n@@ -231,2 +247,2 @@\n-        public Name fromUtf(byte[] cs) {\n-            return fromUtf(cs, 0, cs.length);\n+        public Name fromUtf(byte[] cs) throws InvalidUtfException {\n+            return fromUtf(cs, 0, cs.length, Convert.Validation.STRICT);\n@@ -237,0 +253,1 @@\n+         *  @throws InvalidUtfException if invalid Modified UTF-8 is encountered\n@@ -238,1 +255,2 @@\n-        public abstract Name fromUtf(byte[] cs, int start, int len);\n+        public abstract Name fromUtf(byte[] cs, int start, int len, Convert.Validation validation)\n+            throws InvalidUtfException;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Name.java","additions":26,"deletions":8,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -424,1 +424,1 @@\n-    public Name fromUtf(byte[] cs) {\n+    public Name fromUtf(byte[] cs) throws InvalidUtfException {\n@@ -428,2 +428,10 @@\n-    public Name fromUtf(byte[] cs, int start, int len) {\n-        return table.fromUtf(cs, start, len);\n+    public Name fromUtf(byte[] cs, int start, int len, Convert.Validation validation) throws InvalidUtfException {\n+        return table.fromUtf(cs, start, len, validation);\n+    }\n+\n+    public Name fromUtfLax(byte[] cs, int start, int len) {\n+        try {\n+            return table.fromUtf(cs, start, len, Convert.Validation.NONE);\n+        } catch (InvalidUtfException e) {\n+            throw new AssertionError(e);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -122,1 +122,3 @@\n-    public Name fromUtf(byte[] cs, int start, int len) {\n+    public Name fromUtf(byte[] cs, int start, int len, Convert.Validation validation) throws InvalidUtfException {\n+        if (validation != Convert.Validation.NONE)\n+            Convert.utfValidate(cs, start, len, validation);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/SharedNameTable.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-        return fromUtf(name, 0, nbytes);\n+        return fromValidUtf(name, 0, nbytes);\n@@ -88,1 +88,7 @@\n-    public Name fromUtf(byte[] cs, int start, int len) {\n+    public Name fromUtf(byte[] cs, int start, int len, Convert.Validation validation) throws InvalidUtfException {\n+        if (validation != Convert.Validation.NONE)\n+            Convert.utfValidate(cs, start, len, validation);\n+        return fromValidUtf(cs, start, len);\n+    }\n+\n+    private Name fromValidUtf(byte[] cs, int start, int len) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/UnsharedNameTable.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,252 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8303623\n+ * @modules jdk.compiler\/com.sun.tools.javac.code\n+ * @summary Compiler should disallow non-standard UTF-8 string encodings\n+ *\/\n+\n+import com.sun.tools.javac.code.Source;\n+import com.sun.tools.javac.Main;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.file.Files;\n+import java.util.Arrays;\n+\n+public class InvalidModifiedUtf8Test {\n+\n+    \/\/\n+    \/\/ What this test does (repeatedly):\n+    \/\/  1. Compile a Java source file for ClassX normally\n+    \/\/  2. Modify the UTF-8 inside the ClassX classfile so that it is\n+    \/\/     still valid structurally but uses a non-standard way of\n+    \/\/     encoding some character (according to \"Modified UTF-8\").\n+    \/\/  3. Compile a Java source file for RefClass that references ClassX\n+    \/\/  4. Verify that the compiler gives a \"bad UTF-8\" error\n+    \/\/\n+\n+    \/\/ We change c3 a8 -> c3 e8 (illegal second byte not of the form 0x10xxxxxx)\n+    private static final String SOURCE_0 = \"\"\"\n+        interface CLASSNAME {\n+            void ABC\\u00e8();       \/\/ encodes to: 41 42 43 c3 a8\n+        }\n+    \"\"\";\n+\n+    \/\/ We change e1 80 80 -> e1 80 40 (illegal third byte not of the form 0x10xxxxxx)\n+    private static final String SOURCE_1 = \"\"\"\n+        interface CLASSNAME {\n+            void ABC\\u1000();       \/\/ encodes to: 41 42 43 e1 80 80\n+        }\n+    \"\"\";\n+\n+    \/\/ We change c4 80 -> c1 81 (illegal two-byte encoding for one-byte value)\n+    private static final String SOURCE_2 = \"\"\"\n+        interface CLASSNAME {\n+            void ABC\\u0100();       \/\/ encodes to: 41 42 43 c4 00\n+        }\n+    \"\"\";\n+\n+    \/\/ We change e1 80 80 -> e0 84 80 (illegal three-byte encoding for two-byte value)\n+    private static final String SOURCE_3 = \"\"\"\n+        interface CLASSNAME {\n+            void ABC\\u1000();       \/\/ encodes to: 41 42 43 e1 80 80\n+        }\n+    \"\"\";\n+\n+    \/\/ We change 44 -> 00 (illegal one-byte encoding of 0x0000)\n+    private static final String SOURCE_4 = \"\"\"\n+        interface CLASSNAME {\n+            void ABCD();            \/\/ encodes to: 41 42 43 44\n+        }\n+    \"\"\";\n+\n+    \/\/ We change 43 44 -> e1 80 (illegal truncated three-byte encoding)\n+    private static final String SOURCE_5 = \"\"\"\n+        interface CLASSNAME {\n+            void ABCD();            \/\/ encodes to: 41 42 43 44\n+        }\n+    \"\"\";\n+\n+    \/\/ This is the source file that references one of the above\n+    private static final String REF_SOURCE = \"\"\"\n+        interface RefClass extends CLASSNAME {\n+        }\n+    \"\"\";\n+\n+    private static TestCase[] TEST_CASES = new TestCase[] {\n+        new TestCase(0, SOURCE_0, \"414243c3a8\",     \"414243c3e8\"),\n+        new TestCase(1, SOURCE_1, \"414243e18080\",   \"414243e18040\"),\n+        new TestCase(2, SOURCE_2, \"414243c480\",     \"414243c181\"),\n+        new TestCase(3, SOURCE_3, \"414243e18080\",   \"414243e08480\"),\n+        new TestCase(4, SOURCE_4, \"41424344\",       \"41424300\"),\n+        new TestCase(5, SOURCE_5, \"41424344\",       \"4142e180\"),\n+    };\n+\n+    public static String bytes2string(byte[] array) {\n+        char[] buf = new char[array.length * 2];\n+        for (int i = 0; i < array.length; i++) {\n+            int value = array[i] & 0xff;\n+            buf[i * 2] = Character.forDigit(value >> 4, 16);\n+            buf[i * 2 + 1] = Character.forDigit(value & 0xf, 16);\n+        }\n+        return new String(buf);\n+    }\n+\n+    public static byte[] string2bytes(String string) {\n+        byte[] buf = new byte[string.length() \/ 2];\n+        for (int i = 0; i < string.length(); i += 2) {\n+            int value = Integer.parseInt(string.substring(i, i + 2), 16);\n+            buf[i \/ 2] = (byte)value;\n+        }\n+        return buf;\n+    }\n+\n+    private static void createSourceFile(String content, File file) throws IOException {\n+        System.err.println(\"creating: \" + file);\n+        try (PrintStream output = new PrintStream(new FileOutputStream(file))) {\n+            output.println(content);\n+        }\n+    }\n+\n+    private static void writeFile(File file, byte[] content) throws IOException {\n+        System.err.println(\"writing: \" + file);\n+        try (FileOutputStream output = new FileOutputStream(file)) {\n+            Files.write(file.toPath(), content);\n+        }\n+    }\n+\n+    private static void compileRefClass(File file, boolean expectSuccess, String expectedError) {\n+        final StringWriter diags = new StringWriter();\n+        final String[] params = new String[] {\n+            \"-classpath\",\n+            \".\",\n+            \"-XDrawDiagnostics\",\n+            file.toString()\n+        };\n+        System.err.println(\"compiling: \" + file);\n+        int ret = Main.compile(params, new PrintWriter(diags, true));\n+        System.err.println(\"exit value: \" + ret);\n+        String output = diags.toString().trim();\n+        if (!output.isEmpty())\n+            System.err.println(\"output:\\n\" + output);\n+        else\n+            System.err.println(\"no output\");\n+        if (!expectSuccess && ret == 0)\n+            throw new AssertionError(\"compilation succeeded, but expected failure\");\n+        else if (expectSuccess && ret != 0)\n+            throw new AssertionError(\"compilation failed, but expected success\");\n+        if (expectedError != null && !diags.toString().contains(expectedError))\n+            throw new AssertionError(\"expected output \\\"\" + expectedError + \"\\\" not found\");\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+\n+        \/\/ Create source files\n+        for (TestCase test : TEST_CASES)\n+            test.createSourceFile();\n+\n+        \/\/ Compile source files\n+        for (TestCase test : TEST_CASES) {\n+            int ret = Main.compile(new String[] { test.sourceFile().toString() });\n+            if (ret != 0)\n+                throw new AssertionError(\"compilation of \" + test.sourceFile() + \" failed\");\n+        }\n+\n+        \/\/ We should get warnings in JDK 21 and errors in any later release\n+        final boolean expectSuccess = Source.DEFAULT.compareTo(Source.JDK21) <= 0;\n+\n+        \/\/ Now compile REF_SOURCE against each classfile without and then with the modification.\n+        \/\/ When compiling without the modification, everything should be normal.\n+        \/\/ When compiling with the modification, an error should be generated.\n+        for (TestCase test : TEST_CASES) {\n+            System.err.println(\"==== TEST \" + test.index() + \" ====\");\n+\n+            \/\/ Create reference source file\n+            final File refSource = new File(\"RefClass.java\");\n+            createSourceFile(REF_SOURCE.replaceAll(\"CLASSNAME\", test.className()), refSource);\n+\n+            \/\/ Do a normal compilation\n+            compileRefClass(refSource, true, null);\n+\n+            \/\/ Now corrupt the class file\n+            System.err.println(\"modifying: \" + test.classFile());\n+            final File classFile = test.classFile();\n+            final byte[] data1 = Files.readAllBytes(classFile.toPath());\n+            final byte[] data2 = test.modify(data1);\n+            writeFile(classFile, data2);\n+\n+            \/\/ Do a corrupt compilation\n+            compileRefClass(refSource, expectSuccess, \"compiler.misc.bad.utf8.byte.sequence.at\");\n+        }\n+    }\n+\n+\/\/ TestCase\n+\n+    static class TestCase {\n+\n+        final int index;\n+        final String source;\n+        final String match;\n+        final String replace;\n+\n+        TestCase(int index, String source, String match, String replace) {\n+            this.index = index;\n+            this.source = source.replaceAll(\"CLASSNAME\", className());\n+            this.match = match;\n+            this.replace = replace;\n+        }\n+\n+        byte[] modify(byte[] input) {\n+            final byte[] output = string2bytes(bytes2string(input).replaceAll(match, replace));\n+            if (Arrays.equals(output, input))\n+                throw new AssertionError(\"modification of \" + classFile() + \" failed\");\n+            return output;\n+        }\n+\n+        int index() {\n+            return index;\n+        }\n+\n+        String className() {\n+            return \"Class\" + index;\n+        }\n+\n+        File sourceFile() {\n+            return new File(className() + \".java\");\n+        }\n+\n+        File classFile() {\n+            return new File(className() + \".class\");\n+        }\n+\n+        void createSourceFile() throws IOException {\n+            InvalidModifiedUtf8Test.createSourceFile(source, sourceFile());\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/classreader\/InvalidModifiedUtf8Test.java","additions":252,"deletions":0,"binary":false,"changes":252,"status":"added"},{"patch":"@@ -60,0 +60,1 @@\n+compiler.misc.bad.utf8.byte.sequence.at                 # bad class file\n@@ -119,0 +120,1 @@\n+compiler.warn.invalid.utf8.in.classfile                 # bad class file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}