{"files":[{"patch":"@@ -352,12 +352,8 @@\n-    \/\/ if path is a symbolic link, then add its key to the set and\n-    \/\/ continue recursively down any singly linked list of targets\n-    private void getLinkKeys(UnixPath path, Set<UnixFileKey> keys)\n-        throws IOException {\n-        try {\n-            UnixFileAttributes attrs = UnixFileAttributes.get(path, false);\n-            if (attrs.isSymbolicLink()) {\n-                if (!keys.add(attrs.fileKey()))\n-                    return; \/\/ if key already present, then there is a loop so bail out\n-                UnixPath target = UnixPath.toUnixPath(readSymbolicLink(path));\n-                if (exists(target, LinkOption.NOFOLLOW_LINKS))\n-                    getLinkKeys(target, keys);\n+    \/\/ find the key of the last accessible link in the chain\n+    private UnixFileKey lastFileKey(UnixPath path) throws UnixException {\n+        var fileKeys = new HashSet<UnixFileKey>();\n+        UnixFileKey lastFileKey = null;\n+        while (path != null) {\n+            UnixFileAttributes attrs = UnixFileAttributes.getIfExists(path, false);\n+            if (attrs == null) {\n+                break;\n@@ -365,12 +361,10 @@\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(path);\n-        }\n-    }\n-\n-    \/\/ retrieve the file keys of any symbolic links in this path\n-    private Set<UnixFileKey> getLinkKeys(UnixPath path) throws IOException {\n-        Set<UnixFileKey> keys = new HashSet<>();\n-        UnixPath p = path;\n-        while (p != null && exists(p, LinkOption.NOFOLLOW_LINKS)) {\n-            getLinkKeys(p, keys);\n-            p = p.getParent();\n+            UnixFileKey fileKey = attrs.fileKey();\n+            if (!attrs.isSymbolicLink()) {\n+                return fileKey;\n+            }\n+            if (!fileKeys.add(fileKey)) {\n+                throw new UnixException(ELOOP);\n+            }\n+            lastFileKey = fileKey;\n+            byte[] target = readlink(path);\n+            path = new UnixPath(theFileSystem, target);\n@@ -378,1 +372,1 @@\n-        return keys;\n+        return lastFileKey;\n@@ -407,2 +401,1 @@\n-        \/\/ try to retrieve attributes not following links\n-        attrs1 = attrs2 = null;\n+        \/\/ find the last link in each path and compare them\n@@ -410,2 +403,4 @@\n-            if ((attrs1 = UnixFileAttributes.getIfExists(file1, false)) != null)\n-                attrs2 = UnixFileAttributes.getIfExists(file2, false);\n+            UnixFileKey key1 = lastFileKey(file1);\n+            UnixFileKey key2 = lastFileKey(file2);\n+            if (key1 != null && key2 != null && key1.equals(key2))\n+                return true;\n@@ -417,10 +412,0 @@\n-        if (attrs1 != null && attrs2 != null) {\n-            \/\/ both exist if links are not followed, so see whether\n-            \/\/ the two paths both contain a common symbolic link\n-            Set<UnixFileKey> keys1 = getLinkKeys(file1);\n-            Set<UnixFileKey> keys2 = getLinkKeys(file2);\n-            for (UnixFileKey k : keys1)\n-                if (keys2.contains(k))\n-                    return true;\n-        }\n-\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystemProvider.java","additions":24,"deletions":39,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -437,1 +437,3 @@\n-            x.rethrowAsIOException(file1);\n+            if (x.lastError() != ERROR_FILE_NOT_FOUND &&\n+                x.lastError() != ERROR_PATH_NOT_FOUND)\n+                x.rethrowAsIOException(file1);\n@@ -439,0 +441,5 @@\n+\n+        \/\/ if file1 does not exist, it cannot equal file2\n+        if (h1 == 0L)\n+            return false;\n+\n@@ -450,1 +457,3 @@\n-                x.rethrowAsIOException(file2);\n+                if (x.lastError() != ERROR_FILE_NOT_FOUND &&\n+                    x.lastError() != ERROR_PATH_NOT_FOUND)\n+                    x.rethrowAsIOException(file2);\n@@ -452,0 +461,5 @@\n+\n+            \/\/ if file2 does not exist, it cannot equal file1, which does\n+            if (h2 == 0L)\n+                return false;\n+\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileSystemProvider.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -118,15 +118,2 @@\n-        if (Platform.isWindows()) {\n-            try {\n-                isSameFile(thisFile, thatFile);\n-                throw new RuntimeException(\"IOException not thrown\");\n-            } catch (IOException x) {\n-            }\n-            try {\n-                isSameFile(thatFile, thisFile);\n-                throw new RuntimeException(\"IOException not thrown\");\n-            } catch (IOException x) {\n-            }\n-        } else {\n-            assertTrue(!isSameFile(thisFile, thatFile));\n-            assertTrue(!isSameFile(thatFile, thisFile));\n-        }\n+        assertTrue(!isSameFile(thisFile, thatFile));\n+        assertTrue(!isSameFile(thatFile, thisFile));\n@@ -139,15 +126,2 @@\n-            if (Platform.isWindows()) {\n-                try {\n-                    isSameFile(thisFile, thatFile);\n-                    throw new RuntimeException(\"IOException not thrown\");\n-                } catch (IOException x) {\n-                }\n-                try {\n-                    isSameFile(thatFile, thisFile);\n-                    throw new RuntimeException(\"IOException not thrown\");\n-                } catch (IOException x) {\n-                }\n-            } else {\n-                assertTrue(!isSameFile(thisFile, thatFile));\n-                assertTrue(!isSameFile(thatFile, thisFile));\n-            }\n+            assertTrue(!isSameFile(thisFile, thatFile));\n+            assertTrue(!isSameFile(thatFile, thisFile));\n","filename":"test\/jdk\/java\/nio\/file\/Files\/Misc.java","additions":4,"deletions":30,"binary":false,"changes":34,"status":"modified"}]}