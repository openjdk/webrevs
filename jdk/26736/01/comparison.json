{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,1 @@\n+import java.util.HashSet;\n@@ -351,0 +352,29 @@\n+    \/\/ if path is a symbolic link, then add its key to the set and\n+    \/\/ continue recursively down any singly linked list of targets\n+    private void getLinkKeys(UnixPath path, Set<UnixFileKey> keys)\n+        throws IOException {\n+        try {\n+            UnixFileAttributes attrs = UnixFileAttributes.get(path, false);\n+            if (attrs.isSymbolicLink()) {\n+                if (!keys.add(attrs.fileKey()))\n+                    return; \/\/ if key already present, then there is a loop so bail out\n+                UnixPath target = UnixPath.toUnixPath(readSymbolicLink(path));\n+                if (exists(target, LinkOption.NOFOLLOW_LINKS))\n+                    getLinkKeys(target, keys);\n+            }\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(path);\n+        }\n+    }\n+\n+    \/\/ retrieve the file keys of any symbolic links in this path\n+    private Set<UnixFileKey> getLinkKeys(UnixPath path) throws IOException {\n+        Set<UnixFileKey> keys = new HashSet<>();\n+        UnixPath p = path;\n+        while (p != null && exists(p, LinkOption.NOFOLLOW_LINKS)) {\n+            getLinkKeys(p, keys);\n+            p = p.getParent();\n+        }\n+        return keys;\n+    }\n+\n@@ -353,0 +383,1 @@\n+        \/\/ toUnixPath verifies its argument is a non-null UnixPath\n@@ -361,13 +392,34 @@\n-        UnixFileAttributes attrs1;\n-        UnixFileAttributes attrs2;\n-        try {\n-             attrs1 = UnixFileAttributes.get(file1, true);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file1);\n-            return false;    \/\/ keep compiler happy\n-        }\n-        try {\n-            attrs2 = UnixFileAttributes.get(file2, true);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file2);\n-            return false;    \/\/ keep compiler happy\n+        \/\/ check existence while following linkx\n+        boolean exists1 = exists(file1);\n+        boolean exists2 = exists(file2);\n+\n+        if (exists1 && exists2) {\n+            \/\/ both exist, compare their device IDs and inode numbers\n+            UnixFileAttributes attrs1;\n+            UnixFileAttributes attrs2;\n+            try {\n+                attrs1 = UnixFileAttributes.get(file1, true);\n+            } catch (UnixException x) {\n+                x.rethrowAsIOException(file1);\n+                return false;    \/\/ keep compiler happy\n+            }\n+            try {\n+                attrs2 = UnixFileAttributes.get(file2, true);\n+            } catch (UnixException x) {\n+                x.rethrowAsIOException(file2);\n+                return false;    \/\/ keep compiler happy\n+            }\n+            return attrs1.isSameFile(attrs2);\n+        } else if (exists(file1, LinkOption.NOFOLLOW_LINKS) &&\n+                   exists(file2, LinkOption.NOFOLLOW_LINKS)) {\n+            \/\/ both exist if links are not followed, so see whether\n+            \/\/ the two paths both contain a common symbolic link\n+            Set<UnixFileKey> keys1 = getLinkKeys(file1);\n+            Set<UnixFileKey> keys2 = getLinkKeys(file2);\n+            for (UnixFileKey k : keys1)\n+                if (keys2.contains(k))\n+                    return true;\n+            return false;\n+        } else if (exists1 || exists2) {\n+            \/\/ only one exists, they cannot be equal\n+            return false;\n@@ -375,1 +427,4 @@\n-        return attrs1.isSameFile(attrs2);\n+\n+        \/\/ neither exist and comparison of normalized paths is problematic,\n+        \/\/ so return false\n+        return false;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystemProvider.java","additions":70,"deletions":15,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -423,0 +423,1 @@\n+        \/\/ toWindowsPath verifies its argument is a non-null UnixPath\n@@ -432,9 +433,7 @@\n-        \/\/ open both files and see if they are the same\n-        long h1 = 0L;\n-        try {\n-            h1 = file1.openForReadAttributeAccess(true);\n-        } catch (WindowsException x) {\n-            x.rethrowAsIOException(file1);\n-        }\n-        try {\n-            WindowsFileAttributes attrs1 = null;\n+        \/\/ check existence\n+        boolean exists1 = exists(obj1);\n+        boolean exists2 = exists(obj2);\n+\n+        if (exists1 && exists2) {\n+            \/\/ open both files and see if they are the same\n+            long h1 = 0L;\n@@ -442,1 +441,1 @@\n-                attrs1 = WindowsFileAttributes.readAttributes(h1);\n+                h1 = file1.openForReadAttributeAccess(true);\n@@ -446,6 +445,0 @@\n-            long h2 = 0L;\n-            try {\n-                h2 = file2.openForReadAttributeAccess(true);\n-            } catch (WindowsException x) {\n-                x.rethrowAsIOException(file2);\n-            }\n@@ -453,1 +446,1 @@\n-                WindowsFileAttributes attrs2 = null;\n+                WindowsFileAttributes attrs1 = null;\n@@ -455,1 +448,7 @@\n-                    attrs2 = WindowsFileAttributes.readAttributes(h2);\n+                    attrs1 = WindowsFileAttributes.readAttributes(h1);\n+                } catch (WindowsException x) {\n+                    x.rethrowAsIOException(file1);\n+                }\n+                long h2 = 0L;\n+                try {\n+                    h2 = file2.openForReadAttributeAccess(true);\n@@ -459,1 +458,11 @@\n-                return WindowsFileAttributes.isSameFile(attrs1, attrs2);\n+                try {\n+                    WindowsFileAttributes attrs2 = null;\n+                    try {\n+                        attrs2 = WindowsFileAttributes.readAttributes(h2);\n+                    } catch (WindowsException x) {\n+                        x.rethrowAsIOException(file2);\n+                    }\n+                    return WindowsFileAttributes.isSameFile(attrs1, attrs2);\n+                } finally {\n+                    CloseHandle(h2);\n+                }\n@@ -461,1 +470,1 @@\n-                CloseHandle(h2);\n+                CloseHandle(h1);\n@@ -463,2 +472,3 @@\n-        } finally {\n-            CloseHandle(h1);\n+        } else if (exists1 || exists2) {\n+            \/\/ only one exists, they cannot be equal\n+            return false;\n@@ -466,0 +476,3 @@\n+\n+        \/\/ neither exists, compare normalized paths without filesystem access\n+        return obj1.normalize().equals(obj2.normalize());\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileSystemProvider.java","additions":36,"deletions":23,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -0,0 +1,458 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8154364\n+ * @summary Test of Files.isSameFile\n+ * @library .. \/test\/lib\n+ * @build IsSameFile jdk.test.lib.util.FileUtils\n+ * @run junit IsSameFile\n+ *\/\n+import java.io.IOException;\n+import java.io.FileOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+import jdk.test.lib.util.FileUtils;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.api.TestInstance.Lifecycle;\n+import org.junit.jupiter.api.condition.DisabledOnOs;\n+import org.junit.jupiter.api.condition.OS;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestInstance(Lifecycle.PER_CLASS)\n+public class IsSameFile {\n+    private Path home;\n+    private Path a;\n+    private Path aa;\n+    private Path b;\n+    private Path c;\n+    private List<Path> allFiles;\n+\n+    @BeforeAll\n+    public void init() throws IOException {\n+        home = Files.createTempDirectory(\"TestIsSameFile\");\n+\n+        allFiles = new ArrayList();\n+        allFiles.add(a = home.resolve(\"a\"));\n+        allFiles.add(aa = home.resolve(\"a\"));\n+        allFiles.add(b = home.resolve(\"b\"));\n+        allFiles.add(c = home.resolve(\"c\"));\n+    }\n+\n+    public void deleteFiles() throws IOException {\n+        for (Path p : allFiles)\n+            Files.deleteIfExists(p);\n+    }\n+\n+    @AfterAll\n+    public void deleteHome() throws IOException {\n+        TestUtil.removeAll(home);\n+    }\n+\n+    public void test(boolean expect, Path x, Path y) throws IOException {\n+        assertTrue(Files.isSameFile(x, y) == expect);\n+    }\n+\n+    private Stream<Arguments> stringCompareSource() throws IOException {\n+        deleteFiles();\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        Path x = Path.of(\"x\/y\/z\");\n+        list.add(Arguments.of(true, x, x));\n+        list.add(Arguments.of(false, Path.of(\"w\/x\/y\/z\"), x));\n+        Path y = Path.of(\"v\/w\/x\/..\/y\/z\");\n+        list.add(Arguments.of(false, y, Path.of(\"v\/w\/y\/z\")));\n+        list.add(Arguments.of(false, y, Path.of(\"v\/w\/x\/y\/..\/z\")));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"stringCompareSource\")\n+    public void stringCompare(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    private Stream<Arguments> noneExistSource() throws IOException {\n+        deleteFiles();\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(true, a, a));\n+        list.add(Arguments.of(true, a, aa));\n+        list.add(Arguments.of(false, a, b));\n+        list.add(Arguments.of(true, b, b));\n+        return list.stream();\n+    }\n+\n+    @Test\n+    public void obj2Null() {\n+        Path x = Path.of(\"x\/y\");\n+        assertThrows(NullPointerException.class, () -> Files.isSameFile(x, null));\n+    }\n+\n+    private static void zipStringToFile(String entry, String content,\n+                                        Path path)\n+        throws IOException\n+    {\n+        FileOutputStream fos = new FileOutputStream(path.toString());\n+        ZipOutputStream zos = new ZipOutputStream(fos);\n+\n+        ZipEntry zipEntry = new ZipEntry(entry);\n+        zos.putNextEntry(zipEntry);\n+        zos.write(content.getBytes());\n+\n+        zos.close();\n+        fos.close();\n+    }\n+\n+    private Stream<Arguments> obj2ZipSource() throws IOException {\n+        deleteFiles();\n+        Files.createFile(a);\n+        zipStringToFile(\"quote.txt\", \"To be determined\", b);\n+        FileSystem zipfs = FileSystems.newFileSystem(b);\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(false, a, zipfs.getPath(b.toString())));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"obj2ZipSource\")\n+    public void obj2Zip(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"noneExistSource\")\n+    public void noneExist(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    private Stream<Arguments> aExistsSource() throws IOException {\n+        deleteFiles();\n+        Files.createFile(a);\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(true, a, a));\n+        list.add(Arguments.of(true, a, aa));\n+        list.add(Arguments.of(false, a, b));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"aExistsSource\")\n+    public void aExists(boolean expect, Path x, Path y) throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    private Stream<Arguments> abExistSource() throws IOException {\n+        deleteFiles();\n+        Files.createFile(a);\n+        Files.createFile(b);\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(false, a, b));\n+        list.add(Arguments.of(true, b, b));\n+        list.add(Arguments.of(false, a, c));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"abExistSource\")\n+    public void abExist(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    private Stream<Arguments> abcExistSource() throws IOException {\n+        deleteFiles();\n+        Files.createFile(a);\n+        Files.createFile(b);\n+        Files.createSymbolicLink(c, a);\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(true, a, c));\n+        list.add(Arguments.of(false, a, b));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"abcExistSource\")\n+    public void abcExist(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    private Stream<Arguments> bcExistSource() throws IOException {\n+        deleteFiles();\n+        Files.createFile(b);\n+        Files.createSymbolicLink(c, a);\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(true, a, a));\n+        list.add(Arguments.of(true, a, aa));\n+        list.add(Arguments.of(false, a, b));\n+        list.add(Arguments.of(true, b, b));\n+        list.add(Arguments.of(false, a, c));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"bcExistSource\")\n+    public void bcExist(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    \/\/\n+    \/\/ L1 => L2 => target\n+    \/\/ L3 => L4 => target\n+    \/\/\n+    private Stream<Arguments> equalFollowingSource() throws IOException {\n+        deleteFiles();\n+        Path target = home.resolve(\"target\");\n+        Files.createFile(target);\n+        allFiles.add(target);\n+\n+        Path L2 = Path.of(\"link2\");\n+        Files.createSymbolicLink(L2, target);\n+        allFiles.add(L2);\n+\n+        Path L1 = Path.of(\"link1\");\n+        Files.createSymbolicLink(L1, L2);\n+        allFiles.add(L1);\n+\n+        Path L4 = Path.of(\"link4\");\n+        Files.createSymbolicLink(L4, target);\n+        allFiles.add(L4);\n+\n+        Path L3 = Path.of(\"link3\");\n+        Files.createSymbolicLink(L3, L4);\n+        allFiles.add(L3);\n+\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(true, L1, L3));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"equalFollowingSource\")\n+    public void equalFollowing(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    \/\/\n+    \/\/ L1 => L2 => target\n+    \/\/ L3 => L4 => cible\n+    \/\/\n+    private Stream<Arguments> unequalFollowingSource() throws IOException {\n+        deleteFiles();\n+        Path target = home.resolve(\"target\");\n+        Files.createFile(target);\n+        allFiles.add(target);\n+\n+        Path L2 = Path.of(\"link2\");\n+        Files.createSymbolicLink(L2, target);\n+        allFiles.add(L2);\n+\n+        Path L1 = Path.of(\"link1\");\n+        Files.createSymbolicLink(L1, L2);\n+        allFiles.add(L1);\n+\n+        Path cible = home.resolve(\"cible\");\n+        Files.createFile(cible);\n+        allFiles.add(cible);\n+\n+        Path L4 = Path.of(\"link4\");\n+        Files.createSymbolicLink(L4, cible);\n+        allFiles.add(L4);\n+\n+        Path L3 = Path.of(\"link3\");\n+        Files.createSymbolicLink(L3, L4);\n+        allFiles.add(L3);\n+\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(false, L1, L3));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"unequalFollowingSource\")\n+    public void unequalFollowing(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    \/\/\n+    \/\/ L1 => L2 => <does not exist>\n+    \/\/ L3 => L4 => <does not exist>\n+    \/\/\n+    private Stream<Arguments> unequalNotFollowingSource() throws IOException {\n+        deleteFiles();\n+\n+        Path doesNotExist = Path.of(\"doesNotExist\");\n+\n+        Path L2 = Path.of(\"link2\");\n+        Files.createSymbolicLink(L2, doesNotExist);\n+        allFiles.add(L2);\n+\n+        Path L1 = Path.of(\"link1\");\n+        Files.createSymbolicLink(L1, L2);\n+        allFiles.add(L1);\n+\n+        Path L4 = Path.of(\"link4\");\n+        Files.createSymbolicLink(L4, doesNotExist);\n+        allFiles.add(L4);\n+\n+        Path L3 = Path.of(\"link3\");\n+        Files.createSymbolicLink(L3, L4);\n+        allFiles.add(L3);\n+\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(false, L1, L3));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"unequalNotFollowingSource\")\n+    public void unequalNotFollowing(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    \/\/\n+    \/\/ L1 => L2 => L3 => L4 => target\n+    \/\/\n+    \/\/ isSameFile(LX,LY) should be true for all X, Y\n+    \/\/\n+    private Stream<Arguments> multiLinkSource() throws IOException {\n+        deleteFiles();\n+        Path target = home.resolve(\"target\");\n+        Files.createFile(target);\n+        allFiles.add(target);\n+        Path[] links = new Path[4];\n+        links[3] = Files.createSymbolicLink(Path.of(\"link4\"), target);\n+        allFiles.add(links[3]);\n+        for (int i = 3; i > 0; i--) {\n+            links[i-1] = Files.createSymbolicLink(Path.of(\"link\"+i), links[i]);\n+            allFiles.add(links[i-1]);\n+        }\n+\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        for (int i = 0; i < 4; i++) {\n+            list.add(Arguments.of(true, links[i], target));\n+            for (int j = i+1; j < 4; j++)\n+                list.add(Arguments.of(true, links[i], links[j]));\n+        }\n+\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"multiLinkSource\")\n+    public void multiLink(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    \/\/\n+    \/\/ L1 => L2 => L3 => L4 => <does not exist>\n+    \/\/\n+    \/\/ isSameFile(LX,LY) should be true for all X, Y\n+    \/\/\n+    private Stream<Arguments> multiLinkNoTargetSource() throws IOException {\n+        deleteFiles();\n+        Path target = home.resolve(\"target\");\n+        Files.createFile(target);\n+        allFiles.add(target);\n+        Path[] links = new Path[4];\n+        links[3] = Files.createSymbolicLink(Path.of(\"link4\"), target);\n+        allFiles.add(links[3]);\n+        Files.delete(target);\n+        allFiles.remove(target);\n+        for (int i = 3; i > 0; i--) {\n+            links[i-1] = Files.createSymbolicLink(Path.of(\"link\"+i), links[i]);\n+            allFiles.add(links[i-1]);\n+        }\n+\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        for (int i = 0; i < 4; i++) {\n+            list.add(Arguments.of(false, links[i], target));\n+            for (int j = i+1; j < 4; j++)\n+                list.add(Arguments.of(true, links[i], links[j]));\n+        }\n+\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"multiLinkNoTargetSource\")\n+    @DisabledOnOs(OS.WINDOWS)\n+    public void multiLinkNoTarget(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    \/\/\n+    \/\/ L1 -> L2 -> L3 -> L1...\n+    \/\/\n+    \/\/ This is a loop, but isSameFile(LX,LY) should be true for all X, Y\n+    \/\/\n+    private Stream<Arguments> linkLoopSource() throws IOException {\n+        deleteFiles();\n+\n+        Path link1 = home.resolve(\"L1\");\n+        Path link2 = home.resolve(\"L2\");\n+        Path link3 = home.resolve(\"L3\");\n+        allFiles.add(Files.createSymbolicLink(link1, link2));\n+        allFiles.add(Files.createSymbolicLink(link2, link3));\n+        allFiles.add(Files.createSymbolicLink(link3, link1));\n+\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(true, link1, link2));\n+        list.add(Arguments.of(true, link2, link3));\n+        list.add(Arguments.of(true, link3, link1));\n+\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"linkLoopSource\")\n+    @DisabledOnOs(OS.WINDOWS)\n+    public void linkLoop(boolean expect, Path x, Path y) throws IOException {\n+        test(expect, x, y);\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/Files\/IsSameFile.java","additions":458,"deletions":0,"binary":false,"changes":458,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4313887 6838333 8005566 8215467 8255576 8286160\n+ * @bug 4313887 6838333 8005566 8154364 8215467 8255576 8286160\n@@ -118,10 +118,2 @@\n-        try {\n-            isSameFile(thisFile, thatFile);\n-            throw new RuntimeException(\"IOException not thrown\");\n-        } catch (IOException x) {\n-        }\n-        try {\n-            isSameFile(thatFile, thisFile);\n-            throw new RuntimeException(\"IOException not thrown\");\n-        } catch (IOException x) {\n-        }\n+        assertTrue(!isSameFile(thisFile, thatFile));\n+        assertTrue(!isSameFile(thatFile, thisFile));\n@@ -134,10 +126,2 @@\n-            try {\n-                isSameFile(thisFile, thatFile);\n-                throw new RuntimeException(\"IOException not thrown\");\n-            } catch (IOException x) {\n-            }\n-            try {\n-                isSameFile(thatFile, thisFile);\n-                throw new RuntimeException(\"IOException not thrown\");\n-            } catch (IOException x) {\n-            }\n+            assertTrue(!isSameFile(thisFile, thatFile));\n+            assertTrue(!isSameFile(thatFile, thisFile));\n","filename":"test\/jdk\/java\/nio\/file\/Files\/Misc.java","additions":6,"deletions":22,"binary":false,"changes":28,"status":"modified"}]}