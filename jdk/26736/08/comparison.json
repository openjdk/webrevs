{"files":[{"patch":"@@ -84,2 +84,5 @@\n-    \/\/ get the UnixFileAttributes for a given file. Returns null if the file does not exist.\n-    static UnixFileAttributes getIfExists(UnixPath path) throws UnixException {\n+    \/\/ get the UnixFileAttributes for a given file.\n+    \/\/ Returns null if the file does not exist.\n+    static UnixFileAttributes getIfExists(UnixPath path)\n+        throws UnixException\n+    {\n@@ -97,0 +100,20 @@\n+    \/\/ get the UnixFileAttributes for a given file, optionally following links.\n+    \/\/ Returns null if the file does not exist.\n+    static UnixFileAttributes getIfExists(UnixPath path, boolean followLinks)\n+        throws UnixException\n+    {\n+        UnixFileAttributes attrs = new UnixFileAttributes();\n+        int flag = (followLinks) ? 0 : UnixConstants.AT_SYMLINK_NOFOLLOW;\n+        try {\n+            UnixNativeDispatcher.fstatat(UnixConstants.AT_FDCWD,\n+                                         path.asByteArray(), flag, attrs);\n+        } catch (UnixException x) {\n+            if (x.errno() == UnixConstants.ENOENT)\n+                return null;\n+\n+            throw x;\n+        }\n+\n+        return attrs;\n+    }\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileAttributes.java","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,1 @@\n+import java.util.HashSet;\n@@ -351,0 +352,23 @@\n+    \/\/ find the key of the last accessible link in the chain\n+    private UnixFileKey lastFileKey(UnixPath path) throws UnixException {\n+        var fileKeys = new HashSet<UnixFileKey>();\n+        UnixFileKey lastFileKey = null;\n+        while (path != null) {\n+            UnixFileAttributes attrs = UnixFileAttributes.getIfExists(path, false);\n+            if (attrs == null) {\n+                break;\n+            }\n+            UnixFileKey fileKey = attrs.fileKey();\n+            if (!attrs.isSymbolicLink()) {\n+                return fileKey;\n+            }\n+            if (!fileKeys.add(fileKey)) {\n+                throw new UnixException(ELOOP);\n+            }\n+            lastFileKey = fileKey;\n+            byte[] target = readlink(path);\n+            path = new UnixPath(theFileSystem, target);\n+        }\n+        return lastFileKey;\n+    }\n+\n@@ -353,0 +377,1 @@\n+        \/\/ toUnixPath verifies its argument is a non-null UnixPath\n@@ -361,2 +386,3 @@\n-        UnixFileAttributes attrs1;\n-        UnixFileAttributes attrs2;\n+        \/\/ try to retrieve attributes following links\n+        UnixFileAttributes attrs1 = null;\n+        UnixFileAttributes attrs2 = null;\n@@ -364,1 +390,2 @@\n-             attrs1 = UnixFileAttributes.get(file1, true);\n+            if ((attrs1 = UnixFileAttributes.getIfExists(file1)) != null)\n+                attrs2 = UnixFileAttributes.getIfExists(file2);\n@@ -366,1 +393,1 @@\n-            x.rethrowAsIOException(file1);\n+            x.rethrowAsIOException(file1, file2);\n@@ -369,0 +396,6 @@\n+\n+        if (attrs1 != null && attrs2 != null)\n+            \/\/ both exist, compare their device IDs and inode numbers\n+            return attrs1.isSameFile(attrs2);\n+\n+        \/\/ find the last link in each path and compare them\n@@ -370,1 +403,4 @@\n-            attrs2 = UnixFileAttributes.get(file2, true);\n+            UnixFileKey key1 = lastFileKey(file1);\n+            UnixFileKey key2 = lastFileKey(file2);\n+            if (key1 != null && key2 != null && key1.equals(key2))\n+                return true;\n@@ -372,1 +408,1 @@\n-            x.rethrowAsIOException(file2);\n+            x.rethrowAsIOException(file1, file2);\n@@ -375,1 +411,2 @@\n-        return attrs1.isSameFile(attrs2);\n+\n+        return false;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystemProvider.java","additions":45,"deletions":8,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -437,1 +437,3 @@\n-            x.rethrowAsIOException(file1);\n+            if (x.lastError() != ERROR_FILE_NOT_FOUND &&\n+                x.lastError() != ERROR_PATH_NOT_FOUND)\n+                x.rethrowAsIOException(file1);\n@@ -439,0 +441,5 @@\n+\n+        \/\/ if file1 does not exist, it cannot equal file2\n+        if (h1 == 0L)\n+            return false;\n+\n@@ -450,1 +457,3 @@\n-                x.rethrowAsIOException(file2);\n+                if (x.lastError() != ERROR_FILE_NOT_FOUND &&\n+                    x.lastError() != ERROR_PATH_NOT_FOUND)\n+                    x.rethrowAsIOException(file2);\n@@ -452,0 +461,5 @@\n+\n+            \/\/ if file2 does not exist, it cannot equal file1, which does\n+            if (h2 == 0L)\n+                return false;\n+\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileSystemProvider.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,456 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8154364\n+ * @summary Test of Files.isSameFile\n+ * @requires (os.family != \"windows\")\n+ * @library .. \/test\/lib\n+ * @build IsSameFile jdk.test.lib.util.FileUtils\n+ * @run junit IsSameFile\n+ *\/\n+import java.io.IOException;\n+import java.io.FileOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystemException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+import jdk.test.lib.util.FileUtils;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.api.TestInstance.Lifecycle;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestInstance(Lifecycle.PER_CLASS)\n+public class IsSameFile {\n+    private Path home;\n+    private Path a;\n+    private Path aa;\n+    private Path b;\n+    private Path c;\n+    private List<Path> allFiles;\n+\n+    @BeforeAll\n+    public void init() throws IOException {\n+        home = Files.createTempDirectory(\"TestIsSameFile\");\n+\n+        allFiles = new ArrayList();\n+        allFiles.add(a = home.resolve(\"a\"));\n+        allFiles.add(aa = home.resolve(\"a\"));\n+        allFiles.add(b = home.resolve(\"b\"));\n+        allFiles.add(c = home.resolve(\"c\"));\n+    }\n+\n+    public void deleteFiles() throws IOException {\n+        for (Path p : allFiles)\n+            Files.deleteIfExists(p);\n+    }\n+\n+    @AfterAll\n+    public void deleteHome() throws IOException {\n+        TestUtil.removeAll(home);\n+    }\n+\n+    public void test(boolean expect, Path x, Path y) throws IOException {\n+        assertTrue(Files.isSameFile(x, y) == expect);\n+    }\n+\n+    private Stream<Arguments> stringCompareSource() throws IOException {\n+        deleteFiles();\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        Path x = Path.of(\"x\/y\/z\");\n+        list.add(Arguments.of(true, x, x));\n+        list.add(Arguments.of(false, Path.of(\"w\/x\/y\/z\"), x));\n+        Path y = Path.of(\"v\/w\/x\/..\/y\/z\");\n+        list.add(Arguments.of(false, y, Path.of(\"v\/w\/y\/z\")));\n+        list.add(Arguments.of(false, y, Path.of(\"v\/w\/x\/y\/..\/z\")));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"stringCompareSource\")\n+    public void stringCompare(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    private Stream<Arguments> noneExistSource() throws IOException {\n+        deleteFiles();\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(true, a, a));\n+        list.add(Arguments.of(true, a, aa));\n+        list.add(Arguments.of(false, a, b));\n+        list.add(Arguments.of(true, b, b));\n+        return list.stream();\n+    }\n+\n+    @Test\n+    public void obj2Null() {\n+        Path x = Path.of(\"x\/y\");\n+        assertThrows(NullPointerException.class, () -> Files.isSameFile(x, null));\n+    }\n+\n+    private static void zipStringToFile(String entry, String content,\n+                                        Path path)\n+        throws IOException\n+    {\n+        FileOutputStream fos = new FileOutputStream(path.toString());\n+        ZipOutputStream zos = new ZipOutputStream(fos);\n+\n+        ZipEntry zipEntry = new ZipEntry(entry);\n+        zos.putNextEntry(zipEntry);\n+        zos.write(content.getBytes());\n+\n+        zos.close();\n+        fos.close();\n+    }\n+\n+    private Stream<Arguments> obj2ZipSource() throws IOException {\n+        deleteFiles();\n+        Files.createFile(a);\n+        zipStringToFile(\"quote.txt\", \"To be determined\", b);\n+        FileSystem zipfs = FileSystems.newFileSystem(b);\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(false, a, zipfs.getPath(b.toString())));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"obj2ZipSource\")\n+    public void obj2Zip(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"noneExistSource\")\n+    public void noneExist(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    private Stream<Arguments> aExistsSource() throws IOException {\n+        deleteFiles();\n+        Files.createFile(a);\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(true, a, a));\n+        list.add(Arguments.of(true, a, aa));\n+        list.add(Arguments.of(false, a, b));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"aExistsSource\")\n+    public void aExists(boolean expect, Path x, Path y) throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    private Stream<Arguments> abExistSource() throws IOException {\n+        deleteFiles();\n+        Files.createFile(a);\n+        Files.createFile(b);\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(false, a, b));\n+        list.add(Arguments.of(true, b, b));\n+        list.add(Arguments.of(false, a, c));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"abExistSource\")\n+    public void abExist(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    private Stream<Arguments> abcExistSource() throws IOException {\n+        deleteFiles();\n+        Files.createFile(a);\n+        Files.createFile(b);\n+        Files.createSymbolicLink(c, a);\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(true, a, c));\n+        list.add(Arguments.of(false, a, b));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"abcExistSource\")\n+    public void abcExist(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    private Stream<Arguments> bcExistSource() throws IOException {\n+        deleteFiles();\n+        Files.createFile(b);\n+        Files.createSymbolicLink(c, a);\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(true, a, a));\n+        list.add(Arguments.of(true, a, aa));\n+        list.add(Arguments.of(false, a, b));\n+        list.add(Arguments.of(true, b, b));\n+        list.add(Arguments.of(false, a, c));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"bcExistSource\")\n+    public void bcExist(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    \/\/\n+    \/\/ L1 => L2 => target\n+    \/\/ L3 => L4 => target\n+    \/\/\n+    private Stream<Arguments> equalFollowingSource() throws IOException {\n+        deleteFiles();\n+        Path target = home.resolve(\"target\");\n+        Files.createFile(target);\n+        allFiles.add(target);\n+\n+        Path L2 = Path.of(\"link2\");\n+        Files.createSymbolicLink(L2, target);\n+        allFiles.add(L2);\n+\n+        Path L1 = Path.of(\"link1\");\n+        Files.createSymbolicLink(L1, L2);\n+        allFiles.add(L1);\n+\n+        Path L4 = Path.of(\"link4\");\n+        Files.createSymbolicLink(L4, target);\n+        allFiles.add(L4);\n+\n+        Path L3 = Path.of(\"link3\");\n+        Files.createSymbolicLink(L3, L4);\n+        allFiles.add(L3);\n+\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(true, L1, L3));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"equalFollowingSource\")\n+    public void equalFollowing(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    \/\/\n+    \/\/ L1 => L2 => target\n+    \/\/ L3 => L4 => cible\n+    \/\/\n+    private Stream<Arguments> unequalFollowingSource() throws IOException {\n+        deleteFiles();\n+        Path target = home.resolve(\"target\");\n+        Files.createFile(target);\n+        allFiles.add(target);\n+\n+        Path L2 = Path.of(\"link2\");\n+        Files.createSymbolicLink(L2, target);\n+        allFiles.add(L2);\n+\n+        Path L1 = Path.of(\"link1\");\n+        Files.createSymbolicLink(L1, L2);\n+        allFiles.add(L1);\n+\n+        Path cible = home.resolve(\"cible\");\n+        Files.createFile(cible);\n+        allFiles.add(cible);\n+\n+        Path L4 = Path.of(\"link4\");\n+        Files.createSymbolicLink(L4, cible);\n+        allFiles.add(L4);\n+\n+        Path L3 = Path.of(\"link3\");\n+        Files.createSymbolicLink(L3, L4);\n+        allFiles.add(L3);\n+\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(false, L1, L3));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"unequalFollowingSource\")\n+    public void unequalFollowing(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    \/\/\n+    \/\/ L1 => L2 => <does not exist>\n+    \/\/ L3 => L4 => <does not exist>\n+    \/\/\n+    private Stream<Arguments> unequalNotFollowingSource() throws IOException {\n+        deleteFiles();\n+\n+        Path doesNotExist = Path.of(\"doesNotExist\");\n+\n+        Path L2 = Path.of(\"link2\");\n+        Files.createSymbolicLink(L2, doesNotExist);\n+        allFiles.add(L2);\n+\n+        Path L1 = Path.of(\"link1\");\n+        Files.createSymbolicLink(L1, L2);\n+        allFiles.add(L1);\n+\n+        Path L4 = Path.of(\"link4\");\n+        Files.createSymbolicLink(L4, doesNotExist);\n+        allFiles.add(L4);\n+\n+        Path L3 = Path.of(\"link3\");\n+        Files.createSymbolicLink(L3, L4);\n+        allFiles.add(L3);\n+\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(false, L1, L3));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"unequalNotFollowingSource\")\n+    public void unequalNotFollowing(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    \/\/\n+    \/\/ L1 => L2 => L3 => L4 => target\n+    \/\/\n+    \/\/ isSameFile(LX,LY) should be true for all X, Y\n+    \/\/\n+    private Stream<Arguments> multiLinkSource() throws IOException {\n+        deleteFiles();\n+        Path target = home.resolve(\"target\");\n+        Files.createFile(target);\n+        allFiles.add(target);\n+        Path[] links = new Path[4];\n+        links[3] = Files.createSymbolicLink(Path.of(\"link4\"), target);\n+        allFiles.add(links[3]);\n+        for (int i = 3; i > 0; i--) {\n+            links[i-1] = Files.createSymbolicLink(Path.of(\"link\"+i), links[i]);\n+            allFiles.add(links[i-1]);\n+        }\n+\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        for (int i = 0; i < 4; i++) {\n+            list.add(Arguments.of(true, links[i], target));\n+            for (int j = i+1; j < 4; j++)\n+                list.add(Arguments.of(true, links[i], links[j]));\n+        }\n+\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"multiLinkSource\")\n+    public void multiLink(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    \/\/\n+    \/\/ L1 => L2 => L3 => L4 => <does not exist>\n+    \/\/\n+    \/\/ isSameFile(LX,LY) should be true for all X, Y\n+    \/\/\n+    private Stream<Arguments> multiLinkNoTargetSource() throws IOException {\n+        deleteFiles();\n+        Path target = home.resolve(\"target\");\n+        Files.createFile(target);\n+        allFiles.add(target);\n+        Path[] links = new Path[4];\n+        links[3] = Files.createSymbolicLink(Path.of(\"link4\"), target);\n+        allFiles.add(links[3]);\n+        Files.delete(target);\n+        allFiles.remove(target);\n+        for (int i = 3; i > 0; i--) {\n+            links[i-1] = Files.createSymbolicLink(Path.of(\"link\"+i), links[i]);\n+            allFiles.add(links[i-1]);\n+        }\n+\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        for (int i = 0; i < 4; i++) {\n+            list.add(Arguments.of(false, links[i], target));\n+            for (int j = i+1; j < 4; j++)\n+                list.add(Arguments.of(true, links[i], links[j]));\n+        }\n+\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"multiLinkNoTargetSource\")\n+    public void multiLinkNoTarget(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    \/\/\n+    \/\/ L1 -> L2 -> L3 -> L1...\n+    \/\/\n+    \/\/ This is a loop and should throw FileSystemException.\n+    \/\/\n+    private Stream<Arguments> linkLoopSource() throws IOException {\n+        deleteFiles();\n+\n+        Path link1 = home.resolve(\"L1\");\n+        Path link2 = home.resolve(\"L2\");\n+        Path link3 = home.resolve(\"L3\");\n+        allFiles.add(Files.createSymbolicLink(link1, link2));\n+        allFiles.add(Files.createSymbolicLink(link2, link3));\n+        allFiles.add(Files.createSymbolicLink(link3, link1));\n+\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(true, link1, link2));\n+        list.add(Arguments.of(true, link2, link3));\n+        list.add(Arguments.of(true, link3, link1));\n+\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"linkLoopSource\")\n+    public void linkLoop(boolean expect, Path x, Path y) throws IOException {\n+        assertThrows(FileSystemException.class, () -> Files.isSameFile(x, y));\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/Files\/IsSameFile.java","additions":456,"deletions":0,"binary":false,"changes":456,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4313887 6838333 8005566 8215467 8255576 8286160\n+ * @bug 4313887 6838333 8005566 8154364 8215467 8255576 8286160\n@@ -116,1 +116,1 @@\n-         * Test: Neither files exist\n+         * Test: Neither file exists\n@@ -118,10 +118,2 @@\n-        try {\n-            isSameFile(thisFile, thatFile);\n-            throw new RuntimeException(\"IOException not thrown\");\n-        } catch (IOException x) {\n-        }\n-        try {\n-            isSameFile(thatFile, thisFile);\n-            throw new RuntimeException(\"IOException not thrown\");\n-        } catch (IOException x) {\n-        }\n+        assertTrue(!isSameFile(thisFile, thatFile));\n+        assertTrue(!isSameFile(thatFile, thisFile));\n@@ -134,10 +126,2 @@\n-            try {\n-                isSameFile(thisFile, thatFile);\n-                throw new RuntimeException(\"IOException not thrown\");\n-            } catch (IOException x) {\n-            }\n-            try {\n-                isSameFile(thatFile, thisFile);\n-                throw new RuntimeException(\"IOException not thrown\");\n-            } catch (IOException x) {\n-            }\n+            assertTrue(!isSameFile(thisFile, thatFile));\n+            assertTrue(!isSameFile(thatFile, thisFile));\n","filename":"test\/jdk\/java\/nio\/file\/Files\/Misc.java","additions":7,"deletions":23,"binary":false,"changes":30,"status":"modified"}]}