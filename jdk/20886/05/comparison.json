{"files":[{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -28,0 +29,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -30,0 +33,3 @@\n+import static jdk.internal.util.ModifiedUtf.putChar;\n+import static jdk.internal.util.ModifiedUtf.utfLen;\n+\n@@ -47,0 +53,2 @@\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n@@ -355,0 +363,1 @@\n+    @SuppressWarnings(\"deprecation\")\n@@ -357,7 +366,2 @@\n-        int utflen = strlen; \/\/ optimized for ASCII\n-\n-        for (int i = 0; i < strlen; i++) {\n-            int c = str.charAt(i);\n-            if (c >= 0x80 || c == 0)\n-                utflen += (c >= 0x800) ? 2 : 1;\n-        }\n+        int countNonZeroAscii = JLA.countNonZeroAscii(str);\n+        int utflen = utfLen(str, countNonZeroAscii);\n@@ -380,6 +384,2 @@\n-        int i = 0;\n-        for (i = 0; i < strlen; i++) { \/\/ optimized for initial run of ASCII\n-            int c = str.charAt(i);\n-            if (c >= 0x80 || c == 0) break;\n-            bytearr[count++] = (byte) c;\n-        }\n+        str.getBytes(0, countNonZeroAscii, bytearr, count);\n+        count += countNonZeroAscii;\n@@ -387,12 +387,2 @@\n-        for (; i < strlen; i++) {\n-            int c = str.charAt(i);\n-            if (c < 0x80 && c != 0) {\n-                bytearr[count++] = (byte) c;\n-            } else if (c >= 0x800) {\n-                bytearr[count++] = (byte) (0xE0 | ((c >> 12) & 0x0F));\n-                bytearr[count++] = (byte) (0x80 | ((c >>  6) & 0x3F));\n-                bytearr[count++] = (byte) (0x80 | ((c >>  0) & 0x3F));\n-            } else {\n-                bytearr[count++] = (byte) (0xC0 | ((c >>  6) & 0x1F));\n-                bytearr[count++] = (byte) (0x80 | ((c >>  0) & 0x3F));\n-            }\n+        for (int i = countNonZeroAscii; i < strlen;) {\n+            count = putChar(bytearr, count, str.charAt(i++));\n","filename":"src\/java.base\/share\/classes\/java\/io\/DataOutputStream.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -37,0 +38,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -39,0 +42,3 @@\n+import static jdk.internal.util.ModifiedUtf.putChar;\n+import static jdk.internal.util.ModifiedUtf.utfLen;\n+\n@@ -172,0 +178,1 @@\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n@@ -888,1 +895,1 @@\n-        bout.writeUTF(str);\n+        bout.writeUTFInternal(str, false);\n@@ -1320,8 +1327,1 @@\n-        long utflen = bout.getUTFLength(str);\n-        if (utflen <= 0xFFFF) {\n-            bout.writeByte(TC_STRING);\n-            bout.writeUTF(str, utflen);\n-        } else {\n-            bout.writeByte(TC_LONGSTRING);\n-            bout.writeLongUTF(str, utflen);\n-        }\n+        bout.writeUTFInternal(str, true);\n@@ -1997,11 +1997,12 @@\n-        public void writeBytes(String s) throws IOException {\n-            int endoff = s.length();\n-            int cpos = 0;\n-            int csize = 0;\n-            for (int off = 0; off < endoff; ) {\n-                if (cpos >= csize) {\n-                    cpos = 0;\n-                    csize = Math.min(endoff - off, CHAR_BUF_SIZE);\n-                    s.getChars(off, off + csize, cbuf, 0);\n-                }\n-                if (pos >= MAX_BLOCK_SIZE) {\n+        @SuppressWarnings(\"deprecation\")\n+        void writeBytes(String s, int len) throws IOException {\n+            int pos = this.pos;\n+            for (int strpos = 0; strpos < len;) {\n+                int rem = MAX_BLOCK_SIZE - pos;\n+                int csize = Math.min(len - strpos, rem);\n+                s.getBytes(strpos, strpos + csize, buf, pos);\n+                pos += csize;\n+                strpos += csize;\n+\n+                if (pos == MAX_BLOCK_SIZE) {\n+                    this.pos = pos;\n@@ -2009,0 +2010,1 @@\n+                    pos = 0;\n@@ -2010,6 +2012,0 @@\n-                int n = Math.min(csize - cpos, MAX_BLOCK_SIZE - pos);\n-                int stop = pos + n;\n-                while (pos < stop) {\n-                    buf[pos++] = (byte) cbuf[cpos++];\n-                }\n-                off += n;\n@@ -2017,0 +2013,5 @@\n+            this.pos = pos;\n+        }\n+\n+        public void writeBytes(String s) throws IOException {\n+            writeBytes(s, s.length());\n@@ -2029,2 +2030,41 @@\n-        public void writeUTF(String s) throws IOException {\n-            writeUTF(s, getUTFLength(s));\n+        public void writeUTF(String str) throws IOException {\n+            writeUTFInternal(str, false);\n+        }\n+\n+        private void writeUTFInternal(String str, boolean writeHeader) throws IOException {\n+            int strlen = str.length();\n+            int countNonZeroAscii = JLA.countNonZeroAscii(str);\n+            int utflen = utfLen(str, countNonZeroAscii);\n+            if (utflen <= 0xFFFF) {\n+                if(writeHeader) {\n+                    writeByte(TC_STRING);\n+                }\n+                writeShort(utflen);\n+            } else {\n+                if(writeHeader) {\n+                    writeByte(TC_LONGSTRING);\n+                }\n+                writeLong(utflen);\n+            }\n+\n+            if (countNonZeroAscii != 0) {\n+                writeBytes(str, countNonZeroAscii);\n+            }\n+            if (countNonZeroAscii != strlen) {\n+                writeMoreUTF(str, countNonZeroAscii);\n+            }\n+        }\n+\n+        private void writeMoreUTF(String str, int stroff) throws IOException {\n+            int pos = this.pos;\n+            for (int strlen = str.length(); stroff < strlen;) {\n+                char c = str.charAt(stroff++);\n+                int csize = c != 0 && c < 0x80 ? 1 : c >= 0x800 ? 3 : 2;\n+                if (pos + csize >= MAX_BLOCK_SIZE) {\n+                    this.pos = pos;\n+                    drain();\n+                    pos = 0;\n+                }\n+                pos = putChar(buf, pos, c);\n+            }\n+            this.pos = pos;\n@@ -2156,106 +2196,0 @@\n-\n-        \/**\n-         * Returns the length in bytes of the UTF encoding of the given string.\n-         *\/\n-        long getUTFLength(String s) {\n-            int len = s.length();\n-            long utflen = 0;\n-            for (int off = 0; off < len; ) {\n-                int csize = Math.min(len - off, CHAR_BUF_SIZE);\n-                s.getChars(off, off + csize, cbuf, 0);\n-                for (int cpos = 0; cpos < csize; cpos++) {\n-                    char c = cbuf[cpos];\n-                    if (c >= 0x0001 && c <= 0x007F) {\n-                        utflen++;\n-                    } else if (c > 0x07FF) {\n-                        utflen += 3;\n-                    } else {\n-                        utflen += 2;\n-                    }\n-                }\n-                off += csize;\n-            }\n-            return utflen;\n-        }\n-\n-        \/**\n-         * Writes the given string in UTF format.  This method is used in\n-         * situations where the UTF encoding length of the string is already\n-         * known; specifying it explicitly avoids a prescan of the string to\n-         * determine its UTF length.\n-         *\/\n-        void writeUTF(String s, long utflen) throws IOException {\n-            if (utflen > 0xFFFFL) {\n-                throw new UTFDataFormatException();\n-            }\n-            writeShort((int) utflen);\n-            if (utflen == (long) s.length()) {\n-                writeBytes(s);\n-            } else {\n-                writeUTFBody(s);\n-            }\n-        }\n-\n-        \/**\n-         * Writes given string in \"long\" UTF format.  \"Long\" UTF format is\n-         * identical to standard UTF, except that it uses an 8 byte header\n-         * (instead of the standard 2 bytes) to convey the UTF encoding length.\n-         *\/\n-        void writeLongUTF(String s) throws IOException {\n-            writeLongUTF(s, getUTFLength(s));\n-        }\n-\n-        \/**\n-         * Writes given string in \"long\" UTF format, where the UTF encoding\n-         * length of the string is already known.\n-         *\/\n-        void writeLongUTF(String s, long utflen) throws IOException {\n-            writeLong(utflen);\n-            if (utflen == (long) s.length()) {\n-                writeBytes(s);\n-            } else {\n-                writeUTFBody(s);\n-            }\n-        }\n-\n-        \/**\n-         * Writes the \"body\" (i.e., the UTF representation minus the 2-byte or\n-         * 8-byte length header) of the UTF encoding for the given string.\n-         *\/\n-        private void writeUTFBody(String s) throws IOException {\n-            int limit = MAX_BLOCK_SIZE - 3;\n-            int len = s.length();\n-            for (int off = 0; off < len; ) {\n-                int csize = Math.min(len - off, CHAR_BUF_SIZE);\n-                s.getChars(off, off + csize, cbuf, 0);\n-                for (int cpos = 0; cpos < csize; cpos++) {\n-                    char c = cbuf[cpos];\n-                    if (pos <= limit) {\n-                        if (c <= 0x007F && c != 0) {\n-                            buf[pos++] = (byte) c;\n-                        } else if (c > 0x07FF) {\n-                            buf[pos + 2] = (byte) (0x80 | ((c >> 0) & 0x3F));\n-                            buf[pos + 1] = (byte) (0x80 | ((c >> 6) & 0x3F));\n-                            buf[pos + 0] = (byte) (0xE0 | ((c >> 12) & 0x0F));\n-                            pos += 3;\n-                        } else {\n-                            buf[pos + 1] = (byte) (0x80 | ((c >> 0) & 0x3F));\n-                            buf[pos + 0] = (byte) (0xC0 | ((c >> 6) & 0x1F));\n-                            pos += 2;\n-                        }\n-                    } else {    \/\/ write one byte at a time to normalize block\n-                        if (c <= 0x007F && c != 0) {\n-                            write(c);\n-                        } else if (c > 0x07FF) {\n-                            write(0xE0 | ((c >> 12) & 0x0F));\n-                            write(0x80 | ((c >> 6) & 0x3F));\n-                            write(0x80 | ((c >> 0) & 0x3F));\n-                        } else {\n-                            write(0xC0 | ((c >> 6) & 0x1F));\n-                            write(0x80 | ((c >> 0) & 0x3F));\n-                        }\n-                    }\n-                }\n-                off += csize;\n-            }\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":68,"deletions":134,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -41,0 +41,3 @@\n+import static jdk.internal.util.ModifiedUtf.putChar;\n+import static jdk.internal.util.ModifiedUtf.utfLen;\n+\n@@ -164,8 +167,1 @@\n-        int utflen = strlen;\n-        if (countNonZeroAscii != strlen) {\n-            for (int i = countNonZeroAscii; i < strlen; i++) {\n-                int c = str.charAt(i);\n-                if (c >= 0x80 || c == 0)\n-                    utflen += (c >= 0x800) ? 2 : 1;\n-            }\n-        }\n+        int utflen = utfLen(str, countNonZeroAscii);\n@@ -187,14 +183,2 @@\n-        for (int i = countNonZeroAscii; i < strlen; ++i) {\n-            char c = str.charAt(i);\n-            if (c >= '\\001' && c <= '\\177') {\n-                elems[offset++] = (byte) c;\n-            } else if (c > '\\u07FF') {\n-                elems[offset    ] = (byte) (0xE0 | c >> 12 & 0xF);\n-                elems[offset + 1] = (byte) (0x80 | c >> 6 & 0x3F);\n-                elems[offset + 2] = (byte) (0x80 | c      & 0x3F);\n-                offset += 3;\n-            } else {\n-                elems[offset    ] = (byte) (0xC0 | c >> 6 & 0x1F);\n-                elems[offset + 1] = (byte) (0x80 | c      & 0x3F);\n-                offset += 2;\n-            }\n+        for (int i = countNonZeroAscii; i < strlen; i++) {\n+            offset = putChar(elems, offset, str.charAt(i));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":6,"deletions":22,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.util;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/**\n+ * Helper to JDK UTF putChar and Calculate length\n+ *\n+ * @since 24\n+ *\/\n+public abstract class ModifiedUtf {\n+    private ModifiedUtf() {\n+    }\n+\n+    @ForceInline\n+    public static int putChar(byte[] buf, int offset, char c) {\n+        if (c != 0 && c < 0x80) {\n+            buf[offset++] = (byte) c;\n+        } else if (c >= 0x800) {\n+            buf[offset    ] = (byte) (0xE0 | c >> 12 & 0x0F);\n+            buf[offset + 1] = (byte) (0x80 | c >> 6  & 0x3F);\n+            buf[offset + 2] = (byte) (0x80 | c       & 0x3F);\n+            offset += 3;\n+        } else {\n+            buf[offset    ] = (byte) (0xC0 | c >> 6 & 0x1F);\n+            buf[offset + 1] = (byte) (0x80 | c      & 0x3F);\n+            offset += 2;\n+        }\n+        return offset;\n+    }\n+\n+    \/**\n+     * Calculate the utf length of a string\n+     * @param str input string\n+     * @param countNonZeroAscii the number of non-zero ascii characters in the prefix calculated by JLA.countNonZeroAscii(str)\n+     *\/\n+    @ForceInline\n+    public static int utfLen(String str, int countNonZeroAscii) {\n+        int utflen = str.length();\n+        for (int i = utflen - 1; i >= countNonZeroAscii; i--) {\n+            int c = str.charAt(i);\n+            if (c >= 0x80 || c == 0)\n+                utflen += (c >= 0x800) ? 2 : 1;\n+        }\n+        return utflen;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ModifiedUtf.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.io;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.io.*;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HexFormat;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@Fork(2)\n+@Measurement(iterations = 6, time = 1)\n+@Warmup(iterations = 4, time = 2)\n+@State(Scope.Thread)\n+public class DataOutputStreamBench {\n+\n+    @Param({\"ascii\", \"utf8_2_bytes\", \"utf8_3_bytes\", \"emoji\"})\n+    public String charType;\n+\n+    ByteArrayOutputStream bytesOutput;\n+    DataOutputStream dataOutput;\n+    ObjectOutputStream objectOutput;\n+    String[] strings;\n+\n+    @Setup(Level.Trial)\n+    public void setup() throws Exception {\n+        byte[] bytes = HexFormat.of().parseHex(\n+                switch (charType) {\n+                    case \"ascii\"        -> \"78\";\n+                    case \"utf8_2_bytes\" -> \"c2a9\";\n+                    case \"utf8_3_bytes\" -> \"e6b8a9\";\n+                    case \"emoji\"        -> \"e29da3efb88f\";\n+                    default -> throw new IllegalArgumentException(\"bad charType: \" + charType);\n+                }\n+        );\n+        String s = new String(bytes, 0, bytes.length, StandardCharsets.UTF_8);\n+        strings = new String[128];\n+        for (int i = 0; i < strings.length; i++) {\n+            strings[i] = \"A\".repeat(i).concat(s.repeat(i));\n+        }\n+\n+        bytesOutput = new ByteArrayOutputStream(1024 * 64);\n+        dataOutput = new DataOutputStream(bytesOutput);\n+        objectOutput = new ObjectOutputStream(bytesOutput);\n+    }\n+\n+    @Benchmark\n+    public void dataOutwriteUTF(Blackhole bh) throws Exception {\n+        bytesOutput.reset();\n+        for (var s : strings) {\n+            dataOutput.writeUTF(s);\n+        }\n+        dataOutput.flush();\n+        bh.consume(bytesOutput.size());\n+    }\n+\n+    @Benchmark\n+    public void objectWriteUTF(Blackhole bh) throws Exception {\n+        bytesOutput.reset();\n+        for (var s : strings) {\n+            objectOutput.writeUTF(s);\n+        }\n+        objectOutput.flush();\n+        bh.consume(bytesOutput.size());\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/io\/DataOutputStreamBench.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"}]}