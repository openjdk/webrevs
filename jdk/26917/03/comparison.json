{"files":[{"patch":"@@ -6206,2 +6206,0 @@\n-  RuntimeAddress zero_blocks = RuntimeAddress(StubRoutines::aarch64::zero_blocks());\n-  assert(zero_blocks.target() != nullptr, \"zero_blocks stub has not been generated\");\n@@ -6235,2 +6233,4 @@\n-  \/\/ We have a few words left to do. zero_blocks has adjusted r10 and r11\n-  \/\/ for us.\n+  \/\/ A few words remain to complete.\n+  \/\/ The zero_blocks routine has already performed the necessary\n+  \/\/ adjustments to r10 and r11, ensuring they are correctly set\n+  \/\/ for subsequent processing.\n@@ -6262,2 +6262,1 @@\n-  assert(wordSize <= BlockZeroingLowLimit,\n-            \"increase BlockZeroingLowLimit\");\n+  assert(wordSize <= BlockZeroingLowLimit, \"increase BlockZeroingLowLimit\");\n@@ -6265,1 +6264,9 @@\n-  if (cnt <= (uint64_t)BlockZeroingLowLimit \/ BytesPerWord) {\n+  \/\/ We do not check UseBlockZeroing here because this is delegated to the\n+  \/\/ zero_blocks stub function that wraps the core logic of zero_words\n+  \/\/ and necessary unrolled str\/stp expanding when the condition is not met.\n+  \/\/ This approach also helps prevent sudden increases in code cache size\n+  \/\/ when zeroing large memory areas in many places.\n+  if (cnt > (uint64_t)BlockZeroingLowLimit \/ BytesPerWord) {\n+    mov(r10, base); mov(r11, cnt);\n+    result = zero_words(r10, r11);\n+  } else {\n@@ -6273,2 +6280,5 @@\n-    if (cnt >= 16) {\n-      uint64_t loops = cnt\/16;\n+    \/\/ Use 16 words as the block size which is 128 bytes on 64-bit systems.\n+    \/\/ A complete loop body will be 8 STPs unrolled there.\n+    const int block_size = 16;\n+    if (cnt >= block_size) {\n+      uint64_t loops = cnt\/block_size;\n@@ -6281,1 +6291,1 @@\n-        for (int i = 0; i < 16; i += 2) {\n+        for (int i = 0; i < block_size; i += 2) {\n@@ -6284,1 +6294,1 @@\n-        add(base, base, 16 * BytesPerWord);\n+        add(base, base, block_size * BytesPerWord);\n@@ -6291,1 +6301,1 @@\n-    cnt %= 16;\n+    cnt %= block_size;\n@@ -6299,3 +6309,0 @@\n-  } else {\n-    mov(r10, base); mov(r11, cnt);\n-    result = zero_words(r10, r11);\n@@ -6303,0 +6310,1 @@\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":23,"deletions":15,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -692,3 +692,4 @@\n-      \/\/ Number of stp instructions we'll unroll\n-      const int unroll =\n-        MacroAssembler::zero_words_block_size \/ 2;\n+      \/\/ Process words with length exceeding the predefined\n+      \/\/ block size threshold. The loop body will be unrolled based on\n+      \/\/ the number of STPs calculated below.\n+      const int unroll = MacroAssembler::zero_words_block_size \/ 2;\n@@ -713,1 +714,0 @@\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -456,0 +456,4 @@\n+  if (!UseBlockZeroing && !FLAG_IS_DEFAULT(BlockZeroingLowLimit)) {\n+    warning(\"BlockZeroingLowLimit has been ignored because UseBlockZeroing is disabled\");\n+    FLAG_SET_DEFAULT(BlockZeroingLowLimit, is_zva_enabled() ? (4 * VM_Version::zva_length()) : 256);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+\n+import org.openjdk.bench.vm.gc.RawAllocationRate.BaseClass;\n@@ -40,1 +42,1 @@\n-    @Param({\"32\", \"64\", \"256\", \"1024\", \"2048\", \"4096\", \"8192\", \"16384\", \"65536\", \"131072\"})  \/\/ Object size in bytes.\n+    @Param({\"32\", \"48\", \"64\", \"80\", \"96\", \"128\", \"256\", \"1024\", \"2048\", \"4096\", \"8192\", \"16384\", \"65536\", \"131072\"})  \/\/ Object size in bytes.\n@@ -116,1 +118,0 @@\n-\n@@ -121,0 +122,6 @@\n+    static class Class48 extends BaseClass {\n+       long i0;\n+       long i1;\n+       long i2;\n+       long i3;\n+    }\n@@ -129,0 +136,38 @@\n+    static class Class80 extends BaseClass {\n+       long i0;\n+       long i1;\n+       long i2;\n+       long i3;\n+       long i4;\n+       long i5;\n+       long i6;\n+       long i7;\n+    }\n+    static class Class96 extends BaseClass {\n+       long i0;\n+       long i1;\n+       long i2;\n+       long i3;\n+       long i4;\n+       long i5;\n+       long i6;\n+       long i7;\n+       long i8;\n+       long i9;\n+    }\n+    static class Class128 extends BaseClass {\n+       long i0;\n+       long i1;\n+       long i2;\n+       long i3;\n+       long i4;\n+       long i5;\n+       long i6;\n+       long i7;\n+       long i8;\n+       long i9;\n+       long i10;\n+       long i11;\n+       long i12;\n+       long i13;\n+    }\n@@ -28710,0 +28755,2 @@\n+        case 48:\n+            return new Class48();\n@@ -28712,0 +28759,6 @@\n+        case 80:\n+            return new Class80();\n+        case 96:\n+            return new Class96();\n+        case 128:\n+            return new Class128();\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/RawAllocationRate.java","additions":55,"deletions":2,"binary":false,"changes":57,"status":"modified"}]}