{"files":[{"patch":"@@ -6202,2 +6202,0 @@\n-  assert(is_power_of_2(zero_words_block_size), \"adjust this\");\n-\n@@ -6205,0 +6203,1 @@\n+  assert(is_power_of_2(zero_words_block_size), \"adjust this\");\n@@ -6206,2 +6205,0 @@\n-  RuntimeAddress zero_blocks = RuntimeAddress(StubRoutines::aarch64::zero_blocks());\n-  assert(zero_blocks.target() != nullptr, \"zero_blocks stub has not been generated\");\n@@ -6212,1 +6209,3 @@\n-  {\n+\n+  if (UseBlockZeroing) {\n+    \/\/ Try to zero blocks using DC ZVA if allowed.\n@@ -6215,4 +6214,4 @@\n-    \/\/ Make sure this is a C2 compilation. C1 allocates space only for\n-    \/\/ trampoline stubs generated by Call LIR ops, and in any case it\n-    \/\/ makes sense for a C1 compilation task to proceed as quickly as\n-    \/\/ possible.\n+    \/\/ Ensure that this is a C2 compilation.\n+    \/\/ The C1 compiler allocates space solely for trampoline stubs generated\n+    \/\/ by Call LIR operations, and in any case, it is preferable\n+    \/\/ for a C1 compilation task to complete as quickly as possible.\n@@ -6233,0 +6232,15 @@\n+\n+  \/\/ Process words with length exceeding the predefined block size threshold.\n+  \/\/ The loop body will be unrolled based on the number of STP instructions calculated below.\n+  const int unroll = zero_words_block_size \/ 2;\n+  Label done, loop;\n+  subs(cnt, cnt, unroll * 2);\n+  br(Assembler::LT, done);\n+  bind(loop);\n+  for (int i = 0; i < unroll; i++)\n+    stp(zr, zr, post(ptr, 16));\n+  subs(cnt, cnt, unroll * 2);\n+  br(Assembler::GE, loop);\n+  bind(done);\n+  add(cnt, cnt, unroll * 2);\n+\n@@ -6235,2 +6249,4 @@\n-  \/\/ We have a few words left to do. zero_blocks has adjusted r10 and r11\n-  \/\/ for us.\n+  \/\/ A few words remain to complete.\n+  \/\/ If called, the zero_blocks routine has already performed the necessary\n+  \/\/ adjustments to registers r10 and r11, ensuring they are correctly set\n+  \/\/ for subsequent processing.\n@@ -6262,2 +6278,1 @@\n-  assert(wordSize <= BlockZeroingLowLimit,\n-            \"increase BlockZeroingLowLimit\");\n+  assert(wordSize <= BlockZeroingLowLimit, \"increase BlockZeroingLowLimit\");\n@@ -6265,1 +6280,4 @@\n-  if (cnt <= (uint64_t)BlockZeroingLowLimit \/ BytesPerWord) {\n+  if (UseBlockZeroing && cnt > (uint64_t)BlockZeroingLowLimit \/ BytesPerWord) {\n+    mov(r10, base); mov(r11, cnt);\n+    result = zero_words(r10, r11);\n+  } else {\n@@ -6273,2 +6291,3 @@\n-    if (cnt >= 16) {\n-      uint64_t loops = cnt\/16;\n+    const int block_size = 16;\n+    if (cnt >= block_size) {\n+      uint64_t loops = cnt\/block_size;\n@@ -6281,1 +6300,1 @@\n-        for (int i = 0; i < 16; i += 2) {\n+        for (int i = 0; i < block_size; i += 2) {\n@@ -6284,1 +6303,1 @@\n-        add(base, base, 16 * BytesPerWord);\n+        add(base, base, block_size * BytesPerWord);\n@@ -6291,1 +6310,1 @@\n-    cnt %= 16;\n+    cnt %= block_size;\n@@ -6299,3 +6318,0 @@\n-  } else {\n-    mov(r10, base); mov(r11, cnt);\n-    result = zero_words(r10, r11);\n@@ -6303,0 +6319,1 @@\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":39,"deletions":22,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -645,3 +645,3 @@\n-  \/\/ The inner part of zero_words().  This is the bulk operation,\n-  \/\/ zeroing words in blocks, possibly using DC ZVA to do it.  The\n-  \/\/ caller is responsible for zeroing the last few words.\n+  \/\/ The inner part of zero_words(). This is the bulk operation,\n+  \/\/ zeroing words in blocks, using DC ZVA.\n+  \/\/ The caller is responsible for zeroing the last few words.\n@@ -656,2 +656,1 @@\n-  \/\/      r11 < MacroAssembler::zero_words_block_size.\n-\n+  \/\/      r11 < MAX2(zva_length * 2, (int)BlockZeroingLowLimit)\n@@ -659,1 +658,0 @@\n-    Label done;\n@@ -669,21 +667,1 @@\n-    if (UseBlockZeroing) {\n-      int zva_length = VM_Version::zva_length();\n-\n-      \/\/ Ensure ZVA length can be divided by 16. This is required by\n-      \/\/ the subsequent operations.\n-      assert (zva_length % 16 == 0, \"Unexpected ZVA Length\");\n-\n-      __ tbz(base, 3, base_aligned);\n-      __ str(zr, Address(__ post(base, 8)));\n-      __ sub(cnt, cnt, 1);\n-      __ bind(base_aligned);\n-\n-      \/\/ Ensure count >= zva_length * 2 so that it still deserves a zva after\n-      \/\/ alignment.\n-      Label small;\n-      int low_limit = MAX2(zva_length * 2, (int)BlockZeroingLowLimit);\n-      __ subs(rscratch1, cnt, low_limit >> 3);\n-      __ br(Assembler::LT, small);\n-      __ zero_dcache_blocks(base, cnt);\n-      __ bind(small);\n-    }\n+    assert (UseBlockZeroing, \"only work when UseBlockZeroing is true\");\n@@ -691,16 +669,19 @@\n-    {\n-      \/\/ Number of stp instructions we'll unroll\n-      const int unroll =\n-        MacroAssembler::zero_words_block_size \/ 2;\n-      \/\/ Clear the remaining blocks.\n-      Label loop;\n-      __ subs(cnt, cnt, unroll * 2);\n-      __ br(Assembler::LT, done);\n-      __ bind(loop);\n-      for (int i = 0; i < unroll; i++)\n-        __ stp(zr, zr, __ post(base, 16));\n-      __ subs(cnt, cnt, unroll * 2);\n-      __ br(Assembler::GE, loop);\n-      __ bind(done);\n-      __ add(cnt, cnt, unroll * 2);\n-    }\n+    int zva_length = VM_Version::zva_length();\n+\n+    \/\/ Ensure ZVA length can be divided by 16. This is required by\n+    \/\/ the subsequent operations.\n+    assert (zva_length % 16 == 0, \"Unexpected ZVA Length\");\n+\n+    __ tbz(base, 3, base_aligned);\n+    __ str(zr, Address(__ post(base, 8)));\n+    __ sub(cnt, cnt, 1);\n+    __ bind(base_aligned);\n+\n+    \/\/ Ensure count >= zva_length * 2 so that it still deserves a zva after\n+    \/\/ alignment.\n+    Label small;\n+    int low_limit = MAX2(zva_length * 2, (int)BlockZeroingLowLimit);\n+    __ subs(rscratch1, cnt, low_limit >> 3);\n+    __ br(Assembler::LT, small);\n+    __ zero_dcache_blocks(base, cnt);\n+    __ bind(small);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":24,"deletions":43,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -456,0 +456,3 @@\n+  if (!UseBlockZeroing && !FLAG_IS_DEFAULT(BlockZeroingLowLimit)) {\n+    warning(\"BlockZeroingLowLimit will not work when UseBlockZeroing is false\");\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+\n+import org.openjdk.bench.vm.gc.RawAllocationRate.BaseClass;\n@@ -40,1 +42,1 @@\n-    @Param({\"32\", \"64\", \"256\", \"1024\", \"2048\", \"4096\", \"8192\", \"16384\", \"65536\", \"131072\"})  \/\/ Object size in bytes.\n+    @Param({\"32\", \"48\", \"64\", \"80\", \"96\", \"128\", \"256\", \"1024\", \"2048\", \"4096\", \"8192\", \"16384\", \"65536\", \"131072\"})  \/\/ Object size in bytes.\n@@ -116,1 +118,0 @@\n-\n@@ -121,0 +122,6 @@\n+    static class Class48 extends BaseClass {\n+       long i0;\n+       long i1;\n+       long i2;\n+       long i3;\n+    }\n@@ -129,0 +136,38 @@\n+    static class Class80 extends BaseClass {\n+       long i0;\n+       long i1;\n+       long i2;\n+       long i3;\n+       long i4;\n+       long i5;\n+       long i6;\n+       long i7;\n+    }\n+    static class Class96 extends BaseClass {\n+       long i0;\n+       long i1;\n+       long i2;\n+       long i3;\n+       long i4;\n+       long i5;\n+       long i6;\n+       long i7;\n+       long i8;\n+       long i9;\n+    }\n+    static class Class128 extends BaseClass {\n+       long i0;\n+       long i1;\n+       long i2;\n+       long i3;\n+       long i4;\n+       long i5;\n+       long i6;\n+       long i7;\n+       long i8;\n+       long i9;\n+       long i10;\n+       long i11;\n+       long i12;\n+       long i13;\n+    }\n@@ -28710,0 +28755,2 @@\n+        case 48:\n+            return new Class48();\n@@ -28712,0 +28759,6 @@\n+        case 80:\n+            return new Class80();\n+        case 96:\n+            return new Class96();\n+        case 128:\n+            return new Class128();\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/RawAllocationRate.java","additions":55,"deletions":2,"binary":false,"changes":57,"status":"modified"}]}