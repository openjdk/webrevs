{"files":[{"patch":"@@ -6206,2 +6206,0 @@\n-  RuntimeAddress zero_blocks = RuntimeAddress(StubRoutines::aarch64::zero_blocks());\n-  assert(zero_blocks.target() != nullptr, \"zero_blocks stub has not been generated\");\n@@ -6235,2 +6233,4 @@\n-  \/\/ We have a few words left to do. zero_blocks has adjusted r10 and r11\n-  \/\/ for us.\n+  \/\/ A few words remain to complete.\n+  \/\/ The zero_blocks routine has already performed the necessary\n+  \/\/ adjustments to r10 and r11, ensuring they are correctly set\n+  \/\/ for subsequent processing.\n@@ -6262,2 +6262,1 @@\n-  assert(wordSize <= BlockZeroingLowLimit,\n-            \"increase BlockZeroingLowLimit\");\n+  assert(wordSize <= BlockZeroingLowLimit, \"increase BlockZeroingLowLimit\");\n@@ -6265,1 +6264,9 @@\n-  if (cnt <= (uint64_t)BlockZeroingLowLimit \/ BytesPerWord) {\n+  \/\/ We do not check UseBlockZeroing here because this is delegated to the\n+  \/\/ zero_blocks stub function that wraps the core logic of zero_words\n+  \/\/ and necessary unrolled str\/stp expanding when the condition is not met.\n+  \/\/ This approach also helps prevent sudden increases in code cache size\n+  \/\/ when zeroing large memory areas in many places.\n+  if (cnt > (uint64_t)BlockZeroingLowLimit \/ BytesPerWord) {\n+    mov(r10, base); mov(r11, cnt);\n+    result = zero_words(r10, r11);\n+  } else {\n@@ -6273,2 +6280,5 @@\n-    if (cnt >= 16) {\n-      uint64_t loops = cnt\/16;\n+    \/\/ Use 16 words as the block size which is 128 bytes on 64-bit systems.\n+    \/\/ A complete loop body will be 8 STPs unrolled there.\n+    const int block_size = 16;\n+    if (cnt >= block_size) {\n+      uint64_t loops = cnt\/block_size;\n@@ -6281,1 +6291,1 @@\n-        for (int i = 0; i < 16; i += 2) {\n+        for (int i = 0; i < block_size; i += 2) {\n@@ -6284,1 +6294,1 @@\n-        add(base, base, 16 * BytesPerWord);\n+        add(base, base, block_size * BytesPerWord);\n@@ -6291,1 +6301,1 @@\n-    cnt %= 16;\n+    cnt %= block_size;\n@@ -6299,3 +6309,0 @@\n-  } else {\n-    mov(r10, base); mov(r11, cnt);\n-    result = zero_words(r10, r11);\n@@ -6303,0 +6310,1 @@\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":23,"deletions":15,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -692,3 +692,4 @@\n-      \/\/ Number of stp instructions we'll unroll\n-      const int unroll =\n-        MacroAssembler::zero_words_block_size \/ 2;\n+      \/\/ Process words with length exceeding the predefined\n+      \/\/ block size threshold. The loop body will be unrolled based on\n+      \/\/ the number of STPs calculated below.\n+      const int unroll = MacroAssembler::zero_words_block_size \/ 2;\n@@ -713,1 +714,0 @@\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -456,0 +456,4 @@\n+  if (!UseBlockZeroing && !FLAG_IS_DEFAULT(BlockZeroingLowLimit)) {\n+    warning(\"BlockZeroingLowLimit has been ignored because UseBlockZeroing is disabled\");\n+    FLAG_SET_DEFAULT(BlockZeroingLowLimit, is_zva_enabled() ? (4 * VM_Version::zva_length()) : 256);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"compiler\/disassembler.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"unittest.hpp\"\n+\n+#if defined(AARCH64) && !defined(ZERO)\n+#include <chrono>\n+\n+static void dump_code(address start, address end) {\n+  stringStream sstream;\n+  Disassembler::decode(start, end, &sstream);\n+  printf(\"%s\\n\", sstream.as_string());\n+}\n+\n+class MacroAssemblerZeroWordsTest : public ::testing::Test {\n+public:\n+  MacroAssemblerZeroWordsTest() { }\n+  ~MacroAssemblerZeroWordsTest() { }\n+\n+  \/\/ Measure wall time of MacroAssembler::zero_words for different sizes.\n+  \/\/ Sizes are count of words for clearing and could be:\n+  \/\/ 4 for 32B ( 32B \/ 8B-per-word = 4 words)\n+  \/\/ 16 for 128B (128B \/ 8B-per-word = 16 words)\n+  \/\/ 64 for 512B (512B \/ 8B-per-word = 64 words)\n+  static void benchmark_zero_words(uint clear_words_count) {\n+    BufferBlob* blob = BufferBlob::create(\"zero_words_test\", 200000);\n+    CodeBuffer code(blob);\n+    MacroAssembler _masm(&code);\n+\n+    const size_t call_count = 1000;\n+    const size_t word_count = clear_words_count;\n+    uint64_t* buffer = new uint64_t[word_count];\n+    Register base = r10;\n+    uint64_t cnt = word_count;\n+    \/\/ Set up base register to point to buffer\n+    _masm.mov(base, (uintptr_t)buffer);\n+\n+    _masm.zero_words(base, cnt);\n+    dump_code(code.insts()->start(), code.insts()->end());\n+\n+    auto start = std::chrono::steady_clock::now();\n+    for (size_t i = 0; i < call_count; ++i) {\n+        _masm.zero_words(base, cnt);\n+    }\n+    auto end = std::chrono::steady_clock::now();\n+\n+    auto wall_time_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n+    printf(\"MacroAssemblerZeroWordsTest zero_words wall time (ns): %ld\\n\", wall_time_ns \/ call_count);\n+\n+    delete[] buffer;\n+    BufferBlob::free(blob);\n+  }\n+};\n+\n+\/\/ If necessary, UseBlockZeroing should be configured during JVM initialization.\n+\/\/ However, here it is not required to specify it explicitly via TEST_VM_OPTS\n+\/\/ because MacroAssembler::zero_words does not check the UseBlockZeroing flag.\n+\/\/ In contrast, the stub functions for AArch64, such as generate_zero_blocks, do perform this check.\n+\n+TEST_VM_F(MacroAssemblerZeroWordsTest, UseBZ_clear_32B_with_lowlimit_8B) {\n+  FLAG_SET_CMDLINE(BlockZeroingLowLimit, 8);\n+  benchmark_zero_words(4); \/\/ 32B\n+}\n+\/\/ JDK-8365991 updates the default value of BlockZeroingLowLimit to 256 bytes\n+\/\/ when UseBlockZeroing is set to false. As a result, if a smaller low limit (e.g., 8 bytes)\n+\/\/ was previously configured, the generated code for clearing 32 bytes would no longer use zero_blocks_stub.\n+\/\/ Instead, a simpler sequence of instructions can be produced by applying the 256-byte low limit.\n+\/\/\n+\/\/ Measuring the wall-clock time difference for invocations of MacroAssembler::zero_words\n+\/\/ can help evaluate the performance impact of proactively adjusting the BlockZeroingLowLimit.\n+TEST_VM_F(MacroAssemblerZeroWordsTest, UseBZ_clear_32B_with_lowlimit_256B) {\n+  FLAG_SET_CMDLINE(BlockZeroingLowLimit, 256);\n+  benchmark_zero_words(4); \/\/ 32B\n+}\n+\n+TEST_VM_F(MacroAssemblerZeroWordsTest, UseBZ_clear_128B_with_lowlimit_64B) {\n+  FLAG_SET_CMDLINE(BlockZeroingLowLimit, 64);\n+  benchmark_zero_words(16); \/\/ 128B\n+}\n+\n+\/\/ JDK-8365991 updates BlockZeroingLowLimit from 64B to 256B when UseBlockZeroing is false,\n+\/\/ which also improves the efficiency of generating the code for clearing 128-byte memory blocks.\n+TEST_VM_F(MacroAssemblerZeroWordsTest, UseBZ_clear_128B_with_lowlimit_256B) {\n+  FLAG_SET_CMDLINE(BlockZeroingLowLimit, 256);\n+  benchmark_zero_words(16); \/\/ 128B\n+}\n+\n+#endif  \/\/ AARCH64 && !ZERO\n\\ No newline at end of file\n","filename":"test\/hotspot\/gtest\/aarch64\/test_MacroAssembler_zero_words.cpp","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -26,0 +26,2 @@\n+\n+import org.openjdk.bench.vm.gc.RawAllocationRate.BaseClass;\n@@ -40,1 +42,1 @@\n-    @Param({\"32\", \"64\", \"256\", \"1024\", \"2048\", \"4096\", \"8192\", \"16384\", \"65536\", \"131072\"})  \/\/ Object size in bytes.\n+    @Param({\"32\", \"48\", \"64\", \"80\", \"96\", \"128\", \"256\", \"1024\", \"2048\", \"4096\", \"8192\", \"16384\", \"65536\", \"131072\"})  \/\/ Object size in bytes.\n@@ -116,1 +118,0 @@\n-\n@@ -121,0 +122,6 @@\n+    static class Class48 extends BaseClass {\n+       long i0;\n+       long i1;\n+       long i2;\n+       long i3;\n+    }\n@@ -129,0 +136,38 @@\n+    static class Class80 extends BaseClass {\n+       long i0;\n+       long i1;\n+       long i2;\n+       long i3;\n+       long i4;\n+       long i5;\n+       long i6;\n+       long i7;\n+    }\n+    static class Class96 extends BaseClass {\n+       long i0;\n+       long i1;\n+       long i2;\n+       long i3;\n+       long i4;\n+       long i5;\n+       long i6;\n+       long i7;\n+       long i8;\n+       long i9;\n+    }\n+    static class Class128 extends BaseClass {\n+       long i0;\n+       long i1;\n+       long i2;\n+       long i3;\n+       long i4;\n+       long i5;\n+       long i6;\n+       long i7;\n+       long i8;\n+       long i9;\n+       long i10;\n+       long i11;\n+       long i12;\n+       long i13;\n+    }\n@@ -28710,0 +28755,2 @@\n+        case 48:\n+            return new Class48();\n@@ -28712,0 +28759,6 @@\n+        case 80:\n+            return new Class80();\n+        case 96:\n+            return new Class96();\n+        case 128:\n+            return new Class128();\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/RawAllocationRate.java","additions":55,"deletions":2,"binary":false,"changes":57,"status":"modified"}]}