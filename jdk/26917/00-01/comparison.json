{"files":[{"patch":"@@ -6202,1 +6202,0 @@\n-  BLOCK_COMMENT(\"zero_words {\");\n@@ -6204,0 +6203,2 @@\n+\n+  BLOCK_COMMENT(\"zero_words {\");\n@@ -6209,3 +6210,1 @@\n-\n-  if (UseBlockZeroing) {\n-    \/\/ Try to zero blocks using DC ZVA if allowed.\n+  {\n@@ -6214,4 +6213,4 @@\n-    \/\/ Ensure that this is a C2 compilation.\n-    \/\/ The C1 compiler allocates space solely for trampoline stubs generated\n-    \/\/ by Call LIR operations, and in any case, it is preferable\n-    \/\/ for a C1 compilation task to complete as quickly as possible.\n+    \/\/ Make sure this is a C2 compilation. C1 allocates space only for\n+    \/\/ trampoline stubs generated by Call LIR ops, and in any case it\n+    \/\/ makes sense for a C1 compilation task to proceed as quickly as\n+    \/\/ possible.\n@@ -6232,15 +6231,0 @@\n-\n-  \/\/ Process words with length exceeding the predefined block size threshold.\n-  \/\/ The loop body will be unrolled based on the number of STP instructions calculated below.\n-  const int unroll = zero_words_block_size \/ 2;\n-  Label done, loop;\n-  subs(cnt, cnt, unroll * 2);\n-  br(Assembler::LT, done);\n-  bind(loop);\n-  for (int i = 0; i < unroll; i++)\n-    stp(zr, zr, post(ptr, 16));\n-  subs(cnt, cnt, unroll * 2);\n-  br(Assembler::GE, loop);\n-  bind(done);\n-  add(cnt, cnt, unroll * 2);\n-\n@@ -6250,2 +6234,2 @@\n-  \/\/ If called, the zero_blocks routine has already performed the necessary\n-  \/\/ adjustments to registers r10 and r11, ensuring they are correctly set\n+  \/\/ The zero_blocks routine has already performed the necessary\n+  \/\/ adjustments to r10 and r11, ensuring they are correctly set\n@@ -6291,0 +6275,2 @@\n+    \/\/ Use 16 words as the block size which is 128 bytes on 64-bit systems.\n+    \/\/ A complete loop body will be 8 STPs unrolled there.\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":11,"deletions":25,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -645,3 +645,3 @@\n-  \/\/ The inner part of zero_words(). This is the bulk operation,\n-  \/\/ zeroing words in blocks, using DC ZVA.\n-  \/\/ The caller is responsible for zeroing the last few words.\n+  \/\/ The inner part of zero_words().  This is the bulk operation,\n+  \/\/ zeroing words in blocks, possibly using DC ZVA to do it.  The\n+  \/\/ caller is responsible for zeroing the last few words.\n@@ -656,1 +656,2 @@\n-  \/\/      r11 < MAX2(zva_length * 2, (int)BlockZeroingLowLimit)\n+  \/\/      r11 < MacroAssembler::zero_words_block_size.\n+\n@@ -658,0 +659,1 @@\n+    Label done;\n@@ -667,12 +669,21 @@\n-    assert (UseBlockZeroing, \"only work when UseBlockZeroing is true\");\n-\n-    int zva_length = VM_Version::zva_length();\n-\n-    \/\/ Ensure ZVA length can be divided by 16. This is required by\n-    \/\/ the subsequent operations.\n-    assert (zva_length % 16 == 0, \"Unexpected ZVA Length\");\n-\n-    __ tbz(base, 3, base_aligned);\n-    __ str(zr, Address(__ post(base, 8)));\n-    __ sub(cnt, cnt, 1);\n-    __ bind(base_aligned);\n+    if (UseBlockZeroing) {\n+      int zva_length = VM_Version::zva_length();\n+\n+      \/\/ Ensure ZVA length can be divided by 16. This is required by\n+      \/\/ the subsequent operations.\n+      assert (zva_length % 16 == 0, \"Unexpected ZVA Length\");\n+\n+      __ tbz(base, 3, base_aligned);\n+      __ str(zr, Address(__ post(base, 8)));\n+      __ sub(cnt, cnt, 1);\n+      __ bind(base_aligned);\n+\n+      \/\/ Ensure count >= zva_length * 2 so that it still deserves a zva after\n+      \/\/ alignment.\n+      Label small;\n+      int low_limit = MAX2(zva_length * 2, (int)BlockZeroingLowLimit);\n+      __ subs(rscratch1, cnt, low_limit >> 3);\n+      __ br(Assembler::LT, small);\n+      __ zero_dcache_blocks(base, cnt);\n+      __ bind(small);\n+    }\n@@ -680,8 +691,17 @@\n-    \/\/ Ensure count >= zva_length * 2 so that it still deserves a zva after\n-    \/\/ alignment.\n-    Label small;\n-    int low_limit = MAX2(zva_length * 2, (int)BlockZeroingLowLimit);\n-    __ subs(rscratch1, cnt, low_limit >> 3);\n-    __ br(Assembler::LT, small);\n-    __ zero_dcache_blocks(base, cnt);\n-    __ bind(small);\n+    {\n+      \/\/ Process words with length exceeding the predefined\n+      \/\/ block size threshold. The loop body will be unrolled based on\n+      \/\/ the number of STPs calculated below.\n+      const int unroll = MacroAssembler::zero_words_block_size \/ 2;\n+      \/\/ Clear the remaining blocks.\n+      Label loop;\n+      __ subs(cnt, cnt, unroll * 2);\n+      __ br(Assembler::LT, done);\n+      __ bind(loop);\n+      for (int i = 0; i < unroll; i++)\n+        __ stp(zr, zr, __ post(base, 16));\n+      __ subs(cnt, cnt, unroll * 2);\n+      __ br(Assembler::GE, loop);\n+      __ bind(done);\n+      __ add(cnt, cnt, unroll * 2);\n+    }\n@@ -694,1 +714,0 @@\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":44,"deletions":25,"binary":false,"changes":69,"status":"modified"}]}