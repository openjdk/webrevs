{"files":[{"patch":"@@ -0,0 +1,88 @@\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"compiler\/disassembler.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"unittest.hpp\"\n+\n+#if defined(AARCH64) && !defined(ZERO)\n+#include <chrono>\n+\n+static void dump_code(address start, address end) {\n+  stringStream sstream;\n+  Disassembler::decode(start, end, &sstream);\n+  printf(\"%s\\n\", sstream.as_string());\n+}\n+\n+class MacroAssemblerZeroWordsTest : public ::testing::Test {\n+public:\n+  MacroAssemblerZeroWordsTest() { }\n+  ~MacroAssemblerZeroWordsTest() { }\n+\n+  \/\/ Measure wall time of MacroAssembler::zero_words for different sizes.\n+  \/\/ Sizes are count of words for clearing and could be:\n+  \/\/ 4 for 32B ( 32B \/ 8B-per-word = 4 words)\n+  \/\/ 16 for 128B (128B \/ 8B-per-word = 16 words)\n+  \/\/ 64 for 512B (512B \/ 8B-per-word = 64 words)\n+  static void benchmark_zero_words(uint clear_words_count) {\n+    BufferBlob* blob = BufferBlob::create(\"zero_words_test\", 200000);\n+    CodeBuffer code(blob);\n+    MacroAssembler _masm(&code);\n+\n+    const size_t call_count = 1000;\n+    const size_t word_count = clear_words_count;\n+    uint64_t* buffer = new uint64_t[word_count];\n+    Register base = r10;\n+    uint64_t cnt = word_count;\n+    \/\/ Set up base register to point to buffer\n+    _masm.mov(base, (uintptr_t)buffer);\n+\n+    _masm.zero_words(base, cnt);\n+    dump_code(code.insts()->start(), code.insts()->end());\n+\n+    auto start = std::chrono::steady_clock::now();\n+    for (size_t i = 0; i < call_count; ++i) {\n+        _masm.zero_words(base, cnt);\n+    }\n+    auto end = std::chrono::steady_clock::now();\n+\n+    auto wall_time_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n+    printf(\"MacroAssemblerZeroWordsTest zero_words wall time (ns): %ld\\n\", wall_time_ns \/ call_count);\n+\n+    delete[] buffer;\n+    BufferBlob::free(blob);\n+  }\n+};\n+\n+\/\/ If necessary, UseBlockZeroing should be configured during JVM initialization.\n+\/\/ However, here it is not required to specify it explicitly via TEST_VM_OPTS\n+\/\/ because MacroAssembler::zero_words does not check the UseBlockZeroing flag.\n+\/\/ In contrast, the stub functions for AArch64, such as generate_zero_blocks, do perform this check.\n+\n+TEST_VM_F(MacroAssemblerZeroWordsTest, UseBZ_clear_32B_with_lowlimit_8B) {\n+  FLAG_SET_CMDLINE(BlockZeroingLowLimit, 8);\n+  benchmark_zero_words(4); \/\/ 32B\n+}\n+\/\/ JDK-8365991 updates the default value of BlockZeroingLowLimit to 256 bytes\n+\/\/ when UseBlockZeroing is set to false. As a result, if a smaller low limit (e.g., 8 bytes)\n+\/\/ was previously configured, the generated code for clearing 32 bytes would no longer use zero_blocks_stub.\n+\/\/ Instead, a simpler sequence of instructions can be produced by applying the 256-byte low limit.\n+\/\/\n+\/\/ Measuring the wall-clock time difference for invocations of MacroAssembler::zero_words\n+\/\/ can help evaluate the performance impact of proactively adjusting the BlockZeroingLowLimit.\n+TEST_VM_F(MacroAssemblerZeroWordsTest, UseBZ_clear_32B_with_lowlimit_256B) {\n+  FLAG_SET_CMDLINE(BlockZeroingLowLimit, 256);\n+  benchmark_zero_words(4); \/\/ 32B\n+}\n+\n+TEST_VM_F(MacroAssemblerZeroWordsTest, UseBZ_clear_128B_with_lowlimit_64B) {\n+  FLAG_SET_CMDLINE(BlockZeroingLowLimit, 64);\n+  benchmark_zero_words(16); \/\/ 128B\n+}\n+\n+\/\/ JDK-8365991 updates BlockZeroingLowLimit from 64B to 256B when UseBlockZeroing is false,\n+\/\/ which also improves the efficiency of generating the code for clearing 128-byte memory blocks.\n+TEST_VM_F(MacroAssemblerZeroWordsTest, UseBZ_clear_128B_with_lowlimit_256B) {\n+  FLAG_SET_CMDLINE(BlockZeroingLowLimit, 256);\n+  benchmark_zero_words(16); \/\/ 128B\n+}\n+\n+#endif  \/\/ AARCH64 && !ZERO\n\\ No newline at end of file\n","filename":"test\/hotspot\/gtest\/aarch64\/test_MacroAssembler_zero_words.cpp","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"}]}