{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,2 +125,0 @@\n-    private static final int dump = 0; \/\/ > 0 r, > 1 rw\n-\n@@ -130,1 +128,1 @@\n-    private boolean v3 = true;       \/\/ Set in setV3()\n+    private boolean v3 = true;     \/\/ Set in setV3()\n@@ -133,1 +131,1 @@\n-                         \/\/ used by StartTlsResponse when creating an SSL socket\n+                               \/\/ used by StartTlsResponse when creating an SSL socket\n@@ -135,1 +133,1 @@\n-                         \/\/ used by StartTlsResponse when creating an SSL socket\n+                               \/\/ used by StartTlsResponse when creating an SSL socket\n@@ -327,1 +325,1 @@\n-                                          int connectTimeout) throws Exception {\n+                                          int connectTimeout) throws IOException {\n@@ -330,0 +328,1 @@\n+        \/\/ if timeout is supplied, try to use unconnected socket for connecting with timeout\n@@ -331,8 +330,0 @@\n-            \/\/ create unconnected socket and then connect it if timeout\n-            \/\/ is supplied\n-            InetSocketAddress endpoint =\n-                    createInetSocketAddress(host, port);\n-            \/\/ unconnected socket\n-            socket = factory.createSocket();\n-            \/\/ connect socket with a timeout\n-            socket.connect(endpoint, connectTimeout);\n@@ -340,2 +331,15 @@\n-                System.err.println(\"Connection: creating socket with \" +\n-                        \"a connect timeout\");\n+                System.err.println(\"Connection: creating socket with a connect timeout\");\n+            }\n+            try {\n+                \/\/ unconnected socket\n+                socket = factory.createSocket();\n+            } catch (IOException e) {\n+                \/\/ unconnected socket is likely not supported by the SocketFactory\n+                if (debug) {\n+                    System.err.println(\"Connection: unconnected socket not supported by SocketFactory\");\n+                }\n+            }\n+            if (socket != null) {\n+                InetSocketAddress endpoint = createInetSocketAddress(host, port);\n+                \/\/ connect socket with a timeout\n+                socket.connect(endpoint, connectTimeout);\n@@ -344,0 +348,2 @@\n+\n+        \/\/ either no timeout was supplied or unconnected socket did not work\n@@ -346,1 +352,0 @@\n-            socket = factory.createSocket(host, port);\n@@ -348,2 +353,1 @@\n-                System.err.println(\"Connection: creating connected socket with\" +\n-                        \" no connect timeout\");\n+                System.err.println(\"Connection: creating connected socket with no connect timeout\");\n@@ -351,0 +355,1 @@\n+            socket = factory.createSocket(host, port);\n@@ -359,1 +364,1 @@\n-    private void initialSSLHandshake(SSLSocket sslSocket , int connectTimeout) throws Exception {\n+    private void initialSSLHandshake(SSLSocket sslSocket, int connectTimeout) throws Exception {\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/Connection.java","additions":26,"deletions":21,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,4 @@\n+ *         <br> If a custom socket factory is provided via property\n+ *         {@code java.naming.ldap.factory.socket} and unconnected sockets\n+ *         are not supported, the specified timeout is ignored\n+ *         and the provider behaves as if no connection timeout was set.\n","filename":"src\/java.naming\/share\/classes\/module-info.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,249 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.test.lib.net.URIBuilder;\n-\n-import javax.naming.Context;\n-import javax.naming.ldap.InitialLdapContext;\n-import javax.naming.ldap.LdapContext;\n-import javax.net.SocketFactory;\n-import javax.net.ssl.SSLServerSocketFactory;\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.net.InetAddress;\n-import java.net.ServerSocket;\n-import java.net.Socket;\n-import java.net.SocketException;\n-import java.util.Hashtable;\n-\n-\/*\n- * @test\n- * @bug 8314063\n- * @library \/test\/lib\n- * @summary For LDAPs connection, if the value of com.sun.jndi.ldap.connect.timeout is\n- * set too small or not an optimal value for the system, after the socket is created and\n- * connected to the server, but the handshake between the client and server fails due to\n- * socket time out, the opened socket is not closed properly. In this test case, the server\n- * is forced to sleep ten seconds and connection time out for client is one second. This\n- * will allow the socket opened and connected, and give the chance for the handshake to be\n- * timed out. Before this fix, the socket is kept opened. Right now the exception will be\n- * caught and the socket will be closed.\n- *\n- * @run main\/othervm LdapSSLHandshakeFailureTest LdapSSLHandshakeFailureTest$CustomSocketFactory true 6000\n- * @run main\/othervm LdapSSLHandshakeFailureTest -1000 true 6000\n- * @run main\/othervm LdapSSLHandshakeFailureTest -1000 false 6000\n- * @run main\/othervm LdapSSLHandshakeFailureTest 2000 false 6000\n- * @run main\/othervm LdapSSLHandshakeFailureTest 0 true 6000\n- * @run main\/othervm LdapSSLHandshakeFailureTest 0 false 6000\n- * @run main\/othervm LdapSSLHandshakeFailureTest true\n- * @run main\/othervm LdapSSLHandshakeFailureTest false\n- *\/\n-\n-public class LdapSSLHandshakeFailureTest {\n-    private static String SOCKET_CLOSED_MSG = \"The socket has been closed.\";\n-\n-    private static int serverSleepingTime = 5000;\n-\n-    public static void main(String args[]) throws Exception {\n-\n-        \/\/ Set the keystores\n-        setKeyStore();\n-        boolean serverSlowDown = Boolean.valueOf(args[0]);\n-        if (args.length == 2) {\n-            serverSlowDown = Boolean.valueOf(args[1]);\n-        }\n-\n-        if (args.length == 3) {\n-            serverSleepingTime = Integer.valueOf(args[2]);\n-        }\n-\n-        boolean hasCustomSocketFactory = args[0]\n-                .equals(\"LdapSSLHandshakeFailureTest$CustomSocketFactory\");\n-        \/\/ start the test server first.\n-        try (TestServer server = new TestServer(serverSlowDown, serverSleepingTime)) {\n-            server.start();\n-            Hashtable<String, Object> env = new Hashtable<>();\n-            env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n-            env.put(\"java.naming.ldap.version\", \"3\");\n-            env.put(Context.PROVIDER_URL, URIBuilder.newBuilder()\n-                    .scheme(\"ldaps\")\n-                    .loopback()\n-                    .port(server.getPortNumber())\n-                    .buildUnchecked().toString());\n-\n-            if (hasCustomSocketFactory) {\n-                env.put(\"java.naming.ldap.factory.socket\", args[0]);\n-                env.put(\"com.sun.jndi.ldap.connect.timeout\", \"1000\");\n-            }\n-\n-            if (args.length == 2 && !hasCustomSocketFactory) {\n-                env.put(\"com.sun.jndi.ldap.connect.timeout\", args[0]);\n-            }\n-\n-            env.put(Context.SECURITY_PROTOCOL, \"ssl\");\n-            env.put(Context.SECURITY_AUTHENTICATION, \"Simple\");\n-            env.put(Context.SECURITY_PRINCIPAL, \"cn=principal\");\n-            env.put(Context.SECURITY_CREDENTIALS, \"123456\");\n-            LdapContext ctx = null;\n-            try {\n-                ctx = new InitialLdapContext(env, null);\n-            } catch (Exception e) {\n-                if (CustomSocketFactory.customSocket.closeMethodCalledCount() > 0\n-                        && hasCustomSocketFactory\n-                        && Boolean.valueOf(args[1])) {\n-                    System.out.println(SOCKET_CLOSED_MSG);\n-                } else {\n-                    throw e;\n-                }\n-            } finally {\n-                if (ctx != null)\n-                    ctx.close();\n-            }\n-        }\n-    }\n-\n-    public static class CustomSocketFactory extends SocketFactory {\n-        private static CustomSocket customSocket;\n-\n-        public static CustomSocketFactory getDefault() {\n-            return new CustomSocketFactory();\n-        }\n-\n-        @Override\n-        public Socket createSocket() throws SocketException {\n-            customSocket = new CustomSocket();\n-            return customSocket;\n-        }\n-\n-        @Override\n-        public Socket createSocket(String s, int timeout) {\n-            return customSocket;\n-        }\n-\n-        @Override\n-        public Socket createSocket(String host, int port, InetAddress localHost,\n-                                   int localPort) {\n-            return customSocket;\n-        }\n-\n-        @Override\n-        public Socket createSocket(InetAddress host, int port) {\n-            return customSocket;\n-        }\n-\n-        @Override\n-        public Socket createSocket(InetAddress address, int port,\n-                                   InetAddress localAddress, int localPort) {\n-            return customSocket;\n-        }\n-    }\n-\n-    private static class CustomSocket extends Socket {\n-        private int closeMethodCalled = 0;\n-\n-        public CustomSocket() {\n-            closeMethodCalled = 0;\n-        }\n-\n-        public int closeMethodCalledCount() {\n-            return closeMethodCalled;\n-        }\n-\n-        @Override\n-        public void close() throws java.io.IOException {\n-            closeMethodCalled++;\n-            super.close();\n-        }\n-    }\n-\n-    private static void setKeyStore() {\n-\n-        String fileName = \"ksWithSAN\", dir = System.getProperty(\"test.src\", \".\") + File.separator;\n-\n-        System.setProperty(\"javax.net.ssl.keyStore\", dir + fileName);\n-        System.setProperty(\"javax.net.ssl.keyStorePassword\", \"welcome1\");\n-        System.setProperty(\"javax.net.ssl.trustStore\", dir + fileName);\n-        System.setProperty(\"javax.net.ssl.trustStorePassword\", \"welcome1\");\n-    }\n-\n-    static class TestServer extends Thread implements AutoCloseable {\n-        private boolean isForceToSleep;\n-        private int sleepingTime;\n-        private final ServerSocket serverSocket;\n-        private final int PORT;\n-\n-        private TestServer(boolean isForceToSleep, int sleepingTime) {\n-            this.isForceToSleep = isForceToSleep;\n-            this.sleepingTime = sleepingTime;\n-            try {\n-                SSLServerSocketFactory socketFactory = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\n-                serverSocket = socketFactory.createServerSocket(0, 0, InetAddress.getLoopbackAddress());\n-                PORT = serverSocket.getLocalPort();\n-            } catch (IOException ex) {\n-                throw new RuntimeException(ex);\n-            }\n-            setDaemon(true);\n-        }\n-\n-        public int getPortNumber() {\n-            return PORT;\n-        }\n-\n-        @Override\n-        public void run() {\n-            try (Socket socket = serverSocket.accept();\n-                 InputStream in = socket.getInputStream();\n-                 OutputStream out = socket.getOutputStream()) {\n-                if (isForceToSleep) {\n-                    Thread.sleep(sleepingTime);\n-                }\n-                byte[] bindResponse = {0x30, 0x0C, 0x02, 0x01, 0x01, 0x61, 0x07, 0x0A,\n-                        0x01, 0x00, 0x04, 0x00, 0x04, 0x00};\n-                \/\/ read the bindRequest\n-                while (in.read() != -1) {\n-                    in.skip(in.available());\n-                    break;\n-                }\n-                out.write(bindResponse);\n-                out.flush();\n-                \/\/ ignore the further requests\n-                while (in.read() != -1) {\n-                    in.skip(in.available());\n-                }\n-            } catch (Exception e) {\n-                e.printStackTrace();\n-            }\n-        }\n-\n-        @Override\n-        public void close() throws Exception {\n-            if (serverSocket != null) {\n-                serverSocket.close();\n-            }\n-        }\n-    }\n-}\n-\n-\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/LdapSSLHandshakeFailureTest.java","additions":0,"deletions":249,"binary":false,"changes":249,"status":"deleted"},{"patch":"@@ -0,0 +1,344 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.reflect.Field;\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.net.UnknownHostException;\n+import java.util.Hashtable;\n+\n+import javax.naming.Context;\n+import javax.naming.NamingException;\n+import javax.naming.ldap.InitialLdapContext;\n+import javax.naming.ldap.LdapContext;\n+import javax.net.SocketFactory;\n+import javax.net.ssl.SSLServerSocketFactory;\n+\n+import jdk.test.lib.net.URIBuilder;\n+\n+\/*\n+ * @test\n+ * @bug 8314063 8325579\n+ * @library \/test\/lib\n+ * @summary Several scenarios for LDAP connection handshaking are tested here.\n+ * We test different combinations of com.sun.jndi.ldap.connect.timeout values\n+ * and server behavior, e.g. a server that replies immediately vs a server that\n+ * delays the initial answer. We also try to check whether the underlying Socket\n+ * object will be closed correctly.\n+ * We expect exceptions when using a custom SocketFactory that does not supply\n+ * SSL Sockets. In that case we instrument the supplied Socket object and check\n+ * if it was properly closed after the handshake failure.\n+ * When the value of com.sun.jndi.ldap.connect.timeout is set lower than the\n+ * server delay, we also expect an exception.\n+ * In all other cases a valid Context object shall be returned and we check\n+ * whether the socket is closed after closing the Context.\n+ *\n+ * @run main\/othervm --add-opens java.naming\/javax.naming=ALL-UNNAMED --add-opens java.naming\/com.sun.jndi.ldap=ALL-UNNAMED\n+ *      LdapSSLHandshakeTest\n+ * @run main\/othervm --add-opens java.naming\/javax.naming=ALL-UNNAMED --add-opens java.naming\/com.sun.jndi.ldap=ALL-UNNAMED\n+ *      LdapSSLHandshakeTest true\n+ * @run main\/othervm --add-opens java.naming\/javax.naming=ALL-UNNAMED --add-opens java.naming\/com.sun.jndi.ldap=ALL-UNNAMED\n+ *      LdapSSLHandshakeTest 0\n+ * @run main\/othervm --add-opens java.naming\/javax.naming=ALL-UNNAMED --add-opens java.naming\/com.sun.jndi.ldap=ALL-UNNAMED\n+ *      LdapSSLHandshakeTest 0 true\n+ * @run main\/othervm --add-opens java.naming\/javax.naming=ALL-UNNAMED --add-opens java.naming\/com.sun.jndi.ldap=ALL-UNNAMED\n+ *      LdapSSLHandshakeTest 2000\n+ * @run main\/othervm --add-opens java.naming\/javax.naming=ALL-UNNAMED --add-opens java.naming\/com.sun.jndi.ldap=ALL-UNNAMED\n+ *      LdapSSLHandshakeTest 2000 true\n+ * @run main\/othervm --add-opens java.naming\/javax.naming=ALL-UNNAMED --add-opens java.naming\/com.sun.jndi.ldap=ALL-UNNAMED\n+ *      LdapSSLHandshakeTest -1000\n+ * @run main\/othervm LdapSSLHandshakeTest LdapSSLHandshakeTest$CustomSocketFactoryNoUnconnected\n+ * @run main\/othervm LdapSSLHandshakeTest LdapSSLHandshakeTest$CustomSocketFactoryNoUnconnected 1000\n+ * @run main\/othervm LdapSSLHandshakeTest LdapSSLHandshakeTest$CustomSocketFactoryNoUnconnected true\n+ * @run main\/othervm LdapSSLHandshakeTest LdapSSLHandshakeTest$CustomSocketFactoryNoUnconnected 1000 true\n+ * @run main\/othervm LdapSSLHandshakeTest LdapSSLHandshakeTest$CustomSocketFactory\n+ * @run main\/othervm LdapSSLHandshakeTest LdapSSLHandshakeTest$CustomSocketFactory 1000\n+ * @run main\/othervm LdapSSLHandshakeTest LdapSSLHandshakeTest$CustomSocketFactory true\n+ * @run main\/othervm LdapSSLHandshakeTest LdapSSLHandshakeTest$CustomSocketFactory 1000 true\n+ *\/\n+\n+public class LdapSSLHandshakeTest {\n+    private static int SERVER_SLEEPING_TIME = 4000;\n+    private static String progArgs[];\n+    private static int curArg;\n+    private static String customSocketFactory;\n+    private static Integer connectTimeout;\n+    private static boolean serverSlowDown;\n+\n+    private static String popArg() {\n+        if (curArg >= progArgs.length) {\n+                return null;\n+        }\n+        return progArgs[curArg++];\n+    }\n+\n+    private static void parseArgs(String args[]) {\n+        progArgs = args;\n+        curArg = 0;\n+\n+        String arg = popArg();\n+        if (arg == null)\n+            return;\n+\n+        if (arg.startsWith(\"LdapSSLHandshakeTest$CustomSocketFactory\")) {\n+            customSocketFactory = arg;\n+            arg = popArg();\n+            if (arg == null)\n+                return;\n+        }\n+\n+        try {\n+            connectTimeout = Integer.valueOf(arg);\n+            arg = popArg();\n+            if (arg == null)\n+                return;\n+        } catch (NumberFormatException e) {\n+            \/\/ then it must be the boolean arg for serverSlowDown\n+        }\n+\n+        serverSlowDown = Boolean.valueOf(arg);\n+    }\n+\n+    public static void main(String args[]) {\n+        parseArgs(args);\n+\n+        System.out.println(\"Testing \" +\n+            (customSocketFactory == null ? \"without custom SocketFactory\" : \"with custom SocketFactory \\\"\" + customSocketFactory + \"\\\"\") +\n+            \", \" + (connectTimeout == null ? \"no connectTimeout\" : \"connectTimeout=\" + connectTimeout + \"\") +\n+            \", serverSlowDown=\" + serverSlowDown);\n+\n+        \/\/ Set the keystores\n+        setKeyStore();\n+\n+        \/\/ start the test server first.\n+        try (TestServer server = new TestServer(serverSlowDown)) {\n+            server.start();\n+            Hashtable<String, Object> env = new Hashtable<>();\n+            env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n+            env.put(\"java.naming.ldap.version\", \"3\");\n+            env.put(Context.PROVIDER_URL, URIBuilder.newBuilder()\n+                    .scheme(\"ldaps\")\n+                    .loopback()\n+                    .port(server.getPortNumber())\n+                    .buildUnchecked().toString());\n+\n+            if (customSocketFactory != null) {\n+                env.put(\"java.naming.ldap.factory.socket\", customSocketFactory);\n+            }\n+\n+            if (connectTimeout != null) {\n+                env.put(\"com.sun.jndi.ldap.connect.timeout\", connectTimeout.toString());\n+            }\n+            env.put(Context.SECURITY_PROTOCOL, \"ssl\");\n+            env.put(Context.SECURITY_AUTHENTICATION, \"Simple\");\n+            env.put(Context.SECURITY_PRINCIPAL, \"cn=principal\");\n+            env.put(Context.SECURITY_CREDENTIALS, \"123456\");\n+            LdapContext ctx = null;\n+            try {\n+                ctx = new InitialLdapContext(env, null);\n+            } catch (NamingException e) {\n+                if (customSocketFactory != null) {\n+                    System.out.println(\"Caught expected Exception with custom SocketFactory (no SSL Socket).\");\n+                    if (CustomSocketFactory.customSocket.closeMethodCalledCount() <= 0) {\n+                        System.err.println(\"Custom Socket was not closed.\");\n+                        System.exit(-1);\n+                    }\n+                } else if (connectTimeout > 0) {\n+                    System.out.println(\"Caught expected Exception with connectTimeout > 0.\");\n+                } else {\n+                    throw e;\n+                }\n+            } finally {\n+                if (ctx != null) {\n+                    System.out.println(\"Context was created, closing it.\");\n+                    Socket sock = getSocket(ctx);\n+                    ctx.close();\n+                    if (!checkSocketClosed(sock)) {\n+                        System.exit(-1);\n+                    }\n+                }\n+            }\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            System.exit(-1);\n+        }\n+    }\n+\n+    private static Socket getSocket(LdapContext ctx) throws Exception {\n+        Field defaultInitCtxField = ctx.getClass().getSuperclass().getSuperclass().getDeclaredField(\"defaultInitCtx\");\n+        defaultInitCtxField.setAccessible(true);\n+        Object defaultInitCtx = defaultInitCtxField.get(ctx);\n+        Field clntField = defaultInitCtx.getClass().getDeclaredField(\"clnt\");\n+        clntField.setAccessible(true);\n+        Object clnt = clntField.get(defaultInitCtx);\n+        Field connField = clnt.getClass().getDeclaredField(\"conn\");\n+        connField.setAccessible(true);\n+        Object conn = connField.get(clnt);\n+        return (Socket)conn.getClass().getDeclaredField(\"sock\").get(conn);\n+    }\n+\n+    private static boolean checkSocketClosed(Socket s) throws Exception {\n+        if (s.isClosed()) {\n+            System.out.println(\"Socket is closed\");\n+            return true;\n+        } else {\n+            System.err.println(\"Socket isn't closed\");\n+            return false;\n+        }\n+    }\n+\n+    private static class CustomSocket extends Socket {\n+        private int closeMethodCalled;\n+\n+        public CustomSocket() {\n+            super();\n+        }\n+\n+        public CustomSocket(String s, int timeout) throws IOException {\n+            super(s, timeout);\n+        }\n+\n+        public int closeMethodCalledCount() {\n+            return closeMethodCalled;\n+        }\n+\n+        @Override\n+        public void close() throws java.io.IOException {\n+            closeMethodCalled++;\n+            super.close();\n+        }\n+    }\n+\n+    public static class CustomSocketFactoryNoUnconnected extends SocketFactory {\n+        static CustomSocket customSocket;\n+\n+        public static SocketFactory getDefault() {\n+            return new CustomSocketFactoryNoUnconnected();\n+        }\n+\n+        @Override\n+        public Socket createSocket(String s, int timeout) throws IOException {\n+            customSocket = new CustomSocket(s, timeout);\n+            return customSocket;\n+        }\n+\n+        @Override\n+        public Socket createSocket(String host, int port, InetAddress localHost, int localPort)\n+                throws IOException, UnknownHostException {\n+            return null;\n+        }\n+\n+        @Override\n+        public Socket createSocket(InetAddress host, int port) throws IOException {\n+            return null;\n+        }\n+\n+        @Override\n+        public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort)\n+                throws IOException {\n+            return null;\n+        }\n+    }\n+\n+    public static class CustomSocketFactory extends CustomSocketFactoryNoUnconnected {\n+        public static SocketFactory getDefault() {\n+            return new CustomSocketFactory();\n+        }\n+\n+        @Override\n+        public Socket createSocket() throws SocketException {\n+            customSocket = new CustomSocket();\n+            return customSocket;\n+        }\n+    }\n+\n+    private static void setKeyStore() {\n+        String keystore = System.getProperty(\"test.src\", \".\") + File.separator + \"ksWithSAN\";\n+\n+        System.setProperty(\"javax.net.ssl.keyStore\", keystore);\n+        System.setProperty(\"javax.net.ssl.keyStorePassword\", \"welcome1\");\n+        System.setProperty(\"javax.net.ssl.trustStore\", keystore);\n+        System.setProperty(\"javax.net.ssl.trustStorePassword\", \"welcome1\");\n+    }\n+\n+    static class TestServer extends Thread implements AutoCloseable {\n+        private boolean isForceToSleep;\n+        private final ServerSocket serverSocket;\n+        private final int PORT;\n+\n+        private TestServer(boolean isForceToSleep) {\n+            this.isForceToSleep = isForceToSleep;\n+            try {\n+                SSLServerSocketFactory socketFactory = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\n+                serverSocket = socketFactory.createServerSocket(0, 0, InetAddress.getLoopbackAddress());\n+                PORT = serverSocket.getLocalPort();\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+            setDaemon(true);\n+        }\n+\n+        public int getPortNumber() {\n+            return PORT;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try (Socket socket = serverSocket.accept();\n+                 InputStream in = socket.getInputStream();\n+                 OutputStream out = socket.getOutputStream()) {\n+                if (isForceToSleep) {\n+                    Thread.sleep(SERVER_SLEEPING_TIME);\n+                }\n+                byte[] bindResponse = {0x30, 0x0C, 0x02, 0x01, 0x01, 0x61, 0x07, 0x0A,\n+                        0x01, 0x00, 0x04, 0x00, 0x04, 0x00};\n+                \/\/ read the bindRequest\n+                while (in.read() != -1) {\n+                    in.skip(in.available());\n+                    break;\n+                }\n+                out.write(bindResponse);\n+                out.flush();\n+                \/\/ ignore the further requests\n+                while (in.read() != -1) {\n+                    in.skip(in.available());\n+                }\n+            } catch (Exception e) {\n+                \/\/ e.printStackTrace();\n+            }\n+        }\n+\n+        @Override\n+        public void close() throws Exception {\n+            if (serverSocket != null) {\n+                serverSocket.close();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/LdapSSLHandshakeTest.java","additions":344,"deletions":0,"binary":false,"changes":344,"status":"added"}]}