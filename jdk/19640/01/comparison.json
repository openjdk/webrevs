{"files":[{"patch":"@@ -128,2 +128,2 @@\n-void ShenandoahAdaptiveHeuristics::record_success_concurrent() {\n-  ShenandoahHeuristics::record_success_concurrent();\n+void ShenandoahAdaptiveHeuristics::record_success_concurrent(bool abbreviated) {\n+  ShenandoahHeuristics::record_success_concurrent(abbreviated);\n@@ -243,1 +243,1 @@\n-  double avg_cycle_time = _gc_time_history->davg() + (_margin_of_error_sd * _gc_time_history->dsd());\n+  double avg_cycle_time = _gc_cycle_time_history->davg() + (_margin_of_error_sd * _gc_cycle_time_history->dsd());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-  void record_success_concurrent();\n+  void record_success_concurrent(bool abbreviated);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-  _gc_time_history(new TruncatedSeq(10, ShenandoahAdaptiveDecayFactor)),\n+  _gc_cycle_time_history(new TruncatedSeq(Moving_Average_Samples, ShenandoahAdaptiveDecayFactor)),\n@@ -66,1 +66,1 @@\n-  assert(collection_set->count() == 0, \"Must be empty\");\n+  assert(collection_set->is_empty(), \"Must be empty\");\n@@ -150,1 +150,0 @@\n-\n@@ -155,2 +154,2 @@\n-                     \"Immediate: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%), \"\n-                     \"CSet: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%)\",\n+                     \"Immediate: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%), \" SIZE_FORMAT \" regions, \"\n+                     \"CSet: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%), \" SIZE_FORMAT \" regions\",\n@@ -165,0 +164,1 @@\n+                     immediate_regions,\n@@ -168,1 +168,2 @@\n-                     cset_percent);\n+                     cset_percent,\n+                     collection_set->count());\n@@ -187,1 +188,1 @@\n-  if (ShenandoahGuaranteedGCInterval > 0) {\n+  if (_guaranteed_gc_interval > 0) {\n@@ -189,1 +190,1 @@\n-    if (last_time_ms > ShenandoahGuaranteedGCInterval) {\n+    if (last_time_ms > _guaranteed_gc_interval) {\n@@ -191,1 +192,1 @@\n-                   last_time_ms, ShenandoahGuaranteedGCInterval);\n+                   last_time_ms, _guaranteed_gc_interval);\n@@ -205,1 +206,1 @@\n-          \"In range before adjustment: \" INTX_FORMAT, _gc_time_penalties);\n+         \"In range before adjustment: \" INTX_FORMAT, _gc_time_penalties);\n@@ -217,1 +218,1 @@\n-          \"In range after adjustment: \" INTX_FORMAT, _gc_time_penalties);\n+         \"In range after adjustment: \" INTX_FORMAT, _gc_time_penalties);\n@@ -220,2 +221,1 @@\n-void ShenandoahHeuristics::record_success_concurrent() {\n-  _gc_time_history->add(time_since_last_gc());\n+void ShenandoahHeuristics::record_success_concurrent(bool abbreviated) {\n@@ -225,0 +225,4 @@\n+\n+  if (_gc_times_learned <= ShenandoahLearningSteps || !(abbreviated && ShenandoahAdaptiveIgnoreAbbreviated)) {\n+    _gc_cycle_time_history->add(elapsed_cycle_time());\n+  }\n@@ -259,1 +263,1 @@\n-double ShenandoahHeuristics::time_since_last_gc() const {\n+double ShenandoahHeuristics::elapsed_cycle_time() const {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -73,0 +73,2 @@\n+  static const uint Moving_Average_Samples = 10; \/\/ Number of samples to store in moving averages\n+\n@@ -83,0 +85,2 @@\n+  size_t _guaranteed_gc_interval;\n+\n@@ -88,1 +92,1 @@\n-  TruncatedSeq* _gc_time_history;\n+  TruncatedSeq* _gc_cycle_time_history;\n@@ -109,0 +113,4 @@\n+  void set_guaranteed_gc_interval(size_t guaranteed_gc_interval) {\n+    _guaranteed_gc_interval = guaranteed_gc_interval;\n+  }\n+\n@@ -117,1 +125,1 @@\n-  virtual void record_success_concurrent();\n+  virtual void record_success_concurrent(bool abbreviated);\n@@ -137,1 +145,1 @@\n-  double time_since_last_gc() const;\n+  double elapsed_cycle_time() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -328,1 +328,1 @@\n-    heap->heuristics()->record_success_concurrent();\n+    heap->heuristics()->record_success_concurrent(gc.abbreviated());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -475,0 +475,1 @@\n+  _heuristics->set_guaranteed_gc_interval(ShenandoahGuaranteedGCInterval);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -152,0 +152,10 @@\n+  product(bool, ShenandoahAdaptiveIgnoreAbbreviated, true, EXPERIMENTAL,    \\\n+          \"The adaptive heuristic tracks a moving average of cycle \"        \\\n+          \"times in order to start a gc before memory is exhausted. \"       \\\n+          \"In some cases, Shenandoah may skip the evacuation and update \"   \\\n+          \"reference phases, resulting in a shorter cycle. These may skew \" \\\n+          \"the average cycle time downward and may cause the heuristic \"    \\\n+          \"to wait too long to start a cycle. Disabling this will have \"    \\\n+          \"the gc run less often, which will reduce CPU utilization, but\"   \\\n+          \"increase the risk of degenerated cycles.\")                       \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}