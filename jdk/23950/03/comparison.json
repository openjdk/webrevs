{"files":[{"patch":"@@ -2044,1 +2044,1 @@\n-  subs(zr, scratch, InstanceKlass::fully_initialized);\n+  cmp(scratch, InstanceKlass::fully_initialized);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -96,0 +96,46 @@\n+void MethodHandles::verify_method(MacroAssembler* _masm, Register method, vmIntrinsics::ID iid) {\n+  BLOCK_COMMENT(\"verify_method {\");\n+  __ verify_method_ptr(method);\n+  if (VerifyMethodHandles) {\n+    Label L_ok;\n+    assert_different_registers(method, rscratch1, rscratch2);\n+    const Register method_holder = rscratch1;\n+    __ load_method_holder(method_holder, method);\n+\n+    switch (iid) {\n+      case vmIntrinsicID::_invokeBasic:\n+        \/\/ Require compiled LambdaForm class to be fully initialized.\n+        __ lea(rscratch2, Address(method_holder, InstanceKlass::init_state_offset()));\n+        __ ldarb(rscratch2, rscratch2);\n+        __ cmp(rscratch2, InstanceKlass::fully_initialized);\n+        __ br(Assembler::EQ, L_ok);\n+        break;\n+\n+      case vmIntrinsicID::_linkToStatic:\n+        __ clinit_barrier(method_holder, rscratch2, &L_ok);\n+        break;\n+\n+      case vmIntrinsicID::_linkToVirtual:\n+      case vmIntrinsicID::_linkToSpecial:\n+      case vmIntrinsicID::_linkToInterface:\n+        \/\/ Class initialization check is too strong here. Just ensure that class initialization has been initiated.\n+        __ lea(rscratch2, Address(method_holder, InstanceKlass::init_state_offset()));\n+        __ ldarb(rscratch2, rscratch2);\n+        __ cmp(rscratch2, InstanceKlass::being_initialized);\n+        __ br(Assembler::GE, L_ok);\n+\n+        \/\/ init_state check failed, but it may be an abstract interface method\n+        __ ldrh(rscratch2, Address(method, Method::access_flags_offset()));\n+        __ tbnz(rscratch2, exact_log2(JVM_ACC_ABSTRACT), L_ok);\n+        break;\n+\n+      default:\n+        fatal(\"unexpected intrinsic %d: %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n+    }\n+\n+    \/\/ Method holder init state check failed for a concrete method.\n+    __ stop(\"Method holder klass is not initialized\");\n+    __ bind(L_ok);\n+  }\n+  BLOCK_COMMENT(\"} verify_method\");\n+}\n@@ -99,1 +145,1 @@\n-                                            bool for_compiler_entry) {\n+                                            bool for_compiler_entry, vmIntrinsics::ID iid) {\n@@ -103,1 +149,1 @@\n-  __ verify_method_ptr(method);\n+  verify_method(_masm, method, iid);\n@@ -163,1 +209,1 @@\n-  jump_from_method_handle(_masm, method_temp, temp2, for_compiler_entry);\n+  jump_from_method_handle(_masm, method_temp, temp2, for_compiler_entry, vmIntrinsics::_invokeBasic);\n@@ -450,2 +496,1 @@\n-    __ verify_method_ptr(rmethod);\n-    jump_from_method_handle(_masm, rmethod, temp1, for_compiler_entry);\n+    jump_from_method_handle(_masm, rmethod, temp1, for_compiler_entry, iid);\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp","additions":50,"deletions":5,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+  static void verify_method(MacroAssembler* _masm, Register method, vmIntrinsics::ID iid) NOT_DEBUG_RETURN;\n+\n@@ -52,1 +54,1 @@\n-                                      bool for_compiler_entry);\n+                                      bool for_compiler_entry, vmIntrinsics::ID iid);\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -125,1 +125,48 @@\n-#endif \/\/ASSERT\n+void MethodHandles::verify_method(MacroAssembler* _masm, Register method, Register temp, vmIntrinsics::ID iid) {\n+  BLOCK_COMMENT(\"verify_method {\");\n+  __ verify_method_ptr(method);\n+  if (VerifyMethodHandles) {\n+    Label L_ok;\n+    assert_different_registers(method, temp);\n+\n+    const Register method_holder = temp;\n+    __ load_method_holder(method_holder, method);\n+    __ push(method_holder); \/\/ keep holder around for diagnostic purposes\n+\n+    switch (iid) {\n+      case vmIntrinsicID::_invokeBasic:\n+        \/\/ Require compiled LambdaForm class to be fully initialized.\n+        __ cmpb(Address(method_holder, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);\n+        __ jccb(Assembler::equal, L_ok);\n+        break;\n+\n+      case vmIntrinsicID::_linkToStatic:\n+        __ clinit_barrier(method_holder, &L_ok);\n+        break;\n+\n+      case vmIntrinsicID::_linkToVirtual:\n+      case vmIntrinsicID::_linkToSpecial:\n+      case vmIntrinsicID::_linkToInterface:\n+        \/\/ Class initialization check is too strong here. Just ensure that initialization has been initiated.\n+        __ cmpb(Address(method_holder, InstanceKlass::init_state_offset()), InstanceKlass::being_initialized);\n+        __ jcc(Assembler::greaterEqual, L_ok);\n+\n+        \/\/ init_state check failed, but it may be an abstract interface method\n+        __ load_unsigned_short(temp, Address(method, Method::access_flags_offset()));\n+        __ testl(temp, JVM_ACC_ABSTRACT);\n+        __ jccb(Assembler::notZero, L_ok);\n+        break;\n+\n+      default:\n+        fatal(\"unexpected intrinsic %d: %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n+    }\n+\n+    \/\/ clinit check failed for a concrete method\n+    __ STOP(\"Method holder klass is not initialized\");\n+\n+    __ BIND(L_ok);\n+    __ pop(method_holder); \/\/ restore stack layout\n+  }\n+  BLOCK_COMMENT(\"} verify_method\");\n+}\n+#endif \/\/ ASSERT\n@@ -128,1 +175,1 @@\n-                                            bool for_compiler_entry) {\n+                                            bool for_compiler_entry, vmIntrinsics::ID iid) {\n@@ -135,1 +182,1 @@\n-  __ verify_method_ptr(method);\n+  verify_method(_masm, method, temp, iid);\n@@ -196,1 +243,1 @@\n-  jump_from_method_handle(_masm, method_temp, temp2, for_compiler_entry);\n+  jump_from_method_handle(_masm, method_temp, temp2, for_compiler_entry, vmIntrinsics::_invokeBasic);\n@@ -488,2 +535,1 @@\n-    __ verify_method_ptr(rbx_method);\n-    jump_from_method_handle(_masm, rbx_method, temp1, for_compiler_entry);\n+    jump_from_method_handle(_masm, rbx_method, temp1, for_compiler_entry, iid);\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":52,"deletions":6,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+  static void verify_method(MacroAssembler* _masm, Register method, Register temp, vmIntrinsics::ID iid) NOT_DEBUG_RETURN;\n+\n@@ -51,1 +53,1 @@\n-                                      bool for_compiler_entry);\n+                                      bool for_compiler_entry, vmIntrinsics::ID iid);\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}