{"files":[{"patch":"@@ -489,1 +489,1 @@\n-                && ReflectionData.reads.containsKeyPair(this, ALL_UNNAMED_MODULE))\n+            && ReflectionData.reads.containsKeyPair(this, ALL_UNNAMED_MODULE))\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,158 +0,0 @@\n-import org.openjdk.jmh.annotations.*;\n-\n-import java.lang.foreign.*;\n-import java.lang.invoke.*;\n-import java.util.*;\n-\n-@State(Scope.Benchmark)\n-@Fork(jvmArgsAppend = {\"-XX:MaxInlineLevel=15\"}) \/\/ default is 15 anyway, but override to make sure\n-public class FFMVarHandleInlineTest {\n-\n-    \/**\n-     * Implements the following:\n-     * <pre>{@code\n-     * int JAVA_INT_UNALIGNED(long offset) {\n-     *     return MemorySegment\n-     *         .ofAddress(offset)\n-     *         .reinterpret(8L)\n-     *         .get(ValueLayout.JAVA_INT_UNALIGNED, 0L)\n-     * }\n-     * }<\/pre>\n-     *\/\n-    private static final VarHandle JAVA_INT_UNALIGNED;\n-\n-    static {\n-        try {\n-            var ofAddress = MethodHandles.lookup()\n-                    .findStatic(MemorySegment.class, \"ofAddress\", MethodType.methodType(MemorySegment.class, long.class));\n-\n-            var reinterpret = MethodHandles.lookup()\n-                    .findVirtual(MemorySegment.class, \"reinterpret\", MethodType.methodType(MemorySegment.class, long.class));\n-\n-            var vh = ValueLayout.JAVA_INT_UNALIGNED.varHandle();\n-\n-            vh = MethodHandles.insertCoordinates(vh, 1, 0L);\n-            vh = MethodHandles.filterCoordinates(vh, 0, MethodHandles.filterReturnValue(\n-                    ofAddress,\n-                    MethodHandles.insertArguments(reinterpret, 1, 8L)\n-            ));\n-\n-            JAVA_INT_UNALIGNED = vh.withInvokeExactBehavior();\n-        } catch (NoSuchMethodException | IllegalAccessException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    \/\/ segment + offsets should comfortably fit in L1 cache\n-\n-    private MemorySegment segment;\n-\n-    private long[] offsets;\n-\n-    @Param(value = {\n-            \"1024\", \/\/ 1kb\n-    })\n-    private int segmentSize;\n-\n-    @Param(value = {\n-            \/\/\"8\", \/\/ 64b\n-            \/\/\"512\", \/\/ 4kb\n-            \"2048\", \/\/ 16kb\n-    })\n-    private int offsetCount;\n-\n-    @Setup\n-    public void init() {\n-        var rand = new Random(7);\n-\n-        \/\/ initialize segment with random values\n-        segment = Arena.ofAuto().allocate(segmentSize);\n-        for (int i = 0; i < segment.byteSize() \/ 8; i++) {\n-            segment.set(ValueLayout.JAVA_LONG, i * 8, rand.nextLong());\n-        }\n-\n-        var ints = (int)(segment.byteSize() >> 2);\n-\n-        \/\/ initialize offset array\n-        offsets = new long[offsetCount];\n-        for (int i = 0; i < offsets.length; i++) {\n-            offsets[i] = segment.address() + (rand.nextInt(ints) << 2); \/\/ random\n-            \/\/offsets[i] = segment.address() + ((i % ints) << 2); \/\/ sequential\n-        }\n-\n-        \/\/ validate that all loops are implemented correctly\n-        var ref = t0_reference();\n-        if (\n-                ref != t1_level8() ||\n-                        ref != t2_level9() ||\n-                        ref != t3_level10() ||\n-                        ref != t4_level11()\n-        ) {\n-            throw new IllegalStateException();\n-        }\n-    }\n-\n-    @Benchmark\n-    public int t0_reference() {\n-        var s = 0;\n-        for (long offset : offsets) {\n-            s += (int)JAVA_INT_UNALIGNED.get(offset);\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    @Benchmark\n-    public int t1_level8() {\n-        var s = 0;\n-        for (long offset : offsets) {\n-            s += level8(offset);\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    @Benchmark\n-    public int t2_level9() {\n-        var s = 0;\n-        for (long offset : offsets) {\n-            s += level9(offset);\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    @Benchmark\n-    public int t3_level10() {\n-        var s = 0;\n-        for (long offset : offsets) {\n-            s += level10(offset);\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    @Benchmark\n-    public int t4_level11() {\n-        var s = 0;\n-        for (long offset : offsets) {\n-            s += level11(offset);\n-        }\n-        return s;\n-    }\n-\n-    private static int level11(long offset) { return level10(offset); }\n-    private static int level10(long offset) { return level9(offset); }\n-    private static int level9(long offset)  { return level8(offset); }\n-    private static int level8(long offset)  { return level7(offset); }\n-    private static int level7(long offset)  { return level6(offset); }\n-    private static int level6(long offset)  { return level5(offset); }\n-    private static int level5(long offset)  { return level4(offset); }\n-    private static int level4(long offset)  { return level3(offset); }\n-    private static int level3(long offset)  { return level2(offset); }\n-    private static int level2(long offset)  { return level1(offset); }\n-    private static int level1(long offset)  { return level0(offset); }\n-    private static int level0(long offset)  { return (int)JAVA_INT_UNALIGNED.get(offset); }\n-    \/\/private static int level0(long offset)  { return MemorySegment.ofAddress(offset).reinterpret(8L).get(ValueLayout.JAVA_INT_UNALIGNED, 0L); }\n-\n-}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/FFMVarHandleInlineTest.java","additions":0,"deletions":158,"binary":false,"changes":158,"status":"deleted"}]}