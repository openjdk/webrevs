{"files":[{"patch":"@@ -317,1 +317,1 @@\n-        String mod = mod(currentClass);\n+        String modDeclaredLabel = modDeclaredLabel(currentClass);\n@@ -319,1 +319,1 @@\n-            throw new IllegalCallerException(\"Illegal native access from \" + mod);\n+            throw new IllegalCallerException(\"Illegal native access from \" + modDeclaredLabel);\n@@ -324,1 +324,1 @@\n-            String modflag = isNamed() ? getName() : \"ALL-UNNAMED\";\n+            String modFlag = isNamed() ? getName() : \"ALL-UNNAMED\";\n@@ -332,1 +332,1 @@\n-                            %n\"\"\", cls, mtd, mod, modflag);\n+                            %n\"\"\", cls, mtd, modDeclaredLabel, modFlag);\n@@ -339,1 +339,1 @@\n-                            %n\"\"\", cls, mtd, caller, mod, modflag);\n+                            %n\"\"\", cls, mtd, caller, modDeclaredLabel, modFlag);\n@@ -344,2 +344,2 @@\n-    private String mod(Class<?> currentClass) {\n-        String mod = isNamed() ? \"module \" + getName() : \"an unnamed module\";\n+    private String modDeclaredLabel(Class<?> currentClass) {\n+        String label = isNamed() ? \"module \" + getName() : \"an unnamed module\";\n@@ -352,1 +352,1 @@\n-                    mod += \" (\" + url + \")\";\n+                    label += \" (\" + url + \")\";\n@@ -356,1 +356,1 @@\n-        return mod;\n+        return label;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.lang.foreign.*;\n+import java.lang.invoke.*;\n+import java.util.*;\n+\n+@State(Scope.Benchmark)\n+@Fork(jvmArgsAppend = {\"-XX:MaxInlineLevel=15\"}) \/\/ default is 15 anyway, but override to make sure\n+public class FFMVarHandleInlineTest {\n+\n+    \/**\n+     * Implements the following:\n+     * <pre>{@code\n+     * int JAVA_INT_UNALIGNED(long offset) {\n+     *     return MemorySegment\n+     *         .ofAddress(offset)\n+     *         .reinterpret(8L)\n+     *         .get(ValueLayout.JAVA_INT_UNALIGNED, 0L)\n+     * }\n+     * }<\/pre>\n+     *\/\n+    private static final VarHandle JAVA_INT_UNALIGNED;\n+\n+    static {\n+        try {\n+            var ofAddress = MethodHandles.lookup()\n+                    .findStatic(MemorySegment.class, \"ofAddress\", MethodType.methodType(MemorySegment.class, long.class));\n+\n+            var reinterpret = MethodHandles.lookup()\n+                    .findVirtual(MemorySegment.class, \"reinterpret\", MethodType.methodType(MemorySegment.class, long.class));\n+\n+            var vh = ValueLayout.JAVA_INT_UNALIGNED.varHandle();\n+\n+            vh = MethodHandles.insertCoordinates(vh, 1, 0L);\n+            vh = MethodHandles.filterCoordinates(vh, 0, MethodHandles.filterReturnValue(\n+                    ofAddress,\n+                    MethodHandles.insertArguments(reinterpret, 1, 8L)\n+            ));\n+\n+            JAVA_INT_UNALIGNED = vh.withInvokeExactBehavior();\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/\/ segment + offsets should comfortably fit in L1 cache\n+\n+    private MemorySegment segment;\n+\n+    private long[] offsets;\n+\n+    @Param(value = {\n+            \"1024\", \/\/ 1kb\n+    })\n+    private int segmentSize;\n+\n+    @Param(value = {\n+            \/\/\"8\", \/\/ 64b\n+            \/\/\"512\", \/\/ 4kb\n+            \"2048\", \/\/ 16kb\n+    })\n+    private int offsetCount;\n+\n+    @Setup\n+    public void init() {\n+        var rand = new Random(7);\n+\n+        \/\/ initialize segment with random values\n+        segment = Arena.ofAuto().allocate(segmentSize);\n+        for (int i = 0; i < segment.byteSize() \/ 8; i++) {\n+            segment.set(ValueLayout.JAVA_LONG, i * 8, rand.nextLong());\n+        }\n+\n+        var ints = (int)(segment.byteSize() >> 2);\n+\n+        \/\/ initialize offset array\n+        offsets = new long[offsetCount];\n+        for (int i = 0; i < offsets.length; i++) {\n+            offsets[i] = segment.address() + (rand.nextInt(ints) << 2); \/\/ random\n+            \/\/offsets[i] = segment.address() + ((i % ints) << 2); \/\/ sequential\n+        }\n+\n+        \/\/ validate that all loops are implemented correctly\n+        var ref = t0_reference();\n+        if (\n+                ref != t1_level8() ||\n+                        ref != t2_level9() ||\n+                        ref != t3_level10() ||\n+                        ref != t4_level11()\n+        ) {\n+            throw new IllegalStateException();\n+        }\n+    }\n+\n+    @Benchmark\n+    public int t0_reference() {\n+        var s = 0;\n+        for (long offset : offsets) {\n+            s += (int)JAVA_INT_UNALIGNED.get(offset);\n+        }\n+        return s;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @Benchmark\n+    public int t1_level8() {\n+        var s = 0;\n+        for (long offset : offsets) {\n+            s += level8(offset);\n+        }\n+        return s;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @Benchmark\n+    public int t2_level9() {\n+        var s = 0;\n+        for (long offset : offsets) {\n+            s += level9(offset);\n+        }\n+        return s;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @Benchmark\n+    public int t3_level10() {\n+        var s = 0;\n+        for (long offset : offsets) {\n+            s += level10(offset);\n+        }\n+        return s;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @Benchmark\n+    public int t4_level11() {\n+        var s = 0;\n+        for (long offset : offsets) {\n+            s += level11(offset);\n+        }\n+        return s;\n+    }\n+\n+    private static int level11(long offset) { return level10(offset); }\n+    private static int level10(long offset) { return level9(offset); }\n+    private static int level9(long offset)  { return level8(offset); }\n+    private static int level8(long offset)  { return level7(offset); }\n+    private static int level7(long offset)  { return level6(offset); }\n+    private static int level6(long offset)  { return level5(offset); }\n+    private static int level5(long offset)  { return level4(offset); }\n+    private static int level4(long offset)  { return level3(offset); }\n+    private static int level3(long offset)  { return level2(offset); }\n+    private static int level2(long offset)  { return level1(offset); }\n+    private static int level1(long offset)  { return level0(offset); }\n+    private static int level0(long offset)  { return (int)JAVA_INT_UNALIGNED.get(offset); }\n+    \/\/private static int level0(long offset)  { return MemorySegment.ofAddress(offset).reinterpret(8L).get(ValueLayout.JAVA_INT_UNALIGNED, 0L); }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/FFMVarHandleInlineTest.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"}]}