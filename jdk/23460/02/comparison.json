{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-import java.security.ProtectionDomain;\n@@ -72,0 +71,2 @@\n+import jdk.internal.vm.annotation.DontInline;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -179,0 +180,1 @@\n+    @ForceInline\n@@ -189,0 +191,1 @@\n+    @ForceInline\n@@ -198,0 +201,1 @@\n+    @ForceInline\n@@ -208,0 +212,1 @@\n+    @ForceInline\n@@ -227,0 +232,1 @@\n+    @ForceInline\n@@ -256,0 +262,1 @@\n+    @ForceInline\n@@ -272,0 +279,1 @@\n+        @ForceInline\n@@ -273,1 +281,1 @@\n-            return UNSAFE.getBooleanVolatile(target, FIELD_OFFSET);\n+            return target.enableNativeAccess || UNSAFE.getBooleanVolatile(target, FIELD_OFFSET);\n@@ -285,0 +293,1 @@\n+    @ForceInline\n@@ -290,0 +299,1 @@\n+    @ForceInline\n@@ -296,21 +306,22 @@\n-            String mod = isNamed() ? \"module \" + getName() : \"an unnamed module\";\n-            if (currentClass != null) {\n-                \/\/ try to extract location of the current class (e.g. jar or folder)\n-                CodeSource cs = currentClass.getProtectionDomain().getCodeSource();\n-                if (cs != null) {\n-                    URL url = cs.getLocation();\n-                    if (url != null) {\n-                        mod += \" (\" + url + \")\";\n-                    }\n-                }\n-            }\n-            if (illegalNativeAccess == ModuleBootstrap.IllegalNativeAccess.DENY) {\n-                throw new IllegalCallerException(\"Illegal native access from \" + mod);\n-            } else if (EnableNativeAccess.trySetEnableNativeAccess(target)) {\n-                \/\/ warn and set flag, so that only one warning is reported per module\n-                String cls = owner.getName();\n-                String mtd = cls + \"::\" + methodName;\n-                String modflag = isNamed() ? getName() : \"ALL-UNNAMED\";\n-                String caller = currentClass != null ? currentClass.getName() : \"code\";\n-                if (jni) {\n-                    VM.initialErr().printf(\"\"\"\n+            ensureNativeAccessSlowPath(owner, methodName, currentClass, jni, target, illegalNativeAccess);\n+        }\n+    }\n+\n+    @DontInline\n+    void ensureNativeAccessSlowPath(Class<?> owner,\n+                                    String methodName,\n+                                    Class<?> currentClass,\n+                                    boolean jni,\n+                                    Module target,\n+                                    ModuleBootstrap.IllegalNativeAccess illegalNativeAccess) {\n+        String modDeclaredLabel = modDeclaredLabel(currentClass);\n+        if (illegalNativeAccess == ModuleBootstrap.IllegalNativeAccess.DENY) {\n+            throw new IllegalCallerException(\"Illegal native access from \" + modDeclaredLabel);\n+        } else if (EnableNativeAccess.trySetEnableNativeAccess(target)) {\n+            \/\/ warn and set flag, so that only one warning is reported per module\n+            String cls = owner.getName();\n+            String mtd = cls + \"::\" + methodName;\n+            String modFlag = isNamed() ? getName() : \"ALL-UNNAMED\";\n+            String caller = currentClass != null ? currentClass.getName() : \"code\";\n+            if (jni) {\n+                VM.initialErr().printf(\"\"\"\n@@ -321,3 +332,3 @@\n-                            %n\"\"\", cls, mtd, mod, modflag);\n-                } else {\n-                    VM.initialErr().printf(\"\"\"\n+                            %n\"\"\", cls, mtd, modDeclaredLabel, modFlag);\n+            } else {\n+                VM.initialErr().printf(\"\"\"\n@@ -328,1 +339,14 @@\n-                            %n\"\"\", cls, mtd, caller, mod, modflag);\n+                            %n\"\"\", cls, mtd, caller, modDeclaredLabel, modFlag);\n+            }\n+        }\n+    }\n+\n+    private String modDeclaredLabel(Class<?> currentClass) {\n+        String label = isNamed() ? \"module \" + getName() : \"an unnamed module\";\n+        if (currentClass != null) {\n+            \/\/ try to extract location of the current class (e.g. jar or folder)\n+            CodeSource cs = currentClass.getProtectionDomain().getCodeSource();\n+            if (cs != null) {\n+                URL url = cs.getLocation();\n+                if (url != null) {\n+                    label += \" (\" + url + \")\";\n@@ -332,0 +356,1 @@\n+        return label;\n@@ -464,1 +489,1 @@\n-            && ReflectionData.reads.containsKeyPair(this, ALL_UNNAMED_MODULE))\n+                && ReflectionData.reads.containsKeyPair(this, ALL_UNNAMED_MODULE))\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":54,"deletions":29,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.lang.foreign.*;\n+import java.lang.invoke.*;\n+import java.util.*;\n+\n+@State(Scope.Benchmark)\n+@Fork(jvmArgsAppend = {\"-XX:MaxInlineLevel=15\"}) \/\/ default is 15 anyway, but override to make sure\n+public class FFMVarHandleInlineTest {\n+\n+    \/**\n+     * Implements the following:\n+     * <pre>{@code\n+     * int JAVA_INT_UNALIGNED(long offset) {\n+     *     return MemorySegment\n+     *         .ofAddress(offset)\n+     *         .reinterpret(8L)\n+     *         .get(ValueLayout.JAVA_INT_UNALIGNED, 0L)\n+     * }\n+     * }<\/pre>\n+     *\/\n+    private static final VarHandle JAVA_INT_UNALIGNED;\n+\n+    static {\n+        try {\n+            var ofAddress = MethodHandles.lookup()\n+                    .findStatic(MemorySegment.class, \"ofAddress\", MethodType.methodType(MemorySegment.class, long.class));\n+\n+            var reinterpret = MethodHandles.lookup()\n+                    .findVirtual(MemorySegment.class, \"reinterpret\", MethodType.methodType(MemorySegment.class, long.class));\n+\n+            var vh = ValueLayout.JAVA_INT_UNALIGNED.varHandle();\n+\n+            vh = MethodHandles.insertCoordinates(vh, 1, 0L);\n+            vh = MethodHandles.filterCoordinates(vh, 0, MethodHandles.filterReturnValue(\n+                    ofAddress,\n+                    MethodHandles.insertArguments(reinterpret, 1, 8L)\n+            ));\n+\n+            JAVA_INT_UNALIGNED = vh.withInvokeExactBehavior();\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/\/ segment + offsets should comfortably fit in L1 cache\n+\n+    private MemorySegment segment;\n+\n+    private long[] offsets;\n+\n+    @Param(value = {\n+            \"1024\", \/\/ 1kb\n+    })\n+    private int segmentSize;\n+\n+    @Param(value = {\n+            \/\/\"8\", \/\/ 64b\n+            \/\/\"512\", \/\/ 4kb\n+            \"2048\", \/\/ 16kb\n+    })\n+    private int offsetCount;\n+\n+    @Setup\n+    public void init() {\n+        var rand = new Random(7);\n+\n+        \/\/ initialize segment with random values\n+        segment = Arena.ofAuto().allocate(segmentSize);\n+        for (int i = 0; i < segment.byteSize() \/ 8; i++) {\n+            segment.set(ValueLayout.JAVA_LONG, i * 8, rand.nextLong());\n+        }\n+\n+        var ints = (int)(segment.byteSize() >> 2);\n+\n+        \/\/ initialize offset array\n+        offsets = new long[offsetCount];\n+        for (int i = 0; i < offsets.length; i++) {\n+            offsets[i] = segment.address() + (rand.nextInt(ints) << 2); \/\/ random\n+            \/\/offsets[i] = segment.address() + ((i % ints) << 2); \/\/ sequential\n+        }\n+\n+        \/\/ validate that all loops are implemented correctly\n+        var ref = t0_reference();\n+        if (\n+                ref != t1_level8() ||\n+                        ref != t2_level9() ||\n+                        ref != t3_level10() ||\n+                        ref != t4_level11()\n+        ) {\n+            throw new IllegalStateException();\n+        }\n+    }\n+\n+    @Benchmark\n+    public int t0_reference() {\n+        var s = 0;\n+        for (long offset : offsets) {\n+            s += (int)JAVA_INT_UNALIGNED.get(offset);\n+        }\n+        return s;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @Benchmark\n+    public int t1_level8() {\n+        var s = 0;\n+        for (long offset : offsets) {\n+            s += level8(offset);\n+        }\n+        return s;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @Benchmark\n+    public int t2_level9() {\n+        var s = 0;\n+        for (long offset : offsets) {\n+            s += level9(offset);\n+        }\n+        return s;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @Benchmark\n+    public int t3_level10() {\n+        var s = 0;\n+        for (long offset : offsets) {\n+            s += level10(offset);\n+        }\n+        return s;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @Benchmark\n+    public int t4_level11() {\n+        var s = 0;\n+        for (long offset : offsets) {\n+            s += level11(offset);\n+        }\n+        return s;\n+    }\n+\n+    private static int level11(long offset) { return level10(offset); }\n+    private static int level10(long offset) { return level9(offset); }\n+    private static int level9(long offset)  { return level8(offset); }\n+    private static int level8(long offset)  { return level7(offset); }\n+    private static int level7(long offset)  { return level6(offset); }\n+    private static int level6(long offset)  { return level5(offset); }\n+    private static int level5(long offset)  { return level4(offset); }\n+    private static int level4(long offset)  { return level3(offset); }\n+    private static int level3(long offset)  { return level2(offset); }\n+    private static int level2(long offset)  { return level1(offset); }\n+    private static int level1(long offset)  { return level0(offset); }\n+    private static int level0(long offset)  { return (int)JAVA_INT_UNALIGNED.get(offset); }\n+    \/\/private static int level0(long offset)  { return MemorySegment.ofAddress(offset).reinterpret(8L).get(ValueLayout.JAVA_INT_UNALIGNED, 0L); }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/FFMVarHandleInlineTest.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"}]}