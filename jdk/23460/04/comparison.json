{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-import java.security.ProtectionDomain;\n@@ -72,0 +71,2 @@\n+import jdk.internal.vm.annotation.DontInline;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -179,0 +180,1 @@\n+    @ForceInline\n@@ -189,0 +191,1 @@\n+    @ForceInline\n@@ -198,0 +201,1 @@\n+    @ForceInline\n@@ -208,0 +212,1 @@\n+    @ForceInline\n@@ -227,0 +232,1 @@\n+    @ForceInline\n@@ -256,0 +262,1 @@\n+    @ForceInline\n@@ -272,0 +279,1 @@\n+        @ForceInline\n@@ -273,1 +281,1 @@\n-            return UNSAFE.getBooleanVolatile(target, FIELD_OFFSET);\n+            return target.enableNativeAccess || UNSAFE.getBooleanVolatile(target, FIELD_OFFSET);\n@@ -285,0 +293,1 @@\n+    @ForceInline\n@@ -290,0 +299,1 @@\n+    @ForceInline\n@@ -296,21 +306,22 @@\n-            String mod = isNamed() ? \"module \" + getName() : \"an unnamed module\";\n-            if (currentClass != null) {\n-                \/\/ try to extract location of the current class (e.g. jar or folder)\n-                CodeSource cs = currentClass.getProtectionDomain().getCodeSource();\n-                if (cs != null) {\n-                    URL url = cs.getLocation();\n-                    if (url != null) {\n-                        mod += \" (\" + url + \")\";\n-                    }\n-                }\n-            }\n-            if (illegalNativeAccess == ModuleBootstrap.IllegalNativeAccess.DENY) {\n-                throw new IllegalCallerException(\"Illegal native access from \" + mod);\n-            } else if (EnableNativeAccess.trySetEnableNativeAccess(target)) {\n-                \/\/ warn and set flag, so that only one warning is reported per module\n-                String cls = owner.getName();\n-                String mtd = cls + \"::\" + methodName;\n-                String modflag = isNamed() ? getName() : \"ALL-UNNAMED\";\n-                String caller = currentClass != null ? currentClass.getName() : \"code\";\n-                if (jni) {\n-                    VM.initialErr().printf(\"\"\"\n+            ensureNativeAccessSlowPath(owner, methodName, currentClass, jni, target, illegalNativeAccess);\n+        }\n+    }\n+\n+    @DontInline\n+    void ensureNativeAccessSlowPath(Class<?> owner,\n+                                    String methodName,\n+                                    Class<?> currentClass,\n+                                    boolean jni,\n+                                    Module target,\n+                                    ModuleBootstrap.IllegalNativeAccess illegalNativeAccess) {\n+        String modDeclaredLabel = modDeclaredLabel(currentClass);\n+        if (illegalNativeAccess == ModuleBootstrap.IllegalNativeAccess.DENY) {\n+            throw new IllegalCallerException(\"Illegal native access from \" + modDeclaredLabel);\n+        } else if (EnableNativeAccess.trySetEnableNativeAccess(target)) {\n+            \/\/ warn and set flag, so that only one warning is reported per module\n+            String cls = owner.getName();\n+            String mtd = cls + \"::\" + methodName;\n+            String modFlag = isNamed() ? getName() : \"ALL-UNNAMED\";\n+            String caller = currentClass != null ? currentClass.getName() : \"code\";\n+            if (jni) {\n+                VM.initialErr().printf(\"\"\"\n@@ -321,3 +332,3 @@\n-                            %n\"\"\", cls, mtd, mod, modflag);\n-                } else {\n-                    VM.initialErr().printf(\"\"\"\n+                            %n\"\"\", cls, mtd, modDeclaredLabel, modFlag);\n+            } else {\n+                VM.initialErr().printf(\"\"\"\n@@ -328,1 +339,14 @@\n-                            %n\"\"\", cls, mtd, caller, mod, modflag);\n+                            %n\"\"\", cls, mtd, caller, modDeclaredLabel, modFlag);\n+            }\n+        }\n+    }\n+\n+    private String modDeclaredLabel(Class<?> currentClass) {\n+        String label = isNamed() ? \"module \" + getName() : \"an unnamed module\";\n+        if (currentClass != null) {\n+            \/\/ try to extract location of the current class (e.g. jar or folder)\n+            CodeSource cs = currentClass.getProtectionDomain().getCodeSource();\n+            if (cs != null) {\n+                URL url = cs.getLocation();\n+                if (url != null) {\n+                    label += \" (\" + url + \")\";\n@@ -332,0 +356,1 @@\n+        return label;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":53,"deletions":28,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -43,0 +44,1 @@\n+    @ForceInline\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Object.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -2083,0 +2084,1 @@\n+            @ForceInline\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -164,0 +164,1 @@\n+    @ForceInline\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -213,0 +213,1 @@\n+    @ForceInline\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,0 +41,3 @@\n+    private static final boolean ADDRESS_SIZE_IS_4 =\n+            Unsafe.getUnsafe().addressSize() == 4;\n+\n@@ -46,1 +49,1 @@\n-        this.min = (Unsafe.getUnsafe().addressSize() == 4)\n+        this.min = ADDRESS_SIZE_IS_4\n@@ -80,0 +83,1 @@\n+    @ForceInline\n@@ -96,0 +100,1 @@\n+    @ForceInline\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3570,0 +3570,1 @@\n+    @ForceInline\n@@ -3590,0 +3591,1 @@\n+    @ForceInline\n@@ -3605,0 +3607,1 @@\n+    @ForceInline\n@@ -3621,0 +3624,1 @@\n+    @ForceInline\n@@ -3691,0 +3695,1 @@\n+    @ForceInline\n@@ -3713,0 +3718,1 @@\n+    @ForceInline\n@@ -3729,0 +3735,1 @@\n+    @ForceInline\n@@ -3739,0 +3746,1 @@\n+    @ForceInline\n@@ -3832,4 +3840,4 @@\n-    private static char convEndian(boolean big, char n)   { return big == BIG_ENDIAN ? n : Character.reverseBytes(n); }\n-    private static short convEndian(boolean big, short n) { return big == BIG_ENDIAN ? n : Short.reverseBytes(n)    ; }\n-    private static int convEndian(boolean big, int n)     { return big == BIG_ENDIAN ? n : Integer.reverseBytes(n)  ; }\n-    private static long convEndian(boolean big, long n)   { return big == BIG_ENDIAN ? n : Long.reverseBytes(n)     ; }\n+    @ForceInline private static char convEndian(boolean big, char n)   { return big == BIG_ENDIAN ? n : Character.reverseBytes(n); }\n+    @ForceInline private static short convEndian(boolean big, short n) { return big == BIG_ENDIAN ? n : Short.reverseBytes(n)    ; }\n+    @ForceInline private static int convEndian(boolean big, int n)     { return big == BIG_ENDIAN ? n : Integer.reverseBytes(n)  ; }\n+    @ForceInline private static long convEndian(boolean big, long n)   { return big == BIG_ENDIAN ? n : Long.reverseBytes(n)     ; }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -824,0 +825,1 @@\n+    @ForceInline\n@@ -891,0 +893,1 @@\n+    @ForceInline\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleBootstrap.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,311 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.lang.ref.Reference;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 2, jvmArgsAppend = {\n+        \"-XX:+UnlockDiagnosticVMOptions\",\n+        \"-Xbatch\",\n+        \"-XX:MaxInlineLevel=15\",\n+        \"-XX:CompileCommand=PrintInlining,org.openjdk.bench.java.lang.foreign.FFMVarHandleInlineTest::t_level15\"})\n+public class FFMVarHandleInlineTest {\n+\n+    private static final boolean RANDOM_ORDER = true;\n+\n+    \/**\n+     * Implements the following:\n+     * <pre>{@code\n+     * int JAVA_INT_UNALIGNED(long offset) {\n+     *     return MemorySegment\n+     *         .ofAddress(offset)\n+     *         .reinterpret(8L)\n+     *         .get(ValueLayout.JAVA_INT_UNALIGNED, 0L)\n+     * }\n+     * }<\/pre>\n+     *\/\n+    private static final VarHandle JAVA_INT_UNALIGNED;\n+\n+    static {\n+        try {\n+            var ofAddress = MethodHandles.lookup()\n+                    .findStatic(MemorySegment.class, \"ofAddress\", MethodType.methodType(MemorySegment.class, long.class));\n+\n+            var reinterpret = MethodHandles.lookup()\n+                    .findVirtual(MemorySegment.class, \"reinterpret\", MethodType.methodType(MemorySegment.class, long.class));\n+\n+            var vh = ValueLayout.JAVA_INT_UNALIGNED.varHandle();\n+\n+            vh = MethodHandles.insertCoordinates(vh, 1, 0L);\n+            vh = MethodHandles.filterCoordinates(vh, 0, MethodHandles.filterReturnValue(\n+                    ofAddress,\n+                    MethodHandles.insertArguments(reinterpret, 1, 8L)\n+            ));\n+\n+            JAVA_INT_UNALIGNED = vh.withInvokeExactBehavior();\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/\/ segment + offsets should comfortably fit in L1 cache\n+\n+    private MemorySegment segment;\n+\n+    private long[] offsets;\n+\n+    @Param(value = {\n+            \"1024\", \/\/ 1kb\n+    })\n+    private int segmentSize;\n+\n+    @Param(value = {\n+            \/\/\"8\", \/\/ 64b\n+            \/\/\"512\", \/\/ 4kb\n+            \"2048\", \/\/ 16kb\n+    })\n+    private int offsetCount;\n+\n+    @Setup\n+    public void init() {\n+        var rand = new Random(42);\n+\n+        \/\/ initialize segment with random values\n+        segment = Arena.ofAuto().allocate(segmentSize);\n+        for (int i = 0; i < segment.byteSize() \/ 8; i++) {\n+            segment.setAtIndex(ValueLayout.JAVA_LONG, i, rand.nextLong());\n+        }\n+\n+        var ints = (int) (segment.byteSize() >> 2);\n+\n+        \/\/ initialize offset array\n+        offsets = new long[offsetCount];\n+        for (int i = 0; i < offsets.length; i++) {\n+            if (RANDOM_ORDER) {\n+                offsets[i] = segment.address() + ((long) rand.nextInt(ints) << 2); \/\/ random\n+            } else {\n+                offsets[i] = segment.address() + ((long) (i % ints) << 2); \/\/ sequential\n+            }\n+        }\n+\n+        \/\/ validate that all loops are implemented correctly\n+        var ref = t0_reference();\n+        if (\n+                ref != t_level8() ||\n+                        ref != t_level9() ||\n+                        ref != t_level10() ||\n+                        ref != t_level11()\n+        ) {\n+            throw new IllegalStateException();\n+        }\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        Reference.reachabilityFence(segment);\n+    }\n+\n+    \/\/@Benchmark\n+    public int t0_reference() {\n+        var s = 0;\n+        for (long offset : offsets) {\n+            s += (int) JAVA_INT_UNALIGNED.get(offset);\n+        }\n+        return s;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    \/\/@Benchmark\n+    public int t_level8() {\n+        var s = 0;\n+        for (long offset : offsets) {\n+            s += level8(offset);\n+        }\n+        return s;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    \/\/@Benchmark\n+    public int t_level9() {\n+        var s = 0;\n+        for (long offset : offsets) {\n+            s += level9(offset);\n+        }\n+        return s;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    \/\/@Benchmark\n+    public int t_level10() {\n+        var s = 0;\n+        for (long offset : offsets) {\n+            s += level10(offset);\n+        }\n+        return s;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    \/\/@Benchmark\n+    public int t_level11() {\n+        var s = 0;\n+        for (long offset : offsets) {\n+            s += level11(offset);\n+        }\n+        return s;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    \/\/@Benchmark\n+    public int t_level12() {\n+        var s = 0;\n+        for (long offset : offsets) {\n+            s += level12(offset);\n+        }\n+        return s;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @Benchmark\n+    public int t_level13() {\n+\n+        var s = 0;\n+        for (long offset : offsets) {\n+            s += level13(offset);\n+        }\n+        return s;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @Benchmark\n+    public int t_level14() {\n+        var s = 0;\n+        for (long offset : offsets) {\n+            s += level14(offset);\n+        }\n+        return s;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @Benchmark\n+    public int t_level15() {\n+        var s = 0;\n+        for (long offset : offsets) {\n+            s += level15(offset);\n+        }\n+        return s;\n+    }\n+\n+    private static int level15(long offset) {\n+        return level14(offset);\n+    }\n+\n+    private static int level14(long offset) {\n+        return level13(offset);\n+    }\n+\n+    private static int level13(long offset) {\n+        return level12(offset);\n+    }\n+\n+    private static int level12(long offset) {\n+        return level11(offset);\n+    }\n+\n+    private static int level11(long offset) {\n+        return level10(offset);\n+    }\n+\n+    private static int level10(long offset) {\n+        return level9(offset);\n+    }\n+\n+    private static int level9(long offset) {\n+        return level8(offset);\n+    }\n+\n+    private static int level8(long offset) {\n+        return level7(offset);\n+    }\n+\n+    private static int level7(long offset) {\n+        return level6(offset);\n+    }\n+\n+    private static int level6(long offset) {\n+        return level5(offset);\n+    }\n+\n+    private static int level5(long offset) {\n+        return level4(offset);\n+    }\n+\n+    private static int level4(long offset) {\n+        return level3(offset);\n+    }\n+\n+    private static int level3(long offset) {\n+        return level2(offset);\n+    }\n+\n+    private static int level2(long offset) {\n+        return level1(offset);\n+    }\n+\n+    private static int level1(long offset) {\n+        return level0(offset);\n+    }\n+\n+    private static int level0(long offset) {\n+        return (int) JAVA_INT_UNALIGNED.get(offset);\n+    }\n+\n+\/*    private static int level0(long offset) {\n+        return MemorySegment.ofAddress(offset)\n+                .reinterpret(8L)\n+                .get(ValueLayout.JAVA_INT_UNALIGNED, 0L);\n+    }*\/\n+\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/FFMVarHandleInlineTest.java","additions":311,"deletions":0,"binary":false,"changes":311,"status":"added"}]}