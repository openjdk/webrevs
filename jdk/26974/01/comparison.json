{"files":[{"patch":"@@ -67,1 +67,1 @@\n-            debian-version: bookworm\n+            debian-version: trixie\n@@ -73,1 +73,1 @@\n-            debian-version: bookworm\n+            debian-version: trixie\n@@ -80,1 +80,1 @@\n-            debian-version: bookworm\n+            debian-version: trixie\n@@ -86,1 +86,1 @@\n-            debian-version: bookworm\n+            debian-version: trixie\n@@ -92,2 +92,2 @@\n-            debian-version: sid\n-            tolerate-sysroot-errors: true\n+            debian-version: trixie\n+            tolerate-sysroot-errors: false\n","filename":".github\/workflows\/build-cross-compile.yml","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -212,0 +212,10 @@\n+<h4 id=\"conventions-for-lock-free-code\">Conventions for Lock-free\n+Code<\/h4>\n+<p>Sometimes variables are accessed concurrently without appropriate\n+synchronization context, such as a held mutex or at a safepoint. In such\n+cases the variable should be declared <code>volatile<\/code> and it\n+should NOT be accessed as a normal C++ lvalue. Rather, access should be\n+performed via functions from <code>Atomic<\/code>, such as\n+<code>Atomic::load<\/code>, <code>Atomic::store<\/code>, etc.<\/p>\n+<p>This special formulation makes it more clear to maintainers that the\n+variable is accessed concurrently in a lock-free manner.<\/p>\n","filename":"doc\/hotspot-style.html","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -138,0 +138,11 @@\n+#### Conventions for Lock-free Code\n+\n+Sometimes variables are accessed concurrently without appropriate synchronization\n+context, such as a held mutex or at a safepoint. In such cases the variable should\n+be declared `volatile` and it should NOT be accessed as a normal C++ lvalue. Rather,\n+access should be performed via functions from `Atomic`, such as `Atomic::load`,\n+`Atomic::store`, etc.\n+\n+This special formulation makes it more clear to maintainers that the variable is\n+accessed concurrently in a lock-free manner.\n+\n","filename":"doc\/hotspot-style.md","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -401,1 +401,2 @@\n-<p>Currently only applies to JTReg.<\/p>\n+<p>Currently only applies to <a href=\"#timeout_factor-1\">JTReg\n+-timeoutFactor<\/a>.<\/p>\n@@ -447,2 +448,6 @@\n-<p>The timeout factor (<code>-timeoutFactor<\/code>).<\/p>\n-<p>Defaults to 4.<\/p>\n+<p>The <code>TIMEOUT_FACTOR<\/code> is forwarded to JTReg framework\n+itself (<code>-timeoutFactor<\/code>). Also, some test cases that\n+programmatically wait a certain amount of time will apply this factor.\n+If we run in forced compilation mode (<code>-Xcomp<\/code>), the build\n+system will automatically adjust this factor to compensate for less\n+performance. Defaults to 1.<\/p>\n","filename":"doc\/testing.html","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -327,1 +327,1 @@\n-Currently only applies to JTReg.\n+Currently only applies to [JTReg -timeoutFactor](#timeout_factor-1).\n@@ -386,3 +386,5 @@\n-The timeout factor (`-timeoutFactor`).\n-\n-Defaults to 4.\n+The `TIMEOUT_FACTOR` is forwarded to JTReg framework itself\n+(`-timeoutFactor`). Also, some test cases that programmatically wait a\n+certain amount of time will apply this factor. If we run in forced\n+compilation mode (`-Xcomp`), the build system will automatically\n+adjust this factor to compensate for less performance. Defaults to 1.\n","filename":"doc\/testing.md","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -949,1 +949,2 @@\n-  JTREG_AUTO_TIMEOUT_FACTOR := 4\n+  # Please reach consensus before changing this. It was not easy changing it to a `1`.\n+  JTREG_AUTO_TIMEOUT_FACTOR := 1\n","filename":"make\/RunTests.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -224,0 +224,3 @@\n+# Setup static analyzer\n+JDKOPT_SETUP_STATIC_ANALYZER\n+\n","filename":"make\/autoconf\/configure.ac","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -323,0 +323,3 @@\n+    if test \"x$OPENJDK_TARGET_CPU\" != xaarch64; then\n+      AS_NON_ASM_EXTENSION_OPTION=-Ta\n+    fi\n@@ -329,0 +332,1 @@\n+  AC_SUBST(AS_NON_ASM_EXTENSION_OPTION)\n","filename":"make\/autoconf\/flags.m4","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -482,0 +482,25 @@\n+################################################################################\n+#\n+# Static analyzer\n+#\n+AC_DEFUN_ONCE([JDKOPT_SETUP_STATIC_ANALYZER],\n+[\n+  UTIL_ARG_ENABLE(NAME: static-analyzer, DEFAULT: false, RESULT: STATIC_ANALYZER_ENABLED,\n+      DESC: [enable the GCC static analyzer],\n+      CHECK_AVAILABLE: [\n+        AC_MSG_CHECKING([if static analyzer is available])\n+        if test \"x$TOOLCHAIN_TYPE\" = \"xgcc\"; then\n+          AC_MSG_RESULT([yes])\n+        else\n+          AC_MSG_RESULT([no])\n+          AVAILABLE=false\n+        fi\n+      ],\n+      IF_ENABLED: [\n+        STATIC_ANALYZER_CFLAGS=\"-fanalyzer -Wno-analyzer-fd-leak\"\n+        CFLAGS_JDKLIB=\"$CFLAGS_JDKLIB $STATIC_ANALYZER_CFLAGS\"\n+        CFLAGS_JDKEXE=\"$CFLAGS_JDKEXE $STATIC_ANALYZER_CFLAGS\"\n+      ])\n+  AC_SUBST(STATIC_ANALYZER_ENABLED)\n+])\n+\n","filename":"make\/autoconf\/jdk-options.m4","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -495,0 +495,1 @@\n+AS_NON_ASM_EXTENSION_OPTION := @AS_NON_ASM_EXTENSION_OPTION@\n","filename":"make\/autoconf\/spec.gmk.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -158,6 +158,0 @@\n-      else ifeq ($(TOOLCHAIN_TYPE), microsoft)\n-        ifeq ($(OPENJDK_TARGET_CPU), aarch64)\n-          $1_NON_ASM_EXTENSION_FLAG :=\n-        else\n-          $1_NON_ASM_EXTENSION_FLAG := \"-Ta\"\n-        endif\n@@ -245,1 +239,1 @@\n-\t        $(CC_OUT_OPTION)$$($1_OBJ) $$($1_NON_ASM_EXTENSION_FLAG) $$($1_SRC_FILE))) \\\n+\t        $(CC_OUT_OPTION)$$($1_OBJ) $(AS_NON_ASM_EXTENSION_OPTION) $$($1_SRC_FILE))) \\\n","filename":"make\/common\/native\/CompileFile.gmk","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-    LIBS_linux := $(LIBDL), \\\n+    LIBS_linux := $(LIBDL) $(LIBPTHREAD), \\\n@@ -100,1 +100,1 @@\n-      LIBS_linux := $(LIBDL), \\\n+      LIBS_linux := $(LIBDL) $(LIBPTHREAD), \\\n","filename":"make\/modules\/jdk.jpackage\/Lib.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+  echo \"-b     Specifies the base reference for change set lookup.\"\n@@ -66,1 +67,1 @@\n-  echo \"       as specified by -y.\"\n+  echo \"       as specified by -y. Overrides -b flag.\"\n@@ -72,0 +73,1 @@\n+base_reference=master\n@@ -74,1 +76,1 @@\n-while getopts \"c:fhy:\" option; do\n+while getopts \"b:c:fhy:\" option; do\n@@ -76,0 +78,3 @@\n+    b) # supplied base reference\n+      base_reference=${OPTARG}\n+      ;;\n@@ -114,1 +119,1 @@\n-    vcs_list_changesets=(git log --no-merges 'master..HEAD' --since=\"${year}-01-01T00:00:00Z\" --until=\"${year}-12-31T23:59:59Z\" --pretty=tformat:\"%H\")\n+    vcs_list_changesets=(git log --no-merges \"${base_reference}..HEAD\" --since=\"${year}-01-01T00:00:00Z\" --until=\"${year}-12-31T23:59:59Z\" --pretty=tformat:\"%H\")\n","filename":"make\/scripts\/update_copyright_year.sh","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+#!\/bin\/sh\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+\n+# The output of this script may require some degree of human curation:\n+# - Redundant headers, e.g. both x.hpp, x.inline.hpp are included;\n+# - Headers relative to a non-default feature should be protected by an\n+#   appropriate 'if' clause to make sure all variants can build without \n+#   errors.\n+\n+# Time threshold for header compilation, if the time exceeds the\n+# threshold the header will be precompiled.\n+if [ -z \"$MIN_MS\" ]; then\n+  MIN_MS=100000\n+fi\n+\n+if [ -z \"$CLEAN\" ]; then\n+  CLEAN=true\n+elif [ \"$CLEAN\" != \"true\" ] && [ \"$CLEAN\" != \"false\" ]; then\n+  echo \"Expected either 'true' or 'false' for CLEAN\"\n+fi\n+\n+# CBA_PATH should point to a valid ClangBuildAnalyzer executable.\n+# Build steps:\n+# git clone --depth 1 git@github.com:aras-p\/ClangBuildAnalyzer.git\n+# cd ClangBuildAnalyzer\n+# make -f projects\/make\/Makefile\n+if [ -z \"$CBA_PATH\" ]; then\n+  CBA_PATH=\".\/ClangBuildAnalyzer\/build\/ClangBuildAnalyzer\"\n+fi\n+\n+set -eux\n+\n+PRECOMPILED_HPP=\"src\/hotspot\/share\/precompiled\/precompiled.hpp\"\n+CBA_CONFIG=\"ClangBuildAnalyzer.ini\"\n+TIMESTAMP=\"$(date +%Y%m%d-%H%M)\"\n+RUN_NAME=\"pch_update_$TIMESTAMP\"\n+CBA_OUTPUT=\"cba_out_$TIMESTAMP\"\n+\n+if [ \"$CLEAN\" = \"true\" ]; then\n+  trap 'rm -rf \"build\/'\"$RUN_NAME\"'\" \"$CBA_OUTPUT\" \"$CBA_CONFIG\"' EXIT\n+fi\n+\n+sh configure --with-toolchain-type=clang \\\n+             --with-conf-name=\"$RUN_NAME\" \\\n+             --disable-precompiled-headers \\\n+             --with-extra-cxxflags=\"-ftime-trace\" \\\n+             --with-extra-cflags=\"-ftime-trace\"\n+\n+make clean CONF_NAME=\"$RUN_NAME\"\n+make hotspot CONF_NAME=\"$RUN_NAME\"\n+\"$CBA_PATH\" --all \".\/build\/$RUN_NAME\/hotspot\/variant-server\/libjvm\/objs\" \\\n+  \"$CBA_OUTPUT\"\n+\n+# Preserve license and comments on top\n+cat \"$PRECOMPILED_HPP\" | awk '\/^#include\/ {exit} {print}' > \"$PRECOMPILED_HPP.tmp\"\n+\n+if [ ! -f \"$CBA_CONFIG\" ]; then\n+cat <<EOF > \"$CBA_CONFIG\"\n+[counts]\n+header=100\n+headerChain=0\n+template=0\n+function=0\n+fileCodegen=0\n+fileParse=0\n+\n+[misc]\n+onlyRootHeaders=true\n+EOF\n+fi\n+\n+\"$CBA_PATH\" --analyze \"$CBA_OUTPUT\" | \\\n+  grep \" ms: \" | \\\n+  # Keep the headers more expensive than ${1}ms\n+  awk -v x=\"$MIN_MS\" '$1 < x { exit } { print $3 }' | \\\n+  # Filter away non-hotspot headers\n+  grep hotspot\/share | \\\n+  awk -F \"hotspot\/share\/\" '{ printf \"#include \\\"%s\\\"\\n\", $2 }' \\\n+  >> \"$PRECOMPILED_HPP.tmp\"\n+mv \"$PRECOMPILED_HPP.tmp\" \"$PRECOMPILED_HPP\"\n+\n+java test\/hotspot\/jtreg\/sources\/SortIncludes.java --update \"$PRECOMPILED_HPP\"\n","filename":"make\/scripts\/update_pch.sh","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -141,0 +141,1 @@\n+      LIBS := $(LIBPTHREAD), \\\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4415,1 +4415,1 @@\n-operand immI8_shift8()\n+operand immIDupV()\n@@ -4417,2 +4417,1 @@\n-  predicate((n->get_int() <= 127 && n->get_int() >= -128) ||\n-            (n->get_int() <= 32512 && n->get_int() >= -32768 && (n->get_int() & 0xff) == 0));\n+  predicate(Assembler::operand_valid_for_sve_dup_immediate((int64_t)n->get_int()));\n@@ -4427,1 +4426,1 @@\n-operand immL8_shift8()\n+operand immLDupV()\n@@ -4429,2 +4428,1 @@\n-  predicate((n->get_long() <= 127 && n->get_long() >= -128) ||\n-            (n->get_long() <= 32512 && n->get_long() >= -32768 && (n->get_long() & 0xff) == 0));\n+  predicate(Assembler::operand_valid_for_sve_dup_immediate(n->get_long()));\n@@ -4438,0 +4436,11 @@\n+\/\/ 8 bit signed value (simm8), or #simm8 LSL 8.\n+operand immHDupV()\n+%{\n+  predicate(Assembler::operand_valid_for_sve_dup_immediate((int64_t)n->geth()));\n+  match(ConH);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -7080,3 +7089,0 @@\n-\/\/ The \"ldr\" instruction loads a 32-bit word from the constant pool into a\n-\/\/ 32-bit register but only the bottom half will be populated and the top\n-\/\/ 16 bits are zero.\n@@ -7085,3 +7091,3 @@\n-  format %{\n-    \"ldrs $dst, [$constantaddress]\\t# load from constant table: half float=$con\\n\\t\"\n-  %}\n+  format %{ \"mov    rscratch1, $con\\n\\t\"\n+            \"fmov   $dst, rscratch1\"\n+         %}\n@@ -7089,1 +7095,2 @@\n-    __ ldrs(as_FloatRegister($dst$$reg), $constantaddress($con));\n+    __ movw(rscratch1, (uint32_t)$con$$constant);\n+    __ fmovs($dst$$FloatRegister, rscratch1);\n@@ -7091,1 +7098,1 @@\n-  ins_pipe(fp_load_constant_s);\n+  ins_pipe(pipe_class_default);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -4878,1 +4878,1 @@\n-instruct replicateI_imm8_gt128b(vReg dst, immI8_shift8 con) %{\n+instruct replicateI_imm8_gt128b(vReg dst, immIDupV con) %{\n@@ -4901,1 +4901,1 @@\n-instruct replicateL_imm8_gt128b(vReg dst, immL8_shift8 con) %{\n+instruct replicateL_imm8_gt128b(vReg dst, immLDupV con) %{\n@@ -4912,2 +4912,3 @@\n-\/\/ Replicate a 16-bit half precision float value\n-instruct replicateHF_imm(vReg dst, immH con) %{\n+\/\/ Replicate an immediate 16-bit half precision float value\n+instruct replicateHF_imm_le128b(vReg dst, immH con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n@@ -4915,1 +4916,1 @@\n-  format %{ \"replicateHF_imm $dst, $con\\t# replicate immediate half-precision float\" %}\n+  format %{ \"replicateHF_imm_le128b $dst, $con\\t# vector <= 128 bits\" %}\n@@ -4917,1 +4918,0 @@\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -4919,6 +4919,14 @@\n-    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n-      __ mov($dst$$FloatRegister, get_arrangement(this), imm);\n-    } else { \/\/ length_in_bytes must be > 16 and SVE should be enabled\n-      assert(UseSVE > 0, \"must be sve\");\n-      __ sve_dup($dst$$FloatRegister, __ H, imm);\n-    }\n+    __ mov($dst$$FloatRegister, get_arrangement(this), imm);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Replicate a 16-bit half precision float which is within the limits\n+\/\/ for the operand - immHDupV\n+instruct replicateHF_imm8_gt128b(vReg dst, immHDupV con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (Replicate con));\n+  format %{ \"replicateHF_imm8_gt128b $dst, $con\\t# vector > 128 bits\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_dup($dst$$FloatRegister, __ H, (int)($con$$constant));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3110,1 +3110,1 @@\n-instruct replicateI_imm8_gt128b(vReg dst, immI8_shift8 con) %{\n+instruct replicateI_imm8_gt128b(vReg dst, immIDupV con) %{\n@@ -3133,1 +3133,1 @@\n-instruct replicateL_imm8_gt128b(vReg dst, immL8_shift8 con) %{\n+instruct replicateL_imm8_gt128b(vReg dst, immLDupV con) %{\n@@ -3144,2 +3144,3 @@\n-\/\/ Replicate a 16-bit half precision float value\n-instruct replicateHF_imm(vReg dst, immH con) %{\n+\/\/ Replicate an immediate 16-bit half precision float value\n+instruct replicateHF_imm_le128b(vReg dst, immH con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n@@ -3147,1 +3148,1 @@\n-  format %{ \"replicateHF_imm $dst, $con\\t# replicate immediate half-precision float\" %}\n+  format %{ \"replicateHF_imm_le128b $dst, $con\\t# vector <= 128 bits\" %}\n@@ -3149,1 +3150,0 @@\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -3151,6 +3151,14 @@\n-    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n-      __ mov($dst$$FloatRegister, get_arrangement(this), imm);\n-    } else { \/\/ length_in_bytes must be > 16 and SVE should be enabled\n-      assert(UseSVE > 0, \"must be sve\");\n-      __ sve_dup($dst$$FloatRegister, __ H, imm);\n-    }\n+    __ mov($dst$$FloatRegister, get_arrangement(this), imm);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Replicate a 16-bit half precision float which is within the limits\n+\/\/ for the operand - immHDupV\n+instruct replicateHF_imm8_gt128b(vReg dst, immHDupV con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (Replicate con));\n+  format %{ \"replicateHF_imm8_gt128b $dst, $con\\t# vector > 128 bits\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_dup($dst$$FloatRegister, __ H, (int)($con$$constant));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -437,0 +437,5 @@\n+bool Assembler::operand_valid_for_sve_dup_immediate(int64_t imm) {\n+  return ((imm >= -128 && imm <= 127) ||\n+          (((imm & 0xff) == 0) && imm >= -32768 && imm <= 32512));\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4327,0 +4327,1 @@\n+  static bool operand_valid_for_sve_dup_immediate(int64_t imm);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -705,1 +705,1 @@\n-    snprintf(buf, sizeof buf, \"(bad)\");\n+    os::snprintf_checked(buf, sizeof buf, \"(bad)\");\n@@ -708,1 +708,1 @@\n-    snprintf(buf, sizeof buf, \"%d\", bci);\n+    os::snprintf_checked(buf, sizeof buf, \"%d\", bci);\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2262,1 +2262,1 @@\n-    snprintf(buffer, sizeof(buffer), \"0x%\" PRIX64, (uint64_t)imm64);\n+    os::snprintf_checked(buffer, sizeof(buffer), \"0x%\" PRIX64, (uint64_t)imm64);\n@@ -2320,1 +2320,1 @@\n-    snprintf(buffer, sizeof(buffer), \"0x%\" PRIX64, imm64);\n+    os::snprintf_checked(buffer, sizeof(buffer), \"0x%\" PRIX64, imm64);\n@@ -2433,1 +2433,1 @@\n-      snprintf(buffer, sizeof(buffer), \"0x%\" PRIX32, imm32);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"0x%\" PRIX32, imm32);\n@@ -2905,1 +2905,1 @@\n-      snprintf(buffer, sizeof(buffer), \"push_fp: %d SVE registers\", count);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"push_fp: %d SVE registers\", count);\n@@ -2907,1 +2907,1 @@\n-      snprintf(buffer, sizeof(buffer), \"push_fp: %d Neon registers\", count);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"push_fp: %d Neon registers\", count);\n@@ -2909,1 +2909,1 @@\n-      snprintf(buffer, sizeof(buffer), \"push_fp: %d fp registers\", count);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"push_fp: %d fp registers\", count);\n@@ -3017,1 +3017,1 @@\n-      snprintf(buffer, sizeof(buffer), \"pop_fp: %d SVE registers\", count);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"pop_fp: %d SVE registers\", count);\n@@ -3019,1 +3019,1 @@\n-      snprintf(buffer, sizeof(buffer), \"pop_fp: %d Neon registers\", count);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"pop_fp: %d Neon registers\", count);\n@@ -3021,1 +3021,1 @@\n-      snprintf(buffer, sizeof(buffer), \"pop_fp: %d fp registers\", count);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"pop_fp: %d fp registers\", count);\n@@ -5923,1 +5923,1 @@\n-    snprintf(comment, sizeof comment, \"array_equals%c{\", kind);\n+    os::snprintf_checked(comment, sizeof comment, \"array_equals%c{\", kind);\n@@ -6121,1 +6121,1 @@\n-    snprintf(comment, sizeof comment, \"{string_equalsL\");\n+    os::snprintf_checked(comment, sizeof comment, \"{string_equalsL\");\n@@ -6269,1 +6269,1 @@\n-      snprintf(buf, sizeof buf, \"zero_words (count = %\" PRIu64 \") {\", cnt);\n+      os::snprintf_checked(buf, sizeof buf, \"zero_words (count = %\" PRIu64 \") {\", cnt);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -724,1 +724,1 @@\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"AArch64\");\n+  os::snprintf_checked(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"AArch64\");\n@@ -726,1 +726,1 @@\n-  int desc_len = snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"AArch64 \");\n+  int desc_len = os::snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"AArch64 \");\n@@ -729,1 +729,1 @@\n-  snprintf(_cpu_desc + desc_len, CPU_DETAILED_DESC_BUF_SIZE - desc_len, \" %s\", _cpu_info_string);\n+  os::snprintf_checked(_cpu_desc + desc_len, CPU_DETAILED_DESC_BUF_SIZE - desc_len, \" %s\", _cpu_info_string);\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -842,1 +842,1 @@\n-    snprintf(buffer, sizeof(buffer), \"verify_oop at %d\", offset());\n+    os::snprintf_checked(buffer, sizeof(buffer), \"verify_oop at %d\", offset());\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -365,2 +365,2 @@\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"ARM%d\", _arm_arch);\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _cpu_info_string);\n+  os::snprintf_checked(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"ARM%d\", _arm_arch);\n+  os::snprintf_checked(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _cpu_info_string);\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm_32.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -628,2 +628,2 @@\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE, \"PowerPC POWER%lu\", PowerArchitecturePPC64);\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"PPC %s\", cpu_info_string());\n+  os::snprintf_checked(_cpu_name, CPU_TYPE_DESC_BUF_SIZE, \"PowerPC POWER%lu\", PowerArchitecturePPC64);\n+  os::snprintf_checked(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"PPC %s\", cpu_info_string());\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1991,0 +1991,1 @@\n+  INSN(vnsrl_wi, 0b1010111, 0b011, 0b101100);\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2251,1 +2251,3 @@\n-  VectorRegister tmp = stub.data<2>();\n+  VectorRegister vtmp = stub.data<2>();\n+  assert_different_registers(dst, src, vtmp);\n+\n@@ -2254,0 +2256,1 @@\n+  \/\/ Active elements (NaNs) are marked in v0 mask register.\n@@ -2256,11 +2259,47 @@\n-  \/\/ preserve the payloads of non-canonical NaNs.\n-  __ vnsra_wi(dst, src, 13, Assembler::v0_t);\n-\n-  \/\/ preserve the sign bit.\n-  __ vnsra_wi(tmp, src, 26, Assembler::v0_t);\n-  __ vsll_vi(tmp, tmp, 10, Assembler::v0_t);\n-  __ mv(t0, 0x3ff);\n-  __ vor_vx(tmp, tmp, t0, Assembler::v0_t);\n-\n-  \/\/ get the result by merging sign bit and payloads of preserved non-canonical NaNs.\n-  __ vand_vv(dst, dst, tmp, Assembler::v0_t);\n+  \/\/  Float (32 bits)\n+  \/\/    Bit:     31        30 to 23          22 to 0\n+  \/\/          +---+------------------+-----------------------------+\n+  \/\/          | S |     Exponent     |      Mantissa (Fraction)    |\n+  \/\/          +---+------------------+-----------------------------+\n+  \/\/          1 bit       8 bits                  23 bits\n+  \/\/\n+  \/\/  Float (16 bits)\n+  \/\/    Bit:    15        14 to 10         9 to 0\n+  \/\/          +---+----------------+------------------+\n+  \/\/          | S |    Exponent    |     Mantissa     |\n+  \/\/          +---+----------------+------------------+\n+  \/\/          1 bit      5 bits          10 bits\n+  const int fp_sign_bits = 1;\n+  const int fp32_bits = 32;\n+  const int fp32_mantissa_2nd_part_bits = 9;\n+  const int fp32_mantissa_3rd_part_bits = 4;\n+  const int fp16_exponent_bits = 5;\n+  const int fp16_mantissa_bits = 10;\n+\n+  \/\/ preserve the sign bit and exponent, clear mantissa.\n+  __ vnsra_wi(dst, src, fp32_bits - fp_sign_bits - fp16_exponent_bits, Assembler::v0_t);\n+  __ vsll_vi(dst, dst, fp16_mantissa_bits, Assembler::v0_t);\n+\n+  \/\/ Preserve high order bit of float NaN in the\n+  \/\/ binary16 result NaN (tenth bit); OR in remaining\n+  \/\/ bits into lower 9 bits of binary 16 significand.\n+  \/\/   | (doppel & 0x007f_e000) >> 13 \/\/ 10 bits\n+  \/\/   | (doppel & 0x0000_1ff0) >> 4  \/\/  9 bits\n+  \/\/   | (doppel & 0x0000_000f));     \/\/  4 bits\n+  \/\/\n+  \/\/ Check j.l.Float.floatToFloat16 for more information.\n+  \/\/ 10 bits\n+  __ vnsrl_wi(vtmp, src, fp32_mantissa_2nd_part_bits + fp32_mantissa_3rd_part_bits, Assembler::v0_t);\n+  __ mv(t0, 0x3ff); \/\/ retain first part of mantissa in a float 32\n+  __ vand_vx(vtmp, vtmp, t0, Assembler::v0_t);\n+  __ vor_vv(dst, dst, vtmp, Assembler::v0_t);\n+  \/\/ 9 bits\n+  __ vnsrl_wi(vtmp, src, fp32_mantissa_3rd_part_bits, Assembler::v0_t);\n+  __ mv(t0, 0x1ff); \/\/ retain second part of mantissa in a float 32\n+  __ vand_vx(vtmp, vtmp, t0, Assembler::v0_t);\n+  __ vor_vv(dst, dst, vtmp, Assembler::v0_t);\n+  \/\/ 4 bits\n+  \/\/ Narrow shift is necessary to move data from 32 bits element to 16 bits element in vector register.\n+  __ vnsrl_wi(vtmp, src, 0, Assembler::v0_t);\n+  __ vand_vi(vtmp, vtmp, 0xf, Assembler::v0_t);\n+  __ vor_vv(dst, dst, vtmp, Assembler::v0_t);\n@@ -2273,2 +2312,2 @@\n-void C2_MacroAssembler::float_to_float16_v(VectorRegister dst, VectorRegister src, VectorRegister vtmp,\n-                                           Register tmp, uint vector_length) {\n+void C2_MacroAssembler::float_to_float16_v(VectorRegister dst, VectorRegister src,\n+                                           VectorRegister vtmp, Register tmp, uint vector_length) {\n@@ -2278,1 +2317,1 @@\n-              (dst, src, vtmp, 28, float_to_float16_v_slow_path);\n+              (dst, src, vtmp, 56, float_to_float16_v_slow_path);\n@@ -2285,1 +2324,1 @@\n-  \/\/ replace v_fclass with vmseq_vv as performance optimization.\n+  \/\/ replace v_fclass with vmfne_vv as performance optimization.\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":55,"deletions":16,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2682,1 +2682,1 @@\n-    snprintf(buffer, sizeof(buffer), \"0x%\" PRIx64, uimm64);\n+    os::snprintf_checked(buffer, sizeof(buffer), \"0x%\" PRIx64, uimm64);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -496,2 +496,2 @@\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"RISCV64\");\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"RISCV64 %s\", cpu_info_string());\n+  os::snprintf_checked(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"RISCV64\");\n+  os::snprintf_checked(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"RISCV64 %s\", cpu_info_string());\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1552,2 +1552,2 @@\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE, \"s390 %s\", VM_Version::get_model_string());\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"s390 %s\", cpu_info_string());\n+  os::snprintf_checked(_cpu_name, CPU_TYPE_DESC_BUF_SIZE, \"s390 %s\", VM_Version::get_model_string());\n+  os::snprintf_checked(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"s390 %s\", cpu_info_string());\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4334,1 +4334,1 @@\n-      snprintf(ebuf_, sizeof(ebuf_), VM_Version::supports_avx512_simd_sort() ? \"avx512_sort\" : \"avx2_sort\");\n+      os::snprintf_checked(ebuf_, sizeof(ebuf_), VM_Version::supports_avx512_simd_sort() ? \"avx512_sort\" : \"avx2_sort\");\n@@ -4337,1 +4337,1 @@\n-      snprintf(ebuf_, sizeof(ebuf_), VM_Version::supports_avx512_simd_sort() ? \"avx512_partition\" : \"avx2_partition\");\n+      os::snprintf_checked(ebuf_, sizeof(ebuf_), VM_Version::supports_avx512_simd_sort() ? \"avx512_partition\" : \"avx2_partition\");\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1668,1 +1668,1 @@\n-    if (MaxVectorSize < 32 || !VM_Version::supports_avx512vlbw()) {\n+    if (MaxVectorSize < 32 || (!EnableX86ECoreOpts && !VM_Version::supports_avx512vlbw())) {\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -245,2 +245,2 @@\n-    snprintf(fieldbuf, buflen, \"word[%d]\", offset);\n-    snprintf(valuebuf, buflen, PTR_FORMAT, *addr);\n+    os::snprintf_checked(fieldbuf, buflen, \"word[%d]\", offset);\n+    os::snprintf_checked(valuebuf, buflen, PTR_FORMAT, *addr);\n@@ -303,1 +303,1 @@\n-    snprintf(fieldbuf, buflen, \"local[%d]\", offset - 3);\n+    os::snprintf_checked(fieldbuf, buflen, \"local[%d]\", offset - 3);\n@@ -324,3 +324,3 @@\n-        snprintf(valuebuf, buflen, PTR_FORMAT \" (bci %d)\",\n-                 (intptr_t) istate->bcp(),\n-                 istate->method()->bci_from(istate->bcp()));\n+        os::snprintf_checked(valuebuf, buflen, PTR_FORMAT \" (bci %d)\",\n+                             (intptr_t) istate->bcp(),\n+                             istate->method()->bci_from(istate->bcp()));\n@@ -328,2 +328,2 @@\n-      snprintf(fieldbuf, buflen, \"%sistate->%s\",\n-               field[strlen(field) - 1] == ')' ? \"(\": \"\", field);\n+      os::snprintf_checked(fieldbuf, buflen, \"%sistate->%s\",\n+                           field[strlen(field) - 1] == ')' ? \"(\": \"\", field);\n@@ -361,1 +361,1 @@\n-          snprintf(fieldbuf, buflen, \"parameter[%d]%s\", param, desc);\n+          os::snprintf_checked(fieldbuf, buflen, \"parameter[%d]%s\", param, desc);\n@@ -367,1 +367,1 @@\n-            snprintf(fieldbuf, buflen, \"unboxed parameter[%d]\", i);\n+            os::snprintf_checked(fieldbuf, buflen, \"unboxed parameter[%d]\", i);\n@@ -399,1 +399,1 @@\n-      snprintf(fieldbuf, buflen, \"monitor[%d]->_obj\", index);\n+      os::snprintf_checked(fieldbuf, buflen, \"monitor[%d]->_obj\", index);\n@@ -401,1 +401,1 @@\n-      snprintf(fieldbuf, buflen, \"monitor[%d]->_lock\", index);\n+      os::snprintf_checked(fieldbuf, buflen, \"monitor[%d]->_lock\", index);\n@@ -408,3 +408,3 @@\n-    snprintf(fieldbuf, buflen, \"%s[%d]\",\n-             frame_index == 0 ? \"stack_word\" : \"local\",\n-             (int) (stack_base - addr - 1));\n+    os::snprintf_checked(fieldbuf, buflen, \"%s[%d]\",\n+                         frame_index == 0 ? \"stack_word\" : \"local\",\n+                         (int) (stack_base - addr - 1));\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -153,2 +153,2 @@\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"Zero VM\");\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _cpu_info_string);\n+  os::snprintf_checked(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"Zero VM\");\n+  os::snprintf_checked(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _cpu_info_string);\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -212,2 +212,2 @@\n-  int n = snprintf(path, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n-                   os::get_temp_directory(), os::current_process_id());\n+  int n = os::snprintf(path, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n+                       os::get_temp_directory(), os::current_process_id());\n@@ -215,1 +215,1 @@\n-    n = snprintf(initial_path, UNIX_PATH_MAX, \"%s.tmp\", path);\n+    n = os::snprintf(initial_path, UNIX_PATH_MAX, \"%s.tmp\", path);\n@@ -352,3 +352,2 @@\n-  int n = snprintf(fn, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n-           os::get_temp_directory(), os::current_process_id());\n-  assert(n < (int)UNIX_PATH_MAX, \"java_pid file name buffer overflow\");\n+  os::snprintf_checked(fn, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n+                       os::get_temp_directory(), os::current_process_id());\n@@ -422,2 +421,2 @@\n-    snprintf(fn, sizeof(fn), \"%s\/.attach_pid%d\",\n-             os::get_temp_directory(), os::current_process_id());\n+    os::snprintf_checked(fn, sizeof(fn), \"%s\/.attach_pid%d\",\n+                         os::get_temp_directory(), os::current_process_id());\n","filename":"src\/hotspot\/os\/aix\/attachListener_aix.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-julong    os::Aix::_physical_memory = 0;\n+size_t    os::Aix::_physical_memory = 0;\n@@ -257,2 +257,2 @@\n-julong os::free_memory() {\n-  return Aix::available_memory();\n+bool os::free_memory(size_t& value) {\n+  return Aix::available_memory(value);\n@@ -261,2 +261,2 @@\n-julong os::available_memory() {\n-  return Aix::available_memory();\n+bool os::available_memory(size_t& value) {\n+  return Aix::available_memory(value);\n@@ -265,1 +265,1 @@\n-julong os::Aix::available_memory() {\n+bool os::Aix::available_memory(size_t& value) {\n@@ -268,1 +268,2 @@\n-    return mi.real_free;\n+    value = static_cast<size_t>(mi.real_free);\n+    return true;\n@@ -270,1 +271,1 @@\n-    return ULONG_MAX;\n+    return false;\n@@ -274,1 +275,1 @@\n-jlong os::total_swap_space() {\n+bool os::total_swap_space(size_t& value) {\n@@ -277,1 +278,1 @@\n-    return -1;\n+    return false;\n@@ -279,1 +280,2 @@\n-  return (jlong)(memory_info.pgsp_total * 4 * K);\n+  value = static_cast<size_t>(memory_info.pgsp_total * 4 * K);\n+  return true;\n@@ -282,1 +284,1 @@\n-jlong os::free_swap_space() {\n+bool os::free_swap_space(size_t& value) {\n@@ -285,1 +287,1 @@\n-    return -1;\n+    return false;\n@@ -287,1 +289,2 @@\n-  return (jlong)(memory_info.pgsp_free * 4 * K);\n+  value = static_cast<size_t>(memory_info.pgsp_free * 4 * K);\n+  return true;\n@@ -290,1 +293,1 @@\n-julong os::physical_memory() {\n+size_t os::physical_memory() {\n@@ -329,1 +332,1 @@\n-  _physical_memory = (julong) mi.real_total;\n+  _physical_memory = static_cast<size_t>(mi.real_total);\n@@ -1054,2 +1057,2 @@\n-      snprintf(ebuf, ebuflen - 1, \"%s, LIBPATH=%s, LD_LIBRARY_PATH=%s : %s\",\n-               filename, ::getenv(\"LIBPATH\"), ::getenv(\"LD_LIBRARY_PATH\"), error_report);\n+      os::snprintf_checked(ebuf, ebuflen - 1, \"%s, LIBPATH=%s, LD_LIBRARY_PATH=%s : %s\",\n+                           filename, ::getenv(\"LIBPATH\"), ::getenv(\"LD_LIBRARY_PATH\"), error_report);\n@@ -1080,1 +1083,1 @@\n-      os::snprintf(tmp_path + prefix_size, sizeof(old_extension), \"%s\", new_extension);\n+      os::snprintf_checked(tmp_path + prefix_size, sizeof(old_extension), \"%s\", new_extension);\n@@ -1097,1 +1100,1 @@\n-  snprintf(buf, buflen, \"%s %s\", name.release, name.version);\n+  os::snprintf_checked(buf, buflen, \"%s %s\", name.release, name.version);\n@@ -2196,1 +2199,1 @@\n-  trcVerbose(\"physical memory: %lu\", Aix::_physical_memory);\n+  trcVerbose(\"physical memory: %zu\", Aix::_physical_memory);\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":24,"deletions":21,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  static julong _physical_memory;\n+  static size_t _physical_memory;\n@@ -57,3 +57,3 @@\n-  static julong available_memory();\n-  static julong free_memory();\n-  static julong physical_memory() { return _physical_memory; }\n+  static bool available_memory(size_t& value);\n+  static bool free_memory(size_t& value);\n+  static size_t physical_memory() { return _physical_memory; }\n","filename":"src\/hotspot\/os\/aix\/os_aix.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -939,1 +939,1 @@\n-  snprintf(buffer, 100, \"\/proc\/%ld\/object\/a.out\", (long)getpid());\n+  os::snprintf_checked(buffer, 100, \"\/proc\/%ld\/object\/a.out\", (long)getpid());\n@@ -1157,1 +1157,1 @@\n-        snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n+        os::snprintf_checked(ebuf, ebuflen - 1, \"%s\", error_report);\n@@ -1192,1 +1192,0 @@\n-\n","filename":"src\/hotspot\/os\/aix\/porting_aix.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-        snprintf(buffer, sizeof(buffer), \"user_tag=0x%x(%d)\", user_tag, user_tag);\n+        os::snprintf_checked(buffer, sizeof(buffer), \"user_tag=0x%x(%d)\", user_tag, user_tag);\n","filename":"src\/hotspot\/os\/bsd\/memMapPrinter_macosx.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-julong os::Bsd::_physical_memory = 0;\n+size_t os::Bsd::_physical_memory = 0;\n@@ -136,2 +136,2 @@\n-julong os::available_memory() {\n-  return Bsd::available_memory();\n+bool os::available_memory(size_t& value) {\n+  return Bsd::available_memory(value);\n@@ -140,2 +140,2 @@\n-julong os::free_memory() {\n-  return Bsd::available_memory();\n+bool os::free_memory(size_t& value) {\n+  return Bsd::available_memory(value);\n@@ -147,2 +147,2 @@\n-julong os::Bsd::available_memory() {\n-  uint64_t available = physical_memory() >> 2;\n+bool os::Bsd::available_memory(size_t& value) {\n+  uint64_t available = static_cast<uint64_t>(physical_memory() >> 2);\n@@ -159,0 +159,2 @@\n+  } else {\n+    return false;\n@@ -161,1 +163,2 @@\n-  return available;\n+  value = static_cast<size_t>(available);\n+  return true;\n@@ -180,1 +183,1 @@\n-jlong os::total_swap_space() {\n+bool os::total_swap_space(size_t& value) {\n@@ -185,1 +188,1 @@\n-    return -1;\n+    return false;\n@@ -187,1 +190,2 @@\n-  return (jlong)vmusage.xsu_total;\n+  value = static_cast<size_t>(vmusage.xsu_total);\n+  return true;\n@@ -189,1 +193,1 @@\n-  return -1;\n+  return false;\n@@ -193,1 +197,1 @@\n-jlong os::free_swap_space() {\n+bool os::free_swap_space(size_t& value) {\n@@ -198,1 +202,1 @@\n-    return -1;\n+    return false;\n@@ -200,1 +204,2 @@\n-  return (jlong)vmusage.xsu_avail;\n+  value = static_cast<size_t>(vmusage.xsu_avail);\n+  return true;\n@@ -202,1 +207,1 @@\n-  return -1;\n+  return false;\n@@ -206,1 +211,1 @@\n-julong os::physical_memory() {\n+size_t os::physical_memory() {\n@@ -284,1 +289,1 @@\n-    _physical_memory = mem_val;\n+    _physical_memory = static_cast<size_t>(mem_val);\n@@ -295,1 +300,1 @@\n-    _physical_memory = MIN2(_physical_memory, (julong)limits.rlim_cur);\n+    _physical_memory = MIN2(_physical_memory, static_cast<size_t>(limits.rlim_cur));\n@@ -525,1 +530,1 @@\n-          user_home_dir, Arguments::get_java_home());\n+                       user_home_dir, Arguments::get_java_home());\n@@ -1245,1 +1250,1 @@\n-    ::snprintf(diag_msg_buf, diag_msg_max_length-1,\" (Possible cause: endianness mismatch)\");\n+    os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1,\" (Possible cause: endianness mismatch)\");\n@@ -1251,1 +1256,1 @@\n-    ::snprintf(diag_msg_buf, diag_msg_max_length-1,\" (Possible cause: architecture word width mismatch)\");\n+    os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1,\" (Possible cause: architecture word width mismatch)\");\n@@ -1258,3 +1263,3 @@\n-      ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n-                 \" (Possible cause: can't load %s-bit .so on a %s-bit platform)\",\n-                 lib_arch.name, arch_array[running_arch_index].name);\n+      os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1,\n+                           \" (Possible cause: can't load %s-bit .so on a %s-bit platform)\",\n+                           lib_arch.name, arch_array[running_arch_index].name);\n@@ -1262,4 +1267,4 @@\n-      ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n-                 \" (Possible cause: can't load this .so (machine code=0x%x) on a %s-bit platform)\",\n-                 lib_arch.code,\n-                 arch_array[running_arch_index].name);\n+      os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1,\n+                           \" (Possible cause: can't load this .so (machine code=0x%x) on a %s-bit platform)\",\n+                           lib_arch.code,\n+                           arch_array[running_arch_index].name);\n@@ -1367,1 +1372,1 @@\n-      snprintf(buf, buflen, \"%s %s, macOS %s\", os, release, osproductversion);\n+      os::snprintf_checked(buf, buflen, \"%s %s, macOS %s\", os, release, osproductversion);\n@@ -1369,1 +1374,1 @@\n-      snprintf(buf, buflen, \"%s %s, macOS %s (%s)\", os, release, osproductversion, build);\n+      os::snprintf_checked(buf, buflen, \"%s %s, macOS %s (%s)\", os, release, osproductversion, build);\n@@ -1373,1 +1378,1 @@\n-  snprintf(buf, buflen, \"%s %s\", os, release);\n+  os::snprintf_checked(buf, buflen, \"%s %s\", os, release);\n@@ -1450,1 +1455,1 @@\n-    snprintf(buf, buflen, \"\\\"%s\\\" %s (EMULATED) %d MHz\", model, machine, mhz);\n+    os::snprintf_checked(buf, buflen, \"\\\"%s\\\" %s (EMULATED) %d MHz\", model, machine, mhz);\n@@ -1452,1 +1457,1 @@\n-    NOT_AARCH64(snprintf(buf, buflen, \"\\\"%s\\\" %s %d MHz\", model, machine, mhz));\n+    NOT_AARCH64(os::snprintf_checked(buf, buflen, \"\\\"%s\\\" %s %d MHz\", model, machine, mhz));\n@@ -1454,1 +1459,1 @@\n-    AARCH64_ONLY(snprintf(buf, buflen, \"\\\"%s\\\" %s\", model, machine));\n+    AARCH64_ONLY(os::snprintf_checked(buf, buflen, \"\\\"%s\\\" %s\", model, machine));\n@@ -1457,1 +1462,1 @@\n-  snprintf(buf, buflen, \"\\\"%s\\\" %s %d MHz\", model, machine, mhz);\n+  os::snprintf_checked(buf, buflen, \"\\\"%s\\\" %s %d MHz\", model, machine, mhz);\n@@ -1467,5 +1472,7 @@\n-\n-  st->print(\", physical \" UINT64_FORMAT \"k\",\n-            os::physical_memory() >> 10);\n-  st->print(\"(\" UINT64_FORMAT \"k free)\",\n-            os::available_memory() >> 10);\n+  size_t phys_mem = os::physical_memory();\n+  st->print(\", physical %zuk\",\n+            phys_mem >> 10);\n+  size_t avail_mem = 0;\n+  (void)os::available_memory(avail_mem);\n+  st->print(\"(%zuk free)\",\n+            avail_mem >> 10);\n@@ -2159,1 +2166,1 @@\n-    snprintf(buf, sizeof(buf), \"Java: %s\", name);\n+    (void) os::snprintf(buf, sizeof(buf), \"Java: %s\", name);\n@@ -2493,1 +2500,1 @@\n-      snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n+      os::snprintf_checked(ebuf, ebuflen - 1, \"%s\", error_report);\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":50,"deletions":43,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  static julong _physical_memory;\n+  static size_t _physical_memory;\n@@ -48,3 +48,3 @@\n-  static julong available_memory();\n-  static julong free_memory();\n-  static julong physical_memory() { return _physical_memory; }\n+  static bool available_memory(size_t& value);\n+  static bool free_memory(size_t& value);\n+  static size_t physical_memory() { return _physical_memory; }\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -673,2 +673,2 @@\n-  jlong phys_mem = os::Linux::physical_memory();\n-  log_trace(os, container)(\"total physical memory: \" JLONG_FORMAT, phys_mem);\n+  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n+  log_trace(os, container)(\"total physical memory: \" JULONG_FORMAT, phys_mem);\n@@ -844,1 +844,1 @@\n-  julong phys_mem = os::Linux::physical_memory();\n+  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n@@ -850,1 +850,1 @@\n-  julong phys_mem = os::Linux::physical_memory();\n+  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n@@ -856,1 +856,1 @@\n-  julong phys_mem = os::Linux::physical_memory();\n+  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n@@ -897,1 +897,1 @@\n-  julong phys_mem = os::Linux::physical_memory();\n+  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-  julong phys_mem = os::Linux::physical_memory();\n+  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-  sigevent_t sev;\n+  struct sigevent sev;\n","filename":"src\/hotspot\/os\/linux\/compilerThreadTimeout_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -207,1 +207,1 @@\n-  snprintf(filename, sizeof(filename), \"%s%s\", name, ZLargePages::is_explicit() ? \".hugetlb\" : \"\");\n+  os::snprintf_checked(filename, sizeof(filename), \"%s%s\", name, ZLargePages::is_explicit() ? \".hugetlb\" : \"\");\n@@ -265,1 +265,1 @@\n-  snprintf(filename, sizeof(filename), \"%s\/%s.%d\", mountpoint.get(), name, os::current_process_id());\n+  os::snprintf_checked(filename, sizeof(filename), \"%s\/%s.%d\", mountpoint.get(), name, os::current_process_id());\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zPhysicalMemoryBacking_linux.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-julong os::Linux::_physical_memory = 0;\n+size_t os::Linux::_physical_memory = 0;\n@@ -235,2 +235,2 @@\n-julong os::available_memory() {\n-  return Linux::available_memory();\n+bool os::available_memory(size_t& value) {\n+  return Linux::available_memory(value);\n@@ -239,1 +239,1 @@\n-julong os::Linux::available_memory() {\n+bool os::Linux::available_memory(size_t& value) {\n@@ -243,1 +243,2 @@\n-    return avail_mem;\n+    value = static_cast<size_t>(avail_mem);\n+    return true;\n@@ -258,1 +259,5 @@\n-    avail_mem = free_memory();\n+    size_t free_mem = 0;\n+    if (!free_memory(free_mem)) {\n+      return false;\n+    }\n+    avail_mem = static_cast<julong>(free_mem);\n@@ -261,1 +266,2 @@\n-  return avail_mem;\n+  value = static_cast<size_t>(avail_mem);\n+  return true;\n@@ -264,2 +270,2 @@\n-julong os::free_memory() {\n-  return Linux::free_memory();\n+bool os::free_memory(size_t& value) {\n+  return Linux::free_memory(value);\n@@ -268,1 +274,1 @@\n-julong os::Linux::free_memory() {\n+bool os::Linux::free_memory(size_t& value) {\n@@ -274,1 +280,2 @@\n-    return free_mem;\n+    value = static_cast<size_t>(free_mem);\n+    return true;\n@@ -277,1 +284,4 @@\n-  sysinfo(&si);\n+  int ret = sysinfo(&si);\n+  if (ret != 0) {\n+    return false;\n+  }\n@@ -280,1 +290,2 @@\n-  return free_mem;\n+  value = static_cast<size_t>(free_mem);\n+  return true;\n@@ -283,1 +294,1 @@\n-jlong os::total_swap_space() {\n+bool os::total_swap_space(size_t& value) {\n@@ -285,2 +296,5 @@\n-    if (OSContainer::memory_limit_in_bytes() > 0) {\n-      return (jlong)(OSContainer::memory_and_swap_limit_in_bytes() - OSContainer::memory_limit_in_bytes());\n+    jlong memory_and_swap_limit_in_bytes = OSContainer::memory_and_swap_limit_in_bytes();\n+    jlong memory_limit_in_bytes = OSContainer::memory_limit_in_bytes();\n+    if (memory_limit_in_bytes > 0 && memory_and_swap_limit_in_bytes > 0) {\n+      value = static_cast<size_t>(memory_and_swap_limit_in_bytes - memory_limit_in_bytes);\n+      return true;\n@@ -288,1 +302,1 @@\n-  }\n+  } \/\/ fallback to the host swap space if the container did return the unbound value of -1\n@@ -292,1 +306,2 @@\n-    return -1;\n+    assert(false, \"sysinfo failed in total_swap_space(): %s\", os::strerror(errno));\n+    return false;\n@@ -294,1 +309,2 @@\n-  return  (jlong)(si.totalswap * si.mem_unit);\n+  value = static_cast<size_t>(si.totalswap * si.mem_unit);\n+  return true;\n@@ -297,1 +313,1 @@\n-static jlong host_free_swap() {\n+static bool host_free_swap_f(size_t& value) {\n@@ -301,1 +317,2 @@\n-    return -1;\n+    assert(false, \"sysinfo failed in host_free_swap_f(): %s\", os::strerror(errno));\n+    return false;\n@@ -303,1 +320,2 @@\n-  return (jlong)(si.freeswap * si.mem_unit);\n+  value = static_cast<size_t>(si.freeswap * si.mem_unit);\n+  return true;\n@@ -306,1 +324,1 @@\n-jlong os::free_swap_space() {\n+bool os::free_swap_space(size_t& value) {\n@@ -309,2 +327,6 @@\n-  jlong host_free_swap_val = MIN2(os::total_swap_space(), host_free_swap());\n-  assert(host_free_swap_val >= 0, \"sysinfo failed?\");\n+  size_t total_swap_space = 0;\n+  size_t host_free_swap = 0;\n+  if (!os::total_swap_space(total_swap_space) || !host_free_swap_f(host_free_swap)) {\n+    return false;\n+  }\n+  size_t host_free_swap_val = MIN2(total_swap_space, host_free_swap);\n@@ -317,1 +339,2 @@\n-        return 0;\n+        value = 0;\n+        return true;\n@@ -325,1 +348,2 @@\n-          return free_swap >= 0 ? free_swap : 0;\n+          value = free_swap >= 0 ? static_cast<size_t>(free_swap) : 0;\n+          return true;\n@@ -331,1 +355,1 @@\n-                            \" container_mem_limit=\" JLONG_FORMAT \" returning host value: \" JLONG_FORMAT,\n+                            \" container_mem_limit=\" JLONG_FORMAT \" returning host value: %zu\",\n@@ -334,1 +358,2 @@\n-  return host_free_swap_val;\n+  value = host_free_swap_val;\n+  return true;\n@@ -337,2 +362,1 @@\n-julong os::physical_memory() {\n-  jlong phys_mem = 0;\n+size_t os::physical_memory() {\n@@ -343,1 +367,1 @@\n-      return mem_limit;\n+      return static_cast<size_t>(mem_limit);\n@@ -347,2 +371,2 @@\n-  phys_mem = Linux::physical_memory();\n-  log_trace(os)(\"total system memory: \" JLONG_FORMAT, phys_mem);\n+  size_t phys_mem = Linux::physical_memory();\n+  log_trace(os)(\"total system memory: %zu\", phys_mem);\n@@ -523,1 +547,1 @@\n-  _physical_memory = (julong)sysconf(_SC_PHYS_PAGES) * (julong)sysconf(_SC_PAGESIZE);\n+  _physical_memory = static_cast<size_t>(sysconf(_SC_PHYS_PAGES)) * static_cast<size_t>(sysconf(_SC_PAGESIZE));\n@@ -1851,3 +1875,3 @@\n-      ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n-                 \" (Possible cause: can't load %s .so on a %s platform)\",\n-                 lib_arch.name, arch_array[running_arch_index].name);\n+      os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1,\n+                           \" (Possible cause: can't load %s .so on a %s platform)\",\n+                           lib_arch.name, arch_array[running_arch_index].name);\n@@ -1855,3 +1879,3 @@\n-      ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n-                 \" (Possible cause: can't load this .so (machine code=0x%x) on a %s platform)\",\n-                 lib_arch.code, arch_array[running_arch_index].name);\n+      os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1,\n+                           \" (Possible cause: can't load this .so (machine code=0x%x) on a %s platform)\",\n+                           lib_arch.code, arch_array[running_arch_index].name);\n@@ -1863,1 +1887,1 @@\n-    ::snprintf(diag_msg_buf, diag_msg_max_length-1, \" (Possible cause: endianness mismatch)\");\n+    os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1, \" (Possible cause: endianness mismatch)\");\n@@ -1869,1 +1893,1 @@\n-    ::snprintf(diag_msg_buf, diag_msg_max_length-1, \" (Possible cause: invalid ELF file class)\");\n+    os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1, \" (Possible cause: invalid ELF file class)\");\n@@ -1874,3 +1898,3 @@\n-    ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n-               \" (Possible cause: architecture word width mismatch, can't load %d-bit .so on a %d-bit platform)\",\n-               (int) lib_arch.elf_class * 32, arch_array[running_arch_index].elf_class * 32);\n+    os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1,\n+                         \" (Possible cause: architecture word width mismatch, can't load %d-bit .so on a %d-bit platform)\",\n+                         (int) lib_arch.elf_class * 32, arch_array[running_arch_index].elf_class * 32);\n@@ -2551,5 +2575,7 @@\n-\n-  st->print(\", physical \" UINT64_FORMAT \"k\",\n-            os::physical_memory() >> 10);\n-  st->print(\"(\" UINT64_FORMAT \"k free)\",\n-            os::available_memory() >> 10);\n+  size_t phys_mem = physical_memory();\n+  st->print(\", physical %zuk\",\n+            phys_mem >> 10);\n+  size_t avail_mem = 0;\n+  (void)os::available_memory(avail_mem);\n+  st->print(\"(%zuk free)\",\n+            avail_mem >> 10);\n@@ -2616,4 +2642,4 @@\n-      snprintf(hbuf_level, 60, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/level\", i);\n-      snprintf(hbuf_type, 60, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/type\", i);\n-      snprintf(hbuf_size, 60, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/size\", i);\n-      snprintf(hbuf_coherency_line_size, 80, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/coherency_line_size\", i);\n+      os::snprintf_checked(hbuf_level, 60, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/level\", i);\n+      os::snprintf_checked(hbuf_type, 60, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/type\", i);\n+      os::snprintf_checked(hbuf_size, 60, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/size\", i);\n+      os::snprintf_checked(hbuf_coherency_line_size, 80, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/coherency_line_size\", i);\n@@ -4220,1 +4246,1 @@\n-  snprintf(fname, sizeof(fname), \"\/proc\/%d\/status\", vmid);\n+  os::snprintf_checked(fname, sizeof(fname), \"\/proc\/%d\/status\", vmid);\n@@ -4800,1 +4826,1 @@\n-    snprintf(buf, sizeof(buf), \"%s\", name);\n+    (void) os::snprintf(buf, sizeof(buf), \"%s\", name);\n@@ -5011,1 +5037,1 @@\n-  snprintf(proc_name, 64, \"\/proc\/self\/task\/%d\/stat\", tid);\n+  os::snprintf_checked(proc_name, 64, \"\/proc\/self\/task\/%d\/stat\", tid);\n@@ -5397,1 +5423,1 @@\n-      snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n+      os::snprintf_checked(ebuf, ebuflen - 1, \"%s\", error_report);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":85,"deletions":59,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  static julong _physical_memory;\n+  static size_t _physical_memory;\n@@ -56,2 +56,2 @@\n-  static julong available_memory();\n-  static julong free_memory();\n+  static bool available_memory(size_t& value);\n+  static bool free_memory(size_t& value);\n@@ -120,1 +120,1 @@\n-  static julong physical_memory() { return _physical_memory; }\n+  static size_t physical_memory() { return _physical_memory; }\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -991,1 +991,1 @@\n-  snprintf(buf, sizeof(buf), \"\/sys\/class\/net\/%s\/statistics\/%s\", iface, counter);\n+  os::snprintf_checked(buf, sizeof(buf), \"\/sys\/class\/net\/%s\/statistics\/%s\", iface, counter);\n","filename":"src\/hotspot\/os\/linux\/os_perf_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -198,2 +198,2 @@\n-  int n = snprintf(path, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n-                   os::get_temp_directory(), os::current_process_id());\n+  int n = os::snprintf(path, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n+                       os::get_temp_directory(), os::current_process_id());\n@@ -201,1 +201,1 @@\n-    n = snprintf(initial_path, UNIX_PATH_MAX, \"%s.tmp\", path);\n+    n = os::snprintf(initial_path, UNIX_PATH_MAX, \"%s.tmp\", path);\n@@ -349,3 +349,2 @@\n-  int n = snprintf(fn, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n-           os::get_temp_directory(), os::current_process_id());\n-  assert(n < (int)UNIX_PATH_MAX, \"java_pid file name buffer overflow\");\n+  os::snprintf_checked(fn, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n+                       os::get_temp_directory(), os::current_process_id());\n@@ -421,2 +420,2 @@\n-    snprintf(fn, sizeof(fn), \"%s\/.attach_pid%d\", os::get_temp_directory(),\n-             os::current_process_id());\n+    os::snprintf_checked(fn, sizeof(fn), \"%s\/.attach_pid%d\", os::get_temp_directory(),\n+                         os::current_process_id());\n","filename":"src\/hotspot\/os\/posix\/attachListener_posix.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-    int n = snprintf(fullname, fullname_len + 1, \"%s%s\", dir, name_template);\n+    int n = os::snprintf(fullname, fullname_len + 1, \"%s%s\", dir, name_template);\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-  snprintf(dirname, nbytes, \"%s\/%s_%s\", tmpdir, perfdir, user);\n+  os::snprintf_checked(dirname, nbytes, \"%s\/%s_%s\", tmpdir, perfdir, user);\n@@ -664,1 +664,1 @@\n-  snprintf(name, nbytes, \"%s\/%d\", dirname, pid);\n+  os::snprintf_checked(name, nbytes, \"%s\/%d\", dirname, pid);\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -851,2 +851,2 @@\n-julong os::available_memory() {\n-  return win32::available_memory();\n+bool os::available_memory(size_t& value) {\n+  return win32::available_memory(value);\n@@ -855,2 +855,2 @@\n-julong os::free_memory() {\n-  return win32::available_memory();\n+bool os::free_memory(size_t& value) {\n+  return win32::available_memory(value);\n@@ -859,1 +859,1 @@\n-julong os::win32::available_memory() {\n+bool os::win32::available_memory(size_t& value) {\n@@ -864,3 +864,8 @@\n-  GlobalMemoryStatusEx(&ms);\n-\n-  return (julong)ms.ullAvailPhys;\n+  BOOL res = GlobalMemoryStatusEx(&ms);\n+  if (res == TRUE) {\n+    value = static_cast<size_t>(ms.ullAvailPhys);\n+    return true;\n+  } else {\n+    assert(false, \"GlobalMemoryStatusEx failed in os::win32::available_memory(): %lu\", ::GetLastError());\n+    return false;\n+  }\n@@ -869,1 +874,1 @@\n-jlong os::total_swap_space() {\n+bool os::total_swap_space(size_t& value) {\n@@ -872,2 +877,8 @@\n-  GlobalMemoryStatusEx(&ms);\n-  return (jlong) ms.ullTotalPageFile;\n+  BOOL res = GlobalMemoryStatusEx(&ms);\n+  if (res == TRUE) {\n+    value = static_cast<size_t>(ms.ullTotalPageFile);\n+    return true;\n+  } else {\n+    assert(false, \"GlobalMemoryStatusEx failed in os::total_swap_space(): %lu\", ::GetLastError());\n+    return false;\n+  }\n@@ -876,1 +887,1 @@\n-jlong os::free_swap_space() {\n+bool os::free_swap_space(size_t& value) {\n@@ -879,2 +890,8 @@\n-  GlobalMemoryStatusEx(&ms);\n-  return (jlong) ms.ullAvailPageFile;\n+  BOOL res = GlobalMemoryStatusEx(&ms);\n+  if (res == TRUE) {\n+    value = static_cast<size_t>(ms.ullAvailPageFile);\n+    return true;\n+  } else {\n+    assert(false, \"GlobalMemoryStatusEx failed in os::free_swap_space(): %lu\", ::GetLastError());\n+    return false;\n+  }\n@@ -883,1 +900,1 @@\n-julong os::physical_memory() {\n+size_t os::physical_memory() {\n@@ -1414,1 +1431,1 @@\n-    snprintf(name, MAX_PATH, \"<not available>\");\n+    os::snprintf_checked(name, MAX_PATH, \"<not available>\");\n@@ -1430,1 +1447,1 @@\n-      os::snprintf(buf, sizeof(buf), \"Attempt to unload dll failed (error code %d)\", (int) errcode);\n+      os::snprintf_checked(buf, sizeof(buf), \"Attempt to unload dll failed (error code %d)\", (int) errcode);\n@@ -1827,3 +1844,3 @@\n-    os::snprintf(ebuf, ebuflen - 1,\n-                 \"Can't load %s-bit .dll on a %s-bit platform\",\n-                 lib_arch_str, running_arch_str);\n+    os::snprintf_checked(ebuf, ebuflen - 1,\n+                         \"Can't load %s-bit .dll on a %s-bit platform\",\n+                         lib_arch_str, running_arch_str);\n@@ -1832,3 +1849,3 @@\n-    os::snprintf(ebuf, ebuflen - 1,\n-                 \"Can't load this .dll (machine code=0x%x) on a %s-bit platform\",\n-                 lib_arch, running_arch_str);\n+    os::snprintf_checked(ebuf, ebuflen - 1,\n+                         \"Can't load this .dll (machine code=0x%x) on a %s-bit platform\",\n+                         lib_arch, running_arch_str);\n@@ -3201,1 +3218,1 @@\n-  int n = snprintf(fullname, fullname_len + 1, \"%s%s\", dir, name_template);\n+  int n = os::snprintf(fullname, fullname_len + 1, \"%s%s\", dir, name_template);\n@@ -3951,1 +3968,1 @@\n-julong os::win32::_physical_memory           = 0;\n+size_t os::win32::_physical_memory           = 0;\n@@ -4181,2 +4198,5 @@\n-  GlobalMemoryStatusEx(&ms);\n-  _physical_memory = ms.ullTotalPhys;\n+  BOOL res = GlobalMemoryStatusEx(&ms);\n+  if (res != TRUE) {\n+    assert(false, \"GlobalMemoryStatusEx failed in os::win32::initialize_system_info(): %lu\", ::GetLastError());\n+  }\n+  _physical_memory = static_cast<size_t>(ms.ullTotalPhys);\n@@ -4683,2 +4703,2 @@\n-      errno = ::GetLastError();\n-      log_debug(os)(\"is_symbolic_link() failed to FindClose: GetLastError->%ld.\", errno);\n+      DWORD errcode = ::GetLastError();\n+      log_debug(os)(\"is_symbolic_link() failed to FindClose: GetLastError->%lu.\", errcode);\n@@ -4688,2 +4708,2 @@\n-    errno = ::GetLastError();\n-    log_debug(os)(\"is_symbolic_link() failed to FindFirstFileW: GetLastError->%ld.\", errno);\n+    DWORD errcode = ::GetLastError();\n+    log_debug(os)(\"is_symbolic_link() failed to FindFirstFileW: GetLastError->%lu.\", errcode);\n@@ -4699,2 +4719,2 @@\n-    errno = ::GetLastError();\n-    log_debug(os)(\"get_path_to_target() failed to CreateFileW: GetLastError->%ld.\", errno);\n+    DWORD errcode = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to CreateFileW: GetLastError->%lu.\", errcode);\n@@ -4708,2 +4728,2 @@\n-    errno = ::GetLastError();\n-    log_debug(os)(\"get_path_to_target() failed to GetFinalPathNameByHandleW: GetLastError->%ld.\", errno);\n+    DWORD errcode = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to GetFinalPathNameByHandleW: GetLastError->%lu.\", errcode);\n@@ -4719,2 +4739,2 @@\n-    errno = ::GetLastError();\n-    log_debug(os)(\"get_path_to_target() failed to GetFinalPathNameByHandleW: GetLastError->%ld.\", errno);\n+    DWORD errcode = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to GetFinalPathNameByHandleW: GetLastError->%lu.\", errcode);\n@@ -4725,2 +4745,2 @@\n-    errno = ::GetLastError();\n-    log_debug(os)(\"get_path_to_target() failed to CloseHandle: GetLastError->%ld.\", errno);\n+    DWORD errcode = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to CloseHandle: GetLastError->%lu.\", errcode);\n@@ -4807,3 +4827,2 @@\n-      \/\/ it is a symbolic link, but we failed to resolve it,\n-      \/\/ errno has been set in the call to get_path_to_target(),\n-      \/\/ no need to overwrite it\n+      \/\/ it is a symbolic link, but we failed to resolve it\n+      errno = ENOENT;\n@@ -4820,2 +4839,7 @@\n-    errno = ::GetLastError();\n-    log_debug(os)(\"os::stat() failed to GetFileAttributesExW: GetLastError->%ld.\", errno);\n+    DWORD errcode = ::GetLastError();\n+    if (errcode == ERROR_FILE_NOT_FOUND || errcode == ERROR_PATH_NOT_FOUND) {\n+      errno = ENOENT;\n+    } else {\n+      errno = 0;\n+    }\n+    log_debug(os)(\"os::stat() failed to GetFileAttributesExW: GetLastError->%lu.\", errcode);\n@@ -5021,3 +5045,2 @@\n-      \/\/ it is a symbolic link, but we failed to resolve it,\n-      \/\/ errno has been set in the call to get_path_to_target(),\n-      \/\/ no need to overwrite it\n+      \/\/ it is a symbolic link, but we failed to resolve it\n+      errno = ENOENT;\n@@ -5031,1 +5054,1 @@\n-  \/\/ if opening files failed, GetLastError should be called immediately after that\n+  \/\/ if opening files failed, errno has been set to indicate the problem\n@@ -5033,2 +5056,1 @@\n-    errno = ::GetLastError();\n-    log_debug(os)(\"os::open() failed to _wopen: GetLastError->%ld.\", errno);\n+    log_debug(os)(\"os::open() failed to _wopen: errno->%s.\", strerror(errno));\n@@ -5102,1 +5124,2 @@\n-    errno = ::GetLastError();\n+    DWORD errcode = ::GetLastError();\n+    log_debug(os)(\"os::dir_is_empty() failed to FindFirstFileW: GetLastError->%lu.\", errcode);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":74,"deletions":51,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-  static julong _physical_memory;\n+  static size_t _physical_memory;\n@@ -105,3 +105,3 @@\n-  static julong available_memory();\n-  static julong free_memory();\n-  static julong physical_memory() { return _physical_memory; }\n+  static bool available_memory(size_t& value);\n+  static bool free_memory(size_t& value);\n+  static size_t physical_memory() { return _physical_memory; }\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-  os::snprintf(dirname, nbytes, \"%s\\\\%s_%s\", tmpdir, perfdir, user);\n+  os::snprintf_checked(dirname, nbytes, \"%s\\\\%s_%s\", tmpdir, perfdir, user);\n@@ -457,1 +457,1 @@\n-  os::snprintf(name, nbytes, \"%s_%s_%u\", PERFDATA_NAME, user, vmid);\n+  os::snprintf_checked(name, nbytes, \"%s_%s_%u\", PERFDATA_NAME, user, vmid);\n@@ -473,1 +473,1 @@\n-  os::snprintf(name, nbytes, \"%s\\\\%d\", dirname, vmid);\n+  os::snprintf_checked(name, nbytes, \"%s\\\\%d\", dirname, vmid);\n","filename":"src\/hotspot\/os\/windows\/perfMemory_windows.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-    snprintf(buf, sizeof(buf)\/2, \"%s \", uarch);\n+    os::snprintf_checked(buf, sizeof(buf)\/2, \"%s \", uarch);\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/vm_version_linux_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -244,6 +244,0 @@\n-#ifdef _WINDOWS\n-  } else if (errno == ERROR_FILE_NOT_FOUND || errno == ERROR_PATH_NOT_FOUND) {\n-    \/\/ On Windows, the errno could be ERROR_PATH_NOT_FOUND (3) in case the directory\n-    \/\/ path doesn't exist.\n-    type = FileType::NOT_EXIST;\n-#endif\n","filename":"src\/hotspot\/share\/cds\/aotClassLocation.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,930 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cds\/aotMapLogger.hpp\"\n+#include \"cds\/archiveHeapWriter.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"cds\/filemap.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"memory\/metaspaceClosure.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/method.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+bool AOTMapLogger::_is_logging_at_bootstrap;\n+bool AOTMapLogger::_is_runtime_logging;\n+intx AOTMapLogger::_buffer_to_requested_delta;\n+intx AOTMapLogger::_requested_to_mapped_metadata_delta;\n+size_t AOTMapLogger::_num_root_segments;\n+size_t AOTMapLogger::_num_obj_arrays_logged;\n+GrowableArrayCHeap<AOTMapLogger::FakeOop, mtClass>* AOTMapLogger::_roots;\n+ArchiveHeapInfo* AOTMapLogger::_dumptime_heap_info;\n+\n+class AOTMapLogger::RequestedMetadataAddr {\n+  address _raw_addr;\n+\n+public:\n+  RequestedMetadataAddr(address raw_addr) : _raw_addr(raw_addr) {}\n+\n+  address raw_addr() const { return _raw_addr; }\n+\n+  Klass* to_real_klass() const {\n+    if (_raw_addr == nullptr) {\n+      return nullptr;\n+    }\n+\n+    if (_is_runtime_logging) {\n+      return (Klass*)(_raw_addr + _requested_to_mapped_metadata_delta);\n+    } else {\n+      ArchiveBuilder* builder = ArchiveBuilder::current();\n+      address buffered_addr = builder->requested_to_buffered(_raw_addr);\n+      address klass = builder->get_source_addr(buffered_addr);\n+      return (Klass*)klass;\n+    }\n+  }\n+}; \/\/ AOTMapLogger::RequestedMetadataAddr\n+\n+void AOTMapLogger::ergo_initialize() {\n+  if (!CDSConfig::is_dumping_archive() && CDSConfig::is_using_archive() && log_is_enabled(Info, aot, map)) {\n+    _is_logging_at_bootstrap = true;\n+    if (FLAG_IS_DEFAULT(ArchiveRelocationMode)) {\n+      FLAG_SET_ERGO(ArchiveRelocationMode, 0);\n+    } else if (ArchiveRelocationMode != 0) {\n+      log_warning(aot, map)(\"Addresses in the AOT map may be incorrect for -XX:ArchiveRelocationMode=%d.\", ArchiveRelocationMode);\n+    }\n+  }\n+}\n+\n+void AOTMapLogger::dumptime_log(ArchiveBuilder* builder, FileMapInfo* mapinfo,\n+                                ArchiveHeapInfo* heap_info,\n+                                char* bitmap, size_t bitmap_size_in_bytes) {\n+  _is_runtime_logging = false;\n+  _buffer_to_requested_delta =  ArchiveBuilder::current()->buffer_to_requested_delta();\n+  _num_root_segments = mapinfo->heap_root_segments().count();\n+  _dumptime_heap_info = heap_info;\n+\n+  log_file_header(mapinfo);\n+\n+  DumpRegion* rw_region = &builder->_rw_region;\n+  DumpRegion* ro_region = &builder->_ro_region;\n+\n+  dumptime_log_metaspace_region(\"rw region\", rw_region, &builder->_rw_src_objs);\n+  dumptime_log_metaspace_region(\"ro region\", ro_region, &builder->_ro_src_objs);\n+\n+  address bitmap_end = address(bitmap + bitmap_size_in_bytes);\n+  log_region_range(\"bitmap\", address(bitmap), bitmap_end, nullptr);\n+  log_as_hex((address)bitmap, bitmap_end, nullptr);\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (heap_info->is_used()) {\n+    dumptime_log_heap_region(heap_info);\n+  }\n+#endif\n+\n+  log_info(aot, map)(\"[End of AOT cache map]\");\n+}\n+\n+\/\/ This class is used to find the location and type of all the\n+\/\/ archived metaspace objects.\n+class AOTMapLogger::RuntimeGatherArchivedMetaspaceObjs : public UniqueMetaspaceClosure {\n+  GrowableArrayCHeap<ArchivedObjInfo, mtClass> _objs;\n+\n+  static int compare_objs_by_addr(ArchivedObjInfo* a, ArchivedObjInfo* b) {\n+    intx diff = a->_src_addr - b->_src_addr;\n+    if (diff < 0) {\n+      return -1;\n+    } else if (diff == 0) {\n+      return 0;\n+    } else {\n+      return 1;\n+    }\n+  }\n+\n+public:\n+  GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs() { return &_objs; }\n+\n+  virtual bool do_unique_ref(Ref* ref, bool read_only) {\n+    ArchivedObjInfo info;\n+    info._src_addr = ref->obj();\n+    info._buffered_addr = ref->obj();\n+    info._requested_addr = ref->obj();\n+    info._bytes = ref->size() * BytesPerWord;\n+    info._type = ref->msotype();\n+    _objs.append(info);\n+\n+    return true; \/\/ keep iterating\n+  }\n+\n+  void finish() {\n+    UniqueMetaspaceClosure::finish();\n+    _objs.sort(compare_objs_by_addr);\n+  }\n+}; \/\/ AOTMapLogger::RuntimeGatherArchivedMetaspaceObjs\n+\n+void AOTMapLogger::runtime_log(FileMapInfo* static_mapinfo, FileMapInfo* dynamic_mapinfo) {\n+  _is_runtime_logging = true;\n+  _requested_to_mapped_metadata_delta = static_mapinfo->relocation_delta();\n+\n+  ResourceMark rm;\n+  RuntimeGatherArchivedMetaspaceObjs gatherer;\n+\n+  if (log_is_enabled(Debug, aot, map)) {\n+    \/\/ The metaspace objects in the AOT cache are stored as a stream of bytes. For space\n+    \/\/ saving, we don't store a complete index that tells us where one object ends and\n+    \/\/ another object starts. There's also no type information.\n+    \/\/\n+    \/\/ However, we can rebuild our index by iterating over all the objects using\n+    \/\/ MetaspaceClosure, starting from the dictionary of Klasses in SystemDictionaryShared.\n+    GrowableArray<Klass*> klasses;\n+    SystemDictionaryShared::get_all_archived_classes(\/*is_static*\/true, &klasses);\n+    if (dynamic_mapinfo != nullptr) {\n+      SystemDictionaryShared::get_all_archived_classes(\/*is_static*\/false, &klasses);\n+    }\n+\n+    for (int i = 0; i < klasses.length(); i++) {\n+      gatherer.push(klasses.adr_at(i));\n+    }\n+    gatherer.finish();\n+  }\n+\n+  runtime_log(static_mapinfo, gatherer.objs());\n+  if (dynamic_mapinfo != nullptr) {\n+    runtime_log(dynamic_mapinfo, gatherer.objs());\n+  }\n+}\n+\n+void AOTMapLogger::runtime_log(FileMapInfo* mapinfo, GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs) {\n+  log_file_header(mapinfo);\n+\n+  runtime_log_metaspace_regions(mapinfo, objs);\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (mapinfo->has_heap_region() && CDSConfig::is_loading_heap()) {\n+    _num_root_segments = mapinfo->heap_root_segments().count();\n+    runtime_log_heap_region(mapinfo);\n+  }\n+#endif\n+\n+  log_info(aot, map)(\"[End of map]\");\n+}\n+\n+void AOTMapLogger::dumptime_log_metaspace_region(const char* name, DumpRegion* region,\n+                                                 const ArchiveBuilder::SourceObjList* src_objs) {\n+  address region_base = address(region->base());\n+  address region_top  = address(region->top());\n+  log_region_range(name, region_base, region_top, region_base + _buffer_to_requested_delta);\n+  if (log_is_enabled(Debug, aot, map)) {\n+    GrowableArrayCHeap<ArchivedObjInfo, mtClass> objs;\n+    for (int i = 0; i < src_objs->objs()->length(); i++) {\n+      ArchiveBuilder::SourceObjInfo* src_info = src_objs->at(i);\n+      ArchivedObjInfo info;\n+      info._src_addr = src_info->source_addr();\n+      info._buffered_addr = src_info->buffered_addr();\n+      info._requested_addr = info._buffered_addr + _buffer_to_requested_delta;\n+      info._bytes = src_info->size_in_bytes();\n+      info._type = src_info->msotype();\n+      objs.append(info);\n+    }\n+\n+    log_metaspace_objects_impl(address(region->base()), address(region->end()), &objs, 0, objs.length());\n+  }\n+}\n+\n+void AOTMapLogger::runtime_log_metaspace_regions(FileMapInfo* mapinfo, GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs) {\n+  FileMapRegion* rw = mapinfo->region_at(MetaspaceShared::rw);\n+  FileMapRegion* ro = mapinfo->region_at(MetaspaceShared::ro);\n+\n+  address rw_base = address(rw->mapped_base());\n+  address rw_end  = address(rw->mapped_end());\n+  address ro_base = address(ro->mapped_base());\n+  address ro_end  = address(ro->mapped_end());\n+\n+  int first_rw_index = -1;\n+  int first_ro_index = -1;\n+  int last_ro_index = -1;\n+\n+  if (log_is_enabled(Debug, aot, map)) {\n+    int i = 0;\n+    for (; i < objs->length(); i++) {\n+      address p = objs->at(i)._src_addr;\n+      if (p < rw_base) {\n+        \/\/ We are printing the dynamic archive but found an object in the static archive\n+        precond(!mapinfo->is_static());\n+        continue;\n+      }\n+      if (first_rw_index < 0) {\n+        first_rw_index = i;\n+        continue;\n+      }\n+      if (p < ro_base) {\n+        continue;\n+      }\n+      if (first_ro_index < 0) {\n+        first_ro_index = i;\n+        continue;\n+      }\n+      if (p < ro_end) {\n+        continue;\n+      } else {\n+        last_ro_index = i;\n+        break;\n+      }\n+    }\n+  }\n+\n+  if (last_ro_index < 0) {\n+    last_ro_index = objs->length();\n+  }\n+\n+  log_region_range(\"rw\", rw_base, rw_end, rw_base - _requested_to_mapped_metadata_delta);\n+  if (log_is_enabled(Debug, aot, map)) {\n+    log_metaspace_objects_impl(rw_base, rw_end, objs, first_rw_index, first_ro_index);\n+  }\n+\n+  log_region_range(\"ro\", ro_base, ro_end, ro_base - _requested_to_mapped_metadata_delta);\n+  if (log_is_enabled(Debug, aot, map)) {\n+    log_metaspace_objects_impl(ro_base, ro_end, objs, first_ro_index, last_ro_index);\n+  }\n+}\n+\n+void AOTMapLogger::log_file_header(FileMapInfo* mapinfo) {\n+  const char* type;\n+  if (mapinfo->is_static()) {\n+    if (CDSConfig::new_aot_flags_used()) {\n+      type = \"AOT cache\";\n+    } else {\n+      type = \"Static CDS archive\";\n+    }\n+  } else {\n+    type = \"Dynamic CDS archive\";\n+  }\n+\n+  log_info(aot, map)(\"%s map for %s\", type, mapinfo->full_path());\n+\n+  address header = address(mapinfo->header());\n+  address header_end = header + mapinfo->header()->header_size();\n+\n+  log_region_range(\"header\", header, header_end, nullptr);\n+  LogStreamHandle(Info, aot, map) lsh;\n+  mapinfo->print(&lsh);\n+  log_as_hex(header, header_end, nullptr);\n+}\n+\n+\/\/ Log information about a region, whose address at dump time is [base .. top). At\n+\/\/ runtime, this region will be mapped to requested_base. requested_base is nullptr if this\n+\/\/ region will be mapped at os-selected addresses (such as the bitmap region), or will\n+\/\/ be accessed with os::read (the header).\n+void AOTMapLogger::log_region_range(const char* name, address base, address top, address requested_base) {\n+  size_t size = top - base;\n+  base = requested_base;\n+  if (requested_base == nullptr) {\n+    top = (address)size;\n+  } else {\n+    top = requested_base + size;\n+  }\n+  log_info(aot, map)(\"[%-18s \" PTR_FORMAT \" - \" PTR_FORMAT \" %9zu bytes]\",\n+                     name, p2i(base), p2i(top), size);\n+}\n+\n+#define _LOG_PREFIX PTR_FORMAT \": @@ %-17s %d\"\n+\n+void AOTMapLogger::log_metaspace_objects_impl(address region_base, address region_end, GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs,\n+                                              int start_idx, int end_idx) {\n+  address last_obj_base = region_base;\n+  address last_obj_end  = region_base;\n+  Thread* current = Thread::current();\n+\n+  for (int i = start_idx; i < end_idx; i++) {\n+    ArchivedObjInfo& info = objs->at(i);\n+    address src = info._src_addr;\n+    address buffered_addr = info._buffered_addr;\n+    address requested_addr = info._requested_addr;\n+    int bytes = info._bytes;\n+    MetaspaceObj::Type type = info._type;\n+    const char* type_name = MetaspaceObj::type_name(type);\n+\n+    log_as_hex(last_obj_base, buffered_addr, last_obj_base + _buffer_to_requested_delta);\n+\n+    switch (type) {\n+    case MetaspaceObj::ClassType:\n+      log_klass((Klass*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    case MetaspaceObj::ConstantPoolType:\n+      log_constant_pool((ConstantPool*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    case MetaspaceObj::ConstantPoolCacheType:\n+      log_constant_pool_cache((ConstantPoolCache*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    case MetaspaceObj::ConstMethodType:\n+      log_const_method((ConstMethod*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    case MetaspaceObj::MethodType:\n+      log_method((Method*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    case MetaspaceObj::SymbolType:\n+      log_symbol((Symbol*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    default:\n+      log_debug(aot, map)(_LOG_PREFIX, p2i(requested_addr), type_name, bytes);\n+      break;\n+    }\n+\n+    last_obj_base = buffered_addr;\n+    last_obj_end  = buffered_addr + bytes;\n+  }\n+\n+  log_as_hex(last_obj_base, last_obj_end, last_obj_base + _buffer_to_requested_delta);\n+  if (last_obj_end < region_end) {\n+    log_debug(aot, map)(PTR_FORMAT \": @@ Misc data %zu bytes\",\n+                        p2i(last_obj_end + _buffer_to_requested_delta),\n+                        size_t(region_end - last_obj_end));\n+    log_as_hex(last_obj_end, region_end, last_obj_end + _buffer_to_requested_delta);\n+  }\n+}\n+\n+void AOTMapLogger::log_constant_pool(ConstantPool* cp, address requested_addr,\n+                                     const char* type_name, int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes,\n+                      cp->pool_holder()->external_name());\n+}\n+\n+void AOTMapLogger::log_constant_pool_cache(ConstantPoolCache* cpc, address requested_addr,\n+                                           const char* type_name, int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes,\n+                      cpc->constant_pool()->pool_holder()->external_name());\n+}\n+\n+void AOTMapLogger::log_const_method(ConstMethod* cm, address requested_addr, const char* type_name,\n+                                    int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes,  cm->method()->external_name());\n+}\n+\n+void AOTMapLogger::log_klass(Klass* k, address requested_addr, const char* type_name,\n+                             int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes, k->external_name());\n+}\n+\n+void AOTMapLogger::log_method(Method* m, address requested_addr, const char* type_name,\n+                              int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes,  m->external_name());\n+}\n+\n+void AOTMapLogger::log_symbol(Symbol* s, address requested_addr, const char* type_name,\n+                              int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes,\n+                      s->as_quoted_ascii());\n+}\n+\n+#undef _LOG_PREFIX\n+\n+\/\/ Log all the data [base...top). Pretend that the base address\n+\/\/ will be mapped to requested_base at run-time.\n+void AOTMapLogger::log_as_hex(address base, address top, address requested_base, bool is_heap) {\n+  assert(top >= base, \"must be\");\n+\n+  LogStreamHandle(Trace, aot, map) lsh;\n+  if (lsh.is_enabled()) {\n+    int unitsize = sizeof(address);\n+    if (is_heap && UseCompressedOops) {\n+      \/\/ This makes the compressed oop pointers easier to read, but\n+      \/\/ longs and doubles will be split into two words.\n+      unitsize = sizeof(narrowOop);\n+    }\n+    os::print_hex_dump(&lsh, base, top, unitsize, \/* print_ascii=*\/true, \/* bytes_per_line=*\/32, requested_base);\n+  }\n+}\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+\/\/ FakeOop (and subclasses FakeMirror, FakeString, FakeObjArray, FakeTypeArray) are used to traverse\n+\/\/ and print the (image of) heap objects stored in the AOT cache. These objects are different than regular oops:\n+\/\/ - They do not reside inside the range of the heap.\n+\/\/ - For +UseCompressedOops: pointers may use a different narrowOop encoding: see FakeOop::read_oop_at(narrowOop*)\n+\/\/ - For -UseCompressedOops: pointers are not direct: see FakeOop::read_oop_at(oop*)\n+\/\/\n+\/\/ Hence, in general, we cannot use regular oop API (such as oopDesc::obj_field()) on these objects. There\n+\/\/ are a few rare case where regular oop API work, but these are all guarded with the raw_oop() method and\n+\/\/ should be used with care.\n+class AOTMapLogger::FakeOop {\n+  static int _requested_shift;\n+  static intx _buffer_to_requested_delta;\n+  static address _buffer_start;\n+  static address _buffer_end;\n+  static uint64_t _buffer_start_narrow_oop; \/\/ The encoded narrow oop for the objects at _buffer_start\n+\n+  address _buffer_addr;\n+\n+  static void assert_range(address buffer_addr) {\n+    assert(_buffer_start <= buffer_addr && buffer_addr < _buffer_end, \"range check\");\n+  }\n+\n+  address* field_addr(int field_offset) {\n+    return (address*)(_buffer_addr + field_offset);\n+  }\n+\n+protected:\n+  RequestedMetadataAddr metadata_field(int field_offset) {\n+    return RequestedMetadataAddr(*(address*)(field_addr(field_offset)));\n+  }\n+\n+  \/\/ Return an \"oop\" pointer so we can use APIs that accept regular oops. This\n+  \/\/ must be used with care, as only a limited number of APIs can work with oops that\n+  \/\/ live outside of the range of the heap.\n+  oop raw_oop() { return cast_to_oop(_buffer_addr); }\n+\n+public:\n+  static void init_globals(address requested_base, address requested_start, int requested_shift,\n+                           address buffer_start, address buffer_end) {\n+    _requested_shift = requested_shift;\n+    _buffer_to_requested_delta = requested_start - buffer_start;\n+    _buffer_start = buffer_start;\n+    _buffer_end = buffer_end;\n+\n+    precond(requested_start >= requested_base);\n+    if (UseCompressedOops) {\n+      _buffer_start_narrow_oop = (uint64_t)(pointer_delta(requested_start, requested_base, 1)) >> _requested_shift;\n+      assert(_buffer_start_narrow_oop < 0xffffffff, \"sanity\");\n+    } else {\n+      _buffer_start_narrow_oop = 0xdeadbeed;\n+    }\n+  }\n+\n+  FakeOop() : _buffer_addr(nullptr) {}\n+\n+  FakeOop(address buffer_addr) : _buffer_addr(buffer_addr) {\n+    if (_buffer_addr != nullptr) {\n+      assert_range(_buffer_addr);\n+    }\n+  }\n+\n+  FakeMirror& as_mirror();\n+  FakeObjArray& as_obj_array();\n+  FakeString& as_string();\n+  FakeTypeArray& as_type_array();\n+\n+  RequestedMetadataAddr klass() {\n+    address rk = (address)real_klass();\n+    if (_is_runtime_logging) {\n+      return RequestedMetadataAddr(rk - _requested_to_mapped_metadata_delta);\n+    } else {\n+      ArchiveBuilder* builder = ArchiveBuilder::current();\n+      return builder->to_requested(builder->get_buffered_addr(rk));\n+    }\n+  }\n+\n+  Klass* real_klass() {\n+    assert(UseCompressedClassPointers, \"heap archiving requires UseCompressedClassPointers\");\n+    if (_is_runtime_logging) {\n+      return raw_oop()->klass();\n+    } else {\n+      return ArchiveHeapWriter::real_klass_of_buffered_oop(_buffer_addr);\n+    }\n+  }\n+\n+  \/\/ in heap words\n+  size_t size() {\n+    if (_is_runtime_logging) {\n+      return raw_oop()->size_given_klass(real_klass());\n+    } else {\n+      return ArchiveHeapWriter::size_of_buffered_oop(_buffer_addr);\n+    }\n+  }\n+\n+  bool is_array() { return real_klass()->is_array_klass(); }\n+  bool is_null() { return _buffer_addr == nullptr; }\n+\n+  int array_length() {\n+    precond(is_array());\n+    return arrayOop(raw_oop())->length();\n+  }\n+\n+  address requested_addr() {\n+    return _buffer_addr + _buffer_to_requested_delta;\n+  }\n+\n+  uint32_t as_narrow_oop_value() {\n+    precond(UseCompressedOops);\n+    if (_buffer_addr == nullptr) {\n+      return 0;\n+    }\n+    uint64_t pd = (uint64_t)(pointer_delta(_buffer_addr, _buffer_start, 1));\n+    return checked_cast<uint32_t>(_buffer_start_narrow_oop + (pd >> _requested_shift));\n+  }\n+\n+  FakeOop read_oop_at(narrowOop* addr) { \/\/ +UseCompressedOops\n+    uint64_t n = (uint64_t)(*addr);\n+    if (n == 0) {\n+      return FakeOop(nullptr);\n+    } else {\n+      precond(n >= _buffer_start_narrow_oop);\n+      address value = _buffer_start + ((n - _buffer_start_narrow_oop) << _requested_shift);\n+      return FakeOop(value);\n+    }\n+  }\n+\n+  FakeOop read_oop_at(oop* addr) { \/\/ -UseCompressedOops\n+    address requested_value = cast_from_oop<address>(*addr);\n+    if (requested_value == nullptr) {\n+      return FakeOop(nullptr);\n+    } else {\n+      return FakeOop(requested_value - _buffer_to_requested_delta);\n+    }\n+  }\n+\n+  FakeOop obj_field(int field_offset) {\n+    if (UseCompressedOops) {\n+      return read_oop_at(raw_oop()->field_addr<narrowOop>(field_offset));\n+    } else {\n+      return read_oop_at(raw_oop()->field_addr<oop>(field_offset));\n+    }\n+  }\n+\n+  void print_non_oop_field(outputStream* st, fieldDescriptor* fd) {\n+    \/\/ fd->print_on_for() works for non-oop fields in fake oops\n+    precond(fd->field_type() != T_ARRAY && fd->field_type() != T_OBJECT);\n+    fd->print_on_for(st, raw_oop());\n+  }\n+}; \/\/ AOTMapLogger::FakeOop\n+\n+class AOTMapLogger::FakeMirror : public AOTMapLogger::FakeOop {\n+public:\n+  void print_class_signature_on(outputStream* st);\n+\n+  Klass* real_mirrored_klass() {\n+    RequestedMetadataAddr mirrored_klass = metadata_field(java_lang_Class::klass_offset());\n+    return mirrored_klass.to_real_klass();\n+  }\n+\n+  int static_oop_field_count() {\n+    return java_lang_Class::static_oop_field_count(raw_oop());\n+  }\n+}; \/\/ AOTMapLogger::FakeMirror\n+\n+class AOTMapLogger::FakeObjArray : public AOTMapLogger::FakeOop {\n+  objArrayOop raw_objArrayOop() {\n+    return (objArrayOop)raw_oop();\n+  }\n+\n+public:\n+  int length() {\n+    return raw_objArrayOop()->length();\n+  }\n+  FakeOop obj_at(int i) {\n+    if (UseCompressedOops) {\n+      return read_oop_at(raw_objArrayOop()->obj_at_addr<narrowOop>(i));\n+    } else {\n+      return read_oop_at(raw_objArrayOop()->obj_at_addr<oop>(i));\n+    }\n+  }\n+}; \/\/ AOTMapLogger::FakeObjArray\n+\n+class AOTMapLogger::FakeString : public AOTMapLogger::FakeOop {\n+public:\n+  bool is_latin1() {\n+    jbyte coder = raw_oop()->byte_field(java_lang_String::coder_offset());\n+    assert(CompactStrings || coder == java_lang_String::CODER_UTF16, \"Must be UTF16 without CompactStrings\");\n+    return coder == java_lang_String::CODER_LATIN1;\n+  }\n+\n+  FakeTypeArray value();\n+\n+  int length();\n+  void print_on(outputStream* st, int max_length = MaxStringPrintSize);\n+}; \/\/ AOTMapLogger::FakeString\n+\n+class AOTMapLogger::FakeTypeArray : public AOTMapLogger::FakeOop {\n+  typeArrayOop raw_typeArrayOop() {\n+    return (typeArrayOop)raw_oop();\n+  }\n+\n+public:\n+  void print_elements_on(outputStream* st) {\n+    TypeArrayKlass::cast(real_klass())->oop_print_elements_on(raw_typeArrayOop(), st);\n+  }\n+\n+  int length() { return raw_typeArrayOop()->length(); }\n+  jbyte byte_at(int i) { return raw_typeArrayOop()->byte_at(i); }\n+  jchar char_at(int i) { return raw_typeArrayOop()->char_at(i); }\n+}; \/\/ AOTMapLogger::FakeTypeArray\n+\n+AOTMapLogger::FakeMirror& AOTMapLogger::FakeOop::as_mirror() {\n+  precond(real_klass() == vmClasses::Class_klass());\n+  return (FakeMirror&)*this;\n+}\n+\n+AOTMapLogger::FakeObjArray& AOTMapLogger::FakeOop::as_obj_array() {\n+  precond(real_klass()->is_objArray_klass());\n+  return (FakeObjArray&)*this;\n+}\n+\n+AOTMapLogger::FakeTypeArray& AOTMapLogger::FakeOop::as_type_array() {\n+  precond(real_klass()->is_typeArray_klass());\n+  return (FakeTypeArray&)*this;\n+}\n+\n+AOTMapLogger::FakeString& AOTMapLogger::FakeOop::as_string() {\n+  precond(real_klass() == vmClasses::String_klass());\n+  return (FakeString&)*this;\n+}\n+\n+void AOTMapLogger::FakeMirror::print_class_signature_on(outputStream* st) {\n+  ResourceMark rm;\n+  RequestedMetadataAddr requested_klass = metadata_field(java_lang_Class::klass_offset());\n+  Klass* real_klass = requested_klass.to_real_klass();\n+\n+  if (real_klass == nullptr) {\n+    \/\/ This is a primitive mirror (Java expressions of int.class, long.class, void.class, etc);\n+    RequestedMetadataAddr requested_array_klass = metadata_field(java_lang_Class::array_klass_offset());\n+    Klass* real_array_klass = requested_array_klass.to_real_klass();\n+    if (real_array_klass == nullptr) {\n+      st->print(\" V\"); \/\/ The special mirror for void.class that doesn't have any representation in C++\n+    } else {\n+      precond(real_array_klass->is_typeArray_klass());\n+      st->print(\" %c\", real_array_klass->name()->char_at(1));\n+    }\n+  } else {\n+    const char* class_name = real_klass->name()->as_C_string();\n+    if (real_klass->is_instance_klass()) {\n+      st->print(\" L%s;\", class_name);\n+    } else {\n+      st->print(\" %s\", class_name);\n+    }\n+    if (real_klass->has_aot_initialized_mirror()) {\n+      st->print(\" (aot-inited)\");\n+    }\n+  }\n+}\n+\n+AOTMapLogger::FakeTypeArray AOTMapLogger::FakeString::value() {\n+  return obj_field(java_lang_String::value_offset()).as_type_array();\n+}\n+\n+int AOTMapLogger::FakeString::length() {\n+  FakeTypeArray v = value();\n+  if (v.is_null()) {\n+    return 0;\n+  }\n+  int arr_length = v.length();\n+  if (!is_latin1()) {\n+    assert((arr_length & 1) == 0, \"should be even for UTF16 string\");\n+    arr_length >>= 1; \/\/ convert number of bytes to number of elements\n+  }\n+  return arr_length;\n+}\n+\n+void AOTMapLogger::FakeString::print_on(outputStream* st, int max_length) {\n+  FakeTypeArray v = value();\n+  int length = this->length();\n+  bool is_latin1 = this->is_latin1();\n+  bool abridge = length > max_length;\n+\n+  st->print(\"\\\"\");\n+  for (int index = 0; index < length; index++) {\n+    \/\/ If we need to abridge and we've printed half the allowed characters\n+    \/\/ then jump to the tail of the string.\n+    if (abridge && index >= max_length \/ 2) {\n+      st->print(\" ... (%d characters ommitted) ... \", length - 2 * (max_length \/ 2));\n+      index = length - (max_length \/ 2);\n+      abridge = false; \/\/ only do this once\n+    }\n+    jchar c = (!is_latin1) ?  v.char_at(index) :\n+                             ((jchar) v.byte_at(index)) & 0xff;\n+    if (c < ' ') {\n+      st->print(\"\\\\x%02X\", c); \/\/ print control characters e.g. \\x0A\n+    } else {\n+      st->print(\"%c\", c);\n+    }\n+  }\n+  st->print(\"\\\"\");\n+\n+  if (length > max_length) {\n+    st->print(\" (abridged) \");\n+  }\n+}\n+\n+class AOTMapLogger::ArchivedFieldPrinter : public FieldClosure {\n+  FakeOop _fake_oop;\n+  outputStream* _st;\n+public:\n+  ArchivedFieldPrinter(FakeOop fake_oop, outputStream* st) : _fake_oop(fake_oop), _st(st) {}\n+\n+  void do_field(fieldDescriptor* fd) {\n+    _st->print(\" - \");\n+    BasicType ft = fd->field_type();\n+    switch (ft) {\n+    case T_ARRAY:\n+    case T_OBJECT:\n+      {\n+        fd->print_on(_st); \/\/ print just the name and offset\n+        FakeOop field_value = _fake_oop.obj_field(fd->offset());\n+        print_oop_info_cr(_st, field_value);\n+      }\n+      break;\n+    default:\n+      _fake_oop.print_non_oop_field(_st, fd); \/\/ name, offset, value\n+      _st->cr();\n+    }\n+  }\n+}; \/\/ AOTMapLogger::ArchivedFieldPrinter\n+\n+int AOTMapLogger::FakeOop::_requested_shift;\n+intx AOTMapLogger::FakeOop::_buffer_to_requested_delta;\n+address AOTMapLogger::FakeOop::_buffer_start;\n+address AOTMapLogger::FakeOop::_buffer_end;\n+uint64_t AOTMapLogger::FakeOop::_buffer_start_narrow_oop;\n+\n+void AOTMapLogger::dumptime_log_heap_region(ArchiveHeapInfo* heap_info) {\n+  MemRegion r = heap_info->buffer_region();\n+  address buffer_start = address(r.start()); \/\/ start of the current oop inside the buffer\n+  address buffer_end = address(r.end());\n+\n+  address requested_base = UseCompressedOops ? (address)CompressedOops::base() : (address)ArchiveHeapWriter::NOCOOPS_REQUESTED_BASE;\n+  address requested_start = UseCompressedOops ? ArchiveHeapWriter::buffered_addr_to_requested_addr(buffer_start) : requested_base;\n+  int requested_shift =  CompressedOops::shift();\n+\n+  FakeOop::init_globals(requested_base, requested_start, requested_shift, buffer_start, buffer_end);\n+\n+  log_region_range(\"heap\", buffer_start, buffer_end, requested_start);\n+  log_oops(buffer_start, buffer_end);\n+}\n+\n+void AOTMapLogger::runtime_log_heap_region(FileMapInfo* mapinfo) {\n+  ResourceMark rm;\n+  int heap_region_index = MetaspaceShared::hp;\n+  FileMapRegion* r = mapinfo->region_at(heap_region_index);\n+  size_t alignment = ObjectAlignmentInBytes;\n+\n+  \/\/ Allocate a buffer and read the image of the archived heap region. This buffer is outside\n+  \/\/ of the real Java heap, so we must use FakeOop to access the contents of the archived heap objects.\n+  char* buffer = resource_allocate_bytes(r->used() + alignment);\n+  address buffer_start = (address)align_up(buffer, alignment);\n+  address buffer_end = buffer_start + r->used();\n+  if (!mapinfo->read_region(heap_region_index, (char*)buffer_start, r->used(), \/* do_commit = *\/ false)) {\n+    log_error(aot)(\"Cannot read heap region; AOT map logging of heap objects failed\");\n+    return;\n+  }\n+\n+  address requested_base = UseCompressedOops ? (address)mapinfo->narrow_oop_base() : mapinfo->heap_region_requested_address();\n+  address requested_start = requested_base + r->mapping_offset();\n+  int requested_shift = mapinfo->narrow_oop_shift();\n+\n+  FakeOop::init_globals(requested_base, requested_start, requested_shift, buffer_start, buffer_end);\n+\n+  log_region_range(\"heap\", buffer_start, buffer_end, requested_start);\n+  log_oops(buffer_start, buffer_end);\n+}\n+\n+void AOTMapLogger::log_oops(address buffer_start, address buffer_end) {\n+  LogStreamHandle(Debug, aot, map) st;\n+  if (!st.is_enabled()) {\n+    return;\n+  }\n+\n+  _roots = new GrowableArrayCHeap<FakeOop, mtClass>();\n+  _num_obj_arrays_logged = 0;\n+\n+  for (address fop = buffer_start; fop < buffer_end; ) {\n+    FakeOop fake_oop(fop);\n+    st.print(PTR_FORMAT \": @@ Object \", p2i(fake_oop.requested_addr()));\n+    print_oop_info_cr(&st, fake_oop, \/*print_requested_addr=*\/false);\n+\n+    LogStreamHandle(Trace, aot, map, oops) trace_st;\n+    if (trace_st.is_enabled()) {\n+      print_oop_details(fake_oop, &trace_st);\n+    }\n+\n+    address next_fop = fop + fake_oop.size() * BytesPerWord;\n+    log_as_hex(fop, next_fop, fake_oop.requested_addr(), \/*is_heap=*\/true);\n+\n+    fop = next_fop;\n+  }\n+\n+  delete _roots;\n+}\n+\n+void AOTMapLogger::print_oop_info_cr(outputStream* st, FakeOop fake_oop, bool print_requested_addr) {\n+  if (fake_oop.is_null()) {\n+    st->print_cr(\"null\");\n+  } else {\n+    ResourceMark rm;\n+    Klass* real_klass = fake_oop.real_klass();\n+    address requested_addr = fake_oop.requested_addr();\n+    if (print_requested_addr) {\n+      st->print(PTR_FORMAT \" \", p2i(requested_addr));\n+    }\n+    if (UseCompressedOops) {\n+      st->print(\"(0x%08x) \", fake_oop.as_narrow_oop_value());\n+    }\n+    if (fake_oop.is_array()) {\n+      int array_len = fake_oop.array_length();\n+      st->print_cr(\"%s length: %d\", real_klass->external_name(), array_len);\n+    } else {\n+      st->print(\"%s\", real_klass->external_name());\n+\n+      if (real_klass == vmClasses::String_klass()) {\n+        st->print(\" \");\n+        fake_oop.as_string().print_on(st);\n+      } else if (real_klass == vmClasses::Class_klass()) {\n+        fake_oop.as_mirror().print_class_signature_on(st);\n+      }\n+\n+      st->cr();\n+    }\n+  }\n+}\n+\n+\/\/ Print the fields of instanceOops, or the elements of arrayOops\n+void AOTMapLogger::print_oop_details(FakeOop fake_oop, outputStream* st) {\n+  Klass* real_klass = fake_oop.real_klass();\n+\n+  st->print(\" - klass: \");\n+  real_klass->print_value_on(st);\n+  st->print(\" \" PTR_FORMAT, p2i(fake_oop.klass().raw_addr()));\n+  st->cr();\n+\n+  if (real_klass->is_typeArray_klass()) {\n+    fake_oop.as_type_array().print_elements_on(st);\n+  } else if (real_klass->is_objArray_klass()) {\n+    FakeObjArray fake_obj_array = fake_oop.as_obj_array();\n+    bool is_logging_root_segment = _num_obj_arrays_logged < _num_root_segments;\n+\n+    for (int i = 0; i < fake_obj_array.length(); i++) {\n+      FakeOop elm = fake_obj_array.obj_at(i);\n+      if (is_logging_root_segment) {\n+        st->print(\" root[%4d]: \", _roots->length());\n+        _roots->append(elm);\n+      } else {\n+        st->print(\" -%4d: \", i);\n+      }\n+      print_oop_info_cr(st, elm);\n+    }\n+    _num_obj_arrays_logged ++;\n+  } else {\n+    st->print_cr(\" - fields (%zu words):\", fake_oop.size());\n+\n+    ArchivedFieldPrinter print_field(fake_oop, st);\n+    InstanceKlass::cast(real_klass)->print_nonstatic_fields(&print_field);\n+\n+    if (real_klass == vmClasses::Class_klass()) {\n+      FakeMirror fake_mirror = fake_oop.as_mirror();\n+\n+      st->print(\" - signature: \");\n+      fake_mirror.print_class_signature_on(st);\n+      st->cr();\n+\n+      Klass* real_mirrored_klass = fake_mirror.real_mirrored_klass();\n+      if (real_mirrored_klass != nullptr && real_mirrored_klass->is_instance_klass()) {\n+        InstanceKlass* real_mirrored_ik = InstanceKlass::cast(real_mirrored_klass);\n+\n+        ConstantPoolCache* cp_cache = real_mirrored_ik->constants()->cache();\n+        if (!_is_runtime_logging) {\n+          cp_cache = ArchiveBuilder::current()->get_buffered_addr(cp_cache);\n+        }\n+        int rr_root_index = cp_cache->archived_references_index();\n+        st->print(\" - resolved_references: \");\n+        if (rr_root_index >= 0) {\n+          FakeOop resolved_references = _roots->at(rr_root_index);\n+          print_oop_info_cr(st, resolved_references);\n+        } else {\n+          st->print(\"null\");\n+        }\n+\n+        st->print_cr(\"- ---- static fields (%d):\", fake_mirror.static_oop_field_count());\n+        real_mirrored_ik->do_local_static_fields(&print_field);\n+      }\n+    }\n+  }\n+}\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n","filename":"src\/hotspot\/share\/cds\/aotMapLogger.cpp","additions":930,"deletions":0,"binary":false,"changes":930,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_AOTMAPLOGGER_HPP\n+#define SHARE_CDS_AOTMAPLOGGER_HPP\n+\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+class ArchiveHeapInfo;\n+class DumpRegion;\n+class FileMapInfo;\n+class outputStream;\n+\n+\/\/ Write detailed info to a mapfile to analyze contents of the AOT cache\/CDS archive.\n+\/\/ -Xlog:aot+map* can be used both when creating an AOT cache, or when using an AOT cache.\n+\/\/\n+\/\/ Creating cache:\n+\/\/     java -XX:AOTCacheOutput=app.aot -Xlog:aot+map*=trace -cp app.jar App\n+\/\/\n+\/\/ Using cache:\n+\/\/     java -XX:AOTCache=app.aot -Xlog:aot+map*=trace -cp app.jar App\n+\/\/\n+\/\/ You can also print the map of a cache without executing the application by using the\n+\/\/ --version flag:\n+\/\/     java -XX:AOTCache=app.aot -Xlog:aot+map*=trace --version\n+\/\/\n+\/\/ Because the output can be large, it's best to save it to a file\n+\/\/     java -XX:AOTCache=app.aot -Xlog:aot+map*=trace:file=aot.map:none:filesize=0 --version\n+class AOTMapLogger : AllStatic {\n+  struct ArchivedObjInfo {\n+    address _src_addr;\n+    address _buffered_addr;\n+    address _requested_addr;\n+    int _bytes;\n+    MetaspaceObj::Type _type;\n+  };\n+\n+  \/\/ FakeOop and subtypes\n+  class FakeOop;\n+  class   FakeMirror;\n+  class   FakeObjArray;\n+  class   FakeString;\n+  class   FakeTypeArray;\n+\n+  class RequestedMetadataAddr;\n+  class RuntimeGatherArchivedMetaspaceObjs;\n+\n+  static bool _is_logging_at_bootstrap;\n+  static bool _is_runtime_logging;\n+  static size_t _num_root_segments;\n+  static size_t _num_obj_arrays_logged;\n+  static GrowableArrayCHeap<FakeOop, mtClass>* _roots;\n+  static ArchiveHeapInfo* _dumptime_heap_info;\n+\n+  static intx _buffer_to_requested_delta;\n+  static intx _requested_to_mapped_metadata_delta;\n+\n+  static void runtime_log(FileMapInfo* mapinfo, GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs);\n+  static void runtime_log_metaspace_regions(FileMapInfo* mapinfo, GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs);\n+  static void dumptime_log_metaspace_region(const char* name, DumpRegion* region,\n+                                            const ArchiveBuilder::SourceObjList* src_objs);\n+\n+  \/\/ Common code for dumptime\/runtime\n+  static void log_file_header(FileMapInfo* mapinfo);\n+  static void log_region_range(const char* name, address base, address top, address requested_base);\n+  static void log_metaspace_objects_impl(address region_base, address region_end,\n+                                         GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs, int start_idx, int end_idx);\n+  static void log_as_hex(address base, address top, address requested_base, bool is_heap = false);\n+\n+  \/\/ Metaspace object: type-specific logging\n+  static void log_constant_pool(ConstantPool* cp, address requested_addr, const char* type_name, int bytes, Thread* current);\n+  static void log_constant_pool_cache(ConstantPoolCache* cpc, address requested_addr,\n+                                      const char* type_name, int bytes, Thread* current);\n+  static void log_const_method(ConstMethod* cm, address requested_addr, const char* type_name, int bytes, Thread* current);\n+  static void log_klass(Klass* k, address requested_addr, const char* type_name, int bytes, Thread* current);\n+  static void log_method(Method* m, address requested_addr, const char* type_name, int bytes, Thread* current);\n+  static void log_symbol(Symbol* s, address requested_addr, const char* type_name, int bytes, Thread* current);\n+\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  static void dumptime_log_heap_region(ArchiveHeapInfo* heap_info);\n+  static void runtime_log_heap_region(FileMapInfo* mapinfo);\n+\n+  static void print_oop_info_cr(outputStream* st, FakeOop fake_oop, bool print_requested_addr = true);\n+  static void print_oop_details(FakeOop fake_oop, outputStream* st);\n+  static void log_oops(address buf_start, address buf_end);\n+  class ArchivedFieldPrinter; \/\/ to be replaced by ArchivedFieldPrinter2\n+#endif\n+\n+public:\n+  static void ergo_initialize();\n+  static bool is_logging_at_bootstrap() { return _is_logging_at_bootstrap; }\n+\n+  static void dumptime_log(ArchiveBuilder* builder, FileMapInfo* mapinfo,\n+                           ArchiveHeapInfo* heap_info,\n+                           char* bitmap, size_t bitmap_size_in_bytes);\n+  static void runtime_log(FileMapInfo* static_mapinfo, FileMapInfo* dynamic_mapinfo);\n+};\n+\n+#endif \/\/ SHARE_CDS_AOTMAPLOGGER_HPP\n","filename":"src\/hotspot\/share\/cds\/aotMapLogger.hpp","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cds\/aotMapLogger.hpp\"\n@@ -49,1 +50,0 @@\n-#include \"logging\/logStream.hpp\"\n@@ -63,1 +63,0 @@\n-#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -567,6 +566,1 @@\n-    if (CDSConfig::is_dumping_adapters()) {\n-      AdapterHandlerEntry* entry = (AdapterHandlerEntry*)ref->obj();\n-      return AdapterHandlerLibrary::is_abstract_method_adapter(entry) ? set_to_null : make_a_copy;\n-    } else {\n-      return set_to_null;\n-    }\n+    return CDSConfig::is_dumping_adapters() ? make_a_copy : set_to_null;\n@@ -1191,418 +1185,0 @@\n-\/\/ Write detailed info to a mapfile to analyze contents of the archive.\n-\/\/ static dump:\n-\/\/   java -Xshare:dump -Xlog:cds+map=trace:file=cds.map:none:filesize=0\n-\/\/ dynamic dump:\n-\/\/   java -cp MyApp.jar -XX:ArchiveClassesAtExit=MyApp.jsa \\\n-\/\/        -Xlog:cds+map=trace:file=cds.map:none:filesize=0 MyApp\n-\/\/\n-\/\/ We need to do some address translation because the buffers used at dump time may be mapped to\n-\/\/ a different location at runtime. At dump time, the buffers may be at arbitrary locations\n-\/\/ picked by the OS. At runtime, we try to map at a fixed location (SharedBaseAddress). For\n-\/\/ consistency, we log everything using runtime addresses.\n-class ArchiveBuilder::CDSMapLogger : AllStatic {\n-  static intx buffer_to_runtime_delta() {\n-    \/\/ Translate the buffers used by the RW\/RO regions to their eventual (requested) locations\n-    \/\/ at runtime.\n-    return ArchiveBuilder::current()->buffer_to_requested_delta();\n-  }\n-\n-  \/\/ rw\/ro regions only\n-  static void log_metaspace_region(const char* name, DumpRegion* region,\n-                                   const ArchiveBuilder::SourceObjList* src_objs) {\n-    address region_base = address(region->base());\n-    address region_top  = address(region->top());\n-    log_region(name, region_base, region_top, region_base + buffer_to_runtime_delta());\n-    log_metaspace_objects(region, src_objs);\n-  }\n-\n-#define _LOG_PREFIX PTR_FORMAT \": @@ %-17s %d\"\n-\n-  static void log_klass(Klass* k, address runtime_dest, const char* type_name, int bytes, Thread* current) {\n-    ResourceMark rm(current);\n-    log_debug(aot, map)(_LOG_PREFIX \" %s\",\n-                        p2i(runtime_dest), type_name, bytes, k->external_name());\n-  }\n-  static void log_method(Method* m, address runtime_dest, const char* type_name, int bytes, Thread* current) {\n-    ResourceMark rm(current);\n-    log_debug(aot, map)(_LOG_PREFIX \" %s\",\n-                        p2i(runtime_dest), type_name, bytes,  m->external_name());\n-  }\n-\n-  \/\/ rw\/ro regions only\n-  static void log_metaspace_objects(DumpRegion* region, const ArchiveBuilder::SourceObjList* src_objs) {\n-    address last_obj_base = address(region->base());\n-    address last_obj_end  = address(region->base());\n-    address region_end    = address(region->end());\n-    Thread* current = Thread::current();\n-    for (int i = 0; i < src_objs->objs()->length(); i++) {\n-      SourceObjInfo* src_info = src_objs->at(i);\n-      address src = src_info->source_addr();\n-      address dest = src_info->buffered_addr();\n-      log_as_hex(last_obj_base, dest, last_obj_base + buffer_to_runtime_delta());\n-      address runtime_dest = dest + buffer_to_runtime_delta();\n-      int bytes = src_info->size_in_bytes();\n-\n-      MetaspaceObj::Type type = src_info->msotype();\n-      const char* type_name = MetaspaceObj::type_name(type);\n-\n-      switch (type) {\n-      case MetaspaceObj::ClassType:\n-        log_klass((Klass*)src, runtime_dest, type_name, bytes, current);\n-        break;\n-      case MetaspaceObj::ConstantPoolType:\n-        log_klass(((ConstantPool*)src)->pool_holder(),\n-                    runtime_dest, type_name, bytes, current);\n-        break;\n-      case MetaspaceObj::ConstantPoolCacheType:\n-        log_klass(((ConstantPoolCache*)src)->constant_pool()->pool_holder(),\n-                    runtime_dest, type_name, bytes, current);\n-        break;\n-      case MetaspaceObj::MethodType:\n-        log_method((Method*)src, runtime_dest, type_name, bytes, current);\n-        break;\n-      case MetaspaceObj::ConstMethodType:\n-        log_method(((ConstMethod*)src)->method(), runtime_dest, type_name, bytes, current);\n-        break;\n-      case MetaspaceObj::SymbolType:\n-        {\n-          ResourceMark rm(current);\n-          Symbol* s = (Symbol*)src;\n-          log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(runtime_dest), type_name, bytes,\n-                              s->as_quoted_ascii());\n-        }\n-        break;\n-      default:\n-        log_debug(aot, map)(_LOG_PREFIX, p2i(runtime_dest), type_name, bytes);\n-        break;\n-      }\n-\n-      last_obj_base = dest;\n-      last_obj_end  = dest + bytes;\n-    }\n-\n-    log_as_hex(last_obj_base, last_obj_end, last_obj_base + buffer_to_runtime_delta());\n-    if (last_obj_end < region_end) {\n-      log_debug(aot, map)(PTR_FORMAT \": @@ Misc data %zu bytes\",\n-                          p2i(last_obj_end + buffer_to_runtime_delta()),\n-                          size_t(region_end - last_obj_end));\n-      log_as_hex(last_obj_end, region_end, last_obj_end + buffer_to_runtime_delta());\n-    }\n-  }\n-\n-#undef _LOG_PREFIX\n-\n-  \/\/ Log information about a region, whose address at dump time is [base .. top). At\n-  \/\/ runtime, this region will be mapped to requested_base. requested_base is nullptr if this\n-  \/\/ region will be mapped at os-selected addresses (such as the bitmap region), or will\n-  \/\/ be accessed with os::read (the header).\n-  \/\/\n-  \/\/ Note: across -Xshare:dump runs, base may be different, but requested_base should\n-  \/\/ be the same as the archive contents should be deterministic.\n-  static void log_region(const char* name, address base, address top, address requested_base) {\n-    size_t size = top - base;\n-    base = requested_base;\n-    if (requested_base == nullptr) {\n-      top = (address)size;\n-    } else {\n-      top = requested_base + size;\n-    }\n-    log_info(aot, map)(\"[%-18s \" PTR_FORMAT \" - \" PTR_FORMAT \" %9zu bytes]\",\n-                       name, p2i(base), p2i(top), size);\n-  }\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-  static void log_heap_region(ArchiveHeapInfo* heap_info) {\n-    MemRegion r = heap_info->buffer_region();\n-    address start = address(r.start()); \/\/ start of the current oop inside the buffer\n-    address end = address(r.end());\n-    log_region(\"heap\", start, end, ArchiveHeapWriter::buffered_addr_to_requested_addr(start));\n-\n-    LogStreamHandle(Info, aot, map) st;\n-\n-    HeapRootSegments segments = heap_info->heap_root_segments();\n-    assert(segments.base_offset() == 0, \"Sanity\");\n-\n-    for (size_t seg_idx = 0; seg_idx < segments.count(); seg_idx++) {\n-      address requested_start = ArchiveHeapWriter::buffered_addr_to_requested_addr(start);\n-      st.print_cr(PTR_FORMAT \": Heap roots segment [%d]\",\n-                  p2i(requested_start), segments.size_in_elems(seg_idx));\n-      start += segments.size_in_bytes(seg_idx);\n-    }\n-    log_heap_roots();\n-\n-    while (start < end) {\n-      size_t byte_size;\n-      oop source_oop = ArchiveHeapWriter::buffered_addr_to_source_obj(start);\n-      address requested_start = ArchiveHeapWriter::buffered_addr_to_requested_addr(start);\n-      st.print(PTR_FORMAT \": @@ Object \", p2i(requested_start));\n-\n-      if (source_oop != nullptr) {\n-        \/\/ This is a regular oop that got archived.\n-        \/\/ Don't print the requested addr again as we have just printed it at the beginning of the line.\n-        \/\/ Example:\n-        \/\/ 0x00000007ffd27938: @@ Object (0xfffa4f27) java.util.HashMap\n-        print_oop_info_cr(&st, source_oop, \/*print_requested_addr=*\/false);\n-        byte_size = source_oop->size() * BytesPerWord;\n-      } else if ((byte_size = ArchiveHeapWriter::get_filler_size_at(start)) > 0) {\n-        \/\/ We have a filler oop, which also does not exist in BufferOffsetToSourceObjectTable.\n-        \/\/ Example:\n-        \/\/ 0x00000007ffc3ffd8: @@ Object filler 40 bytes\n-        st.print_cr(\"filler %zu bytes\", byte_size);\n-      } else {\n-        ShouldNotReachHere();\n-      }\n-\n-      address oop_end = start + byte_size;\n-      log_as_hex(start, oop_end, requested_start, \/*is_heap=*\/true);\n-\n-      if (source_oop != nullptr) {\n-        log_oop_details(heap_info, source_oop, \/*buffered_addr=*\/start);\n-      }\n-      start = oop_end;\n-    }\n-  }\n-\n-  \/\/ ArchivedFieldPrinter is used to print the fields of archived objects. We can't\n-  \/\/ use _source_obj->print_on(), because we want to print the oop fields\n-  \/\/ in _source_obj with their requested addresses using print_oop_info_cr().\n-  class ArchivedFieldPrinter : public FieldClosure {\n-    ArchiveHeapInfo* _heap_info;\n-    outputStream* _st;\n-    oop _source_obj;\n-    address _buffered_addr;\n-  public:\n-    ArchivedFieldPrinter(ArchiveHeapInfo* heap_info, outputStream* st, oop src_obj, address buffered_addr) :\n-      _heap_info(heap_info), _st(st), _source_obj(src_obj), _buffered_addr(buffered_addr) {}\n-\n-    void do_field(fieldDescriptor* fd) {\n-      _st->print(\" - \");\n-      BasicType ft = fd->field_type();\n-      switch (ft) {\n-      case T_ARRAY:\n-      case T_OBJECT:\n-        {\n-          fd->print_on(_st); \/\/ print just the name and offset\n-          oop obj = _source_obj->obj_field(fd->offset());\n-          if (java_lang_Class::is_instance(obj)) {\n-            obj = HeapShared::scratch_java_mirror(obj);\n-          }\n-          print_oop_info_cr(_st, obj);\n-        }\n-        break;\n-      default:\n-        if (ArchiveHeapWriter::is_marked_as_native_pointer(_heap_info, _source_obj, fd->offset())) {\n-          print_as_native_pointer(fd);\n-        } else {\n-          fd->print_on_for(_st, cast_to_oop(_buffered_addr)); \/\/ name, offset, value\n-          _st->cr();\n-        }\n-      }\n-    }\n-\n-    void print_as_native_pointer(fieldDescriptor* fd) {\n-      LP64_ONLY(assert(fd->field_type() == T_LONG, \"must be\"));\n-      NOT_LP64 (assert(fd->field_type() == T_INT,  \"must be\"));\n-\n-      \/\/ We have a field that looks like an integer, but it's actually a pointer to a MetaspaceObj.\n-      address source_native_ptr = (address)\n-          LP64_ONLY(_source_obj->long_field(fd->offset()))\n-          NOT_LP64( _source_obj->int_field (fd->offset()));\n-      ArchiveBuilder* builder = ArchiveBuilder::current();\n-\n-      \/\/ The value of the native pointer at runtime.\n-      address requested_native_ptr = builder->to_requested(builder->get_buffered_addr(source_native_ptr));\n-\n-      \/\/ The address of _source_obj at runtime\n-      oop requested_obj = ArchiveHeapWriter::source_obj_to_requested_obj(_source_obj);\n-      \/\/ The address of this field in the requested space\n-      assert(requested_obj != nullptr, \"Attempting to load field from null oop\");\n-      address requested_field_addr = cast_from_oop<address>(requested_obj) + fd->offset();\n-\n-      fd->print_on(_st);\n-      _st->print_cr(PTR_FORMAT \" (marked metadata pointer @\" PTR_FORMAT \" )\",\n-                    p2i(requested_native_ptr), p2i(requested_field_addr));\n-    }\n-  };\n-\n-  \/\/ Print the fields of instanceOops, or the elements of arrayOops\n-  static void log_oop_details(ArchiveHeapInfo* heap_info, oop source_oop, address buffered_addr) {\n-    LogStreamHandle(Trace, aot, map, oops) st;\n-    if (st.is_enabled()) {\n-      Klass* source_klass = source_oop->klass();\n-      ArchiveBuilder* builder = ArchiveBuilder::current();\n-      Klass* requested_klass = builder->to_requested(builder->get_buffered_addr(source_klass));\n-\n-      st.print(\" - klass: \");\n-      source_klass->print_value_on(&st);\n-      st.print(\" \" PTR_FORMAT, p2i(requested_klass));\n-      st.cr();\n-\n-      if (source_oop->is_typeArray()) {\n-        TypeArrayKlass::cast(source_klass)->oop_print_elements_on(typeArrayOop(source_oop), &st);\n-      } else if (source_oop->is_objArray()) {\n-        objArrayOop source_obj_array = objArrayOop(source_oop);\n-        for (int i = 0; i < source_obj_array->length(); i++) {\n-          st.print(\" -%4d: \", i);\n-          oop obj = source_obj_array->obj_at(i);\n-          if (java_lang_Class::is_instance(obj)) {\n-            obj = HeapShared::scratch_java_mirror(obj);\n-          }\n-          print_oop_info_cr(&st, obj);\n-        }\n-      } else {\n-        st.print_cr(\" - fields (%zu words):\", source_oop->size());\n-        ArchivedFieldPrinter print_field(heap_info, &st, source_oop, buffered_addr);\n-        InstanceKlass::cast(source_klass)->print_nonstatic_fields(&print_field);\n-\n-        if (java_lang_Class::is_instance(source_oop)) {\n-          oop scratch_mirror = source_oop;\n-          st.print(\" - signature: \");\n-          print_class_signature_for_mirror(&st, scratch_mirror);\n-          st.cr();\n-\n-          Klass* src_klass = java_lang_Class::as_Klass(scratch_mirror);\n-          if (src_klass != nullptr && src_klass->is_instance_klass()) {\n-            oop rr = HeapShared::scratch_resolved_references(InstanceKlass::cast(src_klass)->constants());\n-            st.print(\" - archived_resolved_references: \");\n-            print_oop_info_cr(&st, rr);\n-\n-            \/\/ We need to print the fields in the scratch_mirror, not the original mirror.\n-            \/\/ (if a class is not aot-initialized, static fields in its scratch mirror will be cleared).\n-            assert(scratch_mirror == HeapShared::scratch_java_mirror(src_klass->java_mirror()), \"sanity\");\n-            st.print_cr(\"- ---- static fields (%d):\", java_lang_Class::static_oop_field_count(scratch_mirror));\n-            InstanceKlass::cast(src_klass)->do_local_static_fields(&print_field);\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  static void print_class_signature_for_mirror(outputStream* st, oop scratch_mirror) {\n-    assert(java_lang_Class::is_instance(scratch_mirror), \"sanity\");\n-    if (java_lang_Class::is_primitive(scratch_mirror)) {\n-      for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n-        BasicType bt = (BasicType)i;\n-        if (!is_reference_type(bt) && scratch_mirror == HeapShared::scratch_java_mirror(bt)) {\n-          oop orig_mirror = Universe::java_mirror(bt);\n-          java_lang_Class::print_signature(orig_mirror, st);\n-          return;\n-        }\n-      }\n-      ShouldNotReachHere();\n-    }\n-    java_lang_Class::print_signature(scratch_mirror, st);\n-  }\n-\n-  static void log_heap_roots() {\n-    LogStreamHandle(Trace, aot, map, oops) st;\n-    if (st.is_enabled()) {\n-      for (int i = 0; i < HeapShared::pending_roots()->length(); i++) {\n-        st.print(\"roots[%4d]: \", i);\n-        print_oop_info_cr(&st, HeapShared::pending_roots()->at(i));\n-      }\n-    }\n-  }\n-\n-  \/\/ Example output:\n-  \/\/ - The first number is the requested address (if print_requested_addr == true)\n-  \/\/ - The second number is the narrowOop version of the requested address (if UseCompressedOops == true)\n-  \/\/     0x00000007ffc7e840 (0xfff8fd08) java.lang.Class Ljava\/util\/Array;\n-  \/\/     0x00000007ffc000f8 (0xfff8001f) [B length: 11\n-  static void print_oop_info_cr(outputStream* st, oop source_oop, bool print_requested_addr = true) {\n-    if (source_oop == nullptr) {\n-      st->print_cr(\"null\");\n-    } else {\n-      ResourceMark rm;\n-      oop requested_obj = ArchiveHeapWriter::source_obj_to_requested_obj(source_oop);\n-      if (print_requested_addr) {\n-        st->print(PTR_FORMAT \" \", p2i(requested_obj));\n-      }\n-      if (UseCompressedOops) {\n-        st->print(\"(0x%08x) \", CompressedOops::narrow_oop_value(requested_obj));\n-      }\n-      if (source_oop->is_array()) {\n-        int array_len = arrayOop(source_oop)->length();\n-        st->print_cr(\"%s length: %d\", source_oop->klass()->external_name(), array_len);\n-      } else {\n-        st->print(\"%s\", source_oop->klass()->external_name());\n-\n-        if (java_lang_String::is_instance(source_oop)) {\n-          st->print(\" \");\n-          java_lang_String::print(source_oop, st);\n-        } else if (java_lang_Class::is_instance(source_oop)) {\n-          oop scratch_mirror = source_oop;\n-\n-          st->print(\" \");\n-          print_class_signature_for_mirror(st, scratch_mirror);\n-\n-          Klass* src_klass = java_lang_Class::as_Klass(scratch_mirror);\n-          if (src_klass != nullptr && src_klass->is_instance_klass()) {\n-            InstanceKlass* buffered_klass =\n-              ArchiveBuilder::current()->get_buffered_addr(InstanceKlass::cast(src_klass));\n-            if (buffered_klass->has_aot_initialized_mirror()) {\n-              st->print(\" (aot-inited)\");\n-            }\n-          }\n-        }\n-        st->cr();\n-      }\n-    }\n-  }\n-#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n-\n-  \/\/ Log all the data [base...top). Pretend that the base address\n-  \/\/ will be mapped to requested_base at run-time.\n-  static void log_as_hex(address base, address top, address requested_base, bool is_heap = false) {\n-    assert(top >= base, \"must be\");\n-\n-    LogStreamHandle(Trace, aot, map) lsh;\n-    if (lsh.is_enabled()) {\n-      int unitsize = sizeof(address);\n-      if (is_heap && UseCompressedOops) {\n-        \/\/ This makes the compressed oop pointers easier to read, but\n-        \/\/ longs and doubles will be split into two words.\n-        unitsize = sizeof(narrowOop);\n-      }\n-      os::print_hex_dump(&lsh, base, top, unitsize, \/* print_ascii=*\/true, \/* bytes_per_line=*\/32, requested_base);\n-    }\n-  }\n-\n-  static void log_header(FileMapInfo* mapinfo) {\n-    LogStreamHandle(Info, aot, map) lsh;\n-    if (lsh.is_enabled()) {\n-      mapinfo->print(&lsh);\n-    }\n-  }\n-\n-public:\n-  static void log(ArchiveBuilder* builder, FileMapInfo* mapinfo,\n-                  ArchiveHeapInfo* heap_info,\n-                  char* bitmap, size_t bitmap_size_in_bytes) {\n-    log_info(aot, map)(\"%s CDS archive map for %s\", CDSConfig::is_dumping_static_archive() ? \"Static\" : \"Dynamic\", mapinfo->full_path());\n-\n-    address header = address(mapinfo->header());\n-    address header_end = header + mapinfo->header()->header_size();\n-    log_region(\"header\", header, header_end, nullptr);\n-    log_header(mapinfo);\n-    log_as_hex(header, header_end, nullptr);\n-\n-    DumpRegion* rw_region = &builder->_rw_region;\n-    DumpRegion* ro_region = &builder->_ro_region;\n-\n-    log_metaspace_region(\"rw region\", rw_region, &builder->_rw_src_objs);\n-    log_metaspace_region(\"ro region\", ro_region, &builder->_ro_src_objs);\n-\n-    address bitmap_end = address(bitmap + bitmap_size_in_bytes);\n-    log_region(\"bitmap\", address(bitmap), bitmap_end, nullptr);\n-    log_as_hex((address)bitmap, bitmap_end, nullptr);\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-    if (heap_info->is_used()) {\n-      log_heap_region(heap_info);\n-    }\n-#endif\n-\n-    log_info(aot, map)(\"[End of CDS archive map]\");\n-  }\n-}; \/\/ end ArchiveBuilder::CDSMapLogger\n-\n@@ -1648,2 +1224,1 @@\n-    CDSMapLogger::log(this, mapinfo, heap_info,\n-                      bitmap, bitmap_size_in_bytes);\n+    AOTMapLogger::dumptime_log(this, mapinfo, heap_info, bitmap, bitmap_size_in_bytes);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":3,"deletions":428,"binary":false,"changes":431,"status":"modified"},{"patch":"@@ -96,0 +96,2 @@\n+  friend class AOTMapLogger;\n+\n@@ -205,2 +207,0 @@\n-  class CDSMapLogger;\n-\n@@ -319,0 +319,6 @@\n+  template <typename T> T requested_to_buffered(T obj) const {\n+    T b = (T)(address(obj) - _buffer_to_requested_delta);\n+    assert(is_in_buffer_space(b), \"must be\");\n+    return b;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -165,0 +165,38 @@\n+Klass* ArchiveHeapWriter::real_klass_of_buffered_oop(address buffered_addr) {\n+  oop p = buffered_addr_to_source_obj(buffered_addr);\n+  if (p != nullptr) {\n+    return p->klass();\n+  } else if (get_filler_size_at(buffered_addr) > 0) {\n+    return Universe::fillerArrayKlass();\n+  } else {\n+    \/\/ This is one of the root segments\n+    return Universe::objectArrayKlass();\n+  }\n+}\n+\n+size_t ArchiveHeapWriter::size_of_buffered_oop(address buffered_addr) {\n+  oop p = buffered_addr_to_source_obj(buffered_addr);\n+  if (p != nullptr) {\n+    return p->size();\n+  }\n+\n+  size_t nbytes = get_filler_size_at(buffered_addr);\n+  if (nbytes > 0) {\n+    assert((nbytes % BytesPerWord) == 0, \"should be aligned\");\n+    return nbytes \/ BytesPerWord;\n+  }\n+\n+  address hrs = buffer_bottom();\n+  for (size_t seg_idx = 0; seg_idx < _heap_root_segments.count(); seg_idx++) {\n+    nbytes = _heap_root_segments.size_in_bytes(seg_idx);\n+    if (hrs == buffered_addr) {\n+      assert((nbytes % BytesPerWord) == 0, \"should be aligned\");\n+      return nbytes \/ BytesPerWord;\n+    }\n+    hrs += nbytes;\n+  }\n+\n+  ShouldNotReachHere();\n+  return 0;\n+}\n+\n@@ -712,21 +750,0 @@\n-\/\/ Do we have a jlong\/jint field that's actually a pointer to a MetaspaceObj?\n-bool ArchiveHeapWriter::is_marked_as_native_pointer(ArchiveHeapInfo* heap_info, oop src_obj, int field_offset) {\n-  HeapShared::CachedOopInfo* p = HeapShared::archived_object_cache()->get(src_obj);\n-  assert(p != nullptr, \"must be\");\n-\n-  \/\/ requested_field_addr = the address of this field in the requested space\n-  oop requested_obj = requested_obj_from_buffer_offset(p->buffer_offset());\n-  Metadata** requested_field_addr = (Metadata**)(cast_from_oop<address>(requested_obj) + field_offset);\n-  assert((Metadata**)_requested_bottom <= requested_field_addr && requested_field_addr < (Metadata**) _requested_top, \"range check\");\n-\n-  BitMap::idx_t idx = requested_field_addr - (Metadata**) _requested_bottom;\n-  \/\/ Leading zeros have been removed so some addresses may not be in the ptrmap\n-  size_t start_pos = FileMapInfo::current_info()->heap_ptrmap_start_pos();\n-  if (idx < start_pos) {\n-    return false;\n-  } else {\n-    idx -= start_pos;\n-  }\n-  return (idx < heap_info->ptrmap()->size()) && (heap_info->ptrmap()->at(idx) == true);\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":38,"deletions":21,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -239,1 +239,0 @@\n-  static bool is_marked_as_native_pointer(ArchiveHeapInfo* heap_info, oop src_obj, int field_offset);\n@@ -243,1 +242,2 @@\n-\n+  static Klass* real_klass_of_buffered_oop(address buffered_addr);\n+  static size_t size_of_buffered_oop(address buffered_addr);\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotMapLogger.hpp\"\n@@ -107,0 +108,2 @@\n+\n+  AOTMapLogger::ergo_initialize();\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"cds\/aotMapLogger.hpp\"\n@@ -328,0 +329,18 @@\n+    FileMapInfo *static_mapinfo = FileMapInfo::current_info();\n+    FileMapInfo *dynamic_mapinfo = FileMapInfo::dynamic_info();\n+\n+    if (AOTMapLogger::is_logging_at_bootstrap()) {\n+      \/\/ The map logging needs to be done here, as it requires some stubs on Windows,\n+      \/\/ which are not generated until the end of init_globals().\n+      AOTMapLogger::runtime_log(static_mapinfo, dynamic_mapinfo);\n+    }\n+\n+    \/\/ Close any open file descriptors. However, mmap'ed pages will remain in memory.\n+    static_mapinfo->close();\n+    static_mapinfo->unmap_region(MetaspaceShared::bm);\n+\n+    if (dynamic_mapinfo != nullptr) {\n+      dynamic_mapinfo->close();\n+      dynamic_mapinfo->unmap_region(MetaspaceShared::bm);\n+    }\n+\n@@ -1957,0 +1976,1 @@\n+  FileMapInfo *dynamic_mapinfo = FileMapInfo::dynamic_info();\n@@ -1972,6 +1992,0 @@\n-  \/\/ Close the mapinfo file\n-  static_mapinfo->close();\n-\n-  static_mapinfo->unmap_region(MetaspaceShared::bm);\n-\n-  FileMapInfo *dynamic_mapinfo = FileMapInfo::dynamic_info();\n@@ -1983,2 +1997,0 @@\n-    dynamic_mapinfo->close();\n-    dynamic_mapinfo->unmap_region(MetaspaceShared::bm);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-    os::vsnprintf(e, m - e, fmt, args);\n+    (void) os::vsnprintf(e, m - e, fmt, args);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4095,1 +4095,1 @@\n-  const Klass* const super = this_klass->super();\n+  const InstanceKlass* const super = this_klass->java_super();\n@@ -4098,2 +4098,0 @@\n-    const InstanceKlass* super_ik = InstanceKlass::cast(super);\n-\n@@ -4101,1 +4099,1 @@\n-      classfile_icce_error(\"class %s cannot inherit from final class %s\", super_ik, THREAD);\n+      classfile_icce_error(\"class %s cannot inherit from final class %s\", super, THREAD);\n@@ -4105,1 +4103,1 @@\n-    if (super_ik->is_sealed()) {\n+    if (super->is_sealed()) {\n@@ -4108,1 +4106,1 @@\n-      if (!super_ik->has_as_permitted_subclass(this_klass, ss)) {\n+      if (!super->has_as_permitted_subclass(this_klass, ss)) {\n@@ -4115,1 +4113,1 @@\n-      Reflection::verify_class_access(this_klass, InstanceKlass::cast(super), false);\n+      Reflection::verify_class_access(this_klass, super, false);\n@@ -4119,1 +4117,1 @@\n-                                                      InstanceKlass::cast(super),\n+                                                      super,\n@@ -4221,1 +4219,1 @@\n-          super_m = InstanceKlass::cast(k)->lookup_method(name, signature);\n+          super_m = k->lookup_method(name, signature);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -319,1 +319,1 @@\n-    ik = ik->super() == nullptr ? nullptr : InstanceKlass::cast(ik->super());\n+    ik = ik->java_super() == nullptr ? nullptr : ik->java_super();\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2622,2 +2622,2 @@\n-  size_t buf_off = os::snprintf_checked(buf, buf_size, \"\\tat %s.%s(\", klass_name, method_name);\n-\n+  int buf_off = os::snprintf(buf, buf_size, \"\\tat %s.%s(\", klass_name, method_name);\n+  assert(static_cast<size_t>(buf_off) < buf_size, \"buffer is wrong size\");\n@@ -2627,1 +2627,2 @@\n-      buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"%s@%s\/\", module_name, module_version);\n+      buf_off += os::snprintf(buf + buf_off, buf_size - buf_off, \"%s@%s\/\", module_name, module_version);\n+      assert(static_cast<size_t>(buf_off) < buf_size, \"buffer is wrong size\");\n@@ -2629,1 +2630,2 @@\n-      buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"%s\/\", module_name);\n+      buf_off += os::snprintf(buf + buf_off, buf_size - buf_off, \"%s\/\", module_name);\n+      assert(static_cast<size_t>(buf_off) < buf_size, \"buffer is wrong size\");\n@@ -2644,1 +2646,2 @@\n-        buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"%s:%d)\", source_file_name, line_number);\n+        buf_off += os::snprintf(buf + buf_off, buf_size - buf_off, \"%s:%d)\", source_file_name, line_number);\n+        assert(static_cast<size_t>(buf_off) < buf_size, \"buffer is wrong size\");\n@@ -2647,1 +2650,2 @@\n-        buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"%s)\", source_file_name);\n+        buf_off += os::snprintf(buf + buf_off, buf_size - buf_off, \"%s)\", source_file_name);\n+        assert(static_cast<size_t>(buf_off) < buf_size, \"buffer is wrong size\");\n@@ -2650,1 +2654,2 @@\n-        buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"Unknown Source)\");\n+        buf_off += os::snprintf(buf + buf_off, buf_size - buf_off, \"Unknown Source)\");\n+        assert(static_cast<size_t>(buf_off) < buf_size, \"buffer is wrong size\");\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1052,1 +1052,1 @@\n-    bool check_super = check_shared_class_super_type(ik, InstanceKlass::cast(ik->super()),\n+    bool check_super = check_shared_class_super_type(ik, ik->java_super(),\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1182,0 +1182,6 @@\n+void SystemDictionaryShared::get_all_archived_classes(bool is_static_archive, GrowableArray<Klass*>* classes) {\n+  get_archive(is_static_archive)->_builtin_dictionary.iterate([&] (const RunTimeClassInfo* record) {\n+      classes->append(record->klass());\n+    });\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -118,0 +118,2 @@\n+template <typename E> class GrowableArray;\n+\n@@ -272,0 +274,1 @@\n+  static void get_all_archived_classes(bool is_static_archive, GrowableArray<Klass*>* classes);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -228,1 +228,1 @@\n-  Klass* super = klass->super();\n+  InstanceKlass* super = klass->java_super();\n@@ -231,1 +231,1 @@\n-    resolve_shared_class(InstanceKlass::cast(super), loader_data, domain, CHECK);\n+    resolve_shared_class(super, loader_data, domain, CHECK);\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -742,1 +742,1 @@\n-              os::snprintf(new_blob_name, size, \"%s jvmci_name=%s\", blob_name, jvmci_name);\n+              os::snprintf_checked(new_blob_name, size, \"%s jvmci_name=%s\", blob_name, jvmci_name);\n","filename":"src\/hotspot\/share\/code\/codeHeapState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-      os::snprintf(tmp, sizeof(tmp), \"%9zu (%+zd)\", e._bytes.cur, e._bytes.end_delta());\n+      os::snprintf_checked(tmp, sizeof(tmp), \"%9zu (%+zd)\", e._bytes.cur, e._bytes.end_delta());\n@@ -164,1 +164,1 @@\n-      os::snprintf(tmp, sizeof(tmp), \"%6u (%+d)\", e._live_nodes.cur, e._live_nodes.end_delta());\n+      os::snprintf_checked(tmp, sizeof(tmp), \"%6u (%+d)\", e._live_nodes.cur, e._live_nodes.end_delta());\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-void CompilationPolicy::replay_training_at_init_impl(InstanceKlass* klass, TRAPS) {\n+void CompilationPolicy::replay_training_at_init_impl(InstanceKlass* klass, JavaThread* current) {\n@@ -153,1 +153,1 @@\n-          if (ctd->init_deps_left() == 0) {\n+          if (ctd->init_deps_left_acquire() == 0) {\n@@ -156,2 +156,2 @@\n-              const methodHandle mh(THREAD, const_cast<Method*>(mtd->holder()));\n-              CompilationPolicy::maybe_compile_early(mh, THREAD);\n+              const methodHandle mh(current, const_cast<Method*>(mtd->holder()));\n+              CompilationPolicy::maybe_compile_early(mh, current);\n@@ -166,1 +166,1 @@\n-void CompilationPolicy::replay_training_at_init(InstanceKlass* klass, TRAPS) {\n+void CompilationPolicy::replay_training_at_init(InstanceKlass* klass, JavaThread* current) {\n@@ -169,1 +169,1 @@\n-    _training_replay_queue.push(klass, TrainingReplayQueue_lock, THREAD);\n+    _training_replay_queue.push(klass, TrainingReplayQueue_lock, current);\n@@ -184,1 +184,1 @@\n-void CompilationPolicy::replay_training_at_init_loop(TRAPS) {\n+void CompilationPolicy::replay_training_at_init_loop(JavaThread* current) {\n@@ -186,1 +186,1 @@\n-    InstanceKlass* ik = _training_replay_queue.pop(TrainingReplayQueue_lock, THREAD);\n+    InstanceKlass* ik = _training_replay_queue.pop(TrainingReplayQueue_lock, current);\n@@ -188,1 +188,1 @@\n-      replay_training_at_init_impl(ik, THREAD);\n+      replay_training_at_init_impl(ik, current);\n@@ -449,1 +449,1 @@\n-      st->print(\"%d\", ctd->init_deps_left());\n+      st->print(\"%d\", ctd->init_deps_left_acquire());\n@@ -1175,1 +1175,1 @@\n-  if (SkipTier2IfPossible && ctd->init_deps_left() == 0) {\n+  if (SkipTier2IfPossible && ctd->init_deps_left_acquire() == 0) {\n@@ -1203,1 +1203,1 @@\n-  if (ctd != nullptr && ctd->init_deps_left() == 0) {\n+  if (ctd != nullptr && ctd->init_deps_left_acquire() == 0) {\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -77,2 +77,2 @@\n-  void push(T* value, Monitor* lock, TRAPS) {\n-    MonitorLocker locker(THREAD, lock);\n+  void push(T* value, Monitor* lock, JavaThread* current) {\n+    MonitorLocker locker(current, lock);\n@@ -85,3 +85,3 @@\n-  T* pop(Monitor* lock, TRAPS) {\n-    MonitorLocker locker(THREAD, lock);\n-    while(is_empty_unlocked() && !CompileBroker::is_compilation_disabled_forever()) {\n+  T* pop(Monitor* lock, JavaThread* current) {\n+    MonitorLocker locker(current, lock);\n+    while (is_empty_unlocked() && !CompileBroker::is_compilation_disabled_forever()) {\n@@ -94,6 +94,3 @@\n-  T* try_pop(Monitor* lock, TRAPS) {\n-    MonitorLocker locker(THREAD, lock);\n-    T* value = nullptr;\n-    if (!is_empty_unlocked()) {\n-      value = pop_unlocked();\n-    }\n+  T* try_pop(Monitor* lock, JavaThread* current) {\n+    MonitorLocker locker(current, lock);\n+    T* value = pop_unlocked();\n@@ -102,1 +99,0 @@\n-\n@@ -345,1 +341,1 @@\n-  static void replay_training_at_init_impl(InstanceKlass* klass, TRAPS);\n+  static void replay_training_at_init_impl(InstanceKlass* klass, JavaThread* current);\n@@ -355,2 +351,2 @@\n-  static void replay_training_at_init(InstanceKlass* klass, TRAPS);\n-  static void replay_training_at_init_loop(TRAPS);\n+  static void replay_training_at_init(InstanceKlass* klass, JavaThread* current);\n+  static void replay_training_at_init_loop(JavaThread* current);\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.hpp","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1064,1 +1064,3 @@\n-  julong free_memory = os::free_memory();\n+  size_t free_memory = 0;\n+  \/\/ Return value ignored - defaulting to 0 on failure.\n+  (void)os::free_memory(free_memory);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -624,0 +624,5 @@\n+  if (UseAutoVectorizationSpeculativeAliasingChecks && !LoopMultiversioning && !UseAutoVectorizationPredicate) {\n+    warning(\"Disabling UseAutoVectorizationSpeculativeAliasingChecks, because neither of the following is enabled:\"\n+            \"  LoopMultiversioning UseAutoVectorizationPredicate\");\n+    UseAutoVectorizationSpeculativeAliasingChecks = false;\n+  }\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"services\/cpuTimeUsage.hpp\"\n@@ -76,0 +77,2 @@\n+    _gc_cpu_time_at_pause_end_ms(),\n+    _concurrent_gc_cpu_time_ms(),\n@@ -91,2 +94,2 @@\n-    _long_term_pause_time_ratio(0.0),\n-    _short_term_pause_time_ratio(0.0) {\n+    _long_term_gc_time_ratio(0.0),\n+    _short_term_gc_time_ratio(0.0) {\n@@ -152,0 +155,4 @@\n+double G1Analytics::gc_cpu_time_ms() const {\n+  return (double)CPUTimeUsage::GC::gc_threads() \/ NANOSECS_PER_MILLISEC;\n+}\n+\n@@ -160,1 +167,9 @@\n-void G1Analytics::compute_pause_time_ratios(double end_time_sec, double pause_time_ms) {\n+void G1Analytics::update_gc_time_ratios(double end_time_sec, double pause_time_ms) {\n+  \/\/ This estimates the wall-clock time \"lost\" by application mutator threads due to concurrent GC\n+  \/\/ activity. We do not account for contention on other shared resources such as memory bandwidth and\n+  \/\/ caches, therefore underestimate the impact of the concurrent GC activity on mutator threads.\n+  uint num_cpus = (uint)os::active_processor_count();\n+  double concurrent_gc_impact_time = _concurrent_gc_cpu_time_ms \/ num_cpus;\n+\n+  double gc_time_ms = pause_time_ms + concurrent_gc_impact_time;\n+\n@@ -162,3 +177,4 @@\n-  double gc_pause_time_ms = _recent_gc_times_ms.sum() - _recent_gc_times_ms.oldest() + pause_time_ms;\n-  _long_term_pause_time_ratio = gc_pause_time_ms \/ long_interval_ms;\n-  _long_term_pause_time_ratio = clamp(_long_term_pause_time_ratio, 0.0, 1.0);\n+  double long_term_gc_time_ms = _recent_gc_times_ms.sum() - _recent_gc_times_ms.oldest() + gc_time_ms;\n+\n+  _long_term_gc_time_ratio = long_term_gc_time_ms \/ long_interval_ms;\n+  _long_term_gc_time_ratio = clamp(_long_term_gc_time_ratio, 0.0, 1.0);\n@@ -167,2 +183,6 @@\n-  _short_term_pause_time_ratio = pause_time_ms \/ short_interval_ms;\n-  _short_term_pause_time_ratio = clamp(_short_term_pause_time_ratio, 0.0, 1.0);\n+\n+  assert(short_interval_ms != 0.0, \"short_interval_ms should not be zero, calculated from %f and %f\", end_time_sec,  most_recent_gc_end_time_sec());\n+  _short_term_gc_time_ratio = gc_time_ms \/ short_interval_ms;\n+  _short_term_gc_time_ratio = clamp(_short_term_gc_time_ratio, 0.0, 1.0);\n+\n+  update_recent_gc_times(end_time_sec, gc_time_ms);\n@@ -308,2 +328,2 @@\n-                                         double pause_time_ms) {\n-  _recent_gc_times_ms.add(pause_time_ms);\n+                                         double gc_time_ms) {\n+  _recent_gc_times_ms.add(gc_time_ms);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Analytics.cpp","additions":30,"deletions":10,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -47,1 +47,9 @@\n-  double        _prev_collection_pause_end_ms;\n+  double       _prev_collection_pause_end_ms;\n+\n+  \/\/ Records the total GC CPU time (in ms) at the end of the last GC pause.\n+  \/\/ Used as a baseline to calculate CPU time spent in GC threads between pauses.\n+  double _gc_cpu_time_at_pause_end_ms;\n+\n+  \/\/ CPU time (ms) spent by GC threads between the end of the last pause\n+  \/\/ and the start of the current pause; calculated at start of a GC pause.\n+  double _concurrent_gc_cpu_time_ms;\n@@ -78,4 +86,4 @@\n-  \/\/ Cached values for long and short term pause time ratios. See\n-  \/\/ compute_pause_time_ratios() for how they are computed.\n-  double _long_term_pause_time_ratio;\n-  double _short_term_pause_time_ratio;\n+  \/\/ Cached values for long and short term gc time ratios. See\n+  \/\/ update_gc_time_ratios() for how they are computed.\n+  double _long_term_gc_time_ratio;\n+  double _short_term_gc_time_ratio;\n@@ -105,2 +113,2 @@\n-  double long_term_pause_time_ratio() const {\n-    return _long_term_pause_time_ratio;\n+  double long_term_gc_time_ratio() const {\n+    return _long_term_gc_time_ratio;\n@@ -109,2 +117,2 @@\n-  double short_term_pause_time_ratio() const {\n-    return _short_term_pause_time_ratio;\n+  double short_term_gc_time_ratio() const {\n+    return _short_term_gc_time_ratio;\n@@ -125,0 +133,14 @@\n+  void set_gc_cpu_time_at_pause_end_ms(double ms) {\n+    _gc_cpu_time_at_pause_end_ms = ms;\n+  }\n+\n+  double gc_cpu_time_at_pause_end_ms() const {\n+    return _gc_cpu_time_at_pause_end_ms;\n+  }\n+\n+  void set_concurrent_gc_cpu_time_ms(double ms) {\n+    _concurrent_gc_cpu_time_ms = ms;\n+  }\n+\n+  double gc_cpu_time_ms() const;\n+\n@@ -176,2 +198,2 @@\n-  void update_recent_gc_times(double end_time_sec, double elapsed_ms);\n-  void compute_pause_time_ratios(double end_time_sec, double pause_time_ms);\n+  void update_recent_gc_times(double end_time_sec, double gc_time_ms);\n+  void update_gc_time_ratios(double end_time_sec, double pause_time_ms);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Analytics.hpp","additions":33,"deletions":11,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2444,0 +2444,6 @@\n+  \/\/ Clear current young cset group to allow adding.\n+  \/\/ It is fine to clear it this late - evacuation does not add any remembered sets\n+  \/\/ by itself, but only marks cards.\n+  \/\/ The regions had their association to this group already removed earlier.\n+  young_regions_cset_group()->clear();\n+\n@@ -2800,0 +2806,2 @@\n+\n+  young_regions_cset_group()->clear(true \/* uninstall_group_cardset *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -326,1 +326,4 @@\n-  double predicted_base_time_ms = _policy->predict_base_time_ms(pending_cards, _g1h->young_regions_cardset()->occupied());\n+  size_t num_young_cards = _g1h->young_regions_cardset()->occupied();\n+  _policy->record_card_rs_length(num_young_cards);\n+\n+  double predicted_base_time_ms = _policy->predict_base_time_ms(pending_cards, num_young_cards);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -247,5 +247,0 @@\n-  \/\/ We clear remembered sets for young regions this late in the full GC because\n-  \/\/ G1HeapVerifier expects the remembered sets for all young regions to be complete\n-  \/\/ throughout most of the collection process (e.g. G1FullCollector::verify_after_marking).\n-  _heap->young_regions_cset_group()->clear();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -220,2 +220,2 @@\n-  const double long_term_gc_cpu_usage = _analytics->long_term_pause_time_ratio();\n-  const double short_term_gc_cpu_usage = _analytics->short_term_pause_time_ratio();\n+  const double long_term_gc_cpu_usage = _analytics->long_term_gc_time_ratio();\n+  const double short_term_gc_cpu_usage = _analytics->short_term_gc_time_ratio();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -238,0 +238,2 @@\n+  bool is_in_full_gc() const { return G1CollectedHeap::heap()->collector_state()->in_full_gc(); }\n+\n@@ -249,1 +251,1 @@\n-    guarantee(!r->is_young() || r->rem_set()->is_complete(), \"Remembered set for Young region %u must be complete, is %s\", r->hrm_index(), r->rem_set()->get_state_str());\n+    guarantee(is_in_full_gc() || !r->is_young() || r->rem_set()->is_complete(), \"Remembered set for Young region %u must be complete outside full gc, is %s\", r->hrm_index(), r->rem_set()->get_state_str());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -667,0 +667,6 @@\n+\n+  double prev_gc_cpu_pause_end_ms = _analytics->gc_cpu_time_at_pause_end_ms();\n+  double cur_gc_cpu_time_ms = _analytics->gc_cpu_time_ms();\n+\n+  double concurrent_gc_cpu_time_ms = cur_gc_cpu_time_ms - prev_gc_cpu_pause_end_ms;\n+  _analytics->set_concurrent_gc_cpu_time_ms(concurrent_gc_cpu_time_ms);\n@@ -1349,2 +1355,1 @@\n-  _analytics->compute_pause_time_ratios(end_time_sec, pause_time_ms);\n-  _analytics->update_recent_gc_times(end_time_sec, pause_time_ms);\n+  _analytics->update_gc_time_ratios(end_time_sec, pause_time_ms);\n@@ -1373,0 +1378,3 @@\n+\n+  double elapsed_gc_cpu_time = _analytics->gc_cpu_time_ms();\n+  _analytics->set_gc_cpu_time_at_pause_end_ms(elapsed_gc_cpu_time);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -132,2 +132,2 @@\n-  void record_card_rs_length(size_t card_rs_length) {\n-    _card_rs_length = card_rs_length;\n+  void record_card_rs_length(size_t num_cards) {\n+    _card_rs_length = num_cards;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1443,10 +1443,0 @@\n-  {\n-    size_t young_rs_length = g1h->young_regions_cardset()->occupied();\n-    \/\/ We only use young_rs_length statistics to estimate young regions length.\n-    g1h->policy()->record_card_rs_length(young_rs_length);\n-\n-    \/\/ Clear current young only collection set. Survivor regions will be added\n-    \/\/ to the set during evacuation.\n-    g1h->young_regions_cset_group()->clear();\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -84,6 +84,6 @@\n-      snprintf(evacuation_failed_string,\n-               ARRAY_SIZE(evacuation_failed_string),\n-               \" (Evacuation Failure: %s%s%s)\",\n-               _collector->evacuation_alloc_failed() ? \"Allocation\" : \"\",\n-               _collector->evacuation_alloc_failed() && _collector->evacuation_pinned() ? \" \/ \" : \"\",\n-               _collector->evacuation_pinned() ? \"Pinned\" : \"\");\n+      os::snprintf_checked(evacuation_failed_string,\n+                           ARRAY_SIZE(evacuation_failed_string),\n+                           \" (Evacuation Failure: %s%s%s)\",\n+                           _collector->evacuation_alloc_failed() ? \"Allocation\" : \"\",\n+                           _collector->evacuation_alloc_failed() && _collector->evacuation_pinned() ? \" \/ \" : \"\",\n+                           _collector->evacuation_pinned() ? \"Pinned\" : \"\");\n@@ -91,6 +91,6 @@\n-    snprintf(_young_gc_name_data,\n-             MaxYoungGCNameLength,\n-             \"Pause Young (%s) (%s)%s\",\n-             G1GCPauseTypeHelper::to_string(_pause_type),\n-             GCCause::to_string(_pause_cause),\n-             evacuation_failed_string);\n+    os::snprintf_checked(_young_gc_name_data,\n+                         MaxYoungGCNameLength,\n+                         \"Pause Young (%s) (%s)%s\",\n+                         G1GCPauseTypeHelper::to_string(_pause_type),\n+                         GCCause::to_string(_pause_cause),\n+                         evacuation_failed_string);\n@@ -522,1 +522,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -106,2 +106,1 @@\n-                                          max_gc_pause_sec,\n-                                          GCTimeRatio);\n+                                          max_gc_pause_sec);\n@@ -283,1 +282,2 @@\n-  {\n+  for (uint loop_count = 0; \/* empty *\/; ++loop_count) {\n+    \/\/ Try young-gen first.\n@@ -288,1 +288,0 @@\n-  }\n@@ -290,2 +289,9 @@\n-  uint loop_count = 0;\n-  uint gc_count = 0;\n+    \/\/ Try allocating from the old gen for non-TLAB in certain scenarios.\n+    if (!is_tlab) {\n+      if (!should_alloc_in_eden(size) || _is_heap_almost_full) {\n+        result = old_gen()->cas_allocate_noexpand(size);\n+        if (result != nullptr) {\n+          return result;\n+        }\n+      }\n+    }\n@@ -293,1 +299,0 @@\n-  while (true) {\n@@ -305,0 +310,1 @@\n+    uint gc_count;\n@@ -308,15 +314,0 @@\n-\n-      HeapWord* result = young_gen()->allocate(size);\n-      if (result != nullptr) {\n-        return result;\n-      }\n-\n-      \/\/ Try allocating from the old gen for non-TLAB in certain scenarios.\n-      if (!is_tlab) {\n-        if (!should_alloc_in_eden(size) || _is_heap_almost_full) {\n-          result = old_gen()->cas_allocate_noexpand(size);\n-          if (result != nullptr) {\n-            return result;\n-          }\n-        }\n-      }\n@@ -329,3 +320,0 @@\n-      \/\/ Did the VM operation execute? If so, return the result directly.\n-      \/\/ This prevents us from looping until time out on requests that can\n-      \/\/ not be satisfied.\n@@ -334,1 +322,0 @@\n-\n@@ -337,4 +324,0 @@\n-      \/\/ Was the gc-overhead reached inside the safepoint? If so, this mutator should return null as well for global consistency.\n-      if (_gc_overhead_counter >= GCOverheadLimitThreshold) {\n-        return nullptr;\n-      }\n@@ -343,1 +326,6 @@\n-    loop_count++;\n+    \/\/ Was the gc-overhead reached inside the safepoint? If so, this mutator\n+    \/\/ should return null as well for global consistency.\n+    if (_gc_overhead_counter >= GCOverheadLimitThreshold) {\n+      return nullptr;\n+    }\n+\n@@ -346,2 +334,1 @@\n-      log_warning(gc)(\"ParallelScavengeHeap::mem_allocate retries %d times\", loop_count);\n-      log_warning(gc)(\"\\tsize=%zu\", size);\n+      log_warning(gc)(\"ParallelScavengeHeap::mem_allocate retries %d times, size=%zu\", loop_count, size);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":20,"deletions":33,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -39,4 +39,2 @@\n-                                           double gc_pause_goal_sec,\n-                                           uint gc_cost_ratio) :\n-     AdaptiveSizePolicy(gc_pause_goal_sec,\n-                        gc_cost_ratio),\n+                                           double gc_pause_goal_sec) :\n+     AdaptiveSizePolicy(gc_pause_goal_sec),\n@@ -76,0 +74,10 @@\n+\/\/ The throughput goal is implemented as\n+\/\/      _throughput_goal = 1 - (1 \/ (1 + gc_cost_ratio))\n+\/\/ gc_cost_ratio is the ratio\n+\/\/      application cost \/ gc cost\n+\/\/ For example a gc_cost_ratio of 4 translates into a\n+\/\/ throughput goal of .80\n+static double calculate_throughput_goal(double gc_cost_ratio) {\n+  return 1.0 - (1.0 \/ (1.0 + gc_cost_ratio));\n+}\n+\n@@ -81,1 +89,5 @@\n-  if (mutator_time_percent() < _throughput_goal) {\n+  \/\/ Get a local copy and use it inside gc-pause in case the global var gets updated externally.\n+  const uint local_GCTimeRatio = Atomic::load(&GCTimeRatio);\n+  const double throughput_goal = calculate_throughput_goal(local_GCTimeRatio);\n+\n+  if (mutator_time_percent() < throughput_goal) {\n@@ -83,1 +95,1 @@\n-    const double expected_gc_distance = _trimmed_minor_gc_time_seconds.last() * GCTimeRatio;\n+    const double expected_gc_distance = _trimmed_minor_gc_time_seconds.last() * local_GCTimeRatio;\n@@ -93,1 +105,1 @@\n-      mutator_time_percent(), _throughput_goal, (new_eden - cur_eden)\/K);\n+      mutator_time_percent(), throughput_goal, (new_eden - cur_eden)\/K);\n@@ -121,1 +133,1 @@\n-    const double gc_distance_target = MAX3(minor_gc_time_conservative_estimate() * GCTimeRatio,\n+    const double gc_distance_target = MAX3(minor_gc_time_conservative_estimate() * local_GCTimeRatio,\n","filename":"src\/hotspot\/share\/gc\/parallel\/psAdaptiveSizePolicy.cpp","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -64,2 +64,1 @@\n-                       double gc_pause_goal_sec,\n-                       uint gc_time_ratio);\n+                       double gc_pause_goal_sec);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psAdaptiveSizePolicy.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  \/\/ Invoked by mutators and GC-workers.\n+  \/\/ Used by GC-workers during GC or for CDS at startup.\n@@ -123,1 +123,0 @@\n-    assert_locked_or_safepoint(Heap_lock);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -972,0 +972,1 @@\n+  assert(ref_processor() != nullptr, \"Sanity\");\n@@ -976,9 +977,0 @@\n-  return PSParallelCompact::invoke_no_policy(clear_all_soft_refs);\n-}\n-\n-\/\/ This method contains no policy. You should probably\n-\/\/ be calling invoke() instead.\n-bool PSParallelCompact::invoke_no_policy(bool clear_all_soft_refs) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must be at a safepoint\");\n-  assert(ref_processor() != nullptr, \"Sanity\");\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -765,1 +765,0 @@\n-  static bool invoke_no_policy(bool clear_all_soft_refs);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -116,0 +116,7 @@\n+  inline HeapWord* allocate_in_young_gen(Klass* klass,\n+                                         size_t obj_size,\n+                                         uint age);\n+  inline HeapWord* allocate_in_old_gen(Klass* klass,\n+                                       size_t obj_size,\n+                                       uint age);\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -156,0 +156,74 @@\n+inline HeapWord* PSPromotionManager::allocate_in_young_gen(Klass* klass,\n+                                                           size_t obj_size,\n+                                                           uint age) {\n+  HeapWord* result = _young_lab.allocate(obj_size);\n+  if (result != nullptr) {\n+    return result;\n+  }\n+  if (_young_gen_is_full) {\n+    return nullptr;\n+  }\n+  \/\/ Do we allocate directly, or flush and refill?\n+  if (obj_size > (YoungPLABSize \/ 2)) {\n+    \/\/ Allocate this object directly\n+    result = young_space()->cas_allocate(obj_size);\n+    promotion_trace_event(cast_to_oop(result), klass, obj_size, age, false, nullptr);\n+  } else {\n+    \/\/ Flush and fill\n+    _young_lab.flush();\n+\n+    HeapWord* lab_base = young_space()->cas_allocate(YoungPLABSize);\n+    if (lab_base != nullptr) {\n+      _young_lab.initialize(MemRegion(lab_base, YoungPLABSize));\n+      \/\/ Try the young lab allocation again.\n+      result = _young_lab.allocate(obj_size);\n+      promotion_trace_event(cast_to_oop(result), klass, obj_size, age, false, &_young_lab);\n+    } else {\n+      _young_gen_is_full = true;\n+    }\n+  }\n+  if (result == nullptr && !_young_gen_is_full && !_young_gen_has_alloc_failure) {\n+    _young_gen_has_alloc_failure = true;\n+  }\n+  return result;\n+}\n+\n+inline HeapWord* PSPromotionManager::allocate_in_old_gen(Klass* klass,\n+                                                         size_t obj_size,\n+                                                         uint age) {\n+#ifndef PRODUCT\n+  if (ParallelScavengeHeap::heap()->promotion_should_fail()) {\n+    return nullptr;\n+  }\n+#endif  \/\/ #ifndef PRODUCT\n+\n+  HeapWord* result = _old_lab.allocate(obj_size);\n+  if (result != nullptr) {\n+    return result;\n+  }\n+  if (_old_gen_is_full) {\n+    return nullptr;\n+  }\n+  \/\/ Do we allocate directly, or flush and refill?\n+  if (obj_size > (OldPLABSize \/ 2)) {\n+    \/\/ Allocate this object directly\n+    result = old_gen()->allocate(obj_size);\n+    promotion_trace_event(cast_to_oop(result), klass, obj_size, age, true, nullptr);\n+  } else {\n+    \/\/ Flush and fill\n+    _old_lab.flush();\n+\n+    HeapWord* lab_base = old_gen()->allocate(OldPLABSize);\n+    if (lab_base != nullptr) {\n+      _old_lab.initialize(MemRegion(lab_base, OldPLABSize));\n+      \/\/ Try the old lab allocation again.\n+      result = _old_lab.allocate(obj_size);\n+      promotion_trace_event(cast_to_oop(result), klass, obj_size, age, true, &_old_lab);\n+    }\n+  }\n+  if (result == nullptr) {\n+    _old_gen_is_full = true;\n+  }\n+  return result;\n+}\n+\n@@ -189,25 +263,1 @@\n-      new_obj = cast_to_oop(_young_lab.allocate(new_obj_size));\n-      if (new_obj == nullptr && !_young_gen_is_full) {\n-        \/\/ Do we allocate directly, or flush and refill?\n-        if (new_obj_size > (YoungPLABSize \/ 2)) {\n-          \/\/ Allocate this object directly\n-          new_obj = cast_to_oop(young_space()->cas_allocate(new_obj_size));\n-          promotion_trace_event(new_obj, klass, new_obj_size, age, false, nullptr);\n-        } else {\n-          \/\/ Flush and fill\n-          _young_lab.flush();\n-\n-          HeapWord* lab_base = young_space()->cas_allocate(YoungPLABSize);\n-          if (lab_base != nullptr) {\n-            _young_lab.initialize(MemRegion(lab_base, YoungPLABSize));\n-            \/\/ Try the young lab allocation again.\n-            new_obj = cast_to_oop(_young_lab.allocate(new_obj_size));\n-            promotion_trace_event(new_obj, klass, new_obj_size, age, false, &_young_lab);\n-          } else {\n-            _young_gen_is_full = true;\n-          }\n-        }\n-        if (new_obj == nullptr && !_young_gen_is_full && !_young_gen_has_alloc_failure) {\n-          _young_gen_has_alloc_failure = true;\n-        }\n-      }\n+      new_obj = cast_to_oop(allocate_in_young_gen(klass, new_obj_size, age));\n@@ -219,2 +269,2 @@\n-#ifndef PRODUCT\n-    if (ParallelScavengeHeap::heap()->promotion_should_fail()) {\n+    new_obj = cast_to_oop(allocate_in_old_gen(klass, new_obj_size, age));\n+    if (new_obj == nullptr) {\n@@ -223,3 +273,0 @@\n-#endif  \/\/ #ifndef PRODUCT\n-\n-    new_obj = cast_to_oop(_old_lab.allocate(new_obj_size));\n@@ -227,33 +274,0 @@\n-\n-    if (new_obj == nullptr) {\n-      if (!_old_gen_is_full) {\n-        \/\/ Do we allocate directly, or flush and refill?\n-        if (new_obj_size > (OldPLABSize \/ 2)) {\n-          \/\/ Allocate this object directly\n-          new_obj = cast_to_oop(old_gen()->allocate(new_obj_size));\n-          promotion_trace_event(new_obj, klass, new_obj_size, age, true, nullptr);\n-        } else {\n-          \/\/ Flush and fill\n-          _old_lab.flush();\n-\n-          HeapWord* lab_base = old_gen()->allocate(OldPLABSize);\n-          if(lab_base != nullptr) {\n-            _old_lab.initialize(MemRegion(lab_base, OldPLABSize));\n-            \/\/ Try the old lab allocation again.\n-            new_obj = cast_to_oop(_old_lab.allocate(new_obj_size));\n-            promotion_trace_event(new_obj, klass, new_obj_size, age, true, &_old_lab);\n-          }\n-        }\n-      }\n-\n-      \/\/ This is the promotion failed test, and code handling.\n-      \/\/ The code belongs here for two reasons. It is slightly\n-      \/\/ different than the code below, and cannot share the\n-      \/\/ CAS testing code. Keeping the code here also minimizes\n-      \/\/ the impact on the common case fast path code.\n-\n-      if (new_obj == nullptr) {\n-        _old_gen_is_full = true;\n-        return oop_promotion_failed(o, test_mark);\n-      }\n-    }\n@@ -290,1 +304,1 @@\n-    \/\/ So, the is->objArray() test would be very infrequent.\n+    \/\/ So, the objArray test would be very infrequent.\n@@ -292,1 +306,1 @@\n-        new_obj->is_objArray() &&\n+        klass->is_objArray_klass() &&\n@@ -299,2 +313,1 @@\n-      if (StringDedup::is_enabled() &&\n-          java_lang_String::is_instance(new_obj) &&\n+      if (StringDedup::is_enabled_string(klass) &&\n@@ -308,1 +321,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":80,"deletions":68,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -270,1 +270,0 @@\n-  _pretenure_size_threshold_words = PretenureSizeThreshold >> LogHeapWordSize;\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -58,2 +58,0 @@\n-  \/\/ Size of object to pretenure in words; command line provides bytes\n-  size_t      _pretenure_size_threshold_words;\n@@ -188,18 +186,0 @@\n-  \/\/ Allocation support\n-  bool should_allocate(size_t word_size, bool is_tlab) {\n-    assert(UseTLAB || !is_tlab, \"Should not allocate tlab\");\n-    assert(word_size != 0, \"precondition\");\n-\n-    size_t overflow_limit    = (size_t)1 << (BitsPerSize_t - LogHeapWordSize);\n-\n-    const bool overflows     = word_size >= overflow_limit;\n-    const bool check_too_big = _pretenure_size_threshold_words > 0;\n-    const bool not_too_big   = word_size < _pretenure_size_threshold_words;\n-    const bool size_ok       = is_tlab || !check_too_big || not_too_big;\n-\n-    bool result = !overflows &&\n-                  size_ok;\n-\n-    return result;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -286,4 +286,2 @@\n-  HeapWord* result = nullptr;\n-  if (_old_gen->should_allocate(size, is_tlab)) {\n-    result = _old_gen->expand_and_allocate(size);\n-  }\n+  HeapWord* result = _young_gen->allocate(size);\n+\n@@ -291,4 +289,1 @@\n-    if (_young_gen->should_allocate(size, is_tlab)) {\n-      \/\/ Young-gen is not expanded.\n-      result = _young_gen->allocate(size);\n-    }\n+    result = _old_gen->expand_and_allocate(size);\n@@ -296,0 +291,1 @@\n+\n@@ -304,5 +300,3 @@\n-    if (_young_gen->should_allocate(size, is_tlab)) {\n-      result = _young_gen->par_allocate(size);\n-      if (result != nullptr) {\n-        break;\n-      }\n+    result = _young_gen->par_allocate(size);\n+    if (result != nullptr) {\n+      break;\n@@ -345,19 +339,0 @@\n-HeapWord* SerialHeap::attempt_allocation(size_t size,\n-                                         bool is_tlab,\n-                                         bool first_only) {\n-  HeapWord* res = nullptr;\n-\n-  if (_young_gen->should_allocate(size, is_tlab)) {\n-    res = _young_gen->allocate(size);\n-    if (res != nullptr || first_only) {\n-      return res;\n-    }\n-  }\n-\n-  if (_old_gen->should_allocate(size, is_tlab)) {\n-    res = _old_gen->allocate(size);\n-  }\n-\n-  return res;\n-}\n-\n@@ -462,1 +437,1 @@\n-  bool should_run_young_gc = _young_gen->should_allocate(size, is_tlab);\n+  bool should_run_young_gc = is_tlab || size <= _young_gen->eden()->capacity();\n@@ -465,6 +440,1 @@\n-  result = attempt_allocation(size, is_tlab, false \/*first_only*\/);\n-  if (result != nullptr) {\n-    return result;\n-  }\n-\n-  \/\/ OK, collection failed, try expansion.\n+  \/\/ Just finished a GC, try to satisfy this allocation, using expansion if needed.\n@@ -487,4 +457,0 @@\n-  result = attempt_allocation(size, is_tlab, false \/* first_only *\/);\n-  if (result != nullptr) {\n-    return result;\n-  }\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":9,"deletions":43,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -105,5 +105,0 @@\n-  \/\/ Helper functions for allocation\n-  HeapWord* attempt_allocation(size_t size,\n-                               bool   is_tlab,\n-                               bool   first_only);\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -138,9 +138,0 @@\n-  bool should_allocate(size_t word_size, bool is_tlab) {\n-    bool result = false;\n-    size_t overflow_limit = (size_t)1 << (BitsPerSize_t - LogHeapWordSize);\n-    if (!is_tlab) {\n-      result = (word_size > 0) && (word_size < overflow_limit);\n-    }\n-    return result;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,10 +34,1 @@\n-\/\/ The throughput goal is implemented as\n-\/\/      _throughput_goal = 1 - ( 1 \/ (1 + gc_cost_ratio))\n-\/\/ gc_cost_ratio is the ratio\n-\/\/      application cost \/ gc cost\n-\/\/ For example a gc_cost_ratio of 4 translates into a\n-\/\/ throughput goal of .80\n-\n-AdaptiveSizePolicy::AdaptiveSizePolicy(double gc_pause_goal_sec,\n-                                       uint gc_cost_ratio) :\n-  _throughput_goal(1.0 - double(1.0 \/ (1.0 + (double) gc_cost_ratio))),\n+AdaptiveSizePolicy::AdaptiveSizePolicy(double gc_pause_goal_sec) :\n","filename":"src\/hotspot\/share\/gc\/shared\/adaptiveSizePolicy.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -50,4 +50,0 @@\n-  \/\/ Goal for the fraction of the total time during which application\n-  \/\/ threads run\n-  const double _throughput_goal;\n-\n@@ -173,2 +169,1 @@\n-  AdaptiveSizePolicy(double gc_pause_goal_sec,\n-                     uint gc_cost_ratio);\n+  AdaptiveSizePolicy(double gc_pause_goal_sec);\n","filename":"src\/hotspot\/share\/gc\/shared\/adaptiveSizePolicy.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -65,3 +65,2 @@\n-  julong memory = os::physical_memory();\n-  log_info_p(gc, init)(\"Memory: \" JULONG_FORMAT \"%s\",\n-                       byte_size_in_proper_unit(memory), proper_unit_for_byte_size(memory));\n+  size_t memory = os::physical_memory();\n+  log_info_p(gc, init)(\"Memory: \" PROPERFMT, PROPERFMTARGS(memory));\n","filename":"src\/hotspot\/share\/gc\/shared\/gcInitLogger.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -487,5 +487,0 @@\n-  product(size_t, PretenureSizeThreshold, 0,                                \\\n-          \"Maximum size in bytes of objects allocated in DefNew \"           \\\n-          \"generation; zero means no maximum\")                              \\\n-          range(0, max_uintx)                                               \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -823,1 +823,1 @@\n-  os::snprintf(name, sizeof(name), \"%s %s lock\", storage_name, kind);\n+  os::snprintf_checked(name, sizeof(name), \"%s %s lock\", storage_name, kind);\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -309,1 +309,1 @@\n-    os::snprintf(buffer, SATB_PRINTER_BUFFER_SIZE, \"Enqueued: %d\", i);\n+    os::snprintf_checked(buffer, SATB_PRINTER_BUFFER_SIZE, \"Enqueued: %d\", i);\n@@ -324,1 +324,1 @@\n-      os::snprintf(_buffer, SATB_PRINTER_BUFFER_SIZE, \"Thread: %s\", t->name());\n+      (void) os::snprintf(_buffer, SATB_PRINTER_BUFFER_SIZE, \"Thread: %s\", t->name());\n","filename":"src\/hotspot\/share\/gc\/shared\/satbMarkQueue.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -197,0 +197,7 @@\n+  \/\/ Gen shen does not support any ShenandoahGCHeuristics value except for the default \"adaptive\"\n+  if ((strcmp(ShenandoahGCMode, \"generational\") == 0)\n+      && strcmp(ShenandoahGCHeuristics, \"adaptive\") != 0) {\n+    log_warning(gc)(\"Ignoring -XX:ShenandoahGCHeuristics input: %s, because generational shenandoah only\"\n+      \" supports adaptive heuristics\", ShenandoahGCHeuristics);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -144,1 +144,2 @@\n-          \"Possible values are:\"                                            \\\n+          \"When -XX:ShenandoahGCMode is generational, the only supported \"  \\\n+          \"option is the default, adaptive. Possible values are:\"           \\\n@@ -147,1 +148,2 @@\n-          \" static -  trigger GC when free heap falls below the threshold;\" \\\n+          \" static - trigger GC when free heap falls below a specified \"    \\\n+          \"threshold;\"                                                      \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -94,0 +94,4 @@\n+\n+  template <typename Function, typename... Args>\n+  bool next_if(T* elem, Function predicate, Args&&... args);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zArray.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -164,0 +164,14 @@\n+template <typename T, bool Parallel>\n+template <typename Function, typename... Args>\n+inline bool ZArrayIteratorImpl<T, Parallel>::next_if(T* elem, Function predicate, Args&&... args) {\n+  size_t index;\n+  while (next_index(&index)) {\n+    if (predicate(index_to_elem(index), args...)) {\n+      *elem = index_to_elem(index);\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zArray.inline.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,1 @@\n+  const uint32_t         _partition_id;\n@@ -111,0 +112,2 @@\n+  uint32_t partition_id() const;\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zForwarding.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,1 @@\n+    _partition_id(page->single_partition_id()),\n@@ -105,0 +106,4 @@\n+inline uint32_t ZForwarding::partition_id() const {\n+  return _partition_id;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zForwarding.inline.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -253,2 +253,2 @@\n-ZPage* ZHeap::alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age) {\n-  ZPage* const page = _page_allocator.alloc_page(type, size, flags, age);\n+ZPage* ZHeap::alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age, uint32_t preferred_partition) {\n+  ZPage* const page = _page_allocator.alloc_page(type, size, flags, age, preferred_partition);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  ZPage* alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age);\n+  ZPage* alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age, uint32_t preferred_partition);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/z\/zNUMA.inline.hpp\"\n@@ -61,3 +62,5 @@\n-  \/\/ Calculate headroom needed to avoid in-place relocation. Each worker will try\n-  \/\/ to allocate a small page, and all workers will share a single medium page.\n-  return (ConcGCThreads * ZPageSizeSmall) + ZPageSizeMediumMax;\n+  \/\/ Calculate headroom needed to avoid in-place relocation. For each NUMA node,\n+  \/\/ each worker will try to allocate a small page, and all workers will share a\n+  \/\/ single medium page.\n+  const size_t per_numa_headroom = (ConcGCThreads * ZPageSizeSmall) + ZPageSizeMediumMax;\n+  return per_numa_headroom * ZNUMA::count();\n","filename":"src\/hotspot\/share\/gc\/z\/zHeuristics.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-  log_info_p(gc, init)(\"Memory: \" JULONG_FORMAT \"M\", os::physical_memory() \/ M);\n+  const size_t memory = os::physical_memory();\n+  log_info_p(gc, init)(\"Memory: \" PROPERFMT, PROPERFMTARGS(memory));\n","filename":"src\/hotspot\/share\/gc\/z\/zLargePages.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  return ZHeap::heap()->alloc_page(type, size, flags, _age);\n+  return ZHeap::heap()->alloc_page(type, size, flags, _age, ZNUMA::id());\n","filename":"src\/hotspot\/share\/gc\/z\/zObjectAllocator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -160,0 +160,1 @@\n+  assert(!is_multi_partition(), \"Don't fetch single partition id if page is multi-partition\");\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -415,1 +415,1 @@\n-  const uint32_t             _initiating_numa_id;\n+  const uint32_t             _preferred_partition;\n@@ -423,1 +423,1 @@\n-  ZPageAllocation(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age)\n+  ZPageAllocation(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age, uint32_t preferred_partition)\n@@ -431,1 +431,1 @@\n-      _initiating_numa_id(ZNUMA::id()),\n+      _preferred_partition(preferred_partition),\n@@ -436,1 +436,3 @@\n-      _stall_result() {}\n+      _stall_result() {\n+    assert(_preferred_partition < ZNUMA::count(), \"Preferred partition out-of-bounds (0 <= %d < %d)\", _preferred_partition, ZNUMA::count());\n+  }\n@@ -477,2 +479,2 @@\n-  uint32_t initiating_numa_id() const {\n-    return _initiating_numa_id;\n+  uint32_t preferred_partition() const {\n+    return _preferred_partition;\n@@ -1093,1 +1095,2 @@\n-  assert(allocation->harvested() + allocation->committed_capacity() == freed, \"must have freed all\");\n+  assert(allocation->harvested() + allocation->committed_capacity() == freed, \"must have freed all\"\n+         \" %zu + %zu == %zu\", allocation->harvested(), allocation->committed_capacity(), freed);\n@@ -1400,1 +1403,1 @@\n-ZPage* ZPageAllocator::alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age) {\n+ZPage* ZPageAllocator::alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age, uint32_t preferred_partition) {\n@@ -1403,1 +1406,1 @@\n-  ZPageAllocation allocation(type, size, flags, age);\n+  ZPageAllocation allocation(type, size, flags, age, preferred_partition);\n@@ -1551,1 +1554,1 @@\n-  const uint32_t start_numa_id = allocation->initiating_numa_id();\n+  const uint32_t start_numa_id = allocation->preferred_partition();\n@@ -1563,1 +1566,1 @@\n-  if (!is_multi_partition_enabled() || sum_available() < allocation->size()) {\n+  if (!is_multi_partition_allowed(allocation)) {\n@@ -1581,1 +1584,1 @@\n-  const uint32_t start_node = allocation->initiating_numa_id();\n+  const uint32_t start_node = allocation->preferred_partition();\n@@ -1910,0 +1913,1 @@\n+  assert(allocation->partial_vmems()->is_empty(), \"Invariant for single partition commit failure\");\n@@ -1911,4 +1915,7 @@\n-  const size_t committed = allocation->committed_capacity();\n-  const ZVirtualMemory non_harvested_vmem = vmem.last_part(allocation->harvested());\n-  const ZVirtualMemory committed_vmem = non_harvested_vmem.first_part(committed);\n-  const ZVirtualMemory non_committed_vmem = non_harvested_vmem.last_part(committed);\n+  \/\/ For a single partition we have unmapped the harvested memory before we\n+  \/\/ started committing, and moved its physical memory association to the start\n+  \/\/ of the vmem. As such, the partial_vmems is empty. All the harvested and\n+  \/\/ partially successfully committed memory is mapped in the first part of vmem.\n+  const size_t harvested_and_committed_capacity = allocation->harvested() + allocation->committed_capacity();\n+  const ZVirtualMemory succeeded_vmem = vmem.first_part(harvested_and_committed_capacity);\n+  const ZVirtualMemory failed_vmem = vmem.last_part(harvested_and_committed_capacity);\n@@ -1916,1 +1923,1 @@\n-  if (committed_vmem.size() > 0) {\n+  if (succeeded_vmem.size() > 0) {\n@@ -1920,1 +1927,1 @@\n-    allocation->partial_vmems()->append(committed_vmem);\n+    allocation->partial_vmems()->append(succeeded_vmem);\n@@ -1925,2 +1932,2 @@\n-  partition.free_physical(non_committed_vmem);\n-  partition.free_virtual(non_committed_vmem);\n+  partition.free_physical(failed_vmem);\n+  partition.free_virtual(failed_vmem);\n@@ -1942,1 +1949,1 @@\n-    const ZVirtualMemory non_harvested_vmem = vmem.last_part(allocation->harvested());\n+    const ZVirtualMemory non_harvested_vmem = partial_vmem.last_part(allocation->harvested());\n@@ -2194,0 +2201,6 @@\n+bool ZPageAllocator::is_multi_partition_allowed(const ZPageAllocation* allocation) const {\n+  return is_multi_partition_enabled() &&\n+         allocation->type() == ZPageType::large &&\n+         allocation->size() <= sum_available();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":34,"deletions":21,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -223,0 +223,1 @@\n+  bool is_multi_partition_allowed(const ZPageAllocation* allocation) const;\n@@ -266,1 +267,1 @@\n-  ZPage* alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age);\n+  ZPage* alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age, uint32_t preferred_partition);\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -217,0 +217,9 @@\n+static size_t inject_commit_limit(const ZVirtualMemory& vmem) {\n+  \/\/ To facilitate easier interoperability with multi partition allocations we\n+  \/\/ divide by ZNUMA::count(). Users of ZFailLargerCommits need to be aware of\n+  \/\/ this when writing tests. In the future we could probe the VirtualMemoryManager\n+  \/\/ and condition this division on whether the vmem is in the multi partition\n+  \/\/ address space.\n+  return align_up(MIN2(ZFailLargerCommits \/ ZNUMA::count(), vmem.size()), ZGranuleSize);\n+}\n+\n@@ -219,1 +228,3 @@\n-  const size_t size = vmem.size();\n+  const size_t size = ZFailLargerCommits > 0\n+      ? inject_commit_limit(vmem)\n+      : vmem.size();\n","filename":"src\/hotspot\/share\/gc\/z\/zPhysicalMemoryManager.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/z\/zNUMA.inline.hpp\"\n@@ -46,0 +47,1 @@\n+#include \"gc\/z\/zValue.inline.hpp\"\n@@ -307,0 +309,25 @@\n+ZRelocationTargets::ZRelocationTargets()\n+  : _targets() {}\n+\n+ZPage* ZRelocationTargets::get(uint32_t partition_id, ZPageAge age) {\n+  return _targets.get(partition_id)[untype(age) - 1];\n+}\n+\n+void ZRelocationTargets::set(uint32_t partition_id, ZPageAge age, ZPage* page) {\n+  _targets.get(partition_id)[untype(age) - 1] = page;\n+}\n+\n+template <typename Function>\n+void ZRelocationTargets::apply_and_clear_targets(Function function) {\n+  ZPerNUMAIterator<TargetArray> iter(&_targets);\n+  for (TargetArray* targets; iter.next(&targets);) {\n+    for (size_t i = 0; i < ZNumRelocationAges; i++) {\n+      \/\/ Apply function\n+      function((*targets)[i]);\n+\n+      \/\/ Clear target\n+      (*targets)[i] = nullptr;\n+    }\n+  }\n+}\n+\n@@ -309,1 +336,5 @@\n-    _queue() {}\n+    _queue(),\n+    _iters(),\n+    _small_targets(),\n+    _medium_targets(),\n+    _shared_medium_targets() {}\n@@ -397,0 +428,1 @@\n+  const uint32_t preferred_partition = forwarding->partition_id();\n@@ -402,1 +434,1 @@\n-  return ZHeap::heap()->alloc_page(type, size, flags, age);\n+  return ZHeap::heap()->alloc_page(type, size, flags, age, preferred_partition);\n@@ -445,1 +477,1 @@\n-  void share_target_page(ZPage* page) {\n+  void share_target_page(ZPage* page, uint32_t partition_id) {\n@@ -470,5 +502,5 @@\n-  ZGeneration* const _generation;\n-  ZConditionLock     _lock;\n-  ZPage*             _shared[ZNumRelocationAges];\n-  bool               _in_place;\n-  volatile size_t    _in_place_count;\n+  ZGeneration* const  _generation;\n+  ZConditionLock      _lock;\n+  ZRelocationTargets* _shared_targets;\n+  bool                _in_place;\n+  volatile size_t     _in_place_count;\n@@ -477,1 +509,1 @@\n-  ZRelocateMediumAllocator(ZGeneration* generation)\n+  ZRelocateMediumAllocator(ZGeneration* generation, ZRelocationTargets* shared_targets)\n@@ -480,1 +512,1 @@\n-      _shared(),\n+      _shared_targets(shared_targets),\n@@ -485,3 +517,3 @@\n-    for (uint i = 0; i < ZNumRelocationAges; ++i) {\n-      if (_shared[i] != nullptr) {\n-        retire_target_page(_generation, _shared[i]);\n+    _shared_targets->apply_and_clear_targets([&](ZPage* page) {\n+      if (page != nullptr) {\n+        retire_target_page(_generation, page);\n@@ -489,9 +521,1 @@\n-    }\n-  }\n-\n-  ZPage* shared(ZPageAge age) {\n-    return _shared[untype(age - 1)];\n-  }\n-\n-  void set_shared(ZPageAge age, ZPage* page) {\n-    _shared[untype(age - 1)] = page;\n+    });\n@@ -513,1 +537,2 @@\n-    if (shared(to_age) == target) {\n+    const uint32_t partition_id = forwarding->partition_id();\n+    if (_shared_targets->get(partition_id, to_age) == target) {\n@@ -515,1 +540,1 @@\n-      set_shared(to_age, to_page);\n+      _shared_targets->set(partition_id, to_age, to_page);\n@@ -527,1 +552,1 @@\n-    return shared(to_age);\n+    return _shared_targets->get(partition_id, to_age);\n@@ -530,1 +555,1 @@\n-  void share_target_page(ZPage* page) {\n+  void share_target_page(ZPage* page, uint32_t partition_id) {\n@@ -535,1 +560,1 @@\n-    assert(shared(age) == nullptr, \"Invalid state\");\n+    assert(_shared_targets->get(partition_id, age) == nullptr, \"Invalid state\");\n@@ -538,1 +563,1 @@\n-    set_shared(age, page);\n+    _shared_targets->set(partition_id, age, page);\n@@ -566,1 +591,1 @@\n-  ZPage*              _target[ZNumRelocationAges];\n+  ZRelocationTargets* _targets;\n@@ -572,9 +597,0 @@\n-\n-  ZPage* target(ZPageAge age) {\n-    return _target[untype(age - 1)];\n-  }\n-\n-  void set_target(ZPageAge age, ZPage* page) {\n-    _target[untype(age - 1)] = page;\n-  }\n-\n@@ -594,1 +610,1 @@\n-  zaddress try_relocate_object_inner(zaddress from_addr) {\n+  zaddress try_relocate_object_inner(zaddress from_addr, uint32_t partition_id) {\n@@ -598,1 +614,1 @@\n-    ZPage* const to_page = target(_forwarding->to_age());\n+    ZPage* const to_page = _targets->get(partition_id, _forwarding->to_age());\n@@ -809,2 +825,2 @@\n-  bool try_relocate_object(zaddress from_addr) {\n-    const zaddress to_addr = try_relocate_object_inner(from_addr);\n+  bool try_relocate_object(zaddress from_addr, uint32_t partition_id) {\n+    const zaddress to_addr = try_relocate_object_inner(from_addr, partition_id);\n@@ -891,7 +907,12 @@\n-    while (!try_relocate_object(addr)) {\n-      \/\/ Allocate a new target page, or if that fails, use the page being\n-      \/\/ relocated as the new target, which will cause it to be relocated\n-      \/\/ in-place.\n-      const ZPageAge to_age = _forwarding->to_age();\n-      ZPage* to_page = _allocator->alloc_and_retire_target_page(_forwarding, target(to_age));\n-      set_target(to_age, to_page);\n+    const ZPageAge to_age = _forwarding->to_age();\n+    const uint32_t partition_id = _forwarding->partition_id();\n+\n+    while (!try_relocate_object(addr, partition_id)) {\n+      \/\/ Failed to relocate object, try to allocate a new target page,\n+      \/\/ or if that fails, use the page being relocated as the new target,\n+      \/\/ which will cause it to be relocated in-place.\n+      ZPage* const target_page = _targets->get(partition_id, to_age);\n+      ZPage* to_page = _allocator->alloc_and_retire_target_page(_forwarding, target_page);\n+      _targets->set(partition_id, to_age, to_page);\n+\n+      \/\/ We got a new page, retry relocation\n@@ -906,1 +927,1 @@\n-      set_target(to_age, to_page);\n+      _targets->set(partition_id, to_age, to_page);\n@@ -911,1 +932,1 @@\n-  ZRelocateWork(Allocator* allocator, ZGeneration* generation)\n+  ZRelocateWork(Allocator* allocator, ZRelocationTargets* targets, ZGeneration* generation)\n@@ -914,1 +935,1 @@\n-      _target(),\n+      _targets(targets),\n@@ -920,3 +941,4 @@\n-    for (uint i = 0; i < ZNumRelocationAges; ++i) {\n-      _allocator->free_target_page(_target[i]);\n-    }\n+    _targets->apply_and_clear_targets([&](ZPage* page) {\n+        _allocator->free_target_page(page);\n+    });\n+\n@@ -1015,2 +1037,3 @@\n-      ZPage* const target_page = target(_forwarding->to_age());\n-      _allocator->share_target_page(target_page);\n+      const uint32_t target_partition = _forwarding->partition_id();\n+      ZPage* const target_page = _targets->get(target_partition, _forwarding->to_age());\n+      _allocator->share_target_page(target_page, target_partition);\n@@ -1060,5 +1083,9 @@\n-  ZRelocationSetParallelIterator _iter;\n-  ZGeneration* const             _generation;\n-  ZRelocateQueue* const          _queue;\n-  ZRelocateSmallAllocator        _small_allocator;\n-  ZRelocateMediumAllocator       _medium_allocator;\n+  ZGeneration* const                        _generation;\n+  ZRelocateQueue* const                     _queue;\n+  ZPerNUMA<ZRelocationSetParallelIterator>* _iters;\n+  ZPerWorker<ZRelocationTargets>*           _small_targets;\n+  ZPerWorker<ZRelocationTargets>*           _medium_targets;\n+  ZRelocateSmallAllocator                   _small_allocator;\n+  ZRelocateMediumAllocator                  _medium_allocator;\n+  const size_t                              _total_forwardings;\n+  volatile size_t                           _numa_local_forwardings;\n@@ -1067,1 +1094,6 @@\n-  ZRelocateTask(ZRelocationSet* relocation_set, ZRelocateQueue* queue)\n+  ZRelocateTask(ZRelocationSet* relocation_set,\n+                ZRelocateQueue* queue,\n+                ZPerNUMA<ZRelocationSetParallelIterator>* iters,\n+                ZPerWorker<ZRelocationTargets>* small_targets,\n+                ZPerWorker<ZRelocationTargets>* medium_targets,\n+                ZRelocationTargets* shared_medium_targets)\n@@ -1069,1 +1101,0 @@\n-      _iter(relocation_set),\n@@ -1072,0 +1103,3 @@\n+      _iters(iters),\n+      _small_targets(small_targets),\n+      _medium_targets(medium_targets),\n@@ -1073,1 +1107,15 @@\n-      _medium_allocator(_generation) {}\n+      _medium_allocator(_generation, shared_medium_targets),\n+      _total_forwardings(relocation_set->nforwardings()),\n+      _numa_local_forwardings(0) {\n+\n+    for (uint32_t i = 0; i < ZNUMA::count(); i++) {\n+      ZRelocationSetParallelIterator* const iter = _iters->addr(i);\n+\n+      \/\/ Destruct the iterator from the previous GC-cycle, which is a temporary\n+      \/\/ iterator if this is the first GC-cycle.\n+      iter->~ZRelocationSetParallelIterator();\n+\n+      \/\/ In-place construct the iterator with the current relocation set\n+      ::new (iter) ZRelocationSetParallelIterator(relocation_set);\n+    }\n+  }\n@@ -1080,0 +1128,5 @@\n+\n+    if (ZNUMA::is_enabled()) {\n+      log_debug(gc, reloc, numa)(\"Forwardings relocated NUMA-locally: %zu \/ %zu (%.0f%%)\",\n+                                 _numa_local_forwardings, _total_forwardings, percent_of(_numa_local_forwardings, _total_forwardings));\n+    }\n@@ -1083,2 +1136,4 @@\n-    ZRelocateWork<ZRelocateSmallAllocator> small(&_small_allocator, _generation);\n-    ZRelocateWork<ZRelocateMediumAllocator> medium(&_medium_allocator, _generation);\n+    ZRelocateWork<ZRelocateSmallAllocator> small(&_small_allocator, _small_targets->addr(), _generation);\n+    ZRelocateWork<ZRelocateMediumAllocator> medium(&_medium_allocator, _medium_targets->addr(), _generation);\n+    const uint32_t num_nodes = ZNUMA::count();\n+    uint32_t numa_local_forwardings_worker = 0;\n@@ -1110,0 +1165,4 @@\n+    const auto check_numa_local = [&](ZForwarding* forwarding, uint32_t numa_id) {\n+      return forwarding->partition_id() == numa_id;\n+    };\n+\n@@ -1112,0 +1171,6 @@\n+      const uint32_t start_node = ZNUMA::id();\n+      uint32_t current_node = start_node;\n+\n+      for (uint32_t i = 0; i < num_nodes; i++) {\n+        if (_iters->get(current_node).next_if(&forwarding, check_numa_local, current_node)) {\n+          claim_and_do_forwarding(forwarding);\n@@ -1113,3 +1178,10 @@\n-      if (_iter.next(&forwarding)) {\n-        claim_and_do_forwarding(forwarding);\n-        return true;\n+          if (current_node == start_node) {\n+            \/\/ Track if this forwarding was relocated on the local NUMA node\n+            numa_local_forwardings_worker++;\n+          }\n+\n+          return true;\n+        }\n+\n+        \/\/ Check next node.\n+        current_node = (current_node + 1) % num_nodes;\n@@ -1141,0 +1213,4 @@\n+    if (ZNUMA::is_enabled()) {\n+      Atomic::add(&_numa_local_forwardings, numa_local_forwardings_worker, memory_order_relaxed);\n+    }\n+\n@@ -1221,1 +1297,1 @@\n-    ZRelocateTask relocate_task(relocation_set, &_queue);\n+    ZRelocateTask relocate_task(relocation_set, &_queue, &_iters, &_small_targets, &_medium_targets, &_shared_medium_targets);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":147,"deletions":71,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"gc\/z\/zValue.hpp\"\n@@ -77,0 +78,16 @@\n+class ZRelocationTargets {\n+private:\n+  using TargetArray = ZPage*[ZNumRelocationAges];\n+\n+  ZPerNUMA<TargetArray> _targets;\n+\n+public:\n+  ZRelocationTargets();\n+\n+  ZPage* get(uint32_t partition_id, ZPageAge age);\n+  void set(uint32_t partition_id, ZPageAge age, ZPage* page);\n+\n+  template <typename Function>\n+  void apply_and_clear_targets(Function function);\n+};\n+\n@@ -81,2 +98,6 @@\n-  ZGeneration* const _generation;\n-  ZRelocateQueue     _queue;\n+  ZGeneration* const                       _generation;\n+  ZRelocateQueue                           _queue;\n+  ZPerNUMA<ZRelocationSetParallelIterator> _iters;\n+  ZPerWorker<ZRelocationTargets>           _small_targets;\n+  ZPerWorker<ZRelocationTargets>           _medium_targets;\n+  ZRelocationTargets                       _shared_medium_targets;\n@@ -85,1 +106,0 @@\n-  void work(ZRelocationSetParallelIterator* iter);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.hpp","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,2 @@\n+  size_t nforwardings() const;\n+\n@@ -67,0 +69,1 @@\n+  ZRelocationSetIteratorImpl();\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSet.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,8 @@\n+inline size_t ZRelocationSet::nforwardings() const {\n+  return _nforwardings;\n+}\n+\n+template <bool Parallel>\n+inline ZRelocationSetIteratorImpl<Parallel>::ZRelocationSetIteratorImpl()\n+  : ZArrayIteratorImpl<ZForwarding*, Parallel>(nullptr, 0) {}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSet.inline.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -121,0 +121,5 @@\n+  develop(size_t, ZFailLargerCommits, 0,                                    \\\n+          \"Commits larger than ZFailLargerCommits will be truncated, \"      \\\n+          \"used to stress page allocation commit failure paths \"            \\\n+          \"(0: Disabled)\")                                                  \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/z\/z_globals.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -217,1 +217,1 @@\n-  InstanceKlass* const super = InstanceKlass::cast(ik->super());\n+  InstanceKlass* const super = ik->java_super();\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrEventClassTransformer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -415,1 +415,1 @@\n-  return os::Linux::physical_memory();\n+  return static_cast<jlong>(os::Linux::physical_memory());\n@@ -417,1 +417,1 @@\n-  return os::physical_memory();\n+  return static_cast<jlong>(os::physical_memory());\n@@ -426,1 +426,4 @@\n-  return os::total_swap_space();\n+  size_t total_swap_space = 0;\n+  \/\/ Return value ignored - defaulting to 0 on failure.\n+  (void)os::total_swap_space(total_swap_space);\n+  return static_cast<jlong>(total_swap_space);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-    ik = (const InstanceKlass*)ik->super();\n+    ik = ik->java_super();\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeUtils.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -531,1 +531,1 @@\n-  u8 totalPhysicalMemory = os::physical_memory();\n+  u8 totalPhysicalMemory = static_cast<u8>(os::physical_memory());\n@@ -534,1 +534,4 @@\n-  event.set_usedSize(totalPhysicalMemory - os::available_memory());\n+  size_t avail_mem = 0;\n+  \/\/ Return value ignored - defaulting to 0 on failure.\n+  (void)os::available_memory(avail_mem);\n+  event.set_usedSize(totalPhysicalMemory - static_cast<u8>(avail_mem));\n@@ -540,2 +543,8 @@\n-  event.set_totalSize(os::total_swap_space());\n-  event.set_freeSize(os::free_swap_space());\n+  size_t total_swap_space = 0;\n+  \/\/ Return value ignored - defaulting to 0 on failure.\n+  (void)os::total_swap_space(total_swap_space);\n+  event.set_totalSize(static_cast<s8>(total_swap_space));\n+  size_t free_swap_space = 0;\n+  \/\/ Return value ignored - defaulting to 0 on failure.\n+  (void)os::free_swap_space(free_swap_space);\n+  event.set_freeSize(static_cast<s8>(free_swap_space));\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2015,1 +2015,1 @@\n-    Klass* k = iklass->local_interfaces()->at(index);\n+    InstanceKlass* k = iklass->local_interfaces()->at(index);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -937,1 +937,1 @@\n-  os::vsnprintf(msg, max_msg_size, format, ap);\n+  (void) os::vsnprintf(msg, max_msg_size, format, ap);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/memory\/allocation.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"memory\/metaspaceUtils.hpp\"\n@@ -41,0 +40,1 @@\n+#include \"memory\/metaspaceUtils.hpp\"\n","filename":"src\/hotspot\/share\/memory\/classLoaderMetaspace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/annotations.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"oops\/annotations.hpp\"\n","filename":"src\/hotspot\/share\/memory\/heapInspection.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"oops\/klass.hpp\"\n+#include \"oops\/instanceClassLoaderKlass.inline.hpp\"\n@@ -38,1 +38,0 @@\n-#include \"oops\/instanceClassLoaderKlass.inline.hpp\"\n@@ -41,0 +40,1 @@\n+#include \"oops\/klass.hpp\"\n","filename":"src\/hotspot\/share\/memory\/iterator.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/memory\/memRegion.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+\n","filename":"src\/hotspot\/share\/memory\/metadataFactory.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"memory\/metaspace\/chunklevel.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"memory\/metaspace\/chunklevel.hpp\"\n","filename":"src\/hotspot\/share\/memory\/metaspace\/blockTree.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n+\n@@ -32,1 +32,0 @@\n-#include \"utilities\/ostream.hpp\"\n@@ -34,0 +33,2 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ostream.hpp\"\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metablock.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"memory\/metaspace\/metaspaceContext.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"memory\/metaspace\/metaspaceContext.hpp\"\n","filename":"src\/hotspot\/share\/memory\/metaspace\/virtualSpaceList.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n","filename":"src\/hotspot\/share\/memory\/resourceArea.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n","filename":"src\/hotspot\/share\/nmt\/arrayWithFreeList.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"runtime\/java.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -32,1 +32,0 @@\n-#include \"utilities\/parseInteger.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"utilities\/parseInteger.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/mallocLimit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -46,1 +47,0 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"nmt\/mallocLimit.hpp\"\n@@ -31,0 +30,2 @@\n+\n+#include \"nmt\/mallocLimit.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"memory\/universe.hpp\"\n@@ -33,0 +32,2 @@\n+#include \"memory\/universe.hpp\"\n+#include \"nmt\/memMapPrinter.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"nmt\/memMapPrinter.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"nmt\/memTag.hpp\"\n+#include \"nmt\/memoryFileTracker.hpp\"\n@@ -31,0 +31,1 @@\n+#include \"nmt\/memTag.hpp\"\n@@ -32,2 +33,0 @@\n-#include \"nmt\/memoryFileTracker.hpp\"\n-#include \"nmt\/regionsTree.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/memReporter.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"nmt\/nmtCommon.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"nmt\/nmtCommon.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/memTracker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"nmt\/memTracker.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"nmt\/memTracker.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"nmt\/vmatree.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"nmt\/vmatree.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+\n","filename":"src\/hotspot\/share\/nmt\/nmtNativeCallStackStorage.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+\n","filename":"src\/hotspot\/share\/nmt\/regionsTree.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-#include \"nmt\/virtualMemoryTracker.hpp\"\n-#include \"nmt\/regionsTree.hpp\"\n@@ -30,0 +28,1 @@\n+#include \"nmt\/virtualMemoryTracker.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"nmt\/vmatree.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"nmt\/vmatree.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"nmt\/memTag.hpp\"\n@@ -35,0 +34,1 @@\n+\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,4 +81,4 @@\n-  os::snprintf(tmp, sizeof(tmp), \"klass range: \" RANGE2FMT \",\"\n-      \" base \" PTR_FORMAT \", shift %d, lowest\/highest valid narrowKlass %u\/%u\",\n-      RANGE2FMTARGS(_klass_range_start, _klass_range_end),\n-      p2i(_base), _shift, _lowest_valid_narrow_klass_id, _highest_valid_narrow_klass_id);\n+  os::snprintf_checked(tmp, sizeof(tmp), \"klass range: \" RANGE2FMT \",\"\n+                       \" base \" PTR_FORMAT \", shift %d, lowest\/highest valid narrowKlass %u\/%u\",\n+                       RANGE2FMTARGS(_klass_range_start, _klass_range_end),\n+                       p2i(_base), _shift, _lowest_valid_narrow_klass_id, _highest_valid_narrow_klass_id);\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -114,0 +114,1 @@\n+  CDS_JAVA_HEAP_ONLY(int archived_references_index() { return _archived_references_index; })\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2153,1 +2153,1 @@\n-  os::vsnprintf(msg_buffer, sizeof(msg_buffer), format, ap);\n+  (void) os::vsnprintf(msg_buffer, sizeof(msg_buffer), format, ap);\n@@ -2156,1 +2156,1 @@\n-  os::snprintf(msg_buffer2, sizeof(msg_buffer2), \"%s in method %s\", msg_buffer, method()->name()->as_C_string());\n+  (void) os::snprintf(msg_buffer2, sizeof(msg_buffer2), \"%s in method %s\", msg_buffer, method()->name()->as_C_string());\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -578,1 +578,1 @@\n-                                          const Klass* super_klass,\n+                                          const InstanceKlass* super_klass,\n@@ -587,1 +587,1 @@\n-                    InstanceKlass::cast(super_klass)->transitive_interfaces();\n+                    super_klass->transitive_interfaces();\n@@ -680,1 +680,1 @@\n-  deallocate_interfaces(loader_data, super(), local_interfaces(), transitive_interfaces());\n+  deallocate_interfaces(loader_data, java_super(), local_interfaces(), transitive_interfaces());\n@@ -945,1 +945,1 @@\n-  Klass* super_klass = super();\n+  InstanceKlass* super_klass = java_super();\n@@ -960,2 +960,1 @@\n-    InstanceKlass* ik_super = InstanceKlass::cast(super_klass);\n-    ik_super->link_class_impl(CHECK_false);\n+    super_klass->link_class_impl(CHECK_false);\n@@ -1808,1 +1807,1 @@\n-    Klass* intf1 = local_interfaces()->at(i);\n+    InstanceKlass* intf1 = local_interfaces()->at(i);\n@@ -1811,1 +1810,1 @@\n-    if (InstanceKlass::cast(intf1)->find_local_field(name, sig, fd)) {\n+    if (intf1->find_local_field(name, sig, fd)) {\n@@ -1816,1 +1815,1 @@\n-    Klass* intf2 = InstanceKlass::cast(intf1)->find_interface_field(name, sig, fd);\n+    Klass* intf2 = intf1->find_interface_field(name, sig, fd);\n@@ -1835,2 +1834,2 @@\n-  { Klass* supr = super();\n-    if (supr != nullptr) return InstanceKlass::cast(supr)->find_field(name, sig, fd);\n+  { InstanceKlass* supr = java_super();\n+    if (supr != nullptr) return supr->find_field(name, sig, fd);\n@@ -1855,2 +1854,2 @@\n-  { Klass* supr = super();\n-    if (supr != nullptr) return InstanceKlass::cast(supr)->find_field(name, sig, is_static, fd);\n+  { InstanceKlass* supr = java_super();\n+    if (supr != nullptr) return supr->find_field(name, sig, is_static, fd);\n@@ -1875,1 +1874,1 @@\n-  Klass* klass = const_cast<InstanceKlass*>(this);\n+  const InstanceKlass* klass = this;\n@@ -1877,1 +1876,1 @@\n-    if (InstanceKlass::cast(klass)->find_local_field_from_offset(offset, is_static, fd)) {\n+    if (klass->find_local_field_from_offset(offset, is_static, fd)) {\n@@ -1880,1 +1879,1 @@\n-    klass = klass->super();\n+    klass = klass->java_super();\n@@ -1923,1 +1922,1 @@\n-  InstanceKlass* super = superklass();\n+  InstanceKlass* super = java_super();\n@@ -1940,1 +1939,1 @@\n-  InstanceKlass* super = superklass();\n+  InstanceKlass* super = java_super();\n@@ -2235,1 +2234,1 @@\n-  const Klass* klass = this;\n+  const InstanceKlass* klass = this;\n@@ -2237,5 +2236,5 @@\n-    Method* const method = InstanceKlass::cast(klass)->find_method_impl(name,\n-                                                                        signature,\n-                                                                        overpass_local_mode,\n-                                                                        StaticLookupMode::find,\n-                                                                        private_mode);\n+    Method* const method = klass->find_method_impl(name,\n+                                                   signature,\n+                                                   overpass_local_mode,\n+                                                   StaticLookupMode::find,\n+                                                   private_mode);\n@@ -2245,1 +2244,1 @@\n-    klass = klass->super();\n+    klass = klass->java_super();\n@@ -2255,1 +2254,1 @@\n-  const Klass* klass = this;\n+  const InstanceKlass* klass = this;\n@@ -2257,1 +2256,1 @@\n-    if (InstanceKlass::cast(klass)->has_been_redefined()) {\n+    if (klass->has_been_redefined()) {\n@@ -2260,1 +2259,1 @@\n-    klass = klass->super();\n+    klass = klass->java_super();\n@@ -3989,1 +3988,1 @@\n-                       p2i(this),  p2i(superklass()));\n+                       p2i(this),  p2i(java_super()));\n@@ -3997,1 +3996,1 @@\n-                           p2i(InstanceKlass::cast(local_interfaces()->at(i))));\n+                           p2i(local_interfaces()->at(i)));\n@@ -4210,1 +4209,0 @@\n-\n@@ -4215,1 +4213,1 @@\n-JNIid::JNIid(Klass* holder, int offset, JNIid* next) {\n+JNIid::JNIid(InstanceKlass* holder, int offset, JNIid* next) {\n@@ -4222,1 +4220,0 @@\n-\n@@ -4240,2 +4237,1 @@\n-\n-void JNIid::verify(Klass* holder) {\n+void JNIid::verify(InstanceKlass* holder) {\n@@ -4244,1 +4240,1 @@\n-  end_field_offset = first_field_offset + (InstanceKlass::cast(holder)->static_field_size() * wordSize);\n+  end_field_offset = first_field_offset + (holder->static_field_size() * wordSize);\n@@ -4557,1 +4553,1 @@\n-    _current = _current->superklass(); \/\/ backtrack; no more sibling subclasses left\n+    _current = _current->java_super(); \/\/ backtrack; no more sibling subclasses left\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":33,"deletions":37,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -991,1 +991,1 @@\n-                                    const Klass* super_klass,\n+                                    const InstanceKlass* super_klass,\n@@ -1208,1 +1208,1 @@\n-  Klass*             _holder;\n+  InstanceKlass*     _holder;\n@@ -1217,1 +1217,1 @@\n-  Klass* holder() const           { return _holder; }\n+  InstanceKlass* holder() const   { return _holder; }\n@@ -1221,1 +1221,1 @@\n-  JNIid(Klass* holder, int offset, JNIid* next);\n+  JNIid(InstanceKlass* holder, int offset, JNIid* next);\n@@ -1235,1 +1235,1 @@\n-  void verify(Klass* holder);\n+  void verify(InstanceKlass* holder);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -614,6 +614,0 @@\n-\/\/ superklass links\n-InstanceKlass* Klass::superklass() const {\n-  assert(super() == nullptr || super()->is_instance_klass(), \"must be instance klass\");\n-  return _super == nullptr ? nullptr : InstanceKlass::cast(_super);\n-}\n-\n@@ -682,2 +676,2 @@\n-  \/\/ add ourselves to superklass' subklass list\n-  InstanceKlass* super = superklass();\n+  \/\/ add ourselves to super' subklass list\n+  InstanceKlass* super = java_super();\n@@ -686,1 +680,1 @@\n-          && (super->superklass() == nullptr || !is_interface())),\n+          && (super->java_super() == nullptr || !is_interface())),\n@@ -695,1 +689,1 @@\n-      \/\/ set our sibling to be the superklass' previous first subklass\n+      \/\/ set our sibling to be the super' previous first subklass\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -300,1 +300,0 @@\n-  InstanceKlass* superklass() const;\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    GrowableArray<Method*>* all_mirandas, const Klass* super,\n+    GrowableArray<Method*>* all_mirandas, const InstanceKlass* super,\n@@ -349,1 +349,1 @@\n-    superk = superk->super() == nullptr ? nullptr : InstanceKlass::cast(superk->super());\n+    superk = superk->java_super();\n@@ -634,1 +634,1 @@\n-                                         const Klass* super,\n+                                         const InstanceKlass* super,\n@@ -686,1 +686,1 @@\n-  const Klass* k = super;\n+  const InstanceKlass* k = super;\n@@ -725,1 +725,1 @@\n-      k = superk->super(); \/\/ haven't found an override match yet; continue to look\n+      k = superk->java_super(); \/\/ haven't found an override match yet; continue to look\n@@ -744,3 +744,2 @@\n-  const InstanceKlass *sk = InstanceKlass::cast(super);\n-  if (sk->has_miranda_methods()) {\n-    if (sk->lookup_method_in_all_interfaces(name, signature, Klass::DefaultsLookupMode::find) != nullptr) {\n+  if (super->has_miranda_methods()) {\n+    if (super->lookup_method_in_all_interfaces(name, signature, Klass::DefaultsLookupMode::find) != nullptr) {\n@@ -778,1 +777,1 @@\n-    if (is_miranda(m, ik()->methods(), ik()->default_methods(), ik()->super(), klass()->is_interface())) {\n+    if (is_miranda(m, ik()->methods(), ik()->default_methods(), ik()->java_super(), klass()->is_interface())) {\n@@ -840,1 +839,1 @@\n-                             Array<Method*>* default_methods, const Klass* super,\n+                             Array<Method*>* default_methods, const InstanceKlass* super,\n@@ -869,6 +868,5 @@\n-  for (const Klass* cursuper = super; cursuper != nullptr; cursuper = cursuper->super())\n-  {\n-     Method* found_mth = InstanceKlass::cast(cursuper)->find_local_method(name, signature,\n-                                                                          Klass::OverpassLookupMode::find,\n-                                                                          Klass::StaticLookupMode::skip,\n-                                                                          Klass::PrivateLookupMode::skip);\n+  for (const InstanceKlass* cursuper = super; cursuper != nullptr; cursuper = cursuper->java_super()) {\n+     Method* found_mth = cursuper->find_local_method(name, signature,\n+                                                     Klass::OverpassLookupMode::find,\n+                                                     Klass::StaticLookupMode::skip,\n+                                                     Klass::PrivateLookupMode::skip);\n@@ -896,1 +894,1 @@\n-    Array<Method*>* default_methods, const Klass* super, bool is_interface) {\n+    Array<Method*>* default_methods, const InstanceKlass* super, bool is_interface) {\n@@ -916,1 +914,0 @@\n-        const InstanceKlass *sk = InstanceKlass::cast(super);\n@@ -918,1 +915,1 @@\n-        if (sk->lookup_method_in_all_interfaces(im->name(), im->signature(), Klass::DefaultsLookupMode::find) == nullptr) {\n+        if (super->lookup_method_in_all_interfaces(im->name(), im->signature(), Klass::DefaultsLookupMode::find) == nullptr) {\n@@ -931,1 +928,1 @@\n-                               const Klass* super,\n+                               const InstanceKlass* super,\n@@ -965,1 +962,1 @@\n-  get_mirandas(&mirandas, nullptr, ik()->super(), ik()->methods(),\n+  get_mirandas(&mirandas, nullptr, ik()->java_super(), ik()->methods(),\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":18,"deletions":21,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-                                                   const Klass* super,\n+                                                   const InstanceKlass* super,\n@@ -119,1 +119,1 @@\n-                                     const Klass* super,\n+                                     const InstanceKlass* super,\n@@ -138,1 +138,1 @@\n-                         Array<Method*>* default_methods, const Klass* super,\n+                         Array<Method*>* default_methods, const InstanceKlass* super,\n@@ -146,1 +146,1 @@\n-      const Klass* super,\n+      const InstanceKlass* super,\n@@ -151,1 +151,1 @@\n-      const Klass* super,\n+      const InstanceKlass* super,\n","filename":"src\/hotspot\/share\/oops\/klassVtable.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -155,0 +155,3 @@\n+  if (is_abstract()) {\n+    return SharedRuntime::throw_AbstractMethodError_entry();\n+  }\n@@ -160,0 +163,3 @@\n+  if (is_abstract()) {\n+    return SharedRuntime::get_handle_wrong_method_abstract_stub();\n+  }\n@@ -1168,1 +1174,1 @@\n-    _from_compiled_entry    = nullptr;\n+    _from_compiled_entry = nullptr;\n@@ -1170,1 +1176,1 @@\n-    _from_compiled_entry    = adapter()->get_c2i_entry();\n+    _from_compiled_entry = adapter()->get_c2i_entry();\n@@ -1199,1 +1205,1 @@\n-  if (!CDSConfig::is_dumping_adapters() || AdapterHandlerLibrary::is_abstract_method_adapter(_adapter)) {\n+  if (!CDSConfig::is_dumping_adapters()) {\n@@ -1280,1 +1286,3 @@\n-  if (_adapter == nullptr) {\n+  if (is_abstract()) {\n+    h_method->_from_compiled_entry = SharedRuntime::get_handle_wrong_method_abstract_stub();\n+  } else if (_adapter == nullptr) {\n@@ -1283,0 +1291,1 @@\n+    h_method->_from_compiled_entry = adapter()->get_c2i_entry();\n@@ -1303,0 +1312,1 @@\n+  assert(!mh->is_abstract(), \"abstract methods do not have adapters\");\n@@ -1321,1 +1331,0 @@\n-  mh->_from_compiled_entry = adapter->get_c2i_entry();\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+  friend class AOTMapLogger;\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,0 +83,27 @@\n+  \/\/ Notes on copy constructor, copy assignment operator, and copy_from().\n+  \/\/ These are necessary for generating deterministic CDS archives.\n+  \/\/\n+  \/\/ We have some unused padding on 64-bit platforms (4 bytes at the tail end).\n+  \/\/\n+  \/\/ When ResolvedFieldEntries in a ConstantPoolCache are allocated from the metaspace,\n+  \/\/ their entire content (including the padding) is filled with zeros. They are\n+  \/\/ then initialized with initialize_resolved_entries_array() in cpCache.cpp from a\n+  \/\/ GrowableArray.\n+  \/\/\n+  \/\/ The GrowableArray is initialized in rewriter.cpp, using ResolvedFieldEntries that\n+  \/\/ are originally allocated from the C++ stack. Functions like GrowableArray::expand_to()\n+  \/\/ will also allocate ResolvedFieldEntries from the stack. These may have random bits\n+  \/\/ in the padding as the C++ compiler is allowed to leave the padding in uninitialized\n+  \/\/ states.\n+  \/\/\n+  \/\/ If we use the default copy constructor and\/or default copy assignment operator,\n+  \/\/ the random padding will be copied into the GrowableArray, from there\n+  \/\/ to the ConstantPoolCache, and eventually to the CDS archive. As a result, the\n+  \/\/ CDS archive will contain random bits, causing failures in\n+  \/\/ test\/hotspot\/jtreg\/runtime\/cds\/DeterministicDump.java (usually on Windows).\n+  \/\/\n+  \/\/ By using copy_from(), we can prevent the random padding from being copied,\n+  \/\/ ensuring that the ResolvedFieldEntries in a ConstantPoolCache (and thus the\n+  \/\/ CDS archive) will have all zeros in the padding.\n+\n+  \/\/ Copy constructor\n@@ -87,0 +114,1 @@\n+  \/\/ Copy assignment operator\n","filename":"src\/hotspot\/share\/oops\/resolvedFieldEntry.hpp","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,3 @@\n+  \/\/ The copy_from() pattern in resolvedFieldEntry.hpp is not necessary\n+  \/\/ as we have no unused padding (on 32- or 64-bit platforms).\n+\n","filename":"src\/hotspot\/share\/oops\/resolvedIndyEntry.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,2 @@\n+  \/\/ See comments in resolvedFieldEntry.hpp about copy_from and padding.\n+  \/\/ We have unused padding on debug builds.\n","filename":"src\/hotspot\/share\/oops\/resolvedMethodEntry.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  if (TrainingData::have_data()) {\n+  if (TrainingData::have_data() && !TrainingData::assembling_data()) {\n@@ -101,3 +101,15 @@\n-        mtd->verify();\n-      } else if (td->is_CompileTrainingData()) {\n-        td->as_CompileTrainingData()->verify();\n+        mtd->verify(\/*verify_dep_counter*\/true);\n+      }\n+    });\n+  }\n+  if (TrainingData::need_data()) {\n+    TrainingDataLocker l;\n+    training_data_set()->iterate([&](TrainingData* td) {\n+      if (td->is_KlassTrainingData()) {\n+        KlassTrainingData* ktd = td->as_KlassTrainingData();\n+        ktd->verify();\n+      } else if (td->is_MethodTrainingData()) {\n+        MethodTrainingData* mtd = td->as_MethodTrainingData();\n+        \/\/ During the training run init deps tracking is not setup yet,\n+        \/\/ don't verify it.\n+        mtd->verify(\/*verify_dep_counter*\/false);\n@@ -232,1 +244,1 @@\n-void CompileTrainingData::dec_init_deps_left(KlassTrainingData* ktd) {\n+void CompileTrainingData::dec_init_deps_left_release(KlassTrainingData* ktd) {\n@@ -453,1 +465,1 @@\n-    comp_dep(i)->dec_init_deps_left(this);\n+    comp_dep(i)->dec_init_deps_left_release(this);\n@@ -479,0 +491,1 @@\n+  }\n@@ -480,3 +493,2 @@\n-    if (AOTVerifyTrainingData) {\n-      training_data_set()->verify();\n-    }\n+  if (AOTVerifyTrainingData) {\n+    TrainingData::verify();\n@@ -595,12 +607,3 @@\n-void MethodTrainingData::verify() {\n-  iterate_compiles([](CompileTrainingData* ctd) {\n-    ctd->verify();\n-\n-    int init_deps_left1 = ctd->init_deps_left();\n-    int init_deps_left2 = ctd->compute_init_deps_left();\n-\n-    if (init_deps_left1 != init_deps_left2) {\n-      ctd->print_on(tty); tty->cr();\n-    }\n-    guarantee(init_deps_left1 == init_deps_left2, \"mismatch: %d %d %d\",\n-              init_deps_left1, init_deps_left2, ctd->init_deps_left());\n+void MethodTrainingData::verify(bool verify_dep_counter) {\n+  iterate_compiles([&](CompileTrainingData* ctd) {\n+    ctd->verify(verify_dep_counter);\n@@ -610,1 +613,1 @@\n-void CompileTrainingData::verify() {\n+void CompileTrainingData::verify(bool verify_dep_counter) {\n@@ -627,0 +630,12 @@\n+\n+  if (verify_dep_counter) {\n+    int init_deps_left1 = init_deps_left_acquire();\n+    int init_deps_left2 = compute_init_deps_left();\n+\n+    bool invariant = (init_deps_left1 >= init_deps_left2);\n+    if (!invariant) {\n+      print_on(tty);\n+      tty->cr();\n+    }\n+    guarantee(invariant, \"init deps invariant violation: %d >= %d\", init_deps_left1, init_deps_left2);\n+  }\n","filename":"src\/hotspot\/share\/oops\/trainingData.cpp","additions":37,"deletions":22,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-  \/\/ It is also a part of the TD collection termination protocol (see the \"spanshot\" field).\n+  \/\/ It is also a part of the TD collection termination protocol (see the \"snapshot\" field).\n@@ -108,1 +108,1 @@\n-        TrainingData_lock->lock();\n+        TrainingData_lock->lock_without_safepoint_check();\n@@ -676,3 +676,3 @@\n-  void dec_init_deps_left(KlassTrainingData* ktd);\n-  int init_deps_left() const {\n-    return Atomic::load(&_init_deps_left);\n+  void dec_init_deps_left_release(KlassTrainingData* ktd);\n+  int init_deps_left_acquire() const {\n+    return Atomic::load_acquire(&_init_deps_left);\n@@ -710,1 +710,1 @@\n-  void verify();\n+  void verify(bool verify_dep_counter);\n@@ -831,1 +831,1 @@\n-  void verify();\n+  void verify(bool verify_dep_counter);\n","filename":"src\/hotspot\/share\/oops\/trainingData.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -362,0 +362,9 @@\n+  product(bool, UseAutoVectorizationPredicate, true, DIAGNOSTIC,            \\\n+          \"Use AutoVectorization predicate (for speculative compilation)\")  \\\n+                                                                            \\\n+  product(bool, UseAutoVectorizationSpeculativeAliasingChecks, true, DIAGNOSTIC, \\\n+          \"Allow the use Multiversioning or Predicate to add aliasing\"      \\\n+          \"runtime checks. Runtime checks will only be inserted if either\"  \\\n+          \"LoopMultiversioning or UseAutoVectorizationPredicate are\"        \\\n+          \"enabled.\")                                                       \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4079,1 +4079,3 @@\n-  add_parse_predicate(Deoptimization::Reason_auto_vectorization_check, nargs);\n+  if (UseAutoVectorizationPredicate) {\n+    add_parse_predicate(Deoptimization::Reason_auto_vectorization_check, nargs);\n+  }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -643,2 +643,2 @@\n-        int written_chars = os::snprintf_checked(buffer, sizeof(buffer), \"%d\", value);\n-        if (written_chars <= 4) {\n+        int written_chars = os::snprintf(buffer, sizeof(buffer), \"%d\", value);\n+        if (written_chars > 0 && written_chars <= 4) {\n@@ -657,2 +657,2 @@\n-        int written_chars = os::snprintf_checked(buffer, sizeof(buffer), JLONG_FORMAT, value);\n-        if (written_chars <= 4) {\n+        int written_chars = os::snprintf(buffer, sizeof(buffer), JLONG_FORMAT, value);\n+        if (written_chars > 0 && written_chars <= 4) {\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -484,0 +484,2 @@\n+\/\/ For more descriptions on multiversioning:\n+\/\/ See: PhaseIdealLoop::maybe_multiversion_for_auto_vectorization_runtime_checks\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"opto\/c2_globals.hpp\"\n@@ -1136,5 +1137,7 @@\n-    \/\/ We only want to use the auto-vectorization check as a trap once per bci. And\n-    \/\/ PhaseIdealLoop::add_parse_predicate only checks trap limits per method, so\n-    \/\/ we do a custom check here.\n-    if (!C->too_many_traps(cloned_sfpt->jvms()->method(), cloned_sfpt->jvms()->bci(), Deoptimization::Reason_auto_vectorization_check)) {\n-      add_parse_predicate(Deoptimization::Reason_auto_vectorization_check, inner_head, outer_ilt, cloned_sfpt);\n+    if (UseAutoVectorizationPredicate) {\n+      \/\/ We only want to use the auto-vectorization check as a trap once per bci. And\n+      \/\/ PhaseIdealLoop::add_parse_predicate only checks trap limits per method, so\n+      \/\/ we do a custom check here.\n+      if (!C->too_many_traps(cloned_sfpt->jvms()->method(), cloned_sfpt->jvms()->bci(), Deoptimization::Reason_auto_vectorization_check)) {\n+        add_parse_predicate(Deoptimization::Reason_auto_vectorization_check, inner_head, outer_ilt, cloned_sfpt);\n+      }\n@@ -4645,0 +4648,3 @@\n+  if (UseAutoVectorizationPredicate && predicates.auto_vectorization_check_block()->is_non_empty()) {\n+    tty->print(\" auto_vectorization_check_predicate\");\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  assert(_raw_summands.is_empty(), \"no prior parsing\");\n@@ -49,0 +50,8 @@\n+#ifndef PRODUCT\n+  if (trace.is_trace_parsing()) {\n+    tty->print_cr(\"MemPointerParser::parse: size=%d\", size);\n+    tty->print(\"  mem:     \"); _mem->dump();\n+    tty->print(\"  pointer: \"); pointer->dump();\n+  }\n+#endif\n+\n@@ -50,1 +59,1 @@\n-  _worklist.push(MemPointerSummand(pointer, NoOverflowInt(1)));\n+  _worklist.push(MemPointerRawSummand::make_trivial(pointer));\n@@ -63,3 +72,61 @@\n-  \/\/ Bail out if there is a constant overflow.\n-  if (_con.is_NaN()) {\n-    return MemPointer::make_trivial(pointer, size NOT_PRODUCT(COMMA trace));\n+  NOT_PRODUCT( if (trace.is_trace_parsing()) { MemPointerRawSummand::print_on(tty, _raw_summands); } )\n+  canonicalize_raw_summands();\n+  NOT_PRODUCT( if (trace.is_trace_parsing()) { MemPointerRawSummand::print_on(tty, _raw_summands); } )\n+\n+  create_summands();\n+  NOT_PRODUCT( if (trace.is_trace_parsing()) { MemPointerSummand::print_on(tty, _con, _summands); } )\n+  canonicalize_summands();\n+  NOT_PRODUCT( if (trace.is_trace_parsing()) { MemPointerSummand::print_on(tty, _con, _summands); } )\n+\n+  return MemPointer::make(pointer, _raw_summands, _con, _summands, size NOT_PRODUCT(COMMA trace));\n+}\n+\n+void MemPointerParser::canonicalize_raw_summands() {\n+  \/\/ We sort by:\n+  \/\/  - int group id\n+  \/\/  - variable idx\n+  \/\/ This means that summands of the same int group with the same variable are consecutive.\n+  \/\/ This simplifies the combining of summands below.\n+  _raw_summands.sort(MemPointerRawSummand::cmp_by_int_group_and_variable_idx);\n+\n+  \/\/ Combine summands of the same int group with the same variable, adding up the scales.\n+  int pos_put = 0;\n+  int pos_get = 0;\n+  while (pos_get < _raw_summands.length()) {\n+    const MemPointerRawSummand& summand = _raw_summands.at(pos_get++);\n+    Node* variable      = summand.variable();\n+    NoOverflowInt scaleI = summand.scaleI();\n+    NoOverflowInt scaleL = summand.scaleL();\n+    int int_group = summand.int_group();\n+    \/\/ Add up scale of all summands with the same variable.\n+    while (pos_get < _raw_summands.length() &&\n+           _raw_summands.at(pos_get).int_group() == int_group &&\n+           _raw_summands.at(pos_get).variable() == variable) {\n+      MemPointerRawSummand s = _raw_summands.at(pos_get++);\n+      if (int_group == 0) {\n+        assert(scaleI.is_one() && s.scaleI().is_one(), \"no ConvI2L\");\n+        scaleL = scaleL + s.scaleL();\n+      } else {\n+        assert(scaleL.value() == s.scaleL().value(), \"same ConvI2L, same scaleL\");\n+        scaleI = scaleI + s.scaleI();\n+      }\n+    }\n+    \/\/ Keep summands with non-zero scale.\n+    if (!scaleI.is_zero() && !scaleL.is_NaN()) {\n+      _raw_summands.at_put(pos_put++, MemPointerRawSummand(variable, scaleI, scaleL, int_group));\n+    }\n+  }\n+  _raw_summands.trunc_to(pos_put);\n+}\n+\n+void MemPointerParser::create_summands() {\n+  assert(_con.is_zero(), \"no prior parsing\");\n+  assert(_summands.is_empty(), \"no prior parsing\");\n+\n+  for (int i = 0; i < _raw_summands.length(); i++) {\n+    const MemPointerRawSummand& raw_summand = _raw_summands.at(i);\n+    if (raw_summand.is_con()) {\n+      _con = _con + raw_summand.to_con();\n+    } else {\n+      _summands.push(raw_summand.to_summand());\n+    }\n@@ -67,0 +134,1 @@\n+}\n@@ -68,0 +136,1 @@\n+void MemPointerParser::canonicalize_summands() {\n@@ -84,4 +153,0 @@\n-    \/\/ Bail out if scale is NaN.\n-    if (scale.is_NaN()) {\n-      return MemPointer::make_trivial(pointer, size NOT_PRODUCT(COMMA trace));\n-    }\n@@ -94,2 +159,0 @@\n-\n-  return MemPointer::make(pointer, _summands, _con, size NOT_PRODUCT(COMMA trace));\n@@ -101,1 +164,1 @@\n-void MemPointerParser::parse_sub_expression(const MemPointerSummand& summand, MemPointerParserCallback& callback) {\n+void MemPointerParser::parse_sub_expression(const MemPointerRawSummand& summand, MemPointerParserCallback& callback) {\n@@ -103,1 +166,3 @@\n-  const NoOverflowInt scale = summand.scale();\n+  const NoOverflowInt scaleI = summand.scaleI();\n+  const NoOverflowInt scaleL = summand.scaleL();\n+  const int int_group = summand.int_group();\n@@ -107,1 +172,1 @@\n-  if (is_safe_to_decompose_op(opc, scale)) {\n+  if (is_safe_to_decompose_op(opc, scaleI * scaleL)) {\n@@ -112,1 +177,1 @@\n-        \/\/ Terminal: add to constant.\n+        \/\/ Terminal summand.\n@@ -115,1 +180,3 @@\n-        _con = _con + scale * con;\n+        NoOverflowInt conI = (int_group == 0) ? scaleI : scaleI * con;\n+        NoOverflowInt conL = (int_group == 0) ? scaleL * con : scaleL;\n+        _raw_summands.push(MemPointerRawSummand::make_con(conI, conL, int_group));\n@@ -125,2 +192,2 @@\n-        _worklist.push(MemPointerSummand(a, scale));\n-        _worklist.push(MemPointerSummand(b, scale));\n+        _worklist.push(MemPointerRawSummand(a, scaleI, scaleL, int_group));\n+        _worklist.push(MemPointerRawSummand(b, scaleI, scaleL, int_group));\n@@ -137,1 +204,3 @@\n-        NoOverflowInt sub_scale = NoOverflowInt(-1) * scale;\n+        \/\/                   int_group  x.scaleI  x.scaleL  y.scaleI  y.scaleL\n+        \/\/ 2L * (x - y)      0          1         2         1         -2\n+        \/\/ ConvI2L(x - y)    1          1         1         -1        1\n@@ -139,2 +208,5 @@\n-        _worklist.push(MemPointerSummand(a, scale));\n-        _worklist.push(MemPointerSummand(b, sub_scale));\n+        NoOverflowInt sub_scaleI = (int_group == 0) ? scaleI : scaleI * NoOverflowInt(-1);\n+        NoOverflowInt sub_scaleL = (int_group == 0) ? scaleL * NoOverflowInt(-1) : scaleL;\n+\n+        _worklist.push(MemPointerRawSummand(a,     scaleI,     scaleL, int_group));\n+        _worklist.push(MemPointerRawSummand(b, sub_scaleI, sub_scaleL, int_group));\n@@ -172,2 +244,6 @@\n-        \/\/ Accumulate scale.\n-        NoOverflowInt new_scale = scale * factor;\n+        \/\/                         int_group  x.scaleI  x.scaleL\n+        \/\/ 2L * (4L * x)           0          1         8\n+        \/\/ 2L * ConvI2L(4 * x)     1          4         2\n+\n+        NoOverflowInt mul_scaleI = (int_group == 0) ? scaleI : scaleI * factor;\n+        NoOverflowInt mul_scaleL = (int_group == 0) ? scaleL * factor : scaleL;\n@@ -175,1 +251,1 @@\n-        _worklist.push(MemPointerSummand(variable, new_scale));\n+        _worklist.push(MemPointerRawSummand(variable, mul_scaleI, mul_scaleL, int_group));\n@@ -203,1 +279,10 @@\n-          _worklist.push(MemPointerSummand(a, scale));\n+\n+          int cast_int_group = int_group;\n+#ifdef _LP64\n+          if (opc == Op_ConvI2L) {\n+            assert(int_group == 0, \"only find ConvI2L once\");\n+            \/\/ We just discovered a new ConvI2L, and this creates a new \"int group\".\n+            cast_int_group = _next_int_group++;\n+          }\n+#endif\n+          _worklist.push(MemPointerRawSummand(a, scaleI, scaleL, cast_int_group));\n@@ -215,1 +300,1 @@\n-  _summands.push(summand);\n+  _raw_summands.push(summand);\n@@ -621,0 +706,52 @@\n+\/\/ Examples:\n+\/\/   p1 = MemPointer[size=1, base + i + 16]\n+\/\/   p2 = MemPointer[size=1, base + i + 17]\n+\/\/   -> Always at distance 1\n+\/\/   -> Can never overlap -> return false\n+\/\/\n+\/\/   p1 = MemPointer[size=1, base + i + 16]\n+\/\/   p2 = MemPointer[size=1, base + i + 16]\n+\/\/   -> Always at distance 0\n+\/\/   -> Always have exact overlap -> return true\n+\/\/\n+\/\/   p1 = MemPointer[size=4, x + y + z + 4L * i + 16]\n+\/\/   p2 = MemPointer[size=4, x + y + z + 4L * i + 56]\n+\/\/   -> Always at distance 40\n+\/\/   -> Can never overlap -> return false\n+\/\/\n+\/\/   p1 = MemPointer[size=8, x + y + z + 4L * i + 16]\n+\/\/   p2 = MemPointer[size=8, x + y + z + 4L * i + 20]\n+\/\/   -> Always at distance 4\n+\/\/   -> Always have partial overlap -> return true\n+\/\/\n+\/\/   p1 = MemPointer[size=4, base1 + 4L * i1 + 16]\n+\/\/   p2 = MemPointer[size=4, base2 + 4L * i2 + 20]\n+\/\/   -> Have differing summands, distance is unknown\n+\/\/   -> Unknown if overlap at runtime -> return false\n+bool MemPointer::always_overlaps_with(const MemPointer& other) const {\n+  const MemPointerAliasing aliasing = get_aliasing_with(other NOT_PRODUCT( COMMA _trace ));\n+\n+  \/\/ The aliasing tries to compute:\n+  \/\/   distance = other - this\n+  \/\/\n+  \/\/ We know that we have an overlap if we can prove:\n+  \/\/   this < other + other.size       &&  this + this.size > other\n+  \/\/\n+  \/\/ Which we can restate as:\n+  \/\/   distance > -other.size          &&  this.size > distance\n+  \/\/\n+  const jint distance_lo = -other.size();\n+  const jint distance_hi = size();\n+  bool is_always_overlap = aliasing.is_always_in_distance_range(distance_lo, distance_hi);\n+\n+#ifndef PRODUCT\n+  if (_trace.is_trace_overlap()) {\n+    tty->print(\"Always Overlap: %s, distance_lo: %d, distance_hi: %d, aliasing: \",\n+               is_always_overlap ? \"true\" : \"false\", distance_lo, distance_hi);\n+    aliasing.print_on(tty);\n+    tty->cr();\n+  }\n+#endif\n+\n+  return is_always_overlap;\n+}\n","filename":"src\/hotspot\/share\/opto\/mempointer.cpp","additions":162,"deletions":25,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -44,0 +44,4 @@\n+\/\/ A more advanced use case of MemPointers is speculative aliasing analysis. If we can prove that\n+\/\/ the MemPointer has a linear form in the loop induction variable (iv), we can formulate runtime\n+\/\/ checks to establish that two MemPointer never overlap for all iterations, i.e. for all iv values.\n+\/\/\n@@ -161,1 +165,1 @@\n-\/\/   Where each summand_i in summands has the form:\n+\/\/   Where each summand_i in summands has the MemPointerSummand form:\n@@ -270,0 +274,4 @@\n+\/\/   Even further down, we prove the \"MemPointer Linearity Corrolary\", where we show that\n+\/\/   (under reasonable restrictions) both the MemPointer and the corresponding pointer\n+\/\/   can be considered linear functions.\n+\/\/\n@@ -388,1 +396,97 @@\n-\n+\/\/\n+\/\/\n+\/\/ Having proven the \"MemPointer Lemma\", we can now derive an interesting corrolary.\n+\/\/\n+\/\/ With the \"Linearity Corrolary\" below, we can prove that some MemPointers can be treated as\n+\/\/ linear in some summand variable v over some range r. This is useful when MemPointers are\n+\/\/ used in loops, where v=iv scale_v=scale_iv and the range is the iv range from some initial\n+\/\/ iv value to the last iv value just before the limit.\n+\/\/ For an application, see: VPointer::make_speculative_aliasing_check_with\n+\/\/\n+\/\/ MemPointer Linearity Corrolary:\n+\/\/   Given:\n+\/\/     (C0) pointer p and its MemPointer mp, which is constructed with safe decompositions.\n+\/\/     (C1) a specific summand \"scale_v * v\" that occurs in mp.\n+\/\/     (C2) a strided range r = [lo, lo + stride_v, .. hi] for v (lo and hi are inclusive in the range).\n+\/\/     (C3) for all v in this strided range r we know that p is within bounds of its memory object.\n+\/\/     (C4) abs(scale_v * stride_v) < 2^31\n+\/\/            Required for (S2) in application of MemPointer Lemma below, it is essencial in\n+\/\/            establishing linearity of mp.\n+\/\/\n+\/\/   Then:\n+\/\/     Both p and mp have a linear form for v in r:\n+\/\/       p(v)  = p(lo)  - lo * scale_v + v * scale_v              (Corrolary P)\n+\/\/       mp(v) = mp(lo) - lo * scale_v + v * scale_v              (Corrolary MP)\n+\/\/\n+\/\/     Note: the calculations are done in long, and hence there can be no int overflow.\n+\/\/           Thus, p(v) and mp(v) can be considered linear functions for v in r.\n+\/\/\n+\/\/   It can be useful to \"anchor\" at hi instead of lo:\n+\/\/     p(hi) = p(lo) - lo * scale_v + hi * scale_v\n+\/\/\n+\/\/     p(v) = p(lo) - lo * scale_v + v * scale_v\n+\/\/            --------------------\n+\/\/          = p(hi) - hi * scale_v + v * scale_v             (Alternative Corrolary P)\n+\/\/\n+\/\/\n+\/\/ Proof of \"MemPointer Linearity Corrolary\":\n+\/\/   We state the form of mp:\n+\/\/\n+\/\/     mp = summand_rest + scale_v * v + con\n+\/\/\n+\/\/   We prove the Corrolary by induction over v:\n+\/\/   Base Case: v = lo\n+\/\/     p(lo)  = p(lo)  - lo * scale_v + lo * scale_v\n+\/\/     mp(lo) = mp(lo) - lo * scale_v + lo * scale_v\n+\/\/\n+\/\/   Step Case: v0 and v1 in r, v1 = v0 + stride_v\n+\/\/     Assume:\n+\/\/       p(v0)  = p(lo)  - lo * scale_v + v * scale_v          (Induction Hypothesis IH-P)\n+\/\/       mp(v0) = mp(lo) - lo * scale_v + v * scale_v          (Induction Hypothesis IH-MP)\n+\/\/\n+\/\/     We take the form of mp, and further apply SAFE1 decompositions, i.e. long addition,\n+\/\/     subtraction and multiplication:\n+\/\/       mp(v1) = summand_rest + scale_v * v1                                   + con\n+\/\/              = summand_rest + scale_v * (v0 + stride_v)                      + con\n+\/\/              = summand_rest + scale_v * v0              + scale_v * stride_v + con\n+\/\/              = mp(v0)                                   + scale_v * stride_v\n+\/\/\n+\/\/     From this it follows that we can see mp(v0) and mp(v1) as two MemPointer with the\n+\/\/     same summands, and only their constants differ by exactly \"scale_v * stride_v\":\n+\/\/       mp(v0) = summand_rest + scale_v * v0 + con\n+\/\/       mp(v1) = summand_rest + scale_v * v0 + con + scale_v * stride_v            (MP-DIFF)\n+\/\/\n+\/\/     We continue by applying the Induction Hypothesis IH-MP\n+\/\/       mp(v1) = mp(v0)                                + scale_v * stride_v\n+\/\/                -------- apply (IH-MP) -------------\n+\/\/              = mp(lo) - lo * scale_v + v0 * scale_v  + scale_v * stride_v\n+\/\/              = mp(lo) - lo * scale_v + (v0 + stride_v) * scale_v\n+\/\/              = mp(lo) - lo * scale_v + v1 * scale_v\n+\/\/\n+\/\/     This proves the Corrolary MP.\n+\/\/\n+\/\/     To prove the Corrolary P, we now apply the MemPointer Lemma:\n+\/\/       (S0) Let p(v0) and p(v1) be the pointers corresponding to v0 and v1, and mp(v0) and mp(v1)\n+\/\/            their MemPointer. (C0) provides the safe deconstruction, and reformulation of terms\n+\/\/            happens with long addition, subtraction and multiplication only, and is hence SAFE\n+\/\/            as well.\n+\/\/       (S1) According to (C3), p is in bounds of its memory object for all v in r. Since v0 and\n+\/\/            v1 are in r, it follows that p(v0) and p(v1) are in bounds of the same memory object.\n+\/\/       (S2) The difference of constants of mp(v0) and mp(v1) is exactly \"scale_v * stride_v\" (MP-DIFF).\n+\/\/            Given (C4), this difference is not too large.\n+\/\/       (S3) All summands of mp0 and mp1 are the same (only the constants differ), given (MP-DIFF).\n+\/\/\n+\/\/     It follows:\n+\/\/       p(v1) - p(v0) = mp(v1) - mp(v0)\n+\/\/\n+\/\/     Reformulating and applying (MP-DIFF) and (IH-P):\n+\/\/       p(v1) = p(v0)                                  + mp(v1) - mp(v1)\n+\/\/                                                        apply (MP-DIFF)\n+\/\/             = p(v0)                                  + scale_v * stride_v\n+\/\/               ------------ apply (IH-P) ------------\n+\/\/             = p(lo) - lo * scale_v + v0 * scale_v    + scale_v * stride_v\n+\/\/             = p(lo) - lo * scale_v + (v0 + stride_v) * scale_v\n+\/\/             = p(lo) - lo * scale_v + v1 * scale_v\n+\/\/\n+\/\/     This proves Corrolary P.\n+\/\/\n@@ -469,0 +573,7 @@\n+  \/\/ Use case: overlap.\n+  \/\/ Note: the bounds are exclusive: lo < element < hi\n+  bool is_always_in_distance_range(const jint distance_lo, const jint distance_hi) const {\n+    return _aliasing == AlwaysAtDistance &&\n+           (distance_lo < _distance && _distance < distance_hi);\n+  }\n+\n@@ -543,1 +654,161 @@\n-    tty->print(\" * [%d %s]\", _variable->_idx, _variable->Name());\n+    st->print(\" * [%d %s]\", _variable->_idx, _variable->Name());\n+  }\n+\n+  static void print_on(outputStream* st, NoOverflowInt con, const GrowableArray<MemPointerSummand>& summands) {\n+    st->print(\"Summands (%d): con(\", summands.length());\n+    con.print_on(st);\n+    st->print(\")\");\n+    for (int i = 0; i < summands.length(); i++) {\n+      st->print(\" + \");\n+      summands.at(i).print_on(tty);\n+    }\n+    st->cr();\n+  }\n+#endif\n+};\n+\n+\/\/ We need two different ways of tracking the summands:\n+\/\/ - MemPointerRawSummand: designed to keep track of the original form of\n+\/\/                         the pointer, preserving its overflow behavior.\n+\/\/ - MemPointerSummand:    designed to allow simplification of the MemPointer\n+\/\/                         form, does not preserve the original form and\n+\/\/                         ignores overflow from ConvI2L.\n+\/\/\n+\/\/ The MemPointerSummand is designed to allow the simplification of\n+\/\/ the MemPointer form as much as possible, to allow aliasing checks\n+\/\/ to be as simple as possible. For example, the C2 IR pointer:\n+\/\/\n+\/\/   pointer = AddP(\n+\/\/               AddP(\n+\/\/                 base,\n+\/\/                 LShiftL(\n+\/\/                   ConvI2L(\n+\/\/                     AddI(AddI(i, LShiftI(j, 2)), con1)\n+\/\/                   ),\n+\/\/                   1\n+\/\/                 )\n+\/\/               ),\n+\/\/               con2\n+\/\/             )\n+\/\/\n+\/\/ and more readable:\n+\/\/\n+\/\/   pointer = base + 2L * ConvI2L(i + 4 * j + con1) + con2\n+\/\/\n+\/\/ is simplified to this MemPointer form, using only MemPointerSummands,\n+\/\/ which ignore the possible overflow in ConvI2L:\n+\/\/\n+\/\/   pointer = base + 2L * ConvI2L(i) + 8L * ConvI2L(j) + con\n+\/\/   con = 2L * con1 + con2\n+\/\/\n+\/\/ This is really convenient, because this way we are able to ignore\n+\/\/ the ConvI2L in the aliasing anaylsis computation, and we can collect\n+\/\/ all constants to a single constant. Even with this simplicication,\n+\/\/ we are able to prove the correctness of the aliasing checks.\n+\/\/\n+\/\/ However, there is one thing we are not able to do with this simplification:\n+\/\/ we cannot reconstruct the original pointer expression, because the\n+\/\/ simplification ignores overflows that could happen inside the ConvI2L:\n+\/\/\n+\/\/   2L * ConvI2L(i + 4 * j + con1) != 2L * ConvI2L(i) + 8L * ConvI2L(j) + 2L * con1\n+\/\/\n+\/\/ The MemPointerRawSummand is designed to keep track of the original form\n+\/\/ of the pointer, preserving its overflow behaviour. We observe that the\n+\/\/ only critical point for overflows is at the ConvI2L. Thus, we give each\n+\/\/ ConvI2L a \"int group\" id > 0, and all raw summands belonging to that ConvI2L\n+\/\/ have that id. This allows us to reconstruct which raw summands need to\n+\/\/ be added together before the ConvI2L. Any raw summands that do not belong\n+\/\/ to a ConvI2L (i.e. the summands with long variables) have \"int group\"\n+\/\/ id = 0, since they do not belong to any such \"int group\" and can be\n+\/\/ directly added together. For raw summands belonging to an \"int group\",\n+\/\/ we need to track the scale inside (scaleI) and outside (scaleL) the\n+\/\/ ConvI2L. With the example from above:\n+\/\/\n+\/\/   pointer = base + 2L * ConvI2L(i + 4 * j + con1) + con2\n+\/\/\n+\/\/   _variable  = base  _variable  = i  _variable  = j  _variable  = null  _variable  = null\n+\/\/   _scaleI    = 1     _scaleI    = 1  _scaleI    = 4  _scaleI    = con1  _scaleI    = 1\n+\/\/   _scaleL    = 1     _scaleL    = 2  _scaleL    = 2  _scaleL    = 2     _scaleL    = con2\n+\/\/   _int_group = 0     _int_group = 1  _int_group = 1  _int_group = 1     _int_group = 0\n+\/\/\n+\/\/ Note: we also need to track constants as separate raw summands. For\n+\/\/       this, we say that a raw summand tracks a constant iff _variable == null,\n+\/\/       and we store the constant value in _scaleI (for int constant) and in\n+\/\/       _scaleL (for long constants).\n+\/\/\n+class MemPointerRawSummand : public StackObj {\n+private:\n+  Node* _variable;\n+  NoOverflowInt _scaleI;\n+  NoOverflowInt _scaleL;\n+  int _int_group;\n+\n+public:\n+  MemPointerRawSummand(Node* variable, NoOverflowInt scaleI, NoOverflowInt scaleL, int int_group) :\n+    _variable(variable), _scaleI(scaleI), _scaleL(scaleL), _int_group(int_group) {}\n+\n+  MemPointerRawSummand() :\n+    MemPointerRawSummand(nullptr, NoOverflowInt::make_NaN(), NoOverflowInt::make_NaN(), -1) {}\n+\n+  static MemPointerRawSummand make_trivial(Node* variable) {\n+    assert(variable != nullptr, \"must have variable\");\n+    return MemPointerRawSummand(variable, NoOverflowInt(1), NoOverflowInt(1), 0);\n+  }\n+\n+  static MemPointerRawSummand make_con(NoOverflowInt scaleI, NoOverflowInt scaleL, int int_group) {\n+    return MemPointerRawSummand(nullptr, scaleI, scaleL, int_group);\n+  }\n+\n+  bool is_valid() const { return _int_group >= 0; }\n+  bool is_con() const { assert(is_valid(), \"\"); return _variable == nullptr; }\n+  Node* variable() const { assert(is_valid(), \"\"); return _variable; }\n+  NoOverflowInt scaleI() const { assert(is_valid(), \"\"); return _scaleI; }\n+  NoOverflowInt scaleL() const { assert(is_valid(), \"\"); return _scaleL; }\n+  int int_group() const { assert(is_valid(), \"\"); return _int_group; }\n+\n+  MemPointerSummand to_summand() const {\n+    assert(!is_con(), \"must be variable\");\n+    return MemPointerSummand(variable(), scaleL() * scaleI());\n+  }\n+\n+  NoOverflowInt to_con() const {\n+    assert(is_con(), \"must be constant\");\n+    return scaleL() * scaleI();\n+  }\n+\n+  static int cmp_by_int_group_and_variable_idx(MemPointerRawSummand* p1, MemPointerRawSummand* p2) {\n+    int int_group_diff = p1->int_group() - p2->int_group();\n+    if (int_group_diff != 0) { return int_group_diff; }\n+\n+    if (p1->is_con()) {\n+      return p2->is_con() ? 0 : 1;\n+    }\n+    if (p2->is_con()) {\n+      return -1;\n+    }\n+    return p1->variable()->_idx - p2->variable()->_idx;\n+  }\n+\n+#ifndef PRODUCT\n+  void print_on(outputStream* st) const {\n+    if (!is_valid()) {\n+      st->print(\"<invalid>\");\n+    } else {\n+      st->print(\"<%d: \", _int_group);\n+      _scaleL.print_on(st);\n+      st->print(\" * \");\n+      _scaleI.print_on(st);\n+      if (!is_con()) {\n+        st->print(\" * [%d %s]\", _variable->_idx, _variable->Name());\n+      }\n+      st->print(\">\");\n+    }\n+  }\n+\n+  static void print_on(outputStream* st, const GrowableArray<MemPointerRawSummand>& summands) {\n+    st->print(\"Raw Summands (%d): \", summands.length());\n+    for (int i = 0; i < summands.length(); i++) {\n+      if (i > 0) { st->print(\" + \"); }\n+      summands.at(i).print_on(tty);\n+    }\n+    st->cr();\n@@ -585,4 +856,7 @@\n-  \/\/ We limit the number of summands to 10. This is just a best guess, and not at this\n-  \/\/ point supported by evidence. But I think it is reasonable: usually, a pointer\n-  \/\/ contains a base pointer (e.g. array pointer or null for native memory) and a few\n-  \/\/ variables. It should be rare that we have more than 9 variables.\n+  \/\/ We limit the number of summands to 10, and the raw summands to 16. This is just a\n+  \/\/ best guess, and not at this point supported by evidence. But I think it is reasonable:\n+  \/\/ usually, a pointer contains a base pointer (e.g. array pointer or null for native memory)\n+  \/\/ and a few variables. It should be rare that we have more than 9 variables. We need\n+  \/\/ a few more raw summands, especially because there can be multiple constants, one\n+  \/\/ per ConvI2L \"int group\".\n+  static const int RAW_SUMMANDS_SIZE = 16;\n@@ -640,0 +914,7 @@\n+  \/\/ Raw summands: represent the pointer form exactly, allowing the reconstruction of the\n+  \/\/               pointer expression. Overflows inside the \"int groups\" (i.e. ConvI2L)\n+  \/\/               are preserved, and there may be multiple constants.\n+  MemPointerRawSummand _raw_summands[RAW_SUMMANDS_SIZE];\n+\n+  \/\/ Summands:     Simplified form, with only a single constant. Makes aliasing analysis\n+  \/\/               much simpler.\n@@ -643,0 +924,2 @@\n+\n+  \/\/ Size in bytes for the referenced memory region: [pointer, pointer + size)\n@@ -644,0 +927,1 @@\n+\n@@ -662,0 +946,1 @@\n+             const GrowableArray<MemPointerRawSummand>& raw_summands,\n@@ -673,0 +958,1 @@\n+    assert(raw_summands.length() <= RAW_SUMMANDS_SIZE, \"raw summands must fit\");\n@@ -679,0 +965,5 @@\n+    for (int i = 0; i < raw_summands.length(); i++) {\n+      const MemPointerRawSummand& s = raw_summands.at(i);\n+      assert(!s.scaleI().is_NaN(), \"non-NaN scale\");\n+      assert(!s.scaleL().is_NaN(), \"non-NaN scale\");\n+    }\n@@ -681,0 +972,5 @@\n+    \/\/ Copy raw summands in the same order.\n+    for (int i = 0; i < raw_summands.length(); i++) {\n+      _raw_summands[i] = raw_summands.at(i);\n+    }\n+\n@@ -711,0 +1007,5 @@\n+\n+    for (int i = 0; i < RAW_SUMMANDS_SIZE; i++) {\n+      _raw_summands[i] = old.raw_summands_at(i);\n+    }\n+\n@@ -736,0 +1037,2 @@\n+                         const GrowableArray<MemPointerRawSummand>& raw_summands,\n+                         const NoOverflowInt con,\n@@ -737,1 +1040,0 @@\n-                         const NoOverflowInt& con,\n@@ -740,2 +1042,4 @@\n-    if (summands.length() <= SUMMANDS_SIZE) {\n-      return MemPointer(pointer, summands, con, size NOT_PRODUCT(COMMA trace));\n+    if (raw_summands.length() <= RAW_SUMMANDS_SIZE &&\n+        summands.length() <= SUMMANDS_SIZE &&\n+        has_no_NaN_in_con_and_summands(con, summands)) {\n+      return MemPointer(pointer, raw_summands, summands, con, size NOT_PRODUCT(COMMA trace));\n@@ -747,0 +1051,9 @@\n+  static bool has_no_NaN_in_con_and_summands(const NoOverflowInt con,\n+                                             const GrowableArray<MemPointerSummand>& summands) {\n+    if (con.is_NaN()) { return false; }\n+    for (int i = 0; i < summands.length(); i++) {\n+      if (summands.at(i).scale().is_NaN()) { return false; }\n+    }\n+    return true;\n+  }\n+\n@@ -778,0 +1091,5 @@\n+  const MemPointerRawSummand& raw_summands_at(const uint i) const {\n+    assert(i < RAW_SUMMANDS_SIZE, \"in bounds\");\n+    return _raw_summands[i];\n+  }\n+\n@@ -782,0 +1100,19 @@\n+  int max_int_group() const {\n+    int n = 0;\n+    for (int i = 0; i < RAW_SUMMANDS_SIZE; i++) {\n+      const MemPointerRawSummand& s = _raw_summands[i];\n+      if (!s.is_valid()) { continue; }\n+      n = MAX2(n, s.int_group());\n+    }\n+    return n;\n+  }\n+\n+  template<typename Callback>\n+  void for_each_raw_summand_of_int_group(int int_group, Callback callback) const {\n+    for (int i = 0; i < RAW_SUMMANDS_SIZE; i++) {\n+      const MemPointerRawSummand& s = _raw_summands[i];\n+      if (!s.is_valid() || s.int_group() != int_group) { continue; }\n+      callback(s);\n+    }\n+  }\n+\n@@ -804,0 +1141,1 @@\n+  bool always_overlaps_with(const MemPointer& other) const;\n@@ -821,1 +1159,1 @@\n-  void print_on(outputStream* st, bool end_with_cr = true) const {\n+  void print_on(outputStream* st) const {\n@@ -827,1 +1165,42 @@\n-    if (end_with_cr) { st->cr(); }\n+    st->cr();\n+\n+    st->print(\"  raw: \");\n+\n+    int long_count = 0;\n+    for_each_raw_summand_of_int_group(0, [&] (const MemPointerRawSummand& s) {\n+      if (long_count > 0) { st->print(\" + \"); }\n+      long_count++;\n+      if (s.is_con()) {\n+        \/\/ Long constant.\n+        NoOverflowInt con = s.scaleI() * s.scaleL();\n+        con.print_on(st);\n+        st->print(\"L\");\n+      } else {\n+        \/\/ Long variable.\n+        assert(s.scaleI().is_one(), \"must be long variable\");\n+        s.scaleL().print_on(st);\n+        st->print(\"L * [%d %s]\", s.variable()->_idx, s.variable()->Name());\n+      }\n+    });\n+\n+    \/\/ Int groups, i.e. \"ConvI2L(...)\"\n+    for (int int_group = 1; int_group <= max_int_group(); int_group++) {\n+      if (long_count > 0) { st->print(\" + \"); }\n+      long_count++;\n+      int int_count = 0;\n+      for_each_raw_summand_of_int_group(int_group, [&] (const MemPointerRawSummand& s) {\n+        if (int_count == 0) {\n+          s.scaleL().print_on(st);\n+          st->print(\"L * ConvI2L(\");\n+        } else {\n+          st->print(\" + \");\n+        }\n+        int_count++;\n+        s.scaleI().print_on(st);\n+        if (!s.is_con()) {\n+          st->print(\" * [%d %s]\", s.variable()->_idx, s.variable()->Name());\n+        }\n+      });\n+      st->print(\")\");\n+    }\n+    st->cr();\n@@ -841,3 +1220,7 @@\n-  \/\/ Internal data-structures for parsing.\n-  NoOverflowInt _con;\n-  GrowableArray<MemPointerSummand> _worklist;\n+  \/\/ Internal data-structures for parsing raw summands.\n+  int _next_int_group = 1;\n+  GrowableArray<MemPointerRawSummand> _worklist;\n+  GrowableArray<MemPointerRawSummand> _raw_summands;\n+\n+  \/\/ Internal data-structures for parsing \"regular\" summands.\n+  NoOverflowInt _con = NoOverflowInt(0);\n@@ -853,1 +1236,0 @@\n-    _con(NoOverflowInt(0)),\n@@ -884,1 +1266,1 @@\n-  void parse_sub_expression(const MemPointerSummand& summand, MemPointerParserCallback& callback);\n+  void parse_sub_expression(const MemPointerRawSummand& summand, MemPointerParserCallback& callback);\n@@ -888,0 +1270,4 @@\n+\n+  void canonicalize_raw_summands();\n+  void create_summands();\n+  void canonicalize_summands();\n","filename":"src\/hotspot\/share\/opto\/mempointer.hpp","additions":403,"deletions":17,"binary":false,"changes":420,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"opto\/c2_globals.hpp\"\n@@ -47,4 +48,6 @@\n- *                    There are initially three Parse Predicates for each loop:\n- *                    - Loop Parse Predicate:             The Parse Predicate added for Loop Predicates.\n- *                    - Profiled Loop Parse Predicate:    The Parse Predicate added for Profiled Loop Predicates.\n- *                    - Loop Limit Check Parse Predicate: The Parse Predicate added for a Loop Limit Check Predicate.\n+ *                    There are initially five Parse Predicates for each loop:\n+ *                    - Loop Parse Predicate:               The Parse Predicate added for Loop Predicates.\n+ *                    - Profiled Loop Parse Predicate:      The Parse Predicate added for Profiled Loop Predicates.\n+ *                    - Loop Limit Check Parse Predicate:   The Parse Predicate added for a Loop Limit Check Predicate.\n+ *                    - Short Running Loop Parse Predicate: The Parse Predicate added for the short running long loop check.\n+ *                    - AutoVectorization Parse Predicate:  The Parse Predicate added for AutoVectorization runtime checks.\n@@ -52,1 +55,2 @@\n- *                      Loop Predicate) or a Loop Limit Check Predicate. These predicates will be checked at runtime while\n+ *                      Loop Predicate), a Loop Limit Check Predicate, a Short Running Long Loop Predicate, or a\n+ *                      AutoVectorization Runtime Check Predicate. These predicates will be checked at runtime while\n@@ -84,0 +88,15 @@\n+ *     - AutoVectorization:  This predicate is used for speculative runtime checks required for AutoVectorization.\n+ *       Runtime Check       There are multiple reasons why we need a runtime check to allow vectorization:\n+ *       Predicate           - Unknown aliasing:\n+ *                             An important compoinent of AutoVectorization is proving that memory addresses do not\n+ *                             alias, and can therefore be reordered. In some cases, this cannot be done statically\n+ *                             and a runtime check is necessary.\n+ *                           - Unknown alignment of native memory:\n+ *                             While heap objects have 8-byte alignment, off-heap (native) memory often has no alignment\n+ *                             guarantees. On platforms that require vectors to be aligned, we need to prove alignment.\n+ *                             We cannot do that statically with native memory, hence we need a runtime check.\n+ *                           The benefit of using a predicate is that we only have to compile the vectorized loop. If\n+ *                           the runtime check fails, we simply deoptimize. Should we eventually recompile, then the\n+ *                           predicate is not available any more, and we instead use a multiversioning approach with\n+ *                           both a vectorized and a scalar loop, where the runtime determines which loop is taken.\n+ *                           See: PhaseIdealLoop::maybe_multiversion_for_auto_vectorization_runtime_checks\n@@ -160,1 +179,3 @@\n- *                    There are three different Predicate Blocks:\n+ *                    There are five different Predicate Blocks:\n+ *                    - Short Running Long    Groups the Short Running Long Loop Predicate (if created), and the\n+ *                      Loop Predicate Block: Short Running Long Loop Parse Predicate together.\n@@ -166,0 +187,3 @@\n+ *                    - AutoVectorization     Groups the AutoVectorization Runtime Check Predicates (if any), and the\n+ *                      Runtime Check         AutoVectorization Runtime Check Parse Predicate together.\n+ *                      Predicate Block:\n@@ -172,1 +196,4 @@\n- * (predicates inside square brackets [] do not need to exist if there are no checks to hoist):\n+ * (predicates inside square brackets [] do not need to exist if there are no checks to hoist \/ insert):\n+ *\n+ *   [Short Running Long Loop Predicate] (at most one)                 \\ Short Running Long\n+ * Short Running Long Loop Parse Predicate                             \/ Loop Predicate Block\n@@ -186,0 +213,6 @@\n+ *   [AutoVectorization Runtime Check Predicate 1]                     \\\n+ *   [AutoVectorization Runtime Check Predicate 2]                     | AutoVectorization\n+ *   ...                                                               | Runtime Check\n+ *   [AutoVectorization Runtime Check Predicate l]                     | Predicate Block\n+ * AutoVectorization Runtime Check Parse Predicate                     \/\n+ *\n@@ -785,2 +818,4 @@\n-    PredicateBlockIterator auto_vectorization_check_iterator(current_node, Deoptimization::Reason_auto_vectorization_check);\n-    current_node = auto_vectorization_check_iterator.for_each(predicate_visitor);\n+    if (UseAutoVectorizationPredicate) {\n+      PredicateBlockIterator auto_vectorization_check_iterator(current_node, Deoptimization::Reason_auto_vectorization_check);\n+      current_node = auto_vectorization_check_iterator.for_each(predicate_visitor);\n+    }\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":44,"deletions":9,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -464,0 +464,3 @@\n+\/\/ Runtime Checks:\n+\/\/   Some required properties cannot be proven statically, and require a\n+\/\/   runtime check. See VTransform::add_speculative_check\n@@ -835,0 +838,5 @@\n+  \/\/ If we can speculate (using the aliasing runtime check), we can drop the weak edges,\n+  \/\/ and later insert a runtime check.\n+  \/\/ If we cannot speculate (aliasing analysis runtime checks), we need to respect all edges.\n+  bool speculate_away_weak_edges = _vloop.use_speculative_aliasing_checks();\n+\n@@ -841,0 +849,1 @@\n+      if (speculate_away_weak_edges && preds.is_current_weak_memory_edge()) { continue; }\n@@ -872,0 +881,6 @@\n+\n+  \/\/ If we can speculate (using the aliasing runtime check), we can drop the weak edges,\n+  \/\/ and later insert a runtime check.\n+  \/\/ If we cannot speculate (aliasing analysis runtime checks), we need to respect all edges.\n+  bool speculate_away_weak_edges = _vloop.use_speculative_aliasing_checks();\n+\n@@ -875,0 +890,1 @@\n+      if (speculate_away_weak_edges && preds.is_current_weak_memory_edge()) { continue; }\n@@ -1635,0 +1651,2 @@\n+    } else if (VectorNode::is_reinterpret_opcode(opc)) {\n+      retValue = Matcher::match_rule_supported_auto_vectorization(Op_VectorReinterpret, size, velt_basic_type(p0));\n@@ -1939,0 +1957,1 @@\n+                        _vloop.is_trace_speculative_aliasing_analysis(),\n@@ -1992,1 +2011,2 @@\n-  apply_speculative_runtime_checks();\n+  apply_speculative_alignment_runtime_checks();\n+  apply_speculative_aliasing_runtime_checks();\n@@ -2093,5 +2113,1 @@\n-  \/\/ We keep track of the resulting Nodes from every \"VTransformNode::apply\" call.\n-  \/\/ Since \"apply\" is called on defs before uses, this allows us to find the\n-  \/\/ generated def (input) nodes when we are generating the use nodes in \"apply\".\n-  int length = _vtnodes.length();\n-  GrowableArray<Node*> vtnode_idx_to_transformed_node(length, length, nullptr);\n+  VTransformApplyState apply_state(_vloop_analyzer, _vtnodes.length());\n@@ -2101,2 +2117,1 @@\n-    VTransformApplyResult result = vtn->apply(_vloop_analyzer,\n-                                              vtnode_idx_to_transformed_node);\n+    VTransformApplyResult result = vtn->apply(apply_state);\n@@ -2105,1 +2120,1 @@\n-    vtnode_idx_to_transformed_node.at_put(vtn->_idx, result.node());\n+    apply_state.set_transformed_node(vtn, result.node());\n@@ -3059,1 +3074,1 @@\n-  Node* xbic = igvn().intcon(is_sub ? -con : con);\n+  Node* xbic = phase()->intcon(is_sub ? -con : con);\n@@ -3076,1 +3091,1 @@\n-    Node* invar_scale_con = igvn().intcon(invar_scale);\n+    Node* invar_scale_con = phase()->intcon(invar_scale);\n@@ -3128,1 +3143,1 @@\n-  Node* log2_abs_iv_scale = igvn().intcon(exact_log2(abs(iv_scale)));\n+  Node* log2_abs_iv_scale = phase()->intcon(exact_log2(abs(iv_scale)));\n@@ -3153,1 +3168,1 @@\n-  Node* mask_AW = igvn().intcon(AW-1);\n+  Node* mask_AW = phase()->intcon(AW-1);\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":28,"deletions":13,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -58,0 +58,2 @@\n+\/\/\n+\/\/ For more documentation, see: SuperWord::SLP_extract\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,13 @@\n-    VTransformScalarNode* vtn = new (_vtransform.arena()) VTransformScalarNode(_vtransform, n);\n+\n+    VTransformNode* vtn = nullptr;\n+    if (n->is_Load() || n->is_Store()) {\n+      MemNode* mem = n->as_Mem();\n+      const VPointer& mem_p = _vloop_analyzer.vpointers().vpointer(mem);\n+      vtn = new (_vtransform.arena()) VTransformMemopScalarNode(_vtransform, mem, mem_p);\n+    } else if (n->is_Phi()) {\n+      vtn = new (_vtransform.arena()) VTransformLoopPhiNode(_vtransform, n->as_Phi());\n+    } else if (n->is_CFG()) {\n+      vtn = new (_vtransform.arena()) VTransformCFGNode(_vtransform, n);\n+    } else {\n+      vtn = new (_vtransform.arena()) VTransformDataScalarNode(_vtransform, n);\n+    }\n@@ -71,1 +83,1 @@\n-      set_req_with_scalar(p0,   vtn, MemNode::Address);\n+      init_req_with_scalar(p0,   vtn, MemNode::Address);\n@@ -76,2 +88,2 @@\n-      set_req_with_scalar(p0,   vtn, MemNode::Address);\n-      set_req_with_vector(pack, vtn, MemNode::ValueIn);\n+      init_req_with_scalar(p0,   vtn, MemNode::Address);\n+      init_req_with_vector(pack, vtn, MemNode::ValueIn);\n@@ -82,2 +94,2 @@\n-      set_req_with_scalar(p0,   vtn, 1); \/\/ scalar init\n-      set_req_with_vector(pack, vtn, 2); \/\/ vector\n+      init_req_with_scalar(p0,   vtn, 1); \/\/ scalar init\n+      init_req_with_vector(pack, vtn, 2); \/\/ vector\n@@ -89,2 +101,2 @@\n-        set_req_with_vector(pack, vtn, 1);\n-        set_req_with_scalar(p0,   vtn, 2); \/\/ constant rotation\n+        init_req_with_vector(pack, vtn, 1);\n+        init_req_with_scalar(p0,   vtn, 2); \/\/ constant rotation\n@@ -92,2 +104,2 @@\n-        set_req_with_vector(pack, vtn, 1);\n-        set_req_with_scalar(p0,   vtn, 2); \/\/ constant rounding mode\n+        init_req_with_vector(pack, vtn, 1);\n+        init_req_with_scalar(p0,   vtn, 2); \/\/ constant rounding mode\n@@ -97,1 +109,1 @@\n-        VTransformBoolVectorNode* vtn_mask_cmp = vtn->in(1)->isa_BoolVector();\n+        VTransformBoolVectorNode* vtn_mask_cmp = vtn->in_req(1)->isa_BoolVector();\n@@ -111,2 +123,2 @@\n-    VTransformScalarNode* vtn = get_vtnode(n)->isa_Scalar();\n-    if (vtn == nullptr) { continue; }\n+    VTransformNode* vtn = get_vtnode(n);\n+    if (vtn->isa_Vector() != nullptr) { continue; }\n@@ -116,1 +128,1 @@\n-      set_req_with_scalar(n, vtn, MemNode::Address);\n+      init_req_with_scalar(n, vtn, MemNode::Address);\n@@ -119,2 +131,2 @@\n-      set_req_with_scalar(n, vtn, MemNode::Address);\n-      set_req_with_scalar(n, vtn, MemNode::ValueIn);\n+      init_req_with_scalar(n, vtn, MemNode::Address);\n+      init_req_with_scalar(n, vtn, MemNode::ValueIn);\n@@ -127,1 +139,1 @@\n-      set_req_with_scalar(n, vtn, 0);\n+      init_req_with_scalar(n, vtn, 0);\n@@ -180,3 +192,3 @@\n-void SuperWordVTransformBuilder::set_req_with_scalar(Node* n, VTransformNode* vtn, const int index) {\n-  VTransformNode* req = get_vtnode_or_wrap_as_input_scalar(n->in(index));\n-  vtn->set_req(index, req);\n+void SuperWordVTransformBuilder::init_req_with_scalar(Node* n, VTransformNode* vtn, const int index) {\n+  VTransformNode* req = get_vtnode_or_wrap_as_outer(n->in(index));\n+  vtn->init_req(index, req);\n@@ -213,1 +225,1 @@\n-    VTransformNode* iv_vtn = get_vtnode_or_wrap_as_input_scalar(_vloop.iv());\n+    VTransformNode* iv_vtn = get_vtnode_or_wrap_as_outer(_vloop.iv());\n@@ -220,1 +232,1 @@\n-    populate_index->set_req(1, iv_vtn);\n+    populate_index->init_req(1, iv_vtn);\n@@ -225,1 +237,1 @@\n-    VTransformNode* same_input_vtn = get_vtnode_or_wrap_as_input_scalar(same_input);\n+    VTransformNode* same_input_vtn = get_vtnode_or_wrap_as_outer(same_input);\n@@ -233,1 +245,1 @@\n-      shift_count->set_req(1, same_input_vtn);\n+      shift_count->init_req(1, same_input_vtn);\n@@ -248,1 +260,1 @@\n-        conv->set_req(1, same_input_vtn);\n+        conv->init_req(1, same_input_vtn);\n@@ -252,1 +264,1 @@\n-      replicate->set_req(1, same_input_vtn);\n+      replicate->init_req(1, same_input_vtn);\n@@ -267,1 +279,1 @@\n-VTransformNode* SuperWordVTransformBuilder::get_vtnode_or_wrap_as_input_scalar(Node* n) {\n+VTransformNode* SuperWordVTransformBuilder::get_vtnode_or_wrap_as_outer(Node* n) {\n@@ -272,1 +284,1 @@\n-  vtn = new (_vtransform.arena()) VTransformInputScalarNode(_vtransform, n);\n+  vtn = new (_vtransform.arena()) VTransformOuterNode(_vtransform, n);\n@@ -277,1 +289,1 @@\n-void SuperWordVTransformBuilder::set_req_with_vector(const Node_List* pack, VTransformNode* vtn, int j) {\n+void SuperWordVTransformBuilder::init_req_with_vector(const Node_List* pack, VTransformNode* vtn, int j) {\n@@ -279,1 +291,1 @@\n-  vtn->set_req(j, req);\n+  vtn->init_req(j, req);\n@@ -287,1 +299,1 @@\n-    set_req_with_scalar(n, vtn, j);\n+    init_req_with_scalar(n, vtn, j);\n@@ -298,1 +310,1 @@\n-    set_req_with_vector(pack, vtn, j);\n+    init_req_with_vector(pack, vtn, j);\n@@ -302,1 +314,4 @@\n-void SuperWordVTransformBuilder::add_memory_dependencies_of_node_to_vtnode(Node*n, VTransformNode* vtn, VectorSet& vtn_memory_dependencies) {\n+void SuperWordVTransformBuilder::add_memory_dependencies_of_node_to_vtnode(Node* n, VTransformNode* vtn, VectorSet& vtn_memory_dependencies) {\n+  \/\/ If we cannot speculate, then all dependencies must be strong edges, i.e. scheduling must respect them.\n+  bool are_speculative_checks_possible = _vloop.are_speculative_checks_possible();\n+\n@@ -307,0 +322,1 @@\n+    assert(n->is_Mem() && pred->is_Mem(), \"only memory edges\");\n@@ -312,2 +328,5 @@\n-    assert(n->is_Mem() && pred->is_Mem(), \"only memory edges\");\n-    vtn->add_memory_dependency(dependency); \/\/ Add every dependency only once per vtn.\n+    if (are_speculative_checks_possible && preds.is_current_weak_memory_edge()) {\n+      vtn->add_weak_memory_edge(dependency);\n+    } else {\n+      vtn->add_strong_memory_edge(dependency);\n+    }\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.cpp","additions":54,"deletions":35,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -79,3 +79,3 @@\n-  VTransformNode* get_vtnode_or_wrap_as_input_scalar(Node* n);\n-  void set_req_with_scalar(Node* n, VTransformNode* vtn, const int index);\n-  void set_req_with_vector(const Node_List* pack, VTransformNode* vtn, const int index);\n+  VTransformNode* get_vtnode_or_wrap_as_outer(Node* n);\n+  void init_req_with_scalar(Node* n, VTransformNode* vtn, const int index);\n+  void init_req_with_vector(const Node_List* pack, VTransformNode* vtn, const int index);\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  flags(SPECULATIVE_ALIASING_ANALYSIS, \"Trace Speculative Aliasing Analysis\") \\\n","filename":"src\/hotspot\/share\/opto\/traceAutoVectorizationTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"opto\/castnode.hpp\"\n@@ -28,0 +29,2 @@\n+#include \"opto\/divnode.hpp\"\n+#include \"opto\/movenode.hpp\"\n@@ -29,0 +32,2 @@\n+#include \"opto\/noOverflowInt.hpp\"\n+#include \"opto\/phaseX.hpp\"\n@@ -260,0 +265,3 @@\n+\/\/    - Strong edge: must be respected.\n+\/\/    - Weak edge:   if we add a speculative aliasing check, we can violate\n+\/\/                   the edge, i.e. spaw the order.\n@@ -266,1 +274,2 @@\n-  GrowableArray<int> memory_pred_edges;\n+  GrowableArray<int> strong_memory_edges;\n+  GrowableArray<int> weak_memory_edges;\n@@ -278,1 +287,2 @@\n-      memory_pred_edges.clear();\n+      strong_memory_edges.clear();\n+      weak_memory_edges.clear();\n@@ -289,0 +299,2 @@\n+\n+        \/\/ If we can prove that they will never overlap -> drop edge.\n@@ -290,2 +302,5 @@\n-          \/\/ Possibly overlapping memory\n-          memory_pred_edges.append(_body.bb_idx(n2));\n+          if (p1.can_make_speculative_aliasing_check_with(p2)) {\n+            weak_memory_edges.append(_body.bb_idx(n2));\n+          } else {\n+            strong_memory_edges.append(_body.bb_idx(n2));\n+          }\n@@ -294,1 +309,1 @@\n-      if (memory_pred_edges.is_nonempty()) {\n+      if (strong_memory_edges.is_nonempty() || weak_memory_edges.is_nonempty()) {\n@@ -297,1 +312,1 @@\n-        add_node(n1, memory_pred_edges);\n+        add_node(n1, strong_memory_edges, weak_memory_edges);\n@@ -308,1 +323,1 @@\n-void VLoopDependencyGraph::add_node(MemNode* n, GrowableArray<int>& memory_pred_edges) {\n+void VLoopDependencyGraph::add_node(MemNode* n, GrowableArray<int>& strong_memory_edges, GrowableArray<int>& weak_memory_edges) {\n@@ -310,2 +325,1 @@\n-  assert(!memory_pred_edges.is_empty(), \"no need to create a node without edges\");\n-  DependencyNode* dn = new (_arena) DependencyNode(n, memory_pred_edges, _arena);\n+  DependencyNode* dn = new (_arena) DependencyNode(n, strong_memory_edges, weak_memory_edges, _arena);\n@@ -318,0 +332,3 @@\n+    \/\/ We must compute the dependence graph depth with all edges (including the weak edges), so that\n+    \/\/ the independence queries work correctly, no matter if we check independence with or without\n+    \/\/ weak edges.\n@@ -361,2 +378,7 @@\n-      for (uint j = 0; j < dn->memory_pred_edges_length(); j++) {\n-        Node* pred = _body.body().at(dn->memory_pred_edge(j));\n+      for (uint j = 0; j < dn->num_strong_memory_edges(); j++) {\n+        Node* pred = _body.body().at(dn->strong_memory_edge(j));\n+        tty->print(\"  %d %s\", pred->_idx, pred->Name());\n+      }\n+      tty->print(\" | weak:\");\n+      for (uint j = 0; j < dn->num_weak_memory_edges(); j++) {\n+        Node* pred = _body.body().at(dn->weak_memory_edge(j));\n@@ -370,1 +392,7 @@\n-  tty->print_cr(\" Complete dependency graph:\");\n+  \/\/ If we cannot speculate (aliasing analysis runtime checks), we need to respect all edges.\n+  bool with_weak_memory_edges = !_vloop.use_speculative_aliasing_checks();\n+  if (with_weak_memory_edges) {\n+    tty->print_cr(\" Complete dependency graph (with weak edges, because we cannot speculate):\");\n+  } else {\n+    tty->print_cr(\" Dependency graph without weak edges (because we can speculate):\");\n+  }\n@@ -375,0 +403,1 @@\n+      if (!with_weak_memory_edges && it.is_current_weak_memory_edge()) { continue; }\n@@ -384,1 +413,2 @@\n-                                                     GrowableArray<int>& memory_pred_edges,\n+                                                     GrowableArray<int>& strong_memory_edges,\n+                                                     GrowableArray<int>& weak_memory_edges,\n@@ -387,2 +417,3 @@\n-    _memory_pred_edges_length(memory_pred_edges.length()),\n-    _memory_pred_edges(nullptr)\n+    _num_strong_memory_edges(strong_memory_edges.length()),\n+    _num_weak_memory_edges(weak_memory_edges.length()),\n+    _memory_edges(nullptr)\n@@ -390,4 +421,11 @@\n-  assert(memory_pred_edges.is_nonempty(), \"not empty\");\n-  uint bytes = memory_pred_edges.length() * sizeof(int);\n-  _memory_pred_edges = (int*)arena->Amalloc(bytes);\n-  memcpy(_memory_pred_edges, memory_pred_edges.adr_at(0), bytes);\n+  assert(strong_memory_edges.is_nonempty() || weak_memory_edges.is_nonempty(), \"only generate DependencyNode if there are pred edges\");\n+  uint bytes_strong = strong_memory_edges.length() * sizeof(int);\n+  uint bytes_weak = weak_memory_edges.length() * sizeof(int);\n+  uint bytes_total = bytes_strong + bytes_weak;\n+  _memory_edges = (int*)arena->Amalloc(bytes_total);\n+  if (strong_memory_edges.length() > 0) {\n+    memcpy(_memory_edges, strong_memory_edges.adr_at(0), bytes_strong);\n+  }\n+  if (weak_memory_edges.length() > 0) {\n+    memcpy(_memory_edges + strong_memory_edges.length(), weak_memory_edges.adr_at(0), bytes_weak);\n+  }\n@@ -403,4 +441,7 @@\n-    _next_pred(0),\n-    _end_pred(node->req()),\n-    _next_memory_pred(0),\n-    _end_memory_pred((_dependency_node != nullptr) ? _dependency_node->memory_pred_edges_length() : 0)\n+    _is_current_weak_memory_edge(false),\n+    _next_data_edge(0),\n+    _end_data_edge(node->req()),\n+    _next_strong_memory_edge(0),\n+    _end_strong_memory_edge((_dependency_node != nullptr) ? _dependency_node->num_strong_memory_edges() : 0),\n+    _next_weak_memory_edge(0),\n+    _end_weak_memory_edge((_dependency_node != nullptr) ? _dependency_node->num_weak_memory_edges() : 0)\n@@ -409,3 +450,5 @@\n-    \/\/ Load: address\n-    \/\/ Store: address, value\n-    _next_pred = MemNode::Address;\n+    \/\/ Ignore ctrl and memory, only address and value are data dependencies.\n+    \/\/ Memory edges are already covered by the strong and weak memory edges.\n+    \/\/ Load:  [ctrl, memory] address\n+    \/\/ Store: [ctrl, memory] address, value\n+    _next_data_edge = MemNode::Address;\n@@ -414,1 +457,1 @@\n-    _next_pred = 1; \/\/ skip control\n+    _next_data_edge = 1; \/\/ skip control\n@@ -420,2 +463,2 @@\n-  if (_next_pred < _end_pred) {\n-    _current = _node->in(_next_pred++);\n+  if (_next_data_edge < _end_data_edge) {\n+    _current = _node->in(_next_data_edge++);\n@@ -423,2 +466,8 @@\n-  } else if (_next_memory_pred < _end_memory_pred) {\n-    int pred_bb_idx = _dependency_node->memory_pred_edge(_next_memory_pred++);\n+    _is_current_weak_memory_edge = false;\n+  } else if (_next_strong_memory_edge < _end_strong_memory_edge) {\n+    int pred_bb_idx = _dependency_node->strong_memory_edge(_next_strong_memory_edge++);\n+    _current = _dependency_graph._body.body().at(pred_bb_idx);\n+    _is_current_memory_edge = true;\n+    _is_current_weak_memory_edge = false;\n+  } else if (_next_weak_memory_edge < _end_weak_memory_edge) {\n+    int pred_bb_idx = _dependency_node->weak_memory_edge(_next_weak_memory_edge++);\n@@ -427,0 +476,1 @@\n+    _is_current_weak_memory_edge = true;\n@@ -430,0 +480,591 @@\n+    _is_current_weak_memory_edge = false;\n+  }\n+}\n+\n+\/\/ Computing aliasing runtime check using init and last of main-loop\n+\/\/ -----------------------------------------------------------------\n+\/\/\n+\/\/ We have two VPointer vp1 and vp2, and would like to create a runtime check that\n+\/\/ guarantees that the corresponding pointers p1 and p2 do not overlap (alias) for\n+\/\/ any iv value in the strided range r = [init, init + iv_stride, .. limit).\n+\/\/ Remember that vp1 and vp2 both represent a region in memory, starting at a\n+\/\/ \"pointer\", and extending for \"size\" bytes:\n+\/\/\n+\/\/   vp1(iv) = [p1(iv), size1)\n+\/\/   vp2(iv) = [p2(iv), size2)\n+\/\/\n+\/\/       |---size1--->           |-------size2------->\n+\/\/       |                       |\n+\/\/     p1(iv)                  p2(iv)\n+\/\/\n+\/\/ In each iv value (intuitively: for each iteration), we check that there is no\n+\/\/ overlap:\n+\/\/\n+\/\/   for all iv in r: p1(iv) + size1 <= p2(iv) OR p2(iv) + size2 <= p1(iv)\n+\/\/\n+\/\/ This would allow situations where for some iv p1 is lower than p2, and for\n+\/\/ other iv p1 is higher than p2. This is not very useful in practice. We can\n+\/\/ strengthen the condition, which will make the check simpler later:\n+\/\/\n+\/\/   for all iv in r: p1(iv) + size1 <= p2(iv)                    (P1-BEFORE-P2)\n+\/\/   OR\n+\/\/   for all iv in r: p2(iv) + size2 <= p1(iv)                    (P1-AFTER-P2)\n+\/\/\n+\/\/ Note: apart from this strengthening, the checks we derive below are byte accurate,\n+\/\/       i.e. they are equivalent to the conditions above. This means we have NO case\n+\/\/       where:\n+\/\/       1) The check passes (predicts no overlap) but the pointers do actually overlap.\n+\/\/          This would be bad because we would wrongly vectorize, possibly leading to\n+\/\/          wrong results.\n+\/\/       2) The check does not pass (predicts overlap) but the pointers do not overlap.\n+\/\/          This would be suboptimal, as we would not be able to vectorize, and either\n+\/\/          trap (with predicate), or go into the slow-loop (with multiversioning).\n+\/\/\n+\/\/\n+\/\/ We apply the \"MemPointer Linearity Corrolary\" to VPointer vp and the corresponding\n+\/\/ pointer p:\n+\/\/   (C0) is given by the construction of VPointer vp, which simply wraps a MemPointer mp.\n+\/\/   (c1) with v = iv and scale_v = iv_scale\n+\/\/   (C2) with r = [init, init + iv_stride, .. last - stride_v, last], which is the set\n+\/\/        of possible iv values in the loop, with \"init\" the first iv value, and \"last\"\n+\/\/        the last iv value which is closest to limit.\n+\/\/        Note: iv_stride > 0  ->  limit - iv_stride <= last < limit\n+\/\/              iv_stride < 0  ->  limit < last <= limit - iv_stride\n+\/\/        We have to be a little careful, and cannot just use \"limit\" instead of \"last\" as\n+\/\/        the last value in r, because the iv never reaches limit in the main-loop, and\n+\/\/        so we are not sure if the memory access at p(limit) is still in bounds.\n+\/\/        For now, we just assume that we can compute init and limit, and we will derive\n+\/\/        the computation of these values later on.\n+\/\/   (C3) the memory accesses for every iv value in the loop must be in bounds, otherwise\n+\/\/        the program has undefined behaviour already.\n+\/\/   (C4) abs(iv_scale * iv_stride) < 2^31 is given by the checks in\n+\/\/        VPointer::init_are_scale_and_stride_not_too_large.\n+\/\/\n+\/\/ Hence, it follows that we can see p and vp as linear functions of iv in r, i.e. for\n+\/\/ all iv values in the loop:\n+\/\/   p(iv)  = p(init)  - init * iv_scale + iv * iv_scale\n+\/\/   vp(iv) = vp(init) - init * iv_scale + iv * iv_scale\n+\/\/\n+\/\/ Hence, p1 and p2 have the linear form:\n+\/\/   p1(iv)  = p1(init) - init * iv_scale1 + iv * iv_scale1             (LINEAR-FORM-INIT)\n+\/\/   p2(iv)  = p2(init) - init * iv_scale2 + iv * iv_scale2\n+\/\/\n+\/\/ With the (Alternative Corrolary P) we get the alternative linar form:\n+\/\/   p1(iv)  = p1(last) - last * iv_scale1 + iv * iv_scale1             (LINEAR-FORM-LAST)\n+\/\/   p2(iv)  = p2(last) - last * iv_scale2 + iv * iv_scale2\n+\/\/\n+\/\/\n+\/\/ We can now use this linearity to construct aliasing runtime checks, depending on the\n+\/\/ different \"geometry\" of the two VPointer over their iv, i.e. the \"slopes\" of the linear\n+\/\/ functions. In the following graphs, the x-axis denotes the values of iv, from init to\n+\/\/ last. And the y-axis denotes the pointer position p(iv). Intuitively, this problem\n+\/\/ can be seen as having two bands that should not overlap.\n+\/\/\n+\/\/       Case 1                     Case 2                     Case 3\n+\/\/       parallel lines             same sign slope            different sign slope\n+\/\/                                  but not parallel\n+\/\/\n+\/\/       +---------+                +---------+                +---------+\n+\/\/       |         |                |        #|                |#        |\n+\/\/       |         |                |       # |                |  #      |\n+\/\/       |        #|                |      #  |                |    #    |\n+\/\/       |      #  |                |     #   |                |      #  |\n+\/\/       |    #    |                |    #    |                |        #|\n+\/\/       |  # ^    |                |   #     |                |        ^|\n+\/\/       |#   |   #|                |  #      |                |        ||\n+\/\/       |    v #  |                | #       |                |        v|\n+\/\/       |    #    |                |#       #|                |        #|\n+\/\/       |  #      |                |^     #  |                |      #  |\n+\/\/       |#        |                ||   #    |                |    #    |\n+\/\/       |         |                |v #      |                |  #      |\n+\/\/       |         |                |#        |                |#        |\n+\/\/       +---------+                +---------+                +---------+\n+\/\/\n+\/\/\n+\/\/ Case 1: parallel lines, i.e. iv_scale = iv_scale1 = iv_scale2\n+\/\/\n+\/\/   p1(iv)  = p1(init)  - init * iv_scale + iv * iv_scale\n+\/\/   p2(iv)  = p2(init)  - init * iv_scale + iv * iv_scale\n+\/\/\n+\/\/   Given this, it follows:\n+\/\/     p1(iv) + size1 <= p2(iv)      <==>      p1(init) + size1 <= p2(init)\n+\/\/     p2(iv) + size2 <= p1(iv)      <==>      p2(init) + size2 <= p1(init)\n+\/\/\n+\/\/   Hence, we do not have to check the condition for every iv, but only for init.\n+\/\/\n+\/\/   p1(init) + size1 <= p2(init)  OR  p2(init) + size2 <= p1(init)\n+\/\/   ----- is equivalent to -----      ---- is equivalent to ------\n+\/\/          (P1-BEFORE-P2)         OR         (P1-AFTER-P2)\n+\/\/\n+\/\/\n+\/\/ Case 2 and 3: different slopes, i.e. iv_scale1 != iv_scale2\n+\/\/\n+\/\/   Without loss of generality, we assume iv_scale1 < iv_scale2.\n+\/\/   (Otherwise, we just swap p1 and p2).\n+\/\/\n+\/\/   If iv_stride >= 0, i.e. init <= iv <= last:\n+\/\/     (iv - init) * iv_scale1 <= (iv - init) * iv_scale2\n+\/\/     (iv - last) * iv_scale1 >= (iv - last) * iv_scale2                 (POS-STRIDE)\n+\/\/   If iv_stride <= 0, i.e. last <= iv <= init:\n+\/\/     (iv - init) * iv_scale1 >= (iv - init) * iv_scale2\n+\/\/     (iv - last) * iv_scale1 <= (iv - last) * iv_scale2                 (NEG-STRIDE)\n+\/\/\n+\/\/   Below, we show that these conditions are equivalent:\n+\/\/\n+\/\/       p1(init) + size1 <= p2(init)       (if iv_stride >= 0)  |    p2(last) + size2 <= p1(last)      (if iv_stride >= 0)   |\n+\/\/       p1(last) + size1 <= p2(last)       (if iv_stride <= 0)  |    p2(init) + size2 <= p1(init)      (if iv_stride <= 0)   |\n+\/\/       ---- are equivalent to -----                            |    ---- are equivalent to -----                            |\n+\/\/              (P1-BEFORE-P2)                                   |           (P1-AFTER-P2)                                    |\n+\/\/                                                               |                                                            |\n+\/\/   Proof:                                                      |                                                            |\n+\/\/                                                               |                                                            |\n+\/\/     Assume: (P1-BEFORE-P2)                                    |  Assume: (P1-AFTER-P2)                                     |\n+\/\/       for all iv in r: p1(iv) + size1 <= p2(iv)               |    for all iv in r: p2(iv) + size2 <= p1(iv)               |\n+\/\/       => And since init and last in r =>                      |    => And since init and last in r =>                      |\n+\/\/       p1(init) + size1 <= p2(init)                            |    p2(init) + size2 <= p1(init)                            |\n+\/\/       p1(last) + size1 <= p2(last)                            |    p2(last) + size2 <= p1(last)                            |\n+\/\/                                                               |                                                            |\n+\/\/                                                               |                                                            |\n+\/\/     Assume: p1(init) + size1 <= p2(init)                      |  Assume: p2(last) + size2 <= p1(last)                      |\n+\/\/        and: iv_stride >= 0                                    |     and: iv_stride >= 0                                    |\n+\/\/                                                               |                                                            |\n+\/\/          size1 + p1(iv)                                       |       size2 + p2(iv)                                       |\n+\/\/                  --------- apply (LINEAR-FORM-INIT) --------- |               --------- apply (LINEAR-FORM-LAST) --------- |\n+\/\/        = size1 + p1(init) - init * iv_scale1 + iv * iv_scale1 |     = size2 + p2(last) - last * iv_scale2 + iv * iv_scale2 |\n+\/\/                           ------ apply (POS-STRIDE) --------- |                        ------ apply (POS-STRIDE) --------- |\n+\/\/       <= size1 + p1(init) - init * iv_scale2 + iv * iv_scale2 |    <= size2 + p2(last) - last * iv_scale1 + iv * iv_scale1 |\n+\/\/          -- assumption --                                     |       -- assumption --                                     |\n+\/\/       <=         p2(init) - init * iv_scale2 + iv * iv_scale2 |    <=         p1(last) - last * iv_scale1 + iv * iv_scale1 |\n+\/\/                  --------- apply (LINEAR-FORM-INIT) --------- |               --------- apply (LINEAR-FORM-LAST) --------- |\n+\/\/        =         p2(iv)                                       |     =         p1(iv)                                       |\n+\/\/                                                               |                                                            |\n+\/\/                                                               |                                                            |\n+\/\/     Assume: p1(last) + size1 <= p2(last)                      |  Assume: p2(init) + size2 <= p1(init)                      |\n+\/\/        and: iv_stride <= 0                                    |     and: iv_stride <= 0                                    |\n+\/\/                                                               |                                                            |\n+\/\/          size1 + p1(iv)                                       |       size2 + p2(iv)                                       |\n+\/\/                  --------- apply (LINEAR-FORM-LAST) --------- |               --------- apply (LINEAR-FORM-INIT) --------- |\n+\/\/        = size1 + p1(last) - last * iv_scale1 + iv * iv_scale1 |     = size2 + p2(init) - init * iv_scale2 + iv * iv_scale2 |\n+\/\/                           ------ apply (NEG-STRIDE) --------- |                        ------ apply (NEG-STRIDE) --------- |\n+\/\/       <= size1 + p1(last) - last * iv_scale2 + iv * iv_scale2 |    <= size2 + p2(init) - init * iv_scale1 + iv * iv_scale1 |\n+\/\/          -- assumption --                                     |       -- assumption --                                     |\n+\/\/       <=         p2(last) - last * iv_scale2 + iv * iv_scale2 |    <=         p1(init) - init * iv_scale1 + iv * iv_scale1 |\n+\/\/                  --------- apply (LINEAR-FORM-LAST) --------- |               --------- apply (LINEAR-FORM-INIT) --------- |\n+\/\/        =         p2(iv)                                       |     =         p1(iv)                                       |\n+\/\/                                                               |                                                            |\n+\/\/\n+\/\/   The obtained conditions already look very simple. However, we would like to avoid\n+\/\/   computing 4 addresses (p1(init), p1(last), p2(init), p2(last)), and would instead\n+\/\/   prefer to only compute 2 addresses, and derive the other two from the distance (span)\n+\/\/   between the pointers at init and last. Using (LINEAR-FORM-INIT), we get:\n+\/\/\n+\/\/     p1(last) = p1(init) - init * iv_scale1 + last * iv_scale1                 (SPAN-1)\n+\/\/                         --------------- defines -------------\n+\/\/                p1(init) + span1\n+\/\/\n+\/\/     p2(last) = p2(init) - init * iv_scale2 + last * iv_scale2                 (SPAN-2)\n+\/\/                         --------------- defines -------------\n+\/\/                p1(init) + span2\n+\/\/\n+\/\/     span1 = - init * iv_scale1 + last * iv_scale1 = (last - init) * iv_scale1\n+\/\/     span2 = - init * iv_scale2 + last * iv_scale2 = (last - init) * iv_scale2\n+\/\/\n+\/\/   Thus, we can use the conditions below:\n+\/\/     p1(init)         + size1 <= p2(init)          OR  p2(init) + span2 + size2 <= p1(init) + span1    (if iv_stride >= 0)\n+\/\/     p1(init) + span1 + size1 <= p2(init) + span2  OR  p2(init)         + size2 <= p1(init)            (if iv_stride <= 0)\n+\/\/\n+\/\/   Below, we visualize the conditions, so that the reader can gain an intuitiion.\n+\/\/   For simplicity, we only show the case with iv_stride > 0. Also, remember that\n+\/\/   iv_scale1 < iv_scale2.\n+\/\/\n+\/\/                             +---------+                     +---------+\n+\/\/                             |        #|                     |        #| <-- p1(init) + span1\n+\/\/                             |       # |  ^ span2    span1 ^ |      # ^|\n+\/\/                             |      #  |  |                | |    #   ||\n+\/\/                             |     #   |  |                | |  #     v| <-- p2(init) + span2 + size2\n+\/\/                             |    #    |  |                v |#       #|\n+\/\/                             |   #     |  |          span2 ^ |       # |\n+\/\/                             |  #      |  |                | |      #  |\n+\/\/                             | #       |  |                | |     #   |\n+\/\/        p2(init)         --> |#       #|  v                | |    #    |\n+\/\/                             |^     #  |  ^ span1          | |   #     |\n+\/\/                             ||   #    |  |                | |  #      |\n+\/\/        p1(init) + size1 --> |v #      |  |                | | #       |\n+\/\/                             |#        |  v                v |#        |\n+\/\/                             +---------+                     +---------+\n+\/\/\n+\/\/ -------------------------------------------------------------------------------------------------------------------------\n+\/\/\n+\/\/ Computing the last iv value in a loop\n+\/\/ -------------------------------------\n+\/\/\n+\/\/ Let us define a helper function, that computes the last iv value in a loop,\n+\/\/ given variable init and limit values, and a constant stride. If the loop\n+\/\/ is never entered, we just return the init value.\n+\/\/\n+\/\/   LAST(init, stride, limit), where stride > 0:   |  LAST(init, stride, limit), where stride < 0:\n+\/\/     last = init                                  |  last = init\n+\/\/     for (iv = init; iv < limit; iv += stride)    |  for (iv = init; iv > limit; iv += stride)\n+\/\/       last = iv                                  |    last = iv\n+\/\/\n+\/\/ It follows that for some k:\n+\/\/    last = init + k * stride\n+\/\/\n+\/\/ If the loop is not entered, we can set k=0.\n+\/\/\n+\/\/ If the loop is entered:\n+\/\/   last is very close to limit:\n+\/\/     stride > 0  ->  limit - stride <= last < limit\n+\/\/     stride < 0  ->  limit < last <= limit - stride\n+\/\/\n+\/\/     If stride > 0:\n+\/\/         limit        - stride                   <= last              <   limit\n+\/\/         limit        - stride                   <= init + k * stride <   limit\n+\/\/         limit - init - stride                   <=        k * stride <   limit - init\n+\/\/         limit - init - stride - 1               <         k * stride <=  limit - init - 1\n+\/\/        (limit - init - stride - 1) \/ stride     <         k          <= (limit - init - 1) \/ stride\n+\/\/        (limit - init          - 1) \/ stride - 1 <         k          <= (limit - init - 1) \/ stride\n+\/\/     -> k = (limit - init - 1) \/ stride\n+\/\/     -> dividend \"limit - init - 1\" is >=0. So a regular round to zero division can be used.\n+\/\/        Note: to incorporate the case where the loop is not entered (init >= limit), we see\n+\/\/              that the divident is zero or negative, and so the result will be zero or\n+\/\/              negative. Thus, we can just clamp k to zero, or last to init, so that we get\n+\/\/              a solution that also works when the loop is not entered:\n+\/\/\n+\/\/              k = (limit - init - 1) \/ abs(stride)\n+\/\/              last = MAX(init, init + k * stride)\n+\/\/\n+\/\/     If stride < 0:\n+\/\/         limit                               <  last              <=   limit        - stride\n+\/\/         limit                               <  init + k * stride <=   limit        - stride\n+\/\/         limit - init                        <         k * stride <=   limit - init - stride\n+\/\/         limit - init + 1                    <=        k * stride <    limit - init - stride + 1\n+\/\/        (limit - init + 1) \/     stride      >=        k          >   (limit - init - stride + 1) \/     stride\n+\/\/       -(limit - init + 1) \/ abs(stride)     >=        k          >  -(limit - init - stride + 1) \/ abs(stride)\n+\/\/       -(limit - init + 1) \/ abs(stride)     >=        k          >  -(limit - init          + 1) \/ abs(stride) - 1\n+\/\/        (init - limit - 1) \/ abs(stride)     >=        k          >   (init - limit          - 1) \/ abs(stride) - 1\n+\/\/        (init - limit - 1) \/ abs(stride)     >=        k          >   (init - limit          - 1) \/ abs(stride) - 1\n+\/\/     -> k = (init - limit - 1) \/ abs(stride)\n+\/\/     -> dividend \"init - limit\" is >=0. So a regular round to zero division can be used.\n+\/\/        Note: to incorporate the case where the loop is not entered (init <= limit), we see\n+\/\/              that the divident is zero or negative, and so the result will be zero or\n+\/\/              negative. Thus, we can just clamp k to zero, or last to init, so that we get\n+\/\/              a solution that also works when the loop is not entered:\n+\/\/\n+\/\/              k = (init - limit - 1) \/ abs(stride)\n+\/\/              last = MIN(init, init + k * stride)\n+\/\/\n+\/\/ Now we can put it all together:\n+\/\/   LAST(init, stride, limit)\n+\/\/     If stride > 0:\n+\/\/       k = (limit - init - 1) \/ abs(stride)\n+\/\/       last = MAX(init, init + k * stride)\n+\/\/     If stride < 0:\n+\/\/       k = (init - limit - 1) \/ abs(stride)\n+\/\/       last = MIN(init, init + k * stride)\n+\/\/\n+\/\/ We will have to consider the implications of clamping to init when the loop is not entered\n+\/\/ at the use of LAST further down.\n+\/\/\n+\/\/ -------------------------------------------------------------------------------------------------------------------------\n+\/\/\n+\/\/ Computing init and last for the main-loop\n+\/\/ -----------------------------------------\n+\/\/\n+\/\/ As we have seen above, we always need the \"init\" of the main-loop. And if \"iv_scale1 != iv_scale2\", then we\n+\/\/ also need the \"last\" of the main-loop. These values need to be pre-loop invariant, because the check is\n+\/\/ to be performed before the pre-loop (at the predicate or multiversioning selector_if). It will be helpful\n+\/\/ to recall the iv structure in the pre and main-loop:\n+\/\/\n+\/\/                  | iv = pre_init\n+\/\/                  |\n+\/\/   Pre-Loop       | +----------------+\n+\/\/                  phi                |\n+\/\/                   |                 |  -> pre_last: last iv value in pre-loop\n+\/\/                   + pre_iv_stride   |\n+\/\/                   |-----------------+\n+\/\/                   | exit check: < pre_limit\n+\/\/                   |\n+\/\/                   | iv = main_init = init\n+\/\/                   |\n+\/\/   Main-Loop       | +------------------------------+\n+\/\/                   phi                              |\n+\/\/                    |                               | -> last: last iv value in main-loop\n+\/\/                    + main_iv_stride = iv_stride    |\n+\/\/                    |-------------------------------+\n+\/\/                    | exit check: < main_limit = limit\n+\/\/\n+\/\/ Unfortunately, the init (aka. main_init) is not pre-loop invariant, rather it is only available\n+\/\/ after the pre-loop. We will have to compute:\n+\/\/\n+\/\/   pre_last = LAST(pre_init, pre_iv_stride, pre_limit)\n+\/\/   init = pre_last + pre_iv_stride\n+\/\/\n+\/\/ If we need \"last\", we unfortunately must compute it as well:\n+\/\/\n+\/\/   last = LAST(init, iv_stride, limit)\n+\/\/\n+\/\/\n+\/\/ These computations assume that we indeed do enter the main-loop - otherwise\n+\/\/ it does not make sense to talk about the \"last main iteration\". Of course\n+\/\/ entering the main-loop implies that we entered the pre-loop already. But\n+\/\/ what happens if we check the aliasing runtime check, but later would never\n+\/\/ enter the main-loop?\n+\/\/\n+\/\/ First: no matter if we pass or fail the aliasing runtime check, we will\n+\/\/ not get wrong results. If we fail the check, we end up in the less optimized\n+\/\/ slow-loop. If we pass the check, and we don't enter the main-loop, we\n+\/\/ never rely on the aliasing check, after all only the vectorized main-loop\n+\/\/ (and the vectorized post-loop) rely on the aliasing check.\n+\/\/\n+\/\/ But: The worry is that we may fail the aliasing runtime check \"spuriously\",\n+\/\/ i.e. even though we would never enter the main-loop, and that this could have\n+\/\/ unfortunate side-effects (for example deopting unnecessarily). Let's\n+\/\/ look at the two possible cases:\n+\/\/  1) We would never even enter the pre-loop.\n+\/\/     There are only predicates between the aliasing runtime check and the pre-loop,\n+\/\/     so a predicate would have to fail. These are rather rare cases. If we\n+\/\/     are using multiversioning for the aliasing runtime check, we would\n+\/\/     immediately fail the predicate in either the slow or fast loop, so\n+\/\/     the decision of the aliasing runtime check does not matter. But if\n+\/\/     we are using a predicate for the aliaing runtime check, then we may\n+\/\/     end up deopting twice: once for the aliasing runtime check, and then\n+\/\/     again for the other predicate. This would not be great, but again,\n+\/\/     failing predicates are rare in the first place.\n+\/\/\n+\/\/  2) We would enter the pre-loop, but not the main-loop.\n+\/\/     The pre_last must be accurate, because we are entering the pre-loop.\n+\/\/     But then we fail the zero-trip guard of the main-loop. Thus, for the\n+\/\/     main-loop, the init lies \"after\" the limit. Thus, the computed last\n+\/\/     for the main-loop equals the init. This means that span1 and span2\n+\/\/     are zero. Hence, p1(init) and p2(init) would have to alias for the\n+\/\/     aliasing runtime check to fail. Hence, it would not be surprising\n+\/\/     at all if we deopted because of the aliasing runtime check.\n+\/\/\n+bool VPointer::can_make_speculative_aliasing_check_with(const VPointer& other) const {\n+  const VPointer& vp1 = *this;\n+  const VPointer& vp2 = other;\n+\n+  if (!_vloop.use_speculative_aliasing_checks()) { return false; }\n+\n+  \/\/ Both pointers need a nice linear form, otherwise we cannot formulate the check.\n+  if (!vp1.is_valid() || !vp2.is_valid()) { return false; }\n+\n+  \/\/ The pointers always overlap -> a speculative check would always fail.\n+  if (vp1.always_overlaps_with(vp2)) { return false; }\n+\n+  \/\/ The pointers never overlap -> a speculative check would always succeed.\n+  assert(!vp1.never_overlaps_with(vp2), \"ensured by caller\");\n+\n+  \/\/ The speculative aliasing check happens either at the AutoVectorization predicate\n+  \/\/ or at the multiversion_if. That is before the pre-loop. From the construction of\n+  \/\/ VPointer, we already know that all its variables (except iv) are pre-loop invariant.\n+  \/\/\n+  \/\/ For the computation of main_init, we also need the pre_limit, and so we need\n+  \/\/ to check that this value is pre-loop invariant. In the case of non-equal iv_scales,\n+  \/\/ we also need the main_limit in the aliasing check, and so this value must then\n+  \/\/ also be pre-loop invariant.\n+  Opaque1Node* pre_limit_opaq = _vloop.pre_loop_end()->limit()->as_Opaque1();\n+  Node* pre_limit = pre_limit_opaq->in(1);\n+  Node* main_limit = _vloop.cl()->limit();\n+\n+  if (!_vloop.is_pre_loop_invariant(pre_limit)) {\n+#ifdef ASSERT\n+    if (_vloop.is_trace_speculative_aliasing_analysis()) {\n+      tty->print_cr(\"VPointer::can_make_speculative_aliasing_check_with: pre_limit is not pre-loop independent!\");\n+    }\n+#endif\n+    return false;\n+  }\n+\n+  if (vp1.iv_scale() != vp2.iv_scale() && !_vloop.is_pre_loop_invariant(main_limit)) {\n+#ifdef ASSERT\n+    if (_vloop.is_trace_speculative_aliasing_analysis()) {\n+      tty->print_cr(\"VPointer::can_make_speculative_aliasing_check_with: main_limit is not pre-loop independent!\");\n+    }\n+#endif\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+\/\/ For description and derivation see \"Computing the last iv value in a loop\".\n+\/\/ Note: the iv computations here should not overflow. But out of an abundance\n+\/\/       of caution, we compute everything in long anyway.\n+Node* make_last(Node* initL, jint stride, Node* limitL, PhaseIdealLoop* phase) {\n+  PhaseIterGVN& igvn = phase->igvn();\n+\n+  Node* abs_strideL = igvn.longcon(abs(stride));\n+  Node* strideL = igvn.longcon(stride);\n+\n+  \/\/ If in some rare case the limit is \"before\" init, then\n+  \/\/ this subtraction could overflow. Doing the calculations\n+  \/\/ in long prevents this. Below, we clamp the \"last\" value\n+  \/\/ back to init, which gets us back into the safe int range.\n+  Node* diffL = (stride > 0) ? new SubLNode(limitL, initL)\n+                             : new SubLNode(initL, limitL);\n+  Node* diffL_m1 = new AddLNode(diffL, igvn.longcon(-1));\n+  Node* k = new DivLNode(nullptr, diffL_m1, abs_strideL);\n+\n+  \/\/ Compute last = init + k * iv_stride\n+  Node* k_mul_stride = new MulLNode(k, strideL);\n+  Node* last = new AddLNode(initL, k_mul_stride);\n+\n+  \/\/ Make sure that the last does not lie \"before\" init.\n+  Node* last_clamped = MaxNode::build_min_max_long(&igvn, initL, last, stride > 0);\n+\n+  phase->register_new_node_with_ctrl_of(diffL,        initL);\n+  phase->register_new_node_with_ctrl_of(diffL_m1,     initL);\n+  phase->register_new_node_with_ctrl_of(k,            initL);\n+  phase->register_new_node_with_ctrl_of(k_mul_stride, initL);\n+  phase->register_new_node_with_ctrl_of(last,         initL);\n+  phase->register_new_node_with_ctrl_of(last_clamped, initL);\n+\n+  return last_clamped;\n+}\n+\n+BoolNode* make_a_plus_b_leq_c(Node* a, Node* b, Node* c, PhaseIdealLoop* phase) {\n+  Node* a_plus_b = new AddLNode(a, b);\n+  Node* cmp = CmpNode::make(a_plus_b, c, T_LONG, true);\n+  BoolNode* bol = new BoolNode(cmp, BoolTest::le);\n+  phase->register_new_node_with_ctrl_of(a_plus_b, a);\n+  phase->register_new_node_with_ctrl_of(cmp, a);\n+  phase->register_new_node_with_ctrl_of(bol, a);\n+  return bol;\n+}\n+\n+BoolNode* VPointer::make_speculative_aliasing_check_with(const VPointer& other) const {\n+  \/\/ Ensure iv_scale1 <= iv_scale2.\n+  const VPointer& vp1 = (this->iv_scale() <= other.iv_scale()) ? *this : other;\n+  const VPointer& vp2 = (this->iv_scale() <= other.iv_scale()) ? other :*this ;\n+  assert(vp1.iv_scale() <= vp2.iv_scale(), \"ensured by swapping if necessary\");\n+\n+  assert(vp1.can_make_speculative_aliasing_check_with(vp2), \"sanity\");\n+\n+  PhaseIdealLoop* phase = _vloop.phase();\n+  PhaseIterGVN& igvn = phase->igvn();\n+\n+  \/\/ init (aka main_init): compute it from the the pre-loop structure.\n+  \/\/ As described above, we cannot just take the _vloop.cl().init_trip(), because that\n+  \/\/ value is pre-loop dependent, and we need a pre-loop independent value, so we can\n+  \/\/ have it available at the predicate \/ multiversioning selector_if.\n+  \/\/ For this, we need to be sure that the pre_limit is pre-loop independent as well,\n+  \/\/ see can_make_speculative_aliasing_check_with.\n+  Node* pre_init = _vloop.pre_loop_end()->init_trip();\n+  jint pre_iv_stride = _vloop.pre_loop_end()->stride_con();\n+  Opaque1Node* pre_limit_opaq = _vloop.pre_loop_end()->limit()->as_Opaque1();\n+  Node* pre_limit = pre_limit_opaq->in(1);\n+  assert(_vloop.is_pre_loop_invariant(pre_init),  \"needed for aliasing check before pre-loop\");\n+  assert(_vloop.is_pre_loop_invariant(pre_limit), \"needed for aliasing check before pre-loop\");\n+\n+  Node* pre_initL = new ConvI2LNode(pre_init);\n+  Node* pre_limitL = new ConvI2LNode(pre_limit);\n+  phase->register_new_node_with_ctrl_of(pre_initL, pre_init);\n+  phase->register_new_node_with_ctrl_of(pre_limitL, pre_init);\n+\n+  Node* pre_lastL = make_last(pre_initL, pre_iv_stride, pre_limitL, phase);\n+\n+  Node* main_initL = new AddLNode(pre_lastL, igvn.longcon(pre_iv_stride));\n+  phase->register_new_node_with_ctrl_of(main_initL, pre_init);\n+\n+  Node* main_init = new ConvL2INode(main_initL);\n+  phase->register_new_node_with_ctrl_of(main_init, pre_init);\n+\n+  Node* p1_init = vp1.make_pointer_expression(main_init);\n+  Node* p2_init = vp2.make_pointer_expression(main_init);\n+  Node* size1 = igvn.longcon(vp1.size());\n+  Node* size2 = igvn.longcon(vp2.size());\n+\n+#ifdef ASSERT\n+  if (_vloop.is_trace_speculative_aliasing_analysis() || _vloop.is_trace_speculative_runtime_checks()) {\n+    tty->print_cr(\"\\nVPointer::make_speculative_aliasing_check_with:\");\n+    tty->print(\"pre_init:  \"); pre_init->dump();\n+    tty->print(\"pre_limit: \"); pre_limit->dump();\n+    tty->print(\"pre_lastL: \"); pre_lastL->dump();\n+    tty->print(\"main_init: \"); main_init->dump();\n+    tty->print_cr(\"p1_init:\");\n+    p1_init->dump_bfs(5, nullptr, \"\");\n+    tty->print_cr(\"p2_init:\");\n+    p2_init->dump_bfs(5, nullptr, \"\");\n+  }\n+#endif\n+\n+  BoolNode* condition1 = nullptr;\n+  BoolNode* condition2 = nullptr;\n+  if (vp1.iv_scale() == vp2.iv_scale()) {\n+#ifdef ASSERT\n+    if (_vloop.is_trace_speculative_aliasing_analysis() || _vloop.is_trace_speculative_runtime_checks()) {\n+      tty->print_cr(\"  Same iv_scale(%d) -> parallel lines -> simple conditions:\", vp1.iv_scale());\n+      tty->print_cr(\"  p1(init) + size1 <= p2(init)  OR  p2(init) + size2 <= p1(init)\");\n+      tty->print_cr(\"  -------- condition1 --------      ------- condition2 ---------\");\n+    }\n+#endif\n+    condition1 = make_a_plus_b_leq_c(p1_init, size1, p2_init, phase);\n+    condition2 = make_a_plus_b_leq_c(p2_init, size2, p1_init, phase);\n+  } else {\n+    assert(vp1.iv_scale() < vp2.iv_scale(), \"assumed in proof, established above by swapping\");\n+\n+#ifdef ASSERT\n+    if (_vloop.is_trace_speculative_aliasing_analysis() || _vloop.is_trace_speculative_runtime_checks()) {\n+      tty->print_cr(\"  Different iv_scale -> lines with different slopes -> more complex conditions:\");\n+      tty->print_cr(\"  p1(init)         + size1 <= p2(init)          OR  p2(init) + span2 + size2 <= p1(init) + span1  (if iv_stride >= 0)\");\n+      tty->print_cr(\"  p1(init) + span1 + size1 <= p2(init) + span2  OR  p2(init)         + size2 <= p1(init)          (if iv_stride <= 0)\");\n+      tty->print_cr(\"  ---------------- condition1 ----------------      --------------- condition2 -----------------\");\n+    }\n+#endif\n+\n+    \/\/ last (aka main_last): compute from main-loop structure.\n+    jint main_iv_stride = _vloop.iv_stride();\n+    Node* main_limit = _vloop.cl()->limit();\n+    assert(_vloop.is_pre_loop_invariant(main_limit), \"needed for aliasing check before pre-loop\");\n+\n+    Node* main_limitL = new ConvI2LNode(main_limit);\n+    phase->register_new_node_with_ctrl_of(main_limitL, pre_init);\n+\n+    Node* main_lastL = make_last(main_initL, main_iv_stride, main_limitL, phase);\n+\n+    \/\/ Compute span1 = (last - init) * iv_scale1\n+    \/\/         span2 = (last - init) * iv_scale2\n+    Node* last_minus_init = new SubLNode(main_lastL, main_initL);\n+    Node* iv_scale1 = igvn.longcon(vp1.iv_scale());\n+    Node* iv_scale2 = igvn.longcon(vp2.iv_scale());\n+    Node* span1 = new MulLNode(last_minus_init, iv_scale1);\n+    Node* span2 = new MulLNode(last_minus_init, iv_scale2);\n+\n+    phase->register_new_node_with_ctrl_of(last_minus_init, pre_init);\n+    phase->register_new_node_with_ctrl_of(span1,           pre_init);\n+    phase->register_new_node_with_ctrl_of(span2,           pre_init);\n+\n+#ifdef ASSERT\n+    if (_vloop.is_trace_speculative_aliasing_analysis() || _vloop.is_trace_speculative_runtime_checks()) {\n+      tty->print(\"main_limitL: \"); main_limitL->dump();\n+      tty->print(\"main_lastL: \"); main_lastL->dump();\n+      tty->print(\"p1_init: \"); p1_init->dump();\n+      tty->print(\"p2_init: \"); p2_init->dump();\n+      tty->print(\"size1: \"); size1->dump();\n+      tty->print(\"size2: \"); size2->dump();\n+      tty->print_cr(\"span1: \"); span1->dump_bfs(5, nullptr, \"\");\n+      tty->print_cr(\"span2: \"); span2->dump_bfs(5, nullptr, \"\");\n+    }\n+#endif\n+\n+    Node* p1_init_plus_span1 = new AddLNode(p1_init, span1);\n+    Node* p2_init_plus_span2 = new AddLNode(p2_init, span2);\n+    phase->register_new_node_with_ctrl_of(p1_init_plus_span1, pre_init);\n+    phase->register_new_node_with_ctrl_of(p2_init_plus_span2, pre_init);\n+    if (_vloop.iv_stride() >= 0) {\n+      condition1 = make_a_plus_b_leq_c(p1_init,            size1, p2_init,            phase);\n+      condition2 = make_a_plus_b_leq_c(p2_init_plus_span2, size2, p1_init_plus_span1, phase);\n+    } else {\n+      condition1 = make_a_plus_b_leq_c(p1_init_plus_span1, size1, p2_init_plus_span2, phase);\n+      condition2 = make_a_plus_b_leq_c(p2_init,            size2, p1_init,            phase);\n+    }\n+  }\n+\n+#ifdef ASSERT\n+  if (_vloop.is_trace_speculative_aliasing_analysis() || _vloop.is_trace_speculative_runtime_checks()) {\n+    tty->print_cr(\"condition1:\");\n+    condition1->dump_bfs(5, nullptr, \"\");\n+    tty->print_cr(\"condition2:\");\n+    condition2->dump_bfs(5, nullptr, \"\");\n@@ -431,0 +1072,87 @@\n+#endif\n+\n+  \/\/ Construct \"condition1 OR condition2\". Convert the bol value back to an int value\n+  \/\/ that we can \"OR\" to create a single bol value. On x64, the two CMove are converted\n+  \/\/ to two setbe instructions which capture the condition bits to a register, meaning\n+  \/\/ we only have a single branch in the end.\n+  Node* zero = igvn.intcon(0);\n+  Node* one  = igvn.intcon(1);\n+  Node* cmov1 = new CMoveINode(condition1, zero, one, TypeInt::INT);\n+  Node* cmov2 = new CMoveINode(condition2, zero, one, TypeInt::INT);\n+  phase->register_new_node_with_ctrl_of(cmov1, main_initL);\n+  phase->register_new_node_with_ctrl_of(cmov2, main_initL);\n+\n+  Node* c1_or_c2 = new OrINode(cmov1, cmov2);\n+  Node* cmp = CmpNode::make(c1_or_c2, zero, T_INT);\n+  BoolNode* bol = new BoolNode(cmp, BoolTest::ne);\n+  phase->register_new_node_with_ctrl_of(c1_or_c2, main_initL);\n+  phase->register_new_node_with_ctrl_of(cmp, main_initL);\n+  phase->register_new_node_with_ctrl_of(bol, main_initL);\n+\n+  return bol;\n+}\n+\n+Node* VPointer::make_pointer_expression(Node* iv_value) const {\n+  assert(is_valid(), \"must be valid\");\n+\n+  PhaseIdealLoop* phase = _vloop.phase();\n+  PhaseIterGVN& igvn = phase->igvn();\n+  Node* iv = _vloop.iv();\n+  Node* ctrl = phase->get_ctrl(iv_value);\n+\n+  auto maybe_add = [&] (Node* n1, Node* n2, BasicType bt) {\n+    if (n1 == nullptr) { return n2; }\n+    Node* add = AddNode::make(n1, n2, bt);\n+    phase->register_new_node(add, ctrl);\n+    return add;\n+  };\n+\n+  Node* expression = nullptr;\n+  mem_pointer().for_each_raw_summand_of_int_group(0, [&] (const MemPointerRawSummand& s) {\n+    Node* node = nullptr;\n+    if (s.is_con()) {\n+      \/\/ Long constant.\n+      NoOverflowInt con = s.scaleI() * s.scaleL();\n+      node = igvn.longcon(con.value());\n+    } else {\n+      \/\/ Long variable.\n+      assert(s.scaleI().is_one(), \"must be long variable\");\n+      Node* scaleL = igvn.longcon(s.scaleL().value());\n+      Node* variable = (s.variable() == iv) ? iv_value : s.variable();\n+      if (variable->bottom_type()->isa_ptr() != nullptr) {\n+        variable = new CastP2XNode(nullptr, variable);\n+        phase->register_new_node(variable, ctrl);\n+      }\n+      node = new MulLNode(scaleL, variable);\n+      phase->register_new_node(node, ctrl);\n+    }\n+    expression = maybe_add(expression, node, T_LONG);\n+  });\n+\n+  int max_int_group = mem_pointer().max_int_group();\n+  for (int int_group = 1; int_group <= max_int_group; int_group++) {\n+    Node* int_expression = nullptr;\n+    NoOverflowInt int_group_scaleL;\n+    mem_pointer().for_each_raw_summand_of_int_group(int_group, [&] (const MemPointerRawSummand& s) {\n+      Node* node = nullptr;\n+      if (s.is_con()) {\n+        node = igvn.intcon(s.scaleI().value());\n+      } else {\n+        Node* scaleI = igvn.intcon(s.scaleI().value());\n+        Node* variable = (s.variable() == iv) ? iv_value : s.variable();\n+        node = new MulINode(scaleI, variable);\n+        phase->register_new_node(node, ctrl);\n+      }\n+      int_group_scaleL = s.scaleL(); \/\/ remember for multiplication after ConvI2L\n+      int_expression = maybe_add(int_expression, node, T_INT);\n+    });\n+    assert(int_expression != nullptr, \"no empty int group\");\n+    int_expression = new ConvI2LNode(int_expression);\n+    phase->register_new_node(int_expression, ctrl);\n+    Node* scaleL = igvn.longcon(int_group_scaleL.value());\n+    int_expression = new MulLNode(scaleL, int_expression);\n+    phase->register_new_node(int_expression, ctrl);\n+    expression = maybe_add(expression, int_expression, T_LONG);\n+  }\n+\n+  return expression;\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":759,"deletions":31,"binary":false,"changes":790,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -164,0 +165,4 @@\n+  bool use_speculative_aliasing_checks() const {\n+    return are_speculative_checks_possible() && UseAutoVectorizationSpeculativeAliasingChecks;\n+  }\n+\n@@ -206,0 +211,4 @@\n+\n+  bool is_trace_speculative_aliasing_analysis() const {\n+    return _vtrace.is_trace(TraceAutoVectorizationTag::SPECULATIVE_ALIASING_ANALYSIS);\n+  }\n@@ -225,0 +234,1 @@\n+    \/\/ Usually the ctrl of n is already before the pre-loop.\n@@ -226,4 +236,2 @@\n-\n-    \/\/ Quick test: is it in the main-loop?\n-    if (lpt()->is_member(phase()->get_loop(ctrl))) {\n-      return false;\n+    if (is_before_pre_loop(ctrl)) {\n+      return true;\n@@ -232,2 +240,6 @@\n-    \/\/ Is it before the pre-loop?\n-    return phase()->is_dominator(ctrl, pre_loop_head());\n+    \/\/ But in some cases, the ctrl of n is between the pre and\n+    \/\/ main loop, but the early ctrl is before the pre-loop.\n+    \/\/ As long as the early ctrl is before the pre-loop, we can\n+    \/\/ compute n before the pre-loop.\n+    Node* early = phase()->compute_early_ctrl(n, ctrl);\n+    return is_before_pre_loop(early);\n@@ -242,0 +254,10 @@\n+\n+  bool is_before_pre_loop(Node* ctrl) const {\n+    \/\/ Quick test: is it in the main-loop?\n+    if (lpt()->is_member(phase()->get_loop(ctrl))) {\n+      return false;\n+    }\n+\n+    \/\/ Is it before the pre-loop?\n+    return phase()->is_dominator(ctrl, pre_loop_head());\n+  }\n@@ -572,0 +594,3 @@\n+\/\/    - Strong edge: must be respected.\n+\/\/    - Weak edge:   if we add a speculative aliasing check, we can violate\n+\/\/                   the edge, i.e. swap the order.\n@@ -614,1 +639,1 @@\n-  void add_node(MemNode* n, GrowableArray<int>& memory_pred_edges);\n+  void add_node(MemNode* n, GrowableArray<int>& strong_memory_edges, GrowableArray<int>& weak_memory_edges);\n@@ -628,2 +653,3 @@\n-    const uint _memory_pred_edges_length;\n-    int* _memory_pred_edges; \/\/ memory pred-edges, mapping to bb_idx\n+    const uint _num_strong_memory_edges;\n+    const uint _num_weak_memory_edges;\n+    int* _memory_edges; \/\/ memory pred-edges, mapping to bb_idx\n@@ -631,1 +657,1 @@\n-    DependencyNode(MemNode* n, GrowableArray<int>& memory_pred_edges, Arena* arena);\n+    DependencyNode(MemNode* n, GrowableArray<int>& strong_memory_edges, GrowableArray<int>& weak_memory_edges, Arena* arena);\n@@ -633,1 +659,7 @@\n-    uint memory_pred_edges_length() const { return _memory_pred_edges_length; }\n+    uint num_strong_memory_edges() const { return _num_strong_memory_edges; }\n+    uint num_weak_memory_edges() const { return _num_weak_memory_edges; }\n+\n+    int strong_memory_edge(uint i) const {\n+      assert(i < _num_strong_memory_edges, \"bounds check\");\n+      return _memory_edges[i];\n+    }\n@@ -635,3 +667,3 @@\n-    int memory_pred_edge(uint i) const {\n-      assert(i < _memory_pred_edges_length, \"bounds check\");\n-      return _memory_pred_edges[i];\n+    int weak_memory_edge(uint i) const {\n+      assert(i < _num_weak_memory_edges, \"bounds check\");\n+      return _memory_edges[_num_strong_memory_edges + i];\n@@ -652,0 +684,9 @@\n+    bool _is_current_weak_memory_edge;\n+\n+    \/\/ Iterate in data edges, i.e. iterate node->in(i), excluding control and memory edges.\n+    int _next_data_edge;\n+    int _end_data_edge;\n+\n+    \/\/ Iterate in dependency_node->strong_memory_edges()\n+    int _next_strong_memory_edge;\n+    int _end_strong_memory_edge;\n@@ -653,3 +694,3 @@\n-    \/\/ Iterate in node->in(i)\n-    int _next_pred;\n-    int _end_pred;\n+    \/\/ Iterate in dependency_node->weak_memory_edge()\n+    int _next_weak_memory_edge;\n+    int _end_weak_memory_edge;\n@@ -657,3 +698,0 @@\n-    \/\/ Iterate in dependency_node->memory_pred_edge(i)\n-    int _next_memory_pred;\n-    int _end_memory_pred;\n@@ -665,0 +703,1 @@\n+\n@@ -669,0 +708,1 @@\n+\n@@ -673,0 +713,5 @@\n+\n+    bool is_current_weak_memory_edge() const {\n+      assert(!done(), \"not done yet\");\n+      return _is_current_weak_memory_edge;\n+    }\n@@ -937,0 +982,37 @@\n+  \/\/ Delegate to MemPointer::always_overlaps_with, but guard for invalid cases\n+  \/\/ where we must return a conservative answer: unknown overlap, return false.\n+  bool always_overlaps_with(const VPointer& other) const {\n+    if (!is_valid() || !other.is_valid()) {\n+#ifndef PRODUCT\n+      if (_vloop.mptrace().is_trace_overlap()) {\n+        tty->print_cr(\"VPointer::always_overlaps_with: invalid VPointer, overlap unknown.\");\n+      }\n+#endif\n+      return false;\n+    }\n+    return mem_pointer().always_overlaps_with(other.mem_pointer());\n+  }\n+\n+  static int cmp_summands(const VPointer& vp1, const VPointer& vp2) {\n+    return MemPointer::cmp_summands(vp1.mem_pointer(), vp2.mem_pointer());\n+  }\n+\n+  static int cmp_con(const VPointer& vp1, const VPointer& vp2) {\n+    \/\/ We use two comparisons, because a subtraction could underflow.\n+    jint con1 = vp1.con();\n+    jint con2 = vp2.con();\n+    if (con1 < con2) { return -1; }\n+    if (con1 > con2) { return  1; }\n+    return 0;\n+  }\n+\n+  static int cmp_summands_and_con(const VPointer& vp1, const VPointer& vp2) {\n+    int cmp = cmp_summands(vp1, vp2);\n+    if (cmp != 0) { return cmp; }\n+    return cmp_con(vp1, vp2);\n+  }\n+\n+  bool can_make_speculative_aliasing_check_with(const VPointer& other) const;\n+  Node* make_pointer_expression(Node* iv_value) const;\n+  BoolNode* make_speculative_aliasing_check_with(const VPointer& other) const;\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":102,"deletions":20,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -995,0 +995,4 @@\n+    case Op_MoveF2I:\n+    case Op_MoveD2L:\n+    case Op_MoveL2D:\n+    case Op_MoveI2F:\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"opto\/vectorization.hpp\"\n@@ -60,1 +61,1 @@\n-  collect_nodes_without_req_or_dependency(stack);\n+  collect_nodes_without_strong_in_edges(stack);\n@@ -75,2 +76,5 @@\n-      for (int i = 0; i < vtn->outs(); i++) {\n-        VTransformNode* use = vtn->out(i);\n+      \/\/ We only need to respect the strong edges (data edges and strong memory edges).\n+      \/\/ Violated weak memory edges are allowed, but require a speculative aliasing\n+      \/\/ runtime check, see VTransform::apply_speculative_aliasing_runtime_checks.\n+      for (uint i = 0; i < vtn->out_strong_edges(); i++) {\n+        VTransformNode* use = vtn->out_strong_edge(i);\n@@ -112,2 +116,2 @@\n-\/\/ Push all \"root\" nodes, i.e. those that have no inputs (req or dependency):\n-void VTransformGraph::collect_nodes_without_req_or_dependency(GrowableArray<VTransformNode*>& stack) const {\n+\/\/ Push all \"root\" nodes, i.e. those that have no strong input edges (data edges and strong memory edges):\n+void VTransformGraph::collect_nodes_without_strong_in_edges(GrowableArray<VTransformNode*>& stack) const {\n@@ -116,1 +120,1 @@\n-    if (!vtn->has_req_or_dependency()) {\n+    if (!vtn->has_strong_in_edge()) {\n@@ -147,1 +151,1 @@\n-void VTransform::apply_speculative_runtime_checks() {\n+void VTransform::apply_speculative_alignment_runtime_checks() {\n@@ -151,1 +155,1 @@\n-      tty->print_cr(\"\\nVTransform::apply_speculative_runtime_checks: native memory alignment\");\n+      tty->print_cr(\"\\nVTransform::apply_speculative_alignment_runtime_checks: native memory alignment\");\n@@ -202,1 +206,1 @@\n-  Node* mask_alignment = igvn().intcon(alignment-1);\n+  Node* mask_alignment = phase()->intcon(alignment-1);\n@@ -208,1 +212,1 @@\n-  Node* zero = igvn().intcon(0);\n+  Node* zero = phase()->intcon(0);\n@@ -219,0 +223,200 @@\n+class VPointerWeakAliasingPair : public StackObj {\n+private:\n+  \/\/ Using references instead of pointers would be preferrable, but GrowableArray\n+  \/\/ requires a default constructor, and we do not have a default constructor for\n+  \/\/ VPointer.\n+  const VPointer* _vp1 = nullptr;\n+  const VPointer* _vp2 = nullptr;\n+\n+  VPointerWeakAliasingPair(const VPointer& vp1, const VPointer& vp2) : _vp1(&vp1), _vp2(&vp2) {\n+    assert(vp1.is_valid(), \"sanity\");\n+    assert(vp2.is_valid(), \"sanity\");\n+    assert(!vp1.never_overlaps_with(vp2), \"otherwise no aliasing\");\n+    assert(!vp1.always_overlaps_with(vp2), \"otherwise must be strong\");\n+    assert(VPointer::cmp_summands_and_con(vp1, vp2) <= 0, \"must be sorted\");\n+  }\n+\n+public:\n+  \/\/ Default constructor to make GrowableArray happy.\n+  VPointerWeakAliasingPair() : _vp1(nullptr), _vp2(nullptr) {}\n+\n+  static VPointerWeakAliasingPair make(const VPointer& vp1, const VPointer& vp2) {\n+    if (VPointer::cmp_summands_and_con(vp1, vp2) <= 0) {\n+      return VPointerWeakAliasingPair(vp1, vp2);\n+    } else {\n+      return VPointerWeakAliasingPair(vp2, vp1);\n+    }\n+  }\n+\n+  const VPointer& vp1() const { return *_vp1; }\n+  const VPointer& vp2() const { return *_vp2; }\n+\n+  \/\/ Sort by summands, so that pairs with same summands (summand1, summands2) are adjacent.\n+  static int cmp_for_sort(VPointerWeakAliasingPair* pair1, VPointerWeakAliasingPair* pair2) {\n+    int cmp_summands1 = VPointer::cmp_summands(pair1->vp1(), pair2->vp1());\n+    if (cmp_summands1 != 0) { return cmp_summands1; }\n+    return VPointer::cmp_summands(pair1->vp2(), pair2->vp2());\n+  }\n+};\n+\n+void VTransform::apply_speculative_aliasing_runtime_checks() {\n+\n+  if (_vloop.use_speculative_aliasing_checks()) {\n+\n+#ifdef ASSERT\n+    if (_trace._speculative_aliasing_analysis || _trace._speculative_runtime_checks) {\n+      tty->print_cr(\"\\nVTransform::apply_speculative_aliasing_runtime_checks: speculative aliasing analysis runtime checks\");\n+    }\n+#endif\n+\n+    \/\/ It would be nice to add a ResourceMark here. But it would collide with resource allocation\n+    \/\/ in PhaseIdealLoop::set_idom for _idom and _dom_depth. See also JDK-8337015.\n+    VectorSet visited;\n+    GrowableArray<VPointerWeakAliasingPair> weak_aliasing_pairs;\n+\n+    const GrowableArray<VTransformNode*>& schedule = _graph.get_schedule();\n+    for (int i = 0; i < schedule.length(); i++) {\n+      VTransformNode* vtn = schedule.at(i);\n+      for (uint i = 0; i < vtn->out_weak_edges(); i++) {\n+        VTransformNode* use = vtn->out_weak_edge(i);\n+        if (visited.test(use->_idx)) {\n+          \/\/ The use node was already visited, i.e. is higher up in the schedule.\n+          \/\/ The \"out\" edge thus points backward, i.e. it is violated.\n+          const VPointer& vp1 = vtn->vpointer();\n+          const VPointer& vp2 = use->vpointer();\n+#ifdef ASSERT\n+          if (_trace._speculative_aliasing_analysis || _trace._speculative_runtime_checks) {\n+            tty->print_cr(\"\\nViolated Weak Edge:\");\n+            vtn->print();\n+            vp1.print_on(tty);\n+            use->print();\n+            vp2.print_on(tty);\n+          }\n+#endif\n+\n+          \/\/ We could generate checks for the pair (vp1, vp2) directly. But in\n+          \/\/ some graphs, this generates quadratically many checks. Example:\n+          \/\/\n+          \/\/   set1: a[i+0] a[i+1] a[i+2] a[i+3]\n+          \/\/   set2: b[i+0] b[i+1] b[i+2] b[i+3]\n+          \/\/\n+          \/\/ We may have a weak memory edge between every memory access from\n+          \/\/ set1 to every memory access from set2. In this example, this would\n+          \/\/ be 4 * 4 = 16 checks. But instead, we can create a union VPointer\n+          \/\/ for set1 and set2 each, and only create a single check.\n+          \/\/\n+          \/\/   set1: a[i+0, size = 4]\n+          \/\/   set1: b[i+0, size = 4]\n+          \/\/\n+          \/\/ For this, we add all pairs to an array, and process it below.\n+          weak_aliasing_pairs.push(VPointerWeakAliasingPair::make(vp1, vp2));\n+        }\n+      }\n+      visited.set(vtn->_idx);\n+    }\n+\n+    \/\/ Sort so that all pairs with the same summands (summands1, summands2)\n+    \/\/ are consecutive, i.e. in the same group. This allows us to do a linear\n+    \/\/ walk over all pairs of a group and create the union VPointers.\n+    weak_aliasing_pairs.sort(VPointerWeakAliasingPair::cmp_for_sort);\n+\n+    int group_start = 0;\n+    while (group_start < weak_aliasing_pairs.length()) {\n+      \/\/ New group: pick the first pair as the reference.\n+      const VPointer* vp1 = &weak_aliasing_pairs.at(group_start).vp1();\n+      const VPointer* vp2 = &weak_aliasing_pairs.at(group_start).vp2();\n+      jint size1 = vp1->size();\n+      jint size2 = vp2->size();\n+      int group_end = group_start + 1;\n+      while (group_end < weak_aliasing_pairs.length()) {\n+        const VPointer* vp1_next = &weak_aliasing_pairs.at(group_end).vp1();\n+        const VPointer* vp2_next = &weak_aliasing_pairs.at(group_end).vp2();\n+        jint size1_next = vp1_next->size();\n+        jint size2_next = vp2_next->size();\n+\n+        \/\/ Different summands -> different group.\n+        if (VPointer::cmp_summands(*vp1, *vp1_next) != 0) { break; }\n+        if (VPointer::cmp_summands(*vp2, *vp2_next) != 0) { break; }\n+\n+        \/\/ Pick the one with the lower con as the reference.\n+        if (vp1->con() > vp1_next->con()) {\n+          swap(vp1, vp1_next);\n+          swap(size1, size1_next);\n+        }\n+        if (vp2->con() > vp2_next->con()) {\n+          swap(vp2, vp2_next);\n+          swap(size2, size2_next);\n+        }\n+\n+        \/\/ Compute the distance from vp1 to vp1_next + size, to get a size that would include vp1_next.\n+        NoOverflowInt new_size1 = NoOverflowInt(vp1_next->con()) + NoOverflowInt(size1_next) - NoOverflowInt(vp1->con());\n+        NoOverflowInt new_size2 = NoOverflowInt(vp2_next->con()) + NoOverflowInt(size2_next) - NoOverflowInt(vp2->con());\n+        if (new_size1.is_NaN() || new_size2.is_NaN()) { break; \/* overflow -> new group *\/ }\n+\n+        \/\/ The \"next\" VPointer indeed belong to the group.\n+        \/\/\n+        \/\/ vp1:       |-------------->\n+        \/\/ vp1_next:            |---------------->\n+        \/\/ result:    |-------------------------->\n+        \/\/\n+        \/\/ vp1:       |-------------------------->\n+        \/\/ vp1_next:            |------->\n+        \/\/ result:    |-------------------------->\n+        \/\/\n+        size1 = MAX2(size1, new_size1.value());\n+        size2 = MAX2(size2, new_size2.value());\n+        group_end++;\n+      }\n+      \/\/ Create \"union\" VPointer that cover all VPointer from the group.\n+      const VPointer vp1_union = vp1->make_with_size(size1);\n+      const VPointer vp2_union = vp2->make_with_size(size2);\n+\n+#ifdef ASSERT\n+      if (_trace._speculative_aliasing_analysis || _trace._speculative_runtime_checks) {\n+        tty->print_cr(\"\\nUnion of %d weak aliasing edges:\", group_end - group_start);\n+        vp1_union.print_on(tty);\n+        vp2_union.print_on(tty);\n+      }\n+\n+      \/\/ Verification - union must contain all VPointer of the group.\n+      for (int i = group_start; i < group_end; i++) {\n+        const VPointer& vp1_i = weak_aliasing_pairs.at(i).vp1();\n+        const VPointer& vp2_i = weak_aliasing_pairs.at(i).vp2();\n+        assert(vp1_union.con() <= vp1_i.con(), \"must start before\");\n+        assert(vp2_union.con() <= vp2_i.con(), \"must start before\");\n+        assert(vp1_union.size() >= vp1_i.size(), \"must end after\");\n+        assert(vp2_union.size() >= vp2_i.size(), \"must end after\");\n+      }\n+#endif\n+\n+      BoolNode* bol = vp1_union.make_speculative_aliasing_check_with(vp2_union);\n+      add_speculative_check(bol);\n+\n+      group_start = group_end;\n+    }\n+  }\n+}\n+\n+\/\/ Runtime Checks:\n+\/\/   Some required properties cannot be proven statically, and require a\n+\/\/   runtime check:\n+\/\/   - Alignment:\n+\/\/       See VTransform::add_speculative_alignment_check\n+\/\/   - Aliasing:\n+\/\/       See VTransform::apply_speculative_aliasing_runtime_checks\n+\/\/   There is a two staged approach for compilation:\n+\/\/   - AutoVectorization Predicate:\n+\/\/       See VM flag UseAutoVectorizationPredicate and documentation in predicates.hpp\n+\/\/       We speculate that the checks pass, and only compile a vectorized  loop.\n+\/\/       We expect the checks to pass in almost all cases, and so we only need\n+\/\/       to compile and cache the vectorized loop.\n+\/\/       If the predicate ever fails, we deoptimize, and eventually compile\n+\/\/       without predicate. This means we will recompile with multiversioning.\n+\/\/    - Multiversioning:\n+\/\/       See VM Flag LoopMultiversioning and documentaiton in loopUnswitch.cpp\n+\/\/       If the predicate is not available or previously failed, then we compile\n+\/\/       a vectorized and a scalar loop. If the runtime check passes we take the\n+\/\/       vectorized loop, else the scalar loop.\n+\/\/       Multiversioning takes more compile time and code cache, but it also\n+\/\/       produces fast code for when the runtime check passes (vectorized) and\n+\/\/       when it fails (scalar performance).\n@@ -429,1 +633,1 @@\n-        const VPointer& p = vtn->vpointer(vloop_analyzer);\n+        const VPointer& p = vtn->vpointer();\n@@ -496,3 +700,8 @@\n-Node* VTransformNode::find_transformed_input(int i, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n-  Node* n = vnode_idx_to_transformed_node.at(in(i)->_idx);\n-  assert(n != nullptr, \"must find input IR node\");\n+void VTransformApplyState::set_transformed_node(VTransformNode* vtn, Node* n) {\n+  assert(_vtnode_idx_to_transformed_node.at(vtn->_idx) == nullptr, \"only set once\");\n+  _vtnode_idx_to_transformed_node.at_put(vtn->_idx, n);\n+}\n+\n+Node* VTransformApplyState::transformed_node(const VTransformNode* vtn) const {\n+  Node* n = _vtnode_idx_to_transformed_node.at(vtn->_idx);\n+  assert(n != nullptr, \"must find IR node for vtnode\");\n@@ -502,2 +711,16 @@\n-VTransformApplyResult VTransformScalarNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                  const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+VTransformApplyResult VTransformMemopScalarNode::apply(VTransformApplyState& apply_state) const {\n+  \/\/ This was just wrapped. Now we simply unwap without touching the inputs.\n+  return VTransformApplyResult::make_scalar(_node);\n+}\n+\n+VTransformApplyResult VTransformDataScalarNode::apply(VTransformApplyState& apply_state) const {\n+  \/\/ This was just wrapped. Now we simply unwap without touching the inputs.\n+  return VTransformApplyResult::make_scalar(_node);\n+}\n+\n+VTransformApplyResult VTransformLoopPhiNode::apply(VTransformApplyState& apply_state) const {\n+  \/\/ This was just wrapped. Now we simply unwap without touching the inputs.\n+  return VTransformApplyResult::make_scalar(_node);\n+}\n+\n+VTransformApplyResult VTransformCFGNode::apply(VTransformApplyState& apply_state) const {\n@@ -508,3 +731,7 @@\n-VTransformApplyResult VTransformReplicateNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                     const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n-  Node* val = find_transformed_input(1, vnode_idx_to_transformed_node);\n+VTransformApplyResult VTransformOuterNode::apply(VTransformApplyState& apply_state) const {\n+  \/\/ This was just wrapped. Now we simply unwap without touching the inputs.\n+  return VTransformApplyResult::make_scalar(_node);\n+}\n+\n+VTransformApplyResult VTransformReplicateNode::apply(VTransformApplyState& apply_state) const {\n+  Node* val = apply_state.transformed_node(in_req(1));\n@@ -512,1 +739,1 @@\n-  register_new_node_from_vectorization(vloop_analyzer, vn, val);\n+  register_new_node_from_vectorization(apply_state, vn, val);\n@@ -516,3 +743,2 @@\n-VTransformApplyResult VTransformConvI2LNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                   const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n-  Node* val = find_transformed_input(1, vnode_idx_to_transformed_node);\n+VTransformApplyResult VTransformConvI2LNode::apply(VTransformApplyState& apply_state) const {\n+  Node* val = apply_state.transformed_node(in_req(1));\n@@ -520,1 +746,1 @@\n-  register_new_node_from_vectorization(vloop_analyzer, n, val);\n+  register_new_node_from_vectorization(apply_state, n, val);\n@@ -524,4 +750,3 @@\n-VTransformApplyResult VTransformShiftCountNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n-  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n-  Node* shift_count_in = find_transformed_input(1, vnode_idx_to_transformed_node);\n+VTransformApplyResult VTransformShiftCountNode::apply(VTransformApplyState& apply_state) const {\n+  PhaseIdealLoop* phase = apply_state.phase();\n+  Node* shift_count_in = apply_state.transformed_node(in_req(1));\n@@ -532,2 +757,2 @@\n-  Node* shift_count_masked = new AndINode(shift_count_in, phase->igvn().intcon(_mask));\n-  register_new_node_from_vectorization(vloop_analyzer, shift_count_masked, shift_count_in);\n+  Node* shift_count_masked = new AndINode(shift_count_in, phase->intcon(_mask));\n+  register_new_node_from_vectorization(apply_state, shift_count_masked, shift_count_in);\n@@ -536,1 +761,1 @@\n-  register_new_node_from_vectorization(vloop_analyzer, vn, shift_count_in);\n+  register_new_node_from_vectorization(apply_state, vn, shift_count_in);\n@@ -541,4 +766,3 @@\n-VTransformApplyResult VTransformPopulateIndexNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                         const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n-  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n-  Node* val = find_transformed_input(1, vnode_idx_to_transformed_node);\n+VTransformApplyResult VTransformPopulateIndexNode::apply(VTransformApplyState& apply_state) const {\n+  PhaseIdealLoop* phase = apply_state.phase();\n+  Node* val = apply_state.transformed_node(in_req(1));\n@@ -548,2 +772,2 @@\n-  VectorNode* vn = new PopulateIndexNode(val, phase->igvn().intcon(1), vt);\n-  register_new_node_from_vectorization(vloop_analyzer, vn, val);\n+  VectorNode* vn = new PopulateIndexNode(val, phase->intcon(1), vt);\n+  register_new_node_from_vectorization(apply_state, vn, val);\n@@ -553,2 +777,1 @@\n-VTransformApplyResult VTransformElementWiseVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                             const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+VTransformApplyResult VTransformElementWiseVectorNode::apply(VTransformApplyState& apply_state) const {\n@@ -558,1 +781,1 @@\n-  BasicType bt = vloop_analyzer.types().velt_basic_type(first);\n+  BasicType bt = apply_state.vloop_analyzer().types().velt_basic_type(first);\n@@ -568,3 +791,3 @@\n-  Node* in1 =                find_transformed_input(1, vnode_idx_to_transformed_node);\n-  Node* in2 = (req() >= 3) ? find_transformed_input(2, vnode_idx_to_transformed_node) : nullptr;\n-  Node* in3 = (req() >= 4) ? find_transformed_input(3, vnode_idx_to_transformed_node) : nullptr;\n+  Node* in1 =                apply_state.transformed_node(in_req(1));\n+  Node* in2 = (req() >= 3) ? apply_state.transformed_node(in_req(2)) : nullptr;\n+  Node* in3 = (req() >= 4) ? apply_state.transformed_node(in_req(3)) : nullptr;\n@@ -590,1 +813,1 @@\n-    register_new_node_from_vectorization(vloop_analyzer, long_vn, first);\n+    register_new_node_from_vectorization(apply_state, long_vn, first);\n@@ -608,1 +831,1 @@\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(apply_state, vn);\n@@ -612,2 +835,1 @@\n-VTransformApplyResult VTransformBoolVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+VTransformApplyResult VTransformBoolVectorNode::apply(VTransformApplyState& apply_state) const {\n@@ -616,1 +838,1 @@\n-  BasicType bt = vloop_analyzer.types().velt_basic_type(first);\n+  BasicType bt = apply_state.vloop_analyzer().types().velt_basic_type(first);\n@@ -619,1 +841,1 @@\n-  VTransformElementWiseVectorNode* vtn_cmp = in(1)->isa_ElementWiseVector();\n+  VTransformElementWiseVectorNode* vtn_cmp = in_req(1)->isa_ElementWiseVector();\n@@ -623,2 +845,2 @@\n-  Node* cmp_in1 = vtn_cmp->find_transformed_input(1, vnode_idx_to_transformed_node);\n-  Node* cmp_in2 = vtn_cmp->find_transformed_input(2, vnode_idx_to_transformed_node);\n+  Node* cmp_in1 = apply_state.transformed_node(vtn_cmp->in_req(1));\n+  Node* cmp_in2 = apply_state.transformed_node(vtn_cmp->in_req(2));\n@@ -627,2 +849,2 @@\n-  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n-  ConINode* mask_node  = phase->igvn().intcon((int)mask);\n+  PhaseIdealLoop* phase = apply_state.phase();\n+  ConINode* mask_node  = phase->intcon((int)mask);\n@@ -631,1 +853,1 @@\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(apply_state, vn);\n@@ -635,2 +857,1 @@\n-VTransformApplyResult VTransformReductionVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                           const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+VTransformApplyResult VTransformReductionVectorNode::apply(VTransformApplyState& apply_state) const {\n@@ -642,2 +863,2 @@\n-  Node* init = find_transformed_input(1, vnode_idx_to_transformed_node);\n-  Node* vec  = find_transformed_input(2, vnode_idx_to_transformed_node);\n+  Node* init = apply_state.transformed_node(in_req(1));\n+  Node* vec  = apply_state.transformed_node(in_req(2));\n@@ -646,1 +867,1 @@\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(apply_state, vn);\n@@ -650,2 +871,1 @@\n-VTransformApplyResult VTransformLoadVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+VTransformApplyResult VTransformLoadVectorNode::apply(VTransformApplyState& apply_state) const {\n@@ -659,1 +879,1 @@\n-  BasicType bt = vloop_analyzer.types().velt_basic_type(first);\n+  BasicType bt = apply_state.vloop_analyzer().types().velt_basic_type(first);\n@@ -664,1 +884,1 @@\n-  const VPointer& load_p = vpointer(vloop_analyzer);\n+  const VPointer& load_p = vpointer();\n@@ -666,1 +886,1 @@\n-    VPointer store_p(mem->as_Mem(), vloop_analyzer.vloop());\n+    VPointer store_p(mem->as_Mem(), apply_state.vloop());\n@@ -677,1 +897,1 @@\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(apply_state, vn);\n@@ -681,2 +901,1 @@\n-VTransformApplyResult VTransformStoreVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                       const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+VTransformApplyResult VTransformStoreVectorNode::apply(VTransformApplyState& apply_state) const {\n@@ -691,1 +910,1 @@\n-  Node* value = find_transformed_input(MemNode::ValueIn, vnode_idx_to_transformed_node);\n+  Node* value = apply_state.transformed_node(in_req(MemNode::ValueIn));\n@@ -694,1 +913,1 @@\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(apply_state, vn);\n@@ -698,2 +917,2 @@\n-void VTransformVectorNode::register_new_node_from_vectorization_and_replace_scalar_nodes(const VLoopAnalyzer& vloop_analyzer, Node* vn) const {\n-  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+void VTransformVectorNode::register_new_node_from_vectorization_and_replace_scalar_nodes(VTransformApplyState& apply_state, Node* vn) const {\n+  PhaseIdealLoop* phase = apply_state.phase();\n@@ -702,1 +921,1 @@\n-  register_new_node_from_vectorization(vloop_analyzer, vn, first);\n+  register_new_node_from_vectorization(apply_state, vn, first);\n@@ -710,2 +929,2 @@\n-void VTransformNode::register_new_node_from_vectorization(const VLoopAnalyzer& vloop_analyzer, Node* vn, Node* old_node) const {\n-  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+void VTransformNode::register_new_node_from_vectorization(VTransformApplyState& apply_state, Node* vn, Node* old_node) const {\n+  PhaseIdealLoop* phase = apply_state.phase();\n@@ -753,2 +972,8 @@\n-    tty->print(\" |\");\n-    for (int i = _req; i < _in.length(); i++) {\n+    tty->print(\" | strong:\");\n+    for (uint i = _req; i < _in_end_strong_memory_edges; i++) {\n+      print_node_idx(_in.at(i));\n+    }\n+  }\n+  if ((uint)_in.length() > _in_end_strong_memory_edges) {\n+    tty->print(\" | weak:\");\n+    for (uint i = _in_end_strong_memory_edges; i < (uint)_in.length(); i++) {\n@@ -759,1 +984,1 @@\n-  for (int i = 0; i < _out.length(); i++) {\n+  for (uint i = 0; i < _out_end_strong_edges; i++) {\n@@ -762,0 +987,6 @@\n+  if ((uint)_out.length() > _out_end_strong_edges) {\n+    tty->print(\" | weak:\");\n+    for (uint i = _out_end_strong_edges; i < (uint)_out.length(); i++) {\n+      print_node_idx(_out.at(i));\n+    }\n+  }\n@@ -775,1 +1006,18 @@\n-void VTransformScalarNode::print_spec() const {\n+void VTransformMemopScalarNode::print_spec() const {\n+  tty->print(\"node[%d %s] \", _node->_idx, _node->Name());\n+  _vpointer.print_on(tty, false);\n+}\n+\n+void VTransformDataScalarNode::print_spec() const {\n+  tty->print(\"node[%d %s]\", _node->_idx, _node->Name());\n+}\n+\n+void VTransformLoopPhiNode::print_spec() const {\n+  tty->print(\"node[%d %s]\", _node->_idx, _node->Name());\n+}\n+\n+void VTransformCFGNode::print_spec() const {\n+  tty->print(\"node[%d %s]\", _node->_idx, _node->Name());\n+}\n+\n+void VTransformOuterNode::print_spec() const {\n@@ -803,0 +1051,4 @@\n+  if (is_load_or_store_in_loop()) {\n+    tty->print(\" \");\n+    vpointer().print_on(tty, false);\n+  }\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":330,"deletions":78,"binary":false,"changes":408,"status":"modified"},{"patch":"@@ -63,2 +63,5 @@\n-class VTransformScalarNode;\n-class VTransformInputScalarNode;\n+class VTransformMemopScalarNode;\n+class VTransformDataScalarNode;\n+class VTransformLoopPhiNode;\n+class VTransformCFGNode;\n+class VTransformOuterNode;\n@@ -112,0 +115,1 @@\n+  const bool _speculative_aliasing_analysis;\n@@ -118,0 +122,1 @@\n+                  const bool is_trace_speculative_aliasing_analysis,\n@@ -121,4 +126,5 @@\n-    _rejections                (_verbose | is_trace_vtransform(vtrace) | is_trace_rejections),\n-    _align_vector              (_verbose | is_trace_vtransform(vtrace) | is_trace_align_vector),\n-    _speculative_runtime_checks(_verbose | is_trace_vtransform(vtrace) | is_trace_speculative_runtime_checks),\n-    _info                      (_verbose | is_trace_vtransform(vtrace) | is_trace_info) {}\n+    _rejections                    (_verbose | is_trace_vtransform(vtrace) | is_trace_rejections),\n+    _align_vector                  (_verbose | is_trace_vtransform(vtrace) | is_trace_align_vector),\n+    _speculative_aliasing_analysis (_verbose | is_trace_vtransform(vtrace) | is_trace_speculative_aliasing_analysis),\n+    _speculative_runtime_checks    (_verbose | is_trace_vtransform(vtrace) | is_trace_speculative_runtime_checks),\n+    _info                          (_verbose | is_trace_vtransform(vtrace) | is_trace_info) {}\n@@ -164,0 +170,1 @@\n+  const GrowableArray<VTransformNode*>& get_schedule() const { return _schedule; }\n@@ -176,1 +183,1 @@\n-  void collect_nodes_without_req_or_dependency(GrowableArray<VTransformNode*>& stack) const;\n+  void collect_nodes_without_strong_in_edges(GrowableArray<VTransformNode*>& stack) const;\n@@ -251,1 +258,2 @@\n-  void apply_speculative_runtime_checks();\n+  void apply_speculative_alignment_runtime_checks();\n+  void apply_speculative_aliasing_runtime_checks();\n@@ -258,0 +266,26 @@\n+\/\/ Keeps track of the state during \"VTransform::apply\"\n+\/\/ -> keep track of the already transformed nodes\n+class VTransformApplyState : public StackObj {\n+private:\n+  const VLoopAnalyzer& _vloop_analyzer;\n+\n+  \/\/ We keep track of the resulting Nodes from every \"VTransformNode::apply\" call.\n+  \/\/ Since \"apply\" is called on defs before uses, this allows us to find the\n+  \/\/ generated def (input) nodes when we are generating the use nodes in \"apply\".\n+  GrowableArray<Node*> _vtnode_idx_to_transformed_node;\n+\n+public:\n+  VTransformApplyState(const VLoopAnalyzer& vloop_analyzer, int num_vtnodes) :\n+    _vloop_analyzer(vloop_analyzer),\n+    _vtnode_idx_to_transformed_node(num_vtnodes, num_vtnodes, nullptr)\n+  {\n+  }\n+\n+  const VLoop& vloop() const { return _vloop_analyzer.vloop(); }\n+  PhaseIdealLoop* phase() const { return vloop().phase(); }\n+  const VLoopAnalyzer& vloop_analyzer() const { return _vloop_analyzer; }\n+\n+  void set_transformed_node(VTransformNode* vtn, Node* n);\n+  Node* transformed_node(const VTransformNode* vtn) const;\n+};\n+\n@@ -262,0 +296,20 @@\n+\/\/\n+\/\/ There are 3 tyes of edges:\n+\/\/ - data edges (req):           corresponding to C2 IR Node data edges, except control\n+\/\/                               and memory.\n+\/\/ - strong memory edges:        memory edges that must be respected when scheduling.\n+\/\/ - weak memory edges:          memory edges that can be violated, but if violated then\n+\/\/                               corresponding aliasing analysis runtime checks must be\n+\/\/                               inserted.\n+\/\/\n+\/\/ Strong edges: union of data edges and strong memory edges.\n+\/\/               These must be respected by scheduling in all cases.\n+\/\/\n+\/\/ The C2 IR Node memory edges essentially define a linear order of all memory operations\n+\/\/ (only Loads with the same memory input can be executed in an arbitrary order). This is\n+\/\/ efficient, because it means every Load and Store has exactly one input memory edge,\n+\/\/ which keeps the memory edge count linear. This is approach is too restrictive for\n+\/\/ vectorization, for example, we could never vectorize stores, since they are all in a\n+\/\/ dependency chain. Instead, we model the memory edges between all memory nodes, which\n+\/\/ could be quadratic in the worst case. For vectorization, we must essentially reorder the\n+\/\/ instructions in the graph. For this we must model all memory dependencies.\n@@ -267,2 +321,4 @@\n-  \/\/ _in is split into required inputs (_req, i.e. all data dependencies),\n-  \/\/ and memory dependencies.\n+  \/\/ We split _in into 3 sections:\n+  \/\/ - data edges (req):     _in[0                           .. _req-1]\n+  \/\/ - strong memory edges:  _in[_req                        .. _in_end_strong_memory_edges-1]\n+  \/\/ - weak memory edges:    _in[_in_end_strong_memory_edges .. ]\n@@ -270,0 +326,1 @@\n+  uint _in_end_strong_memory_edges;\n@@ -271,0 +328,5 @@\n+\n+  \/\/ We split _out into 2 sections:\n+  \/\/ - strong edges:         _out[0                     .. _out_end_strong_edges-1]\n+  \/\/ - weak memory edges:    _out[_out_end_strong_edges .. _len-1]\n+  uint _out_end_strong_edges;\n@@ -277,0 +339,1 @@\n+    _in_end_strong_memory_edges(req),\n@@ -278,0 +341,1 @@\n+    _out_end_strong_edges(0),\n@@ -283,1 +347,1 @@\n-  void set_req(uint i, VTransformNode* n) {\n+  void init_req(uint i, VTransformNode* n) {\n@@ -287,1 +351,1 @@\n-    n->add_out(this);\n+    n->add_out_strong_edge(this);\n@@ -298,1 +362,16 @@\n-  void add_memory_dependency(VTransformNode* n) {\n+  void add_strong_memory_edge(VTransformNode* n) {\n+    assert(n != nullptr, \"no need to add nullptr\");\n+    if (_in_end_strong_memory_edges < (uint)_in.length()) {\n+      \/\/ Put n in place of first weak memory edge, and move\n+      \/\/ the weak memory edge to the end.\n+      VTransformNode* first_weak = _in.at(_in_end_strong_memory_edges);\n+      _in.at_put(_in_end_strong_memory_edges, n);\n+      _in.push(first_weak);\n+    } else {\n+      _in.push(n);\n+    }\n+    _in_end_strong_memory_edges++;\n+    n->add_out_strong_edge(this);\n+  }\n+\n+  void add_weak_memory_edge(VTransformNode* n) {\n@@ -301,1 +380,1 @@\n-    n->add_out(this);\n+    n->add_out_weak_memory_edge(this);\n@@ -304,1 +383,15 @@\n-  void add_out(VTransformNode* n) {\n+private:\n+  void add_out_strong_edge(VTransformNode* n) {\n+    if (_out_end_strong_edges < (uint)_out.length()) {\n+      \/\/ Put n in place of first weak memory edge, and move\n+      \/\/ the weak memory edge to the end.\n+      VTransformNode* first_weak = _out.at(_out_end_strong_edges);\n+      _out.at_put(_out_end_strong_edges, n);\n+      _out.push(first_weak);\n+    } else {\n+      _out.push(n);\n+    }\n+    _out_end_strong_edges++;\n+  }\n+\n+  void add_out_weak_memory_edge(VTransformNode* n) {\n@@ -308,0 +401,1 @@\n+public:\n@@ -309,3 +403,17 @@\n-  VTransformNode* in(int i) const { return _in.at(i); }\n-  int outs() const { return _out.length(); }\n-  VTransformNode* out(int i) const { return _out.at(i); }\n+  uint out_strong_edges() const { return _out_end_strong_edges; }\n+  uint out_weak_edges() const { return _out.length() - _out_end_strong_edges; }\n+\n+  VTransformNode* in_req(uint i) const {\n+    assert(i < _req, \"must be a req\");\n+    return _in.at(i);\n+  }\n+\n+  VTransformNode* out_strong_edge(uint i) const {\n+    assert(i < out_strong_edges(), \"must be a strong memory edge or data edge\");\n+    return _out.at(i);\n+  }\n+\n+  VTransformNode* out_weak_edge(uint i) const {\n+    assert(i < out_weak_edges(), \"must be a strong memory edge\");\n+    return _out.at(_out_end_strong_edges + i);\n+  }\n@@ -313,2 +421,2 @@\n-  bool has_req_or_dependency() const {\n-    for (int i = 0; i < _in.length(); i++) {\n+  bool has_strong_in_edge() const {\n+    for (uint i = 0; i < _in_end_strong_memory_edges; i++) {\n@@ -320,2 +428,2 @@\n-  virtual VTransformScalarNode* isa_Scalar() { return nullptr; }\n-  virtual VTransformInputScalarNode* isa_InputScalar() { return nullptr; }\n+  virtual VTransformMemopScalarNode* isa_MemopScalar() { return nullptr; }\n+  virtual VTransformOuterNode* isa_Outer() { return nullptr; }\n@@ -332,1 +440,1 @@\n-  virtual const VPointer& vpointer(const VLoopAnalyzer& vloop_analyzer) const { ShouldNotReachHere(); }\n+  virtual const VPointer& vpointer() const { ShouldNotReachHere(); }\n@@ -334,2 +442,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const = 0;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const = 0;\n@@ -339,1 +446,1 @@\n-  void register_new_node_from_vectorization(const VLoopAnalyzer& vloop_analyzer, Node* vn, Node* old_node) const;\n+  void register_new_node_from_vectorization(VTransformApplyState& apply_state, Node* vn, Node* old_node) const;\n@@ -347,2 +454,2 @@\n-\/\/ Identity transform for scalar nodes.\n-class VTransformScalarNode : public VTransformNode {\n+\/\/ Identity transform for scalar loads and stores.\n+class VTransformMemopScalarNode : public VTransformNode {\n@@ -350,1 +457,2 @@\n-  Node* _node;\n+  MemNode* _node;\n+  const VPointer _vpointer;\n@@ -352,4 +460,9 @@\n-  VTransformScalarNode(VTransform& vtransform, Node* n) :\n-    VTransformNode(vtransform, n->req()), _node(n) {}\n-  Node* node() const { return _node; }\n-  virtual VTransformScalarNode* isa_Scalar() override { return this; }\n+  VTransformMemopScalarNode(VTransform& vtransform, MemNode* n, const VPointer& vpointer) :\n+    VTransformNode(vtransform, n->req()), _node(n), _vpointer(vpointer)\n+  {\n+    assert(node()->is_Load() || node()->is_Store(), \"must be memop\");\n+  }\n+\n+  MemNode* node() const { return _node; }\n+  virtual VTransformMemopScalarNode* isa_MemopScalar() override { return this; }\n+\n@@ -357,5 +470,53 @@\n-  virtual bool is_load_or_store_in_loop() const override { return _node->is_Load() || _node->is_Store(); }\n-  virtual const VPointer& vpointer(const VLoopAnalyzer& vloop_analyzer) const override { return vloop_analyzer.vpointers().vpointer(node()->as_Mem()); }\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n-  NOT_PRODUCT(virtual const char* name() const override { return \"Scalar\"; };)\n+  virtual bool is_load_or_store_in_loop() const override { return true; }\n+\n+  virtual const VPointer& vpointer() const override { return _vpointer; }\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"MemopScalar\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Identity transform for scalar data nodes.\n+class VTransformDataScalarNode : public VTransformNode {\n+private:\n+  Node* _node;\n+public:\n+  VTransformDataScalarNode(VTransform& vtransform, Node* n) :\n+    VTransformNode(vtransform, n->req()), _node(n)\n+  {\n+    assert(!_node->is_Mem() && !_node->is_Phi() && !_node->is_CFG(), \"must be data node: %s\", _node->Name());\n+  }\n+\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"DataScalar\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Identity transform for loop head phi nodes.\n+class VTransformLoopPhiNode : public VTransformNode {\n+private:\n+  PhiNode* _node;\n+public:\n+  VTransformLoopPhiNode(VTransform& vtransform, PhiNode* n) :\n+    VTransformNode(vtransform, n->req()), _node(n)\n+  {\n+    assert(_node->in(0)->is_Loop(), \"phi ctrl must be Loop: %s\", _node->in(0)->Name());\n+  }\n+\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"LoopPhi\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Identity transform for CFG nodes.\n+class VTransformCFGNode : public VTransformNode {\n+private:\n+  Node* _node;\n+public:\n+  VTransformCFGNode(VTransform& vtransform, Node* n) :\n+    VTransformNode(vtransform, n->req()), _node(n)\n+  {\n+    assert(_node->is_CFG(), \"must be CFG node: %s\", _node->Name());\n+  }\n+\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"CFG\"; };)\n@@ -368,1 +529,3 @@\n-class VTransformInputScalarNode : public VTransformScalarNode {\n+class VTransformOuterNode : public VTransformNode {\n+private:\n+  Node* _node;\n@@ -370,6 +533,7 @@\n-  VTransformInputScalarNode(VTransform& vtransform, Node* n) :\n-    VTransformScalarNode(vtransform, n) {}\n-  virtual VTransformInputScalarNode* isa_InputScalar() override { return this; }\n-  virtual bool is_load_in_loop() const override { return false; }\n-  virtual bool is_load_or_store_in_loop() const override { return false; }\n-  NOT_PRODUCT(virtual const char* name() const override { return \"InputScalar\"; };)\n+  VTransformOuterNode(VTransform& vtransform, Node* n) :\n+    VTransformNode(vtransform, n->req()), _node(n) {}\n+\n+  virtual VTransformOuterNode* isa_Outer() override { return this; }\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"Outer\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n@@ -386,2 +550,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -396,2 +559,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -411,2 +573,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -425,2 +586,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -447,1 +607,1 @@\n-  void register_new_node_from_vectorization_and_replace_scalar_nodes(const VLoopAnalyzer& vloop_analyzer, Node* vn) const;\n+  void register_new_node_from_vectorization_and_replace_scalar_nodes(VTransformApplyState& apply_state, Node* vn) const;\n@@ -457,2 +617,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -478,2 +637,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -489,2 +647,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -505,1 +662,1 @@\n-  virtual const VPointer& vpointer(const VLoopAnalyzer& vloop_analyzer) const override { return _vpointer; }\n+  virtual const VPointer& vpointer() const override { return _vpointer; }\n@@ -516,2 +673,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -528,2 +684,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -541,2 +696,2 @@\n-    \/\/ We can ignore input nodes, they are outside the loop.\n-    if (vtn->isa_InputScalar() != nullptr) { continue; }\n+    \/\/ We must ignore nodes outside the loop.\n+    if (vtn->isa_Outer() != nullptr) { continue; }\n@@ -544,3 +699,3 @@\n-    VTransformScalarNode* scalar = vtn->isa_Scalar();\n-    if (scalar != nullptr && scalar->node()->is_Mem()) {\n-      callback(scalar->node()->as_Mem());\n+    VTransformMemopScalarNode* scalar = vtn->isa_MemopScalar();\n+    if (scalar != nullptr) {\n+      callback(scalar->node());\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":225,"deletions":70,"binary":false,"changes":295,"status":"modified"},{"patch":"@@ -28,3 +28,3 @@\n-\/\/ These header files are included in at least 130 C++ files, as of\n-\/\/ measurements made in November 2018. This list excludes files named\n-\/\/ *.inline.hpp, since including them decreased build performance.\n+\/\/ These header files are selected using the output of Clang\n+\/\/ '-ftime-trace' as a measure of how much time we spend\n+\/\/ compiling them.\n@@ -32,6 +32,1 @@\n-#include \"classfile\/classLoaderData.hpp\"\n-#include \"classfile\/javaClasses.hpp\"\n-#include \"classfile\/systemDictionary.hpp\"\n-#include \"gc\/shared\/collectedHeap.hpp\"\n-#include \"gc\/shared\/gcCause.hpp\"\n-#include \"logging\/log.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n@@ -39,35 +34,1 @@\n-#include \"memory\/iterator.hpp\"\n-#include \"memory\/memRegion.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"memory\/universe.hpp\"\n-#include \"nmt\/memTracker.hpp\"\n-#include \"oops\/instanceKlass.hpp\"\n-#include \"oops\/klass.hpp\"\n-#include \"oops\/method.hpp\"\n-#include \"oops\/objArrayKlass.hpp\"\n-#include \"oops\/objArrayOop.hpp\"\n-#include \"oops\/oop.hpp\"\n-#include \"oops\/oopsHierarchy.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"runtime\/globals.hpp\"\n-#include \"runtime\/handles.hpp\"\n-#include \"runtime\/javaThread.hpp\"\n-#include \"runtime\/mutex.hpp\"\n-#include \"runtime\/orderAccess.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"runtime\/timer.hpp\"\n-#include \"utilities\/align.hpp\"\n-#include \"utilities\/bitMap.hpp\"\n-#include \"utilities\/copy.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/exceptions.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-#include \"utilities\/macros.hpp\"\n-#include \"utilities\/ostream.hpp\"\n-#include \"utilities\/ticks.hpp\"\n-\n-#ifdef TARGET_COMPILER_visCPP\n-\/\/ For Visual Studio, including the *.inline.hpp files actually\n-\/\/ increased performance.\n-#include \"memory\/allocation.inline.hpp\"\n+#include \"memory\/iterator.inline.hpp\"\n@@ -75,0 +36,2 @@\n+#include \"oops\/instanceStackChunkKlass.inline.hpp\"\n+#include \"oops\/objArrayOop.inline.hpp\"\n@@ -76,2 +39,13 @@\n-#include \"runtime\/handles.inline.hpp\"\n-#endif \/\/ TARGET_COMPILER_visCPP\n+#include \"oops\/oopHandle.inline.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#if INCLUDE_SHENANDOAHGC\n+#include \"gc\/shenandoah\/shenandoahBarrierSet.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#endif\n+#if INCLUDE_ZGC\n+#include \"gc\/z\/zBarrier.inline.hpp\"\n+#include \"gc\/z\/zGeneration.inline.hpp\"\n+#include \"gc\/z\/zHeap.inline.hpp\"\n+#endif\n","filename":"src\/hotspot\/share\/precompiled\/precompiled.hpp","additions":20,"deletions":46,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-#include \"foreignGlobals.hpp\"\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"oops\/oopsHierarchy.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"oops\/oopsHierarchy.hpp\"\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"classfile\/javaClasses.hpp\"\n@@ -48,1 +47,0 @@\n-#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"classfile\/classLoaderData.hpp\"\n@@ -64,1 +63,0 @@\n-#include \"oops\/recordComponent.hpp\"\n@@ -68,0 +66,1 @@\n+#include \"oops\/recordComponent.hpp\"\n@@ -76,0 +75,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -78,0 +78,1 @@\n+#include \"runtime\/handshake.hpp\"\n@@ -80,2 +81,0 @@\n-#include \"runtime\/deoptimization.hpp\"\n-#include \"runtime\/handshake.hpp\"\n@@ -95,1 +94,0 @@\n-#include \"runtime\/vmOperations.hpp\"\n@@ -97,0 +95,1 @@\n+#include \"runtime\/vmOperations.hpp\"\n@@ -1180,1 +1179,1 @@\n-      Klass* k = InstanceKlass::cast(klass)->local_interfaces()->at(index);\n+      InstanceKlass* k = InstanceKlass::cast(klass)->local_interfaces()->at(index);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -39,1 +40,0 @@\n-#include \"runtime\/globals_extension.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-#include \"cds\/cdsConfig.hpp\"\n@@ -26,0 +25,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"classfile\/stringTable.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"classfile\/stringTable.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-#include \"runtime\/vmThread.hpp\"\n@@ -65,0 +64,1 @@\n+#include \"runtime\/vmThread.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"oops\/oopHandle.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"oops\/oopHandle.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"prims\/jvmtiEventController.hpp\"\n@@ -44,1 +43,0 @@\n-#include \"runtime\/vmThread.hpp\"\n@@ -46,0 +44,1 @@\n+#include \"runtime\/vmThread.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-#include \"prims\/jvmtiEventController.hpp\"\n@@ -64,1 +63,0 @@\n-#include \"runtime\/objectMonitor.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"runtime\/mutexLocker.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiManageCapabilities.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"classfile\/klassFactory.hpp\"\n@@ -34,1 +35,0 @@\n-#include \"classfile\/klassFactory.hpp\"\n@@ -58,1 +58,0 @@\n-#include \"prims\/resolvedMethodTable.hpp\"\n@@ -60,0 +59,1 @@\n+#include \"prims\/resolvedMethodTable.hpp\"\n@@ -1361,1 +1361,3 @@\n-\n+    size_t avail_mem = 0;\n+    \/\/ Return value ignored - defaulting to 0 on failure.\n+    (void)os::available_memory(avail_mem);\n@@ -1363,2 +1365,2 @@\n-      (\"loading name=%s kind=%d (avail_mem=\" UINT64_FORMAT \"K)\",\n-       the_class->external_name(), _class_load_kind, os::available_memory() >> 10);\n+      (\"loading name=%s kind=%d (avail_mem=%zuK)\",\n+       the_class->external_name(), _class_load_kind, avail_mem >> 10);\n@@ -1528,1 +1530,2 @@\n-\n+    \/\/ Return value ignored - defaulting to 0 on failure.\n+    (void)os::available_memory(avail_mem);\n@@ -1530,1 +1533,1 @@\n-      (\"loaded name=%s (avail_mem=\" UINT64_FORMAT \"K)\", the_class->external_name(), os::available_memory() >> 10);\n+      (\"loaded name=%s (avail_mem=%zuK)\", the_class->external_name(), avail_mem >> 10);\n@@ -4438,0 +4441,3 @@\n+    size_t avail_mem = 0;\n+    \/\/ Return value ignored - defaulting to 0 on failure.\n+    (void)os::available_memory(avail_mem);\n@@ -4439,2 +4445,2 @@\n-      (\"redefined name=%s, count=%d (avail_mem=\" UINT64_FORMAT \"K)\",\n-       the_class->external_name(), java_lang_Class::classRedefinedCount(the_class->java_mirror()), os::available_memory() >> 10);\n+      (\"redefined name=%s, count=%d (avail_mem=%zuK)\",\n+       the_class->external_name(), java_lang_Class::classRedefinedCount(the_class->java_mirror()), avail_mem >> 10);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-#include \"prims\/jvmtiEventController.hpp\"\n@@ -64,1 +63,0 @@\n-#include \"runtime\/timerTrace.hpp\"\n@@ -66,0 +64,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -67,1 +66,0 @@\n-#include \"runtime\/vmThread.hpp\"\n@@ -69,1 +67,1 @@\n-#include \"utilities\/objectBitSet.inline.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n@@ -71,0 +69,1 @@\n+#include \"utilities\/objectBitSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiTrace.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"runtime\/handles.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiUtil.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"interpreter\/oopMapCache.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"interpreter\/oopMapCache.hpp\"\n@@ -55,1 +55,0 @@\n-#include \"runtime\/timerTrace.hpp\"\n@@ -60,0 +59,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"runtime\/frame.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"runtime\/frame.hpp\"\n","filename":"src\/hotspot\/share\/prims\/methodHandles.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -31,1 +30,0 @@\n-#include \"oops\/typeArrayOop.inline.hpp\"\n@@ -33,1 +31,1 @@\n-#include \"prims\/foreignGlobals.inline.hpp\"\n+#include \"oops\/typeArrayOop.inline.hpp\"\n@@ -35,0 +33,2 @@\n+#include \"prims\/foreignGlobals.inline.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/nativeEntryPoint.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-#include \"prims\/jvmtiAgentList.hpp\"\n@@ -41,0 +40,1 @@\n+#include \"prims\/jvmtiAgentList.hpp\"\n@@ -43,1 +43,0 @@\n-#include \"prims\/unsafe.hpp\"\n@@ -45,0 +44,1 @@\n+#include \"prims\/unsafe.hpp\"\n","filename":"src\/hotspot\/share\/prims\/nativeLookup.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"oops\/oop.inline.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"oops\/oop.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/stackwalk.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-#include \"runtime\/vmOperations.hpp\"\n@@ -57,0 +56,1 @@\n+#include \"runtime\/vmOperations.hpp\"\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-#include <cstdint>\n-\n@@ -34,0 +32,2 @@\n+#include <cstdint>\n+\n","filename":"src\/hotspot\/share\/prims\/vmstorage.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"prims\/whitebox.inline.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"prims\/whitebox.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/wbtestmethods\/parserTests.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -129,1 +129,0 @@\n-#include \"osContainer_linux.hpp\"\n@@ -131,0 +130,1 @@\n+#include \"osContainer_linux.hpp\"\n@@ -2508,2 +2508,2 @@\n-  LINUX_ONLY(return os::Linux::physical_memory();)\n-  return os::physical_memory();\n+  LINUX_ONLY(return static_cast<jlong>(os::Linux::physical_memory());)\n+  return static_cast<jlong>(os::physical_memory());\n@@ -2514,1 +2514,4 @@\n-  return os::available_memory();\n+  size_t avail_mem = 0;\n+  \/\/ Return value ignored - defaulting to 0 on failure.\n+  (void)os::available_memory(avail_mem);\n+  return static_cast<jlong>(avail_mem);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -274,0 +274,12 @@\n+      #elif _MSC_VER == 1939\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.9 (VS2022)\"\n+      #elif _MSC_VER == 1940\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.10 (VS2022)\"\n+      #elif _MSC_VER == 1941\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.11 (VS2022)\"\n+      #elif _MSC_VER == 1942\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.12 (VS2022)\"\n+      #elif _MSC_VER == 1943\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.13 (VS2022)\"\n+      #elif _MSC_VER == 1944\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.14 (VS2022)\"\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -570,0 +570,2 @@\n+  { \"PretenureSizeThreshold\",       JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n+\n@@ -1520,1 +1522,1 @@\n-      phys_mem = os::physical_memory();\n+      phys_mem = static_cast<julong>(os::physical_memory());\n@@ -1526,1 +1528,1 @@\n-    phys_mem = FLAG_IS_DEFAULT(MaxRAM) ? MIN2(os::physical_memory(), (julong)MaxRAM)\n+    phys_mem = FLAG_IS_DEFAULT(MaxRAM) ? MIN2(static_cast<julong>(os::physical_memory()), (julong)MaxRAM)\n@@ -1648,1 +1650,2 @@\n-  julong total_memory = os::physical_memory();\n+  size_t phys_mem = os::physical_memory();\n+  julong total_memory = static_cast<julong>(phys_mem);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/basicLock.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/barrierSet.hpp\"\n@@ -33,1 +34,0 @@\n-#include \"gc\/shared\/barrierSet.hpp\"\n@@ -42,1 +42,0 @@\n-#include \"oops\/oopsHierarchy.hpp\"\n@@ -44,0 +43,1 @@\n+#include \"oops\/oopsHierarchy.hpp\"\n@@ -60,1 +60,0 @@\n-#include \"runtime\/smallRegisterMap.inline.hpp\"\n@@ -62,0 +61,1 @@\n+#include \"runtime\/smallRegisterMap.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"compiler\/oopMap.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"oops\/oop.inline.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"oops\/oop.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/continuationWrapper.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"runtime\/cpuTimeCounters.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"runtime\/cpuTimeCounters.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/cpuTimeCounters.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"interpreter\/bytecode.hpp\"\n@@ -71,1 +70,0 @@\n-#include \"runtime\/fieldDescriptor.hpp\"\n@@ -94,1 +92,0 @@\n-#include \"runtime\/vframeArray.hpp\"\n@@ -96,0 +93,1 @@\n+#include \"runtime\/vframeArray.hpp\"\n@@ -1479,1 +1477,1 @@\n-  InstanceKlass* super = klass->superklass();\n+  InstanceKlass* super = klass->java_super();\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"oops\/fieldStreams.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -32,0 +32,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagAccess.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"oops\/metadata.hpp\"\n-#include \"runtime\/os.hpp\"\n@@ -31,0 +29,1 @@\n+#include \"oops\/metadata.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"runtime\/os.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsCompiler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"memory\/allocation.inline.hpp\"\n@@ -27,0 +26,2 @@\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n@@ -32,0 +32,1 @@\n+#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n@@ -33,2 +34,0 @@\n-#include \"gc\/shared\/referenceProcessor.hpp\"\n-#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLimit.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"runtime\/globals_extension.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLookup.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-#include \"runtime\/sharedRuntime.hpp\"\n@@ -55,0 +54,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"oops\/stackChunkOop.inline.hpp\"\n@@ -35,0 +34,1 @@\n+#include \"oops\/stackChunkOop.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/frame.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"runtime\/javaThread.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/handles.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"utilities\/formatBuffer.hpp\"\n@@ -45,0 +44,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -198,4 +198,1 @@\n-  \/\/ Initialize TrainingData only we're recording\/replaying\n-  if (TrainingData::have_data() || TrainingData::need_data()) {\n-   TrainingData::initialize();\n-  }\n+  TrainingData::initialize();\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"gc\/shared\/collectedHeap.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"compiler\/compilationPolicy.hpp\"\n@@ -78,0 +79,1 @@\n+#include \"runtime\/vm_version.hpp\"\n@@ -80,1 +82,0 @@\n-#include \"runtime\/vm_version.hpp\"\n@@ -506,0 +507,6 @@\n+  #if INCLUDE_CDS\n+  if (AOTVerifyTrainingData) {\n+    TrainingData::verify();\n+  }\n+  #endif\n+\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -409,1 +409,1 @@\n-              entry_point = method->adapter()->get_i2c_entry();\n+              entry_point = method->get_i2c_entry();\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"compiler\/compileTask.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"compiler\/compileTask.hpp\"\n@@ -91,1 +91,0 @@\n-#include \"runtime\/vframeArray.hpp\"\n@@ -93,1 +92,1 @@\n-#include \"runtime\/vmThread.hpp\"\n+#include \"runtime\/vframeArray.hpp\"\n@@ -95,0 +94,1 @@\n+#include \"runtime\/vmThread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-#include \"runtime\/stackWatermarkSet.hpp\"\n@@ -43,0 +42,1 @@\n+#include \"runtime\/stackWatermarkSet.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"runtime\/keepStackGCProcessed.hpp\"\n@@ -28,1 +29,0 @@\n-#include \"runtime\/keepStackGCProcessed.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/keepStackGCProcessed.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -266,1 +266,1 @@\n-  MUTEX_DEFL(TrainingData_lock               , PaddedMutex  , MethodCompileQueue_lock);\n+  MUTEX_DEFN(TrainingData_lock               , PaddedMutex  , nosafepoint);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-#include \"runtime\/objectMonitor.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-#include \"runtime\/vmOperations.hpp\"\n@@ -70,0 +69,1 @@\n+#include \"runtime\/vmOperations.hpp\"\n@@ -92,1 +92,0 @@\n-# include <signal.h>\n@@ -94,0 +93,1 @@\n+# include <signal.h>\n@@ -111,1 +111,1 @@\n-int os::snprintf_checked(char* buf, size_t len, const char* fmt, ...) {\n+void os::snprintf_checked(char* buf, size_t len, const char* fmt, ...) {\n@@ -116,1 +116,0 @@\n-  assert(result >= 0, \"os::snprintf error\");\n@@ -118,1 +117,0 @@\n-  return result;\n@@ -122,0 +120,2 @@\n+  assert(buf != nullptr || len == 0, \"Valid buffer and length must be given\");\n+  assert(fmt != nullptr, \"Missing format string\");\n@@ -123,1 +123,1 @@\n-  \/\/ If an encoding error occurred (result < 0) then it's not clear\n+  \/\/ If an error occurred (result < 0) then it's not clear\n@@ -125,1 +125,1 @@\n-  if ((result < 0) && (len > 0)) {\n+  if ((result < 0) && (len > 0) && (buf != nullptr)) {\n@@ -128,0 +128,1 @@\n+  assert(result >= 0, \"os::vsnprintf error: %s\", strerror(errno));\n@@ -1186,1 +1187,2 @@\n-  size_t mem = physical_memory()\/G;\n+  size_t phys_mem = physical_memory();\n+  size_t mem = phys_mem\/G;\n@@ -1188,1 +1190,1 @@\n-    mem = physical_memory()\/M;\n+    mem = phys_mem\/M;\n@@ -1943,1 +1945,1 @@\n-\n+  size_t phys_mem = os::physical_memory();\n@@ -1946,1 +1948,1 @@\n-      (os::physical_memory() >= (server_memory - missing_memory))) {\n+      (phys_mem >= (server_memory - missing_memory))) {\n@@ -2205,1 +2207,1 @@\n-julong os::used_memory() {\n+bool os::used_memory(size_t& value) {\n@@ -2210,1 +2212,4 @@\n-      return mem_usage;\n+      value = static_cast<size_t>(mem_usage);\n+      return true;\n+    } else {\n+      return false;\n@@ -2214,1 +2219,6 @@\n-  return os::physical_memory() - os::available_memory();\n+  size_t avail_mem = 0;\n+  \/\/ Return value ignored - defaulting to 0 on failure.\n+  (void)os::available_memory(avail_mem);\n+  size_t phys_mem = os::physical_memory();\n+  value = phys_mem - avail_mem;\n+  return true;\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":24,"deletions":14,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -335,3 +335,3 @@\n-  static julong available_memory();\n-  static julong used_memory();\n-  static julong free_memory();\n+  [[nodiscard]] static bool available_memory(size_t& value);\n+  [[nodiscard]] static bool used_memory(size_t& value);\n+  [[nodiscard]] static bool free_memory(size_t& value);\n@@ -339,2 +339,2 @@\n-  static jlong total_swap_space();\n-  static jlong free_swap_space();\n+  [[nodiscard]] static bool total_swap_space(size_t& value);\n+  [[nodiscard]] static bool free_swap_space(size_t& value);\n@@ -342,1 +342,1 @@\n-  static julong physical_memory();\n+  static size_t physical_memory();\n@@ -807,2 +807,0 @@\n-  static int vsnprintf(char* buf, size_t len, const char* fmt, va_list args) ATTRIBUTE_PRINTF(3, 0);\n-  static int snprintf(char* buf, size_t len, const char* fmt, ...) ATTRIBUTE_PRINTF(3, 4);\n@@ -810,3 +808,13 @@\n-  \/\/ Performs snprintf and asserts the result is non-negative (so there was not\n-  \/\/ an encoding error) and that the output was not truncated.\n-  static int snprintf_checked(char* buf, size_t len, const char* fmt, ...) ATTRIBUTE_PRINTF(3, 4);\n+  \/\/ Performs vsnprintf and asserts the result is non-negative (so there was not\n+  \/\/ an encoding error or any other kind of usage error).\n+  [[nodiscard]]\n+  ATTRIBUTE_PRINTF(3, 0)\n+  static int vsnprintf(char* buf, size_t len, const char* fmt, va_list args);\n+  \/\/ Delegates to vsnprintf.\n+  [[nodiscard]]\n+  ATTRIBUTE_PRINTF(3, 4)\n+  static int snprintf(char* buf, size_t len, const char* fmt, ...);\n+\n+  \/\/ Delegates to snprintf and asserts that the output was not truncated.\n+  ATTRIBUTE_PRINTF(3, 4)\n+  static void snprintf_checked(char* buf, size_t len, const char* fmt, ...);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":19,"deletions":11,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-#include \"jvm.h\"\n@@ -47,0 +46,1 @@\n+#include \"jvm.h\"\n@@ -2513,1 +2513,0 @@\n-AdapterHandlerEntry* AdapterHandlerLibrary::_abstract_method_handler = nullptr;\n@@ -2549,15 +2548,0 @@\n-void AdapterHandlerLibrary::create_abstract_method_handler() {\n-  assert_lock_strong(AdapterHandlerLibrary_lock);\n-  \/\/ Create a special handler for abstract methods.  Abstract methods\n-  \/\/ are never compiled so an i2c entry is somewhat meaningless, but\n-  \/\/ throw AbstractMethodError just in case.\n-  \/\/ Pass wrong_method_abstract for the c2i transitions to return\n-  \/\/ AbstractMethodError for invalid invocations.\n-  address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();\n-  _abstract_method_handler = AdapterHandlerLibrary::new_entry(AdapterFingerPrint::allocate(0, nullptr));\n-  _abstract_method_handler->set_entry_points(SharedRuntime::throw_AbstractMethodError_entry(),\n-                                             wrong_method_abstract,\n-                                             wrong_method_abstract,\n-                                             nullptr);\n-}\n-\n@@ -2567,1 +2551,0 @@\n-    MutexLocker mu(AdapterHandlerLibrary_lock);\n@@ -2570,1 +2553,0 @@\n-    create_abstract_method_handler();\n@@ -2630,3 +2612,0 @@\n-  if (method->is_abstract()) {\n-    return _abstract_method_handler;\n-  }\n@@ -2730,0 +2709,1 @@\n+  assert(!method->is_abstract(), \"abstract methods do not have adapters\");\n@@ -3500,7 +3480,0 @@\n-bool AdapterHandlerLibrary::is_abstract_method_adapter(AdapterHandlerEntry* entry) {\n-  if (entry == _abstract_method_handler) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":2,"deletions":29,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -786,1 +786,0 @@\n-  static AdapterHandlerEntry* _abstract_method_handler;\n@@ -804,1 +803,0 @@\n-  static void create_abstract_method_handler();\n@@ -834,2 +832,0 @@\n-  static bool is_abstract_method_adapter(AdapterHandlerEntry* adapter);\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-#include \"runtime\/sharedRuntime.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"oops\/instanceStackChunkKlass.inline.hpp\"\n@@ -37,1 +38,0 @@\n-#include \"oops\/instanceStackChunkKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"asm\/macroAssembler.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/stubCodeGenerator.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"runtime\/timerTrace.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-#include \"runtime\/objectMonitor.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"runtime\/atomic.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"runtime\/atomic.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-#include \"compiler\/compileTask.hpp\"\n@@ -42,0 +41,1 @@\n+#include \"compiler\/compileTask.hpp\"\n@@ -94,1 +94,0 @@\n-#include \"runtime\/threadSMR.inline.hpp\"\n@@ -96,0 +95,1 @@\n+#include \"runtime\/threadSMR.inline.hpp\"\n@@ -99,1 +99,0 @@\n-#include \"runtime\/vmOperations.hpp\"\n@@ -101,0 +100,1 @@\n+#include \"runtime\/vmOperations.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-#include \"runtime\/objectMonitor.hpp\"\n@@ -54,1 +53,0 @@\n-#include \"runtime\/vframeArray.hpp\"\n@@ -56,0 +54,1 @@\n+#include \"runtime\/vframeArray.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"runtime\/vframeArray.hpp\"\n@@ -45,0 +44,1 @@\n+#include \"runtime\/vframeArray.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-#include \"runtime\/vframeArray.hpp\"\n@@ -47,0 +46,1 @@\n+#include \"runtime\/vframeArray.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"logging\/logStream.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"logging\/logStream.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"runtime\/vmOperation.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"runtime\/vmOperation.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -59,1 +58,0 @@\n-#include \"oops\/constMethod.hpp\"\n@@ -61,0 +59,1 @@\n+#include \"oops\/constMethod.hpp\"\n@@ -102,1 +101,0 @@\n-#include \"runtime\/vmStructs.hpp\"\n@@ -104,0 +102,1 @@\n+#include \"runtime\/vmStructs.hpp\"\n@@ -324,1 +323,1 @@\n-  nonstatic_field(JNIid,                       _holder,                                       Klass*)                                \\\n+  nonstatic_field(JNIid,                       _holder,                                       InstanceKlass*)                        \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2116,1 +2116,1 @@\n-  os::snprintf(path, buf_size, \"%s.p%d\", base_path, seq);\n+  os::snprintf_checked(path, buf_size, \"%s.p%d\", base_path, seq);\n@@ -2615,1 +2615,4 @@\n-    julong max_threads = os::free_memory() \/ (20 * M);\n+    size_t free_memory = 0;\n+    \/\/ Return value ignored - defaulting to 0 on failure.\n+    (void)os::free_memory(free_memory);\n+    julong max_threads = free_memory \/ (20 * M);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -978,1 +978,1 @@\n-    return os::physical_memory();\n+    return static_cast<jlong>(os::physical_memory());\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+FORBID_C_FUNCTION(int snprintf(char*, size_t, const char*, ...), \"use os::snprintf\");\n","filename":"src\/hotspot\/share\/utilities\/forbiddenFunctions.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -644,8 +644,0 @@\n-\/\/ the fancy casts are a hopefully portable way\n-\/\/ to do unsigned 32 to 64 bit type conversion\n-inline void set_low (jlong* value, jint low )    { *value &= (jlong)0xffffffff << 32;\n-                                                   *value |= (jlong)(julong)(juint)low; }\n-\n-inline void set_high(jlong* value, jint high)    { *value &= (jlong)(julong)(juint)0xffffffff;\n-                                                   *value |= (jlong)high       << 32; }\n-\n@@ -653,4 +645,4 @@\n-  jlong result = 0; \/\/ initialization to avoid warning\n-  set_high(&result, h);\n-  set_low(&result,  l);\n-  return result;\n+  \/\/ First cast jint values to juint, so cast to julong will zero-extend.\n+  julong high = (julong)(juint)h << 32;\n+  julong low = (julong)(juint)l;\n+  return (jlong)(high | low);\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"memory\/allocation.inline.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/numberSeq.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/ostream.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/numberSeq.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-\/\/ ALLOCATOR must check for oom and exit, as RBTree does not handle the allocation failing.\n@@ -471,1 +470,3 @@\n-    assert(node_place != nullptr, \"rb-tree allocator must exit on failure\");\n+    if (node_place == nullptr) {\n+      return nullptr;\n+    }\n@@ -477,1 +478,3 @@\n-    assert(node_place != nullptr, \"rb-tree allocator must exit on failure\");\n+    if (node_place == nullptr) {\n+      return nullptr;\n+    }\n@@ -488,1 +491,2 @@\n-  void upsert(const K& key, const V& val, const RBNode<K, V>* hint_node = nullptr) {\n+  \/\/ Returns false if and only if allocation of a new node failed.\n+  bool upsert(const K& key, const V& val, const RBNode<K, V>* hint_node = nullptr) {\n@@ -493,1 +497,1 @@\n-      return;\n+      return true;\n@@ -497,0 +501,3 @@\n+    if (node == nullptr) {\n+      return false;\n+    }\n@@ -498,0 +505,1 @@\n+    return true;\n@@ -548,1 +556,1 @@\n-template <MemTag mem_tag>\n+template <MemTag mem_tag, AllocFailType strategy>\n@@ -553,1 +561,1 @@\n-    if (allocation == nullptr) {\n+    if (allocation == nullptr && strategy == AllocFailStrategy::EXIT_OOM) {\n@@ -563,2 +571,2 @@\n-template <typename K, typename V, typename COMPARATOR, MemTag mem_tag>\n-using RBTreeCHeap = RBTree<K, V, COMPARATOR, RBTreeCHeapAllocator<mem_tag>>;\n+template <typename K, typename V, typename COMPARATOR, MemTag mem_tag, AllocFailType strategy = AllocFailStrategy::EXIT_OOM>\n+using RBTreeCHeap = RBTree<K, V, COMPARATOR, RBTreeCHeapAllocator<mem_tag, strategy>>;\n","filename":"src\/hotspot\/share\/utilities\/rbTree.hpp","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-      os::snprintf(extended_resource_info_at_startup, sizeof(extended_resource_info_at_startup), \"%s\", result_info);\n+      os::snprintf_checked(extended_resource_info_at_startup, sizeof(extended_resource_info_at_startup), \"%s\", result_info);\n@@ -76,1 +76,1 @@\n-      os::snprintf(host_information, sizeof(host_information), \"%s\", result_info);\n+      os::snprintf_checked(host_information, sizeof(host_information), \"%s\", result_info);\n","filename":"src\/hotspot\/share\/utilities\/virtualizationSupport.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -1052,3 +1053,9 @@\n-        Class<?> c = defineClass2(this, name, b, b.position(), len, protectionDomain, source);\n-        postDefineClass(c, protectionDomain);\n-        return c;\n+\n+        SharedSecrets.getJavaNioAccess().acquireSession(b);\n+        try {\n+            Class<?> c = defineClass2(this, name, b, b.position(), len, protectionDomain, source);\n+            postDefineClass(c, protectionDomain);\n+            return c;\n+        } finally {\n+            SharedSecrets.getJavaNioAccess().releaseSession(b);\n+        }\n@@ -1060,0 +1067,2 @@\n+    \/\/ Warning: Before calling this method, the provided ByteBuffer must be guarded\n+    \/\/          via JavaNioAccess::(acquire|release)Session\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,3 @@\n-     * Constructs an UnsupportedOperationException with no detail message.\n+     * Constructs a new {@code UnsupportedOperationException} with {@code null}\n+     * as its detail message. The cause is not initialized, and may subsequently\n+     * be initialized by a call to {@link #initCause(Throwable)}.\n@@ -46,2 +48,3 @@\n-     * Constructs an UnsupportedOperationException with the specified\n-     * detail message.\n+     * Constructs a new {@code UnsupportedOperationException} with the specified\n+     * detail message. The cause is not initialized, and may subsequently be\n+     * initialized by a call to {@link #initCause(Throwable)}.\n@@ -56,2 +59,2 @@\n-     * Constructs a new exception with the specified detail message and\n-     * cause.\n+     * Constructs a new {@code UnsupportedOperationException} with the specified\n+     * detail message and cause.\n@@ -76,2 +79,3 @@\n-     * Constructs a new exception with the specified cause and a detail\n-     * message of {@code (cause==null ? null : cause.toString())} (which\n+     * Constructs a new {@code UnsupportedOperationException} with the specified\n+     * cause and a detail message of\n+     * {@code (cause==null ? null : cause.toString())} (which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/UnsupportedOperationException.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -67,2 +67,2 @@\n-     * {@return the access flags, as a bit mask}  It is in the range of unsigned\n-     * short, {@code [0, 0xFFFF]}.\n+     * {@return the access flags, as a bit mask}  It is a {@link\n+     * java.lang.classfile##u2 u2} value.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AccessFlags.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,0 +69,3 @@\n+     * @throws IllegalArgumentException if {@code major} or {@code minor} is not\n+     *         {@link java.lang.classfile##u2 u2}; {@code minor} may be {@code\n+     *         -1} to indicate {@value ClassFile#PREVIEW_MINOR_VERSION}\n@@ -80,0 +83,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -191,0 +196,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -224,0 +231,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -263,0 +272,2 @@\n+     * @throws IllegalArgumentException if {@code methodFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -287,0 +298,2 @@\n+     * @throws IllegalArgumentException if {@code methodFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -307,0 +320,2 @@\n+     * @throws IllegalArgumentException if {@code methodFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -336,0 +351,2 @@\n+     * @throws IllegalArgumentException if {@code methodFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassBuilder.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -63,2 +63,2 @@\n-     * {@return the major version}  It is in the range of unsigned short, {@code\n-     * [0, 65535]}.\n+     * {@return the major version}  It is a {@link java.lang.classfile##u2 u2}\n+     * value.\n@@ -74,2 +74,2 @@\n-     * {@return the minor version}  It is in the range of unsigned short, {@code\n-     * [0, 65535]}.\n+     * {@return the minor version}  It is a {@link java.lang.classfile##u2 u2}\n+     * value.\n@@ -80,1 +80,3 @@\n-     * {@return a {@link ClassFileVersion} element}\n+     * {@return a {@link ClassFileVersion} element}  The minor version number\n+     * may be {@code -1} to represent {@value ClassFile#PREVIEW_MINOR_VERSION}.\n+     *\n@@ -83,0 +85,3 @@\n+     * @throws IllegalArgumentException if the major version or the minor\n+     *         version is not {@link java.lang.classfile##u2 u2}; the minor\n+     *         version may be {@code -1}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFileVersion.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -87,2 +87,2 @@\n-     * {@return the major version of this class}  It is in the range of unsigned\n-     * short, {@code [0, 65535]}.\n+     * {@return the major version of this class}  It is a {@link\n+     * java.lang.classfile##u2 u2} value.\n@@ -95,2 +95,2 @@\n-     * {@return the minor version of this class}  It is in the range of unsigned\n-     * short, {@code [0, 65535]}.\n+     * {@return the minor version of this class}  It is a {@link\n+     * java.lang.classfile##u2 u2} value.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassModel.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -156,2 +156,3 @@\n-     * {@return the unsigned short at the specified offset within the {@code\n-     * class} file}  Reads a 2-byte value and zero-extends it to an {@code int}.\n+     * {@return the {@link java.lang.classfile##u2 u2} at the specified offset\n+     * within the {@code class} file}  Reads a 2-byte value and zero-extends it\n+     * to an {@code int}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassReader.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -468,1 +468,1 @@\n-     *         void} or {@code slot} is out of range\n+     *         void} or {@code slot} is not {@link java.lang.classfile##u2 u2}\n@@ -482,1 +482,2 @@\n-     *         void} or {@code slot} is out of range\n+     *         void} or {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -814,0 +815,2 @@\n+     * @throws IllegalArgumentException if {@code line} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -910,0 +913,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -929,1 +934,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -949,1 +955,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -977,1 +984,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -1002,1 +1010,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -1061,1 +1070,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -1131,1 +1141,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -1387,1 +1398,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -1452,1 +1464,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -1699,1 +1712,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -1764,1 +1778,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -2396,1 +2411,3 @@\n-     * @throws IllegalArgumentException if {@code slot} or {@code val} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2} or {@code val} is out of range of\n+     *         {@link TypeKind#SHORT short}\n@@ -2413,1 +2430,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -2766,1 +2784,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -3004,1 +3023,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -3106,1 +3126,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":38,"deletions":17,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -59,0 +59,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -72,0 +74,2 @@\n+     * @throws IllegalArgumentException if any flag cannot be applied to the\n+     *         {@link AccessFlag.Location#FIELD} location\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/FieldBuilder.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,1 +61,2 @@\n-     * @throws IllegalArgumentException if the {@link ClassFile#ACC_STATIC\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}, or the {@link ClassFile#ACC_STATIC\n@@ -77,1 +78,2 @@\n-     *         ACC_STATIC} flag is modified\n+     *         ACC_STATIC} flag is modified, or if any flag cannot be applied to\n+     *         the {@link AccessFlag.Location#METHOD} location\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/MethodBuilder.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.classfile.impl.Util;\n@@ -355,0 +356,2 @@\n+         * @throws IllegalArgumentException if {@code typeParameterIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -363,0 +366,2 @@\n+         * @throws IllegalArgumentException if {@code typeParameterIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -371,0 +376,2 @@\n+         * @throws IllegalArgumentException if {@code typeParameterIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -379,0 +386,2 @@\n+         * @throws IllegalArgumentException if {@code supertypeIndex} is not\n+         *         {@link java.lang.classfile##u2 u2}\n@@ -390,0 +399,2 @@\n+         * @throws IllegalArgumentException if {@code typeParameterIndex} or\n+         *         {@code boundIndex} is not {@link java.lang.classfile##u1 u1}\n@@ -400,0 +411,2 @@\n+         * @throws IllegalArgumentException if {@code typeParameterIndex} or\n+         *         {@code boundIndex} is not {@link java.lang.classfile##u1 u1}\n@@ -410,0 +423,2 @@\n+         * @throws IllegalArgumentException if {@code typeParameterIndex} or\n+         *         {@code boundIndex} is not {@link java.lang.classfile##u1 u1}\n@@ -451,0 +466,2 @@\n+         * @throws IllegalArgumentException if {@code formalParameterIndex} is\n+         *         not {@link java.lang.classfile##u1 u1}\n@@ -460,0 +477,2 @@\n+         * @throws IllegalArgumentException if {@code throwsTargetIndex} is\n+         *         not {@link java.lang.classfile##u2 u2}\n@@ -495,0 +514,2 @@\n+         * @throws IllegalArgumentException if {@code exceptionTableIndex} is\n+         *         not {@link java.lang.classfile##u2 u2}\n@@ -555,0 +576,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -564,0 +587,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -574,0 +599,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -584,0 +611,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -594,0 +623,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -604,0 +635,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -795,0 +828,2 @@\n+         * @throws IllegalArgumentException if {@code index} is not {@link\n+         *         java.lang.classfile##u2 u2}\n@@ -962,0 +997,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -964,1 +1001,1 @@\n-\n+            Util.checkU1(typeArgumentIndex, \"type argument index\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/TypeAnnotation.java","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.classfile.impl.Util;\n@@ -169,0 +170,2 @@\n+     * @throws IllegalArgumentException if {@code startPc}, {@code endPc}, or\n+     *         {@code flags} is not {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/CharacterRangeInfo.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -71,2 +71,1 @@\n-     * of the inner class}  It is in the range of unsigned short, {@code [0,\n-     * 0xFFFF]}.\n+     * of the inner class}  It is a {@link java.lang.classfile##u2 u2} value.\n@@ -107,0 +106,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -119,1 +120,3 @@\n-     * @throws IllegalArgumentException if {@code innerClass} or {@code outerClass} represents a primitive type\n+     * @throws IllegalArgumentException if {@code innerClass} or {@code outerClass}\n+     *         represents a primitive type, or if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/InnerClassInfo.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+     * @throws IllegalArgumentException if {@code startPc} or {@code lineNumber}\n+     *         is not {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LineNumberInfo.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-     * {@return the access flags, as a bit mask}  It is in the range of unsigned\n-     * short, {@code [0, 0xFFFF]}.\n+     * {@return the access flags, as a bit mask}  It is a {@link\n+     * java.lang.classfile##u2 u2} value.\n@@ -88,0 +88,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -108,0 +110,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/MethodParameterInfo.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -84,2 +84,2 @@\n-     * {@return the module flags of the module, as a bit mask}  It is in the\n-     * range of unsigned short, {@code [0, 0xFFFF]}.\n+     * {@return the module flags of the module, as a bit mask}  It is a {@link\n+     * java.lang.classfile##u2 u2} value.\n@@ -173,0 +173,2 @@\n+     * @throws IllegalArgumentException if {@code moduleFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -233,0 +235,2 @@\n+         * @throws IllegalArgumentException if {@code flagsMask} is not {@link\n+         *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleAttribute.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-     * It is in the range of unsigned short, {@code [0, 0xFFFF]}.\n+     * It is a {@link java.lang.classfile##u2 u2} value.\n@@ -106,0 +106,2 @@\n+     * @throws IllegalArgumentException if {@code exportFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -134,0 +136,2 @@\n+     * @throws IllegalArgumentException if {@code exportFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -164,0 +168,2 @@\n+     * @throws IllegalArgumentException if {@code exportFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -194,0 +200,2 @@\n+     * @throws IllegalArgumentException if {@code exportFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleExportInfo.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-     * It is in the range of unsigned short, {@code [0, 0xFFFF]}.\n+     * It is a {@link java.lang.classfile##u2 u2} value.\n@@ -112,0 +112,2 @@\n+     * @throws IllegalArgumentException if {@code opensFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -140,0 +142,2 @@\n+     * @throws IllegalArgumentException if {@code opensFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -169,0 +173,2 @@\n+     * @throws IllegalArgumentException if {@code opensFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -197,0 +203,2 @@\n+     * @throws IllegalArgumentException if {@code opensFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleOpenInfo.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-     * It is in the range of unsigned short, {@code [0, 0xFFFF]}.\n+     * It is a {@link java.lang.classfile##u2 u2} value.\n@@ -100,0 +100,2 @@\n+     * @throws IllegalArgumentException if {@code requiresFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -124,0 +126,2 @@\n+     * @throws IllegalArgumentException if {@code requiresFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleRequireInfo.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -81,2 +81,2 @@\n-     * {@return the module resolution flags}  It is in the range of unsigned\n-     * short, {@code [0, 0xFFFF]}.\n+     * {@return the module resolution flags}  It is a {@link\n+     * java.lang.classfile##u2 u2} value.\n@@ -102,0 +102,2 @@\n+     * @throws IllegalArgumentException if {@code resolutionFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleResolutionAttribute.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -400,1 +400,1 @@\n-     * referring to a {@link MemberRefEntry}}  The reference kind must be\n+     * referring to a {@link MemberRefEntry}}  The reference kind is\n@@ -406,0 +406,2 @@\n+     * @throws IllegalArgumentException if {@code refKind} is not {@link\n+     *         java.lang.classfile##u1 u1}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ConstantPoolBuilder.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,0 +152,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/CharacterRange.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-     * where {@code slot} must be within {@code [0, 65535]}.\n+     * where {@code slot} must be {@link java.lang.classfile##u2 u2}.\n@@ -156,1 +156,1 @@\n-         * The value is within {@code [0, 65535]}.\n+         * It is a {@link java.lang.classfile##u2 u2} value.\n@@ -163,3 +163,3 @@\n-         * {@code slot} must be in the closed range of {@code [0, 255]} for\n-         * {@link Opcode#RET ret}, or within {@code [0, 65535]} for {@link\n-         * Opcode#RET_W wide ret}.\n+         * {@code slot} must be {@link java.lang.classfile##u1 u1} for\n+         * {@link Opcode#RET ret}, or {@link java.lang.classfile##u2 u2} for\n+         * {@link Opcode#RET_W wide ret}.\n@@ -186,1 +186,1 @@\n-         * {@code slot} must be within {@code [0, 65535]}.\n+         * {@code slot} must be {@link java.lang.classfile##u2 u2}.\n@@ -189,1 +189,2 @@\n-         * @throws IllegalArgumentException if {@code slot} is out of range\n+         * @throws IllegalArgumentException if {@code slot} is not {@link\n+         *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/DiscontinuedInstruction.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n- * <li>{@code slot} must be within {@code [0, 65535]}.\n+ * <li>{@code slot} must be {@link java.lang.classfile##u2 u2}.\n@@ -76,1 +76,1 @@\n-     * <li>{@code slot} must be within {@code [0, 65535]}.\n+     * <li>{@code slot} must be {@link java.lang.classfile##u2 u2}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/IncrementInstruction.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,2 @@\n+     * @throws IllegalArgumentException if {@code line} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LineNumber.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n- * computational}, and {@code slot} is within {@code [0, 65535]}.\n+ * computational}, and {@code slot} is {@link java.lang.classfile##u2 u2}.\n@@ -65,1 +65,1 @@\n-     * The value is within {@code [0, 65535]}.\n+     * It is a {@link java.lang.classfile##u2 u2} value.\n@@ -79,1 +79,1 @@\n-     * {@code slot} must be within {@code [0, 65535]}.\n+     * {@code slot} must be a {@link java.lang.classfile##u2 u2} value.\n@@ -84,1 +84,2 @@\n-     *         {@link TypeKind#VOID void} or {@code slot} is out of range\n+     *         {@link TypeKind#VOID void} or {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -99,2 +100,4 @@\n-     * <li>If {@code op} has size 2, {@code slot} must be within {@code [0, 255]}.\n-     * <li>If {@code op} has size 4, {@code slot} must be within {@code [0, 65535]}.\n+     * <li>If {@code op} has size 2, {@code slot} must be {@link\n+     *     java.lang.classfile##u1 u1}.\n+     * <li>If {@code op} has size 4, {@code slot} must be {@link\n+     *     java.lang.classfile##u2 u2}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LoadInstruction.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n- * Where {@code slot} is within {@code [0, 65535]}.\n+ * Where {@code slot} is {@link java.lang.classfile##u2 u2}.\n@@ -82,1 +82,1 @@\n-     * The value is within {@code [0, 65535]}.\n+     * It is a {@link java.lang.classfile##u2 u2} value.\n@@ -119,1 +119,1 @@\n-     * {@code slot} must be within {@code [0, 65535]}.\n+     * {@code slot} must be {@link java.lang.classfile##u2 u2}.\n@@ -126,1 +126,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -135,1 +136,1 @@\n-     * {@code slot} must be within {@code [0, 65535]}.\n+     * {@code slot} must be {@link java.lang.classfile##u2 u2}.\n@@ -142,1 +143,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LocalVariable.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n- * Where {@code slot} is within {@code [0, 65535]}.\n+ * Where {@code slot} is {@link java.lang.classfile##u2 u2}.\n@@ -75,1 +75,1 @@\n-     * The value is within {@code [0, 65535]}.\n+     * It is a {@link java.lang.classfile##u2 u2} value.\n@@ -112,1 +112,1 @@\n-     * {@code slot} must be within {@code [0, 65535]}.\n+     * {@code slot} must be {@link java.lang.classfile##u2 u2}.\n@@ -119,1 +119,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -128,1 +129,1 @@\n-     * {@code slot} must be within {@code [0, 65535]}.\n+     * {@code slot} must be {@link java.lang.classfile##u2 u2}.\n@@ -135,1 +136,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LocalVariableType.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n- * computational}, and {@code slot} is within {@code [0, 65535]}.\n+ * computational}, and {@code slot} is {@link java.lang.classfile##u2 u2}.\n@@ -69,1 +69,1 @@\n-     * The value is within {@code [0, 65535]}.\n+     * It is a {@link java.lang.classfile##u2 u2} value.\n@@ -85,1 +85,1 @@\n-     * {@code slot} must be within {@code [0, 65535]}.\n+     * {@code slot} must be {@link java.lang.classfile##u2 u2}.\n@@ -90,1 +90,2 @@\n-     *         TypeKind#VOID void} or {@code slot} is out of range\n+     *         TypeKind#VOID void} or {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -105,2 +106,4 @@\n-     * <li>If {@code op} has size 2, {@code slot} must be within {@code [0, 255]}.\n-     * <li>If {@code op} has size 4, {@code slot} must be within {@code [0, 65535]}.\n+     * <li>If {@code op} has size 2, {@code slot} must be {@link\n+     *     java.lang.classfile##u1 u1}.\n+     * <li>If {@code op} has size 4, {@code slot} must be {@link\n+     *     java.lang.classfile##u2 u2}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/StoreInstruction.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -276,0 +276,8 @@\n+ * The Class-File API performs checks to ensure arguments are representable in\n+ * the {@code class} file format.  A value that is lost when it is built to a\n+ * {@code class} file and re-parsed to a model is rejected with an {@link\n+ * IllegalArgumentException}.  For example, a negative value or a value over\n+ * {@code 65535} is lost when built to a {@link ##u2 u2} item, with\n+ * the range {@code [0, 65535]}.  In particular, any variable-sized table\n+ * exceeding its maximum representable size is rejected.\n+ * <p>\n@@ -277,3 +285,4 @@\n- * (except for null arguments checks). All builders and classfile elements factory\n- * methods accepts the provided information without implicit validation.\n- * However, fatal inconsistencies (like for example invalid code sequence or\n+ * (except for null and representable arguments checks). All builders and\n+ * classfile elements factory methods accepts the provided information without\n+ * implicit validation, as long as they are representable in the {@code class}\n+ * file format.  However, fatal inconsistencies (like invalid code sequence or\n@@ -282,1 +291,1 @@\n- * {@link IllegalArgumentException}.\n+ * {@code IllegalArgumentException}.\n@@ -297,3 +306,3 @@\n- * directly from raw values, with no additional conversions or validations.\n- * Following example uses intentionally wrong class name form and it is applied\n- * without any validation or conversion.\n+ * directly from raw values, with no additional conversions or validations, as\n+ * long as they are representable.  Following example uses intentionally wrong\n+ * class name form, which is applied without any validation or conversion.\n@@ -454,0 +463,23 @@\n+ * <h3 id=\"data-types\">Conventional data types<\/h3>\n+ * Chapter {@jvms 4} of the <cite>Java Virtual Machine Specification<\/cite>\n+ * defines a few conventional data types in the {@code class} file format.\n+ * They are consistently represented as {@code int} in the API model.\n+ * Out-of-bound values provided for these data types to the API result in {@link\n+ * IllegalArgumentException}.\n+ * <dl>\n+ * <dt id=\"u1\">{@code u1}<\/dt>\n+ * <dd>One-byte {@linkplain Byte#toUnsignedInt(byte) unsigned} integer, in the\n+ * range {@code [0, 255]}.\n+ * <br>See {@link java.io.DataInput#readUnsignedByte()}.<\/dd>\n+ * <dt id=\"u2\">{@code u2}<\/dt>\n+ * <dd>Two-byte {@linkplain Short#toUnsignedInt(short) unsigned} integer, in the\n+ * range {@code [0, 65535]}.\n+ * <br>Equivalent to a Java {@link Character char}.  Frequently used for flag\n+ * fields and indices and sizes of list structures.\n+ * <br>See {@link java.io.DataInput#readUnsignedShort()}.<\/dd>\n+ * <dt id=\"u4\">{@code u4}<\/dt>\n+ * <dd>Four-byte {@linkplain Integer#toUnsignedLong(int) unsigned} integer, in\n+ * the range {@code [0, 4294967295]}.\n+ * <br>See {@link java.io.DataInput#readInt()}.<\/dd>\n+ * <\/dl>\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":39,"deletions":7,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -85,9 +85,5 @@\n-        switch (kind) {\n-            case GETTER:\n-            case SETTER:\n-            case STATIC_GETTER:\n-            case STATIC_SETTER:\n-                return ofField(kind, owner, name, ClassDesc.ofDescriptor(lookupDescriptor));\n-            default:\n-                return new DirectMethodHandleDescImpl(kind, owner, name, MethodTypeDesc.ofDescriptor(lookupDescriptor));\n-        }\n+        return switch (kind) {\n+            case GETTER, SETTER, STATIC_GETTER, STATIC_SETTER\n+                    -> ofField(kind, owner, name, ClassDesc.ofDescriptor(lookupDescriptor));\n+            default -> new DirectMethodHandleDescImpl(kind, owner, name, MethodTypeDesc.ofDescriptor(lookupDescriptor));\n+        };\n@@ -125,17 +121,7 @@\n-        switch (kind) {\n-            case GETTER:\n-            case SETTER:\n-            case STATIC_GETTER:\n-            case STATIC_SETTER:\n-                throw new IllegalArgumentException(kind.toString());\n-            case VIRTUAL:\n-            case SPECIAL:\n-            case INTERFACE_VIRTUAL:\n-            case INTERFACE_SPECIAL:\n-            case INTERFACE_STATIC:\n-            case STATIC:\n-            case CONSTRUCTOR:\n-                return new DirectMethodHandleDescImpl(kind, owner, name, lookupMethodType);\n-            default:\n-                throw new IllegalArgumentException(kind.toString());\n-        }\n+        return switch (kind) {\n+            case GETTER, SETTER, STATIC_GETTER, STATIC_SETTER\n+                    -> throw new IllegalArgumentException(kind.toString());\n+            case VIRTUAL, SPECIAL, INTERFACE_VIRTUAL, INTERFACE_SPECIAL, INTERFACE_STATIC, STATIC, CONSTRUCTOR\n+                    -> new DirectMethodHandleDescImpl(kind, owner, name, lookupMethodType);\n+            default -> throw new IllegalArgumentException(kind.toString());\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodHandleDesc.java","additions":12,"deletions":26,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -372,11 +372,26 @@\n-     * <li>If {@code dstType} is a reference type, a reference cast\n-     *     is applied to {@code value} as if by calling {@code dstType.cast(value)}.\n-     * <li>If {@code dstType} is a primitive type, then, if the runtime type\n-     *     of {@code value} is a primitive wrapper type (such as {@link Integer}),\n-     *     a Java unboxing conversion is applied {@jls 5.1.8} followed by a\n-     *     Java casting conversion {@jls 5.5} converting either directly to\n-     *     {@code dstType}, or, if {@code dstType} is {@code boolean},\n-     *     to {@code int}, which is then converted to either {@code true}\n-     *     or {@code false} depending on whether the least-significant-bit\n-     *     is 1 or 0 respectively. If the runtime type of {@code value} is\n-     *     not a primitive wrapper type a {@link ClassCastException} is thrown.\n+     * <li>If {@code dstType} is a reference type, a reference cast is applied\n+     *     to {@code value} as if by calling {@link Class#cast(Object)\n+     *     dstType.cast(value)}.\n+     * <li>Otherwise, {@code dstType} is a primitive type:\n+     *     <ol>\n+     *     <li>If {@code value} is null, the default value (JVMS {@jvms 2.3})\n+     *         of {@code dstType} is returned.\n+     *     <li>If the runtime type of {@code value} is a primitive wrapper type\n+     *         (such as {@link Integer}), a Java unboxing conversion is applied\n+     *         (JLS {@jls 5.1.8}).\n+     *         <ul>\n+     *         <li>If the runtime type is {@link Boolean}, the unboxing result\n+     *             is then converted to {@code int}, where {@code true} becomes\n+     *             {@code 1} and {@code false} becomes {@code 0}.\n+     *         <\/ul>\n+     *         Followed by a Java casting conversion (JLS {@jls 5.5}):\n+     *         <ul>\n+     *         <li>If {@code dstType} is not {@code boolean}, the cast converts\n+     *             directly to {@code dstType}.\n+     *         <li>If {@code dstType} is {@code boolean}, the cast converts to\n+     *             {@code int}, and the resulting {@code boolean} is produced\n+     *             by testing whether the least significant bit of the cast\n+     *             {@code int} is 1.\n+     *         <\/ul>\n+     *     <li>Otherwise, a {@link ClassCastException} is thrown.\n+     *     <\/ol>\n@@ -396,1 +411,1 @@\n-     * @param value the value to be converted\n+     * @param value the value to be converted, may be null\n@@ -398,5 +413,4 @@\n-     * @throws ClassCastException when {@code dstType} is {@code void},\n-     *         when a cast per (1) fails, or when {@code dstType} is a primitive type\n-     *         and the runtime type of {@code value} is not a primitive wrapper type\n-     *         (such as {@link Integer})\n-     *\n+     * @throws ClassCastException when {@code dstType} is {@code void}; when\n+     *         {@code dstType} is a reference type, and the reference cast fails; or\n+     *         when {@code dstType} is primitive, and {@code value} is an\n+     *         instance of a reference type that is not a wrapper class\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ConstantBootstraps.java","additions":32,"deletions":18,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -1519,5 +1519,1 @@\n-     * Returns the set of packages in the module.\n-     *\n-     * <p> The set of packages includes all exported and open packages, as well\n-     * as the packages of any service providers, and the package for the main\n-     * class. <\/p>\n+     * Returns the set of all packages in the module.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/ModuleDescriptor.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -440,1 +440,1 @@\n-                    throw new IllegalArgumentException(\"Invalid KeySpec.\");\n+                    throw new ClassCastException(\"Invalid KeySpec\");\n@@ -443,3 +443,3 @@\n-                throw new IllegalArgumentException(\"Invalid KeySpec \" +\n-                    \"specified (\" + tClass.getName() +\") for key (\" +\n-                    key.getClass().getName() +\")\", e);\n+                throw new ClassCastException(\"Invalid KeySpec \" +\n+                    \"specified: \" + tClass.getName() + \" for key \" +\n+                    key.getClass().getName());\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMDecoder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,1 +141,1 @@\n-     * different accented forms of the same base letter (\"a\" vs \"ä\" (U+00E9)) to be\n+     * different accented forms of the same base letter (\"a\" vs \"ä\" (U+00E4)) to be\n@@ -164,2 +164,2 @@\n-     * \"&#092;u00C0\" (A-grave) and combining accents such as \"A&#092;u0300\"\n-     * (A, combining-grave) will be considered significant at the IDENTICAL\n+     * \"&#092;u00E4\" (a-diaeresis) and combining accents such as \"a&#092;u0308\"\n+     * (a, combining-diaeresis) will be considered significant at the IDENTICAL\n","filename":"src\/java.base\/share\/classes\/java\/text\/Collator.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -104,2 +104,2 @@\n- * and\/or \"tz\" (timezone) <a href=\"..\/util\/Locale.html#def_locale_extension\">Unicode\n- * extensions<\/a>, the calendar, the country and\/or the time zone for formatting\n+ * and\/or \"tz\" (timezone) {@linkplain Locale##def_locale_extension Unicode\n+ * extensions}, the calendar, the country and\/or the time zone for formatting\n","filename":"src\/java.base\/share\/classes\/java\/text\/DateFormat.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n- * <a href=\"..\/util\/Locale.html#def_locale_extension\">Unicode extension<\/a>,\n+ * {@linkplain Locale##def_locale_extension Unicode extension},\n","filename":"src\/java.base\/share\/classes\/java\/text\/DateFormatSymbols.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,2 +63,2 @@\n- * {@code Locale} <a href=\"..\/util\/Locale.html#def_locale_extension\">Unicode\n- * extensions<\/a> are supported which may override values within the symbols.\n+ * {@code Locale} {@linkplain Locale##def_locale_extension Unicode\n+ * extensions} are supported which may override values within the symbols.\n@@ -1018,1 +1018,2 @@\n-        if (loadNumberData(locale) instanceof Object[] d &&\n+        \/\/ `locale` was once nullable, need to check before loading locale data\n+        if (locale != null && loadNumberData(locale) instanceof Object[] d &&\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormatSymbols.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n- * <a href=\"..\/util\/Locale.html#def_locale_extension\">Unicode extensions<\/a>,\n+ * {@linkplain Locale##def_locale_extension Unicode extensions},\n@@ -113,1 +113,1 @@\n- * Although <a href=\"..\/util\/Locale.html#def_locale_extension\">Unicode extensions<\/a>\n+ * Although {@linkplain Locale##def_locale_extension Unicode extensions}\n@@ -694,1 +694,1 @@\n-     * <a href=\"..\/util\/Locale.html#def_locale_extension\">Unicode extension<\/a>,\n+     * {@linkplain Locale##def_locale_extension Unicode extension},\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,2 @@\n- * <p>The requested {@code Locale} may contain an <a\n- * href=\"..\/..\/util\/Locale.html#def_locale_extension\"> extension<\/a> for\n+ * <p>The requested {@code Locale} may contain an {@linkplain\n+ * Locale##def_locale_extension extension} for\n","filename":"src\/java.base\/share\/classes\/java\/text\/spi\/DecimalFormatSymbolsProvider.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1511,3 +1511,3 @@\n-     * If the locale has <a href=\"..\/..\/util\/Locale.html#def_locale_extension\">\n-     * Unicode extensions<\/a>, they may be used later in text\n-     * processing. To set the chronology, time-zone and decimal style from\n+     * If the locale has {@linkplain Locale##def_locale_extension Unicode extensions},\n+     * they may be used later in text processing.\n+     * To set the chronology, time-zone and decimal style from\n@@ -1538,1 +1538,1 @@\n-     * <a href=\"..\/..\/util\/Locale.html#def_locale_extension\">Unicode extensions<\/a>,\n+     * {@linkplain Locale##def_locale_extension Unicode extensions},\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatter.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-     * <a href=\"..\/..\/util\/Locale.html#def_locale_extension\">Unicode extensions<\/a>,\n+     * {@linkplain Locale##def_locale_extension Unicode extensions},\n@@ -238,1 +238,1 @@\n-     * <a href=\"..\/..\/util\/Locale.html#def_locale_extension\">Unicode extensions<\/a>,\n+     * {@linkplain Locale##def_locale_extension Unicode extensions},\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -153,2 +153,2 @@\n-     * (Region Override) <a href=\"..\/..\/util\/Locale.html#def_locale_extension\">\n-     * Unicode extensions<\/a>, returned instance will reflect the values specified with\n+     * (Region Override) {@linkplain Locale##def_locale_extension Unicode extensions},\n+     * returned instance will reflect the values specified with\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DecimalStyle.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -292,2 +292,2 @@\n-     * (Region Override) <a href=\"..\/..\/util\/Locale.html#def_locale_extension\">\n-     * Unicode extensions<\/a>, returned instance will reflect the values specified with\n+     * (Region Override) {@linkplain Locale##def_locale_extension Unicode extensions},\n+     * returned instance will reflect the values specified with\n","filename":"src\/java.base\/share\/classes\/java\/time\/temporal\/WeekFields.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,2 +132,2 @@\n- * locale contains \"fw\" and\/or \"rg\" <a href=\".\/Locale.html#def_locale_extension\">\n- * Unicode extensions<\/a>, the first day of the week will be obtained according to\n+ * locale contains \"fw\" and\/or \"rg\" {@linkplain Locale##def_locale_extension\n+ * Unicode extensions}, the first day of the week will be obtained according to\n@@ -1457,1 +1457,1 @@\n-         * <a href=\"Locale.html#def_locale_extension\">Unicode extension<\/a>,\n+         * {@linkplain Locale##def_locale_extension Unicode extension},\n@@ -1618,1 +1618,1 @@\n-     * <a href=\"Locale.html#def_locale_extension\">Unicode extension<\/a>,\n+     * {@linkplain Locale##def_locale_extension Unicode extension},\n@@ -1650,1 +1650,1 @@\n-     * <a href=\"Locale.html#def_locale_extension\">Unicode extension<\/a>,\n+     * {@linkplain Locale##def_locale_extension Unicode extension},\n@@ -2635,2 +2635,2 @@\n-     * calendar types can be used for the <a\n-     * href=\"Locale.html#def_locale_extension\">Unicode locale extensions<\/a>.\n+     * calendar types can be used for the {@linkplain Locale##def_locale_extension\n+     * Unicode locale extensions}.\n@@ -2670,1 +2670,1 @@\n-     * @see <a href=\"Locale.html#def_extensions\">Locale extensions<\/a>\n+     * @see Locale##def_locale_extension Locale extensions\n","filename":"src\/java.base\/share\/classes\/java\/util\/Calendar.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3055,2 +3055,2 @@\n-         * <a href=\".\/Locale.html#legacy_language_codes\">Legacy language\n-         * codes<\/a>, either old or new, then repeat the loading process\n+         * {@linkplain Locale##legacy_language_codes Legacy language\n+         * codes}, either old or new, then repeat the loading process\n","filename":"src\/java.base\/share\/classes\/java\/util\/ResourceBundle.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,1 +148,1 @@\n-     * <a href=\"..\/Locale.html#def_locale_extension\">Unicode extension<\/a> key,\n+     * {@linkplain Locale##def_locale_extension Unicode extension} key,\n@@ -172,1 +172,1 @@\n-     * <a href=\"..\/Locale.html#def_locale_extension\">Unicode extension<\/a> type,\n+     * {@linkplain Locale##def_locale_extension Unicode extension} type,\n","filename":"src\/java.base\/share\/classes\/java\/util\/spi\/LocaleNameProvider.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,1 @@\n-            this.flags = flags;\n+            this.flags = Util.checkU2(flags, \"character range flags\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPseudoInstruction.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-    public  AccessFlagsImpl(AccessFlag.Location location, AccessFlag... flags) {\n+    public AccessFlagsImpl(AccessFlag.Location location, AccessFlag... flags) {\n@@ -46,1 +46,1 @@\n-        this.flagsMask = mask;\n+        this.flagsMask = Util.checkFlags(mask);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AccessFlagsImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import static java.lang.classfile.ClassFile.PREVIEW_MINOR_VERSION;\n+\n@@ -35,2 +37,3 @@\n-        this.majorVersion = majorVersion;\n-        this.minorVersion = minorVersion;\n+        this.majorVersion = Util.checkU2(majorVersion, \"major version\");\n+        this.minorVersion = minorVersion == -1 ? PREVIEW_MINOR_VERSION\n+                : Util.checkU2(minorVersion, \"minor version\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassFileVersionImpl.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-        setFlags(flags);\n+        setFlags(Util.checkFlags(flags));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-        this.flags = flags;\n+        this.flags = Util.checkFlags(flags);\n@@ -74,1 +74,1 @@\n-        setFlags(flags);\n+        setFlags(Util.checkFlags(flags));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectFieldBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-        this.flags = flags;\n+        this.flags = Util.checkFlags(flags);\n@@ -59,1 +59,1 @@\n-        setFlags(flags);\n+        setFlags(Util.checkFlags(flags));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectMethodBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-        return (line < INTERN_LIMIT)\n+        return (Util.checkU2(line, \"line number\") < INTERN_LIMIT)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/LineNumberImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-        this.moduleFlags = flags;\n+        this.moduleFlags = Util.checkFlags(flags);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ModuleAttributeBuilderImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -597,0 +597,1 @@\n+        Util.checkU1(refKind, \"reference kind\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,3 +47,3 @@\n-        public TypeParameterTargetImpl(TargetType targetType, int typeParameterIndex) {\n-            this.targetType = checkValid(targetType, TARGET_CLASS_TYPE_PARAMETER, TARGET_METHOD_TYPE_PARAMETER);\n-            this.typeParameterIndex = typeParameterIndex;\n+        public TypeParameterTargetImpl {\n+            checkValid(targetType, TARGET_CLASS_TYPE_PARAMETER, TARGET_METHOD_TYPE_PARAMETER);\n+            Util.checkU1(typeParameterIndex, \"type parameter index\");\n@@ -54,0 +54,5 @@\n+\n+        public SupertypeTargetImpl {\n+            Util.checkU2(supertypeIndex, \"supertype index\");\n+        }\n+\n@@ -63,4 +68,4 @@\n-        public TypeParameterBoundTargetImpl(TargetType targetType, int typeParameterIndex, int boundIndex) {\n-            this.targetType = checkValid(targetType, TARGET_CLASS_TYPE_PARAMETER_BOUND, TARGET_METHOD_TYPE_PARAMETER_BOUND);\n-            this.typeParameterIndex = typeParameterIndex;\n-            this.boundIndex = boundIndex;\n+        public TypeParameterBoundTargetImpl {\n+            checkValid(targetType, TARGET_CLASS_TYPE_PARAMETER_BOUND, TARGET_METHOD_TYPE_PARAMETER_BOUND);\n+            Util.checkU1(typeParameterIndex, \"type parameter index\");\n+            Util.checkU1(boundIndex, \"bound index\");\n@@ -78,0 +83,5 @@\n+\n+        public FormalParameterTargetImpl {\n+            Util.checkU1(formalParameterIndex, \"formal parameter index\");\n+        }\n+\n@@ -85,0 +95,5 @@\n+\n+        public ThrowsTargetImpl {\n+            Util.checkU2(throwsTargetIndex, \"throws type index\");\n+        }\n+\n@@ -110,0 +125,1 @@\n+            BytecodeHelpers.validateSlot(index);\n@@ -114,0 +130,5 @@\n+\n+        public CatchTargetImpl {\n+            Util.checkU2(exceptionTableIndex, \"exception table index\");\n+        }\n+\n@@ -131,4 +152,4 @@\n-        public TypeArgumentTargetImpl(TargetType targetType, Label target, int typeArgumentIndex) {\n-            this.targetType = checkValid(targetType, TARGET_CAST, TARGET_METHOD_REFERENCE_TYPE_ARGUMENT);\n-            this.target = requireNonNull(target);\n-            this.typeArgumentIndex = typeArgumentIndex;\n+        public TypeArgumentTargetImpl {\n+            checkValid(targetType, TARGET_CAST, TARGET_METHOD_REFERENCE_TYPE_ARGUMENT);\n+            requireNonNull(target);\n+            Util.checkU1(typeArgumentIndex, \"type argument index\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TargetInfoImpl.java","additions":33,"deletions":12,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -477,1 +477,1 @@\n-            resolutionFlags = flags;\n+            resolutionFlags = Util.checkU2(flags, \"resolution flags\");\n@@ -891,1 +891,8 @@\n-            implements CharacterRangeInfo { }\n+            implements CharacterRangeInfo {\n+\n+        public UnboundCharacterRangeInfo {\n+            Util.checkU2(startPc, \"start pc\");\n+            Util.checkU2(endPc, \"end pc\");\n+            Util.checkU2(flags, \"flags\");\n+        }\n+    }\n@@ -902,0 +909,1 @@\n+            Util.checkFlags(flagsMask);\n@@ -906,1 +914,6 @@\n-            implements LineNumberInfo { }\n+            implements LineNumberInfo {\n+        public UnboundLineNumberInfo {\n+            Util.checkU2(startPc, \"start pc\");\n+            Util.checkU2(lineNumber, \"line number\");\n+        }\n+    }\n@@ -934,0 +947,1 @@\n+            Util.checkFlags(flagsMask);\n@@ -943,0 +957,1 @@\n+            Util.checkFlags(exportsFlagsMask);\n@@ -960,0 +975,1 @@\n+            Util.checkFlags(opensFlagsMask);\n@@ -978,0 +994,1 @@\n+            Util.checkFlags(requiresFlagsMask);\n@@ -1031,1 +1048,1 @@\n-            this.moduleFlags = moduleFlags;\n+            this.moduleFlags = Util.checkFlags(moduleFlags);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-public class Util {\n+public final class Util {\n@@ -189,0 +189,25 @@\n+    \/\/\/ Ensures the given value won't be truncated when written as a u1\n+    public static int checkU1(int incoming, String valueName) {\n+        if ((incoming & ~0xFF) != 0) {\n+            throw outOfRangeException(incoming, valueName, \"u1\");\n+        }\n+        return incoming;\n+    }\n+\n+    \/\/\/ Ensures the given value won't be truncated when written as a u2\n+    public static char checkU2(int incoming, String valueName) {\n+        if ((incoming & ~0xFFFF) != 0)\n+            throw outOfRangeException(incoming, valueName, \"u2\");\n+        return (char) incoming;\n+    }\n+\n+    public static IllegalArgumentException outOfRangeException(int value, String fieldName, String typeName) {\n+        return new IllegalArgumentException(\n+                String.format(\"%s out of range of %d: %d\", fieldName, typeName, value));\n+    }\n+\n+    \/\/\/ Ensures the given mask won't be truncated when written as an access flag\n+    public static char checkFlags(int mask) {\n+        return checkU2(mask, \"access flags\");\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.nio.charset.CharacterCodingException;\n@@ -74,1 +75,6 @@\n-        return new String(bytes, charset);\n+        try {\n+            return JAVA_LANG_ACCESS.uncheckedNewStringNoRepl(bytes, charset);\n+        } catch (CharacterCodingException _) {\n+            \/\/ use replacement characters for malformed input\n+            return new String(bytes, charset);\n+        }\n@@ -88,1 +94,6 @@\n-        return new String(bytes, charset);\n+        try {\n+            return JAVA_LANG_ACCESS.uncheckedNewStringNoRepl(bytes, charset);\n+        } catch (CharacterCodingException _) {\n+          \/\/ use replacement characters for malformed input\n+          return new String(bytes, charset);\n+        }\n@@ -102,1 +113,6 @@\n-        return new String(bytes, charset);\n+        try {\n+            return JAVA_LANG_ACCESS.uncheckedNewStringNoRepl(bytes, charset);\n+        } catch (CharacterCodingException _) {\n+            \/\/ use replacement characters for malformed input\n+            return new String(bytes, charset);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,2 +99,9 @@\n-            if (t != null)\n-                t = t.arrayType();\n+            if (t != null) {\n+                try {\n+                    t = t.arrayType();\n+                } catch (UnsupportedOperationException ex) {\n+                    \/\/ Bad arrays, such as [V or more than 255 dims\n+                    \/\/ We have a more informative IAE\n+                    return null;\n+                }\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/BytecodeDescriptor.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -181,1 +181,5 @@\n-        if (!uninterruptible) end(completed);\n+        if (!uninterruptible) {\n+            end(completed);\n+        } else if (!completed && !isOpen()) {\n+            throw new AsynchronousCloseException();\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1565,3 +1565,0 @@\n-        if (ids == null) {\n-            throw new Exception(\"Must provide -id when -gencrl\");\n-        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/tools\/keytool\/Main.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2504,4 +2504,3 @@\n-    soft goal, and the JVM will make its best effort to achieve it. The\n-    specified value doesn't adapt to your heap size. By default, for G1 the\n-    maximum pause time target is 200 milliseconds. The other generational\n-    collectors do not use a pause time goal by default.\n+    soft goal, and the JVM will make its best effort to achieve it. Only G1\n+    and Parallel support a maximum GC pause time target. For G1, the default\n+    maximum pause time target is 200 milliseconds.\n@@ -2886,0 +2885,40 @@\n+`-XX:+UseShenandoahGC`\n+:   Enables the use of the Shenandoah garbage collector. This is a low pause\n+    time, concurrent garbage collector. Its pause times are not proportional to\n+    the size of the heap. Shenandoah garbage collector can work with compressed\n+    pointers. See `-XX:UseCompressedOops` for further information about\n+    compressed pointers.\n+\n+`-XX:ShenandoahGCMode=`*mode*\n+:   Sets the GC mode for Shenandoah GC to use. By default, this option is set\n+    to `satb`. Among other things, this defines which barriers are in use.\n+    Possible mode values include the following:\n+\n+    `satb`\n+    :   Snapshot-at-the-beginning concurrent GC (three pass mark-evac-update).\n+        It is a single generation GC.\n+\n+    `generational`\n+    :   It is also a snapshot-at-the-beginning and concurrent GC, but it is\n+        generational. Please see [JEP 404](https:\/\/openjdk.org\/jeps\/404) and\n+        [JEP 521](https:\/\/openjdk.org\/jeps\/521) for its advantages and risks.\n+\n+`-XX:ShenandoahGCHeuristics=`*heuristics*\n+:   Sets the heuristics for Shenandoah GC to use. By default, this option is\n+    set to `adaptive`. This fine-tunes the GC mode selected, by choosing when\n+    to start the GC, how much to process on each cycle, and what other features\n+    to automatically enable. When `-XX:ShenandoahGCMode` is `generational`, the\n+    only supported option is the default, `adaptive`.\n+\n+    Possible heuristics are the following:\n+\n+    `adaptive`\n+    :   To maintain the given amount of free heap at all times, even during\n+        the GC cycle.\n+\n+    `static`\n+    :   Trigger GC when free heap falls below a specified threshold.\n+\n+    `compact`\n+    :   Run GC more frequently and with deeper targets to free up more memory.\n+\n","filename":"src\/java.base\/share\/man\/java.md","additions":43,"deletions":4,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,59 +151,0 @@\n-\/\/ ImageModuleData constructor maps out sub-tables for faster access.\n-ImageModuleData::ImageModuleData(const ImageFileReader* image_file) :\n-        _image_file(image_file),\n-        _endian(image_file->endian()) {\n-}\n-\n-\/\/ Release module data resource.\n-ImageModuleData::~ImageModuleData() {\n-}\n-\n-\n-\/\/ Return the module in which a package resides.    Returns NULL if not found.\n-const char* ImageModuleData::package_to_module(const char* package_name) {\n-    \/\/ replace all '\/' by '.'\n-    char* replaced = new char[(int) strlen(package_name) + 1];\n-    assert(replaced != NULL && \"allocation failed\");\n-    int i;\n-    for (i = 0; package_name[i] != '\\0'; i++) {\n-      replaced[i] = package_name[i] == '\/' ? '.' : package_name[i];\n-    }\n-    replaced[i] = '\\0';\n-\n-    \/\/ build path \/packages\/<package_name>\n-    const char* radical = \"\/packages\/\";\n-    char* path = new char[(int) strlen(radical) + (int) strlen(package_name) + 1];\n-    assert(path != NULL && \"allocation failed\");\n-    strcpy(path, radical);\n-    strcat(path, replaced);\n-    delete[] replaced;\n-\n-    \/\/ retrieve package location\n-    ImageLocation location;\n-    bool found = _image_file->find_location(path, location);\n-    delete[] path;\n-    if (!found) {\n-        return NULL;\n-    }\n-\n-    \/\/ retrieve offsets to module name\n-    int size = (int)location.get_attribute(ImageLocation::ATTRIBUTE_UNCOMPRESSED);\n-    u1* content = new u1[size];\n-    assert(content != NULL && \"allocation failed\");\n-    _image_file->get_resource(location, content);\n-    u1* ptr = content;\n-    \/\/ sequence of sizeof(8) isEmpty|offset. Use the first module that is not empty.\n-    u4 offset = 0;\n-    for (i = 0; i < size; i+=8) {\n-        u4 isEmpty = _endian->get(*((u4*)ptr));\n-        ptr += 4;\n-        if (!isEmpty) {\n-            offset = _endian->get(*((u4*)ptr));\n-            break;\n-        }\n-        ptr += 4;\n-    }\n-    delete[] content;\n-    return _image_file->get_strings().get(offset);\n-}\n-\n@@ -343,2 +284,1 @@\n-ImageFileReader::ImageFileReader(const char* name, bool big_endian) :\n-    _module_data(NULL) {\n+ImageFileReader::ImageFileReader(const char* name, bool big_endian) {\n@@ -365,4 +305,0 @@\n-\n-    if (_module_data != NULL) {\n-        delete _module_data;\n-    }\n@@ -417,5 +353,1 @@\n-\n-    \/\/ Initialize the module data\n-    _module_data = new ImageModuleData(this);\n-    \/\/ Successful open (if memory allocation succeeded).\n-    return _module_data != NULL;\n+    return true;\n@@ -436,5 +368,0 @@\n-\n-    if (_module_data != NULL) {\n-        delete _module_data;\n-        _module_data = NULL;\n-    }\n@@ -570,5 +497,0 @@\n-\n-\/\/ Return the ImageModuleData for this image\n-ImageModuleData * ImageFileReader::get_image_module_data() {\n-    return _module_data;\n-}\n","filename":"src\/java.base\/share\/native\/libjimage\/imageFile.cpp","additions":3,"deletions":81,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -305,14 +305,0 @@\n-\/\/\n-\/\/ Manage the image module meta data.\n-class ImageModuleData {\n-    const ImageFileReader* _image_file; \/\/ Source image file\n-    Endian* _endian;                    \/\/ Endian handler\n-\n-public:\n-    ImageModuleData(const ImageFileReader* image_file);\n-    ~ImageModuleData();\n-\n-    \/\/ Return the module in which a package resides.    Returns NULL if not found.\n-    const char* package_to_module(const char* package_name);\n-};\n-\n@@ -431,1 +417,0 @@\n-    ImageModuleData *_module_data;       \/\/ The ImageModuleData for this image\n@@ -580,4 +565,0 @@\n-\n-    \/\/ Return the ImageModuleData for this image\n-    ImageModuleData * get_image_module_data();\n-\n","filename":"src\/java.base\/share\/native\/libjimage\/imageFile.hpp","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,17 +89,0 @@\n-\/*\n- * JImagePackageToModule - Given an open image file (see JImageOpen) and the name\n- * of a package, return the name of module where the package resides. If the\n- * package does not exist in the image file, the function returns NULL.\n- * The resulting string does\/should not have to be released. All strings are\n- * utf-8, zero byte terminated.\n- *\n- * Ex.\n- *  const char* package = (*JImagePackageToModule)(image, \"java\/lang\");\n- *  tty->print_cr(package);\n- *  -> java.base\n- *\/\n-extern \"C\" JNIEXPORT const char*\n-JIMAGE_PackageToModule(JImageFile* image, const char* package_name) {\n-    return ((ImageFileReader*) image)->get_image_module_data()->package_to_module(package_name);\n-}\n-\n","filename":"src\/java.base\/share\/native\/libjimage\/jimage.cpp","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,19 +96,0 @@\n-\/*\n- * JImagePackageToModule - Given an open image file (see JImageOpen) and the name\n- * of a package, return the name of module where the package resides. If the\n- * package does not exist in the image file, the function returns NULL.\n- * The resulting string does\/should not have to be released. All strings are\n- * utf-8, zero byte terminated.\n- *\n- * Ex.\n- *  const char* package = (*JImagePackageToModule)(image, \"java\/lang\");\n- *  tty->print_cr(package);\n- *  -> java.base\n- *\/\n-\n-extern \"C\" JNIEXPORT const char *\n-JIMAGE_PackageToModule(JImageFile* jimage, const char* package_name);\n-\n-typedef const char* (*JImagePackageToModule_t)(JImageFile* jimage, const char* package_name);\n-\n-\n","filename":"src\/java.base\/share\/native\/libjimage\/jimage.hpp","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,3 +95,5 @@\n-        if (errno() == UnixConstants.ELOOP)\n-            return new FileSystemException(file, other, errorString()\n-                + \" or unable to access attributes of symbolic link\");\n+        if (errno() == UnixConstants.ELOOP) {\n+            String msg = file + \": \" + errorString()\n+                 + \" or unable to access attributes of symbolic link\";\n+            return new FileSystemLoopException(msg);\n+        }\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixException.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -61,0 +61,3 @@\n+    CHECKED_MALLOC4(_pointer, _type, _size, {})\n+\n+#define CHECKED_MALLOC4(_pointer, _type, _size, _onFailure) \\\n@@ -65,0 +68,1 @@\n+            do _onFailure while (0); \\\n@@ -998,1 +1002,1 @@\n-         CHECKED_MALLOC3(currif, netif *, sizeof(netif) + IFNAMESIZE);\n+         CHECKED_MALLOC4(currif, netif *, sizeof(netif) + IFNAMESIZE, { free(addrP); });\n@@ -1030,1 +1034,4 @@\n-            CHECKED_MALLOC3(currif, netif *, sizeof(netif) + IFNAMESIZE);\n+            CHECKED_MALLOC4(currif, netif *, sizeof(netif) + IFNAMESIZE, {\n+                free(addrP);\n+                free(parent);\n+            });\n@@ -1042,1 +1049,5 @@\n-        CHECKED_MALLOC3(tmpaddr, netaddr *, sizeof(netaddr) + 2 * addr_size);\n+        CHECKED_MALLOC4(tmpaddr, netaddr *, sizeof(netaddr) + 2 * addr_size, {\n+            free(addrP);\n+            free(parent);\n+            free(currif);\n+        });\n","filename":"src\/java.base\/unix\/native\/libnet\/NetworkInterface.c","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -968,1 +968,0 @@\n- \/\/ int got = 0;\n@@ -972,2 +971,1 @@\n-         \/\/ got =\n-                  getLocaleInfoWrapper(langtag,\n+            getLocaleInfoWrapper(langtag,\n@@ -977,2 +975,1 @@\n-         \/\/ got =\n-                  getLocaleInfoWrapper(langtag,\n+            getLocaleInfoWrapper(langtag,\n@@ -984,2 +981,1 @@\n-         \/\/ got =\n-                  getLocaleInfoWrapper(langtag,\n+            getLocaleInfoWrapper(langtag,\n@@ -989,2 +985,1 @@\n-         \/\/ got =\n-                  getLocaleInfoWrapper(langtag,\n+            getLocaleInfoWrapper(langtag,\n@@ -994,2 +989,1 @@\n-         \/\/ got =\n-                  getLocaleInfoWrapper(langtag,\n+            getLocaleInfoWrapper(langtag,\n","filename":"src\/java.base\/windows\/native\/libjava\/HostLocaleProviderAdapter_md.c","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -235,1 +235,0 @@\n-     \/\/ int onlyMapID;\n@@ -307,1 +306,0 @@\n-     \/\/ onlyMapID = 0;\n@@ -328,1 +326,0 @@\n-             \/\/ onlyMapID = 1;\n","filename":"src\/java.base\/windows\/native\/libjava\/TimeZone_md.c","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,2 +50,0 @@\n-\/\/ static HINSTANCE lib = NULL;\n-\n","filename":"src\/java.base\/windows\/native\/libnet\/NTLMAuthSequence.c","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -394,0 +394,6 @@\n+    private void verifyImageIndex(int imageIndex) {\n+        if (imageIndex < minIndex) {\n+            throw new IndexOutOfBoundsException(\"imageIndex < \" + minIndex);\n+        }\n+    }\n+\n@@ -500,3 +506,1 @@\n-        if (imageIndex < minIndex) {\n-            throw new IndexOutOfBoundsException();\n-        }\n+        verifyImageIndex(imageIndex);\n@@ -845,0 +849,1 @@\n+            verifyImageIndex(imageIndex);\n@@ -859,0 +864,1 @@\n+            verifyImageIndex(imageIndex);\n@@ -889,0 +895,1 @@\n+            verifyImageIndex(imageIndex);\n@@ -907,0 +914,1 @@\n+            verifyImageIndex(imageIndex);\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/JPEGImageReader.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,1 +128,3 @@\n-        switch (image.getType()) {\n+        Raster raster = image.getRaster();\n+        int type = image.getType();\n+        switch (type) {\n@@ -167,1 +169,1 @@\n-                    return createImageLayout(image.getRaster(), cm);\n+                    return createImageLayout(raster, cm);\n@@ -175,1 +177,1 @@\n-        switch (image.getType()) {\n+        switch (type) {\n@@ -179,1 +181,3 @@\n-                var intRaster = (IntegerComponentRaster) image.getRaster();\n+                if (!(raster instanceof IntegerComponentRaster intRaster)) {\n+                    return null;\n+                }\n@@ -191,1 +195,3 @@\n-                var byteRaster = (ByteComponentRaster) image.getRaster();\n+                if (!(raster instanceof ByteComponentRaster byteRaster)) {\n+                    return null;\n+                }\n@@ -201,1 +207,3 @@\n-                var shortRaster = (ShortComponentRaster) image.getRaster();\n+                if (!(raster instanceof ShortComponentRaster shortRaster)) {\n+                    return null;\n+                }\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMSImageLayout.java","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1101,2 +1101,0 @@\n-        updateFocusability();\n-        promoteDefaultPosition();\n@@ -1104,0 +1102,4 @@\n+        if (refreshChildsTransientFor) {\n+            updateFocusability();\n+        }\n+        promoteDefaultPosition();\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XWindowPeer.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+            @Override\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsCheckBoxMenuItemUI.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-        new  WindowsMenuItemUIAccessor() {\n+        new WindowsMenuItemUIAccessor() {\n@@ -79,0 +79,1 @@\n+            @Override\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsMenuItemUI.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-    protected Integer menuBarHeight;\n-    protected boolean hotTrackingOn;\n+    private Integer menuBarHeight;\n+    private boolean hotTrackingOn;\n@@ -65,0 +65,1 @@\n+            @Override\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsMenuUI.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+           @Override\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsRadioButtonMenuItemUI.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -294,2 +294,7 @@\n-        \/\/ ------------------------------\n-        \/\/ ------------------------------\n+        if (object == null) {\n+            final RuntimeException wrapped =\n+                new IllegalArgumentException(\"Object cannot be null\");\n+            throw new RuntimeOperationsException(wrapped,\n+                      \"Exception occurred trying to register the MBean\");\n+        }\n+\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/interceptor\/DefaultMBeanServerInterceptor.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.io.IOException;\n@@ -32,0 +33,1 @@\n+import java.nio.channels.FileChannel;\n@@ -34,2 +36,0 @@\n-import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n@@ -723,0 +723,38 @@\n+        \/**\n+         * {@return a request body publisher whose body is the {@code length}\n+         * content bytes read from the provided file {@code channel} starting\n+         * from the specified {@code offset}}\n+         * <p>\n+         * This method and the returned {@code BodyPublisher} do not modify the\n+         * {@code channel}'s position, and do not close the {@code channel}. The\n+         * caller is expected to close the {@code channel} when no longer needed.\n+         *\n+         * @apiNote\n+         * This method can be used to either publish just a region of a file as\n+         * the request body or to publish different regions of a file\n+         * concurrently. A typical usage would be to publish different regions\n+         * of a file by creating a single instance of {@link FileChannel} and\n+         * then send multiple concurrent {@code HttpRequest}s, each of which\n+         * uses a new {@code ofFileChannel BodyPublisher} created from the same\n+         * channel with a different, typically non-overlapping, range of bytes\n+         * specified by offset and length.\n+         *\n+         * @param channel a file channel\n+         * @param offset the offset of the first byte\n+         * @param length the number of bytes to read from the file channel\n+         *\n+         * @throws IndexOutOfBoundsException if the specified byte range is\n+         * found to be {@linkplain Objects#checkFromIndexSize(long, long, long)\n+         * out of bounds} compared with the size of the file referred by the\n+         * channel\n+         *\n+         * @throws IOException if the {@linkplain FileChannel#size() channel's\n+         * size} cannot be determined or the {@code channel} is closed\n+         *\n+         * @since 26\n+         *\/\n+        public static BodyPublisher ofFileChannel(FileChannel channel, long offset, long length) throws IOException {\n+            Objects.requireNonNull(channel, \"channel\");\n+            return new RequestPublishers.FileChannelPublisher(channel, offset, length);\n+        }\n+\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpRequest.java","additions":41,"deletions":3,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.nio.channels.FileChannel;\n@@ -421,0 +422,75 @@\n+    public static final class FileChannelPublisher implements BodyPublisher {\n+\n+        private final FileChannel channel;\n+\n+        private final long position;\n+\n+        private final long limit;\n+\n+        public FileChannelPublisher(FileChannel channel, long offset, long length) throws IOException {\n+            this.channel = Objects.requireNonNull(channel, \"channel\");\n+            long fileSize = channel.size();\n+            Objects.checkFromIndexSize(offset, length, fileSize);\n+            this.position = offset;\n+            this.limit = offset + length;\n+        }\n+\n+        @Override\n+        public long contentLength() {\n+            return limit - position;\n+        }\n+\n+        @Override\n+        public void subscribe(Flow.Subscriber<? super ByteBuffer> subscriber) {\n+            Iterable<ByteBuffer> iterable = () -> new FileChannelIterator(channel, position, limit);\n+            new PullPublisher<>(iterable).subscribe(subscriber);\n+        }\n+\n+    }\n+\n+    private static final class FileChannelIterator implements Iterator<ByteBuffer> {\n+\n+        private final FileChannel channel;\n+\n+        private final long limit;\n+\n+        private long position;\n+\n+        private boolean terminated;\n+\n+        private FileChannelIterator(FileChannel channel, long position, long limit) {\n+            this.channel = channel;\n+            this.position = position;\n+            this.limit = limit;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            return position < limit && !terminated;\n+        }\n+\n+        @Override\n+        public ByteBuffer next() {\n+            if (!hasNext()) {\n+                throw new NoSuchElementException();\n+            }\n+            long remaining = limit - position;\n+            ByteBuffer buffer = Utils.getBufferWithAtMost(remaining);\n+            try {\n+                int readLength = channel.read(buffer, position);\n+                \/\/ Short-circuit if `read()` has failed, e.g., due to file content being changed in the meantime\n+                if (readLength < 0) {\n+                    \/\/ Throw to signal that the request needs to be cancelled\n+                    throw new IOException(\"Unexpected EOF (position=%s)\".formatted(position));\n+                } else {\n+                    position += readLength;\n+                }\n+            } catch (IOException ioe) {\n+                terminated = true;\n+                throw new UncheckedIOException(ioe);\n+            }\n+            return buffer.flip();\n+        }\n+\n+    }\n+\n@@ -433,1 +509,1 @@\n-        public final long contentLength() {\n+        public long contentLength() {\n@@ -438,1 +514,1 @@\n-        public final void subscribe(Flow.Subscriber<? super ByteBuffer> subscriber) {\n+        public void subscribe(Flow.Subscriber<? super ByteBuffer> subscriber) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/RequestPublishers.java","additions":78,"deletions":2,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -395,0 +395,4 @@\n+\n+    \/**\n+     * {@return a new {@link ByteBuffer} instance of {@link #BUFSIZE} capacity}\n+     *\/\n@@ -399,0 +403,18 @@\n+    \/**\n+     * {@return a new {@link ByteBuffer} instance whose capacity is set to the\n+     * smaller of the specified {@code maxCapacity} and the default\n+     * ({@value BUFSIZE})}\n+     *\n+     * @param maxCapacity a buffer capacity, in bytes\n+     * @throws IllegalArgumentException if {@code maxCapacity < 0}\n+     *\/\n+    public static ByteBuffer getBufferWithAtMost(long maxCapacity) {\n+        if (maxCapacity < 0) {\n+            throw new IllegalArgumentException(\n+                    \/\/ Match the message produced by `ByteBuffer::createCapacityException`\n+                    \"capacity < 0: (%s < 0)\".formatted(maxCapacity));\n+        }\n+        int effectiveCapacity = (int) Math.min(maxCapacity, BUFSIZE);\n+        return ByteBuffer.allocate(effectiveCapacity);\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.security.Provider;\n@@ -54,1 +55,1 @@\n- * The JDK implementation supports the following property that can be set\n+ * The JDK implementation supports the following properties that can be set\n@@ -57,0 +58,3 @@\n+ *   <li><code>org.jcp.xml.dsig.internal.dom.SignatureProvider<\/code>: value\n+ *       must be a {@link Provider}. If specified, the underlying {@code Signature}\n+ *       will be instantiated from this provider.\n","filename":"src\/java.xml.crypto\/share\/classes\/javax\/xml\/crypto\/dsig\/dom\/DOMSignContext.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+import java.security.Provider;\n+\n@@ -55,12 +57,22 @@\n- * By default, the JDK implementation enables a secure validation mode by\n- * setting the <code>org.jcp.xml.dsig.secureValidation<\/code> property to\n- * <code>Boolean.TRUE<\/code> (see the {@link #setProperty setProperty}\n- * method). When enabled, validation of XML signatures are subject to\n- * stricter checking of algorithms and other constraints as specified by the\n- * <code>jdk.xml.dsig.secureValidationPolicy<\/code> security property.\n- * The mode can be disabled by setting the property to {@code Boolean.FALSE}.\n- * The mode can also be enabled or disabled by setting the\n- * {@systemProperty org.jcp.xml.dsig.secureValidation} system property to\n- * \"true\" or \"false\". Any other value for the system property is also treated\n- * as \"false\". If the system property is set, it supersedes the\n- * {@code DOMValidateContext} property value.\n+ * The JDK implementation supports the following properties that can be set\n+ * using the {@link #setProperty setProperty} method.\n+ * <ul>\n+ *   <li><code>org.jcp.xml.dsig.secureValidation<\/code>: value must be a\n+ *      {@link Boolean}. When enabled, validation of XML signatures are subject\n+ *      to stricter checking of algorithms and other constraints as specified by the\n+ *      <code>jdk.xml.dsig.secureValidationPolicy<\/code> security property.\n+ *      The default value if not specified is <code>Boolean.TRUE<\/code>.\n+ *      The mode can be disabled by setting the property to {@code Boolean.FALSE}.\n+ *      The mode can also be enabled or disabled by setting the\n+ *      {@systemProperty org.jcp.xml.dsig.secureValidation} system property to\n+ *      \"true\" or \"false\". Any other value for the system property is also treated\n+ *      as \"false\". If the system property is set, it supersedes the\n+ *      {@code DOMValidateContext} property value.\n+ *   <li><code>org.jcp.xml.dsig.validateManifests<\/code>: value\n+ *      must be a {@link Boolean}. If enabled, the references in manifest\n+ *      elements (if exist) are validated during signature validation.\n+ *      The default value if not specified is <code>Boolean.FALSE<\/code>.\n+ *   <li><code>org.jcp.xml.dsig.internal.dom.SignatureProvider<\/code>: value\n+ *      must be a {@link Provider}. If specified, the underlying {@code Signature}\n+ *      will be instantiated from this provider.\n+ * <\/ul>\n","filename":"src\/java.xml.crypto\/share\/classes\/javax\/xml\/crypto\/dsig\/dom\/DOMValidateContext.java","additions":25,"deletions":13,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n-        <string>English<\/string>\n+        <string>en-US<\/string>\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/ApplicationRuntime-Info.plist.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-  <string>English<\/string>\n+  <string>en-US<\/string>\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/Info-lite.plist.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n-        <string>English<\/string>\n+        <string>en-US<\/string>\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/Runtime-Info.plist.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,1 +95,0 @@\n-import java.net.URI;\n@@ -104,0 +103,1 @@\n+import java.nio.file.ProviderNotFoundException;\n@@ -2005,6 +2005,16 @@\n-            Collection<Path> paths = new ArrayList<>();\n-            MemoryFileManager fm = proc.taskFactory.fileManager();\n-\n-            appendPaths(fm, StandardLocation.PLATFORM_CLASS_PATH, paths);\n-            appendPaths(fm, StandardLocation.CLASS_PATH, paths);\n-            appendPaths(fm, StandardLocation.SOURCE_PATH, paths);\n+            Collection<Path> paths = proc.taskFactory.parse(\"\", task -> {\n+                MemoryFileManager fm = proc.taskFactory.fileManager();\n+                Collection<Path> _paths = new ArrayList<>();\n+                try {\n+                    appendPaths(fm, StandardLocation.PLATFORM_CLASS_PATH, _paths);\n+                    appendPaths(fm, StandardLocation.CLASS_PATH, _paths);\n+                    appendPaths(fm, StandardLocation.SOURCE_PATH, _paths);\n+                    appendModulePaths(fm, StandardLocation.SYSTEM_MODULES, _paths);\n+                    appendModulePaths(fm, StandardLocation.UPGRADE_MODULE_PATH, _paths);\n+                    appendModulePaths(fm, StandardLocation.MODULE_PATH, _paths);\n+                    return _paths;\n+                } catch (Exception ex) {\n+                    proc.debug(ex, \"SourceCodeAnalysisImpl.refreshIndexes(\" + version + \")\");\n+                    return List.of();\n+                }\n+            });\n@@ -2063,0 +2073,14 @@\n+    private void appendModulePaths(MemoryFileManager fm, Location loc, Collection<Path> paths) throws IOException {\n+        for (Set<Location> moduleLocations : fm.listLocationsForModules(loc)) {\n+            for (Location moduleLocation : moduleLocations) {\n+                Iterable<? extends Path> modulePaths = fm.getLocationAsPaths(moduleLocation);\n+\n+                if (modulePaths == null) {\n+                    continue;\n+                }\n+\n+                modulePaths.forEach(paths::add);\n+            }\n+        }\n+    }\n+\n@@ -2066,18 +2090,1 @@\n-        if (isJRTMarkerFile(path)) {\n-            FileSystem jrtfs = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n-            Path modules = jrtfs.getPath(\"modules\");\n-            return PATH_TO_INDEX.compute(path, (p, index) -> {\n-                try {\n-                    long lastModified = Files.getLastModifiedTime(modules).toMillis();\n-                    if (index == null || index.timestamp != lastModified) {\n-                        try (DirectoryStream<Path> stream = Files.newDirectoryStream(modules)) {\n-                            index = doIndex(lastModified, path, stream);\n-                        }\n-                    }\n-                    return index;\n-                } catch (IOException ex) {\n-                    proc.debug(ex, \"SourceCodeAnalysisImpl.indexesForPath(\" + path.toString() + \")\");\n-                    return new ClassIndex(-1, path, Collections.emptySet(), Collections.emptyMap());\n-                }\n-            });\n-        } else if (!Files.isDirectory(path)) {\n+        if (!Files.isDirectory(path)) {\n@@ -2096,1 +2103,1 @@\n-                    } catch (IOException ex) {\n+                    } catch (IOException | ProviderNotFoundException ex) {\n@@ -2115,4 +2122,0 @@\n-    static boolean isJRTMarkerFile(Path path) {\n-        return path.equals(Paths.get(System.getProperty(\"java.home\"), \"lib\", \"modules\"));\n-    }\n-\n@@ -2203,1 +2206,1 @@\n-            INDEXER.submit(() -> {}).get();\n+            waitCurrentBackgroundTasksFinished();\n@@ -2210,0 +2213,4 @@\n+    public static void waitCurrentBackgroundTasksFinished() throws Exception {\n+        INDEXER.submit(() -> {}).get();\n+    }\n+\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/SourceCodeAnalysisImpl.java","additions":38,"deletions":31,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,1 +198,1 @@\n-    if (read_ticks(\"\/proc\/self\/stat\", &userTicks, &systemTicks) < 0) {\n+    if (read_ticks(\"\/proc\/self\/stat\", &userTicks, &systemTicks) != 2) {\n","filename":"src\/jdk.management\/linux\/native\/libmanagement_ext\/UnixOperatingSystem.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-        <batik.version>1.17<\/batik.version>\n+        <batik.version>1.19<\/batik.version>\n","filename":"src\/utils\/IdealGraphVisualizer\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-    os::snprintf(symbol_name, symbol_name_length, \"some_symbol%d\", i);\n+    os::snprintf_checked(symbol_name, symbol_name_length, \"some_symbol%d\", i);\n@@ -161,1 +161,1 @@\n-    os::snprintf(symbol_name, symbol_name_length, \"temp-filler-%d\", i);\n+    os::snprintf_checked(symbol_name, symbol_name_length, \"temp-filler-%d\", i);\n@@ -180,1 +180,1 @@\n-    os::snprintf(symbol_name, symbol_name_length, \"temp-%d\", i);\n+    os::snprintf_checked(symbol_name, symbol_name_length, \"temp-%d\", i);\n","filename":"test\/hotspot\/gtest\/classfile\/test_symbolTable.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-  ASSERT_EQ(a.long_term_pause_time_ratio(), 0.0);\n-  ASSERT_EQ(a.short_term_pause_time_ratio(), 0.0);\n+  ASSERT_EQ(a.long_term_gc_time_ratio(), 0.0);\n+  ASSERT_EQ(a.short_term_gc_time_ratio(), 0.0);\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1Analytics.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -259,1 +259,1 @@\n-  snprintf(path, len, \"%s\/lib\/jli\/libjli.dylib\", java_home);\n+  os::snprintf_checked(path, len, \"%s\/lib\/jli\/libjli.dylib\", java_home);\n","filename":"test\/hotspot\/gtest\/gtestMain.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-  snprintf(name, len, \"%s%s\", LogFileOutput::Prefix, TestLogFileName);\n+  os::snprintf_checked(name, len, \"%s%s\", LogFileOutput::Prefix, TestLogFileName);\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -379,1 +379,1 @@\n-    os::snprintf(buf, JVM_MAXPATHLEN, \"%d\", (int) wcslen(path));\n+    os::snprintf_checked(buf, JVM_MAXPATHLEN, \"%d\", (int) wcslen(path));\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -298,0 +298,27 @@\n+\n+TEST(globalDefinitions, jlong_from) {\n+  jlong val = jlong_from(0xFF, 0);\n+  EXPECT_EQ(val, CONST64(0x00000000FF00000000));\n+\n+  val = jlong_from(0, 0xFF);\n+  EXPECT_EQ(val, CONST64(0x00000000000000FF));\n+\n+  val = jlong_from(0xFFFFFFFF, 0);\n+  EXPECT_EQ((julong)val, UCONST64(0xFFFFFFFF00000000));\n+\n+  val = jlong_from(0, 0xFFFFFFFF);\n+  EXPECT_EQ(val, CONST64(0x00000000FFFFFFFF));\n+\n+  val = jlong_from(0, -1);\n+  EXPECT_EQ(val, CONST64(0x00000000FFFFFFFF));\n+\n+  val = jlong_from(-1, 0);\n+  EXPECT_EQ((julong)val, UCONST64(0xFFFFFFFF00000000));\n+\n+  val = jlong_from(-1, -1);\n+  EXPECT_EQ((julong)val, UCONST64(0xFFFFFFFFFFFFFFFF));\n+  EXPECT_EQ(val, CONST64(-1));\n+\n+  val = jlong_from(0xABCD, 0xEFEF);\n+  EXPECT_EQ(val, CONST64(0x0000ABCD0000EFEF));\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_globalDefinitions.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -989,17 +989,17 @@\n-  typedef RBTree<int, unsigned, IntCmp, RBTreeCHeapAllocator<mtTest> > TreeType;\n-    TreeType tree;\n-    const int i1 = 82924;\n-    const char* const s1 = \"[82924] = 1\";\n-    const int i2 = -13591;\n-    const char* const s2 = \"[-13591] = 2\";\n-    const int i3 = 0;\n-    const char* const s3 = \"[0] = 3\";\n-    tree.upsert(i1, 1U);\n-    tree.upsert(i2, 2U);\n-    tree.upsert(i3, 3U);\n-    stringStream ss;\n-    tree.print_on(&ss);\n-    const char* const N = nullptr;\n-    ASSERT_NE(strstr(ss.base(), s1), N);\n-    ASSERT_NE(strstr(ss.base(), s2), N);\n-    ASSERT_NE(strstr(ss.base(), s3), N);\n+  using TreeType = RBTreeCHeap<int, unsigned, IntCmp, mtTest>;\n+  TreeType tree;\n+  const int i1 = 82924;\n+  const char* const s1 = \"[82924] = 1\";\n+  const int i2 = -13591;\n+  const char* const s2 = \"[-13591] = 2\";\n+  const int i3 = 0;\n+  const char* const s3 = \"[0] = 3\";\n+  tree.upsert(i1, 1U);\n+  tree.upsert(i2, 2U);\n+  tree.upsert(i3, 3U);\n+  stringStream ss;\n+  tree.print_on(&ss);\n+  const char* const N = nullptr;\n+  ASSERT_NE(strstr(ss.base(), s1), N);\n+  ASSERT_NE(strstr(ss.base(), s2), N);\n+  ASSERT_NE(strstr(ss.base(), s3), N);\n@@ -1082,0 +1082,12 @@\n+struct OomAllocator {\n+  void* allocate(size_t sz) {\n+    return nullptr;\n+  }\n+  void free(void* ptr) {}\n+};\n+TEST_VM_F(RBTreeTest, AllocatorMayReturnNull) {\n+  RBTree<int, int, Cmp, OomAllocator> rbtree;\n+  bool success = rbtree.upsert(5, 5);\n+  EXPECT_EQ(false, success);\n+  \/\/ The test didn't exit the VM, so it was succesful.\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_rbtree.cpp","additions":29,"deletions":17,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+    vm.cds.nocoops.archive.available \\\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @run driver compiler.arguments.TestCompileTaskTimeout\n+ * @run driver\/timeout=480 compiler.arguments.TestCompileTaskTimeout\n@@ -52,1 +52,1 @@\n-        ProcessTools.executeTestJava(\"-Xcomp\", \"-XX:CompileTaskTimeout=200\", \"--version\")\n+        ProcessTools.executeTestJava(\"-Xcomp\", \"-XX:CompileTaskTimeout=2000\", \"--version\")\n@@ -55,1 +55,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestCompileTaskTimeout.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- * @run main\/othervm\/timeout=7200\n+ * @run main\/othervm\/timeout=28800\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/TestStressArrayCopy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-  * @run main\/othervm\/timeout=480 -Xcomp -XX:CompileCommand=compileonly,TestConcurrentPatching::* -XX:TieredStopAtLevel=1 TestConcurrentPatching\n+  * @run main\/othervm\/timeout=1920 -Xcomp -XX:CompileCommand=compileonly,TestConcurrentPatching::* -XX:TieredStopAtLevel=1 TestConcurrentPatching\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestConcurrentPatching.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main\/othervm -XX:TieredStopAtLevel=1 -Xbatch\n+ * @run main\/othervm\/timeout=480 -XX:TieredStopAtLevel=1 -Xbatch\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestPinnedIntrinsics.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @run main compiler.c2.TestMergeStores aligned\n+ * @run main\/timeout=480 compiler.c2.TestMergeStores aligned\n@@ -49,1 +49,1 @@\n- * @run main compiler.c2.TestMergeStores unaligned\n+ * @run main\/timeout=480 compiler.c2.TestMergeStores unaligned\n@@ -58,1 +58,1 @@\n- * @run main compiler.c2.TestMergeStores StressIGVN\n+ * @run main\/timeout=480 compiler.c2.TestMergeStores StressIGVN\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStores.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,2 @@\n- * @run main\/othervm compiler.c2.TestScalarReplacementMaxLiveNodes\n- * @run main\/othervm -Xbatch -XX:-OptimizeStringConcat -XX:-TieredCompilation\n+ * @run main\/othervm\/timeout=480 compiler.c2.TestScalarReplacementMaxLiveNodes\n+ * @run main\/othervm\/timeout=480 -Xbatch -XX:-OptimizeStringConcat -XX:-TieredCompilation\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestScalarReplacementMaxLiveNodes.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main\/othervm -Xcomp -XX:+IgnoreUnrecognizedVMOptions -XX:+StressRecompilation\n+ * @run main\/othervm\/timeout=480 -Xcomp -XX:+IgnoreUnrecognizedVMOptions -XX:+StressRecompilation\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestStressRecompilation.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/* Copyright (c) 2025, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8361582\n+* @summary Ensure the correct backend replicate node is being generated for\n+*          half precision float constants on >16B SVE machines\n+* @modules jdk.incubator.vector\n+* @library \/test\/lib \/\n+* @run main\/othervm compiler.c2.aarch64.TestFloat16Replicate\n+*\/\n+\n+package compiler.c2.aarch64;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.verify.*;\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.incubator.vector.Float16;\n+import jdk.test.lib.*;\n+import jdk.test.lib.Utils;\n+\n+import static java.lang.Float.*;\n+import static jdk.incubator.vector.Float16.*;\n+\n+public class TestFloat16Replicate {\n+    private static short[] input;\n+    private static short[] output;\n+    private static short[] expected;\n+    private static Random rnd;\n+\n+    \/\/ Choose FP16_IMM8 which is within the range of [-128 << 8, 127 << 8] and a multiple of 256\n+    private static final Float16 FP16_IMM8;\n+\n+    \/\/ Choose a value in the range [-128 << 8, 127 << 8] and a non multiple of 256 for FP16_NON_IMM8\n+    private static final Float16 FP16_NON_IMM8;\n+\n+    private static final int LEN = 1024;\n+\n+    public static void main(String args[]) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\");\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:-TieredCompilation\");\n+    }\n+\n+    static {\n+        rnd = Utils.getRandomInstance();\n+        int k = rnd.nextInt(-128, 128);\n+        int b = rnd.nextInt(1, 256);\n+        short bits_imm8     = (short) (k << 8);\n+        short bits_non_imm8 = (short) ((k << 8) + b);\n+\n+        FP16_IMM8     = Float16.shortBitsToFloat16(bits_imm8);\n+        FP16_NON_IMM8 = Float16.shortBitsToFloat16(bits_non_imm8);\n+\n+        input  = new short[LEN];\n+        output = new short[LEN];\n+        expected = new short[LEN];\n+\n+        for (int i = 0; i < LEN; i++) {\n+            input[i] = (short) i;\n+        }\n+    }\n+\n+    \/\/ For vectorizable loops containing FP16 operations with an FP16 constant as one of the inputs, the IR\n+    \/\/ node `(dst (Replicate con))` is generated to broadcast the constant into all lanes of an SVE register.\n+    \/\/ On SVE-capable hardware with vector length > 16B, if the FP16 immediate is a signed value within the\n+    \/\/ range [-128, 127] or a signed multiple of 256 in the range [-32768, 32512] for element widths of\n+    \/\/ 16 bits or higher then the backend should generate the \"replicateHF_imm_gt128b\" machnode.\n+    @Test\n+    @Warmup(5000)\n+    @IR(counts = {IRNode.REPLICATE_HF_IMM8, \">0\"},\n+        phase = CompilePhase.FINAL_CODE,\n+        applyIf = {\"MaxVectorSize\", \">16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    public void TestFloat16AddInRange() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(Float16.add(shortBitsToFloat16(input[i]), FP16_IMM8));\n+        }\n+    }\n+\n+    @Check(test=\"TestFloat16AddInRange\")\n+    public void checkResultFloat16AddInRange() {\n+        for (int i = 0; i < LEN; ++i) {\n+            expected[i] = floatToFloat16(float16ToFloat(input[i]) + FP16_IMM8.floatValue());\n+        }\n+        Verify.checkEQWithRawBits(output, expected);\n+    }\n+\n+    \/\/ For vectorizable loops containing FP16 operations with an FP16 constant as one of the inputs, the IR\n+    \/\/ node `(dst (Replicate con))` is generated to broadcast the constant into all lanes of an SVE register.\n+    \/\/ On SVE-capable hardware with vector length > 16B, if the FP16 constant falls outside the immediate\n+    \/\/ range accepted by the SVE \"dup\" instruction, the backend must:\n+    \/\/   1. Generate the \"loadConH\" machnode to load the FP16 constant from the constant pool.\n+    \/\/   2. Emit the \"replicateHF\" machnode to broadcast this loaded constant into an SVE register.\n+    \/\/ In this case, the backend should not generate the \"replicateHF_imm8_gt128b\" machnode.\n+    @Test\n+    @Warmup(5000)\n+    @IR(counts = {IRNode.REPLICATE_HF, \">0\"},\n+        failOn = {IRNode.REPLICATE_HF_IMM8},\n+        phase = CompilePhase.FINAL_CODE,\n+        applyIf = {\"MaxVectorSize\", \">16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    public void TestFloat16AddOutOfRange() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(add(shortBitsToFloat16(input[i]), FP16_NON_IMM8));\n+        }\n+    }\n+\n+    @Check(test=\"TestFloat16AddOutOfRange\")\n+    public void checkResultFloat16AddOutOfRange() {\n+        for (int i = 0; i < LEN; ++i) {\n+            expected[i] = floatToFloat16(float16ToFloat(input[i]) + FP16_NON_IMM8.floatValue());\n+        }\n+        Verify.checkEQWithRawBits(output, expected);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestFloat16Replicate.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.List;\n@@ -53,13 +54,18 @@\n-        \/\/ Cross-product: +-AlignVector and +-UseCompactObjectHeaders\n-        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n-                                   \"-XX:-UseCompactObjectHeaders\",\n-                                   \"-XX:-AlignVector\");\n-        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n-                                   \"-XX:-UseCompactObjectHeaders\",\n-                                   \"-XX:+AlignVector\");\n-        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n-                                   \"-XX:+UseCompactObjectHeaders\",\n-                                   \"-XX:-AlignVector\");\n-        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n-                                   \"-XX:+UseCompactObjectHeaders\",\n-                                   \"-XX:+AlignVector\");\n+        TestFramework framework = new TestFramework();\n+        framework.addFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                           \"-XX:+UnlockExperimentalVMOptions\");\n+\n+        \/\/ Cross-product:\n+        \/\/   +-AlignVector\n+        \/\/   +-UseCompactObjectHeaders\n+        \/\/   +-UseAutoVectorizationSpeculativeAliasingChecks\n+        int idx = 0;\n+        for (String av : List.of(\"-XX:-AlignVector\", \"-XX:+AlignVector\")) {\n+            for (String coh : List.of(\"-XX:-UseCompactObjectHeaders\", \"-XX:+UseCompactObjectHeaders\")) {\n+                for (String sac : List.of(\"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\")) {\n+                    framework.addScenarios(new Scenario(idx++, av, coh, sac));\n+                }\n+            }\n+        }\n+\n+        framework.start();\n@@ -129,1 +135,1 @@\n-            int val = offset > 0 ? verifyByteArray[(i-offset) % 8] : verifyByteArray[i-offset];\n+            int val = offset >=1 ? verifyByteArray[(i-offset) % 8] : verifyByteArray[i-offset];\n@@ -482,1 +488,8 @@\n-    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR })\n+    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR },\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\", \".*multiversion.*\", \">=1\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ We have unknown aliasing. At runtime \"dest == src\", so the AutoVectorization Predicate fails, and recompiles with Multiversioning.\n@@ -490,1 +503,8 @@\n-    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR })\n+    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR },\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\", \".*multiversion.*\", \">=1\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ We have unknown aliasing. At runtime \"dest == src\", so the AutoVectorization Predicate fails, and recompiles with Multiversioning.\n@@ -504,1 +524,8 @@\n-    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR })\n+    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR },\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\", \".*multiversion.*\", \">=1\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ We have unknown aliasing. At runtime \"dest == src\", so the AutoVectorization Predicate fails, and recompiles with Multiversioning.\n@@ -512,1 +539,8 @@\n-    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR })\n+    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR },\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\", \".*multiversion.*\", \">=1\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ We have unknown aliasing. At runtime \"dest == src\", so the AutoVectorization Predicate fails, and recompiles with Multiversioning.\n@@ -527,1 +561,8 @@\n-    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR })\n+    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR },\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\", \".*multiversion.*\", \">=1\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ We have unknown aliasing. At runtime \"dest == src\", so the AutoVectorization Predicate fails, and recompiles with Multiversioning.\n@@ -535,1 +576,8 @@\n-    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR })\n+    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR },\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\", \".*multiversion.*\", \">=1\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ We have unknown aliasing. At runtime \"dest == src\", so the AutoVectorization Predicate fails, and recompiles with Multiversioning.\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizationMismatchedAccess.java","additions":68,"deletions":20,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main\/othervm\/timeout=300 -XX:-TieredCompilation -XX:CompileThreshold=2 -XX:CICompilerCount=1\n+ * @run main\/othervm\/timeout=1200 -XX:-TieredCompilation -XX:CompileThreshold=2 -XX:CICompilerCount=1\n@@ -31,1 +31,1 @@\n- * @run main\/othervm\/timeout=300 -XX:TieredCompileTaskTimeout=1000 -XX:CompileThresholdScaling=0.001 -XX:CICompilerCount=2\n+ * @run main\/othervm\/timeout=1200 -XX:TieredCompileTaskTimeout=1000 -XX:CompileThresholdScaling=0.001 -XX:CICompilerCount=2\n","filename":"test\/hotspot\/jtreg\/compiler\/classUnloading\/methodUnloading\/TestOverloadCompileQueues.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run main\/othervm -XX:CompileOnly=TestAntiDependenciesHighMemUsage2::test1 -XX:-ClipInlining\n+ * @run main\/othervm\/timeout=480 -XX:CompileOnly=TestAntiDependenciesHighMemUsage2::test1 -XX:-ClipInlining\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestAntiDependenciesHighMemUsage2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main\/othervm -Xbatch\n+ * @run main\/othervm\/timeout=480 -Xbatch\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/aes\/TestCipherBlockChainingEncrypt.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:-UseOnStackReplacement -XX:CompileOnly=TestLoadBypassesClassCast::test\n+ * @run main\/othervm\/timeout=480 -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:-UseOnStackReplacement -XX:CompileOnly=TestLoadBypassesClassCast::test\n","filename":"test\/hotspot\/jtreg\/compiler\/controldependency\/TestLoadBypassesClassCast.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/othervm\/native compiler.floatingpoint.TestFloatSyncJNIArgs\n+ * @run main\/othervm\/native\/timeout=480 compiler.floatingpoint.TestFloatSyncJNIArgs\n","filename":"test\/hotspot\/jtreg\/compiler\/floatingpoint\/TestFloatSyncJNIArgs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-* @run driver compiler.intrinsics.TestLongUnsignedDivMod\n+* @run driver\/timeout=480 compiler.intrinsics.TestLongUnsignedDivMod\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestLongUnsignedDivMod.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+ * @requires (os.arch != \"riscv64\" | (os.arch == \"riscv64\" & vm.cpu.features ~= \".*rvv.*\"))\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestVerifyIntrinsicChecks.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run driver\/timeout=180 compiler.jsr292.ContinuousCallSiteTargetChange\n+ * @run driver\/timeout=720 compiler.jsr292.ContinuousCallSiteTargetChange\n","filename":"test\/hotspot\/jtreg\/compiler\/jsr292\/ContinuousCallSiteTargetChange.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @run main\/othervm -Djdk.attach.allowAttachSelf compiler.jsr292.RedefineMethodUsedByMultipleMethodHandles\n+ * @run main\/othervm\/timeout=480 -Djdk.attach.allowAttachSelf compiler.jsr292.RedefineMethodUsedByMultipleMethodHandles\n","filename":"test\/hotspot\/jtreg\/compiler\/jsr292\/RedefineMethodUsedByMultipleMethodHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run junit\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler -Djdk.attach.allowAttachSelf jdk.vm.ci.runtime.test.RedefineClassTest\n+ * @run junit\/othervm\/timeout=480 -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler -Djdk.attach.allowAttachSelf jdk.vm.ci.runtime.test.RedefineClassTest\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/RedefineClassTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n- * @run junit\/othervm\/timeout=240 -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler jdk.vm.ci.runtime.test.TestResolvedJavaMethod\n+ * @run junit\/othervm\/timeout=960 -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler jdk.vm.ci.runtime.test.TestResolvedJavaMethod\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaMethod.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2899,0 +2899,10 @@\n+    public static final String REPLICATE_HF = PREFIX + \"REPLICATE_HF\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(REPLICATE_HF, \"replicateHF\");\n+    }\n+\n+    public static final String REPLICATE_HF_IMM8 = PREFIX + \"REPLICATE_HF_IMM8\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(REPLICATE_HF_IMM8, \"replicateHF_imm8_gt128b\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-If a user wants to provide multiple flag combinations for a single test, he or she has the option to provide different scenarios. A scenario based flag will always have precedence over other user defined flags. More information about scenarios can be found in the Javadocs of [Scenario](.\/Scenario.java).\n+If a user wants to provide multiple flag combinations for a single test, he or she has the option to provide different scenarios. A scenario based flag will always have precedence over other user defined flags. More information about scenarios can be found in the Javadocs of [Scenario](.\/Scenario.java). If a user wants to test all combinations of multiple sets of flags, they can use `TestFramework.addCrossProductScenarios()`.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/README.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -50,0 +51,1 @@\n+import java.util.stream.Stream;\n@@ -336,0 +338,65 @@\n+    \/**\n+     * Add the cross-product (cartesian product) of sets of flags as Scenarios. Unlike when when constructing\n+     * scenarios directly a string can contain multiple flags separated with a space. This allows grouping\n+     * flags that have to be specified togeher. Further, an empty string in a set stands in for \"no flag\".\n+     * <p>\n+     * Example:\n+     * <pre>\n+     *     addCrossProductScenarios(Set.of(\"\", \"-Xint\", \"-Xbatch -XX:-TieredCompilation\"),\n+     *                              Set.of(\"-XX:+UseNewCode\", \"-XX:UseNewCode2\"))\n+     * <\/pre>\n+     *   produces the following Scenarios\n+     * <pre>\n+     *     Scenario(0, \"-XX:+UseNewCode\")\n+     *     Scenario(1, \"-XX:+UseNewCode2\")\n+     *     Scenario(2, \"-Xint\", \"-XX:+UseNewCode\")\n+     *     Scenario(3, \"-Xint\", \"-XX:+UseNewCode2\")\n+     *     Scenario(4, \"-Xbatch -XX:-TieredCompilation\", \"-XX:+UseNewCode\")\n+     *     Scenario(5, \"-Xbatch -XX:-TieredCompilation\", \"-XX:+UseNewCode2\")\n+     * <\/pre>\n+     *\n+     * @param sets sets of flags to generate the cross product for.\n+     * @return the same framework instance.\n+     *\/\n+    @SafeVarargs\n+    final public TestFramework addCrossProductScenarios(Set<String>... flagSets) {\n+        TestFormat.checkAndReport(flagSets != null &&\n+                                  Arrays.stream(flagSets).noneMatch(Objects::isNull) &&\n+                                  Arrays.stream(flagSets).flatMap(Set::stream).noneMatch(Objects::isNull),\n+                                  \"Flags must not be null\");\n+        if (flagSets.length == 0) {\n+            return this;\n+        }\n+\n+        int initIdx = 0;\n+        if (this.scenarioIndices != null && !this.scenarioIndices.isEmpty()) {\n+            initIdx = this.scenarioIndices.stream().max(Comparator.comparingInt(Integer::intValue)).get() + 1;\n+        }\n+        AtomicInteger idx = new AtomicInteger(initIdx);\n+\n+        Stream<List<String>> crossProduct = Arrays.stream(flagSets)\n+            .reduce(\n+                Stream.of(Collections.<String>emptyList()), \/\/ Initialize Stream<List<String>> acc with a Stream containing an empty list of Strings.\n+                (Stream<List<String>> acc, Set<String> set) ->\n+                    acc.flatMap(lAcc -> \/\/ For each List<String>> lAcc in acc...\n+                        set.stream().map(flag -> { \/\/ ...and each flag in the current set...\n+                            List<String> newList = new ArrayList<>(lAcc); \/\/ ...create a new list containing lAcc...\n+                            newList.add(flag); \/\/ ...and append the flag.\n+                            return newList;\n+                        }) \/\/ This results in one List<List<String>> for each lAcc...\n+                    ), \/\/ ...that get flattend into one big List<List<String>>.\n+                (a, b) -> Stream.concat(a, b)); \/\/ combiner; if any reduction steps are executed in parallel, just concat two streams.\n+\n+        Scenario[] newScenarios = crossProduct\n+            .map(flags -> new Scenario( \/\/ For each List<String> flags in crossProduct create a new Scenario.\n+                idx.getAndIncrement(),\n+                flags.stream() \/\/ Process flags\n+                     .map(s -> Set.of(s.split(\"[ ]\"))) \/\/ Split muliple flags in the same string into separate strings.\n+                     .flatMap(Collection::stream) \/\/ Flatten the Stream<List<String>> into Stream<String>>.\n+                     .filter(s -> !s.isEmpty()) \/\/ Remove empty string flags.\n+                     .collect(Collectors.toList())\n+                     .toArray(new String[0])))\n+            .collect(Collectors.toList()).toArray(new Scenario[0]);\n+        return addScenarios(newScenarios);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main\/othervm -Xcomp -XX:-PartialPeelLoop -XX:CompileCommand=compileonly,TestMaxLoopOptsCountReached::test TestMaxLoopOptsCountReached\n+ * @run main\/othervm\/timeout=480 -Xcomp -XX:-PartialPeelLoop -XX:CompileCommand=compileonly,TestMaxLoopOptsCountReached::test TestMaxLoopOptsCountReached\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestMaxLoopOptsCountReached.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main\/othervm -Xbatch -XX:-TieredCompilation\n+ * @run main\/othervm\/timeout=480 -Xbatch -XX:-TieredCompilation\n@@ -37,1 +37,1 @@\n- * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ * @run main\/othervm\/timeout=480 -Xcomp -XX:-TieredCompilation\n@@ -48,1 +48,1 @@\n- * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=*TestPartialPeel*::original*,*TestPartialPeel*::test*\n+ * @run main\/othervm\/timeout=480 -Xcomp -XX:-TieredCompilation -XX:CompileOnly=*TestPartialPeel*::original*,*TestPartialPeel*::test*\n@@ -58,1 +58,1 @@\n- * @run main compiler.loopopts.TestPartialPeelAtUnsignedTestsNegativeLimit\n+ * @run main\/timeout=480 compiler.loopopts.TestPartialPeelAtUnsignedTestsNegativeLimit\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestPartialPeelAtUnsignedTestsNegativeLimit.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.ProdRed_Double\n+ * @run driver\/timeout=480 compiler.loopopts.superword.ProdRed_Double\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ProdRed_Double.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.ProdRed_Float\n+ * @run driver\/timeout=480 compiler.loopopts.superword.ProdRed_Float\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ProdRed_Float.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.ProdRed_Int\n+ * @run driver\/timeout=480 compiler.loopopts.superword.ProdRed_Int\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ProdRed_Int.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.SumRedAbsNeg_Double\n+ * @run driver\/timeout=480 compiler.loopopts.superword.SumRedAbsNeg_Double\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRedAbsNeg_Double.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.SumRedAbsNeg_Float\n+ * @run driver\/timeout=480 compiler.loopopts.superword.SumRedAbsNeg_Float\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRedAbsNeg_Float.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.SumRedSqrt_Double\n+ * @run driver\/timeout=480 compiler.loopopts.superword.SumRedSqrt_Double\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRedSqrt_Double.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.SumRed_Double\n+ * @run driver\/timeout=480 compiler.loopopts.superword.SumRed_Double\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRed_Double.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.SumRed_Float\n+ * @run driver\/timeout=480 compiler.loopopts.superword.SumRed_Float\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRed_Float.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.SumRed_Int\n+ * @run driver\/timeout=480 compiler.loopopts.superword.SumRed_Int\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRed_Int.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,516 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8324751\n+ * @summary Test Speculative Aliasing checks in SuperWord\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestAliasing nCOH_nAV_ySAC\n+ * @run driver compiler.loopopts.superword.TestAliasing nCOH_yAV_ySAC\n+ * @run driver compiler.loopopts.superword.TestAliasing yCOH_nAV_ySAC\n+ * @run driver compiler.loopopts.superword.TestAliasing yCOH_yAV_ySAC\n+ * @run driver compiler.loopopts.superword.TestAliasing nCOH_nAV_nSAC\n+ * @run driver compiler.loopopts.superword.TestAliasing nCOH_yAV_nSAC\n+ * @run driver compiler.loopopts.superword.TestAliasing yCOH_nAV_nSAC\n+ * @run driver compiler.loopopts.superword.TestAliasing yCOH_yAV_nSAC\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import jdk.test.lib.Utils;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Random;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.verify.*;\n+import static compiler.lib.generators.Generators.G;\n+import compiler.lib.generators.Generator;\n+\n+\/**\n+ * More complicated test cases can be found in {@link TestAliasingFuzzing}.\n+ *\/\n+public class TestAliasing {\n+    static int SIZE = 1024*8;\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+    private static final Generator INT_GEN = G.ints();\n+\n+    \/\/ Invariants used in tests.\n+    public static int INVAR_ZERO = 0;\n+\n+    \/\/ Original data.\n+    public static byte[] ORIG_AB = fillRandom(new byte[SIZE]);\n+    public static byte[] ORIG_BB = fillRandom(new byte[SIZE]);\n+    public static int[]  ORIG_AI = fillRandom(new int[SIZE]);\n+    public static int[]  ORIG_BI = fillRandom(new int[SIZE]);\n+\n+    \/\/ The data we use in the tests. It is initialized from ORIG_* every time.\n+    public static byte[] AB = new byte[SIZE];\n+    public static byte[] BB = new byte[SIZE];\n+    public static int[]  AI = new int[SIZE];\n+    public static int[]  BI = new int[SIZE];\n+\n+    \/\/ Parallel to data above, but for use in reference methods.\n+    public static byte[] AB_REFERENCE = new byte[SIZE];\n+    public static byte[] BB_REFERENCE = new byte[SIZE];\n+    public static int[]  AI_REFERENCE = new int[SIZE];\n+    public static int[]  BI_REFERENCE = new int[SIZE];\n+\n+    interface TestFunction {\n+        void run();\n+    }\n+\n+    \/\/ Map of goldTests, i.e. tests that work with a golds value generated from the same test method,\n+    \/\/ at the beginning when we are still executing in the interpreter.\n+    Map<String,TestFunction> goldTests = new HashMap<String,TestFunction>();\n+\n+    \/\/ Map of gold, the results from the first run before compilation, one per goldTests entry.\n+    Map<String,Object> golds = new HashMap<String,Object>();\n+\n+    \/\/ Map of referenceTests, i.e. tests that have a reference implementation that is run with the interpreter.\n+    \/\/ The TestFunction must run both the test and reference methods.\n+    Map<String,TestFunction> referenceTests = new HashMap<String,TestFunction>();\n+\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework(TestAliasing.class);\n+        switch (args[0]) {\n+            case \"nCOH_nAV_ySAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"nCOH_yAV_ySAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"yCOH_nAV_ySAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"yCOH_yAV_ySAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"nCOH_nAV_nSAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"nCOH_yAV_nSAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"yCOH_nAV_nSAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"yCOH_yAV_nSAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            default -> { throw new RuntimeException(\"Test argument not recognized: \" + args[0]); }\n+        };\n+        framework.start();\n+    }\n+\n+    public TestAliasing() {\n+        \/\/ Add all goldTests to list\n+        goldTests.put(\"copy_B_sameIndex_noalias\",         () -> { copy_B_sameIndex_noalias(AB, BB); });\n+        goldTests.put(\"copy_B_sameIndex_alias\",           () -> { copy_B_sameIndex_alias(AB, AB); });\n+        goldTests.put(\"copy_B_differentIndex_noalias\",    () -> { copy_B_differentIndex_noalias(AB, BB); });\n+        goldTests.put(\"copy_B_differentIndex_noalias_v2\", () -> { copy_B_differentIndex_noalias_v2(); });\n+        goldTests.put(\"copy_B_differentIndex_alias\",      () -> { copy_B_differentIndex_alias(AB, AB); });\n+\n+        goldTests.put(\"copy_I_sameIndex_noalias\",         () -> { copy_I_sameIndex_noalias(AI, BI); });\n+        goldTests.put(\"copy_I_sameIndex_alias\",           () -> { copy_I_sameIndex_alias(AI, AI); });\n+        goldTests.put(\"copy_I_differentIndex_noalias\",    () -> { copy_I_differentIndex_noalias(AI, BI); });\n+        goldTests.put(\"copy_I_differentIndex_alias\",      () -> { copy_I_differentIndex_alias(AI, AI); });\n+\n+        \/\/ Compute gold value for all test methods before compilation\n+        for (Map.Entry<String,TestFunction> entry : goldTests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            init();\n+            test.run();\n+            Object gold = snapshotCopy();\n+            golds.put(name, gold);\n+        }\n+\n+        referenceTests.put(\"fill_B_sameArray_alias\", () -> {\n+            int invar1 = RANDOM.nextInt(64);\n+            int invar2 = RANDOM.nextInt(64);\n+            test_fill_B_sameArray_alias(AB, AB, invar1, invar2);\n+            reference_fill_B_sameArray_alias(AB_REFERENCE, AB_REFERENCE, invar1, invar2);\n+        });\n+        referenceTests.put(\"fill_B_sameArray_noalias\", () -> {\n+            \/\/ The accesses either start at the middle and go out,\n+            \/\/ or start from opposite sides and meet in the middle.\n+            \/\/ But they never overlap.\n+            \/\/      <------|------>\n+            \/\/      ------>|<------\n+            \/\/\n+            \/\/ This tests that the checks we emit are not too relaxed.\n+            int middle = SIZE \/ 2 + RANDOM.nextInt(-256, 256);\n+            int limit = SIZE \/ 3 + RANDOM.nextInt(256);\n+            int invar1 = middle;\n+            int invar2 = middle;\n+            if (RANDOM.nextBoolean()) {\n+                invar1 -= limit;\n+                invar2 += limit;\n+            }\n+            test_fill_B_sameArray_noalias(AB, AB, invar1, invar2, limit);\n+            reference_fill_B_sameArray_noalias(AB_REFERENCE, AB_REFERENCE, invar1, invar2, limit);\n+        });\n+    }\n+\n+    public static void init() {\n+        System.arraycopy(ORIG_AB, 0, AB, 0, SIZE);\n+        System.arraycopy(ORIG_BB, 0, BB, 0, SIZE);\n+        System.arraycopy(ORIG_AI, 0, AI, 0, SIZE);\n+        System.arraycopy(ORIG_BI, 0, BI, 0, SIZE);\n+    }\n+\n+    public static void initReference() {\n+        System.arraycopy(ORIG_AB, 0, AB_REFERENCE, 0, SIZE);\n+        System.arraycopy(ORIG_BB, 0, BB_REFERENCE, 0, SIZE);\n+        System.arraycopy(ORIG_AI, 0, AI_REFERENCE, 0, SIZE);\n+        System.arraycopy(ORIG_BI, 0, BI_REFERENCE, 0, SIZE);\n+    }\n+\n+    public static Object snapshotCopy() {\n+        return new Object[] {\n+            AB.clone(), BB.clone(),\n+            AI.clone(), BI.clone()\n+        };\n+    }\n+\n+    public static Object snapshot() {\n+        return new Object[] {\n+            AB, BB,\n+            AI, BI\n+        };\n+    }\n+\n+    public static Object snapshotReference() {\n+        return new Object[] {\n+            AB_REFERENCE, BB_REFERENCE,\n+            AI_REFERENCE, BI_REFERENCE\n+        };\n+    }\n+\n+    @Warmup(100)\n+    @Run(test = {\"copy_B_sameIndex_noalias\",\n+                 \"copy_B_sameIndex_alias\",\n+                 \"copy_B_differentIndex_noalias\",\n+                 \"copy_B_differentIndex_noalias_v2\",\n+                 \"copy_B_differentIndex_alias\",\n+                 \"copy_I_sameIndex_noalias\",\n+                 \"copy_I_sameIndex_alias\",\n+                 \"copy_I_differentIndex_noalias\",\n+                 \"copy_I_differentIndex_alias\",\n+                 \"test_fill_B_sameArray_alias\",\n+                 \"test_fill_B_sameArray_noalias\"})\n+    public void runTests() {\n+        for (Map.Entry<String,TestFunction> entry : goldTests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            \/\/ Recall gold value from before compilation\n+            Object gold = golds.get(name);\n+            \/\/ Compute new result\n+            init();\n+            test.run();\n+            Object result = snapshot();\n+            \/\/ Compare gold and new result\n+            try {\n+                Verify.checkEQ(gold, result);\n+            } catch (VerifyException e) {\n+                throw new RuntimeException(\"Verify failed for \" + name, e);\n+            }\n+        }\n+\n+        for (Map.Entry<String,TestFunction> entry : referenceTests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            \/\/ Init data for test and reference\n+            init();\n+            initReference();\n+            \/\/ Run test and reference\n+            test.run();\n+            \/\/ Capture results from test and reference\n+            Object result = snapshot();\n+            Object expected = snapshotReference();\n+            \/\/ Compare expected and new result\n+            try {\n+                Verify.checkEQ(expected, result);\n+            } catch (VerifyException e) {\n+                throw new RuntimeException(\"Verify failed for \" + name, e);\n+            }\n+        }\n+    }\n+\n+    static byte[] fillRandom(byte[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (byte)(int)INT_GEN.next();\n+        }\n+        return a;\n+    }\n+\n+    static int[] fillRandom(int[] a) {\n+        G.fill(INT_GEN, a);\n+        return a;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Should always vectorize, no speculative runtime check required.\n+    static void copy_B_sameIndex_noalias(byte[] a, byte[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+          b[i] = a[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Should always vectorize, no speculative runtime check required.\n+    static void copy_B_sameIndex_alias(byte[] a, byte[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+          b[i] = a[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Without speculative runtime check we cannot know that there is no aliasing.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ We use speculative runtime checks, they never fail, so no multiversioning required.\n+    \/\/ With AlignVector we cannot prove that both accesses are alignable.\n+    static void copy_B_differentIndex_noalias(byte[] a, byte[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+          b[i] = a[i + INVAR_ZERO];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Without speculative runtime check we cannot know that there is no aliasing.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ We use speculative runtime checks, they never fail, so no multiversioning required.\n+    \/\/ With AlignVector we cannot prove that both accesses are alignable.\n+    \/\/\n+    \/\/ Same as \"copy_B_differentIndex_noalias, but somehow loading from fields rather\n+    \/\/ than arguments does not lead to vectorization.\n+    static void copy_B_differentIndex_noalias_v2() {\n+        for (int i = 0; i < AB.length; i++) {\n+            BB[i] = AB[i + INVAR_ZERO];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Without speculative runtime check we cannot know that there is no aliasing.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B,            \"> 0\",\n+                  IRNode.STORE_VECTOR,             \"> 0\",\n+                  \".*pre .* multiversion_fast.*\",  \"= 1\",\n+                  \".*main .* multiversion_fast.*\", \"= 1\",\n+                  \".*post .* multiversion_fast.*\", \"= 2\", \/\/ vectorized and scalar versions\n+                  \".*multiversion_slow.*\",         \"= 2\", \/\/ main and post (pre-loop only has a single iteration)\n+                  \".*multiversion.*\",              \"= 6\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\",\n+                      \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ We use speculative runtime checks, it fails and so we do need multiversioning.\n+    \/\/ With AlignVector we cannot prove that both accesses are alignable.\n+    static void copy_B_differentIndex_alias(byte[] a, byte[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+          b[i] = a[i + INVAR_ZERO];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Should always vectorize, no speculative runtime check required.\n+    static void copy_I_sameIndex_noalias(int[] a, int[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+          b[i] = a[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Should always vectorize, no speculative runtime check required.\n+    static void copy_I_sameIndex_alias(int[] a, int[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+          b[i] = a[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Without speculative runtime check we cannot know that there is no aliasing.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ We use speculative runtime checks, they never fail, so no multiversioning required.\n+    \/\/ With AlignVector we cannot prove that both accesses are alignable.\n+    static void copy_I_differentIndex_noalias(int[] a, int[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+          b[i] = a[i + INVAR_ZERO];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Without speculative runtime check we cannot know that there is no aliasing.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,            \"> 0\",\n+                  IRNode.STORE_VECTOR,             \"> 0\",\n+                  \".*pre .* multiversion_fast.*\",  \"= 1\",\n+                  \".*main .* multiversion_fast.*\", \"= 1\",\n+                  \".*post .* multiversion_fast.*\", \"= 2\", \/\/ vectorized and scalar versions\n+                  \".*multiversion_slow.*\",         \"= 2\", \/\/ main and post (pre-loop only has a single iteration)\n+                  \".*multiversion.*\",              \"= 6\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\",\n+                      \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ We use speculative runtime checks, it fails and so we do need multiversioning.\n+    \/\/ With AlignVector we cannot prove that both accesses are alignable.\n+    static void copy_I_differentIndex_alias(int[] a, int[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            b[i] = a[i + INVAR_ZERO];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Without speculative runtime check we cannot know that there is no aliasing.\n+    @IR(counts = {IRNode.STORE_VECTOR,             \"> 0\",\n+                  \".*pre .* multiversion_fast.*\",  \"= 1\",\n+                  \".*main .* multiversion_fast.*\", \"= 1\",\n+                  \".*post .* multiversion_fast.*\", \"= 2\", \/\/ vectorized and scalar versions\n+                  \".*multiversion_slow.*\",         \"= 2\", \/\/ main and post (pre-loop only has a single iteration)\n+                  \".*multiversion.*\",              \"= 6\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\",\n+                      \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ We use speculative runtime checks, it fails and so we do need multiversioning.\n+    \/\/ With AlignVector we cannot prove that both accesses are alignable.\n+    \/\/\n+    \/\/ FYI: invar1 and invar2 are small values, only used to test that everything runs\n+    \/\/      correctly with at different offsets \/ with different alignment.\n+    static void test_fill_B_sameArray_alias(byte[] a, byte[] b, int invar1, int invar2) {\n+        for (int i = 0; i < a.length - 100; i++) {\n+            a[i + invar1] = (byte)0x0a;\n+            b[a.length - i - 1 - invar2] = (byte)0x0b;\n+        }\n+    }\n+\n+    @DontCompile\n+    static void reference_fill_B_sameArray_alias(byte[] a, byte[] b, int invar1, int invar2) {\n+        for (int i = 0; i < a.length - 100; i++) {\n+            a[i + invar1] = (byte)0x0a;\n+            b[a.length - i - 1 - invar2] = (byte)0x0b;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Without speculative runtime check we cannot know that there is no aliasing.\n+    @IR(counts = {IRNode.STORE_VECTOR,             \"> 0\",\n+                  \".*multiversion.*\",              \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\",\n+                      \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ We use speculative runtime checks, and they should not fail, so no multiversioning.\n+    static void test_fill_B_sameArray_noalias(byte[] a, byte[] b, int invar1, int invar2, int limit) {\n+        for (int i = 0; i < limit; i++) {\n+            a[invar1 + i] = (byte)0x0a;\n+            b[invar2 - i] = (byte)0x0b;\n+        }\n+    }\n+\n+    @DontCompile\n+    static void reference_fill_B_sameArray_noalias(byte[] a, byte[] b, int invar1, int invar2, int limit) {\n+        for (int i = 0; i < limit; i++) {\n+            a[invar1 + i] = (byte)0x0a;\n+            b[invar2 - i] = (byte)0x0b;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAliasing.java","additions":516,"deletions":0,"binary":false,"changes":516,"status":"added"},{"patch":"@@ -0,0 +1,1284 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=vanilla\n+ * @bug 8324751\n+ * @summary Test Speculative Aliasing checks in SuperWord\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @compile ..\/..\/..\/compiler\/lib\/ir_framework\/TestFramework.java\n+ * @compile ..\/..\/..\/compiler\/lib\/generators\/Generators.java\n+ * @compile ..\/..\/..\/compiler\/lib\/verify\/Verify.java\n+ * @run driver compiler.loopopts.superword.TestAliasingFuzzer vanilla\n+ *\/\n+\n+\/*\n+ * @test id=random-flags\n+ * @bug 8324751\n+ * @summary Test Speculative Aliasing checks in SuperWord\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @compile ..\/..\/..\/compiler\/lib\/ir_framework\/TestFramework.java\n+ * @compile ..\/..\/..\/compiler\/lib\/generators\/Generators.java\n+ * @compile ..\/..\/..\/compiler\/lib\/verify\/Verify.java\n+ * @run driver compiler.loopopts.superword.TestAliasingFuzzer random-flags\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.util.Set;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Random;\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import jdk.test.lib.Utils;\n+\n+import compiler.lib.compile_framework.*;\n+import compiler.lib.generators.Generators;\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.TemplateToken;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.let;\n+import static compiler.lib.template_framework.Template.$;\n+\n+import compiler.lib.template_framework.library.TestFrameworkClass;\n+\n+\/**\n+ * Simpler test cases can be found in {@link TestAliasing}.\n+ *\n+ * We randomly generate tests to verify the behavior of the aliasing runtime checks. We feature:\n+ * - Different primitive types:\n+ *   - for access type (primitive, we can have multiple types in a single loop)\n+ *   - for backing type (primitive and additionally we have native memory)\n+ * - Different AccessScenarios:\n+ *   - copy (load and store)\n+ *   - fill (using two stores)\n+ * - Different Aliasing: in some cases we never alias at runtime, in other cases we might\n+ *   -> Should exercise both the predicate and the multiversioning approach with the\n+ *      aliasing runtime checks.\n+ * - Backing memory\n+ *   - Arrays: using int-index\n+ *   - MemorySegment (backed by primitive array or native memory):\n+ *     - Using long-index with MemorySegment::getAtIndex\n+ *     - Using byte-offset with MemorySegment::get\n+ * - Loop iv:\n+ *   - forward (counting up) and backward (counting down)\n+ *   - Different iv stride:\n+ *     - inc\/dec by one, and then scale with ivScale:   for (..; i++)  { access(i * 4); }\n+ *     - abs(ivScale) == 1, but use iv stride instead:  for (..; i+=4) { access(i); }\n+ *   - type of index, invars, and bounds (see isLongIvType)\n+ *     - int: for array and MemorySegment\n+ *     - long: for MemorySegment\n+ * - IR rules:\n+ *   - Verify that verification does (not) happen as expected.\n+ *   - Verify that we do not use multiversioning when no aliasing is expected at runtime.\n+ *     -> verify that the aliasing runtime check is not overly sensitive, so that the\n+ *        predicate does not fail unnecessarily and we have to recompile with multiversioning.\n+ *\n+ * Possible extensions (Future Work):\n+ * - Access with Unsafe\n+ * - Backing memory with Buffers\n+ * - AccessScenario:\n+ *   - More than two accesses\n+ * - Improve IR rules, once more cases vectorize (see e.g. JDK-8359688)\n+ * - Aliasing:\n+ *   - MemorySegment on same backing memory, creating different MemorySegments\n+ *     via slicing. Possibly overlapping MemorySegments.\n+ *   - CONTAINER_UNKNOWN_ALIASING_NEVER: currently always has different\n+ *     memory and split ranges. But we could alternate between same memory\n+ *     and split ranges, and then different memory but overlapping ranges.\n+ *     This would also be never aliasing.\n+ *\n+ *\/\n+public class TestAliasingFuzzer {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    public record MyType(String name, int byteSize, String con1, String con2, String layout) {\n+        @Override\n+        public String toString() { return name(); }\n+\n+        public String letter() { return name().substring(0, 1).toUpperCase(); }\n+    }\n+    public static final String con1 = \"0x0102030405060708L\";\n+    public static final String con2 = \"0x0910111213141516L\";\n+    public static final String con1F = \"Float.intBitsToFloat(0x01020304)\";\n+    public static final String con2F = \"Float.intBitsToFloat(0x09101112)\";\n+    public static final String con1D = \"Double.longBitsToDouble(\" + con1 + \")\";\n+    public static final String con2D = \"Double.longBitsToDouble(\" + con2 + \")\";\n+\n+    \/\/ List of primitive types for accesses and arrays.\n+    public static final MyType myByte   = new MyType(\"byte\",   1, con1, con2,   \"ValueLayout.JAVA_BYTE\");\n+    public static final MyType myChar   = new MyType(\"char\",   2, con1, con2,   \"ValueLayout.JAVA_CHAR_UNALIGNED\");\n+    public static final MyType myShort  = new MyType(\"short\",  2, con1, con2,   \"ValueLayout.JAVA_SHORT_UNALIGNED\");\n+    public static final MyType myInt    = new MyType(\"int\",    4, con1, con2,   \"ValueLayout.JAVA_INT_UNALIGNED\");\n+    public static final MyType myLong   = new MyType(\"long\",   8, con1, con2,   \"ValueLayout.JAVA_LONG_UNALIGNED\");\n+    public static final MyType myFloat  = new MyType(\"float\",  4, con1F, con2F, \"ValueLayout.JAVA_FLOAT_UNALIGNED\");\n+    public static final MyType myDouble = new MyType(\"double\", 8, con1D, con2D, \"ValueLayout.JAVA_DOUBLE_UNALIGNED\");\n+    public static final List<MyType> primitiveTypes\n+        = List.of(myByte, myChar, myShort, myInt, myLong, myFloat, myDouble);\n+\n+    \/\/ For native memory, we use this \"fake\" type. It has a byteSize of 1, since we measure the memory in bytes.\n+    public static final MyType myNative = new MyType(\"native\", 1, null, null,   null);\n+    public static final List<MyType> primitiveTypesAndNative\n+        = List.of(myByte, myChar, myShort, myInt, myLong, myFloat, myDouble, myNative);\n+\n+    \/\/ Do the containers (array, MemorySegment, etc) ever overlap?\n+    enum Aliasing {\n+        CONTAINER_DIFFERENT,\n+        CONTAINER_SAME_ALIASING_NEVER,\n+        CONTAINER_SAME_ALIASING_UNKNOWN,\n+        CONTAINER_UNKNOWN_ALIASING_NEVER,\n+        CONTAINER_UNKNOWN_ALIASING_UNKNOWN,\n+    }\n+\n+    enum AccessScenario {\n+        COPY_LOAD_STORE,  \/\/ a[i1] = b[i2];\n+        FILL_STORE_STORE, \/\/ a[i1] = x; b[i2] = y;\n+    }\n+\n+    enum ContainerKind {\n+        ARRAY,\n+        MEMORY_SEGMENT_LONG_ADR_SCALE,  \/\/ for (..; i++)  { access(i * 4); }\n+        MEMORY_SEGMENT_LONG_ADR_STRIDE, \/\/ for (..; i+=4) { access(i); }\n+        MEMORY_SEGMENT_AT_INDEX,\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        long t0 = System.nanoTime();\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"compiler.loopopts.superword.templated.AliasingFuzzer\", generate(comp));\n+\n+        long t1 = System.nanoTime();\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        long t2 = System.nanoTime();\n+\n+        String[] flags = switch(args[0]) {\n+            case \"vanilla\" -> new String[] {};\n+            case \"random-flags\" -> randomFlags();\n+            default -> throw new RuntimeException(\"unknown run id=\" + args[0]);\n+        };\n+        \/\/ Run the tests without any additional VM flags.\n+        \/\/ compiler.loopopts.superword.templated.AliasingFuzzer.main(new String[] {});\n+        comp.invoke(\"compiler.loopopts.superword.templated.AliasingFuzzer\", \"main\", new Object[] {flags});\n+        long t3 = System.nanoTime();\n+\n+        System.out.println(\"Code Generation:  \" + (t1-t0) * 1e-9f);\n+        System.out.println(\"Code Compilation: \" + (t2-t1) * 1e-9f);\n+        System.out.println(\"Running Tests:    \" + (t3-t2) * 1e-9f);\n+    }\n+\n+    public static String[] randomFlags() {\n+        \/\/ We don't want to always run with all flags, that is too expensive.\n+        \/\/ But let's make sure things don't completely, rot by running with some\n+        \/\/ random flags that are relevant.\n+        \/\/ We set the odds towards the \"default\" we are targetting.\n+        return new String[] {\n+            \/\/ Default disabled.\n+            \"-XX:\" + randomPlusMinus(1, 5) + \"AlignVector\",\n+            \/\/ Default enabled.\n+            \"-XX:\" + randomPlusMinus(5, 1) + \"UseAutoVectorizationSpeculativeAliasingChecks\",\n+            \"-XX:\" + randomPlusMinus(5, 1) + \"UseAutoVectorizationPredicate\",\n+            \"-XX:\" + randomPlusMinus(5, 1) + \"ShortRunningLongLoop\",\n+            \/\/ Either way is ok.\n+            \"-XX:\" + randomPlusMinus(1, 1) + \"UseCompactObjectHeaders\",\n+            \"-XX:SuperWordAutomaticAlignment=\" + RANDOM.nextInt(0,3)\n+        };\n+    }\n+\n+    public static String randomPlusMinus(int plus, int minus) {\n+        return (RANDOM.nextInt(plus + minus) < plus) ? \"+\" : \"-\";\n+    }\n+\n+    public static <T> T sample(List<T> list) {\n+        int r = RANDOM.nextInt(list.size());\n+        return list.get(r);\n+    }\n+\n+    public static String generate(CompileFramework comp) {\n+        \/\/ Create a list to collect all tests.\n+        List<TemplateToken> testTemplateTokens = new ArrayList<>();\n+\n+        \/\/ Add some basic functionalities.\n+        testTemplateTokens.add(generateIndexForm());\n+\n+        \/\/ Array tests\n+        for (int i = 0; i < 10; i++) {\n+            testTemplateTokens.add(TestGenerator.makeArray().generate());\n+        }\n+\n+        \/\/ MemorySegment with getAtIndex \/ setAtIndex\n+        for (int i = 0; i < 20; i++) {\n+            testTemplateTokens.add(TestGenerator.makeMemorySegment().generate());\n+        }\n+\n+        \/\/ Create the test class, which runs all testTemplateTokens.\n+        return TestFrameworkClass.render(\n+            \/\/ package and class name.\n+            \"compiler.loopopts.superword.templated\", \"AliasingFuzzer\",\n+            \/\/ List of imports.\n+            Set.of(\"compiler.lib.generators.*\",\n+                   \"compiler.lib.verify.*\",\n+                   \"java.lang.foreign.*\",\n+                   \"java.util.Random\",\n+                   \"jdk.test.lib.Utils\"),\n+            \/\/ classpath, so the Test VM has access to the compiled class files.\n+            comp.getEscapedClassPathOfCompiledClasses(),\n+            \/\/ The list of tests.\n+            testTemplateTokens);\n+    }\n+\n+    \/\/ The IndexForm is used to model the index. We can use it for arrays, but also by\n+    \/\/ restricting the MemorySegment index to a simple index.\n+    \/\/\n+    \/\/ Form:\n+    \/\/   index = con + iv * ivScale + invar0 * invar0Scale + invarRest\n+    \/\/                                                       [err]\n+    \/\/\n+    \/\/ The index has a size >= 1, so that the index refers to a region:\n+    \/\/   [index, index + size]\n+    \/\/\n+    \/\/ The idea is that invarRest is always close to zero, with some small range [-err .. err].\n+    \/\/ The invar variables for invarRest must be in the range [-1, 0, 1], so that we can\n+    \/\/ estimate the error range from the invarRestScales.\n+    \/\/\n+    \/\/ At runtime, we will have to generate inputs for the iv.lo\/iv.hi, as well as the invar0,\n+    \/\/ so that the index range lays in some predetermined range [range.lo, range.hi] and the\n+    \/\/ ivStride:\n+    \/\/\n+    \/\/ for (int iv = iv.lo; iv < iv.hi; iv += ivStride) {\n+    \/\/     assert: range.lo <= index(iv)\n+    \/\/                         index(iv) + size <= range.hi\n+    \/\/ }\n+    \/\/\n+    \/\/ Since there are multiple memory accesses, we may have multiple indices to compute.\n+    \/\/ Since they are all in the same loop, the indices share the same iv.lo and iv.hi. Hence,\n+    \/\/ we fix either iv.lo or iv.hi, and compute the other via the constraints.\n+    \/\/\n+    \/\/ Fix iv.lo, assume ivScale > 0:\n+    \/\/   index(iv) is smallest for iv = iv.lo, so we must satisfy\n+    \/\/     range.lo <= con + iv.lo * ivScale + invar0 * invar0Scale + invarRest\n+    \/\/              <= con + iv.lo * ivScale + invar0 * invar0Scale - err\n+    \/\/   It follows:\n+    \/\/     invar0 * invar0Scale >= range.lo - con - iv.lo * ivScale + err\n+    \/\/   This allows us to pick a invar0.\n+    \/\/   Now, we can compute the largest iv.lo possible.\n+    \/\/   index(iv) is largest for iv = iv.hi, so we must satisfy:\n+    \/\/     range.hi >= con + iv.hi * ivScale + invar0 * invar0Scale + invarRest + size\n+    \/\/              >= con + iv.hi * ivScale + invar0 * invar0Scale + err       + size\n+    \/\/   It follows:\n+    \/\/     iv.hi * ivScale <= range.hi - con - invar0 * invar0Scale - err - size\n+    \/\/   This allows us to pick a iv.hi.\n+    \/\/\n+    \/\/ More details can be found in the implementation below.\n+    \/\/\n+    public static record IndexForm(int con, int ivScale, int invar0Scale, int[] invarRestScales, int size) {\n+        public static IndexForm random(int numInvarRest, int size, int ivStrideAbs) {\n+            int con = RANDOM.nextInt(-100_000, 100_000);\n+            int ivScale = randomScale(size \/ ivStrideAbs);\n+            int invar0Scale = randomScale(size);\n+            int[] invarRestScales = new int[numInvarRest];\n+            \/\/ Sample values [-1, 0, 1]\n+            for (int i = 0; i < invarRestScales.length; i++) {\n+                invarRestScales[i] = RANDOM.nextInt(-1, 2);\n+            }\n+            return new IndexForm(con, ivScale, invar0Scale, invarRestScales, size);\n+        }\n+\n+        public static int randomScale(int size) {\n+            int scale = switch(RANDOM.nextInt(10)) {\n+                case 0 -> RANDOM.nextInt(1, 4 * size + 1); \/\/ any strided access\n+                default -> size; \/\/ in most cases, we do not want it to be strided\n+            };\n+            return RANDOM.nextBoolean() ? scale : -scale;\n+        }\n+\n+        public String generate() {\n+            return \"new IndexForm(\" + con() + \", \" + ivScale() + \", \" + invar0Scale() + \", new int[] {\" +\n+                   Arrays.stream(invarRestScales)\n+                         .mapToObj(String::valueOf)\n+                         .collect(Collectors.joining(\", \")) +\n+                   \"}, \" + size() + \")\";\n+        }\n+\n+        public TemplateToken index(String invar0, String[] invarRest) {\n+            var template = Template.make(() -> body(\n+                let(\"con\", con),\n+                let(\"ivScale\", ivScale),\n+                let(\"invar0Scale\", invar0Scale),\n+                let(\"invar0\", invar0),\n+                \"#con + #ivScale * i + #invar0Scale * #invar0\",\n+                IntStream.range(0, invarRestScales.length).mapToObj(\n+                    i -> List.of(\" + \", invarRestScales[i], \" * \", invarRest[i])\n+                ).toList()\n+            ));\n+            return template.asToken();\n+        }\n+\n+        \/\/ MemorySegment need to be long-addressed, otherwise there can be int-overflow\n+        \/\/ in the index, and that prevents RangeCheck Elimination and Vectorization.\n+        public TemplateToken indexLong(String invar0, String[] invarRest) {\n+            var template = Template.make(() -> body(\n+                let(\"con\", con),\n+                let(\"ivScale\", ivScale),\n+                let(\"invar0Scale\", invar0Scale),\n+                let(\"invar0\", invar0),\n+                \"#{con}L + #{ivScale}L * i + #{invar0Scale}L * #invar0\",\n+                IntStream.range(0, invarRestScales.length).mapToObj(\n+                    i -> List.of(\" + \", invarRestScales[i], \"L * \", invarRest[i])\n+                ).toList()\n+            ));\n+            return template.asToken();\n+        }\n+    }\n+\n+    \/\/ Mirror the IndexForm from the generator to the test.\n+    public static TemplateToken generateIndexForm() {\n+        var template = Template.make(() -> body(\n+            \"\"\"\n+            private static final Random RANDOM = Utils.getRandomInstance();\n+\n+            public static record IndexForm(int con, int ivScale, int invar0Scale, int[] invarRestScales, int size) {\n+                public IndexForm {\n+                    if (ivScale == 0 || invar0Scale == 0) {\n+                        throw new RuntimeException(\"Bad scales: \" + ivScale + \" \" + invar0Scale);\n+                    }\n+                }\n+\n+                public static record Range(int lo, int hi) {\n+                    public Range {\n+                        if (lo >= hi) { throw new RuntimeException(\"Bad range: \" + lo + \" \" + hi); }\n+                    }\n+                }\n+\n+                public int err() {\n+                    int sum = 0;\n+                    for (int scale : invarRestScales) { sum += Math.abs(scale); }\n+                    return sum;\n+                }\n+\n+                public int invar0ForIvLo(Range range, int ivLo) {\n+                    if (ivScale > 0) {\n+                        \/\/ index(iv) is smallest for iv = ivLo, so we must satisfy:\n+                        \/\/   range.lo <= con + iv.lo * ivScale + invar0 * invar0Scale + invarRest\n+                        \/\/            <= con + iv.lo * ivScale + invar0 * invar0Scale - err\n+                        \/\/ It follows:\n+                        \/\/   invar0 * invar0Scale >= range.lo - con - iv.lo * ivScale + err\n+                        int rhs = range.lo() - con - ivLo * ivScale + err();\n+                        int invar0 = (invar0Scale > 0)\n+                        ?\n+                            \/\/ invar0 * invar0Scale >=  range.lo - con - iv.lo * ivScale + err\n+                            \/\/ invar0               >= (range.lo - con - iv.lo * ivScale + err) \/ invar0Scale\n+                            Math.floorDiv(rhs + invar0Scale - 1, invar0Scale) \/\/ round up division\n+                        :\n+                            \/\/ invar0 * invar0Scale >=  range.lo - con - iv.lo * ivScale + err\n+                            \/\/ invar0               <= (range.lo - con - iv.lo * ivScale + err) \/ invar0Scale\n+                            Math.floorDiv(rhs, invar0Scale); \/\/ round down division\n+                        if (range.lo() > con + ivLo * ivScale + invar0 * invar0Scale - err()) {\n+                            throw new RuntimeException(\"sanity check failed (1)\");\n+                        }\n+                        return invar0;\n+                    } else {\n+                        \/\/ index(iv) is largest for iv = ivLo, so we must satisfy:\n+                        \/\/   range.hi >= con + iv.lo * ivScale + invar0 * invar0Scale + invarRest + size\n+                        \/\/            >= con + iv.lo * ivScale + invar0 * invar0Scale + err       + size\n+                        \/\/ It follows:\n+                        \/\/   invar0 * invar0Scale <= range.hi - con - iv.lo * ivScale - err - size\n+                        int rhs = range.hi() - con - ivLo * ivScale - err() - size();\n+                        int invar0 = (invar0Scale > 0)\n+                        ?\n+                            \/\/ invar0 * invar0Scale <= rhs\n+                            \/\/ invar0               <= rhs \/ invar0Scale\n+                            Math.floorDiv(rhs, invar0Scale) \/\/ round down division\n+                        :\n+                            \/\/ invar0 * invar0Scale <= rhs\n+                            \/\/ invar0               >= rhs \/ invar0Scale\n+                            Math.floorDiv(rhs + invar0Scale + 1, invar0Scale); \/\/ round up division\n+                        if (range.hi() < con + ivLo * ivScale + invar0 * invar0Scale + err() + size()) {\n+                            throw new RuntimeException(\"sanity check failed (2)\");\n+                        }\n+                        return invar0;\n+\n+                    }\n+                }\n+\n+                public int ivHiForInvar0(Range range, int invar0) {\n+                    if (ivScale > 0) {\n+                        \/\/ index(iv) is largest for iv = ivHi, so we must satisfy:\n+                        \/\/   range.hi >= con + iv.hi * ivScale + invar0 * invar0Scale + invarRest + size\n+                        \/\/            >= con + iv.hi * ivScale + invar0 * invar0Scale + err       + size\n+                        \/\/ It follows:\n+                        \/\/   iv.hi * ivScale <=  range.hi - con - invar0 * invar0Scale - err - size\n+                        \/\/   iv.hi           <= (range.hi - con - invar0 * invar0Scale - err - size) \/ ivScale\n+                        int rhs = range.hi() - con - invar0 * invar0Scale - err() - size();\n+                        int ivHi = Math.floorDiv(rhs, ivScale); \/\/ round down division\n+                        if (range.hi() < con + ivHi * ivScale + invar0 * invar0Scale + err() + size()) {\n+                            throw new RuntimeException(\"sanity check failed (3)\");\n+                        }\n+                        return ivHi;\n+                    } else {\n+                        \/\/ index(iv) is smallest for iv = ivHi, so we must satisfy:\n+                        \/\/   range.lo <= con + iv.hi * ivScale + invar0 * invar0Scale + invarRest\n+                        \/\/            <= con + iv.hi * ivScale + invar0 * invar0Scale - err\n+                        \/\/ It follows:\n+                        \/\/   iv.hi * ivScale >=  range.lo - con - invar0 * invar0Scale + err\n+                        \/\/   iv.hi           <= (range.lo - con - invar0 * invar0Scale + err) \/ ivScale\n+                        int rhs = range.lo() - con - invar0 * invar0Scale + err();\n+                        int ivHi = Math.floorDiv(rhs, ivScale); \/\/ round down division\n+                        if (range.lo() > con + ivHi * ivScale + invar0 * invar0Scale - err()) {\n+                            throw new RuntimeException(\"sanity check failed (4)\");\n+                        }\n+                        return ivHi;\n+\n+                    }\n+                }\n+            }\n+            \"\"\"\n+        ));\n+        return template.asToken();\n+    }\n+\n+    public static record TestGenerator(\n+        \/\/ The containers.\n+        int numContainers,\n+        int containerByteSize,\n+        ContainerKind containerKind,\n+        MyType containerElementType,\n+\n+        \/\/ Do we count up or down, iterate over the containers forward or backward?\n+        boolean loopForward,\n+        int ivStrideAbs,\n+        boolean isLongIvType,\n+\n+        \/\/ For all index forms: number of invariants in the rest, i.e. the [err] term.\n+        int numInvarRest,\n+\n+        \/\/ Each access has an index form and a type.\n+        IndexForm[] accessIndexForm,\n+        MyType[] accessType,\n+\n+        \/\/ The scenario.\n+        Aliasing aliasing,\n+        AccessScenario accessScenario) {\n+\n+        public static TestGenerator makeArray() {\n+            \/\/ Sample some random parameters:\n+            Aliasing aliasing = sample(Arrays.asList(Aliasing.values()));\n+            AccessScenario accessScenario = sample(Arrays.asList(AccessScenario.values()));\n+            MyType type = sample(primitiveTypes);\n+\n+            \/\/ size must be large enough for:\n+            \/\/   - scale = 4\n+            \/\/   - range with size \/ 4\n+            \/\/ -> need at least size 16_000 to ensure we have 1000 iterations\n+            \/\/ We want there to be a little variation, so alignment is not always the same.\n+            int numElements = Generators.G.safeRestrict(Generators.G.ints(), 18_000, 20_000).next();\n+            int containerByteSize = numElements * type.byteSize();\n+            boolean loopForward = RANDOM.nextBoolean();\n+\n+            int numInvarRest = RANDOM.nextInt(5);\n+            int ivStrideAbs = 1;\n+            boolean isLongIvType = false; \/\/ int index\n+            var form0 = IndexForm.random(numInvarRest, 1, ivStrideAbs);\n+            var form1 = IndexForm.random(numInvarRest, 1, ivStrideAbs);\n+\n+            return new TestGenerator(\n+                2,\n+                containerByteSize,\n+                ContainerKind.ARRAY,\n+                type,\n+                loopForward,\n+                ivStrideAbs,\n+                isLongIvType,\n+                numInvarRest,\n+                new IndexForm[] {form0, form1},\n+                new MyType[]    {type,   type},\n+                aliasing,\n+                accessScenario);\n+        }\n+\n+        public static int alignUp(int value, int align) {\n+            return Math.ceilDiv(value, align) * align;\n+        }\n+\n+        public static TestGenerator makeMemorySegment() {\n+            \/\/ Sample some random parameters:\n+            Aliasing aliasing = sample(Arrays.asList(Aliasing.values()));\n+            AccessScenario accessScenario = sample(Arrays.asList(AccessScenario.values()));\n+            \/\/ Backing memory can be native, access must be primitive.\n+            MyType containerElementType = sample(primitiveTypesAndNative);\n+            MyType accessType0 = sample(primitiveTypes);\n+            MyType accessType1 = sample(primitiveTypes);\n+            ContainerKind containerKind = sample(List.of(\n+                ContainerKind.MEMORY_SEGMENT_AT_INDEX,\n+                ContainerKind.MEMORY_SEGMENT_LONG_ADR_SCALE,\n+                ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE\n+            ));\n+\n+            if (containerKind == ContainerKind.MEMORY_SEGMENT_AT_INDEX) {\n+                \/\/ The access types must be the same, it is a limitation of the index computation.\n+                accessType1 = accessType0;\n+            }\n+\n+            final int minAccessSize = Math.min(accessType0.byteSize(), accessType1.byteSize());\n+            final int maxAccessSize = Math.max(accessType0.byteSize(), accessType1.byteSize());\n+\n+            \/\/ size must be large enough for:\n+            \/\/   - scale = 4\n+            \/\/   - range with size \/ 4\n+            \/\/ -> need at least size 16_000 to ensure we have 1000 iterations\n+            \/\/ We want there to be a little variation, so alignment is not always the same.\n+            final int numAccessElements = Generators.G.safeRestrict(Generators.G.ints(), 18_000, 20_000).next();\n+            final int align = Math.max(maxAccessSize, containerElementType.byteSize());\n+            \/\/ We need to align up, so the size is divisible exactly by all involved type sizes.\n+            final int containerByteSize = alignUp(numAccessElements * maxAccessSize, align);\n+            final boolean loopForward = RANDOM.nextBoolean();\n+\n+            final int numInvarRest = RANDOM.nextInt(5);\n+            int indexSize0 = accessType0.byteSize();\n+            int indexSize1 = accessType1.byteSize();\n+            if (containerKind == ContainerKind.MEMORY_SEGMENT_AT_INDEX) {\n+                \/\/ These are int-indeces for getAtIndex, so we index by element and not bytes.\n+                indexSize0 = 1;\n+                indexSize1 = 1;\n+            }\n+\n+            boolean withAbsOneIvScale = containerKind == ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE;\n+            int ivStrideAbs = containerKind == ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE ? minAccessSize : 1;\n+            boolean isLongIvType = RANDOM.nextBoolean();\n+            var form0 = IndexForm.random(numInvarRest, indexSize0, ivStrideAbs);\n+            var form1 = IndexForm.random(numInvarRest, indexSize1, ivStrideAbs);\n+\n+            return new TestGenerator(\n+                2,\n+                containerByteSize,\n+                containerKind,\n+                containerElementType,\n+                loopForward,\n+                ivStrideAbs,\n+                isLongIvType,\n+                numInvarRest,\n+                new IndexForm[] {form0, form1},\n+                new MyType[]    {accessType0, accessType1},\n+                aliasing,\n+                accessScenario);\n+        }\n+\n+        public TemplateToken generate() {\n+            var testTemplate = Template.make(() -> {\n+                \/\/ Let's generate the variable names that are to be shared for the nested Templates.\n+                String[] invarRest = new String[numInvarRest];\n+                for (int i = 0; i < invarRest.length; i++) {\n+                    invarRest[i] = $(\"invar\" + i);\n+                }\n+                String[] containerNames = new String[numContainers];\n+                for (int i = 0; i < numContainers; i++) {\n+                    containerNames[i] = $(\"container\" + i);\n+                }\n+                String[] indexFormNames = new String[accessIndexForm.length];\n+                for (int i = 0; i < indexFormNames.length; i++) {\n+                    indexFormNames[i] = $(\"index\" + i);\n+                }\n+                return body(\n+                    \"\"\"\n+                    \/\/ --- $test start ---\n+                    \"\"\",\n+                    generateTestFields(invarRest, containerNames, indexFormNames),\n+                    \"\"\"\n+                    \/\/ Count the run invocations.\n+                    private static int $iterations = 0;\n+\n+                    @Run(test = \"$test\")\n+                    @Warmup(100)\n+                    public static void $run(RunInfo info) {\n+\n+                        \/\/ Once warmup is over (100x), repeat 10x to get reasonable coverage of the\n+                        \/\/ randomness in the tests.\n+                        int reps = info.isWarmUp() ? 10 : 1;\n+                        for (int r = 0; r < reps; r++) {\n+\n+                            $iterations++;\n+                    \"\"\",\n+                    generateContainerInit(containerNames),\n+                    generateContainerAliasing(containerNames, $(\"iterations\")),\n+                    generateRanges(),\n+                    generateBoundsAndInvariants(indexFormNames, invarRest),\n+                    \"\"\"\n+                            \/\/ Run test and compare with interpreter results.\n+                    \"\"\",\n+                    generateCallMethod(\"result\", $(\"test\"), \"test\"),\n+                    generateCallMethod(\"expected\", $(\"reference\"), \"reference\"),\n+                    \"\"\"\n+                            Verify.checkEQ(result, expected);\n+                        } \/\/ end reps\n+                    } \/\/ end $run\n+\n+                    @Test\n+                    \"\"\",\n+                    generateIRRules(),\n+                    generateTestMethod($(\"test\"), invarRest),\n+                    \"\"\"\n+                    @DontCompile\n+                    \"\"\",\n+                    generateTestMethod($(\"reference\"), invarRest),\n+                    \"\"\"\n+\n+                    \/\/ --- $test end ---\n+                    \"\"\"\n+                );\n+            });\n+            return testTemplate.asToken();\n+        }\n+\n+        private TemplateToken generateArrayField(String name, MyType type) {\n+            var template = Template.make(() -> body(\n+                let(\"size\", containerByteSize \/ type.byteSize()),\n+                let(\"name\", name),\n+                let(\"type\", type),\n+                \"\"\"\n+                private static #type[] original_#name  = new #type[#size];\n+                private static #type[] test_#name      = new #type[#size];\n+                private static #type[] reference_#name = new #type[#size];\n+                \"\"\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateMemorySegmentField(String name, MyType type) {\n+            var template = Template.make(() -> body(\n+                let(\"size\", containerByteSize \/ type.byteSize()),\n+                let(\"byteSize\", containerByteSize),\n+                let(\"name\", name),\n+                let(\"type\", type),\n+                (type == myNative\n+                 ?  \"\"\"\n+                    private static MemorySegment original_#name  = Arena.ofAuto().allocate(#byteSize);\n+                    private static MemorySegment test_#name      = Arena.ofAuto().allocate(#byteSize);\n+                    private static MemorySegment reference_#name = Arena.ofAuto().allocate(#byteSize);\n+                    \"\"\"\n+                 :  \"\"\"\n+                    private static MemorySegment original_#name  = MemorySegment.ofArray(new #type[#size]);\n+                    private static MemorySegment test_#name      = MemorySegment.ofArray(new #type[#size]);\n+                    private static MemorySegment reference_#name = MemorySegment.ofArray(new #type[#size]);\n+                    \"\"\"\n+                )\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateIndexField(String name, IndexForm form) {\n+            var template = Template.make(() -> body(\n+                let(\"name\", name),\n+                let(\"form\", form.generate()),\n+                \"\"\"\n+                private static IndexForm #name = #form;\n+                \"\"\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateTestFields(String[] invarRest, String[] containerNames, String[] indexFormNames) {\n+            var template = Template.make(() -> body(\n+                let(\"ivType\", isLongIvType ? \"long\" : \"int\"),\n+                \"\"\"\n+                \/\/ invarRest fields:\n+                \"\"\",\n+                Arrays.stream(invarRest).map(invar ->\n+                    List.of(\"private static #ivType \", invar, \" = 0;\\n\")\n+                ).toList(),\n+                \"\"\"\n+                \/\/ Containers fields:\n+                \"\"\",\n+                Arrays.stream(containerNames).map(name ->\n+                    switch (containerKind) {\n+                        case ContainerKind.ARRAY ->\n+                            generateArrayField(name, containerElementType);\n+                        case ContainerKind.MEMORY_SEGMENT_AT_INDEX,\n+                             ContainerKind.MEMORY_SEGMENT_LONG_ADR_SCALE,\n+                             ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE ->\n+                            generateMemorySegmentField(name, containerElementType);\n+                    }\n+                ).toList(),\n+                \"\"\"\n+                \/\/ Index forms for the accesses:\n+                \"\"\",\n+                IntStream.range(0, indexFormNames.length).mapToObj(i ->\n+                    generateIndexField(indexFormNames[i], accessIndexForm[i])\n+                ).toList()\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateContainerInitArray(String name) {\n+            var template = Template.make(() -> body(\n+                let(\"size\", containerByteSize \/ containerElementType.byteSize()),\n+                let(\"name\", name),\n+                \"\"\"\n+                System.arraycopy(original_#name, 0, test_#name, 0, #size);\n+                System.arraycopy(original_#name, 0, reference_#name, 0, #size);\n+                \"\"\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateContainerInitMemorySegment(String name) {\n+            var template = Template.make(() -> body(\n+                let(\"size\", containerByteSize \/ containerElementType.byteSize()),\n+                let(\"name\", name),\n+                \"\"\"\n+                test_#name.copyFrom(original_#name);\n+                reference_#name.copyFrom(original_#name);\n+                \"\"\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateContainerInit(String[] containerNames) {\n+            var template = Template.make(() -> body(\n+                \"\"\"\n+                \/\/ Init containers from original data:\n+                \"\"\",\n+                Arrays.stream(containerNames).map(name ->\n+                    switch (containerKind) {\n+                        case ContainerKind.ARRAY ->\n+                            generateContainerInitArray(name);\n+                        case ContainerKind.MEMORY_SEGMENT_AT_INDEX,\n+                             ContainerKind.MEMORY_SEGMENT_LONG_ADR_SCALE,\n+                             ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE ->\n+                            generateContainerInitMemorySegment(name);\n+                    }\n+                ).toList()\n+             ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateContainerAliasingAssignment(int i, String name1, String name2, String iterations) {\n+            var template = Template.make(() -> body(\n+                let(\"i\", i),\n+                let(\"name1\", name1),\n+                let(\"name2\", name2),\n+                let(\"iterations\", iterations),\n+                \"\"\"\n+                var test_#i      = (#iterations % 2 == 0) ? test_#name1      : test_#name2;\n+                var reference_#i = (#iterations % 2 == 0) ? reference_#name1 : reference_#name2;\n+                \"\"\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateContainerAliasing(String[] containerNames, String iterations) {\n+            var template = Template.make(() -> body(\n+                \"\"\"\n+                \/\/ Container aliasing:\n+                \"\"\",\n+                IntStream.range(0, containerNames.length).mapToObj(i ->\n+                    switch(aliasing) {\n+                        case Aliasing.CONTAINER_DIFFERENT ->\n+                            generateContainerAliasingAssignment(i, containerNames[i], containerNames[i], iterations);\n+                        case Aliasing.CONTAINER_SAME_ALIASING_NEVER,\n+                             Aliasing.CONTAINER_SAME_ALIASING_UNKNOWN ->\n+                            generateContainerAliasingAssignment(i, containerNames[0], containerNames[0], iterations);\n+                        case Aliasing.CONTAINER_UNKNOWN_ALIASING_NEVER,\n+                             Aliasing.CONTAINER_UNKNOWN_ALIASING_UNKNOWN ->\n+                            generateContainerAliasingAssignment(i, containerNames[i], containerNames[0], iterations);\n+                    }\n+                ).toList()\n+             ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateRanges() {\n+            int size = switch (containerKind) {\n+                case ContainerKind.ARRAY,\n+                     ContainerKind.MEMORY_SEGMENT_AT_INDEX ->\n+                    \/\/ Access with element index\n+                    containerByteSize \/ accessType[0].byteSize();\n+                case ContainerKind.MEMORY_SEGMENT_LONG_ADR_SCALE,\n+                     ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE ->\n+                    \/\/ Access with byte offset\n+                    containerByteSize;\n+            };\n+\n+            if (accessIndexForm.length != 2) { throw new RuntimeException(\"not yet implemented\"); }\n+\n+            var templateSplitRanges = Template.make(() -> body(\n+                let(\"size\", size),\n+                \"\"\"\n+                int middle = RANDOM.nextInt(#size \/ 3, #size * 2 \/ 3);\n+                int rnd = Math.min(256, #size \/ 10);\n+                int range = #size \/ 3 - RANDOM.nextInt(rnd);\n+                \"\"\",\n+                (RANDOM.nextBoolean()\n+                 \/\/ Maximal range\n+                 ?  \"\"\"\n+                    var r0 = new IndexForm.Range(0, middle);\n+                    var r1 = new IndexForm.Range(middle, #size);\n+                    \"\"\"\n+                 \/\/ Same size range\n+                 \/\/ If the accesses run towards each other, and the runtime\n+                 \/\/ check is too relaxed, we may fail the checks even though\n+                 \/\/ there is no overlap. Having same size ranges makes this\n+                 \/\/ more likely, and we could detect it if we get multiversioning\n+                 \/\/ unexpectedly.\n+                 :  \"\"\"\n+                    var r0 = new IndexForm.Range(middle - range, middle);\n+                    var r1 = new IndexForm.Range(middle, middle + range);\n+                    \"\"\"\n+                ),\n+                \"\"\"\n+                if (RANDOM.nextBoolean()) {\n+                    var tmp = r0;\n+                    r0 = r1;\n+                    r1 = tmp;\n+                }\n+                \"\"\"\n+            ));\n+\n+            var templateWholeRanges = Template.make(() -> body(\n+                let(\"size\", size),\n+                \"\"\"\n+                var r0 = new IndexForm.Range(0, #size);\n+                var r1 = new IndexForm.Range(0, #size);\n+                \"\"\"\n+            ));\n+\n+            var templateRandomRanges = Template.make(() -> body(\n+                let(\"size\", size),\n+                \"\"\"\n+                int lo0 = RANDOM.nextInt(0, #size * 3 \/ 4);\n+                int lo1 = RANDOM.nextInt(0, #size * 3 \/ 4);\n+                var r0 = new IndexForm.Range(lo0, lo0 + #size \/ 4);\n+                var r1 = new IndexForm.Range(lo1, lo1 + #size \/ 4);\n+                \"\"\"\n+            ));\n+\n+            var templateSmallOverlapRanges = Template.make(() -> body(\n+                \/\/ Idea: same size ranges, with size \"range\". A small overlap,\n+                \/\/       so that bad runtime checks would create wrong results.\n+                let(\"size\", size),\n+                \"\"\"\n+                int rnd = Math.min(256, #size \/ 10);\n+                int middle = #size \/ 2 + RANDOM.nextInt(-rnd, rnd);\n+                int range = #size \/ 3 - RANDOM.nextInt(rnd);\n+                int overlap = RANDOM.nextInt(-rnd, rnd);\n+                var r0 = new IndexForm.Range(middle - range + overlap, middle + overlap);\n+                var r1 = new IndexForm.Range(middle, middle + range);\n+                if (RANDOM.nextBoolean()) {\n+                    var tmp = r0;\n+                    r0 = r1;\n+                    r1 = tmp;\n+                }\n+                \"\"\"\n+                \/\/ Can this go out of bounds? Assume worst case on lower end:\n+                \/\/   middle         - range          + overlap\n+                \/\/   (size\/2 - rnd) - (size\/3 - rnd) - rnd\n+                \/\/   size\/6 - rnd\n+                \/\/ -> safe with rnd = size\/10\n+            ));\n+\n+            var templateAnyRanges = Template.make(() -> body(\n+                switch(RANDOM.nextInt(4)) {\n+                    case 0 -> templateSplitRanges.asToken();\n+                    case 1 -> templateWholeRanges.asToken();\n+                    case 2 -> templateRandomRanges.asToken();\n+                    case 3 -> templateSmallOverlapRanges.asToken();\n+                    default -> throw new RuntimeException(\"impossible\");\n+                }\n+            ));\n+\n+            var template = Template.make(() -> body(\n+                \"\"\"\n+                \/\/ Generate ranges:\n+                \"\"\",\n+                switch(aliasing) {\n+                    case Aliasing.CONTAINER_DIFFERENT ->\n+                        templateAnyRanges.asToken();\n+                    case Aliasing.CONTAINER_SAME_ALIASING_NEVER ->\n+                        templateSplitRanges.asToken();\n+                    case Aliasing.CONTAINER_SAME_ALIASING_UNKNOWN ->\n+                        templateAnyRanges.asToken();\n+                    case Aliasing.CONTAINER_UNKNOWN_ALIASING_NEVER ->\n+                        templateSplitRanges.asToken();\n+                    case Aliasing.CONTAINER_UNKNOWN_ALIASING_UNKNOWN ->\n+                        templateAnyRanges.asToken();\n+                }\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateBoundsAndInvariants(String[] indexFormNames, String[] invarRest) {\n+            \/\/ We want there to be at least 1000 iterations.\n+            final int minIvRange = ivStrideAbs * 1000;\n+\n+            var template = Template.make(() -> body(\n+                let(\"containerByteSize\", containerByteSize),\n+                \"\"\"\n+                \/\/ Compute loop bounds and loop invariants.\n+                int ivLo = RANDOM.nextInt(-1000, 1000);\n+                int ivHi = ivLo + #containerByteSize;\n+                \"\"\",\n+                IntStream.range(0, indexFormNames.length).mapToObj(i ->\n+                    Template.make(() -> body(\n+                        let(\"i\", i),\n+                        let(\"form\", indexFormNames[i]),\n+                        \"\"\"\n+                        int invar0_#i = #form.invar0ForIvLo(r#i, ivLo);\n+                        ivHi = Math.min(ivHi, #form.ivHiForInvar0(r#i, invar0_#i));\n+                        \"\"\"\n+                    )).asToken()\n+                ).toList(),\n+                let(\"minIvRange\", minIvRange),\n+                \"\"\"\n+                \/\/ Let's check that the range is large enough, so that the vectorized\n+                \/\/ main loop can even be entered.\n+                if (ivLo + #minIvRange > ivHi) { throw new RuntimeException(\"iv range too small: \" + ivLo + \" \" + ivHi); }\n+                \"\"\",\n+                Arrays.stream(invarRest).map(invar ->\n+                    List.of(invar, \" = RANDOM.nextInt(-1, 2);\\n\")\n+                ).toList(),\n+                \"\"\"\n+                \/\/ Verify the bounds we just created, just to be sure there is no unexpected aliasing!\n+                int i = ivLo;\n+                \"\"\",\n+                IntStream.range(0, indexFormNames.length).mapToObj(i ->\n+                    List.of(\"int lo_\", i, \" = (int)(\", accessIndexForm[i].index(\"invar0_\" + i, invarRest), \");\\n\")\n+                ).toList(),\n+                \"\"\"\n+                i = ivHi;\n+                \"\"\",\n+                IntStream.range(0, indexFormNames.length).mapToObj(i ->\n+                    List.of(\"int hi_\", i, \" =  (int)(\", accessIndexForm[i].index(\"invar0_\" + i, invarRest), \");\\n\")\n+                ).toList(),\n+                switch(aliasing) {\n+                    case Aliasing.CONTAINER_SAME_ALIASING_NEVER,\n+                         Aliasing.CONTAINER_UNKNOWN_ALIASING_NEVER -> \/\/ could fail in the future if we make it smarter\n+                        List.of(\n+                        \"\"\"\n+                        \/\/ Bounds should not overlap.\n+                        if (false\n+                        \"\"\",\n+                        IntStream.range(0, indexFormNames.length).mapToObj(i1 ->\n+                            IntStream.range(0, i1).mapToObj(i2 ->\n+                                Template.make(() -> body(\n+                                    let(\"i1\", i1),\n+                                    let(\"i2\", i2),\n+                                    \/\/ i1 < i2 or i1 > i2\n+                                    \"\"\"\n+                                    || (lo_#i1 < lo_#i2 && lo_#i1 < hi_#i2 && hi_#i1 < lo_#i2 && hi_#i1 < hi_#i2)\n+                                    || (lo_#i1 > lo_#i2 && lo_#i1 > hi_#i2 && hi_#i1 > lo_#i2 && hi_#i1 > hi_#i2)\n+                                    \"\"\"\n+                                )).asToken()\n+                            ).toList()\n+                        ).toList(),\n+                        \"\"\"\n+                        ) {\n+                            \/\/ pass\n+                        } else {\n+                            throw new RuntimeException(\"bounds overlap!\");\n+                        }\n+                        \"\"\");\n+                    case Aliasing.CONTAINER_DIFFERENT,\n+                         Aliasing.CONTAINER_SAME_ALIASING_UNKNOWN,\n+                         Aliasing.CONTAINER_UNKNOWN_ALIASING_UNKNOWN ->\n+                        \"\"\"\n+                        \/\/ Aliasing unknown, cannot verify bounds.\n+                        \"\"\";\n+                }\n+            ));\n+            return template.asToken();\n+        }\n+\n+\n+        private TemplateToken generateCallMethod(String output, String methodName, String containerPrefix) {\n+            var template = Template.make(() -> body(\n+                let(\"output\", output),\n+                let(\"methodName\", methodName),\n+                \"var #output = #methodName(\",\n+                IntStream.range(0, numContainers).mapToObj(i ->\n+                    List.of(containerPrefix, \"_\", i, \", invar0_\", i, \", \")\n+                ).toList(),\n+                \"ivLo, ivHi);\\n\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateIRRules() {\n+            var template = Template.make(() -> body(\n+                switch (containerKind) {\n+                    case ContainerKind.ARRAY ->\n+                        generateIRRulesArray();\n+                    case ContainerKind.MEMORY_SEGMENT_AT_INDEX ->\n+                        generateIRRulesMemorySegmentAtIndex();\n+                    case ContainerKind.MEMORY_SEGMENT_LONG_ADR_SCALE ->\n+                        generateIRRulesMemorySegmentLongAdrScale();\n+                    case ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE ->\n+                        generateIRRulesMemorySegmentLongAdrStride();\n+                },\n+                \/\/ In same scnearios, we know that a aliasing runtime check will never fail.\n+                \/\/ That means if we have UseAutoVectorizationPredicate enabled, that predicate\n+                \/\/ will never fail, and we will not have to do multiversioning.\n+                switch(aliasing) {\n+                    case Aliasing.CONTAINER_DIFFERENT,\n+                         Aliasing.CONTAINER_SAME_ALIASING_NEVER,\n+                         Aliasing.CONTAINER_UNKNOWN_ALIASING_NEVER ->\n+                        \/\/ We would have liked to check that there is no multiversioning.\n+                        \/\/\n+                        \/\/ But sadly there are some cases that have issues with RCE and\/or\n+                        \/\/ predicates, and so we end up using multiversioning anyway. We\n+                        \/\/ should fix those cases eventually, to strengthen the checks here.\n+                        \/\/\n+                        \/\/ The array cases are a little more tame, and do not have the same\n+                        \/\/ issues as the MemorySegment cases.\n+                        (containerKind == ContainerKind.ARRAY)\n+                        ? \"\"\"\n+                          \/\/ Aliasing check should never fail at runtime, so the predicate\n+                          \/\/ should never fail, and we do not have to use multiversioning.\n+                          \/\/ Failure could have a few causes:\n+                          \/\/ - issues with doing RCE \/ missing predicates\n+                          \/\/   -> other loop-opts need to be fixed\n+                          \/\/ - predicate fails: recompile with multiversioning\n+                          \/\/   -> logic in runtime check may be wrong\n+                          @IR(counts = {\".*multiversion.*\", \"= 0\"},\n+                              phase = CompilePhase.PRINT_IDEAL,\n+                              applyIf = {\"UseAutoVectorizationPredicate\", \"true\"},\n+                              applyIfPlatform = {\"64-bit\", \"true\"},\n+                              applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+                          \"\"\"\n+                        : \"\"\"\n+                          \/\/ Due to cases like JDK-8360204 and JDK-8365982, there can be issues\n+                          \/\/ with RCE leading cases where we remove predicates and then unroll again\n+                          \/\/ and then end up multiversioning. These cases seem relatively rare but\n+                          \/\/ prevent us from asserting that there is never multiversioning in these cases.\n+                          \"\"\";\n+                   case Aliasing.CONTAINER_SAME_ALIASING_UNKNOWN,\n+                         Aliasing.CONTAINER_UNKNOWN_ALIASING_UNKNOWN ->\n+                            \"\"\"\n+                            \/\/ Aliasing unknown, we may use the predicate or multiversioning.\n+                            \"\"\";\n+                }\n+            ));\n+            return template.asToken();\n+        }\n+\n+        \/\/ Regular array-accesses are vectorized quite predictably, and we can create nice\n+        \/\/ IR rules - even for cases where we do not expect vectorization.\n+        private TemplateToken generateIRRulesArray() {\n+            var template = Template.make(() -> body(\n+                let(\"T\", containerElementType.letter()),\n+                switch (accessScenario) {\n+                    case COPY_LOAD_STORE ->\n+                        \/\/ Currently, we do not allow strided access or shuffle.\n+                        \/\/ Since the load and store are connected, we either vectorize both or none.\n+                        (accessIndexForm[0].ivScale() == accessIndexForm[1].ivScale() &&\n+                         Math.abs(accessIndexForm[0].ivScale()) == 1)\n+                        ?   \"\"\"\n+                            \/\/ Good ivScales, vectorization expected.\n+                            @IR(counts = {IRNode.LOAD_VECTOR_#T, \"> 0\",\n+                                          IRNode.STORE_VECTOR,   \"> 0\"},\n+                                applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\",\n+                                              \"AlignVector\", \"false\"},\n+                                applyIfPlatform = {\"64-bit\", \"true\"},\n+                                applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+                            \"\"\"\n+                        :   \"\"\"\n+                            \/\/ Bad ivScales, no vectorization expected.\n+                            @IR(counts = {IRNode.LOAD_VECTOR_#T, \"= 0\",\n+                                          IRNode.STORE_VECTOR,   \"= 0\"},\n+                                applyIfPlatform = {\"64-bit\", \"true\"},\n+                                applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+                            \"\"\";\n+                    case FILL_STORE_STORE ->\n+                        \/\/ Currently, we do not allow strided access.\n+                        \/\/ We vectorize any contiguous pattern. Possibly only one is vectorized.\n+                        (Math.abs(accessIndexForm[0].ivScale()) == 1 ||\n+                         Math.abs(accessIndexForm[1].ivScale()) == 1)\n+                        ?   \"\"\"\n+                            \/\/ Good ivScales, vectorization expected.\n+                            @IR(counts = {IRNode.LOAD_VECTOR_#T, \"= 0\",\n+                                          IRNode.STORE_VECTOR,   \"> 0\"},\n+                                applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\",\n+                                              \"AlignVector\", \"false\"},\n+                                applyIfPlatform = {\"64-bit\", \"true\"},\n+                                applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+                            \"\"\"\n+                        :   \"\"\"\n+                            \/\/ Bad ivScales, no vectorization expected.\n+                            @IR(counts = {IRNode.LOAD_VECTOR_#T, \"= 0\",\n+                                          IRNode.STORE_VECTOR,   \"= 0\"},\n+                                applyIfPlatform = {\"64-bit\", \"true\"},\n+                                applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+                            \"\"\";\n+                }\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateIRRulesMemorySegmentAtIndex() {\n+           var template = Template.make(() -> body(\n+                \"\"\"\n+                \/\/ Unfortunately, there are some issues that prevent RangeCheck elimination.\n+                \/\/ The cases are currently quite unpredictable, so we cannot create any IR\n+                \/\/ rules - sometimes there are vectors sometimes not.\n+                \"\"\"\n+                \/\/ JDK-8359688: it seems we only vectorize with ivScale=1, and not ivScale=-1\n+                \/\/              The issue seems to be RangeCheck elimination\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateIRRulesMemorySegmentLongAdrStride() {\n+           var template = Template.make(() -> body(\n+                \"\"\"\n+                \/\/ Unfortunately, there are some issues that prevent RangeCheck elimination.\n+                \/\/ The cases are currently quite unpredictable, so we cannot create any IR\n+                \/\/ rules - sometimes there are vectors sometimes not.\n+                \"\"\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateIRRulesMemorySegmentLongAdrScale() {\n+           var template = Template.make(() -> body(\n+                \"\"\"\n+                \/\/ Unfortunately, there are some issues that prevent RangeCheck elimination.\n+                \/\/ The cases are currently quite unpredictable, so we cannot create any IR\n+                \/\/ rules - sometimes there are vectors sometimes not.\n+                \"\"\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateTestMethod(String methodName, String[] invarRest) {\n+            var template = Template.make(() -> body(\n+                let(\"methodName\", methodName),\n+                let(\"containerElementType\", containerElementType),\n+                let(\"ivStrideAbs\", ivStrideAbs),\n+                let(\"ivType\", isLongIvType ? \"long\" : \"int\"),\n+                \/\/ Method head \/ signature.\n+                \"public static Object #methodName(\",\n+                IntStream.range(0, numContainers).mapToObj(i ->\n+                    switch (containerKind) {\n+                        case ContainerKind.ARRAY ->\n+                            List.of(\"#containerElementType[] container_\", i, \", #ivType invar0_\", i, \", \");\n+                        case ContainerKind.MEMORY_SEGMENT_AT_INDEX,\n+                             ContainerKind.MEMORY_SEGMENT_LONG_ADR_SCALE,\n+                             ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE ->\n+                            List.of(\"MemorySegment container_\", i, \", #ivType invar0_\", i, \", \");\n+                    }\n+                ).toList(),\n+                \"#ivType ivLo, #ivType ivHi) {\\n\",\n+                \/\/ Method loop body.\n+                (loopForward\n+                 ?  \"for (#ivType i = ivLo; i < ivHi; i+=#ivStrideAbs) {\\n\"\n+                 :  \"for (#ivType i = ivHi-#ivStrideAbs; i >= ivLo; i-=#ivStrideAbs) {\\n\"),\n+                \/\/ Loop iteration.\n+                switch (containerKind) {\n+                    case ContainerKind.ARRAY ->\n+                        generateTestLoopIterationArray(invarRest);\n+                    case ContainerKind.MEMORY_SEGMENT_AT_INDEX ->\n+                        generateTestLoopIterationMemorySegmentAtIndex(invarRest);\n+                    case ContainerKind.MEMORY_SEGMENT_LONG_ADR_SCALE,\n+                         ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE ->\n+                        generateTestLoopIterationMemorySegmentLongAdr(invarRest);\n+                },\n+                \"\"\"\n+                    }\n+                    return new Object[] {\n+                \"\"\",\n+                \/\/ Return a list of all containers that are involved in the test.\n+                \/\/ The caller can then compare the results of the test and reference method.\n+                IntStream.range(0, numContainers).mapToObj(i ->\n+                    \"container_\" + i\n+                ).collect(Collectors.joining(\", \")), \"\\n\",\n+                \"\"\"\n+                    };\n+                }\n+                \"\"\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateTestLoopIterationArray(String[] invarRest) {\n+            var template = Template.make(() -> body(\n+                let(\"type\", containerElementType),\n+                switch (accessScenario) {\n+                    case COPY_LOAD_STORE ->\n+                        List.of(\"container_0[\", accessIndexForm[0].index(\"invar0_0\", invarRest), \"] = \",\n+                                \"container_1[\", accessIndexForm[1].index(\"invar0_1\", invarRest), \"];\\n\");\n+                    case FILL_STORE_STORE ->\n+                        List.of(\"container_0[\", accessIndexForm[0].index(\"invar0_0\", invarRest), \"] = (#type)0x0102030405060708L;\\n\",\n+                                \"container_1[\", accessIndexForm[1].index(\"invar0_1\", invarRest), \"] = (#type)0x1112131415161718L;\\n\");\n+                }\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateTestLoopIterationMemorySegmentAtIndex(String[] invarRest) {\n+            var template = Template.make(() -> body(\n+                let(\"type0\", accessType[0]),\n+                let(\"type1\", accessType[1]),\n+                let(\"type0Layout\", accessType[0].layout()),\n+                let(\"type1Layout\", accessType[1].layout()),\n+                switch (accessScenario) {\n+                    case COPY_LOAD_STORE ->\n+                        \/\/ Conversion not implemented, index bound computation is too limited for this currently.\n+                        List.of(\"var v = \",\n+                                \"container_0.getAtIndex(#type0Layout, \", accessIndexForm[0].indexLong(\"invar0_0\", invarRest), \");\\n\",\n+                                \"container_1.setAtIndex(#type1Layout, \", accessIndexForm[1].indexLong(\"invar0_1\", invarRest), \", v);\\n\");\n+                    case FILL_STORE_STORE ->\n+                        List.of(\"container_0.setAtIndex(#type0Layout, \", accessIndexForm[0].indexLong(\"invar0_0\", invarRest), \", (#type0)0x0102030405060708L);\\n\",\n+                                \"container_1.setAtIndex(#type1Layout, \", accessIndexForm[1].indexLong(\"invar0_1\", invarRest), \", (#type1)0x1112131415161718L);\\n\");\n+                }\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateTestLoopIterationMemorySegmentLongAdr(String[] invarRest) {\n+            var template = Template.make(() -> body(\n+                let(\"type0\", accessType[0]),\n+                let(\"type1\", accessType[1]),\n+                let(\"type0Layout\", accessType[0].layout()),\n+                let(\"type1Layout\", accessType[1].layout()),\n+                switch (accessScenario) {\n+                    case COPY_LOAD_STORE ->\n+                        \/\/ We allow conversions here.\n+                        List.of(\"#type1 v = (#type1)\",\n+                                \"container_0.get(#type0Layout, \", accessIndexForm[0].indexLong(\"invar0_0\", invarRest), \");\\n\",\n+                                \"container_1.set(#type1Layout, \", accessIndexForm[1].indexLong(\"invar0_1\", invarRest), \", v);\\n\");\n+                    case FILL_STORE_STORE ->\n+                        List.of(\"container_0.set(#type0Layout, \", accessIndexForm[0].indexLong(\"invar0_0\", invarRest), \", (#type0)0x0102030405060708L);\\n\",\n+                                \"container_1.set(#type1Layout, \", accessIndexForm[1].indexLong(\"invar0_1\", invarRest), \", (#type1)0x1112131415161718L);\\n\");\n+                }\n+            ));\n+            return template.asToken();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAliasingFuzzer.java","additions":1284,"deletions":0,"binary":false,"changes":1284,"status":"added"},{"patch":"@@ -398,1 +398,1 @@\n-    \/\/ Would be nice to vectorize: Missing support for CmpF, CMove and MoveF2I.\n+    \/\/ Would be nice to vectorize: Missing support for CmpF and CMove.\n@@ -407,1 +407,3 @@\n-    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.VECTOR_REINTERPRET, \"> 0\"},\n@@ -410,1 +412,0 @@\n-    \/\/ Missing support for MoveF2I\n@@ -419,1 +420,3 @@\n-    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.VECTOR_REINTERPRET, \"> 0\"},\n@@ -422,1 +425,0 @@\n-    \/\/ Missing support for MoveI2F\n@@ -434,1 +436,1 @@\n-    \/\/ Missing support for Needs CmpD, CMove and MoveD2L\n+    \/\/ Missing support to vectorize CmpD and CMove\n@@ -443,1 +445,3 @@\n-    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.VECTOR_REINTERPRET, \"> 0\"},\n@@ -446,1 +450,0 @@\n-    \/\/ Missing support for MoveD2L\n@@ -455,1 +458,3 @@\n-    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.VECTOR_REINTERPRET, \"> 0\"},\n@@ -458,1 +463,0 @@\n-    \/\/ Missing support for MoveL2D\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestCompatibleUseDefTypeSize.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.List;\n@@ -39,1 +40,0 @@\n-    static final int ITER  = 100;\n@@ -76,6 +76,22 @@\n-        TestFramework.runWithFlags(\"-XX:CompileCommand=compileonly,TestCyclicDependency::test*\",\n-                                   \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:-AlignVector\", \"-XX:-VerifyAlignVector\");\n-        TestFramework.runWithFlags(\"-XX:CompileCommand=compileonly,TestCyclicDependency::test*\",\n-                                   \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+AlignVector\", \"-XX:-VerifyAlignVector\");\n-        TestFramework.runWithFlags(\"-XX:CompileCommand=compileonly,TestCyclicDependency::test*\",\n-                                   \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+AlignVector\", \"-XX:+VerifyAlignVector\");\n+        \/\/ Cross-product:\n+        \/\/ - AlignVector (+VerifyAlignVector)\n+        \/\/ - UseAutoVectorizationSpeculativeAliasingChecks\n+        List<String[]> avList = List.of(\n+            new String[] {\"-XX:-AlignVector\", \"-XX:-VerifyAlignVector\"},\n+            new String[] {\"-XX:+AlignVector\", \"-XX:-VerifyAlignVector\"},\n+            new String[] {\"-XX:+AlignVector\", \"-XX:+VerifyAlignVector\"}\n+        );\n+        List<String[]> sacList = List.of(\n+            new String[] {\"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"},\n+            new String[] {\"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"}\n+        );\n+        for (String[] av : avList) {\n+            for (String[] sac : sacList) {\n+                TestFramework framework = new TestFramework();\n+                framework.addFlags(\"-XX:CompileCommand=compileonly,TestCyclicDependency::test*\",\n+                                   \"-XX:+IgnoreUnrecognizedVMOptions\");\n+                framework.addFlags(av);\n+                framework.addFlags(sac);\n+                framework.start();\n+            }\n+        }\n@@ -137,1 +153,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -148,1 +164,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -159,1 +175,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -170,1 +186,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -181,1 +197,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -192,1 +208,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -203,1 +219,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -214,1 +230,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -225,1 +241,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -236,1 +252,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -247,1 +263,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -260,1 +276,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -271,1 +287,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -282,1 +298,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -295,1 +311,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -306,1 +322,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -433,2 +449,4 @@\n-                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"2\", \"> 0\"},\n-        applyIf = {\"AlignVector\", \"false\"},\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"2\", \"> 0\",\n+                  \".*multiversion.*\", \"=0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n@@ -437,1 +455,9 @@\n-                  IRNode.ADD_VF, \"= 0\"},\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VF, \"= 0\",\n+                  \".*multiversion.*\", \"=0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n@@ -448,4 +474,8 @@\n-            \/\/   AlignVector=false -> vectorizes because we cannot prove store-to-load forwarding\n-            \/\/                        failure. But we can only have 2-element vectors in case\n-            \/\/                        the two float-arrays reference the same array.\n-            \/\/                        Note: at runtime the float-arrays are always different.\n+            \/\/   AlignVector=false\n+            \/\/     UseAutoVectorizationSpeculativeAliasingChecks=false\n+            \/\/       vectorizes because we cannot prove store-to-load forwarding\n+            \/\/       failure. But we can only have 2-element vectors in case\n+            \/\/       the two float-arrays reference the same array.\n+            \/\/     UseAutoVectorizationSpeculativeAliasingChecks=true\n+            \/\/       Speculate that dataF and dataF_2 do not alias -> full vectorization.\n+            \/\/ Note: at runtime the float-arrays are always different -> predicate suffices, no multiversioning.\n@@ -459,2 +489,11 @@\n-                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"2\", \"> 0\"},\n-        applyIf = {\"AlignVector\", \"false\"},\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"2\", \"> 0\",\n+                  \".*multiversion.*\", \"=0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"2\", \"> 0\",\n+                  \".*multiversion.*\", \"> 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n@@ -464,0 +503,1 @@\n+        phase = CompilePhase.PRINT_IDEAL,\n@@ -474,4 +514,9 @@\n-            \/\/   AlignVector=false -> vectorizes because we cannot prove store-to-load forwarding\n-            \/\/                        failure. But we can only have 2-element vectors in case\n-            \/\/                        the two float-arrays reference the same array.\n-            \/\/                        Note: at runtime the float-arrays are always the same.\n+            \/\/   AlignVector=false\n+            \/\/     UseAutoVectorizationSpeculativeAliasingChecks=false\n+            \/\/       vectorizes because we cannot prove store-to-load forwarding\n+            \/\/       failure. But we can only have 2-element vectors in case\n+            \/\/       the two float-arrays reference the same array.\n+            \/\/     UseAutoVectorizationSpeculativeAliasingChecks=true\n+            \/\/       Speculate that dataF and dataF_2 do not alias -> full vectorization.\n+            \/\/       multiversion_slow loop can still vectorize, but only with 2 elements.\n+            \/\/ Note: at runtime the float-arrays are always the same -> predicate fails -> multiversioning.\n@@ -511,2 +556,10 @@\n-                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\"},\n-        applyIf = {\"AlignVector\", \"false\"},\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  \".*multiversion.*\", \"=0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  \".*multiversion.*\", \"=0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n@@ -515,1 +568,3 @@\n-                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\"},\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  \".*multiversion.*\", \"=0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n@@ -523,4 +578,8 @@\n-            \/\/   AlignVector=false -> vectorizes because we cannot prove store-to-load forwarding\n-            \/\/                        failure. But we can only have 2-element vectors in case\n-            \/\/                        the two float-arrays reference the same array.\n-            \/\/                        Note: at runtime the float-arrays are always different.\n+            \/\/   AlignVector=false\n+            \/\/     UseAutoVectorizationSpeculativeAliasingChecks=false\n+            \/\/       vectorizes because we cannot prove store-to-load forwarding\n+            \/\/       failure. But we can only have 2-element vectors in case\n+            \/\/       the two int-arrays reference the same array.\n+            \/\/     UseAutoVectorizationSpeculativeAliasingChecks=true\n+            \/\/       Speculate that dataI and dataI_2 do not alias -> full vectorization.\n+            \/\/ Note: at runtime the int-arrays are always different -> predicate suffices, no multiversioning.\n@@ -537,2 +596,11 @@\n-                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\"},\n-        applyIf = {\"AlignVector\", \"false\"},\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  \".*multiversion.*\", \"=0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VI, IRNode.VECTOR_SIZE + \"2\", \"> 0\",\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  \".*multiversion.*\", \">0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n@@ -542,0 +610,1 @@\n+        phase = CompilePhase.PRINT_IDEAL,\n@@ -549,4 +618,9 @@\n-            \/\/   AlignVector=false -> vectorizes because we cannot prove store-to-load forwarding\n-            \/\/                        failure. But we can only have 2-element vectors in case\n-            \/\/                        the two float-arrays reference the same array.\n-            \/\/                        Note: at runtime the float-arrays are always the same.\n+            \/\/   AlignVector=false\n+            \/\/     UseAutoVectorizationSpeculativeAliasingChecks=false\n+            \/\/       vectorizes because we cannot prove store-to-load forwarding\n+            \/\/       failure. But we can only have 2-element vectors in case\n+            \/\/       the two int-arrays reference the same array.\n+            \/\/     UseAutoVectorizationSpeculativeAliasingChecks=true\n+            \/\/       Speculate that dataF and dataF_2 do not alias -> full vectorization.\n+            \/\/       multiversion_slow loop can still vectorize, but only with 2 elements.\n+            \/\/ Note: at runtime the int-arrays are always the same -> predicate fails -> multiversioning.\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestCyclicDependency.java","additions":123,"deletions":49,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vanilla-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vanilla-A\n@@ -39,1 +39,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vanilla-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vanilla-U\n@@ -51,1 +51,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v016-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets sse4-v016-A\n@@ -63,1 +63,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v016-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets sse4-v016-U\n@@ -75,1 +75,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v008-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets sse4-v008-A\n@@ -87,1 +87,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v008-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets sse4-v008-U\n@@ -99,1 +99,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v004-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets sse4-v004-A\n@@ -111,1 +111,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v004-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets sse4-v004-U\n@@ -123,1 +123,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx1-v032-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx1-v032-A\n@@ -135,1 +135,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx1-v032-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx1-v032-U\n@@ -147,1 +147,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx1-v016-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx1-v016-A\n@@ -159,1 +159,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx1-v016-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx1-v016-U\n@@ -171,1 +171,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx2-v032-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx2-v032-A\n@@ -183,1 +183,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx2-v032-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx2-v032-U\n@@ -195,1 +195,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx2-v016-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx2-v016-A\n@@ -207,1 +207,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx2-v016-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx2-v016-U\n@@ -219,1 +219,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512-v064-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx512-v064-A\n@@ -231,1 +231,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512-v064-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx512-v064-U\n@@ -243,1 +243,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512-v032-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx512-v032-A\n@@ -255,1 +255,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512-v032-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx512-v032-U\n@@ -267,1 +267,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512bw-v064-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx512bw-v064-A\n@@ -279,1 +279,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512bw-v064-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx512bw-v064-U\n@@ -291,1 +291,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512bw-v032-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx512bw-v032-A\n@@ -303,1 +303,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512bw-v032-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx512bw-v032-U\n@@ -314,1 +314,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v064-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v064-A\n@@ -325,1 +325,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v064-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v064-U\n@@ -336,1 +336,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v032-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v032-A\n@@ -347,1 +347,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v032-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v032-U\n@@ -358,1 +358,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v016-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v016-A\n@@ -369,1 +369,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v016-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v016-U\n@@ -380,1 +380,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v008-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v008-A\n@@ -391,1 +391,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v008-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v008-U\n@@ -402,1 +402,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v004-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v004-A\n@@ -413,1 +413,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v004-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v004-U\n@@ -754,0 +754,2 @@\n+                \/\/ If we have two array references, then we can speculate that they do not alias, and\n+                \/\/ still produce full vectorization.\n@@ -758,1 +760,1 @@\n-                if (0 < byteOffset && byteOffset < maxVectorWidth) {\n+                if (isSingleArray && 0 < byteOffset && byteOffset < maxVectorWidth) {\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestDependencyOffsets.java","additions":37,"deletions":35,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * @run driver\/timeout=1200 compiler.loopopts.superword.TestEquivalentInvariants\n+ * @run driver\/timeout=4800 compiler.loopopts.superword.TestEquivalentInvariants\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestEquivalentInvariants.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,0 +50,16 @@\n+\/*\n+ * @test id=byte-array-NoSpeculativeAliasingCheck\n+ * @bug 8329273 8348263 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ByteArray NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-AlignVector-NoSpeculativeAliasingCheck\n+ * @bug 8329273 8348263 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ByteArray AlignVector NoSpeculativeAliasingCheck\n+ *\/\n+\n@@ -66,0 +82,7 @@\n+\/*\n+ * @test id=byte-array-NoSpeculativeAliasingCheck-NoShortRunningLongLoop\n+ * @bug 8329273 8348263 8342692 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ByteArray NoSpeculativeAliasingCheck NoShortRunningLongLoop\n+ *\/\n@@ -163,0 +186,40 @@\n+\/*\n+ * @test id=native-NoSpeculativeAliasingCheck\n+ * @bug 8329273 8348263 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment Native NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=native-AlignVector-NoSpeculativeAliasingCheck\n+ * @bug 8329273 8348263 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment Native AlignVector NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=native-NoShortRunningLongLoop\n+ * @bug 8329273 8342692\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment Native NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=native-AlignVector-NoShortRunningLongLoop\n+ * @bug 8329273 8348263 8342692\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment Native AlignVector NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=native-NoSpeculativeAliasingCheck-NoShortRunningLongLoop\n+ * @bug 8329273 8348263 8342692 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment Native NoSpeculativeAliasingCheck NoShortRunningLongLoop\n+ *\/\n+\n@@ -196,0 +259,4 @@\n+                case \"NoSpeculativeAliasingCheck\" -> framework.addFlags(\"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\");\n+                \/\/ Disabling the ShortRunningLongLoop optimization changes the shape of the loop.\n+                \/\/ Testing both with and without it allows us to simulate long running loops with short running loops,\n+                \/\/ i.e. we don't need to allocate massive amounts of memory.\n@@ -197,0 +264,1 @@\n+                default ->                           throw new RuntimeException(\"Bad tag: \" + tag);\n@@ -199,3 +267,0 @@\n-        if (args.length > 1 && args[1].equals(\"AlignVector\")) {\n-            framework.addFlags(\"-XX:+AlignVector\");\n-        }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment.java","additions":68,"deletions":3,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -0,0 +1,914 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.verify.*;\n+import jdk.test.lib.Utils;\n+import java.nio.ByteBuffer;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Random;\n+import java.lang.foreign.*;\n+\n+\/*\n+ * @test id=byte-array\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-AlignVector\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray AlignVector\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-NoSpeculativeAliasingCheck\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-AlignVector-NoSpeculativeAliasingCheck\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray AlignVector NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-NoAutoAlignment\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray NoAutoAlignment\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-AlignVector-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray AlignVector NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-NoSpeculativeAliasingCheck-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray NoSpeculativeAliasingCheck NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=char-array\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing CharArray\n+ *\/\n+\n+\/*\n+ * @test id=short-array\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ShortArray\n+ *\/\n+\n+\/*\n+ * @test id=int-array\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing IntArray\n+ *\/\n+\n+\/*\n+ * @test id=int-array-AlignVector\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing IntArray AlignVector\n+ *\/\n+\n+\/*\n+ * @test id=int-array-NoSpeculativeAliasingCheck\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing IntArray NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=int-array-AlignVector-NoSpeculativeAliasingCheck\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing IntArray AlignVector NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=int-array-NoAutoAlignment\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing IntArray NoAutoAlignment\n+ *\/\n+\n+\/*\n+ * @test id=int-array-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing IntArray NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=int-array-NoSpeculativeAliasingCheck-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing IntArray NoSpeculativeAliasingCheck NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=long-array\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing LongArray\n+ *\/\n+\n+\/*\n+ * @test id=long-array-AlignVector\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing LongArray AlignVector\n+ *\/\n+\n+\/*\n+ * @test id=long-array-NoSpeculativeAliasingCheck\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing LongArray NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=long-array-AlignVector-NoSpeculativeAliasingCheck\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing LongArray AlignVector NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=float-array\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing FloatArray\n+ *\/\n+\n+\/*\n+ * @test id=double-array\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing DoubleArray\n+ *\/\n+\n+\/*\n+ * @test id=byte-buffer\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteBuffer\n+ *\/\n+\n+\/*\n+ * @test id=byte-buffer-direct\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteBufferDirect\n+ *\/\n+\n+\/*\n+ * @test id=native\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing Native\n+ *\/\n+\n+\/*\n+ * @test id=native-AlignVector\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing Native AlignVector\n+ *\/\n+\n+\/*\n+ * @test id=native-NoSpeculativeAliasingCheck\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing Native NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=native-AlignVector-NoSpeculativeAliasingCheck\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing Native AlignVector NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=native-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing Native NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=native-AlignVector-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing Native AlignVector NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=native-NoSpeculativeAliasingCheck-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing Native NoSpeculativeAliasingCheck NoShortRunningLongLoop\n+ *\/\n+\n+public class TestMemorySegmentAliasing {\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework(TestMemorySegmentAliasingImpl.class);\n+        framework.addFlags(\"-DmemorySegmentProviderNameForTestVM=\" + args[0]);\n+        for (int i = 1; i < args.length; i++) {\n+            String tag = args[i];\n+            switch (tag) {\n+                case \"AlignVector\" ->                framework.addFlags(\"-XX:+AlignVector\");\n+                case \"NoSpeculativeAliasingCheck\" -> framework.addFlags(\"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\");\n+                \/\/ automatic alignment has an impact on where the main-loop starts, and that affects init and limit\n+                \/\/ of the main loop.\n+                case \"NoAutoAlignment\" ->            framework.addFlags(\"-XX:SuperWordAutomaticAlignment=0\");\n+                \/\/ Disabling the ShortRunningLongLoop optimization changes the shape of the loop.\n+                \/\/ Testing both with and without it allows us to simulate long running loops with short running loops,\n+                \/\/ i.e. we don't need to allocate massive amounts of memory.\n+                case \"NoShortRunningLongLoop\" ->     framework.addFlags(\"-XX:-ShortRunningLongLoop\");\n+                default ->                           throw new RuntimeException(\"Bad tag: \" + tag);\n+            }\n+        }\n+        framework.setDefaultWarmup(100);\n+        framework.start();\n+    }\n+}\n+\n+class TestMemorySegmentAliasingImpl {\n+    static final int BACKING_SIZE = 1024 * 8;\n+    static final Random RANDOM = Utils.getRandomInstance();\n+\n+\n+    interface TestFunction {\n+        void run();\n+    }\n+\n+    interface MemorySegmentProvider {\n+        MemorySegment newMemorySegment();\n+    }\n+\n+    public static MemorySegmentProvider provider;\n+\n+    static {\n+        String providerName = System.getProperty(\"memorySegmentProviderNameForTestVM\");\n+        provider = switch (providerName) {\n+            case \"ByteArray\"        -> TestMemorySegmentAliasingImpl::newMemorySegmentOfByteArray;\n+            case \"CharArray\"        -> TestMemorySegmentAliasingImpl::newMemorySegmentOfCharArray;\n+            case \"ShortArray\"       -> TestMemorySegmentAliasingImpl::newMemorySegmentOfShortArray;\n+            case \"IntArray\"         -> TestMemorySegmentAliasingImpl::newMemorySegmentOfIntArray;\n+            case \"LongArray\"        -> TestMemorySegmentAliasingImpl::newMemorySegmentOfLongArray;\n+            case \"FloatArray\"       -> TestMemorySegmentAliasingImpl::newMemorySegmentOfFloatArray;\n+            case \"DoubleArray\"      -> TestMemorySegmentAliasingImpl::newMemorySegmentOfDoubleArray;\n+            case \"ByteBuffer\"       -> TestMemorySegmentAliasingImpl::newMemorySegmentOfByteBuffer;\n+            case \"ByteBufferDirect\" -> TestMemorySegmentAliasingImpl::newMemorySegmentOfByteBufferDirect;\n+            case \"Native\"           -> TestMemorySegmentAliasingImpl::newMemorySegmentOfNative;\n+            case \"MixedArray\"       -> TestMemorySegmentAliasingImpl::newMemorySegmentOfMixedArray;\n+            case \"MixedBuffer\"      -> TestMemorySegmentAliasingImpl::newMemorySegmentOfMixedBuffer;\n+            case \"Mixed\"            -> TestMemorySegmentAliasingImpl::newMemorySegmentOfMixed;\n+            default -> throw new RuntimeException(\"Test argument not recognized: \" + providerName);\n+        };\n+    }\n+\n+    \/\/ Map of goldTests\n+    public static Map<String, TestFunction> goldTests = new HashMap<>();\n+\n+    \/\/ Map of gold for the goldTests, the results from the first run before compilation\n+    public static Map<String, Object> golds = new HashMap<>();\n+\n+    \/\/ Map of referenceTests, i.e. tests that have a reference implementation that is run with the interpreter.\n+    \/\/ The TestFunction must run both the test and reference methods.\n+    public static Map<String, TestFunction> referenceTests = new HashMap<>();\n+\n+    \/\/ Original data.\n+    public static MemorySegment ORIG_A = fillRandom(newMemorySegment());\n+    public static MemorySegment ORIG_B = fillRandom(newMemorySegment());\n+    public static MemorySegment ORIG_C = fillRandom(newMemorySegment());\n+\n+    \/\/ The data we use in the tests. It is initialized from ORIG_* every time.\n+    public static MemorySegment A = newMemorySegment();\n+    public static MemorySegment B = newMemorySegment();\n+    public static MemorySegment C = newMemorySegment();\n+\n+    \/\/ Parallel to data above, but for use in reference methods.\n+    public static MemorySegment A_REFERENCE = newMemorySegment();\n+    public static MemorySegment B_REFERENCE = newMemorySegment();\n+    public static MemorySegment C_REFERENCE = newMemorySegment();\n+\n+    public TestMemorySegmentAliasingImpl () {\n+        \/\/ Add all goldTests to list\n+        goldTests.put(\"test_byte_incr_noaliasing\",     () -> test_byte_incr_noaliasing(A, B));\n+        goldTests.put(\"test_byte_incr_aliasing\",       () -> test_byte_incr_aliasing(A, A));\n+        goldTests.put(\"test_byte_incr_aliasing_fwd3\",  () -> {\n+            MemorySegment x = A.asSlice(0, BACKING_SIZE - 3);\n+            MemorySegment y = A.asSlice(3, BACKING_SIZE - 3);\n+            test_byte_incr_aliasing_fwd3(x, y);\n+        });\n+        goldTests.put(\"test_byte_incr_noaliasing_fwd128\",  () -> {\n+            MemorySegment x = A.asSlice(0,   BACKING_SIZE - 128);\n+            MemorySegment y = A.asSlice(120, BACKING_SIZE - 128);\n+            test_byte_incr_noaliasing_fwd128(x, y);\n+        });\n+\n+        goldTests.put(\"test_int_to_long_noaliasing\",   () -> test_int_to_long_noaliasing(A, B));\n+\n+        \/\/ Compute gold value for all test methods before compilation\n+        for (Map.Entry<String,TestFunction> entry : goldTests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            init();\n+            test.run();\n+            Object gold = snapshotCopy();\n+            golds.put(name, gold);\n+        }\n+\n+        referenceTests.put(\"test_fill_byte_sameMS_alias\", () -> {\n+            int invar1 = RANDOM.nextInt(64);\n+            int invar2 = RANDOM.nextInt(64);\n+            test_fill_byte_sameMS_alias(A, A, invar1, invar2);\n+            reference_fill_byte_sameMS_alias(A_REFERENCE, A_REFERENCE, invar1, invar2);\n+        });\n+        referenceTests.put(\"test_fill_byte_sameMS_noalias\", () -> {\n+            \/\/ The accesses either start at the middle and go out,\n+            \/\/ or start from opposite sides and meet in the middle.\n+            \/\/ But they never overlap.\n+            \/\/      <------|------>\n+            \/\/      ------>|<------\n+            \/\/\n+            \/\/ This tests that the checks we emit are not too relaxed.\n+            int middle = BACKING_SIZE \/ 2 + RANDOM.nextInt(-256, 256);\n+            int limit = BACKING_SIZE \/ 3 + RANDOM.nextInt(256);\n+            int invar1 = middle;\n+            int invar2 = middle;\n+            if (RANDOM.nextBoolean()) {\n+                invar1 -= limit;\n+                invar2 += limit;\n+            }\n+            test_fill_byte_sameMS_noalias(A, A, invar1, invar2, limit);\n+            reference_fill_byte_sameMS_noalias(A_REFERENCE, A_REFERENCE, invar1, invar2, limit);\n+        });\n+        referenceTests.put(\"test_fill_byte_sameMS_maybeAlias\", () -> {\n+            \/\/ The accesses either start at the middle and go out,\n+            \/\/ or start from opposite sides and meet in the middle.\n+            \/\/ In the middle, sometimes we overlap and sometimes not.\n+            \/\/      <------|------>\n+            \/\/      ------>|<------\n+            \/\/\n+            \/\/ This tests that the checks we emit are not too relaxed.\n+            int middle = BACKING_SIZE \/ 2 + RANDOM.nextInt(-256, 256);\n+            int limit = BACKING_SIZE \/ 3 + RANDOM.nextInt(256);\n+            int invar1 = middle + RANDOM.nextInt(-256, 256);\n+            int invar2 = middle + RANDOM.nextInt(-256, 256);\n+            \/\/ Are the bounds safe? Assume extreme values:\n+            \/\/ invar1 = 8k\/2 + 256 + 256\n+            \/\/ limit = 8k\/3 + 256\n+            \/\/ invar1 + limit = 8k * 5\/6 + 3 * 256\n+            \/\/                = 8k * 5\/6 + 3\/4 * 1k = 7.41k < 8k\n+            if (RANDOM.nextBoolean()) {\n+                invar1 -= limit;\n+                invar2 += limit;\n+            }\n+            test_fill_byte_sameMS_maybeAlias(A, A, invar1, invar2, limit);\n+            reference_fill_byte_sameMS_maybeAlias(A_REFERENCE, A_REFERENCE, invar1, invar2, limit);\n+        });\n+        referenceTests.put(\"test_fill_int_sameMS_alias\", () -> {\n+            int invar1 = RANDOM.nextInt(64);\n+            int invar2 = RANDOM.nextInt(64);\n+            test_fill_int_sameMS_alias(A, A, invar1, invar2);\n+            reference_fill_int_sameMS_alias(A_REFERENCE, A_REFERENCE, invar1, invar2);\n+        });\n+        referenceTests.put(\"test_fill_int_sameMS_noalias\", () -> {\n+            \/\/ The accesses either start at the middle and go out,\n+            \/\/ or start from opposite sides and meet in the middle.\n+            \/\/ But they never overlap.\n+            \/\/      <------|------>\n+            \/\/      ------>|<------\n+            \/\/\n+            \/\/ This tests that the checks we emit are not too relaxed.\n+            int middle = BACKING_SIZE \/ 2 + RANDOM.nextInt(-256, 256);\n+            int limit = BACKING_SIZE \/ 3 + RANDOM.nextInt(256);\n+            int invar1 = middle;\n+            int invar2 = middle;\n+            if (RANDOM.nextBoolean()) {\n+                invar1 -= limit;\n+                invar2 += limit;\n+            }\n+            test_fill_int_sameMS_noalias(A, A, invar1, invar2, limit);\n+            reference_fill_int_sameMS_noalias(A_REFERENCE, A_REFERENCE, invar1, invar2, limit);\n+        });\n+        referenceTests.put(\"test_fill_int_sameMS_maybeAlias\", () -> {\n+            \/\/ The accesses either start at the middle and go out,\n+            \/\/ or start from opposite sides and meet in the middle.\n+            \/\/ In the middle, sometimes we overlap and sometimes not.\n+            \/\/      <------|------>\n+            \/\/      ------>|<------\n+            \/\/\n+            \/\/ This tests that the checks we emit are not too relaxed.\n+            int middle = BACKING_SIZE \/ 2 + RANDOM.nextInt(-256, 256);\n+            int limit = BACKING_SIZE \/ 3 + RANDOM.nextInt(256);\n+            int invar1 = middle + RANDOM.nextInt(-256, 256);\n+            int invar2 = middle + RANDOM.nextInt(-256, 256);\n+            \/\/ Are the bounds safe? Assume extreme values:\n+            \/\/ invar1 = 8k\/2 + 256 + 256\n+            \/\/ limit = 8k\/3 + 256\n+            \/\/ invar1 + limit = 8k * 5\/6 + 3 * 256\n+            \/\/                = 8k * 5\/6 + 3\/4 * 1k = 7.41k < 8k\n+            if (RANDOM.nextBoolean()) {\n+                invar1 -= limit;\n+                invar2 += limit;\n+            }\n+            test_fill_int_sameMS_maybeAlias(A, A, invar1, invar2, limit);\n+            reference_fill_int_sameMS_maybeAlias(A_REFERENCE, A_REFERENCE, invar1, invar2, limit);\n+        });\n+    }\n+\n+    static MemorySegment newMemorySegment() {\n+        return provider.newMemorySegment();\n+    }\n+\n+    static MemorySegment copy(MemorySegment src) {\n+        MemorySegment dst = newMemorySegment();\n+        dst.copyFrom(src);\n+        return dst;\n+    }\n+\n+    static MemorySegment newMemorySegmentOfByteArray() {\n+        return MemorySegment.ofArray(new byte[BACKING_SIZE]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfCharArray() {\n+        return MemorySegment.ofArray(new char[BACKING_SIZE \/ 2]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfShortArray() {\n+        return MemorySegment.ofArray(new short[BACKING_SIZE \/ 2]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfIntArray() {\n+        return MemorySegment.ofArray(new int[BACKING_SIZE \/ 4]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfLongArray() {\n+        return MemorySegment.ofArray(new long[BACKING_SIZE \/ 8]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfFloatArray() {\n+        return MemorySegment.ofArray(new float[BACKING_SIZE \/ 4]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfDoubleArray() {\n+        return MemorySegment.ofArray(new double[BACKING_SIZE \/ 8]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfByteBuffer() {\n+        return MemorySegment.ofBuffer(ByteBuffer.allocate(BACKING_SIZE));\n+    }\n+\n+    static MemorySegment newMemorySegmentOfByteBufferDirect() {\n+        return MemorySegment.ofBuffer(ByteBuffer.allocateDirect(BACKING_SIZE));\n+    }\n+\n+    static MemorySegment newMemorySegmentOfNative() {\n+        \/\/ Auto arena: GC decides when there is no reference to the MemorySegment,\n+        \/\/ and then it deallocates the backing memory.\n+        return Arena.ofAuto().allocate(BACKING_SIZE, 1);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfMixedArray() {\n+        switch(RANDOM.nextInt(7)) {\n+            case 0  -> { return newMemorySegmentOfByteArray(); }\n+            case 1  -> { return newMemorySegmentOfCharArray(); }\n+            case 2  -> { return newMemorySegmentOfShortArray(); }\n+            case 3  -> { return newMemorySegmentOfIntArray(); }\n+            case 4  -> { return newMemorySegmentOfLongArray(); }\n+            case 5  -> { return newMemorySegmentOfFloatArray(); }\n+            default -> { return newMemorySegmentOfDoubleArray(); }\n+        }\n+    }\n+\n+    static MemorySegment newMemorySegmentOfMixedBuffer() {\n+        switch (RANDOM.nextInt(2)) {\n+            case 0  -> { return newMemorySegmentOfByteBuffer(); }\n+            default -> { return newMemorySegmentOfByteBufferDirect(); }\n+        }\n+    }\n+\n+    static MemorySegment newMemorySegmentOfMixed() {\n+        switch (RANDOM.nextInt(3)) {\n+            case 0  -> { return newMemorySegmentOfMixedArray(); }\n+            case 1  -> { return newMemorySegmentOfMixedBuffer(); }\n+            default -> { return newMemorySegmentOfNative(); }\n+        }\n+    }\n+\n+    static MemorySegment fillRandom(MemorySegment data) {\n+        for (int i = 0; i < (int)data.byteSize(); i += 8) {\n+            data.set(ValueLayout.JAVA_LONG_UNALIGNED, i, RANDOM.nextLong());\n+        }\n+        return data;\n+    }\n+\n+    public static void init() {\n+        A.copyFrom(ORIG_A);\n+        B.copyFrom(ORIG_B);\n+        C.copyFrom(ORIG_C);\n+    }\n+\n+    public static void initReference() {\n+        A_REFERENCE.copyFrom(ORIG_A);\n+        B_REFERENCE.copyFrom(ORIG_B);\n+        C_REFERENCE.copyFrom(ORIG_C);\n+    }\n+\n+    public static Object snapshotCopy() {\n+        return new Object[]{copy(A), copy(B), copy(C)};\n+    }\n+\n+    public static Object snapshot() {\n+        return new Object[]{A, B, C};\n+    }\n+\n+    public static Object snapshotReference() {\n+        return new Object[]{A_REFERENCE, B_REFERENCE, C_REFERENCE};\n+    }\n+\n+    @Run(test = {\"test_byte_incr_noaliasing\",\n+                 \"test_byte_incr_aliasing\",\n+                 \"test_byte_incr_aliasing_fwd3\",\n+                 \"test_byte_incr_noaliasing_fwd128\",\n+                 \"test_int_to_long_noaliasing\",\n+                 \"test_fill_byte_sameMS_alias\",\n+                 \"test_fill_byte_sameMS_noalias\",\n+                 \"test_fill_byte_sameMS_maybeAlias\",\n+                 \"test_fill_int_sameMS_alias\",\n+                 \"test_fill_int_sameMS_noalias\",\n+                 \"test_fill_int_sameMS_maybeAlias\"})\n+    void runTests(RunInfo info) {\n+        for (Map.Entry<String,TestFunction> entry : goldTests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            \/\/ Recall gold value from before compilation\n+            Object gold = golds.get(name);\n+            \/\/ Compute new result\n+            init();\n+            test.run();\n+            Object result = snapshot();\n+            \/\/ Compare gold and new result\n+            try {\n+                Verify.checkEQ(gold, result);\n+            } catch (VerifyException e) {\n+                throw new RuntimeException(\"Verify failed for \" + name, e);\n+            }\n+        }\n+\n+        \/\/ Once warmup is over (100x), repeat 10x to get reasonable coverage of the\n+        \/\/ randomness in the tests.\n+        int reps = info.isWarmUp() ? 10 : 1;\n+        for (int r = 0; r < reps; r++) {\n+            for (Map.Entry<String,TestFunction> entry : referenceTests.entrySet()) {\n+                String name = entry.getKey();\n+                TestFunction test = entry.getValue();\n+                \/\/ Init data for test and reference\n+                init();\n+                initReference();\n+                \/\/ Run test and reference\n+                test.run();\n+                \/\/ Capture results from test and reference\n+                Object result = snapshot();\n+                Object expected = snapshotReference();\n+                \/\/ Compare expected and new result\n+                try {\n+                    Verify.checkEQ(expected, result);\n+                } catch (VerifyException e) {\n+                    throw new RuntimeException(\"Verify failed for \" + name, e);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\",\n+                  \".*multiversion.*\",   \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test_byte_incr_noaliasing(MemorySegment a, MemorySegment b) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            byte v = a.get(ValueLayout.JAVA_BYTE, i);\n+            b.set(ValueLayout.JAVA_BYTE, i, (byte)(v + 1));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\",\n+                  \".*multiversion.*\",   \"> 0\"}, \/\/ AutoVectorization Predicate FAILS\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test_byte_incr_aliasing(MemorySegment a, MemorySegment b) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            byte v = a.get(ValueLayout.JAVA_BYTE, i);\n+            b.set(ValueLayout.JAVA_BYTE, i, (byte)(v + 1));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\",\n+                  \".*multiversion.*\",   \"> 0\"}, \/\/ AutoVectorization Predicate FAILS\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test_byte_incr_aliasing_fwd3(MemorySegment a, MemorySegment b) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            byte v = a.get(ValueLayout.JAVA_BYTE, i);\n+            b.set(ValueLayout.JAVA_BYTE, i, (byte)(v + 1));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\",\n+                  \".*multiversion.*\",   \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test_byte_incr_noaliasing_fwd128(MemorySegment a, MemorySegment b) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            byte v = a.get(ValueLayout.JAVA_BYTE, i);\n+            b.set(ValueLayout.JAVA_BYTE, i, (byte)(v + 1));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.VECTOR_CAST_I2L, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.STORE_VECTOR,                                                   \"> 0\",\n+                  \".*multiversion.*\",   \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    \/\/ In this case, the limit is pre-loop independent, but its assigned\n+    \/\/ ctrl sits between main and pre loop. Only the early ctrl is before\n+    \/\/ the pre loop.\n+    static void test_int_to_long_noaliasing(MemorySegment a, MemorySegment b) {\n+        long limit = a.byteSize() \/ 8L;\n+        for (long i = 0; i < limit; i++) {\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, 4L * i);\n+            b.set(ValueLayout.JAVA_LONG_UNALIGNED, 8L * i, v);\n+        }\n+    }\n+\n+    @Test\n+    \/\/ @IR(counts = {IRNode.STORE_VECTOR,  \"> 0\",\n+    \/\/               \".*multiversion.*\",   \"> 0\"}, \/\/ AutoVectorization Predicate FAILS\n+    \/\/     phase = CompilePhase.PRINT_IDEAL,\n+    \/\/     applyIfPlatform = {\"64-bit\", \"true\"},\n+    \/\/     applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+    \/\/     applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/\n+    \/\/ FAILS: but only on \"native\" and \"byte-buffer-direct\"\n+    \/\/        The issue is that one of the VPointers is invalid.\n+    static void test_fill_byte_sameMS_alias(MemorySegment a, MemorySegment b, long invar1, long invar2) {\n+        for (long i = 0; i < a.byteSize() - 100; i++) {\n+            a.set(ValueLayout.JAVA_BYTE, i + invar1, (byte)0x0a);\n+            b.set(ValueLayout.JAVA_BYTE, a.byteSize() - i - 1 - invar2, (byte)0x0b);\n+        }\n+    }\n+\n+    @DontCompile\n+    static void reference_fill_byte_sameMS_alias(MemorySegment a, MemorySegment b, long invar1, long invar2) {\n+        for (long i = 0; i < a.byteSize() - 100; i++) {\n+            a.set(ValueLayout.JAVA_BYTE, i + invar1, (byte)0x0a);\n+            b.set(ValueLayout.JAVA_BYTE, a.byteSize() - i - 1 - invar2, (byte)0x0b);\n+        }\n+    }\n+\n+    @Test\n+    \/\/ @IR(counts = {IRNode.STORE_VECTOR,  \"> 0\",\n+    \/\/               \".*multiversion.*\",   \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES\n+    \/\/     phase = CompilePhase.PRINT_IDEAL,\n+    \/\/     applyIfPlatform = {\"64-bit\", \"true\"},\n+    \/\/     applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+    \/\/     applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/\n+    \/\/ FAILS: but only on \"native\" and \"byte-buffer-direct\"\n+    \/\/        The issue is that one of the VPointers is invalid.\n+    \/\/\n+    \/\/ For now, we just assert that there is never multiversioning, which holds with or without vectorization:\n+    @IR(counts = {\".*multiversion.*\",   \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test_fill_byte_sameMS_noalias(MemorySegment a, MemorySegment b, long invar1, long invar2, long limit) {\n+        for (long i = 0; i < limit; i++) {\n+            a.set(ValueLayout.JAVA_BYTE, invar1 + i, (byte)0xa);\n+            b.set(ValueLayout.JAVA_BYTE, invar2 - i, (byte)0xb);\n+        }\n+    }\n+\n+    @DontCompile\n+    static void reference_fill_byte_sameMS_noalias(MemorySegment a, MemorySegment b, long invar1, long invar2, long limit) {\n+        for (long i = 0; i < limit; i++) {\n+            a.set(ValueLayout.JAVA_BYTE, invar1 + i, (byte)0xa);\n+            b.set(ValueLayout.JAVA_BYTE, invar2 - i, (byte)0xb);\n+        }\n+    }\n+\n+    @Test\n+    \/\/ @IR(counts = {IRNode.STORE_VECTOR,  \"> 0\"},\n+    \/\/     phase = CompilePhase.PRINT_IDEAL,\n+    \/\/     applyIfPlatform = {\"64-bit\", \"true\"},\n+    \/\/     applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+    \/\/     applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/\n+    \/\/ FAILS: but only on \"native\" and \"byte-buffer-direct\"\n+    \/\/        The issue is that one of the VPointers is invalid.\n+    \/\/\n+    \/\/ Note: we may or may not use multiversioning, depending if we alias or not at runtime.\n+    static void test_fill_byte_sameMS_maybeAlias(MemorySegment a, MemorySegment b, long invar1, long invar2, long limit) {\n+        for (long i = 0; i < limit; i++) {\n+            a.set(ValueLayout.JAVA_BYTE, invar1 + i, (byte)0xa);\n+            b.set(ValueLayout.JAVA_BYTE, invar2 - i, (byte)0xb);\n+        }\n+    }\n+\n+    @DontCompile\n+    static void reference_fill_byte_sameMS_maybeAlias(MemorySegment a, MemorySegment b, long invar1, long invar2, long limit) {\n+        for (long i = 0; i < limit; i++) {\n+            a.set(ValueLayout.JAVA_BYTE, invar1 + i, (byte)0xa);\n+            b.set(ValueLayout.JAVA_BYTE, invar2 - i, (byte)0xb);\n+        }\n+    }\n+\n+    @Test\n+    \/\/ @IR(counts = {IRNode.STORE_VECTOR,  \"> 0\",\n+    \/\/               \".*multiversion.*\",   \"> 0\"}, \/\/ AutoVectorization Predicate FAILS\n+    \/\/     phase = CompilePhase.PRINT_IDEAL,\n+    \/\/     applyIfPlatform = {\"64-bit\", \"true\"},\n+    \/\/     applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+    \/\/     applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/\n+    \/\/ FAILS: but only on \"native\" and \"byte-buffer-direct\"\n+    \/\/        The issue is that one of the VPointers is invalid.\n+    static void test_fill_int_sameMS_alias(MemorySegment a, MemorySegment b, long invar1, long invar2) {\n+        for (long i = 0; i < a.byteSize() - 100; i+=4) {\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, i + invar1, 0x01020304);\n+            b.set(ValueLayout.JAVA_INT_UNALIGNED, a.byteSize() - i - 4 - invar2, 0x11121314);\n+        }\n+    }\n+\n+    @DontCompile\n+    static void reference_fill_int_sameMS_alias(MemorySegment a, MemorySegment b, long invar1, long invar2) {\n+        for (long i = 0; i < a.byteSize() - 100; i+=4) {\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, i + invar1, 0x01020304);\n+            b.set(ValueLayout.JAVA_INT_UNALIGNED, a.byteSize() - i - 4 - invar2, 0x11121314);\n+        }\n+    }\n+\n+    @Test\n+    \/\/ @IR(counts = {IRNode.STORE_VECTOR,  \"> 0\",\n+    \/\/               \".*multiversion.*\",   \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES\n+    \/\/     phase = CompilePhase.PRINT_IDEAL,\n+    \/\/     applyIfPlatform = {\"64-bit\", \"true\"},\n+    \/\/     applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+    \/\/     applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/\n+    \/\/ FAILS: but only on \"native\" and \"byte-buffer-direct\"\n+    \/\/        The issue is that one of the VPointers is invalid.\n+    \/\/\n+    \/\/ For now, we just assert that there is never multiversioning, which holds with or without vectorization:\n+    @IR(counts = {\".*multiversion.*\",   \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test_fill_int_sameMS_noalias(MemorySegment a, MemorySegment b, long invar1, long invar2, long limit) {\n+        for (long i = 0; i <= limit - 4; i+=4) {\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, invar1 + i, 0x01020304);\n+            b.set(ValueLayout.JAVA_INT_UNALIGNED, invar2 - i, 0x11121314);\n+        }\n+    }\n+\n+    @DontCompile\n+    static void reference_fill_int_sameMS_noalias(MemorySegment a, MemorySegment b, long invar1, long invar2, long limit) {\n+        for (long i = 0; i <= limit - 4; i+=4) {\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, invar1 + i, 0x01020304);\n+            b.set(ValueLayout.JAVA_INT_UNALIGNED, invar2 - i, 0x11121314);\n+        }\n+    }\n+\n+    @Test\n+    \/\/ @IR(counts = {IRNode.STORE_VECTOR,  \"> 0\"},\n+    \/\/     phase = CompilePhase.PRINT_IDEAL,\n+    \/\/     applyIfPlatform = {\"64-bit\", \"true\"},\n+    \/\/     applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+    \/\/     applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/\n+    \/\/ FAILS: but only on \"native\" and \"byte-buffer-direct\"\n+    \/\/        The issue is that one of the VPointers is invalid.\n+    \/\/\n+    \/\/ Note: we may or may not use multiversioning, depending if we alias or not at runtime.\n+    static void test_fill_int_sameMS_maybeAlias(MemorySegment a, MemorySegment b, long invar1, long invar2, long limit) {\n+        for (long i = 0; i <= limit - 4; i+=4) {\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, invar1 + i, 0x01020304);\n+            b.set(ValueLayout.JAVA_INT_UNALIGNED, invar2 - i, 0x11121314);\n+        }\n+    }\n+\n+    @DontCompile\n+    static void reference_fill_int_sameMS_maybeAlias(MemorySegment a, MemorySegment b, long invar1, long invar2, long limit) {\n+        for (long i = 0; i <= limit - 4; i+=4) {\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, invar1 + i, 0x01020304);\n+            b.set(ValueLayout.JAVA_INT_UNALIGNED, invar2 - i, 0x11121314);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegmentAliasing.java","additions":914,"deletions":0,"binary":false,"changes":914,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8324751\n+ * @summary Reported issue: JDK-8359688: C2 SuperWord: missing RCE with MemorySegment\n+ *          The examples are generated from TestAliasingFuzzer.java\n+ *          So if you see something change here, you may want to investigate if we\n+ *          can also tighten up the IR rules there.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment_8359688\n+ *\/\n+\n+\n+public class TestMemorySegment_8359688 {\n+\n+    public static MemorySegment b = MemorySegment.ofArray(new long[4 * 30_000]);\n+\n+    public static void main(String[] args) {\n+        TestFramework f = new TestFramework();\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n+                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n+        f.start();\n+    }\n+\n+    @Setup\n+    static Object[] setup() {\n+        return new Object[] { b, 0, 5_000, 0 };\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\",\n+                  IRNode.REPLICATE_L,  \"= 0\",\n+                  \".*multiversion.*\",  \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES, there is no aliasing\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Does not manage to remove all RangeChecks -> no vectorization\n+    \/\/ If you see this IR rule fail: investigate JDK-8359688, possibly close it and fix this IR rule!\n+    \/\/ Also: consider renaming the file to something more descriptive: what have you fixed with this?\n+    \/\/ And: you may now be able to tighten IR rules in TestAliasingFuzzer.java\n+    public static void test1(MemorySegment b, int ivLo, int ivHi, int invar) {\n+        for (int i = ivLo; i < ivHi; i++) {\n+            b.setAtIndex(ValueLayout.JAVA_LONG_UNALIGNED, 30_000L - (long)i + (long)invar, 42);\n+            \/\/                                                    ^ subtraction here\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.REPLICATE_L,  \"> 0\",\n+                  \".*multiversion.*\",  \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES, there is no aliasing\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Is fully RFE'd and vectorized\n+    public static void test2(MemorySegment b, int ivLo, int ivHi, int invar) {\n+        for (int i = ivLo; i < ivHi; i++) {\n+            b.setAtIndex(ValueLayout.JAVA_LONG_UNALIGNED, 1_000L + 1L * i + (long)invar, 42);\n+            \/\/                                                   ^ addition here\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment_8359688.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8324751\n+ * @summary Reported issue: JDK-8360204: C2 SuperWord: missing RCE with MemorySegment.getAtIndex\n+ *          The examples are generated from TestAliasingFuzzer.java\n+ *          So if you see something change here, you may want to investigate if we\n+ *          can also tighten up the IR rules there.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment_8360204\n+ *\/\n+\n+public class TestMemorySegment_8360204 {\n+\n+    public static MemorySegment a = Arena.ofAuto().allocate(10_000);\n+    public static MemorySegment b = Arena.ofAuto().allocate(10_000);\n+\n+    private static long invar0_1159 = 0;\n+    private static long invar1_1159 = 0;\n+\n+    public static void main(String[] args) {\n+        TestFramework f = new TestFramework();\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n+                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n+        f.start();\n+    }\n+\n+    @Setup\n+    static Object[] setup() {\n+        return new Object[] { a, -19125L, b, 71734L + 2_000L, 0, 1_000 };\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\",\n+                  \".*multiversion.*\",   \"> 0\"}, \/\/ Sadly, we now multiversion\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    \/\/ There is no aliasing, so we should compile without multiversioning.\n+    \/\/ But currently, there seems to be some issue with RCE, we peel and lose the predicate.\n+    \/\/ Then we multiversion.\n+    \/\/ We could imagine that this would eventually vectorize, but since one counts up, and the other down,\n+    \/\/ we would have to implement shuffle first.\n+    \/\/\n+    \/\/ If you see this IR rule fail: investigate JDK-8360204, possibly close it and fix this IR rule!\n+    \/\/ Also: consider renaming the file to something more descriptive: what have you fixed with this?\n+    \/\/ And: you may now be able to tighten IR rules in TestAliasingFuzzer.java\n+    public static void test(MemorySegment container_0, long invar0_0, MemorySegment container_1, long invar0_1, long ivLo, long ivHi) {\n+        for (long i = ivLo; i < ivHi; i+=1) {\n+            var v = container_0.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED, 19125L + 1L * i + 1L * invar0_0 + 0L * invar0_1159 + 1L * invar1_1159);\n+            container_1.setAtIndex(ValueLayout.JAVA_INT_UNALIGNED, -71734L + -1L * i + 1L * invar0_1 + 1L * invar0_1159 + 0L * invar1_1159, v);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment_8360204.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8324751\n+ * @summary Reported issue: JDK-8365982: C2 SuperWord: missing RCE \/ strange Multiversioning with MemorySegment.set\n+ *          The examples are generated from TestAliasingFuzzer.java\n+ *          So if you see something change here, you may want to investigate if we\n+ *          can also tighten up the IR rules there.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment_8365982\n+ *\/\n+\n+public class TestMemorySegment_8365982 {\n+\n+    public static MemorySegment a = MemorySegment.ofArray(new short[100_000]);\n+    public static MemorySegment b = MemorySegment.ofArray(new short[100_000]);\n+\n+    private static long invar0_853 = 0;\n+    private static long invar1_853 = 0;\n+    private static long invar2_853 = 0;\n+\n+    public static void main(String[] args) {\n+        TestFramework f = new TestFramework();\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n+                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n+        f.start();\n+    }\n+\n+    @Setup\n+    static Object[] setup() {\n+        return new Object[] { a, -50_000, b, -30_000, 0, 10_000 };\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.REPLICATE_S,  \"> 0\",\n+                  \".*multiversion.*\",  \"= 0\"}, \/\/ Good: The AutoVectorization predicate suffices.\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"ShortRunningLongLoop\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    \/\/\n+    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.REPLICATE_S,  \"> 0\",\n+                  \".*multiversion.*\",  \"> 0\"}, \/\/ Bad: Sadly, we now multiversion\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"ShortRunningLongLoop\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Some but not all predicates are RCE'd at the beginning. After unrolling, we multiversion (why?).\n+    \/\/ After PreMainPost, we can do more RangeCheck. Now the main-loop of the multiversion_fast loop\n+    \/\/ does not have any range checks any more.\n+    \/\/ Now it vectorizes. That's good, but we should be able to vectorize without multiversioning.\n+    \/\/\n+    \/\/ If you see this IR rule fail: investigate JDK-8365982, possibly close it and fix this IR rule!\n+    \/\/ Also: consider renaming the file to something more descriptive: what have you fixed with this?\n+    \/\/ And: you may now be able to tighten IR rules in TestAliasingFuzzer.java\n+    public static void test(MemorySegment container_0, long invar0_0, MemorySegment container_1, long invar0_1, long ivLo, long ivHi) {\n+        for (long i = ivHi-1; i >= ivLo; i-=1) {\n+            container_0.set(ValueLayout.JAVA_CHAR_UNALIGNED, -47143L + -2L * i + -2L * invar0_0 + -1L * invar0_853 + -1L * invar1_853 + 0L * invar2_853, (char)0x0102030405060708L);\n+            container_1.set(ValueLayout.JAVA_CHAR_UNALIGNED, 74770L + 2L * i + 2L * invar0_1 + 0L * invar0_853 + 0L * invar1_853 + 0L * invar2_853, (char)0x1112131415161718L);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment_8365982.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -32,6 +32,7 @@\n- * @run main\/othervm -XX:CompileCommand=compileonly,compiler.loopopts.superword.TestMovingLoadBeforeStore::test*\n- *                   --add-modules java.base --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED\n- *                   -Xbatch\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressLCM\n- *                   -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=100\n- *                   compiler.loopopts.superword.TestMovingLoadBeforeStore\n+ * @run main\/othervm\/timeout=480\n+ *   -XX:CompileCommand=compileonly,compiler.loopopts.superword.TestMovingLoadBeforeStore::test*\n+ *   --add-modules java.base --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UnlockDiagnosticVMOptions -XX:+StressLCM\n+ *   -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=100\n+ *   compiler.loopopts.superword.TestMovingLoadBeforeStore\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMovingLoadBeforeStore.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -40,4 +40,8 @@\n- * @run driver compiler.loopopts.superword.TestSplitPacks nCOH_nAV\n- * @run driver compiler.loopopts.superword.TestSplitPacks nCOH_yAV\n- * @run driver compiler.loopopts.superword.TestSplitPacks yCOH_nAV\n- * @run driver compiler.loopopts.superword.TestSplitPacks yCOH_yAV\n+ * @run driver compiler.loopopts.superword.TestSplitPacks nCOH_nAV_ySAC\n+ * @run driver compiler.loopopts.superword.TestSplitPacks nCOH_yAV_ySAC\n+ * @run driver compiler.loopopts.superword.TestSplitPacks yCOH_nAV_ySAC\n+ * @run driver compiler.loopopts.superword.TestSplitPacks yCOH_yAV_ySAC\n+ * @run driver compiler.loopopts.superword.TestSplitPacks nCOH_nAV_nSAC\n+ * @run driver compiler.loopopts.superword.TestSplitPacks nCOH_yAV_nSAC\n+ * @run driver compiler.loopopts.superword.TestSplitPacks yCOH_nAV_nSAC\n+ * @run driver compiler.loopopts.superword.TestSplitPacks yCOH_yAV_nSAC\n@@ -79,4 +83,8 @@\n-            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n-            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"nCOH_nAV_ySAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"nCOH_yAV_ySAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"yCOH_nAV_ySAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"yCOH_yAV_ySAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"nCOH_nAV_nSAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"nCOH_yAV_nSAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"yCOH_nAV_nSAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"yCOH_yAV_nSAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"); }\n@@ -117,0 +125,7 @@\n+        tests.put(\"test4a_alias\",() -> { short[] x = aS.clone(); return test4a_alias(x, x); });\n+        tests.put(\"test4b_alias\",() -> { short[] x = aS.clone(); return test4b_alias(x, x); });\n+        tests.put(\"test4c_alias\",() -> { short[] x = aS.clone(); return test4c_alias(x, x); });\n+        tests.put(\"test4d_alias\",() -> { short[] x = aS.clone(); return test4d_alias(x, x); });\n+        tests.put(\"test4e_alias\",() -> { short[] x = aS.clone(); return test4e_alias(x, x); });\n+        tests.put(\"test4f_alias\",() -> { short[] x = aS.clone(); return test4f_alias(x, x); });\n+        tests.put(\"test4g_alias\",() -> { short[] x = aS.clone(); return test4g_alias(x, x); });\n@@ -148,0 +163,7 @@\n+                 \"test4a_alias\",\n+                 \"test4b_alias\",\n+                 \"test4c_alias\",\n+                 \"test4d_alias\",\n+                 \"test4e_alias\",\n+                 \"test4f_alias\",\n+                 \"test4g_alias\",\n@@ -714,1 +736,4 @@\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n@@ -718,0 +743,8 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\"})\n+    \/\/ Speculative aliasing check -> full vectorization.\n@@ -727,2 +760,4 @@\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIf = {\"AlignVector\", \"false\"},\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n@@ -732,0 +767,8 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\"})\n+    \/\/ Speculative aliasing check -> full vectorization.\n@@ -741,2 +784,4 @@\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIf = {\"MaxVectorSize\", \">=8\"},\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n@@ -746,0 +791,8 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check -> full vectorization.\n@@ -755,2 +808,4 @@\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\"},\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n@@ -760,0 +815,8 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check -> full vectorization.\n@@ -769,2 +832,4 @@\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\"},\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n@@ -774,0 +839,8 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check -> full vectorization.\n@@ -783,2 +856,4 @@\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\"},\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n@@ -788,0 +863,8 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check -> full vectorization.\n@@ -797,2 +880,4 @@\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIf = {\"MaxVectorSize\", \">=32\"},\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n@@ -802,0 +887,8 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check -> full vectorization.\n@@ -809,0 +902,175 @@\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\"})\n+    \/\/ Cyclic dependency with distance 2 -> split into 2-packs\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"> 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\"})\n+    \/\/ Speculative aliasing check with multiversioning -> full vectorization & split packs.\n+    static Object[] test4a_alias(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+2] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\"})\n+    \/\/ Cyclic dependency with distance 3 -> split into 2-packs\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"> 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\"})\n+    \/\/ Speculative aliasing check with multiversioning -> full vectorization & split packs.\n+    static Object[] test4b_alias(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+3] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Cyclic dependency with distance 4 -> split into 4-packs\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"> 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check with multiversioning -> full vectorization & split packs.\n+    static Object[] test4c_alias(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+4] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Cyclic dependency with distance 5 -> split into 4-packs\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"> 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check with multiversioning -> full vectorization & split packs.\n+    static Object[] test4d_alias(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+5] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Cyclic dependency with distance 6 -> split into 4-packs\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"> 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check with multiversioning -> full vectorization & split packs.\n+    static Object[] test4e_alias(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+6] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Cyclic dependency with distance 7 -> split into 4-packs\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"> 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check with multiversioning -> full vectorization & split packs.\n+    static Object[] test4f_alias(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+7] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_8, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Cyclic dependency with distance 8 -> split into 8-packs\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_8, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"> 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check with multiversioning -> full vectorization & split packs.\n+    static Object[] test4g_alias(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+8] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestSplitPacks.java","additions":289,"deletions":21,"binary":false,"changes":310,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run driver compiler.loopstripmining.CheckLoopStripMining\n+ * @run driver\/timeout=480 compiler.loopstripmining.CheckLoopStripMining\n","filename":"test\/hotspot\/jtreg\/compiler\/loopstripmining\/CheckLoopStripMining.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm -Xbatch -XX:-UseOnStackReplacement -XX:+IgnoreUnrecognizedVMOptions -XX:MaxTrivialSize=0 -XX:C1MaxTrivialSize=0 compiler.profiling.TestProfileCounterOverflow\n+ * @run main\/othervm\/timeout=480 -Xbatch -XX:-UseOnStackReplacement -XX:+IgnoreUnrecognizedVMOptions -XX:MaxTrivialSize=0 -XX:C1MaxTrivialSize=0 compiler.profiling.TestProfileCounterOverflow\n","filename":"test\/hotspot\/jtreg\/compiler\/profiling\/TestProfileCounterOverflow.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,4 +35,4 @@\n- * @run main\/othervm -XX:CompilationMode=high-only -XX:-BackgroundCompilation -XX:CompileThreshold=10000\n- *                   -XX:-UseOnStackReplacement -XX:TypeProfileLevel=222\n- *                   -XX:ReservedCodeCacheSize=3M -Djdk.attach.allowAttachSelf\n- *                   compiler.profiling.spectrapredefineclass.Agent\n+ * @run main\/othervm\/timeout=480 -XX:CompilationMode=high-only -XX:-BackgroundCompilation -XX:CompileThreshold=10000\n+ *                               -XX:-UseOnStackReplacement -XX:TypeProfileLevel=222\n+ *                               -XX:ReservedCodeCacheSize=3M -Djdk.attach.allowAttachSelf\n+ *                               compiler.profiling.spectrapredefineclass.Agent\n","filename":"test\/hotspot\/jtreg\/compiler\/profiling\/spectrapredefineclass\/Launcher.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,4 +38,4 @@\n- * @run main\/othervm -XX:CompilationMode=high-only -XX:-BackgroundCompilation -XX:CompileThreshold=10000\n- *                   -XX:-UseOnStackReplacement -XX:TypeProfileLevel=222\n- *                   -XX:ReservedCodeCacheSize=3M -Djdk.attach.allowAttachSelf\n- *                   compiler.profiling.spectrapredefineclass_classloaders.Agent\n+ * @run main\/othervm\/timeout=480 -XX:CompilationMode=high-only -XX:-BackgroundCompilation -XX:CompileThreshold=10000\n+ *                               -XX:-UseOnStackReplacement -XX:TypeProfileLevel=222\n+ *                               -XX:ReservedCodeCacheSize=3M -Djdk.attach.allowAttachSelf\n+ *                               compiler.profiling.spectrapredefineclass_classloaders.Agent\n","filename":"test\/hotspot\/jtreg\/compiler\/profiling\/spectrapredefineclass_classloaders\/Launcher.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+TieredCompilation\n+ * @run main\/othervm\/timeout=960 -Xbootclasspath\/a:. -XX:+TieredCompilation\n@@ -104,1 +104,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/tiered\/Level2RecompilationTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm -XX:-BackgroundCompilation -Xmx128M -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyStack\n+ * @run main\/othervm\/timeout=480 -XX:-BackgroundCompilation -Xmx128M -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyStack\n@@ -41,1 +41,1 @@\n- * @run main\/othervm -XX:-BackgroundCompilation -Xmx128M -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyStack\n+ * @run main\/othervm\/timeout=480 -XX:-BackgroundCompilation -Xmx128M -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyStack\n","filename":"test\/hotspot\/jtreg\/compiler\/uncommontrap\/TestDeoptOOM.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,2 @@\n- * @run main\/othervm -XX:-TieredCompilation -Xbatch\n+ * @run main\/othervm\/timeout=480\n+ *                   -XX:-TieredCompilation -Xbatch\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestRawOopAtSafepoint.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-* @run driver compiler.vectorization.TestFloat16VectorOperations\n+* @run driver\/timeout=480 compiler.vectorization.TestFloat16VectorOperations\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorOperations.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,4 +30,1 @@\n- * @run driver compiler.vectorization.TestFloatConversionsVector nCOH_nAV\n- * @run driver compiler.vectorization.TestFloatConversionsVector nCOH_yAV\n- * @run driver compiler.vectorization.TestFloatConversionsVector yCOH_nAV\n- * @run driver compiler.vectorization.TestFloatConversionsVector yCOH_yAV\n+ * @run driver compiler.vectorization.TestFloatConversionsVector\n@@ -38,0 +35,2 @@\n+import java.util.Set;\n+\n@@ -52,7 +51,2 @@\n-        switch (args[0]) {\n-            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n-            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n-            default -> { throw new RuntimeException(\"Test argument not recognized: \" + args[0]); }\n-        };\n+        framework.addCrossProductScenarios(Set.of(\"-XX:-UseCompactObjectHeaders\", \"-XX:+UseCompactObjectHeaders\"),\n+                                           Set.of(\"-XX:-AlignVector\", \"-XX:+AlignVector\"));\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloatConversionsVector.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @key randomness\n@@ -40,0 +41,1 @@\n+import java.util.Random;\n@@ -43,0 +45,1 @@\n+import jdk.test.lib.Utils;\n@@ -82,0 +85,1 @@\n+        Random rand = Utils.getRandomInstance();\n@@ -88,2 +92,3 @@\n-            if (i%39 == 0) {\n-                int x = 0x7f800000 + ((i\/39) << 13);\n+            if (i%3 == 0) {\n+                int shift = rand.nextInt(13+1);\n+                int x = 0x7f800000 + ((i\/39) << shift);\n@@ -131,1 +136,2 @@\n-        String msg = \"floatToFloat16 wrong result: idx: \" + idx + \", \\t\" + f +\n+        String msg = \"floatToFloat16 wrong result: idx: \" + idx +\n+                     \", \\t\" + f + \", hex: \" + Integer.toHexString(Float.floatToRawIntBits(f)) +\n@@ -170,1 +176,1 @@\n-            if (i%39 == 0) {\n+            if (i%3 == 0) {\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloatConversionsVectorNaN.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main\/othervm compiler.vectorization.TestVectorZeroCount\n+ * @run main\/othervm\/timeout=480 compiler.vectorization.TestVectorZeroCount\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestVectorZeroCount.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,4 +34,12 @@\n- * @run main\/othervm -Xbootclasspath\/a:.\n- *                   -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI\n- *                   compiler.vectorization.runner.LoopArrayIndexComputeTest\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.LoopArrayIndexComputeTest nAV_ySAC\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.LoopArrayIndexComputeTest yAV_ySAC\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.LoopArrayIndexComputeTest nAV_nSAC\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.LoopArrayIndexComputeTest yAV_nSAC\n@@ -51,0 +59,12 @@\n+    \/\/ We must pass the flags directly to the test-VM, and not the driver vm in the @run above.\n+    @Override\n+    protected String[] testVMFlags(String[] args) {\n+        return switch (args[0]) {\n+            case \"nAV_ySAC\" -> new String[]{\"-XX:-AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"};\n+            case \"yAV_ySAC\" -> new String[]{\"-XX:+AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"};\n+            case \"nAV_nSAC\" -> new String[]{\"-XX:-AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"};\n+            case \"yAV_nSAC\" -> new String[]{\"-XX:+AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"};\n+            default -> { throw new RuntimeException(\"Test argument not recognized: \" + args[0]); }\n+        };\n+    }\n+\n@@ -178,1 +198,10 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+     \/\/ Speculative aliasing check -> never fails -> only predicate, no multiversioning.\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.LOAD_VECTOR_I, \">0\", \/\/ full vectorization\n+                  \".*multiversion.*\", \"= 0\"})\n+    \/\/ JDK-8354303: could we prove statically that there is no aliasing?\n@@ -189,1 +218,10 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    \/\/ Speculative aliasing check -> never fails -> only predicate, no multiversioning.\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.LOAD_VECTOR_I, \">0\", \/\/ full vectorization\n+                  \".*multiversion.*\", \"= 0\"})\n+    \/\/ JDK-8354303: could we prove statically that there is no aliasing?\n@@ -279,1 +317,11 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    \/\/ Speculative aliasing check -> never fails -> only predicate, no multiversioning.\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.MUL_VS, \">0\",\n+                  IRNode.LOAD_VECTOR_S, \">0\", \/\/ full vectorization\n+                  \".*multiversion.*\", \"= 0\"})\n+    \/\/ JDK-8354303: could we prove statically that there is no aliasing?\n@@ -307,0 +355,2 @@\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n@@ -308,1 +358,2 @@\n-                  IRNode.MUL_VS, IRNode.VECTOR_SIZE_2, \">0\"}) \/\/ size 2 only\n+                  IRNode.MUL_VS, IRNode.VECTOR_SIZE_2, \">0\", \/\/ size 2 only\n+                  \".*multiversion.*\", \"= 0\"})\n@@ -335,1 +386,11 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        failOn = {IRNode.STORE_VECTOR})\n+    \/\/ Speculative aliasing check -> never fails -> only predicate, no multiversioning.\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.ADD_VB, \">0\", \/\/ full vectorization\n+                  \".*multiversion.*\", \"= 0\"})\n+    \/\/ JDK-8354303: could we prove statically that there is no aliasing?\n@@ -340,1 +401,1 @@\n-            res[i] *= bytes[i - 3];\n+            res[i] += bytes[i - 3];\n@@ -362,0 +423,9 @@\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.OR_VB, IRNode.VECTOR_SIZE_4, \">0\", \/\/ size 4 only\n+                  \".*multiversion.*\", \"= 0\"})\n+    \/\/ Speculative aliasing check -> never fails -> only predicate, no multiversioning.\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n@@ -363,1 +433,3 @@\n-                  IRNode.OR_VB, IRNode.VECTOR_SIZE_4, \">0\"}) \/\/ size 4 only\n+                  IRNode.OR_VB, \">0\", \/\/ full vectorization\n+                  \".*multiversion.*\", \"= 0\"})\n+    \/\/ JDK-8354303: could we prove statically that there is no aliasing?\n@@ -389,1 +461,10 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    \/\/ Speculative aliasing check -> never fails -> only predicate, no multiversioning.\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.LOAD_VECTOR_I, \">0\", \/\/ full vectorization\n+                  \".*multiversion.*\", \"= 0\"})\n+    \/\/ JDK-8354303: could we prove statically that there is no aliasing?\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopArrayIndexComputeTest.java","additions":93,"deletions":12,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @run main\/othervm -XX:+UseG1GC -Xss32m -Xmx128m -XX:G1HeapRegionSize=1m\n+ * @run main\/othervm\/timeout=480 -XX:+UseG1GC -Xss32m -Xmx128m -XX:G1HeapRegionSize=1m\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGreyReclaimedHumongousObjects.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n- * @run main\/othervm\/timeout=240  -Xms256M -Xmx256M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=960  -Xms256M -Xmx256M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -54,1 +54,1 @@\n- * @run main\/othervm -Xms256M -Xmx256M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480 -Xms256M -Xmx256M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -59,1 +59,1 @@\n- * @run main\/othervm -Xms256M -Xmx256M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480 -Xms256M -Xmx256M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -64,1 +64,1 @@\n- *@run main\/othervm -Xms256M -Xmx256M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *@run main\/othervm\/timeout=480 -Xms256M -Xmx256M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/humongousObjects\/TestHumongousClassLoader.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n- * @run main\/othervm -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480 -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -51,1 +51,1 @@\n- * @run main\/othervm -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480 -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -55,1 +55,1 @@\n- * @run main\/othervm -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480 -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -59,1 +59,1 @@\n- * @run main\/othervm -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480 -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -63,1 +63,1 @@\n- * @run main\/othervm -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480 -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/humongousObjects\/TestHumongousNonArrayAllocation.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @run driver\/timeout=480 gc.g1.ihop.TestIHOPErgo\n+ * @run driver\/timeout=1920 gc.g1.ihop.TestIHOPErgo\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/ihop\/TestIHOPErgo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n- * @run main\/othervm\/timeout=700 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=1200 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestMultiThreadStressRSet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,4 +34,4 @@\n- * @run driver gc.stress.TestReclaimStringsLeaksMemory\n- * @run driver gc.stress.TestReclaimStringsLeaksMemory -XX:+UseSerialGC\n- * @run driver gc.stress.TestReclaimStringsLeaksMemory -XX:+UseParallelGC\n- * @run driver gc.stress.TestReclaimStringsLeaksMemory -XX:+UseG1GC\n+ * @run driver\/timeout=480 gc.stress.TestReclaimStringsLeaksMemory\n+ * @run driver\/timeout=480 gc.stress.TestReclaimStringsLeaksMemory -XX:+UseSerialGC\n+ * @run driver\/timeout=480 gc.stress.TestReclaimStringsLeaksMemory -XX:+UseParallelGC\n+ * @run driver\/timeout=480 gc.stress.TestReclaimStringsLeaksMemory -XX:+UseG1GC\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestReclaimStringsLeaksMemory.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run driver\/timeout=180 gc.stress.TestStressG1Humongous 4 3 1.1 120\n+ * @run driver\/timeout=240 gc.stress.TestStressG1Humongous 4 3 1.1 120\n@@ -43,1 +43,1 @@\n- * @run driver\/timeout=180 gc.stress.TestStressG1Humongous 16 5 2.1 120\n+ * @run driver\/timeout=240 gc.stress.TestStressG1Humongous 16 5 2.1 120\n@@ -52,1 +52,1 @@\n- * @run driver\/timeout=180 gc.stress.TestStressG1Humongous 32 4 0.6 120\n+ * @run driver\/timeout=240 gc.stress.TestStressG1Humongous 32 4 0.6 120\n@@ -61,1 +61,1 @@\n- * @run driver\/timeout=900 gc.stress.TestStressG1Humongous 1 7 0.6 600\n+ * @run driver\/timeout=1200 gc.stress.TestStressG1Humongous 1 7 0.6 600\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestStressG1Humongous.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n@@ -56,1 +56,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n@@ -71,1 +71,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n@@ -86,1 +86,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n@@ -101,1 +101,1 @@\n- * @run main\/othervm\/timeout=1800\n+ * @run main\/othervm\/timeout=7200\n@@ -116,1 +116,1 @@\n- * @run main\/othervm\/timeout=1800\n+ * @run main\/othervm\/timeout=7200\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestStressRSetCoarsening.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm\/timeout=300 -Xlog:gc*=info -Xmx512m -XX:+UseG1GC gc.stress.systemgc.TestSystemGCWithG1 270\n+ * @run main\/othervm\/timeout=540 -Xlog:gc*=info -Xmx512m -XX:+UseG1GC gc.stress.systemgc.TestSystemGCWithG1 270\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/systemgc\/TestSystemGCWithG1.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm\/timeout=300 -Xlog:gc=info -Xmx512m -XX:+UseParallelGC gc.stress.systemgc.TestSystemGCWithParallel 270\n+ * @run main\/othervm\/timeout=540 -Xlog:gc=info -Xmx512m -XX:+UseParallelGC gc.stress.systemgc.TestSystemGCWithParallel 270\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/systemgc\/TestSystemGCWithParallel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm\/timeout=300 -Xlog:gc*=info -Xmx512m -XX:+UseSerialGC gc.stress.systemgc.TestSystemGCWithSerial 270\n+ * @run main\/othervm\/timeout=540 -Xlog:gc*=info -Xmx512m -XX:+UseSerialGC gc.stress.systemgc.TestSystemGCWithSerial 270\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/systemgc\/TestSystemGCWithSerial.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @run main\/othervm\/timeout=300 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n+ * @run main\/othervm\/timeout=540 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n@@ -40,1 +40,1 @@\n- * @run main\/othervm\/timeout=300 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n+ * @run main\/othervm\/timeout=540 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n@@ -52,1 +52,1 @@\n- * @run main\/othervm\/timeout=300 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n+ * @run main\/othervm\/timeout=540 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n@@ -57,1 +57,1 @@\n- * @run main\/othervm\/timeout=300 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n+ * @run main\/othervm\/timeout=540 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/systemgc\/TestSystemGCWithShenandoah.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.z;\n+\n+\/*\n+ * @test id=Normal\n+ * @requires vm.gc.Z & vm.debug\n+ * @summary Test ZGC graceful failure when a commit fails\n+ * @library \/ \/test\/lib\n+ * @run driver gc.z.TestCommitFailure\n+ *\/\n+\n+\/*\n+ * @test id=ZFakeNUMA\n+ * @requires vm.gc.Z & vm.debug\n+ * @library \/ \/test\/lib\n+ * @summary Test ZGC graceful failure when a commit fails (with ZFakeNUMA)\n+ * @run driver gc.z.TestCommitFailure -XX:ZFakeNUMA=16\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+\n+import static gc.testlibrary.Allocation.blackHole;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class TestCommitFailure {\n+    static final int K = 1024;\n+    static final int M = 1024 * K;\n+\n+    static final int XMS = 128 * M;\n+    static final int XMX = 512 * M;\n+\n+    static class Test {\n+        static final int LARGE_ALLOC = 256 * M;\n+        static final int SMALL_GARBAGE = 256 * M;\n+        static final int SMALL_LIVE = 128 * M;\n+\n+        \/\/ Allocates at least totalLive bytes of objects and add them to list.\n+        static void allocLive(List<Object> list, int totalLive) {\n+            final int largePageAllocationSize = 6 * M;\n+            for (int live = 0; live < totalLive; live += largePageAllocationSize) {\n+                list.add(new byte[largePageAllocationSize - K]);\n+            }\n+        }\n+\n+        \/\/ Allocates at least totalGarbage bytes of garbage large pages.\n+        static void allocGarbage(int totalGarbage) {\n+            final int largePageAllocationSize = 6 * M;\n+            for (int garbage = 0; garbage < totalGarbage; garbage += largePageAllocationSize) {\n+                blackHole(new byte[largePageAllocationSize - K]);\n+            }\n+        }\n+\n+        public static void main(String[] args) {\n+            final var list = new ArrayList<Object>();\n+            try {\n+                \/\/ Fill heap with small live objects\n+                allocLive(list, SMALL_LIVE);\n+                \/\/ Fill with small garbage objects\n+                allocGarbage(SMALL_GARBAGE);\n+                \/\/ Allocate large objects where commit fails until an OOME is thrown\n+                while (true) {\n+                    list.add(new byte[LARGE_ALLOC - K]);\n+                }\n+            } catch (OutOfMemoryError oome) {}\n+            blackHole(list);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        final int xmxInM = XMX \/ M;\n+        final int xmsInM = XMS \/ M;\n+        final var arguments = new ArrayList(Arrays.asList(args));\n+        arguments.addAll(List.of(\n+            \"-XX:+UseZGC\",\n+            \"-Xlog:gc+init\",\n+            \"-XX:ZFailLargerCommits=\" + XMS,\n+            \"-Xms\" + xmsInM + \"M\",\n+            \"-Xmx\" + xmxInM + \"M\",\n+            Test.class.getName()));\n+\n+        ProcessTools.executeTestJava(arguments)\n+                .outputTo(System.out)\n+                .errorTo(System.out)\n+                .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestCommitFailure.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,2 @@\n+                \/\/ Disable NUMA to avoid potential OOM after JDK-8359683\n+                \"-XX:-UseNUMA\",\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestSmallHeap.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/othervm -XX:+UseZGC -Xlog:gc*,gc+heap=debug,gc+stats=off -Xms128M -Xmx512M -XX:ZUncommitDelay=5 gc.z.TestUncommit\n+ * @run main\/othervm\/timeout=480 -XX:+UseZGC -Xlog:gc*,gc+heap=debug,gc+stats=off -Xms128M -Xmx512M -XX:ZUncommitDelay=5 gc.z.TestUncommit\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestUncommit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/native GTestWrapper\n+ * @run main\/native\/timeout=480 GTestWrapper\n","filename":"test\/hotspot\/jtreg\/gtest\/GTestWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n- * @run driver TestInheritFD\n+ * @run driver\/timeout=480 TestInheritFD\n@@ -81,0 +81,2 @@\n+import jdk.test.lib.Utils;\n+\n@@ -93,2 +95,1 @@\n-    public static float timeoutFactor = Float.parseFloat(System.getProperty(\"test.timeout.factor\", \"1.0\"));\n-    public static long subProcessTimeout = (long)(15L * timeoutFactor);\n+    public static long subProcessTimeout = (long)(60L * Utils.TIMEOUT_FACTOR);\n","filename":"test\/hotspot\/jtreg\/runtime\/8176717\/TestInheritFD.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires vm.cds.default.archive.available\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedCPUSpecificClassSpaceReservation.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main\/othervm -Xcomp ArraysNewInstanceBug\n+ * @run main\/othervm\/timeout=480 -Xcomp ArraysNewInstanceBug\n","filename":"test\/hotspot\/jtreg\/runtime\/CreateMirror\/ArraysNewInstanceBug.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run driver CreateCoredumpOnCrash\n+ * @run driver\/timeout=480 CreateCoredumpOnCrash\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/CreateCoredumpOnCrash.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,1 +79,5 @@\n-                pattern = new Pattern[] { Pattern.compile(\"Registers:\"), Pattern.compile(\"R0=.*\")};\n+                if (Platform.isLinux()) {\n+                    pattern = new Pattern[] { Pattern.compile(\"Registers:\"), Pattern.compile(\"R0=.*\")};\n+                } else if (Platform.isWindows()) {\n+                    pattern = new Pattern[] { Pattern.compile(\"Registers:\"), Pattern.compile(\"X0 =.*\")};\n+                }\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/ShowRegistersOnAssertTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @run driver\/timeout=1800 invocationC1Tests special\n+ * @run driver\/timeout=7200 invocationC1Tests special\n@@ -48,1 +48,1 @@\n- * @run driver\/timeout=1800 invocationC1Tests virtual\n+ * @run driver\/timeout=7200 invocationC1Tests virtual\n@@ -61,1 +61,1 @@\n- * @run driver\/timeout=1800 invocationC1Tests interface\n+ * @run driver\/timeout=7200 invocationC1Tests interface\n","filename":"test\/hotspot\/jtreg\/runtime\/InvocationTests\/invocationC1Tests.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * @run driver\/timeout=1800 invokeinterfaceTests current-int\n+ * @run driver\/timeout=5400 invokeinterfaceTests current-int\n@@ -50,1 +50,1 @@\n- * @run driver\/timeout=1800 invokeinterfaceTests current-comp\n+ * @run driver\/timeout=5400 invokeinterfaceTests current-comp\n@@ -64,1 +64,1 @@\n- * @run driver\/timeout=1800 invokeinterfaceTests old-int\n+ * @run driver\/timeout=5400 invokeinterfaceTests old-int\n","filename":"test\/hotspot\/jtreg\/runtime\/InvocationTests\/invokeinterfaceTests.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run driver TestResize\n+ * @run driver\/timeout=480 TestResize\n","filename":"test\/hotspot\/jtreg\/runtime\/LoadClass\/TestResize.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -Xint -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=detail VirtualAllocCommitMerge\n+ * @run main\/othervm\/timeout=480 -Xbootclasspath\/a:. -Xint -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=detail VirtualAllocCommitMerge\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/VirtualAllocCommitMerge.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm\/timeout=500 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies InvokeInterfaceICCE\n+ * @run main\/othervm\/timeout=2000 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies InvokeInterfaceICCE\n","filename":"test\/hotspot\/jtreg\/runtime\/SelectionResolution\/InvokeInterfaceICCE.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm\/timeout=300 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies InvokeInterfaceSuccessTest\n+ * @run main\/othervm\/timeout=1200 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies InvokeInterfaceSuccessTest\n","filename":"test\/hotspot\/jtreg\/runtime\/SelectionResolution\/InvokeInterfaceSuccessTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm\/timeout=1200 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies InvokeVirtualICCE\n+ * @run main\/othervm\/timeout=4800 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies InvokeVirtualICCE\n","filename":"test\/hotspot\/jtreg\/runtime\/SelectionResolution\/InvokeVirtualICCE.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm\/timeout=400 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies InvokeVirtualSuccessTest\n+ * @run main\/othervm\/timeout=1600 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies InvokeVirtualSuccessTest\n","filename":"test\/hotspot\/jtreg\/runtime\/SelectionResolution\/InvokeVirtualSuccessTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main\/othervm TestThreadDumpMonitorContention\n+ * @run main\/othervm\/timeout=480 TestThreadDumpMonitorContention\n@@ -53,0 +53,5 @@\n+    \/\/ jstack streaming output should be disabled because if the attach operation is executed at a safepoint,\n+    \/\/ the attach streaming output is enabled, and the tool output is lengthy, then we can get both buffers (the attach\n+    \/\/ channel and the tool redirection buffer) full and the test hangs.\n+    \/\/ Instead the attach operation output is buffered and is sent after the operation is completed.\n+    final static String DISABLE_STREAMING_OUTPUT = \"-J-Djdk.attach.allowStreamingOutput=false\";\n@@ -382,1 +387,1 @@\n-            Process process = new ProcessBuilder(JSTACK, PID)\n+            Process process = new ProcessBuilder(JSTACK, DISABLE_STREAMING_OUTPUT, PID)\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/TestThreadDumpMonitorContention.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires vm.flagless\n@@ -36,0 +37,2 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n@@ -49,1 +52,1 @@\n-        ArrayList<String> dumpArgs = new ArrayList<>();\n+        ArrayList<String> vmArgs = new ArrayList<>();\n@@ -52,1 +55,1 @@\n-        dumpArgs.add(\"-Xmx128M\");\n+        vmArgs.add(\"-Xmx128M\");\n@@ -57,1 +60,1 @@\n-            dumpArgs.add(\"-XX:\" + sign + \"UseCompressedOops\");\n+            vmArgs.add(\"-XX:\" + sign + \"UseCompressedOops\");\n@@ -60,1 +63,3 @@\n-        dump(dumpArgs);\n+        String archiveFile = dump(vmArgs);\n+        exec(vmArgs, archiveFile);\n+\n@@ -64,1 +69,3 @@\n-    static void dump(ArrayList<String> args, String... more) throws Exception {\n+\n+    \/\/ Create a map file when creating the archive\n+    static String dump(ArrayList<String> args) throws Exception {\n@@ -70,0 +77,1 @@\n+            \/\/ filesize=0 ensures that a large map file not broken up in multiple files.\n@@ -72,2 +80,1 @@\n-            .addSuffix(args)\n-            .addSuffix(more);\n+            .addSuffix(args);\n@@ -78,0 +85,19 @@\n+\n+        return archiveName;\n+    }\n+\n+    \/\/ Create a map file when using the archive\n+    static void exec(ArrayList<String> vmArgs, String archiveFile) throws Exception {\n+        String mapName = archiveFile + \".exec.map\";\n+        vmArgs.add(\"-XX:SharedArchiveFile=\" + archiveFile);\n+        vmArgs.add(\"-Xlog:cds=debug\");\n+        vmArgs.add(\"-Xshare:on\");\n+        vmArgs.add(\"-Xlog:aot+map=debug,aot+map+oops=trace:file=\" + mapName + \":none:filesize=0\");\n+        vmArgs.add(\"--version\");\n+        String[] cmdLine = vmArgs.toArray(new String[vmArgs.size()]);\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(cmdLine);\n+        OutputAnalyzer out = CDSTestUtils.executeAndLog(pb, \"exec\");\n+        out.shouldHaveExitValue(0);\n+\n+        CDSMapReader.MapFile mapFile = CDSMapReader.read(mapName);\n+        CDSMapReader.validate(mapFile);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/CDSMapTest.java","additions":33,"deletions":7,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ * @run main\/othervm\/timeout=480 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/DeterministicDump.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,2 +97,2 @@\n-    private static boolean isCOHArchiveAvailable(char coops, char coh,\n-                                                 String archiveSuffix) throws Exception {\n+    private static boolean isArchiveAvailable(char coops, char coh,\n+                                              String archiveSuffix) throws Exception {\n@@ -116,0 +116,4 @@\n+                if (!isArchiveAvailable(coops, coh, archiveSuffix)) {\n+                    throw new SkippedException(\"Skipping test due to \" +\n+                                               archivePath(archiveSuffix).toString() + \" not available\");\n+                }\n@@ -121,1 +125,1 @@\n-                if (!isCOHArchiveAvailable(coops, coh, archiveSuffix)) {\n+                if (!isArchiveAvailable(coops, coh, archiveSuffix)) {\n@@ -130,0 +134,4 @@\n+                if (!isArchiveAvailable(coops, coh, archiveSuffix)) {\n+                    throw new SkippedException(\"Skipping test due to \" +\n+                                               archivePath(archiveSuffix).toString() + \" not available\");\n+                }\n@@ -134,1 +142,1 @@\n-                if (!isCOHArchiveAvailable(coops, coh, archiveSuffix)) {\n+                if (!isArchiveAvailable(coops, coh, archiveSuffix)) {\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/TestDefaultArchiveLoading.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @run driver\/timeout=500 LotsOfSyntheticClasses\n+ * @run driver\/timeout=8000 LotsOfSyntheticClasses\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LotsOfSyntheticClasses.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,9 +25,1 @@\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.BuildHelper;\n-import jdk.test.lib.JDKToolFinder;\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.cds.CDSOptions;\n-import jdk.test.lib.cds.CDSTestUtils;\n-import jdk.test.lib.cds.CDSTestUtils.Result;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n+import cdsutils.DynamicDumpHelper;\n@@ -37,1 +29,0 @@\n-import java.io.InputStream;\n@@ -39,0 +30,1 @@\n+import java.io.InputStream;\n@@ -41,1 +33,0 @@\n-import java.nio.file.Files;\n@@ -44,0 +35,1 @@\n+import java.nio.file.Files;\n@@ -47,1 +39,0 @@\n-import java.util.Arrays;\n@@ -49,0 +40,1 @@\n+import java.util.Arrays;\n@@ -56,0 +48,10 @@\n+import jdk.test.lib.BuildHelper;\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils.Result;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n@@ -57,1 +59,0 @@\n-import cdsutils.DynamicDumpHelper;\n@@ -79,3 +80,0 @@\n-    private static final String timeoutFactor =\n-        System.getProperty(\"test.timeout.factor\", \"1.0\");\n-\n@@ -423,1 +421,1 @@\n-        cmd.add(\"-Dtest.timeout.factor=\" + timeoutFactor);\n+        cmd.add(\"-Dtest.timeout.factor=\" + Utils.TIMEOUT_FACTOR);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestCommon.java","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=aot\n+ * @bug 8362566\n+ * @summary Test the contents of -Xlog:aot+map with AOT workflow\n+ * @requires vm.flagless\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\n+ * @build AOTMapTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar AOTMapTestApp\n+ * @run driver AOTMapTest AOT --two-step-training\n+ *\/\n+\n+\/**\n+ * @test id=dynamic\n+ * @bug 8362566\n+ * @summary Test the contents of -Xlog:aot+map with AOT workflow\n+ * @requires vm.flagless\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @build AOTMapTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar AOTMapTestApp\n+ * @run  main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. AOTMapTest DYNAMIC\n+ *\/\n+\n+\n+import java.util.ArrayList;\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.Platform;\n+\n+public class AOTMapTest {\n+    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+    static final String mainClass = \"AOTMapTestApp\";\n+\n+    public static void main(String[] args) throws Exception {\n+        doTest(args, false);\n+\n+        if (Platform.is64bit()) {\n+            \/\/ There's no oop\/klass compression on 32-bit.\n+            doTest(args, true);\n+        }\n+    }\n+\n+    public static void doTest(String[] args, boolean compressed) throws Exception {\n+        Tester tester = new Tester(compressed);\n+        tester.run(args);\n+\n+        validate(tester.dumpMapFile);\n+        validate(tester.runMapFile);\n+    }\n+\n+    static void validate(String mapFileName) {\n+        CDSMapReader.MapFile mapFile = CDSMapReader.read(mapFileName);\n+        CDSMapReader.validate(mapFile);\n+    }\n+\n+    static class Tester extends CDSAppTester {\n+        boolean compressed;\n+        String dumpMapFile;\n+        String runMapFile;\n+\n+        public Tester(boolean compressed) {\n+            super(mainClass);\n+            this.compressed = compressed;\n+\n+            dumpMapFile = \"test\" + (compressed ? \"0\" : \"1\") + \".dump.aotmap\";\n+            runMapFile  = \"test\" + (compressed ? \"0\" : \"1\") + \".run.aotmap\";\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            ArrayList<String> vmArgs = new ArrayList<>();\n+\n+            vmArgs.add(\"-Xmx128M\");\n+            vmArgs.add(\"-Xlog:aot=debug\");\n+\n+            if (Platform.is64bit()) {\n+                \/\/ These options are available only on 64-bit.\n+                String sign = (compressed) ?  \"+\" : \"-\";\n+                vmArgs.add(\"-XX:\" + sign + \"UseCompressedOops\");\n+            }\n+\n+            \/\/ filesize=0 ensures that a large map file not broken up in multiple files.\n+            String logMapPrefix = \"-Xlog:aot+map=debug,aot+map+oops=trace:file=\";\n+            String logMapSuffix = \":none:filesize=0\";\n+\n+            if (runMode == RunMode.ASSEMBLY || runMode == RunMode.DUMP_DYNAMIC) {\n+                vmArgs.add(logMapPrefix + dumpMapFile + logMapSuffix);\n+            } else if (runMode == RunMode.PRODUCTION) {\n+                vmArgs.add(logMapPrefix + runMapFile + logMapSuffix);\n+            }\n+\n+            return vmArgs.toArray(new String[vmArgs.size()]);\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                mainClass,\n+            };\n+        }\n+    }\n+}\n+\n+class AOTMapTestApp {\n+    public static void main(String[] args) {\n+        System.out.println(\"Hello AOTMapTestApp\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/AOTMapTest.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -35,1 +35,1 @@\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ * @run driver\/timeout=480 jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n@@ -40,1 +40,1 @@\n- * @run driver AOTCodeCompressedOopsTest\n+ * @run driver\/timeout=480 AOTCodeCompressedOopsTest\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCode\/AOTCodeCompressedOopsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @run driver AOTProfileFlags\n+ * @run driver\/timeout=480 AOTProfileFlags\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotProfile\/AOTProfileFlags.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+ * @requires vm.cds.nocoops.archive.available\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/loaderConstraints\/DynamicLoaderConstraintsTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run driver\/timeout=650 SharedStringsStress\n+ * @run driver\/timeout=2600 SharedStringsStress\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/SharedStringsStress.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,2 @@\n- * @run testng\/othervm -Xcomp -XX:-TieredCompilation  ArrayIndexOutOfBoundsExceptionTest\n- * @run testng\/othervm -Xcomp -XX:TieredStopAtLevel=1 ArrayIndexOutOfBoundsExceptionTest\n+ * @run testng\/othervm\/timeout=480 -Xcomp -XX:-TieredCompilation  ArrayIndexOutOfBoundsExceptionTest\n+ * @run testng\/othervm\/timeout=480 -Xcomp -XX:TieredStopAtLevel=1 ArrayIndexOutOfBoundsExceptionTest\n","filename":"test\/hotspot\/jtreg\/runtime\/exceptionMsgs\/ArrayIndexOutOfBoundsException\/ArrayIndexOutOfBoundsExceptionTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm -Xmx256m -XX:MaxMetaspaceSize=64m -javaagent:redefineagent.jar -Xlog:all=trace:file=all.log RedefineClasses\n+ * @run main\/othervm\/timeout=480 -Xmx256m -XX:MaxMetaspaceSize=64m -javaagent:redefineagent.jar -Xlog:all=trace:file=all.log RedefineClasses\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/RedefineClasses.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run driver StressAsyncUL\n+ * @run driver\/timeout=480 StressAsyncUL\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/StressAsyncUL.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main\/othervm -Xmx128m ReflectOutOfMemoryError\n+ * @run main\/othervm\/timeout=480 -Xmx128m ReflectOutOfMemoryError\n","filename":"test\/hotspot\/jtreg\/runtime\/reflect\/ReflectOutOfMemoryError.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @run junit\/othervm\/native -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI --enable-native-access=ALL-UNNAMED UnmountedVThreadNativeMethodAtTop\n+ * @run junit\/othervm\/native\/timeout=480 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI --enable-native-access=ALL-UNNAMED UnmountedVThreadNativeMethodAtTop\n","filename":"test\/hotspot\/jtreg\/serviceability\/HeapDump\/UnmountedVThreadNativeMethodAtTop.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main\/othervm\/native -Xmx512m -agentlib:HeapMonitorTest MyPackage.HeapMonitorThreadTest\n+ * @run main\/othervm\/native\/timeout=480 -Xmx512m -agentlib:HeapMonitorTest MyPackage.HeapMonitorThreadTest\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorThreadTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,3 +29,3 @@\n- * @run main\/othervm\/native -agentlib:TagMapTest\n- *                          -Xlog:jvmti+table\n- *                          TagMapTest\n+ * @run main\/othervm\/native\/timeout=480 -agentlib:TagMapTest\n+ *                                      -Xlog:jvmti+table\n+ *                                      TagMapTest\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SetTag\/TagMapTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=700\n@@ -43,1 +43,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=700\n@@ -56,1 +56,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=700\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/SuspendResume2\/SuspendResume2.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n- * @run main\/othervm\/timeout=240 ClhsdbDumpheap\n+ * @run main\/othervm\/timeout=960 ClhsdbDumpheap\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbDumpheap.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run main\/othervm\/timeout=480 ClhsdbFindPC true false\n+ * @run main\/othervm\/timeout=1920 ClhsdbFindPC true false\n@@ -56,1 +56,1 @@\n- * @run main\/othervm\/timeout=480 ClhsdbFindPC true true\n+ * @run main\/othervm\/timeout=1920 ClhsdbFindPC true true\n@@ -67,1 +67,1 @@\n- * @run main\/othervm\/timeout=480 ClhsdbFindPC false false\n+ * @run main\/othervm\/timeout=1920 ClhsdbFindPC false false\n@@ -77,1 +77,1 @@\n- * @run main\/othervm\/timeout=480 ClhsdbFindPC false true\n+ * @run main\/othervm\/timeout=1920 ClhsdbFindPC false true\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbFindPC.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * @run driver\/timeout=300 ClhsdbJstackXcompStress\n+ * @run driver\/timeout=1200 ClhsdbJstackXcompStress\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbJstackXcompStress.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run main\/othervm ClhsdbThreadContext\n+ * @run main\/othervm\/timeout=480 ClhsdbThreadContext\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbThreadContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run driver TestJhsdbJstackLineNumbers\n+ * @run driver\/timeout=480 TestJhsdbJstackLineNumbers\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJhsdbJstackLineNumbers.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run driver TestObjectAlignment\n+ * @run driver\/timeout=480 TestObjectAlignment\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestObjectAlignment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run driver SADebugDTest\n+ * @run driver\/timeout=480 SADebugDTest\n@@ -128,1 +128,1 @@\n-                Process debugd = startProcess(\"debugd\", pb, null, l -> checkOutput(l, useRmiPort, rmiPort), 20, TimeUnit.SECONDS);\n+                Process debugd = startProcess(\"debugd\", pb, null, l -> checkOutput(l, useRmiPort, rmiPort), 80, TimeUnit.SECONDS);\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/sadebugd\/SADebugDTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+                    \"share\/memory\",\n@@ -59,0 +60,1 @@\n+                    \"share\/nmt\",\n@@ -61,0 +63,3 @@\n+                    \"share\/precompiled\",\n+                    \"share\/prims\",\n+                    \"share\/runtime\",\n","filename":"test\/hotspot\/jtreg\/sources\/TestIncludesAreSorted.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * @run driver ir_framework.tests.TestNotCompilable\n+ * @run driver\/timeout=480 ir_framework.tests.TestNotCompilable\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestNotCompilable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.tests;\n+\n+import java.util.Set;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true & vm.compMode != \"Xint\" & vm.compiler2.enabled & vm.flagless\n+ * @summary Test cross product scenarios with the framework.\n+ * @library \/test\/lib \/testlibrary_tests \/\n+ * @run driver ir_framework.tests.TestScenariosCrossProduct\n+ *\/\n+\n+public class TestScenariosCrossProduct {\n+    static void hasNFailures(String s, int count) {\n+        if (!s.matches(\"The following scenarios have failed: (#[0-9](, )?){\" + count + \"}. Please check stderr for more information.\")) {\n+            throw new RuntimeException(\"Expected \" + count + \" failures in \\\"\" + s + \"\\\"\");\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Test argument handling\n+        try {\n+            TestFramework t = new TestFramework();\n+            t.addCrossProductScenarios((Set<String>[]) null);\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestFormatException e) {}\n+        try {\n+            TestFramework t = new TestFramework();\n+            t.addCrossProductScenarios(Set.of(\"foo\", \"bar\"), null);\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestFormatException e) {}\n+        try {\n+            TestFramework t = new TestFramework();\n+            t.addCrossProductScenarios(Set.of(\"blub\"), Set.of(\"foo\", null));\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (NullPointerException e) {} \/\/ Set.of prevents null elements\n+        try {\n+            TestFramework t = new TestFramework();\n+            t.addCrossProductScenarios();\n+        } catch (TestFormatException e) {\n+            Asserts.fail(\"Should not have thrown exception\");\n+        }\n+\n+        \/\/ Single set should test all flags in the set by themselves.\n+        try {\n+            TestFramework t1 = new TestFramework();\n+            t1.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=51\",\n+                                               \"-XX:TLABRefillWasteFraction=53\",\n+                                               \"-XX:TLABRefillWasteFraction=64\"));\n+            t1.start();\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestRunException e) {\n+            hasNFailures(e.getMessage(), 3);\n+        }\n+\n+        \/\/ The cross product of a set with one element and a set with three elements is three sets.\n+        try {\n+            TestFramework t2 = new TestFramework();\n+            t2.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=53\"),\n+                                        Set.of(\"-XX:+UseNewCode\", \"-XX:+UseNewCode2\", \"-XX:+UseNewCode3\"));\n+            t2.start();\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestRunException e) {\n+            hasNFailures(e.getMessage(), 3);\n+        }\n+\n+        \/\/ The cross product of two sets with two elements is four sets.\n+        try {\n+            TestFramework t3 = new TestFramework();\n+            t3.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:TLABRefillWasteFraction=64\"),\n+                                        Set.of(\"-XX:+UseNewCode\", \"-XX:-UseNewCode\"));\n+            t3.start();\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestRunException e) {\n+            hasNFailures(e.getMessage(), 4);\n+        }\n+\n+        \/\/ Test with a pair of flags.\n+        try {\n+            TestFramework t4 = new TestFramework();\n+            t4.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=50 -XX:+UseNewCode\", \"-XX:TLABRefillWasteFraction=40\"),\n+                                        Set.of(\"-XX:+UseNewCode2\"));\n+            t4.start();\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestRunException e) {\n+            hasNFailures(e.getMessage(), 1);\n+        }\n+\n+        \/\/ Test with an empty string. All 6 scenarios fail because 64 is the default value for TLABRefillWasteFraction.\n+        try {\n+            TestFramework t5 = new TestFramework();\n+            t5.addCrossProductScenarios(Set.of(\"\", \"-XX:TLABRefillWasteFraction=51\", \"-XX:TLABRefillWasteFraction=53\"),\n+                                        Set.of(\"-XX:+UseNewCode\", \"-XX:+UseNewCode2\"));\n+            t5.start();\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestRunException e) {\n+            hasNFailures(e.getMessage(), 6);\n+        }\n+\n+        try {\n+            TestFramework t6 = new TestFramework();\n+            t6.addScenarios(new Scenario(0, \"-XX:TLABRefillWasteFraction=50\", \"-XX:+UseNewCode\")); \/\/ failPair\n+            t6.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=51\", \"-XX:TLABRefillWasteFraction=53\"),\n+                                        Set.of(\"-XX:+UseNewCode\", \"-XX:+UseNewCode2\"));\n+            try {\n+                t6.addScenarios(new Scenario(4, \"-XX:+UseNewCode3\")); \/\/ fails because index 4 is already used\n+            Asserts.fail(\"Should have thrown exception\");\n+            } catch (TestFormatException e) {}\n+            t6.addScenarios(new Scenario(5, \"-XX:+UseNewCode3\")); \/\/ fail default\n+            t6.start();\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestRunException e) {\n+            hasNFailures(e.getMessage(), 6);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"TLABRefillWasteFraction\", \"64\"}, counts = {IRNode.CALL, \"1\"})\n+    public void failDefault() {\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"TLABRefillWasteFraction\", \"51\"}, counts = {IRNode.CALL, \"1\"})\n+    public void fail1() {\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"TLABRefillWasteFraction\", \"53\"}, counts = {IRNode.CALL, \"1\"})\n+    public void fail2() {\n+    }\n+\n+    @Test\n+    @IR(applyIfAnd = {\"TLABRefillWasteFraction\", \"50\", \"UseNewCode\", \"true\"}, counts = {IRNode.CALL, \"1\"})\n+    public void failPair() {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestScenariosCrossProduct.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_redefinition_inMemoryCompilation_keep_class\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_redefinition_inMemoryCompilation_keep_obj\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large001\/large001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large002\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large003\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large004\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large005\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.gctests.SoftReference.soft004.soft004 -t 1\n+ * @run main\/othervm\/timeout=480 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.gctests.SoftReference.soft004.soft004 -t 1\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/SoftReference\/soft004\/soft004.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.gctests.WeakReference.weak004.weak004 -t 1\n+ * @run main\/othervm\/timeout=480 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.gctests.WeakReference.weak004.weak004 -t 1\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReference\/weak004\/weak004.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm gc.vector.SimpleGC.SimpleGC -ms low -gp circularList(low)\n+ * @run main\/othervm\/timeout=480 gc.vector.SimpleGC.SimpleGC -ms low -gp circularList(low)\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/vector\/CircularListLow\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * @run driver\/timeout=300 ExecDriver --java -server -Xcomp -XX:+DoEscapeAnalysis\n+ * @run driver\/timeout=1200 ExecDriver --java -server -Xcomp -XX:+DoEscapeAnalysis\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/jit\/escape\/AdaptiveBlocking\/AdaptiveBlocking001\/AdaptiveBlocking001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -41,1 +41,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/shrink_grow\/CompressedClassSpaceSize\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run driver metaspace.shrink_grow.ShrinkGrowMultiJVM.ShrinkGrowMultiJVM\n+ * @run driver\/timeout=480 metaspace.shrink_grow.ShrinkGrowMultiJVM.ShrinkGrowMultiJVM\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/shrink_grow\/ShrinkGrowMultiJVM\/ShrinkGrowMultiJVM.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy001\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy002\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy003\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy004\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy005\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy006\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy007\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy008\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy009\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy010\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy011\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy012\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy013\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy014\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy015\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ObjectReference\/referringObjects\/referringObjects001\/referringObjects001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n- * @run driver\n+ * @run driver\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/StepEvent\/_itself_\/stepEvent004\/stepEvent004.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n- * @run driver\n+ * @run driver\/timeout=480\n@@ -94,1 +94,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadDeathEvent\/thread\/thread001\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n@@ -79,1 +79,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/stress\/serial\/mixed002\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n- * @run main\/othervm\/timeout=420\n+ * @run main\/othervm\/timeout=1680\n@@ -65,1 +65,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdwp\/VirtualMachine\/HoldEvents\/holdevents002\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * @run main\/othervm\/native -agentlib:rawmnwait001 nsk.jvmti.RawMonitorWait.rawmnwait001\n+ * @run main\/othervm\/native\/timeout=480 -agentlib:rawmnwait001 nsk.jvmti.RawMonitorWait.rawmnwait001\n@@ -42,1 +42,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RawMonitorWait\/rawmnwait001\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n@@ -66,1 +66,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP03\/sp03t001\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n@@ -66,1 +66,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP03\/sp03t002\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n@@ -65,1 +65,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP04\/sp04t001\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n@@ -65,1 +65,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP04\/sp04t002\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n@@ -45,1 +45,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP07\/sp07t001\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * @run main\/othervm nsk.monitoring.ThreadInfo.isSuspended.issuspended002\n+ * @run main\/othervm\/timeout=480 nsk.monitoring.ThreadInfo.isSuspended.issuspended002\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended002.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n- * @run main\/othervm\/native nsk.monitoring.stress.thread.strace001 -threadCount=50 -depth=200\n+ * @run main\/othervm\/native\/timeout=480 nsk.monitoring.stress.thread.strace001 -threadCount=50 -depth=200\n@@ -65,1 +65,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/thread\/strace001\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n@@ -67,1 +67,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/thread\/strace002\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n@@ -68,1 +68,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/thread\/strace003\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+\n+    \/\/ In nanoseconds\n@@ -62,1 +64,0 @@\n-    private long finishTime;\n@@ -64,0 +65,2 @@\n+    private long stressTime;\n+\n@@ -182,1 +185,1 @@\n-        println(out, \"Execution time: \" + (currentTime - startTime) + \" seconds\");\n+        println(out, \"Execution time: \" + (currentTime - startTime) \/ 1_000_000_000.0 + \" seconds\");\n@@ -189,2 +192,2 @@\n-        } else if (finishTime != 0 && currentTime >= finishTime) {\n-            println(out, \"Execution finished because time was exceeded: \" + (currentTime - startTime) + \" >= \" + (finishTime - startTime));\n+        } else if (stressTime != 0 && (currentTime - startTime) >= stressTime) {\n+            println(out, \"Execution finished because time has exceeded stress time: \" + stressTime \/ 1_000_000_000 + \" seconds\");\n@@ -211,7 +214,2 @@\n-        long stressTime = options.getTime();\n-        startTime = System.currentTimeMillis();\n-        if (stressTime == 0) {\n-            finishTime = 0;\n-        } else {\n-            finishTime = startTime + stressTime * 1000;\n-        }\n+        stressTime = options.getTime() * 1_000_000_000;\n+        startTime = System.nanoTime();\n@@ -235,1 +233,1 @@\n-        currentTime = System.currentTimeMillis();\n+        currentTime = System.nanoTime();\n@@ -258,0 +256,2 @@\n+        boolean result = continueExecution();\n+        \/\/ Call print at the end to show the most up-to-date info.\n@@ -261,1 +261,1 @@\n-        return continueExecution();\n+        return result;\n@@ -270,1 +270,1 @@\n-        currentTime = System.currentTimeMillis();\n+        currentTime = System.nanoTime();\n@@ -277,1 +277,1 @@\n-                && (finishTime == 0 || currentTime < finishTime);\n+                && (stressTime == 0 || (currentTime - startTime) < stressTime);\n@@ -312,1 +312,1 @@\n-        return System.currentTimeMillis() - startTime;\n+        return (System.nanoTime() - startTime) \/ 1_000_000;\n@@ -321,2 +321,2 @@\n-        long current = System.currentTimeMillis();\n-        if (current >= finishTime) {\n+        long elapsedTime = System.nanoTime() - startTime;\n+        if (elapsedTime >= stressTime) {\n@@ -325,1 +325,1 @@\n-            return finishTime - current;\n+            return (stressTime - elapsedTime) \/ 1_000_000;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/test\/Stresser.java","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n- * @run main\/othervm\/native nsk.stress.strace.strace006\n+ * @run main\/othervm\/native\/timeout=480 nsk.stress.strace.strace006\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace006.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm nsk.stress.thread.thread001 500 2m 5s\n+ * @run main\/othervm\/timeout=480 nsk.stress.thread.thread001 500 2m 5s\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/thread\/thread001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/othervm nsk.stress.thread.thread002 500 2m 5s\n+ * @run main\/othervm\/timeout=480 nsk.stress.thread.thread002 500 2m 5s\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/thread\/thread002.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm nsk.stress.thread.thread005 500 2m 5s\n+ * @run main\/othervm\/timeout=480 nsk.stress.thread.thread005 500 2m 5s\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/thread\/thread005.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/othervm nsk.stress.thread.thread006 500 2m 5s\n+ * @run main\/othervm\/timeout=480 nsk.stress.thread.thread006 500 2m 5s\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/thread\/thread006.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/othervm\/timeout=300 nsk.stress.thread.thread007 500 2m 5s\n+ * @run main\/othervm\/timeout=1200 nsk.stress.thread.thread007 500 2m 5s\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/thread\/thread007.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\/timeout=300 nsk.stress.thread.thread008 500 2m 5s\n+ * @run main\/othervm\/timeout=1200 nsk.stress.thread.thread008 500 2m 5s\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/thread\/thread008.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -45,1 +45,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -47,1 +47,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -53,1 +53,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree001\/btree001.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -44,1 +44,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -46,1 +46,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -53,1 +53,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree002\/btree002.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -44,1 +44,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -46,1 +46,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -53,1 +53,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree003\/btree003.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -45,1 +45,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -47,1 +47,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -52,1 +52,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree004\/btree004.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -44,1 +44,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -46,1 +46,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -52,1 +52,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree005\/btree005.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -44,1 +44,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -46,1 +46,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -52,1 +52,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree006\/btree006.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -47,1 +47,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -49,1 +49,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -56,1 +56,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree007\/btree007.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -46,1 +46,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -48,1 +48,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -56,1 +56,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree008\/btree008.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -46,1 +46,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -48,1 +48,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -56,1 +56,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree009\/btree009.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -47,1 +47,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -49,1 +49,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -55,1 +55,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree010\/btree010.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -46,1 +46,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -48,1 +48,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -55,1 +55,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree011\/btree011.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -46,1 +46,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -48,1 +48,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -55,1 +55,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree012\/btree012.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/indy\/func\/jvmti\/mergeCP_indy2manyDiff_a\/TestDescription.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n- * @run main\/othervm -XX:CompileCommand=MemLimit,*.*,0 vm.mlvm.meth.stress.compiler.i2c_c2i.Test\n+ * @run main\/othervm\/timeout=480 -XX:CompileCommand=MemLimit,*.*,0 vm.mlvm.meth.stress.compiler.i2c_c2i.Test\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/meth\/stress\/compiler\/i2c_c2i\/Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/meth\/stress\/compiler\/sequences\/Test.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -122,1 +122,0 @@\n-java\/awt\/Frame\/BogusFocusableWindowState\/BogusFocusableWindowState.java 8361521 linux-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ * @library \/test\/lib\n@@ -50,0 +51,1 @@\n+import jdk.test.lib.Utils;\n@@ -62,3 +64,1 @@\n-            double timeoutFactor = Double.parseDouble(\n-                    System.getProperty(\"test.timeout.factor\", \"1.0\"));\n-            timeout = (int) (timeout * timeoutFactor);\n+            timeout = (int) (timeout * Utils.TIMEOUT_FACTOR);\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KeyFactory\/TestProviderLeak.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import jdk.test.lib.Utils;\n@@ -33,0 +34,1 @@\n+ * @library \/test\/lib\n@@ -287,2 +289,1 @@\n-                    float timeoutFactor = Float.parseFloat(System.getProperty(\"test.timeout.factor\", \"1.0\"));\n-                    long sleepSeconds = (long)(20 * timeoutFactor);\n+                    long sleepSeconds = (long)(20 * Utils.TIMEOUT_FACTOR);\n","filename":"test\/jdk\/com\/sun\/jdi\/InterruptHangTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,3 @@\n- * @run driver MethodEntryExitEvents SUSPEND_EVENT_THREAD MethodEntryExitEventsDebugee\n- * @run driver MethodEntryExitEvents SUSPEND_NONE MethodEntryExitEventsDebugee\n- * @run driver MethodEntryExitEvents SUSPEND_ALL MethodEntryExitEventsDebugee\n+ * @run driver\/timeout=480 MethodEntryExitEvents SUSPEND_EVENT_THREAD MethodEntryExitEventsDebugee\n+ * @run driver\/timeout=480 MethodEntryExitEvents SUSPEND_NONE MethodEntryExitEventsDebugee\n+ * @run driver\/timeout=480 MethodEntryExitEvents SUSPEND_ALL MethodEntryExitEventsDebugee\n","filename":"test\/jdk\/com\/sun\/jdi\/MethodEntryExitEvents.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/othervm -Xmx7m ThreadMemoryLeakTest\n+ * @run main\/othervm\/timeout=480 -Xmx7m ThreadMemoryLeakTest\n","filename":"test\/jdk\/com\/sun\/jdi\/ThreadMemoryLeakTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run testng\/othervm LdapPoolTimeoutTest\n+ * @run testng\/othervm\/timeout=480 LdapPoolTimeoutTest\n@@ -147,1 +147,0 @@\n-\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/LdapPoolTimeoutTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -51,0 +52,2 @@\n+import jtreg.SkippedException;\n+\n@@ -57,6 +60,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -344,0 +341,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/Bind.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @key intermittent\n@@ -48,0 +49,2 @@\n+import jtreg.SkippedException;\n+\n@@ -57,1 +60,1 @@\n-            throw new jtreg.SkippedException(\"SCTP protocol is not supported\");\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n@@ -66,1 +69,1 @@\n-            throw new jtreg.SkippedException(\"Cannot locate lsof in \" + lsofDirs);\n+            throw new SkippedException(\"Cannot locate lsof in \" + lsofDirs);\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/CloseDescriptors.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -52,0 +53,2 @@\n+import jtreg.SkippedException;\n+\n@@ -64,6 +67,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -358,0 +355,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/CommUp.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -28,0 +29,1 @@\n+ * @run main\/timeout=480 Connect\n@@ -46,0 +48,2 @@\n+import jtreg.SkippedException;\n+\n@@ -53,6 +57,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -238,0 +236,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/Connect.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -51,0 +52,2 @@\n+import jtreg.SkippedException;\n+\n@@ -64,7 +67,0 @@\n-\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -352,0 +348,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/Receive.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -48,0 +49,2 @@\n+import jtreg.SkippedException;\n+\n@@ -59,6 +62,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -267,0 +264,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/ReceiveIntoDirect.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -51,0 +52,2 @@\n+import jtreg.SkippedException;\n+\n@@ -63,6 +66,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -454,0 +451,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/Send.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -46,0 +47,2 @@\n+import jtreg.SkippedException;\n+\n@@ -54,6 +57,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -275,0 +272,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/Shutdown.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -46,0 +47,2 @@\n+import jtreg.SkippedException;\n+\n@@ -69,6 +72,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -193,0 +190,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/SocketOptionTests.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -51,0 +52,2 @@\n+import jtreg.SkippedException;\n+\n@@ -61,6 +64,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -280,0 +277,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpMultiChannel\/Branch.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -41,0 +42,2 @@\n+import jtreg.SkippedException;\n+\n@@ -49,3 +52,1 @@\n-            System.out.println(\"SCTP protocol is not supported\");\n-            System.out.println(\"Test cannot be run\");\n-            return;\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n@@ -60,3 +61,1 @@\n-            System.out.println(\"Cannot locate lsof in \" + lsofDirs);\n-            System.out.println(\"Test cannot be run\");\n-            return;\n+            throw new SkippedException(\"Cannot locate lsof in \" + lsofDirs);\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpMultiChannel\/CloseDescriptors.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -45,0 +46,2 @@\n+import jtreg.SkippedException;\n+\n@@ -55,6 +58,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -358,0 +355,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpMultiChannel\/Send.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -38,0 +39,2 @@\n+import jtreg.SkippedException;\n+\n@@ -48,6 +51,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -189,0 +186,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpMultiChannel\/SendFailed.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -54,0 +55,2 @@\n+import jtreg.SkippedException;\n+\n@@ -77,6 +80,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -247,0 +244,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpMultiChannel\/SocketOptionTests.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -44,0 +45,2 @@\n+import jtreg.SkippedException;\n+\n@@ -53,6 +56,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -265,0 +262,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpServerChannel\/Accept.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -28,0 +29,1 @@\n+ * @run main\/timeout=480 NonBlockingAccept\n@@ -45,0 +47,2 @@\n+import jtreg.SkippedException;\n+\n@@ -54,6 +58,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -221,0 +219,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpServerChannel\/NonBlockingAccept.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @bug 8346952\n+ * @bug 8346952 8361521\n","filename":"test\/jdk\/java\/awt\/Frame\/BogusFocusableWindowState\/BogusFocusableWindowState.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main\/timeout=300\/othervm MTTest\n+ * @run main\/timeout=400\/othervm MTTest\n","filename":"test\/jdk\/java\/awt\/font\/NumericShaper\/MTTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run main TestMethodFinder\n+ * @run main\/timeout=480 TestMethodFinder\n","filename":"test\/jdk\/java\/beans\/XMLDecoder\/8028054\/TestMethodFinder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED StdLibTest\n+ * @run testng\/othervm\/timeout=480 --enable-native-access=ALL-UNNAMED StdLibTest\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,4 +26,4 @@\n- * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAccessModes\n- * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAccessModes\n- * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAccessModes\n- * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAccessModes\n+ * @run testng\/othervm\/timeout=480 -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAccessModes\n+ * @run testng\/othervm\/timeout=480 -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAccessModes\n+ * @run testng\/othervm\/timeout=480 -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAccessModes\n+ * @run testng\/othervm\/timeout=480 -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAccessModes\n","filename":"test\/jdk\/java\/foreign\/TestAccessModes.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @run junit TestBufferStackStress2\n+ * @run junit\/timeout=480 TestBufferStackStress2\n","filename":"test\/jdk\/java\/foreign\/TestBufferStackStress2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run testng\/othervm\n+ * @run testng\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/foreign\/TestConcurrentClose.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @run main\/othervm\/timeout=10 --enable-native-access=ALL-UNNAMED -Xlog:class+init TestDeadlock Arena\n+ * @run main\/othervm\/timeout=60 --enable-native-access=ALL-UNNAMED -Xlog:class+init TestDeadlock Arena\n","filename":"test\/jdk\/java\/foreign\/TestDeadlock.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @run testng TestMismatch\n+ * @run testng\/timeout=480 TestMismatch\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run testng\/othervm -Xmx6G TestStringEncodingJumbo\n+ * @run testng\/othervm\/timeout=480 -Xmx6G TestStringEncodingJumbo\n","filename":"test\/jdk\/java\/foreign\/TestStringEncodingJumbo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng\/othervm\/native\n+ * @run testng\/othervm\/native\/timeout=480\n","filename":"test\/jdk\/java\/foreign\/TestStubAllocFailure.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run testng\/othervm\/native -Xcheck:jni -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n+ * @run testng\/othervm\/native\/timeout=480 -Xcheck:jni -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run main\/othervm\/native --enable-native-access=ALL-UNNAMED TestLoaderLookup\n+ * @run main\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED TestLoaderLookup\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/TestLoaderLookup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main\/othervm UnreferencedFISClosesFd\n+ * @run main\/othervm\/timeout=480 UnreferencedFISClosesFd\n","filename":"test\/jdk\/java\/io\/FileInputStream\/UnreferencedFISClosesFd.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @run main\/othervm UnreferencedFOSClosesFd\n+ * @run main\/othervm\/timeout=480 UnreferencedFOSClosesFd\n","filename":"test\/jdk\/java\/io\/FileOutputStream\/UnreferencedFOSClosesFd.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n- * @run main\/othervm UnreferencedRAFClosesFd\n+ * @run main\/othervm\/timeout=480 UnreferencedRAFClosesFd\n","filename":"test\/jdk\/java\/io\/RandomAccessFile\/UnreferencedRAFClosesFd.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n- * @run main\/othervm --add-modules=ALL-SYSTEM FieldSetAccessibleTest\n+ * @run main\/othervm\/timeout=480 --add-modules=ALL-SYSTEM FieldSetAccessibleTest\n","filename":"test\/jdk\/java\/lang\/Class\/getDeclaredField\/FieldSetAccessibleTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8365203\n+ * @summary Tests guarding of ByteBuffers in ClassLoader::defineClass\n+ * @run junit TestGuardByteBuffer\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.foreign.Arena;\n+import java.util.HexFormat;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class TestGuardByteBuffer {\n+\n+    @Test\n+    void guardCrash() {\n+        final byte[] classBytes = getClassBytes(); \/\/ get bytes of a valid class\n+        final var cl = new ClassLoader() {\n+            void tryCrash() {\n+                var arena = Arena.ofConfined();\n+                var byteBuffer = arena.allocate(classBytes.length).asByteBuffer();\n+                \/\/ Close the arena underneath\n+                arena.close();\n+                \/\/ expected to always fail because the arena\n+                \/\/ from which the ByteBuffer was constructed\n+                \/\/ has been closed\n+                assertThrows(IllegalStateException.class,\n+                        () -> defineClass(null, byteBuffer, null));\n+            }\n+        };\n+        for (int i = 0; i < 10_000; i++) {\n+            cl.tryCrash();\n+        }\n+    }\n+\n+    private static byte[] getClassBytes() {\n+        \/\/ unused. this is here just for reference\n+        final String source = \"\"\"\n+                    public class NoOp {}\n+                \"\"\";\n+        \/\/ (externally) compiled content of the above \"source\", represented as hex\n+        final String classBytesHex = \"\"\"\n+                cafebabe00000044000d0a000200030700040c000500060100106a6176612f\n+                6c616e672f4f626a6563740100063c696e69743e0100032829560700080100\n+                044e6f4f70010004436f646501000f4c696e654e756d6265725461626c6501\n+                000a536f7572636546696c650100094e6f4f702e6a61766100210007000200\n+                0000000001000100050006000100090000001d00010001000000052ab70001\n+                b100000001000a000000060001000000010001000b00000002000c\n+                \"\"\";\n+\n+        return HexFormat.of().parseHex(classBytesHex.replaceAll(\"\\n\", \"\"));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/defineClass\/TestGuardByteBuffer.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n- * @run junit IntegralPowTest\n+ * @run junit\/timeout=480 IntegralPowTest\n","filename":"test\/jdk\/java\/lang\/Math\/IntegralPowTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+#include <errno.h>\n@@ -25,0 +26,3 @@\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys\/resource.h>\n@@ -27,0 +31,2 @@\n+static jint limit_num_fds();\n+\n@@ -29,0 +35,7 @@\n+  \/\/ Lower the number of possible open files to make the test go faster\n+  jint ret = limit_num_fds();\n+  if (ret != 0) {\n+    fprintf(stderr, \"Failed to limit number of fds: %s\", strerror(errno));\n+    return ret;\n+  }\n+\n@@ -32,0 +45,1 @@\n+    fprintf(stderr, \"Failed to open file: %s\", strerror(errno));\n@@ -34,0 +48,1 @@\n+\n@@ -37,0 +52,24 @@\n+\n+static jint limit_num_fds() {\n+  struct rlimit rl;\n+\n+  \/\/ Fetch the current limit\n+  int ret = getrlimit(RLIMIT_NOFILE, &rl);\n+  if (ret != 0) {\n+    return JNI_ERR;\n+  }\n+\n+  \/\/ Use a lower value unless it is already low\n+  rlim_t limit = 100;\n+  if (limit < rl.rlim_cur) {\n+    rl.rlim_cur = limit;\n+  }\n+\n+  \/\/ Lower the value\n+  int ret2 = setrlimit(RLIMIT_NOFILE, &rl);\n+  if (ret2 != 0) {\n+    return JNI_ERR;\n+  }\n+\n+  return JNI_OK;\n+}\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/FDLeakTest\/libFDLeaker.c","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,2 @@\n- * @run main\/othervm -Djdk.lang.Process.launchMechanism=POSIX_SPAWN UnblockSignals\n- * @run main\/othervm -Djdk.lang.Process.launchMechanism=POSIX_SPAWN -Xrs UnblockSignals\n+ * @run main\/othervm\/timeout=480 -Djdk.lang.Process.launchMechanism=POSIX_SPAWN UnblockSignals\n+ * @run main\/othervm\/timeout=480 -Djdk.lang.Process.launchMechanism=POSIX_SPAWN -Xrs UnblockSignals\n@@ -44,2 +44,2 @@\n- * @run main\/othervm -Djdk.lang.Process.launchMechanism=FORK UnblockSignals\n- * @run main\/othervm -Djdk.lang.Process.launchMechanism=FORK -Xrs UnblockSignals\n+ * @run main\/othervm\/timeout=480 -Djdk.lang.Process.launchMechanism=FORK UnblockSignals\n+ * @run main\/othervm\/timeout=480 -Djdk.lang.Process.launchMechanism=FORK -Xrs UnblockSignals\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/UnblockSignals.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run testng\/othervm -Xint -DtestUnused=true LocalsAndOperands\n- * @run testng\/othervm -Xcomp LocalsAndOperands\n+ * @run testng\/othervm\/timeout=480 -Xint -DtestUnused=true LocalsAndOperands\n+ * @run testng\/othervm\/timeout=480 -Xcomp LocalsAndOperands\n@@ -38,1 +38,1 @@\n- * @run testng\/othervm -Xcomp -XX:-TieredCompilation LocalsAndOperands\n+ * @run testng\/othervm\/timeout=480 -Xcomp -XX:-TieredCompilation LocalsAndOperands\n","filename":"test\/jdk\/java\/lang\/StackWalker\/LocalsAndOperands.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,3 +35,3 @@\n- * @run junit\/othervm -XX:+CompactStrings -Xmx8g MaxSizeUTF16String\n- * @run junit\/othervm -XX:-CompactStrings -Xmx8g MaxSizeUTF16String\n- * @run junit\/othervm -Xcomp -Xmx8g MaxSizeUTF16String\n+ * @run junit\/othervm\/timeout=480 -XX:+CompactStrings -Xmx8g MaxSizeUTF16String\n+ * @run junit\/othervm\/timeout=480 -XX:-CompactStrings -Xmx8g MaxSizeUTF16String\n+ * @run junit\/othervm\/timeout=480 -Xcomp -Xmx8g MaxSizeUTF16String\n","filename":"test\/jdk\/java\/lang\/String\/CompactString\/MaxSizeUTF16String.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,3 +36,3 @@\n- * @run testng\/othervm -XX:+CompactStrings CompactStringBuilder\n- * @run testng\/othervm -XX:-CompactStrings CompactStringBuilder\n- * @run testng\/othervm -Xcomp CompactStringBuilder\n+ * @run testng\/othervm\/timeout=480 -XX:+CompactStrings CompactStringBuilder\n+ * @run testng\/othervm\/timeout=480 -XX:-CompactStrings CompactStringBuilder\n+ * @run testng\/othervm\/timeout=480 -Xcomp CompactStringBuilder\n","filename":"test\/jdk\/java\/lang\/StringBuilder\/CompactStringBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/CancelTimerWithContention.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run junit\/othervm MiscMonitorTests\n+ * @run junit\/othervm\/timeout=480 MiscMonitorTests\n@@ -38,1 +38,1 @@\n- * @run junit\/othervm -Xint MiscMonitorTests\n+ * @run junit\/othervm\/timeout=480 -Xint MiscMonitorTests\n@@ -46,1 +46,1 @@\n- * @run junit\/othervm -Xcomp MiscMonitorTests\n+ * @run junit\/othervm\/timeout=480 -Xcomp MiscMonitorTests\n@@ -54,1 +54,1 @@\n- * @run junit\/othervm -Xcomp -XX:TieredStopAtLevel=3 MiscMonitorTests\n+ * @run junit\/othervm\/timeout=480 -Xcomp -XX:TieredStopAtLevel=3 MiscMonitorTests\n@@ -63,1 +63,1 @@\n- * @run junit\/othervm -Xcomp -XX:-TieredCompilation MiscMonitorTests\n+ * @run junit\/othervm\/timeout=480 -Xcomp -XX:-TieredCompilation MiscMonitorTests\n@@ -71,1 +71,1 @@\n- * @run junit\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+FullGCALot -XX:FullGCALotInterval=1000 MiscMonitorTests\n+ * @run junit\/othervm\/timeout=480 -XX:+UnlockDiagnosticVMOptions -XX:+FullGCALot -XX:FullGCALotInterval=1000 MiscMonitorTests\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MiscMonitorTests.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run junit\/othervm\/native --enable-native-access=ALL-UNNAMED MonitorEnterExit\n+ * @run junit\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED MonitorEnterExit\n@@ -36,1 +36,1 @@\n- * @run junit\/othervm\/native -Xint --enable-native-access=ALL-UNNAMED MonitorEnterExit\n+ * @run junit\/othervm\/native\/timeout=480 -Xint --enable-native-access=ALL-UNNAMED MonitorEnterExit\n@@ -43,1 +43,1 @@\n- * @run junit\/othervm\/native -Xcomp --enable-native-access=ALL-UNNAMED MonitorEnterExit\n+ * @run junit\/othervm\/native\/timeout=480 -Xcomp --enable-native-access=ALL-UNNAMED MonitorEnterExit\n@@ -50,1 +50,1 @@\n- * @run junit\/othervm\/native -Xcomp -XX:TieredStopAtLevel=1 --enable-native-access=ALL-UNNAMED MonitorEnterExit\n+ * @run junit\/othervm\/native\/timeout=480 -Xcomp -XX:TieredStopAtLevel=1 --enable-native-access=ALL-UNNAMED MonitorEnterExit\n@@ -57,1 +57,1 @@\n- * @run junit\/othervm\/native -Xcomp -XX:-TieredCompilation --enable-native-access=ALL-UNNAMED MonitorEnterExit\n+ * @run junit\/othervm\/native\/timeout=480 -Xcomp -XX:-TieredCompilation --enable-native-access=ALL-UNNAMED MonitorEnterExit\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorEnterExit.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run junit\/othervm\/native --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n+ * @run junit\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n@@ -36,1 +36,1 @@\n- * @run junit\/othervm\/native -Xint --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n+ * @run junit\/othervm\/native\/timeout=480 -Xint --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n@@ -43,1 +43,1 @@\n- * @run junit\/othervm\/native -Xcomp --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n+ * @run junit\/othervm\/native\/timeout=480 -Xcomp --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n@@ -50,1 +50,1 @@\n- * @run junit\/othervm\/native -Xcomp -XX:TieredStopAtLevel=1 --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n+ * @run junit\/othervm\/native\/timeout=480 -Xcomp -XX:TieredStopAtLevel=1 --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n@@ -57,1 +57,1 @@\n- * @run junit\/othervm\/native -Xcomp -XX:-TieredCompilation --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n+ * @run junit\/othervm\/native\/timeout=480 -Xcomp -XX:-TieredCompilation --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorWaitNotify.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run junit Parking\n+ * @run junit\/timeout=480 Parking\n@@ -36,1 +36,1 @@\n- * @run junit\/othervm -Xint Parking\n+ * @run junit\/othervm\/timeout=480 -Xint Parking\n@@ -43,1 +43,1 @@\n- * @run junit\/othervm -Xcomp Parking\n+ * @run junit\/othervm\/timeout=480 -Xcomp Parking\n@@ -50,1 +50,1 @@\n- * @run junit\/othervm -Xcomp -XX:-TieredCompilation Parking\n+ * @run junit\/othervm\/timeout=480 -Xcomp -XX:-TieredCompilation Parking\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/Parking.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @run main\/othervm\/native --enable-native-access=ALL-UNNAMED RetryMonitorEnterWhenPinned\n+ * @run main\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED RetryMonitorEnterWhenPinned\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/RetryMonitorEnterWhenPinned.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run main\/othervm\/timeout=200\/native --enable-native-access=ALL-UNNAMED Starvation 100000\n+ * @run main\/othervm\/timeout=800\/native --enable-native-access=ALL-UNNAMED Starvation 100000\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/Starvation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run junit\/othervm\/native --enable-native-access=ALL-UNNAMED SynchronizedNative\n+ * @run junit\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED SynchronizedNative\n@@ -39,1 +39,1 @@\n- * @run junit\/othervm\/native -Xint --enable-native-access=ALL-UNNAMED SynchronizedNative\n+ * @run junit\/othervm\/native\/timeout=480 -Xint --enable-native-access=ALL-UNNAMED SynchronizedNative\n@@ -47,1 +47,1 @@\n- * @run junit\/othervm\/native -Xcomp -XX:TieredStopAtLevel=1 --enable-native-access=ALL-UNNAMED SynchronizedNative\n+ * @run junit\/othervm\/native\/timeout=480 -Xcomp -XX:TieredStopAtLevel=1 --enable-native-access=ALL-UNNAMED SynchronizedNative\n@@ -55,1 +55,1 @@\n- * @run junit\/othervm\/native -Xcomp -XX:-TieredCompilation --enable-native-access=ALL-UNNAMED SynchronizedNative\n+ * @run junit\/othervm\/native\/timeout=480 -Xcomp -XX:-TieredCompilation --enable-native-access=ALL-UNNAMED SynchronizedNative\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/SynchronizedNative.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run junit\/othervm\/native --enable-native-access=ALL-UNNAMED ThreadPollOnYield\n+ * @run junit\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED ThreadPollOnYield\n@@ -39,1 +39,1 @@\n- * @run junit\/othervm\/native --enable-native-access=ALL-UNNAMED -Xcomp -XX:-TieredCompilation\n+ * @run junit\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED -Xcomp -XX:-TieredCompilation\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadPollOnYield.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run main\/othervm\/timeout=300 GetStackTraceALotWhenBlocking 100000\n+ * @run main\/othervm\/timeout=1200 GetStackTraceALotWhenBlocking 100000\n@@ -39,1 +39,1 @@\n- * @run main\/othervm\/timeout=300 GetStackTraceALotWhenBlocking 50000\n+ * @run main\/othervm\/timeout=1200 GetStackTraceALotWhenBlocking 50000\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/GetStackTraceALotWhenBlocking.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main GetStackTraceALotWithTimedWait 100000\n+ * @run main\/timeout=480 GetStackTraceALotWithTimedWait 100000\n@@ -34,1 +34,1 @@\n- * @run main GetStackTraceALotWithTimedWait 50000\n+ * @run main\/timeout=480 GetStackTraceALotWithTimedWait 50000\n@@ -91,1 +91,0 @@\n-\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/GetStackTraceALotWithTimedWait.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main\/othervm\/timeout=300 ParkALot 300000\n+ * @run main\/othervm\/timeout=1200 ParkALot 300000\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\/timeout=300 ParkALot 100000\n+ * @run main\/othervm\/timeout=1200 ParkALot 100000\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/ParkALot.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main\/othervm\/native --enable-native-access=ALL-UNNAMED PinALot 500000\n+ * @run main\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED PinALot 500000\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\/native\/timeout=300 --enable-native-access=ALL-UNNAMED PinALot 200000\n+ * @run main\/othervm\/native\/timeout=1200 --enable-native-access=ALL-UNNAMED PinALot 200000\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/PinALot.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main\/othervm\/timeout=400 -Xmx1500m Skynet\n+ * @run main\/othervm\/timeout=1600 -Xmx1500m Skynet\n@@ -35,1 +35,1 @@\n- * @run main\/othervm\/timeout=400 -XX:+UnlockDiagnosticVMOptions\n+ * @run main\/othervm\/timeout=1600 -XX:+UnlockDiagnosticVMOptions\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/Skynet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/othervm\/timeout=300 Skynet100kWithMonitors 50\n+ * @run main\/othervm\/timeout=1200 Skynet100kWithMonitors 50\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\/timeout=300 Skynet100kWithMonitors 10\n+ * @run main\/othervm\/timeout=1200 Skynet100kWithMonitors 10\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/Skynet100kWithMonitors.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main SleepALot 500000\n+ * @run main\/timeout=480 SleepALot 500000\n@@ -34,1 +34,1 @@\n- * @run main\/othervm\/timeout=300 SleepALot 200000\n+ * @run main\/othervm\/timeout=1200 SleepALot 200000\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/SleepALot.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng LoaderLeakTest\n+ * @run testng\/timeout=480 LoaderLeakTest\n","filename":"test\/jdk\/java\/lang\/annotation\/LoaderLeakTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @run testng ConvertTest\n- *\/\n-\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import java.lang.invoke.ConstantBootstraps;\n-import java.math.BigInteger;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-public class ConvertTest {\n-\n-    @DataProvider\n-    public static Object[][] cceInputs() {\n-        return new Object[][]{\n-            { void.class, null },\n-            { Integer.class, \"a\" },\n-            { int.class, BigInteger.ZERO },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"cceInputs\", expectedExceptions = ClassCastException.class)\n-    public void testBadConversion(Class<?> dstType, Object value) {\n-        ConstantBootstraps.explicitCast(null, null, dstType, value);\n-    }\n-\n-    @DataProvider\n-    public static Object[][] goodInputs() {\n-        Object o = new Object();\n-        return new Object[][]{\n-            { Object.class, null, null },\n-            { Object.class, o, o },\n-            { String.class, \"abc\", \"abc\" },\n-            { short.class, 10, (short) 10 },\n-            { int.class, (short) 10, 10 },\n-            { boolean.class, 1, true },\n-            { boolean.class, 2, false },\n-            { int.class, true, 1 },\n-            { int.class, false, 0 },\n-            { int.class, 10, 10 },\n-            { Integer.class, 10, 10 },\n-            { Object.class, 10, 10 },\n-            { Number.class, 10, 10 },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"goodInputs\")\n-    public void testSuccess(Class<?> dstType, Object value, Object expected) {\n-        Object actual = ConstantBootstraps.explicitCast(null, null, dstType, value);\n-        assertEquals(actual, expected);\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/lang\/constant\/ConvertTest.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+ * @bug 8366028\n@@ -38,0 +39,2 @@\n+\n+import static org.testng.Assert.assertThrows;\n@@ -221,0 +224,18 @@\n+    @DataProvider(name = \"badMethodDescriptorStrings\")\n+    public String[] badMethodDescriptorStrings() {\n+        return new String[] {\n+                \"(I)\",\n+                \"(V)V\",\n+                \"([V)V\",\n+                \"(\" + \"[\".repeat(256) + \"J)I\",\n+                \"(java\/lang\/Object)V\",\n+                \"()java\/lang\/Object\",\n+        };\n+    }\n+\n+    \/\/ JDK-8366028\n+    @Test(dataProvider = \"badMethodDescriptorStrings\", expectedExceptions = IllegalArgumentException.class)\n+    public void testFromMethodDescriptorStringNegatives(String desc) {\n+        MethodType.fromMethodDescriptorString(desc, null);\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodTypeTest.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,2 @@\n-  * @run main TestLambdaFormCustomization\n-  * @run main\/othervm -Djava.lang.invoke.MethodHandle.CUSTOMIZE_THRESHOLD=0 TestLambdaFormCustomization\n+  * @run main\/timeout=480 TestLambdaFormCustomization\n+  * @run main\/othervm\/timeout=480 -Djava.lang.invoke.MethodHandle.CUSTOMIZE_THRESHOLD=0 TestLambdaFormCustomization\n","filename":"test\/jdk\/java\/lang\/invoke\/TestLambdaFormCustomization.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8186046 8195694\n+ * @bug 8186046 8195694 8241100 8364751\n@@ -34,0 +34,1 @@\n+import org.testng.annotations.DataProvider;\n@@ -244,0 +245,41 @@\n+\n+    @DataProvider\n+    public static Object[][] cceCasts() {\n+        return new Object[][]{\n+                { void.class, null },\n+                { Integer.class, \"a\" },\n+                { int.class, BigInteger.ZERO },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"cceCasts\", expectedExceptions = ClassCastException.class)\n+    public void testBadCasts(Class<?> dstType, Object value) {\n+        ConstantBootstraps.explicitCast(null, null, dstType, value);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] validCasts() {\n+        Object o = new Object();\n+        return new Object[][]{\n+                { Object.class, null, null },\n+                { Object.class, o, o },\n+                { String.class, \"abc\", \"abc\" },\n+                { short.class, 10, (short) 10 },\n+                { int.class, (short) 10, 10 },\n+                { boolean.class, 1, true },\n+                { boolean.class, 2, false },\n+                { int.class, true, 1 },\n+                { int.class, false, 0 },\n+                { int.class, 10, 10 },\n+                { Integer.class, 10, 10 },\n+                { Object.class, 10, 10 },\n+                { Number.class, 10, 10 },\n+                { char.class, null, (char) 0 }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"validCasts\")\n+    public void testSuccessfulCasts(Class<?> dstType, Object value, Object expected) {\n+        Object actual = ConstantBootstraps.explicitCast(null, null, dstType, value);\n+        assertEquals(actual, expected);\n+    }\n","filename":"test\/jdk\/java\/lang\/invoke\/condy\/ConstantBootstrapsTest.java","additions":44,"deletions":2,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng\/othervm\/timeout=180 IllegalArgumentsTest\n+ * @run testng\/othervm\/timeout=720 IllegalArgumentsTest\n","filename":"test\/jdk\/java\/lang\/reflect\/IllegalArgumentsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng\/othervm -Xmx4g LargeValueExceptions\n+ * @run testng\/othervm\/timeout=480 -Xmx4g LargeValueExceptions\n","filename":"test\/jdk\/java\/math\/BigInteger\/LargeValueExceptions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run main\/othervm UnreferencedDatagramSockets\n- * @run main\/othervm -Djava.net.preferIPv4Stack=true UnreferencedDatagramSockets\n+ * @run main\/othervm\/timeout=480 UnreferencedDatagramSockets\n+ * @run main\/othervm\/timeout=480 -Djava.net.preferIPv4Stack=true UnreferencedDatagramSockets\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/UnreferencedDatagramSockets.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,2 +45,0 @@\n-\n-\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/SetLoopbackModeIPv4.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run main\/othervm -Djava.net.preferIPv4Stack=true UnreferencedMulticastSockets\n- * @run main\/othervm UnreferencedMulticastSockets\n+ * @run main\/othervm\/timeout=480 -Djava.net.preferIPv4Stack=true UnreferencedMulticastSockets\n+ * @run main\/othervm\/timeout=480 UnreferencedMulticastSockets\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/UnreferencedMulticastSockets.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n- * @run main\/othervm UnreferencedSockets\n- * @run main\/othervm -Djava.net.preferIPv4Stack=true UnreferencedSockets\n+ * @run main\/othervm\/timeout=480 UnreferencedSockets\n+ * @run main\/othervm\/timeout=480 -Djava.net.preferIPv4Stack=true UnreferencedSockets\n","filename":"test\/jdk\/java\/net\/ServerSocket\/UnreferencedSockets.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run main CloseAvailable\n- * @run main\/othervm -Djava.net.preferIPv4Stack=true CloseAvailable\n+ * @run main\/timeout=480 CloseAvailable\n+ * @run main\/othervm\/timeout=480 -Djava.net.preferIPv4Stack=true CloseAvailable\n","filename":"test\/jdk\/java\/net\/Socket\/CloseAvailable.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n- * @run testng\/othervm AsFileDownloadTest\n+ * @run testng\/othervm\/timeout=480 AsFileDownloadTest\n","filename":"test\/jdk\/java\/net\/httpclient\/AsFileDownloadTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n- * @run testng\/othervm -Djdk.internal.httpclient.debug=true BufferingSubscriberTest\n+ * @run testng\/othervm\/timeout=480 -Djdk.internal.httpclient.debug=true BufferingSubscriberTest\n","filename":"test\/jdk\/java\/net\/httpclient\/BufferingSubscriberTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,2 +62,2 @@\n- * @run main\/othervm  CancelledResponse\n- * @run main\/othervm  CancelledResponse SSL\n+ * @run main\/othervm\/timeout=480 CancelledResponse\n+ * @run main\/othervm\/timeout=480 CancelledResponse SSL\n","filename":"test\/jdk\/java\/net\/httpclient\/CancelledResponse.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,708 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Verifies `HttpRequest.BodyPublishers::ofFileChannel`\n+ * @library \/test\/lib\n+ *          \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.common.HttpServerAdapters\n+ *        jdk.test.lib.net.SimpleSSLContext\n+ * @run junit FileChannelPublisherTest\n+ *\/\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestHandler;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import jdk.internal.net.http.common.Logger;\n+import jdk.internal.net.http.common.Utils;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Version;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpResponse.BodyHandlers.discarding;\n+import static java.net.http.HttpResponse.BodyHandlers.ofInputStream;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertInstanceOf;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class FileChannelPublisherTest {\n+\n+    private static final String CLASS_NAME = FileChannelPublisherTest.class.getSimpleName();\n+\n+    private static final Logger LOGGER = Utils.getDebugLogger(CLASS_NAME::toString, Utils.DEBUG);\n+\n+    private static final int DEFAULT_BUFFER_SIZE = Utils.getBuffer().capacity();\n+\n+    private static final SSLContext SSL_CONTEXT = createSslContext();\n+\n+    private static final HttpClient CLIENT = HttpClient.newBuilder().sslContext(SSL_CONTEXT).proxy(NO_PROXY).build();\n+\n+    private static final ExecutorService EXECUTOR = Executors.newCachedThreadPool();\n+\n+    private static final ServerRequestPair\n+            HTTP1 = ServerRequestPair.of(Version.HTTP_1_1, false),\n+            HTTPS1 = ServerRequestPair.of(Version.HTTP_1_1, true),\n+            HTTP2 = ServerRequestPair.of(Version.HTTP_2, false),\n+            HTTPS2 = ServerRequestPair.of(Version.HTTP_2, true);\n+\n+    private static SSLContext createSslContext() {\n+        try {\n+            return new SimpleSSLContext().get();\n+        } catch (IOException exception) {\n+            throw new UncheckedIOException(exception);\n+        }\n+    }\n+\n+    private record ServerRequestPair(\n+            String serverName,\n+            HttpTestServer server,\n+            BlockingQueue<byte[]> serverReadRequestBodyBytes,\n+            HttpRequest.Builder requestBuilder,\n+            boolean secure) {\n+\n+        private static CountDownLatch SERVER_REQUEST_RECEIVED_SIGNAL = null;\n+\n+        private static CountDownLatch SERVER_READ_PERMISSION = null;\n+\n+        private static ServerRequestPair of(Version version, boolean secure) {\n+\n+            \/\/ Create the server\n+            SSLContext sslContext = secure ? SSL_CONTEXT : null;\n+            HttpTestServer server = createServer(version, sslContext);\n+            String serverName = secure ? version.toString().replaceFirst(\"_\", \"S_\") : version.toString();\n+\n+            \/\/ Add the handler\n+            String handlerPath = \"\/%s\/\".formatted(CLASS_NAME);\n+            BlockingQueue<byte[]> serverReadRequestBodyBytes =\n+                    addRequestBodyConsumingServerHandler(serverName, server, handlerPath);\n+\n+            \/\/ Create the request builder\n+            String requestUriScheme = secure ? \"https\" : \"http\";\n+            \/\/ `x` suffix in the URI is not a typo, but ensures that *only* the parent handler path is matched\n+            URI requestUri = URI.create(\"%s:\/\/%s%sx\".formatted(requestUriScheme, server.serverAuthority(), handlerPath));\n+            HttpRequest.Builder requestBuilder = HttpRequest.newBuilder(requestUri).version(version);\n+\n+            \/\/ Create the pair\n+            ServerRequestPair pair = new ServerRequestPair(serverName, server, serverReadRequestBodyBytes, requestBuilder, secure);\n+            pair.server.start();\n+            LOGGER.log(\"Server[%s] is started at `%s`\", pair, server.serverAuthority());\n+\n+            return pair;\n+\n+        }\n+\n+        private static HttpTestServer createServer(Version version, SSLContext sslContext) {\n+            try {\n+                \/\/ The default HTTP\/1.1 test server processes requests sequentially.\n+                \/\/ This causes a deadlock for concurrent tests such as `testSlicedUpload()`.\n+                \/\/ Hence, explicitly providing a multithreaded executor for HTTP\/1.1.\n+                ExecutorService executor = Version.HTTP_1_1.equals(version) ? EXECUTOR : null;\n+                return HttpTestServer.create(version, sslContext, executor);\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        private static BlockingQueue<byte[]> addRequestBodyConsumingServerHandler(\n+                String serverName, HttpTestServer server, String handlerPath) {\n+            BlockingQueue<byte[]> readRequestBodyBytes = new LinkedBlockingQueue<>();\n+            HttpTestHandler handler = exchange -> {\n+                \/\/ `HttpTestExchange::toString` changes on failure, pin it\n+                String exchangeName = exchange.toString();\n+                try (exchange) {\n+\n+                    \/\/ Discard `HEAD` requests used for initial connection admission\n+                    if (\"HEAD\".equals(exchange.getRequestMethod())) {\n+                        exchange.sendResponseHeaders(200, -1L);\n+                        return;\n+                    }\n+\n+                    signalServerRequestReceived(serverName, exchangeName);\n+                    awaitServerReadPermission(serverName, exchangeName);\n+\n+                    LOGGER.log(\"Server[%s] is reading the request body (exchange=%s)\", serverName, exchangeName);\n+                    byte[] requestBodyBytes = exchange.getRequestBody().readAllBytes();\n+                    LOGGER.log(\"Server[%s] has read %s bytes (exchange=%s)\", serverName, requestBodyBytes.length, exchangeName);\n+                    readRequestBodyBytes.add(requestBodyBytes);\n+\n+                    LOGGER.log(\"Server[%s] is writing the response (exchange=%s)\", serverName, exchangeName);\n+                    exchange.sendResponseHeaders(200, requestBodyBytes.length);\n+                    exchange.getResponseBody().write(requestBodyBytes);\n+\n+                } catch (Throwable exception) {\n+                    LOGGER.log(\n+                            \"Server[%s] failed to process the request (exchange=%s)\".formatted(serverName, exception),\n+                            exception);\n+                    readRequestBodyBytes.add(new byte[0]);\n+                } finally {\n+                    LOGGER.log(\"Server[%s] completed processing the request (exchange=%s)\", serverName, exchangeName);\n+                }\n+            };\n+            server.addHandler(handler, handlerPath);\n+            return readRequestBodyBytes;\n+        }\n+\n+        private static void signalServerRequestReceived(String serverName, String exchangeName) {\n+            if (SERVER_REQUEST_RECEIVED_SIGNAL != null) {\n+                LOGGER.log(\"Server[%s] is signaling that the request is received (exchange=%s)\", serverName, exchangeName);\n+                SERVER_REQUEST_RECEIVED_SIGNAL.countDown();\n+            }\n+        }\n+\n+        private static void awaitServerReadPermission(String serverName, String exchangeName) {\n+            if (SERVER_READ_PERMISSION != null) {\n+                LOGGER.log(\"Server[%s] is waiting for the read permission (exchange=%s)\", serverName, exchangeName);\n+                try {\n+                    SERVER_READ_PERMISSION.await();\n+                } catch (InterruptedException ie) {\n+                    Thread.currentThread().interrupt();     \/\/ Restore the `interrupted` flag\n+                    throw new RuntimeException(ie);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return serverName;\n+        }\n+\n+    }\n+\n+    @AfterAll\n+    static void shutDown() {\n+        LOGGER.log(\"Closing the client\");\n+        CLIENT.close();\n+        LOGGER.log(\"Closing servers\");\n+        closeServers();\n+        LOGGER.log(\"Closing the executor\");\n+        EXECUTOR.shutdownNow();\n+    }\n+\n+    private static void closeServers() {\n+        Exception[] exceptionRef = {null};\n+        Stream\n+                .of(HTTP1, HTTPS1, HTTP2, HTTPS2)\n+                .map(pair -> (Runnable) pair.server::stop)\n+                .forEach(terminator -> {\n+                    try {\n+                        terminator.run();\n+                    } catch (Exception exception) {\n+                        if (exceptionRef[0] == null) {\n+                            exceptionRef[0] = exception;\n+                        } else {\n+                            exceptionRef[0].addSuppressed(exception);\n+                        }\n+                    }\n+                });\n+        if (exceptionRef[0] != null) {\n+            throw new RuntimeException(\"failed closing one or more server resources\", exceptionRef[0]);\n+        }\n+    }\n+\n+    \/**\n+     * Resets {@link ServerRequestPair#serverReadRequestBodyBytes()} to avoid leftover state from a test leaking to the next.\n+     *\/\n+    @BeforeEach\n+    void resetServerHandlerResults() {\n+        Stream\n+                .of(HTTP1, HTTPS1, HTTP2, HTTPS2)\n+                .forEach(pair -> pair.serverReadRequestBodyBytes.clear());\n+    }\n+\n+    static ServerRequestPair[] serverRequestPairs() {\n+        return new ServerRequestPair[]{\n+                HTTP1,\n+                HTTPS1,\n+                HTTP2,\n+                HTTPS2\n+        };\n+    }\n+\n+    @Test\n+    void testNullFileChannel() {\n+        assertThrows(NullPointerException.class, () -> BodyPublishers.ofFileChannel(null, 0, 1));\n+    }\n+\n+    @ParameterizedTest\n+    @CsvSource({\n+            \"6,-1,1\",   \/\/ offset < 0\n+            \"6,7,1\",    \/\/ offset > fileSize\n+            \"6,0,-1\",   \/\/ length < 0\n+            \"6,0,7\",    \/\/ length > fileSize\n+            \"6,2,5\"     \/\/ (offset + length) > fileSize\n+    })\n+    void testIllegalOffsetOrLength(\n+            int fileLength,\n+            int fileChannelOffset,\n+            int fileChannelLength,\n+            @TempDir Path tempDir) throws Exception {\n+        withFileChannel(tempDir.resolve(\"data.txt\"), fileLength, (_, fileChannel) ->\n+                assertThrows(\n+                        IndexOutOfBoundsException.class,\n+                        () -> BodyPublishers.ofFileChannel(fileChannel, fileChannelOffset, fileChannelLength)));\n+    }\n+\n+    \/**\n+     * Stresses corner cases in {@linkplain\n+     * BodyPublishers#ofFileChannel(FileChannel, long, long) the file channel\n+     * publisher}, which uses a {@linkplain #DEFAULT_BUFFER_SIZE fixed size}\n+     * buffer to read files, by providing sub-ranges and files that are\n+     * <em>smaller<\/em> than the buffer size.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testContentLessThanBufferSize(ServerRequestPair pair, @TempDir Path tempDir) throws Exception {\n+\n+        \/\/ Use a file of length smaller than the default buffer size\n+        int fileLength = 6;\n+        assertTrue(fileLength < DEFAULT_BUFFER_SIZE);\n+\n+        \/\/ Publish the `[0, fileLength)` sub-range\n+        testSuccessfulContentDelivery(\n+                \"Complete content\",\n+                pair, tempDir, fileLength, 0, fileLength);\n+\n+        \/\/ Publish the `[1, fileLength)` sub-range to stress the inclusion of EOF\n+        {\n+            int fileChannelOffset = 1;\n+            int fileChannelLength = fileLength - 1;\n+            String debuggingContext = debuggingContext(fileLength, fileChannelOffset, fileChannelLength);\n+            assertEquals(\n+                    fileLength - fileChannelOffset, fileChannelLength,\n+                    \"must be until EOF \" + debuggingContext);\n+            testSuccessfulContentDelivery(\n+                    \"Partial content until the EOF \" + debuggingContext,\n+                    pair, tempDir, fileLength, fileChannelOffset, fileChannelLength);\n+        }\n+\n+        \/\/ Publish the `[1, fileLength - 1)` sub-range to stress the exclusion of EOF\n+        {\n+            int fileChannelOffset = 1;\n+            int fileChannelLength = fileLength - 2;\n+            String debuggingContext = debuggingContext(fileLength, fileChannelOffset, fileChannelLength);\n+            assertTrue(\n+                    fileLength - fileChannelOffset > fileChannelLength,\n+                    \"must end before EOF \" + debuggingContext);\n+            testSuccessfulContentDelivery(\n+                    \"Partial content *before* the EOF \" + debuggingContext,\n+                    pair, tempDir, fileLength, fileChannelOffset, fileChannelLength);\n+        }\n+\n+    }\n+\n+    \/**\n+     * Stresses corner cases in {@linkplain\n+     * BodyPublishers#ofFileChannel(FileChannel, long, long) the file channel\n+     * publisher}, which uses a {@linkplain #DEFAULT_BUFFER_SIZE fixed size}\n+     * buffer to read files, by providing sub-ranges and files that are\n+     * <em>bigger<\/em> than the buffer size.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testContentMoreThanBufferSize(ServerRequestPair pair, @TempDir Path tempDir) throws Exception {\n+\n+        \/\/ Use a file of length that is\n+        \/\/ 1. greater than the default buffer size\n+        \/\/ 2. *not* a multitude of the buffer size\n+        int fileLength = 1 + 3 * DEFAULT_BUFFER_SIZE;\n+\n+        \/\/ Publish the `[0, fileLength)` sub-range\n+        testSuccessfulContentDelivery(\n+                \"Complete content\",\n+                pair, tempDir, fileLength, 0, fileLength);\n+\n+        \/\/ Publish the `[1, fileLength)` sub-range such that\n+        \/\/ - EOF is included\n+        \/\/ - the total length is a multitude of the buffer size\n+        {\n+            int fileChannelOffset = 1;\n+            int fileChannelLength = 3 * DEFAULT_BUFFER_SIZE;\n+            String debuggingContext = debuggingContext(fileLength, fileChannelOffset, fileChannelLength);\n+            assertEquals(\n+                    fileLength - fileChannelOffset, fileChannelLength,\n+                    \"must be until EOF \" + debuggingContext);\n+            testSuccessfulContentDelivery(\n+                    \"Partial content until the EOF. Occupies exactly 3 buffers. \" + debuggingContext,\n+                    pair, tempDir, fileLength, fileChannelOffset, fileChannelLength);\n+        }\n+\n+        \/\/ Publish the `[1, fileLength)` sub-range such that\n+        \/\/ - EOF is included\n+        \/\/ - the total length is *not* a multitude of the buffer size\n+        {\n+            int fileChannelOffset = 2;\n+            int fileChannelLength = 3 * DEFAULT_BUFFER_SIZE - 1;\n+            String debuggingContext = debuggingContext(fileLength, fileChannelOffset, fileChannelLength);\n+            assertEquals(\n+                    fileLength - fileChannelOffset, fileChannelLength,\n+                    \"must be until EOF \" + debuggingContext);\n+            testSuccessfulContentDelivery(\n+                    \"Partial content until the EOF. Occupies 3 buffers, the last is custom sized. \" + debuggingContext,\n+                    pair, tempDir, fileLength, fileChannelOffset, fileChannelLength);\n+        }\n+\n+        \/\/ Publish the `[1, fileLength)` sub-range such that\n+        \/\/ - EOF is *not* included\n+        \/\/ - the total length is a multitude of the buffer size\n+        {\n+            int fileChannelOffset = 2;\n+            int fileChannelLength = 2 * DEFAULT_BUFFER_SIZE;\n+            String debuggingContext = debuggingContext(fileLength, fileChannelOffset, fileChannelLength);\n+            assertTrue(\n+                    fileLength - fileChannelOffset > fileChannelLength,\n+                    \"must end before EOF \" + debuggingContext);\n+            testSuccessfulContentDelivery(\n+                    \"Partial content *before* the EOF. Occupies exactly 2 buffers. \" + debuggingContext,\n+                    pair, tempDir, fileLength, fileChannelOffset, fileChannelLength);\n+        }\n+\n+        \/\/ Publish the `[1, fileLength)` sub-range such that\n+        \/\/ - EOF is *not* included\n+        \/\/ - the total length is *not* a multitude of the buffer size\n+        {\n+            int fileChannelOffset = 2;\n+            int fileChannelLength = 3 * DEFAULT_BUFFER_SIZE - 2;\n+            String debuggingContext = debuggingContext(fileLength, fileChannelOffset, fileChannelLength);\n+            assertTrue(\n+                    fileLength - fileChannelOffset > fileChannelLength,\n+                    \"must end before EOF \" + debuggingContext);\n+            testSuccessfulContentDelivery(\n+                    \"Partial content *before* the EOF. Occupies 3 buffers, the last is custom sized. \"+ debuggingContext,\n+                    pair, tempDir, fileLength, fileChannelOffset, fileChannelLength);\n+        }\n+\n+    }\n+\n+    private static String debuggingContext(int fileLength, int fileChannelOffset, int fileChannelLength) {\n+        Map<String, Object> context = new LinkedHashMap<>();    \/\/ Using `LHM` to preserve the insertion order\n+        context.put(\"DEFAULT_BUFFER_SIZE\", DEFAULT_BUFFER_SIZE);\n+        context.put(\"fileLength\", fileLength);\n+        context.put(\"fileChannelOffset\", fileChannelOffset);\n+        context.put(\"fileChannelLength\", fileChannelLength);\n+        boolean customSizedBuffer = fileChannelLength % DEFAULT_BUFFER_SIZE == 0;\n+        context.put(\"customSizedBuffer\", customSizedBuffer);\n+        return context.toString();\n+    }\n+\n+    private void testSuccessfulContentDelivery(\n+            String caseDescription,\n+            ServerRequestPair pair,\n+            Path tempDir,\n+            int fileLength,\n+            int fileChannelOffset,\n+            int fileChannelLength) throws Exception {\n+\n+        \/\/ Case names come handy even when no debug logging is enabled.\n+        \/\/ Hence, intentionally avoiding `Logger`.\n+        System.err.printf(\"Case: %s%n\", caseDescription);\n+\n+        \/\/ Create the file to upload\n+        String fileName = \"data-%d-%d-%d.txt\".formatted(fileLength, fileChannelOffset, fileChannelLength);\n+        Path filePath = tempDir.resolve(fileName);\n+        withFileChannel(filePath, fileLength, (fileBytes, fileChannel) -> {\n+\n+            \/\/ Upload the file\n+            HttpRequest request = pair\n+                    .requestBuilder\n+                    .POST(BodyPublishers.ofFileChannel(fileChannel, fileChannelOffset, fileChannelLength))\n+                    .build();\n+            CLIENT.send(request, discarding());\n+\n+            \/\/ Verify the received request body\n+            byte[] expectedRequestBodyBytes = new byte[fileChannelLength];\n+            System.arraycopy(fileBytes, fileChannelOffset, expectedRequestBodyBytes, 0, fileChannelLength);\n+            byte[] actualRequestBodyBytes = pair.serverReadRequestBodyBytes.take();\n+            assertArrayEquals(expectedRequestBodyBytes, actualRequestBodyBytes);\n+\n+        });\n+\n+    }\n+\n+    \/**\n+     * <em>Big enough<\/em> file length to observe the effects of publisher state corruption while uploading.\n+     * <p>\n+     * Certain tests follow below steps:\n+     * <\/p>\n+     * <ol>\n+     * <li>Issue the request<\/li>\n+     * <li>Wait for the server's signal that the request (not the body!) is received<\/li>\n+     * <li>Corrupt the publisher's state; modify the file, close the file channel, etc.<\/li>\n+     * <li>Signal the server to proceed with reading<\/li>\n+     * <\/ol>\n+     * <p>\n+     * With small files, even before we permit the server to read (step 4), file gets already uploaded.\n+     * This voids the effect of state corruption (step 3).\n+     * To circumvent this, use this <em>big enough<\/em> file size.\n+     * <\/p>\n+     *\n+     * @see #testChannelCloseDuringPublisherRead(ServerRequestPair, Path)\n+     * @see #testFileModificationDuringPublisherRead(ServerRequestPair, Path)\n+     *\/\n+    private static final int BIG_FILE_LENGTH = 8 * 1024 * 1024;  \/\/ 8 MiB\n+\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testChannelCloseDuringPublisherRead(ServerRequestPair pair, @TempDir Path tempDir) throws Exception {\n+        establishInitialConnection(pair);\n+        ServerRequestPair.SERVER_REQUEST_RECEIVED_SIGNAL = new CountDownLatch(1);\n+        ServerRequestPair.SERVER_READ_PERMISSION = new CountDownLatch(1);\n+        try {\n+\n+            int fileLength = BIG_FILE_LENGTH;\n+            AtomicReference<Future<HttpResponse<Void>>> responseFutureRef = new AtomicReference<>();\n+            withFileChannel(tempDir.resolve(\"data.txt\"), fileLength, ((_, fileChannel) -> {\n+\n+                \/\/ Issue the request\n+                LOGGER.log(\"Issuing the request\");\n+                HttpRequest request = pair\n+                        .requestBuilder\n+                        .POST(BodyPublishers.ofFileChannel(fileChannel, 0, fileLength))\n+                        .build();\n+                responseFutureRef.set(CLIENT.sendAsync(request, discarding()));\n+\n+                \/\/ Wait for server to receive the request\n+                LOGGER.log(\"Waiting for the request to be received\");\n+                ServerRequestPair.SERVER_REQUEST_RECEIVED_SIGNAL.await();\n+\n+            }));\n+\n+            LOGGER.log(\"File channel is closed\");\n+\n+            \/\/ Let the server proceed\n+            LOGGER.log(\"Permitting the server to proceed\");\n+            ServerRequestPair.SERVER_READ_PERMISSION.countDown();\n+\n+            \/\/ Verifying the client failure\n+            LOGGER.log(\"Verifying the client failure\");\n+            Exception requestFailure0 = assertThrows(ExecutionException.class, () -> responseFutureRef.get().get());\n+            Exception requestFailure1 = assertInstanceOf(UncheckedIOException.class, requestFailure0.getCause());\n+            assertInstanceOf(ClosedChannelException.class, requestFailure1.getCause());\n+\n+            verifyServerIncompleteRead(pair, fileLength);\n+\n+        } finally {\n+            ServerRequestPair.SERVER_REQUEST_RECEIVED_SIGNAL = null;\n+            ServerRequestPair.SERVER_READ_PERMISSION = null;\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testFileModificationDuringPublisherRead(ServerRequestPair pair, @TempDir Path tempDir) throws Exception {\n+        establishInitialConnection(pair);\n+        ServerRequestPair.SERVER_REQUEST_RECEIVED_SIGNAL = new CountDownLatch(1);\n+        ServerRequestPair.SERVER_READ_PERMISSION = new CountDownLatch(1);\n+        try {\n+\n+            int fileLength = BIG_FILE_LENGTH;\n+            Path filePath = tempDir.resolve(\"data.txt\");\n+            withFileChannel(filePath, fileLength, ((_, fileChannel) -> {\n+\n+                \/\/ Issue the request\n+                LOGGER.log(\"Issuing the request\");\n+                HttpRequest request = pair\n+                        .requestBuilder\n+                        .POST(BodyPublishers.ofFileChannel(fileChannel, 0, fileLength))\n+                        .build();\n+                Future<HttpResponse<Void>> responseFuture = CLIENT.sendAsync(request, discarding());\n+\n+                \/\/ Wait for server to receive the request\n+                LOGGER.log(\"Waiting for the request to be received\");\n+                ServerRequestPair.SERVER_REQUEST_RECEIVED_SIGNAL.await();\n+\n+                \/\/ Modify the file\n+                LOGGER.log(\"Modifying the file\");\n+                Files.write(filePath, generateFileBytes(1));\n+\n+                \/\/ Let the server proceed\n+                LOGGER.log(\"Permitting the server to proceed\");\n+                ServerRequestPair.SERVER_READ_PERMISSION.countDown();\n+\n+                \/\/ Verifying the client failure\n+                LOGGER.log(\"Verifying the client failure\");\n+                Exception requestFailure0 = assertThrows(ExecutionException.class, responseFuture::get);\n+                Exception requestFailure1 = assertInstanceOf(UncheckedIOException.class, requestFailure0.getCause());\n+                Exception requestFailure2 = assertInstanceOf(IOException.class, requestFailure1.getCause());\n+                String requestFailure2Message = requestFailure2.getMessage();\n+                assertTrue(\n+                        requestFailure2Message.contains(\"Unexpected EOF\"),\n+                        \"unexpected message: \" + requestFailure2Message);\n+\n+                verifyServerIncompleteRead(pair, fileLength);\n+\n+            }));\n+\n+        } finally {\n+            ServerRequestPair.SERVER_REQUEST_RECEIVED_SIGNAL = null;\n+            ServerRequestPair.SERVER_READ_PERMISSION = null;\n+        }\n+    }\n+\n+    private static void verifyServerIncompleteRead(ServerRequestPair pair, int fileLength) throws InterruptedException {\n+        LOGGER.log(\"Verifying the server's incomplete read\");\n+        byte[] readRequestBodyBytes = pair.serverReadRequestBodyBytes.take();\n+        assertTrue(\n+                readRequestBodyBytes.length < fileLength,\n+                \"was expecting `readRequestBodyBytes < fileLength` (%s < %s)\".formatted(\n+                        readRequestBodyBytes.length, fileLength));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testSlicedUpload(ServerRequestPair pair, @TempDir Path tempDir) throws Exception {\n+\n+        \/\/ Populate the file\n+        int sliceCount = 4;\n+        int sliceLength = 14_281; \/\/ Intentionally using a prime number to increase the chances of hitting corner cases\n+        int fileLength = sliceCount * sliceLength;\n+        byte[] fileBytes = generateFileBytes(fileLength);\n+        Path filePath = tempDir.resolve(\"data.txt\");\n+        Files.write(filePath, fileBytes, StandardOpenOption.CREATE);\n+\n+        List<InputStream> responseBodyStreams = new ArrayList<>(sliceCount);\n+        try (FileChannel fileChannel = FileChannel.open(filePath)) {\n+\n+            \/\/ Upload the complete file in mutually exclusive slices\n+            List<Future<HttpResponse<InputStream>>> responseFutures = new ArrayList<>(sliceCount);\n+            for (int sliceIndex = 0; sliceIndex < sliceCount; sliceIndex++) {\n+                LOGGER.log(\"Issuing request %d\/%d\", (sliceIndex + 1), sliceCount);\n+                HttpRequest request = pair\n+                        .requestBuilder\n+                        .POST(BodyPublishers.ofFileChannel(fileChannel, sliceIndex * sliceLength, sliceLength))\n+                        .build();\n+                responseFutures.add(CLIENT.sendAsync(\n+                        request,\n+                        \/\/ Intentionally using an `InputStream` response\n+                        \/\/ handler to defer consuming the response body\n+                        \/\/ until after the file channel is closed:\n+                        ofInputStream()));\n+            }\n+\n+            \/\/ Collect response body `InputStream`s from all requests\n+            for (int sliceIndex = 0; sliceIndex < sliceCount; sliceIndex++) {\n+                LOGGER.log(\"Collecting response body `InputStream` for request %d\/%d\", (sliceIndex + 1), sliceCount);\n+                HttpResponse<InputStream> response = responseFutures.get(sliceIndex).get();\n+                assertEquals(200, response.statusCode());\n+                responseBodyStreams.add(response.body());\n+            }\n+\n+        }\n+\n+        LOGGER.log(\"File channel is closed\");\n+\n+        \/\/ Verify response bodies\n+        for (int sliceIndex = 0; sliceIndex < sliceCount; sliceIndex++) {\n+            LOGGER.log(\"Consuming response body %d\/%d\", (sliceIndex + 1), sliceCount);\n+            byte[] expectedResponseBodyBytes = new byte[sliceLength];\n+            System.arraycopy(fileBytes, sliceIndex * sliceLength, expectedResponseBodyBytes, 0, sliceLength);\n+            try (InputStream responseBodyStream = responseBodyStreams.get(sliceIndex)) {\n+                byte[] responseBodyBytes = responseBodyStream.readAllBytes();\n+                assertArrayEquals(expectedResponseBodyBytes, responseBodyBytes);\n+            }\n+        }\n+\n+    }\n+\n+    \/**\n+     * Performs the initial {@code HEAD} request to the specified server. This\n+     * effectively admits a connection to the client's pool, where all protocol\n+     * upgrades, handshakes, etc. are already performed.\n+     * <p>\n+     * HTTP\/2 test server consumes the complete request payload in the very\n+     * first upgrade frame. That is, if a client sends 100 MiB of data, all\n+     * of it will be consumed first before the configured handler is\n+     * invoked. Though certain tests expect the data to be consumed\n+     * piecemeal. To accommodate this, we ensure client has an upgraded\n+     * connection in the pool.\n+     * <\/p>\n+     *\/\n+    private static void establishInitialConnection(ServerRequestPair pair) {\n+        LOGGER.log(\"Server[%s] is getting queried for the initial connection pool admission\", pair);\n+        try {\n+            CLIENT.send(pair.requestBuilder.HEAD().build(), discarding());\n+        } catch (Exception exception) {\n+            throw new RuntimeException(exception);\n+        }\n+    }\n+\n+    private static void withFileChannel(Path filePath, int fileLength, FileChannelConsumer fileChannelConsumer) throws Exception {\n+        byte[] fileBytes = generateFileBytes(fileLength);\n+        Files.write(filePath, fileBytes, StandardOpenOption.CREATE);\n+        try (FileChannel fileChannel = FileChannel.open(filePath)) {\n+            fileChannelConsumer.consume(fileBytes, fileChannel);\n+        }\n+    }\n+\n+    @FunctionalInterface\n+    private interface FileChannelConsumer {\n+\n+        void consume(byte[] fileBytes, FileChannel fileChannel) throws Exception;\n+\n+    }\n+\n+    private static byte[] generateFileBytes(int length) {\n+        byte[] bytes = new byte[length];\n+        for (int i = 0; i < length; i++) {\n+            bytes[i] = (byte) i;\n+        }\n+        return bytes;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/FileChannelPublisherTest.java","additions":708,"deletions":0,"binary":false,"changes":708,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n- * @run main\/othervm -Dtest.requiresHost=true\n+ * @run main\/othervm\/timeout=480 -Dtest.requiresHost=true\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpSlowServerTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,4 +36,4 @@\n- * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=ssl,channel ManyRequests\n- * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=channel -Dtest.insertDelay=true ManyRequests\n- * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=channel -Dtest.chunkSize=64 ManyRequests\n- * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=channel -Dtest.insertDelay=true -Dtest.chunkSize=64 ManyRequests\n+ * @run main\/othervm\/timeout=160 -Djdk.httpclient.HttpClient.log=ssl,channel ManyRequests\n+ * @run main\/othervm\/timeout=160 -Djdk.httpclient.HttpClient.log=channel -Dtest.insertDelay=true ManyRequests\n+ * @run main\/othervm\/timeout=160 -Djdk.httpclient.HttpClient.log=channel -Dtest.chunkSize=64 ManyRequests\n+ * @run main\/othervm\/timeout=160 -Djdk.httpclient.HttpClient.log=channel -Dtest.insertDelay=true -Dtest.chunkSize=64 ManyRequests\n","filename":"test\/jdk\/java\/net\/httpclient\/ManyRequests.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run testng\/othervm ResponseBodyBeforeError\n+ * @run testng\/othervm\/timeout=480 ResponseBodyBeforeError\n","filename":"test\/jdk\/java\/net\/httpclient\/ResponseBodyBeforeError.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run testng\/othervm ResponsePublisher\n+ * @run testng\/othervm\/timeout=480 ResponsePublisher\n","filename":"test\/jdk\/java\/net\/httpclient\/ResponsePublisher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run testng\/othervm\n+ * @run testng\/othervm\/timeout=480\n@@ -37,1 +37,1 @@\n- * @run testng\/othervm -Djdk.httpclient.allowRestrictedHeaders=Host\n+ * @run testng\/othervm\/timeout=480 -Djdk.httpclient.allowRestrictedHeaders=Host\n","filename":"test\/jdk\/java\/net\/httpclient\/SpecialHeadersTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/net\/httpclient\/SplitResponse.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/net\/httpclient\/SplitResponseAsync.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/net\/httpclient\/SplitResponseKeepAlive.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/net\/httpclient\/SplitResponseKeepAliveAsync.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/net\/httpclient\/SplitResponseSSL.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/net\/httpclient\/SplitResponseSSLAsync.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/net\/httpclient\/SplitResponseSSLKeepAlive.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/net\/httpclient\/SplitResponseSSLKeepAliveAsync.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @run testng java.net.http\/jdk.internal.net.http.FlowTest\n+ * @run testng\/timeout=480 java.net.http\/jdk.internal.net.http.FlowTest\n","filename":"test\/jdk\/java\/net\/httpclient\/whitebox\/FlowTestDriver.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main\/othervm -Djdk.net.useFastTcpLoopback StressLoopback\n+ * @run main\/othervm\/timeout=480 -Djdk.net.useFastTcpLoopback StressLoopback\n","filename":"test\/jdk\/java\/nio\/channels\/AsynchronousSocketChannel\/StressLoopback.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8361495\n+ * @summary Test for AsynchronousCloseException from uninterruptible FileChannel\n+ * @run junit AsyncCloseStreams\n+ *\/\n+\n+import java.io.Closeable;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.channels.AsynchronousCloseException;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.concurrent.LinkedTransferQueue;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class AsyncCloseStreams {\n+    private static final Closeable STOP = () -> { };\n+\n+    private static Thread startCloseThread(LinkedTransferQueue<Closeable> q) {\n+        return Thread.ofPlatform().start(() -> {\n+                try {\n+                    Closeable c;\n+                    while((c = q.take()) != STOP) {\n+                        try {\n+                            c.close();\n+                        } catch (IOException ignored) {\n+                        }\n+                    }\n+                } catch (InterruptedException ignored) {\n+                }\n+            });\n+    }\n+\n+    @Test\n+    public void available() throws InterruptedException, IOException {\n+        var close = new LinkedTransferQueue<Closeable>();\n+        Thread closeThread = startCloseThread(close);\n+\n+        try {\n+            Path path = Files.createTempFile(Path.of(\".\"), \"foo\", \"bar\");\n+            path.toFile().deleteOnExit();\n+\n+            do {\n+                InputStream in = Files.newInputStream(path);\n+                close.offer(in);\n+                int available = 0;\n+                try {\n+                    available = in.available();\n+                } catch (AsynchronousCloseException ace) {\n+                    System.err.println(\"AsynchronousCloseException caught\");\n+                    break;\n+                } catch (ClosedChannelException ignored) {\n+                    continue;\n+                } catch (Throwable t) {\n+                    fail(\"Unexpected error\", t);\n+                }\n+                if (available < 0) {\n+                    fail(\"FAILED: available < 0\");\n+                }\n+            } while (true);\n+        } finally {\n+            close.offer(STOP);\n+            closeThread.join();\n+        }\n+    }\n+\n+    @Test\n+    public void read() throws InterruptedException, IOException {\n+        var close = new LinkedTransferQueue<Closeable>();\n+        Thread closeThread = startCloseThread(close);\n+\n+        try {\n+            Path path = Files.createTempFile(Path.of(\".\"), \"foo\", \"bar\");\n+            path.toFile().deleteOnExit();\n+            byte[] bytes = new byte[100_000];\n+            Arrays.fill(bytes, (byte)27);\n+            Files.write(path, bytes);\n+\n+            do {\n+                InputStream in = Files.newInputStream(path);\n+                close.offer(in);\n+                int value = 0;\n+                try {\n+                    value = in.read();\n+                } catch (AsynchronousCloseException ace) {\n+                    System.err.println(\"AsynchronousCloseException caught\");\n+                    break;\n+                } catch (ClosedChannelException ignored) {\n+                    continue;\n+                } catch (Throwable t) {\n+                    fail(\"Unexpected error\", t);\n+                }\n+                if (value < 0) {\n+                    fail(\"FAILED: value < 0\");\n+                }\n+            } while (true);\n+        } finally {\n+            close.offer(STOP);\n+            closeThread.join();\n+        }\n+    }\n+\n+    @Test\n+    public void write() throws InterruptedException, IOException {\n+        var close = new LinkedTransferQueue<Closeable>();\n+        Thread closeThread = startCloseThread(close);\n+\n+        try {\n+            Path path = Files.createTempFile(Path.of(\".\"), \"foo\", \"bar\");\n+            path.toFile().deleteOnExit();\n+\n+            do {\n+                OutputStream out = Files.newOutputStream(path);\n+                close.offer(out);\n+                try {\n+                    out.write(27);\n+                } catch (AsynchronousCloseException ace) {\n+                    System.err.println(\"AsynchronousCloseException caught\");\n+                    break;\n+                } catch (ClosedChannelException ignored) {\n+                } catch (Throwable t) {\n+                    fail(\"Write error\", t);\n+                }\n+            } while (true);\n+        } finally {\n+            close.offer(STOP);\n+            closeThread.join();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/AsyncCloseStreams.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n- * @run testng\/othervm\/timeout=180 TransferTo\n+ * @run testng\/othervm\/timeout=720 TransferTo\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/TransferTo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * @run testng\/othervm\/timeout=180 TransferTo_2GB_transferFrom\n+ * @run testng\/othervm\/timeout=720 TransferTo_2GB_transferFrom\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/TransferTo_2GB_transferFrom.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run testng\/othervm\/timeout=180 TransferTo_2GB_transferTo\n+ * @run testng\/othervm\/timeout=720 TransferTo_2GB_transferTo\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/TransferTo_2GB_transferTo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run main\/othervm CleanerTest\n+ * @run main\/othervm\/timeout=480 CleanerTest\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/CleanerTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @modules java.base\/sun.nio.ch:+open java.base\/java.io:+open\n@@ -35,0 +36,1 @@\n+import java.lang.reflect.Field;\n@@ -50,0 +52,18 @@\n+    private static final int TRIES = 3;\n+\n+    public static int getFD(FileChannel channel) throws Exception {\n+        Field fFdFd = channel.getClass().getDeclaredField(\"fd\");\n+        fFdFd.setAccessible(true);\n+        FileDescriptor fd = (FileDescriptor) fFdFd.get(channel);\n+\n+        Field fFd = FileDescriptor.class.getDeclaredField(\"fd\");\n+        fFd.setAccessible(true);\n+        return fFd.getInt(fd);\n+    }\n+\n+    private static void testWrite(Path p, long blockSize) throws Exception {\n+        try (FileChannel fc = FileChannel.open(p,\n+                StandardOpenOption.READ,\n+                StandardOpenOption.WRITE,\n+                ExtendedOpenOption.DIRECT)) {\n+            int fd = getFD(fc);\n@@ -51,3 +71,0 @@\n-    private static int testWrite(Path p, long blockSize) throws Exception {\n-        try (FileChannel fc = FileChannel.open(p, StandardOpenOption.WRITE,\n-             ExtendedOpenOption.DIRECT)) {\n@@ -63,3 +80,17 @@\n-            src.flip();\n-            fc.write(src);\n-            return size;\n+\n+            \/\/ If there is AV or other FS tracing software, it may cache the file\n+            \/\/ contents on first access, even though we have asked for DIRECT here.\n+            \/\/ Do several attempts to make test more resilient.\n+\n+            for (int t = 0; t < TRIES; t++) {\n+                flushFileCache(size, fd);\n+                src.flip();\n+                fc.position(0);\n+                fc.write(src);\n+                if (!isFileInCache(size, fd)) {\n+                    return;\n+                }\n+            }\n+\n+            throw new RuntimeException(\"DirectIO is not working properly with \" +\n+                                       \"write. File still exists in cache!\");\n@@ -69,2 +100,6 @@\n-    private static int testRead(Path p, long blockSize) throws Exception {\n-        try (FileChannel fc = FileChannel.open(p, ExtendedOpenOption.DIRECT)) {\n+    private static void testRead(Path p, long blockSize) throws Exception {\n+        try (FileChannel fc = FileChannel.open(p,\n+                StandardOpenOption.READ,\n+                ExtendedOpenOption.DIRECT)) {\n+            int fd = getFD(fc);\n+\n@@ -77,2 +112,17 @@\n-            fc.read(dest);\n-            return size;\n+\n+            \/\/ If there is AV or other FS tracing software, it may cache the file\n+            \/\/ contents on first access, even though we have asked for DIRECT here.\n+            \/\/ Do several attempts to make test more resilient.\n+\n+            for (int t = 0; t < TRIES; t++) {\n+                flushFileCache(size, fd);\n+                dest.clear();\n+                fc.position(0);\n+                fc.read(dest);\n+                if (!isFileInCache(size, fd)) {\n+                    return;\n+                }\n+            }\n+\n+            throw new RuntimeException(\"DirectIO is not working properly with \" +\n+                                       \"read. File still exists in cache!\");\n@@ -87,6 +137,2 @@\n-    private static boolean isFileInCache(int size, Path p) {\n-        String path = p.toString();\n-        return isFileInCache0(size, path);\n-    }\n-\n-    private static native boolean isFileInCache0(int size, String path);\n+    private static native boolean flushFileCache(int size, int fd);\n+    private static native boolean isFileInCache(int size, int fd);\n@@ -101,10 +147,2 @@\n-            int size = testWrite(p, blockSize);\n-            if (isFileInCache(size, p)) {\n-                throw new RuntimeException(\"DirectIO is not working properly with \"\n-                    + \"write. File still exists in cache!\");\n-            }\n-            size = testRead(p, blockSize);\n-            if (isFileInCache(size, p)) {\n-                throw new RuntimeException(\"DirectIO is not working properly with \"\n-                    + \"read. File still exists in cache!\");\n-            }\n+            testWrite(p, blockSize);\n+            testRead(p, blockSize);\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/directio\/DirectIOTest.java","additions":64,"deletions":26,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n- * Method:    isFileInCache0\n- * Signature: (ILjava\/lang\/String;)Z\n+ * Method:    flushFileCache\n+ * Signature: (II;)V\n@@ -51,1 +51,1 @@\n-JNIEXPORT jboolean Java_DirectIOTest_isFileInCache0(JNIEnv *env,\n+JNIEXPORT void Java_DirectIOTest_flushFileCache(JNIEnv *env,\n@@ -54,1 +54,15 @@\n-                                                jstring file_path) {\n+                                                jint fd) {\n+#ifdef __linux__\n+    posix_fadvise(fd, 0, file_size, POSIX_FADV_DONTNEED);\n+#endif\n+}\n+\n+\/*\n+ * Class:     DirectIO\n+ * Method:    isFileInCache\n+ * Signature: (II;)Z\n+ *\/\n+JNIEXPORT jboolean Java_DirectIOTest_isFileInCache(JNIEnv *env,\n+                                                jclass cls,\n+                                                jint file_size,\n+                                                jint fd) {\n@@ -72,6 +86,0 @@\n-    const char* path = (*env)->GetStringUTFChars(env, file_path, JNI_FALSE);\n-\n-    int fd = open(path, O_RDWR);\n-\n-    (*env)->ReleaseStringUTFChars(env, file_path, path);\n-\n@@ -80,1 +88,0 @@\n-        close(fd);\n@@ -82,1 +89,1 @@\n-            \"test of whether file exists in cache failed\");\n+            \"test of whether file exists in cache failed: mmap failed\");\n@@ -98,1 +105,1 @@\n-            \"test of whether file exists in cache failed\");\n+            \"test of whether file exists in cache failed: malloc failed\");\n@@ -100,1 +107,0 @@\n-    close(fd);\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/directio\/libDirectIO.c","additions":20,"deletions":14,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main CloseDuringConnect\n+ * @run main\/timeout=480 CloseDuringConnect\n","filename":"test\/jdk\/java\/nio\/channels\/SocketChannel\/CloseDuringConnect.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run junit\/othervm OpenLeak\n+ * @run junit\/othervm\/timeout=480 OpenLeak\n","filename":"test\/jdk\/java\/nio\/channels\/SocketChannel\/OpenLeak.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @run testng\/othervm IOExchanges\n+ * @run testng\/othervm\/timeout=480 IOExchanges\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/IOExchanges.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run junit BlockingChannelOps\n+ * @run junit\/timeout=480 BlockingChannelOps\n@@ -36,2 +36,2 @@\n- * @run junit\/othervm -Djdk.pollerMode=1 BlockingChannelOps\n- * @run junit\/othervm -Djdk.pollerMode=2 BlockingChannelOps\n+ * @run junit\/othervm\/timeout=480 -Djdk.pollerMode=1 BlockingChannelOps\n+ * @run junit\/othervm\/timeout=480 -Djdk.pollerMode=2 BlockingChannelOps\n@@ -44,1 +44,1 @@\n- * @run junit\/othervm -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations BlockingChannelOps\n+ * @run junit\/othervm\/timeout=480 -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations BlockingChannelOps\n","filename":"test\/jdk\/java\/nio\/channels\/vthread\/BlockingChannelOps.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 8154364\n+ * @bug 8154364 8366254\n@@ -36,0 +36,1 @@\n+import java.nio.file.FileSystemLoopException;\n@@ -454,1 +455,1 @@\n-        assertThrows(FileSystemException.class, () -> Files.isSameFile(x, y));\n+        assertThrows(FileSystemLoopException.class, () -> Files.isSameFile(x, y));\n","filename":"test\/jdk\/java\/nio\/file\/Files\/IsSameFile.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @run main\/othervm\/timeout=360 DGCDeadLock\n+ * @run main\/othervm\/timeout=1440 DGCDeadLock\n@@ -59,2 +59,1 @@\n-    public static final double TEST_FAIL_TIME =\n-            (HOLD_TARGET_TIME + 30000) * TestLibrary.getTimeoutFactor();\n+    public static final double TEST_FAIL_TIME = (HOLD_TARGET_TIME + 30000) * Math.max(TestLibrary.getTimeoutFactor(), 4);\n","filename":"test\/jdk\/java\/rmi\/transport\/dgcDeadLock\/DGCDeadLock.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @bug 8298420\n+ * @bug 8298420 8365288\n@@ -81,1 +81,3 @@\n-        testClass(PEMData.rsapriv, X509EncodedKeySpec.class, false);\n+        testClass(PEMData.rsapriv, X509EncodedKeySpec.class, false, ClassCastException.class);\n+        System.out.println(\"Decoder test rsapriv PEM asking other EKS returned:\");\n+        testClass(PEMData.rsapriv, XEKS.class, false, ClassCastException.class);\n@@ -487,0 +489,13 @@\n+    static void testClass(PEMData.Entry entry, Class clazz, boolean pass,\n+        Class ec) throws RuntimeException {\n+        try {\n+            testClass(entry, clazz);\n+        } catch (Exception e) {\n+            if (ec.isInstance(e)) {\n+                System.out.println(\"PASS\");\n+                return;\n+            }\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n@@ -576,0 +591,11 @@\n+\n+    class XEKS extends EncodedKeySpec {\n+        public XEKS(byte[] encodedKey) {\n+            super(encodedKey);\n+        }\n+\n+        @Override\n+        public String getFormat() {\n+            return \"\";\n+        }\n+    }\n","filename":"test\/jdk\/java\/security\/PEM\/PEMDecoderTest.java","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main Chain\n+ * @run main\/timeout=480 Chain\n","filename":"test\/jdk\/java\/security\/SignedObject\/Chain.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run junit DateFormatTest\n+ * @run junit\/timeout=480 DateFormatTest\n","filename":"test\/jdk\/java\/text\/Format\/DateFormat\/DateFormatTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,264 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8366401\n+ * @summary Check serialization of DecimalFormatSymbols. That is, ensure the\n+ *          behavior for each stream version is correct during de-serialization.\n+ * @run junit\/othervm --add-opens java.base\/java.text=ALL-UNNAMED DFSSerializationTest\n+ *\/\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Field;\n+import java.text.DecimalFormatSymbols;\n+import java.util.Currency;\n+import java.util.Locale;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class DFSSerializationTest {\n+\n+    @Nested\n+    class VersionTests {\n+\n+        \/\/ Ensure correct monetarySeparator and exponential field defaults\n+        \/\/ Reads monetary from decimal, and sets exponential to 'E'\n+        @Test\n+        public void version0Test() {\n+            var crafted = new DFSBuilder()\n+                    .setVer(0)\n+                    .set(\"monetarySeparator\", '~')\n+                    .set(\"exponential\", 'Z')\n+                    .build();\n+            var bytes = ser(crafted);\n+            var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+            \/\/ Check exponential is set to proper default 'E', not 'Z'\n+            assertEquals('E', readField(dfs, \"exponential\"));\n+            \/\/ Ensure that mSep is based on dSep, and is not '~'\n+            assertNotEquals('~', dfs.getMonetaryDecimalSeparator());\n+            assertEquals(dfs.getDecimalSeparator(), dfs.getMonetaryDecimalSeparator());\n+        }\n+\n+        \/\/ Version 1 did not have a locale field, and it defaulted to Locale.ROOT.\n+        \/\/ Note that other versions did allow a locale field, which was nullable.\n+        \/\/ E.g. see nullableLocaleTest which does not set locale when it is `null`\n+        @Test\n+        public void version1Test() {\n+            var crafted = new DFSBuilder()\n+                    .setVer(1)\n+                    .set(\"locale\", null)\n+                    .build();\n+            var bytes = ser(crafted);\n+            var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+            assertEquals(Locale.ROOT, dfs.getLocale());\n+        }\n+\n+        \/\/ Version 2 did not have an exponential separator, and created it via exponent\n+        \/\/ char field.\n+        @Test\n+        public void version2Test() {\n+            var crafted = new DFSBuilder()\n+                    .setVer(2)\n+                    .set(\"exponentialSeparator\", null)\n+                    .set(\"exponential\", '~')\n+                    .build();\n+            var bytes = ser(crafted);\n+            var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+            assertEquals(\"~\", dfs.getExponentSeparator());\n+        }\n+\n+        \/\/ Version 3 didn't have perMillText, percentText, and minusSignText.\n+        \/\/ These were created from the corresponding char equivalents.\n+        @Test\n+        public void version3Test() {\n+            var crafted = new DFSBuilder()\n+                    .setVer(3)\n+                    .set(\"perMillText\", null)\n+                    .set(\"percentText\", null)\n+                    .set(\"minusSignText\", null)\n+                    .set(\"perMill\", '~')\n+                    .set(\"percent\", '~')\n+                    .set(\"minusSign\", '~')\n+                    .build();\n+            var bytes = ser(crafted);\n+            var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+            \/\/ Need to check these String fields using reflection, since they\n+            \/\/ are not exposed via the public API\n+            assertEquals(\"~\", readField(dfs, \"perMillText\"));\n+            assertEquals(\"~\", readField(dfs, \"percentText\"));\n+            assertEquals(\"~\", readField(dfs, \"minusSignText\"));\n+        }\n+\n+        \/\/ Version 4 did not have monetaryGroupingSeparator. It should be based\n+        \/\/ off of groupingSeparator.\n+        @Test\n+        public void version4Test() {\n+            var crafted = new DFSBuilder()\n+                    .setVer(4)\n+                    .set(\"monetaryGroupingSeparator\", 'Z')\n+                    .set(\"groupingSeparator\", '~')\n+                    .build();\n+            var bytes = ser(crafted);\n+            var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+            assertEquals(dfs.getGroupingSeparator(), dfs.getMonetaryGroupingSeparator());\n+        }\n+    }\n+\n+    \/\/ Up-to-date DFS stream versions do not expect a null locale since the\n+    \/\/ standard DecimalFormatSymbols API forbids it. However, this was not always\n+    \/\/ the case and previous stream versions can contain a null locale. Thus,\n+    \/\/ ensure that a null locale does not cause number data loading to fail.\n+    @Test\n+    public void nullableLocaleTest() {\n+        var bytes = ser(new DFSBuilder()\n+                .set(\"locale\", null)\n+                .set(\"minusSignText\", \"zFoo\")\n+                .set(\"minusSign\", 'z') \/\/ Set so that char\/String forms agree\n+                .build());\n+        var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+        assertNull(dfs.getLocale());\n+        \/\/ LMS should be based off of minusSignText when locale is null\n+        assertEquals(\"zFoo\", readField(dfs, \"lenientMinusSigns\"));\n+    }\n+\n+    \/\/ readObject fails when the {@code char} and {@code String} representations\n+    \/\/ of percent, per mille, and\/or minus sign disagree.\n+    @Test\n+    public void disagreeingTextTest() {\n+        var expected = \"'char' and 'String' representations of either percent, \" +\n+                \"per mille, and\/or minus sign disagree.\";\n+        assertEquals(expected, assertThrows(InvalidObjectException.class, () ->\n+                deSer(ser(new DFSBuilder()\n+                        .set(\"minusSignText\", \"Z\")\n+                        .set(\"minusSign\", 'X')\n+                        .build()))).getMessage());\n+        assertEquals(expected, assertThrows(InvalidObjectException.class, () ->\n+                deSer(ser(new DFSBuilder()\n+                        .set(\"perMillText\", \"Z\")\n+                        .set(\"perMill\", 'X')\n+                        .build()))).getMessage());\n+        assertEquals(expected, assertThrows(InvalidObjectException.class, () ->\n+                deSer(ser(new DFSBuilder()\n+                        .set(\"percentText\", \"Z\")\n+                        .set(\"percent\", 'X')\n+                        .build()))).getMessage());\n+    }\n+\n+    \/\/ Ensure the serial version is updated to the current after de-serialization.\n+    @Test\n+    public void updatedVersionTest() {\n+        var bytes = ser(new DFSBuilder().setVer(-25).build());\n+        var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+        assertEquals(5, readField(dfs, \"serialVersionOnStream\"));\n+    }\n+\n+    \/\/ Should set currency from 4217 code when it is valid.\n+    @Test\n+    public void validIntlCurrencyTest() {\n+        var bytes = ser(new DFSBuilder().set(\"intlCurrencySymbol\", \"JPY\").build());\n+        var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+        assertEquals(Currency.getInstance(\"JPY\"), dfs.getCurrency());\n+    }\n+\n+    \/\/ Should not set currency when 4217 code is invalid, it remains null.\n+    @Test\n+    public void invalidIntlCurrencyTest() {\n+        var bytes = ser(new DFSBuilder()\n+                .set(\"intlCurrencySymbol\", \">.,\")\n+                .set(\"locale\", Locale.JAPAN)\n+                .build());\n+        var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+        \/\/ Can not init off invalid 4217 code, remains null\n+        assertNull(dfs.getCurrency());\n+    }\n+\n+\/\/ Utilities ----\n+\n+    \/\/ Utility to serialize\n+    private static byte[] ser(Object obj) {\n+        return assertDoesNotThrow(() -> {\n+            try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+                 ObjectOutputStream oos = new ObjectOutputStream(byteArrayOutputStream)) {\n+                oos.writeObject(obj);\n+                return byteArrayOutputStream.toByteArray();\n+            }\n+        }, \"Unexpected error during serialization\");\n+    }\n+\n+    \/\/ Utility to deserialize\n+    private static DecimalFormatSymbols deSer(byte[] bytes) throws IOException, ClassNotFoundException {\n+        try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);\n+             ObjectInputStream ois = new ObjectInputStream(byteArrayInputStream)) {\n+            return (DecimalFormatSymbols) ois.readObject();\n+        }\n+    }\n+\n+    \/\/ Utility to read a private field\n+    private static Object readField(DecimalFormatSymbols dfs, String name) {\n+        return assertDoesNotThrow(() -> {\n+            var field = DecimalFormatSymbols.class.getDeclaredField(name);\n+            field.setAccessible(true);\n+            return field.get(dfs);\n+        }, \"Unexpected error during field reading\");\n+    }\n+\n+    \/\/ Utility class to build instances of DFS via reflection\n+    private static class DFSBuilder {\n+\n+        private final DecimalFormatSymbols dfs;\n+\n+        private DFSBuilder() {\n+            dfs = new DecimalFormatSymbols();\n+        }\n+\n+        private DFSBuilder setVer(Object value) {\n+            return set(\"serialVersionOnStream\", value);\n+        }\n+\n+        private DFSBuilder set(String field, Object value) {\n+            return assertDoesNotThrow(() -> {\n+                Field f = dfs.getClass().getDeclaredField(field);\n+                f.setAccessible(true);\n+                f.set(dfs, value);\n+                return this;\n+            }, \"Unexpected error during reflection setting\");\n+        }\n+\n+        private DecimalFormatSymbols build() {\n+            return dfs;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/DFSSerializationTest.java","additions":264,"deletions":0,"binary":false,"changes":264,"status":"added"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n- * @run testng\/othervm -Xmx2g WhiteBoxResizeTest\n+ * @run testng\/othervm\/timeout=960 -Xmx2g WhiteBoxResizeTest\n","filename":"test\/jdk\/java\/util\/HashMap\/WhiteBoxResizeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm -Djava.locale.providers=CLDR,SPI CurrencyNameProviderTest\n+ * @run main\/othervm\/timeout=480 -Djava.locale.providers=CLDR,SPI CurrencyNameProviderTest\n","filename":"test\/jdk\/java\/util\/PluggableLocale\/CurrencyNameProviderTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @run junit\/othervm -Djava.locale.providers=CLDR,SPI LocaleNameProviderTest\n+ * @run junit\/othervm\/timeout=960 -Djava.locale.providers=CLDR,SPI LocaleNameProviderTest\n","filename":"test\/jdk\/java\/util\/PluggableLocale\/LocaleNameProviderTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,5 @@\n+import javax.swing.SwingConstants;\n+import javax.swing.BoxLayout;\n+import javax.swing.Box;\n+import java.awt.Dimension;\n+import java.awt.Component;\n@@ -101,1 +106,2 @@\n-        var label = new JLabel(SDF.format(new Date()));\n+        contents.setSize(350, 250);\n+        \/\/ Panel with vertical layout\n@@ -103,0 +109,8 @@\n+        panel.setLayout(new BoxLayout(panel, BoxLayout.PAGE_AXIS));\n+        \/\/ Time zone ID label\n+        var timeZoneID = new JLabel(\"Time zone ID: \" + SDF.getTimeZone().getID(), SwingConstants.CENTER);\n+        timeZoneID.setAlignmentX(Component.CENTER_ALIGNMENT);\n+        \/\/ Time label\n+        var label = new JLabel(SDF.format(new Date()), SwingConstants.CENTER);\n+        label.setAlignmentX(Component.CENTER_ALIGNMENT);\n+        \/\/ Update button\n@@ -104,0 +118,7 @@\n+        button.setAlignmentX(Component.CENTER_ALIGNMENT);\n+        \/\/ Add components with spacing\n+        panel.add(Box.createRigidArea(new Dimension(0, 10)));\n+        panel.add(timeZoneID);\n+        panel.add(Box.createRigidArea(new Dimension(0, 5)));\n+        panel.add(label);\n+        panel.add(Box.createRigidArea(new Dimension(0, 10)));\n@@ -105,3 +126,2 @@\n-        contents.setSize(350, 250);\n-        contents.add(label, BorderLayout.NORTH);\n-        contents.add(panel, BorderLayout.CENTER);\n+        contents.add(panel);\n+\n@@ -110,0 +130,3 @@\n+            \/\/ Clear JVM cached timezone and force reload from OS\n+            TimeZone.setDefault(null);\n+            System.setProperty(\"user.timezone\", \"\");\n@@ -112,0 +135,1 @@\n+            timeZoneID.setText(\"Time zone ID: \" + tz.getID());\n","filename":"test\/jdk\/java\/util\/TimeZone\/DefaultTimeZoneTest.java","additions":29,"deletions":5,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @run main\/othervm -Xmx64m BasicCancelTest\n+ * @run main\/othervm\/timeout=480 -Xmx64m BasicCancelTest\n","filename":"test\/jdk\/java\/util\/concurrent\/ScheduledThreadPoolExecutor\/BasicCancelTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * @run main\/othervm FileHandlerPath\n+ * @run main\/othervm\/timeout=480 FileHandlerPath\n","filename":"test\/jdk\/java\/util\/logging\/FileHandlerPath.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import jdk.test.lib.Utils;\n@@ -52,0 +53,1 @@\n+ * @library \/test\/lib\n@@ -63,5 +65,0 @@\n-    public static final double TIMEOUT_FACTOR;\n-    static {\n-        String toFactor = System.getProperty(\"test.timeout.factor\", \"1.0\");\n-        TIMEOUT_FACTOR = Double.parseDouble(toFactor);\n-    }\n@@ -69,1 +66,1 @@\n-        return Math.min(count, (int) Math.ceil(TIMEOUT_FACTOR * count));\n+        return Math.min(count, (int) Math.ceil(Utils.TIMEOUT_FACTOR * count));\n","filename":"test\/jdk\/java\/util\/logging\/LogManager\/Configuration\/updateConfiguration\/HandlersOnComplexResetUpdate.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import jdk.test.lib.Utils;\n@@ -52,0 +53,1 @@\n+ * @library \/test\/lib\n@@ -63,5 +65,0 @@\n-    public static final double TIMEOUT_FACTOR;\n-    static {\n-        String toFactor = System.getProperty(\"test.timeout.factor\", \"1.0\");\n-        TIMEOUT_FACTOR = Double.parseDouble(toFactor);\n-    }\n@@ -69,1 +66,1 @@\n-        return Math.min(count, (int) Math.ceil(TIMEOUT_FACTOR * count));\n+        return Math.min(count, (int) Math.ceil(Utils.TIMEOUT_FACTOR * count));\n","filename":"test\/jdk\/java\/util\/logging\/LogManager\/Configuration\/updateConfiguration\/HandlersOnComplexUpdate.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+timeout.default.seconds=480\n","filename":"test\/jdk\/java\/util\/stream\/boottest\/java.base\/java\/util\/stream\/TEST.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+timeout.default.seconds=480\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/TEST.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary Test basic deflater & inflater functionality\n+ * @summary Test basic deflater and inflater functionality\n@@ -29,0 +29,1 @@\n+ * @run main\/timeout=480 DeInflate\n","filename":"test\/jdk\/java\/util\/zip\/DeInflate.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng TestZipFileEncodings\n+ * @run testng\/timeout=480 TestZipFileEncodings\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/TestZipFileEncodings.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     8364135\n+ * @summary Test verifies that jpeg image reader throws\n+ *          IndexOutOfBoundsException when \"-1\" image index is used.\n+ * @run main JpegNegativeImageIndexTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.concurrent.Callable;\n+\n+import javax.imageio.ImageIO;\n+import javax.imageio.ImageReader;\n+\n+public class JpegNegativeImageIndexTest {\n+\n+    private static boolean failed;\n+\n+    private static void checkException(boolean exceptionReceived,\n+                                       String testName) {\n+        if (!exceptionReceived) {\n+            System.out.println(\"Didn't receive IndexOutOfBoundsException for \"\n+                + testName);\n+            failed = true;\n+        }\n+    }\n+\n+    private static void testMethod(String methodName,\n+                                   Callable<?> method) {\n+        boolean exceptionReceived = false;\n+        System.out.println(\"Testing \" + methodName);\n+        try {\n+            method.call();\n+        } catch (Exception e) {\n+            if (e instanceof IndexOutOfBoundsException) {\n+                exceptionReceived = true;\n+            }\n+        }\n+        checkException(exceptionReceived, methodName);\n+    }\n+\n+    public static void main(String[] args) throws IOException {\n+        Iterator<ImageReader> readers =\n+            ImageIO.getImageReadersByFormatName(\"jpeg\");\n+        if (!readers.hasNext()) {\n+            throw new RuntimeException(\"No jpeg image readers found\");\n+        }\n+\n+        ImageReader ir = readers.next();\n+\n+        testMethod(\"getImageTypes()\", () -> ir.getImageTypes(-1));\n+        testMethod(\"getWidth()\", () -> ir.getWidth(-1));\n+        testMethod(\"getHeight()\", () -> ir.getHeight(-1));\n+        testMethod(\"getRawImageType()\", () -> ir.getRawImageType(-1));\n+\n+        if (failed) {\n+            throw new RuntimeException(\"JpegImageReader didn't throw required\" +\n+                \" IndexOutOfBoundsException for -1 image index\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/imageio\/plugins\/jpeg\/JpegNegativeImageIndexTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8364227\n+ * @summary Test various null parameters and verify Exceptions thrown\n+ * @modules java.management.rmi\n+ * @run main ExceptionTestNulls\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import javax.management.AttributeNotFoundException;\n+import javax.management.ObjectName;\n+import javax.management.InstanceAlreadyExistsException;\n+import javax.management.InstanceNotFoundException;\n+import javax.management.InvalidAttributeValueException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.MBeanException;\n+import javax.management.MBeanServer;\n+import javax.management.MBeanServerConnection;\n+import javax.management.MBeanServerFactory;\n+import javax.management.NotCompliantMBeanException;\n+import javax.management.NotificationListener;\n+import javax.management.ReflectionException;\n+import javax.management.RuntimeOperationsException;\n+\n+public class ExceptionTestNulls {\n+\n+    public interface MyMBean {\n+    }\n+\n+    public class My implements MyMBean {\n+    }\n+\n+    private int count;\n+\n+    public static void main(String args[]) throws Exception {\n+        ExceptionTestNulls test = new ExceptionTestNulls();\n+        test.run();\n+    }\n+\n+    public ExceptionTestNulls() {\n+        count = 0; \/\/ Simple index for printing tests, for readability.\n+    }\n+\n+    public void run() {\n+\n+        try {\n+        ObjectName name = new ObjectName(\"a:b=c\");\n+        ObjectName namePattern = new ObjectName(\"*:type=Foo\");\n+        My myMy = new My();\n+            MBeanServer mbs = MBeanServerFactory.newMBeanServer();\n+\n+            try {\n+                \/\/ createMBean with null className\n+                mbs.createMBean((String) null, name, name, new Object[0], new String[0]);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+            try {\n+                \/\/ createMBean with ObjectName as a pattern\n+                mbs.createMBean(\"myMy\", namePattern, name, new Object[0], new String[0]);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+            try {\n+                \/\/ registerMBean with null Object\n+                mbs.registerMBean(null, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+            try {\n+                \/\/ registerMBean with no name available\n+                mbs.registerMBean(myMy, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+            try {\n+                \/\/ unregisterMBean with null ObjectName\n+                mbs.unregisterMBean(null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+            try {\n+                mbs.isRegistered(null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+            try {\n+                mbs.getAttribute(null, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+            try {\n+                mbs.getAttribute(name, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+           try {\n+                mbs.getAttributes(null, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+           try {\n+                mbs.getAttributes(name, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+           try {\n+                mbs.setAttribute(null, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+           try {\n+                mbs.setAttribute(name, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+           try {\n+                mbs.setAttributes(null, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+           try {\n+                mbs.setAttributes(name, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+           try {\n+                mbs.addNotificationListener(null, (NotificationListener) null, null, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+           try {\n+                mbs.registerMBean(myMy, name);\n+                mbs.addNotificationListener(null, name, null, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+        } catch (MBeanException | MalformedObjectNameException | InstanceAlreadyExistsException\n+                 | NotCompliantMBeanException | InstanceNotFoundException | ReflectionException\n+                 | AttributeNotFoundException | InvalidAttributeValueException e) {\n+            \/\/ Should not reach here.  Known Exceptions thrown by methods above.\n+            \/\/ These would be a failure, as would other exceptions not caught (e.g. NullPointerException).\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public void checkROEContainsIAE(RuntimeOperationsException e) {\n+        System.out.println(++count);\n+        System.out.println(\"Checking: \" + e);\n+        if (e.getCause() instanceof IllegalArgumentException) {\n+            System.out.println(\"Got expected cause: \" + e.getCause());\n+            System.out.println();\n+        } else {\n+            throw new RuntimeException(\"Not the expected cause: \" + e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/management\/MBeanServer\/ExceptionTestNulls.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n- * @run main\/othervm DisabledAlgorithms default\n- * @run main\/othervm DisabledAlgorithms empty\n+ * @run main\/othervm\/timeout=480 DisabledAlgorithms default\n+ * @run main\/othervm\/timeout=480 DisabledAlgorithms empty\n","filename":"test\/jdk\/javax\/net\/ssl\/ciphersuites\/DisabledAlgorithms.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,3 @@\n-import javax.print.attribute.AttributeSet;\n-import javax.print.attribute.HashAttributeSet;\n-import javax.print.attribute.standard.PrinterName;\n+import java.io.IOException;\n+\n+import jtreg.SkippedException;\n@@ -36,0 +36,2 @@\n+ * @library \/test\/lib\/\n+ * @requires (os.family == \"linux\")\n@@ -41,6 +43,0 @@\n-    String os = System.getProperty(\"os.name\").toLowerCase();\n-    System.out.println(\"OS is \" + os);\n-    if (!os.equals(\"linux\")) {\n-        System.out.println(\"Linux specific test. No need to continue\");\n-        return;\n-    }\n@@ -54,1 +50,10 @@\n-    Process proc = Runtime.getRuntime().exec(lpcmd);\n+    Process proc;\n+    try {\n+        proc = Runtime.getRuntime().exec(lpcmd);\n+    } catch (IOException e) {\n+        if (e.getMessage().contains(\"No such file or directory\")) {\n+            throw new SkippedException(\"Cannot find lpstat\");\n+        } else {\n+            throw e;\n+        }\n+    }\n@@ -69,1 +74,0 @@\n-\n","filename":"test\/jdk\/javax\/print\/PrintServiceLookup\/CountPrintServices.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main bug6868611\n+ * @run main\/timeout=480 bug6868611\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/6868611\/bug6868611.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+\n@@ -28,4 +29,4 @@\n- *     ComponentOrientation property is set to RIGHT_TO_LEFT. This test is\n- *     manual.  The tester is asked to compare left-to-right and\n- *     right-to-left menu bars and judge whether they are mirror images of each\n- *     other.\n+ *     ComponentOrientation property is set to RIGHT_TO_LEFT.\n+ *     The tester is asked to compare left-to-right and\n+ *     right-to-left menu bars and decide whether they are mirror\n+ *     images of each other.\n@@ -38,1 +39,0 @@\n-import java.awt.Point;\n@@ -41,0 +41,2 @@\n+import java.util.List;\n+\n@@ -45,0 +47,1 @@\n+import javax.swing.JOptionPane;\n@@ -50,1 +53,1 @@\n-public class RightLeftOrientation {\n+public final class RightLeftOrientation {\n@@ -52,2 +55,1 @@\n-    static JFrame ltrFrame;\n-    static JFrame rtlFrame;\n+    private static List<JFrame> frames;\n@@ -56,3 +58,1 @@\n-        This test checks menu bars for correct Right-To-Left Component Orientation.\n-\n-        You should see two frames, each containing a menu bar.\n+        This test checks menu bars for correct Right-To-Left component orientation.\n@@ -60,1 +60,2 @@\n-        One frame will be labelled \"Left To Right\" and will contain\n+        You should see two frames, each contains a menu bar.\n+        One frame is labelled \"Left To Right\" and contains\n@@ -62,2 +63,2 @@\n-        The other frame will be labelled \"Right To Left\" and will\n-        contain a menu bar with menus starting on its right side.\n+        The other frame is labelled \"Right To Left\" and\n+        contains a menu bar with menus starting on its right side.\n@@ -65,4 +66,5 @@\n-        The test will also contain radio buttons that can be used to set\n-        the look and feel of the menu bars.\n-        For each look and feel, you should compare the two menu\n-        bars and make sure they are mirror images of each other. \"\"\";\n+        The test also displays a frame with radio buttons\n+        to change the look and feel of the menu bars.\n+        For each look and feel, compare the two menu bars\n+        in LTR and RTL orientation and make sure they are mirror\n+        images of each other.\"\"\";\n@@ -72,1 +74,1 @@\n-                 .title(\"RTL test Instructions\")\n+                 .title(\"Menu Bar RTL Instructions\")\n@@ -74,1 +76,0 @@\n-                 .rows((int) INSTRUCTIONS.lines().count() + 2)\n@@ -77,0 +78,1 @@\n+                 .positionTestUIRightColumn()\n@@ -81,2 +83,2 @@\n-    private static JFrame createTestUI() {\n-        JFrame frame = new JFrame(\"RightLeftOrientation\");\n+    private static JFrame createPlafChangerFrame() {\n+        JFrame frame = new JFrame(\"Change Look and Feel\");\n@@ -86,1 +88,0 @@\n-        JRadioButton rb;\n@@ -91,1 +92,1 @@\n-            rb = new JRadioButton(lafInfos[i].getName());\n+            JRadioButton rb = new JRadioButton(lafInfos[i].getName());\n@@ -102,0 +103,3 @@\n+        frame.pack();\n+        return frame;\n+    }\n@@ -103,1 +107,4 @@\n-        ltrFrame = new JFrame(\"Left To Right\");\n+    private static List<JFrame> createTestUI() {\n+        JFrame plafFrame = createPlafChangerFrame();\n+\n+        JFrame ltrFrame = new JFrame(\"Left To Right\");\n@@ -106,2 +113,0 @@\n-        ltrFrame.setLocation(new Point(10, 10));\n-        ltrFrame.setVisible(true);\n@@ -109,1 +114,1 @@\n-        rtlFrame = new JFrame(\"Right To Left\");\n+        JFrame rtlFrame = new JFrame(\"Right To Left\");\n@@ -112,4 +117,2 @@\n-        rtlFrame.setLocation(new Point(10, 120));\n-        rtlFrame.setVisible(true);\n-        frame.pack();\n-        return frame;\n+\n+        return (frames = List.of(plafFrame, ltrFrame, rtlFrame));\n@@ -118,1 +121,2 @@\n-    static class PlafChanger implements ActionListener {\n+    private static final class PlafChanger implements ActionListener {\n+        @Override\n@@ -124,5 +128,8 @@\n-                SwingUtilities.updateComponentTreeUI(ltrFrame);\n-                SwingUtilities.updateComponentTreeUI(rtlFrame);\n-            }\n-            catch (Exception exc) {\n-                System.err.println(\"Could not load LookAndFeel: \" + lnfName);\n+                frames.forEach(SwingUtilities::updateComponentTreeUI);\n+            } catch (Exception exc) {\n+                String message = \"Could not set Look and Feel to \" + lnfName;\n+                System.err.println(message);\n+                JOptionPane.showMessageDialog(frames.get(0),\n+                                              message,\n+                                              \"Look and Feel Error\",\n+                                              JOptionPane.ERROR_MESSAGE);\n","filename":"test\/jdk\/javax\/swing\/JMenuBar\/RightLeftOrientation.java","additions":46,"deletions":39,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run main\/othervm -Djava.awt.headless=true ConcurrentModification\n+ * @run main\/othervm\/timeout=480 -Djava.awt.headless=true ConcurrentModification\n","filename":"test\/jdk\/javax\/swing\/plaf\/basic\/BasicDirectoryModel\/ConcurrentModification.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import jdk.test.lib.Utils;\n+\n@@ -38,0 +40,1 @@\n+   @library \/test\/lib\n@@ -41,2 +44,1 @@\n-    private static final float tf = Float.parseFloat(System.getProperty(\"test.timeout.factor\", \"1.0\"));\n-    private static final long TIMEOUT = 10_000 * (long)tf;\n+    private static final long TIMEOUT = (long) (10_000 * Utils.TIMEOUT_FACTOR);\n","filename":"test\/jdk\/javax\/swing\/text\/html\/parser\/Parser\/8078268\/bug8078268.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * @run main\/othervm\/timeout=300 -Dsun.net.httpserver.nodelay=true GenerationTests\n+ * @run main\/othervm\/timeout=1200 -Dsun.net.httpserver.nodelay=true GenerationTests\n","filename":"test\/jdk\/javax\/xml\/crypto\/dsig\/GenerationTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,2 @@\n- * @bug 8341277 8361102\n- * @summary Testing ClassFile instruction argument validation.\n+ * @bug 8341277 8361102 8361182 8361614\n+ * @summary Testing ClassFile (pseudo-)instruction argument validation.\n@@ -32,0 +32,2 @@\n+import java.lang.classfile.attribute.CharacterRangeInfo;\n+import java.lang.classfile.attribute.LineNumberInfo;\n@@ -281,0 +283,58 @@\n+\n+    @Test\n+    void testCharacterRange() {\n+        assertDoesNotThrow(() -> CharacterRangeInfo.of(0, 0, -234, 59494648, 0));\n+        assertDoesNotThrow(() -> CharacterRangeInfo.of(0, 0, -234, 59494648, 65535));\n+        assertThrows(IllegalArgumentException.class, () -> CharacterRangeInfo.of(0, 0, -234, 59494648, -1));\n+        assertThrows(IllegalArgumentException.class, () -> CharacterRangeInfo.of(0, 0, -234, 59494648, 65536));\n+        ClassFile.of().build(CD_Object, clb -> clb.withMethodBody(\"test\", MTD_void, 0, cob -> {\n+            var dummyLabel = cob.startLabel();\n+            assertDoesNotThrow(() -> CharacterRange.of(dummyLabel, dummyLabel, -234, 59494648, 0));\n+            assertDoesNotThrow(() -> CharacterRange.of(dummyLabel, dummyLabel, -234, 59494648, 65535));\n+            assertThrows(IllegalArgumentException.class, () -> CharacterRange.of(dummyLabel, dummyLabel, -234, 59494648, -1));\n+            assertThrows(IllegalArgumentException.class, () -> CharacterRange.of(dummyLabel, dummyLabel, -234, 59494648, 65536));\n+            assertThrows(IllegalArgumentException.class, () -> cob.characterRange(dummyLabel, dummyLabel, -234, 59494648, -1));\n+            assertThrows(IllegalArgumentException.class, () -> cob.characterRange(dummyLabel, dummyLabel, -234, 59494648, 65536));\n+            cob.return_();\n+        }));\n+    }\n+\n+    @Test\n+    void testLineNumber() {\n+        assertDoesNotThrow(() -> LineNumberInfo.of(0, 25));\n+        assertThrows(IllegalArgumentException.class, () -> LineNumberInfo.of(0, -1));\n+        assertThrows(IllegalArgumentException.class, () -> LineNumberInfo.of(0, 65536));\n+        assertDoesNotThrow(() -> LineNumber.of(25));\n+        assertThrows(IllegalArgumentException.class, () -> LineNumber.of(-1));\n+        assertThrows(IllegalArgumentException.class, () -> LineNumber.of(65536));\n+        ClassFile.of().build(CD_Object, clb -> clb.withMethodBody(\"test\", MTD_void, 0, cob -> {\n+            assertThrows(IllegalArgumentException.class, () -> cob.lineNumber(-1));\n+            assertThrows(IllegalArgumentException.class, () -> cob.lineNumber(65536));\n+            cob.return_();\n+        }));\n+    }\n+\n+    @Test\n+    void testTypeAnnotationLocalVarTargetInfo() {\n+        ClassFile.of().build(CD_Object, clb -> clb.withMethodBody(\"test\", MTD_void, 0, cob -> {\n+            var label = cob.startLabel();\n+            assertDoesNotThrow(() -> TypeAnnotation.LocalVarTargetInfo.of(label, label, 256));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.LocalVarTargetInfo.of(label, label, -1));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.LocalVarTargetInfo.of(label, label, 65536));\n+            cob.return_();\n+        }));\n+    }\n+\n+    @Test\n+    void testTypeAnnotationTypeArgumentTarget() {\n+        ClassFile.of().build(CD_Object, clb -> clb.withMethodBody(\"test\", MTD_void, 0, cob -> {\n+            var label = cob.startLabel();\n+            assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofTypeArgument(TypeAnnotation.TargetType.CAST, label, 0));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofCastExpr(label, -1));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofMethodInvocationTypeArgument(label, Integer.MIN_VALUE));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofMethodReferenceTypeArgument(label, 256));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofConstructorInvocationTypeArgument(label, 300));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofConstructorReferenceTypeArgument(label, -2));\n+            cob.return_();\n+        }));\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/InstructionValidationTest.java","additions":63,"deletions":3,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-import java.lang.classfile.ClassFile;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.constant.ClassDesc;\n-\n-import static java.lang.constant.ConstantDescs.*;\n-import static java.lang.classfile.ClassFile.*;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-\/*\n- * @test\n- * @bug 8311172\n- * @run junit PreviewMinorVersionTest\n- * @summary Ensures ClassFile.PREVIEW_MINOR_VERSION equals that of classes with\n- *          preview minor version from ClassModel::minorVersion\n- *\/\n-public class PreviewMinorVersionTest {\n-\n-    @Test\n-    public void testMinorVersionMatches() {\n-        \/\/ compile a class with --enable-preview\n-        \/\/ uses Record feature to trigger forcePreview\n-        var cf = ClassFile.of();\n-        var cd = ClassDesc.of(\"Test\");\n-        var bytes = cf.build(cd, cb -> cb\n-                .withSuperclass(CD_Object)\n-                \/\/ old preview minor version,\n-                \/\/ with all bits set to 1\n-                .withVersion(JAVA_17_VERSION, -1)\n-        );\n-\n-        var cm = ClassFile.of().parse(bytes);\n-        assertEquals(ClassFile.PREVIEW_MINOR_VERSION, cm.minorVersion());\n-    }\n-}\n","filename":"test\/jdk\/jdk\/classfile\/PreviewMinorVersionTest.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassFileVersion;\n+import java.lang.classfile.TypeAnnotation;\n+import java.lang.classfile.attribute.InnerClassInfo;\n+import java.lang.classfile.attribute.MethodParameterInfo;\n+import java.lang.classfile.attribute.ModuleAttribute;\n+import java.lang.classfile.attribute.ModuleExportInfo;\n+import java.lang.classfile.attribute.ModuleOpenInfo;\n+import java.lang.classfile.attribute.ModuleRequireInfo;\n+import java.lang.classfile.attribute.ModuleResolutionAttribute;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ModuleDesc;\n+import java.lang.constant.PackageDesc;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.classfile.ClassFile.JAVA_17_VERSION;\n+import static java.lang.constant.ConstantDescs.*;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/*\n+ * @test\n+ * @bug 8311172 8361614\n+ * @summary Testing ClassFile validation of non-instruction subint (u1, u2) arguments.\n+ * @run junit SubIntValidationTest\n+ *\/\n+class SubIntValidationTest {\n+\n+    @Test\n+    public void testBuilderFlags() {\n+        ClassFile.of().build(CD_Void, clb -> {\n+            assertThrows(IllegalArgumentException.class, () -> clb.withFlags(-1));\n+            assertThrows(IllegalArgumentException.class, () -> clb.withFlags(70000));\n+            assertThrows(IllegalArgumentException.class, () -> clb.withField(\"test\", CD_String, -1));\n+            assertThrows(IllegalArgumentException.class, () -> clb.withField(\"test\", CD_String, 70000));\n+            assertThrows(IllegalArgumentException.class, () -> clb.withMethod(\"test\", MTD_void, -1, _ -> {}));\n+            assertThrows(IllegalArgumentException.class, () -> clb.withMethod(\"test\", MTD_void, 70000, _ -> {}));\n+            clb.withField(\"test\", CD_String, fb -> {\n+                assertThrows(IllegalArgumentException.class, () -> fb.withFlags(-1));\n+                assertThrows(IllegalArgumentException.class, () -> fb.withFlags(70000 | ACC_STATIC));\n+            });\n+            clb.withMethod(\"test\", MTD_void, ACC_STATIC, mb -> {\n+                assertThrows(IllegalArgumentException.class, () -> mb.withFlags(-1));\n+                assertThrows(IllegalArgumentException.class, () -> mb.withFlags(70000 | ACC_STATIC));\n+            });\n+        });\n+    }\n+\n+    @Test\n+    public void testClassFileVersion() {\n+        \/\/ Prohibited but representable major\/minor\n+        assertDoesNotThrow(() -> ClassFileVersion.of(0, 0));\n+        \/\/ Non-representable major\/minor\n+        assertDoesNotThrow(() -> ClassFileVersion.of(JAVA_17_VERSION, 42));\n+        assertThrows(IllegalArgumentException.class, () -> ClassFileVersion.of(-1, 0));\n+        assertThrows(IllegalArgumentException.class, () -> ClassFileVersion.of(65536, 0));\n+        assertThrows(IllegalArgumentException.class, () -> ClassFileVersion.of(0, -2));\n+        assertThrows(IllegalArgumentException.class, () -> ClassFileVersion.of(0, 65536));\n+        ClassFile.of().build(CD_Void, clb -> assertThrows(IllegalArgumentException.class, () -> clb.withVersion(-1, 0)));\n+        \/\/ Special rule without serializing to class file format\n+        assertEquals(ClassFile.PREVIEW_MINOR_VERSION, ClassFileVersion.of(0, -1).minorVersion());\n+    }\n+\n+    @Test\n+    public void testReadMinorVersion() {\n+        var cf = ClassFile.of();\n+        var cd = ClassDesc.of(\"Test\");\n+        var bytes = cf.build(cd, cb -> cb\n+                .withSuperclass(CD_Object)\n+                \/\/ old preview minor version,\n+                \/\/ with all bits set to 1\n+                .withVersion(JAVA_17_VERSION, -1)\n+        );\n+\n+        var cm = ClassFile.of().parse(bytes);\n+        assertEquals(ClassFile.PREVIEW_MINOR_VERSION, cm.minorVersion());\n+    }\n+\n+    \/\/ LocalVarTargetInfo\/TypeArgumentTarget in InstructionValidationTest for Label\n+    @Test\n+    public void testTypeAnnotations() {\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofTypeParameter(TypeAnnotation.TargetType.CLASS_TYPE_PARAMETER, 0));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofClassTypeParameter(-1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofMethodTypeParameter(300));\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofClassExtends(65535));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofClassExtends(-1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofClassExtends(65536));\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofClassTypeParameterBound(255, 255));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofClassTypeParameterBound(-1, 255));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofMethodTypeParameterBound(0, 256));\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofMethodFormalParameter(0));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofMethodFormalParameter(-1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofMethodFormalParameter(256));\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofThrows(256));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofThrows(-1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofThrows(65536));\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofExceptionParameter(256));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofExceptionParameter(-1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofExceptionParameter(65536));\n+        assertDoesNotThrow(() -> TypeAnnotation.TypePathComponent.of(TypeAnnotation.TypePathComponent.Kind.ARRAY, 2));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TypePathComponent.of(TypeAnnotation.TypePathComponent.Kind.INNER_TYPE, -1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TypePathComponent.of(TypeAnnotation.TypePathComponent.Kind.TYPE_ARGUMENT, 256));\n+    }\n+\n+    @Test\n+    public void testInnerClasses() {\n+        assertDoesNotThrow(() -> InnerClassInfo.of(CD_Object, Optional.empty(), Optional.empty(), 65535));\n+        assertThrows(IllegalArgumentException.class, () -> InnerClassInfo.of(CD_Object, Optional.empty(), Optional.empty(), -1));\n+        assertThrows(IllegalArgumentException.class, () -> InnerClassInfo.of(ConstantPoolBuilder.of().classEntry(CD_String),\n+                Optional.empty(), Optional.empty(), 65536));\n+    }\n+\n+    @Test\n+    public void testMethodParameter() {\n+        assertDoesNotThrow(() -> MethodParameterInfo.of(Optional.empty(), 65535));\n+        assertThrows(IllegalArgumentException.class, () -> MethodParameterInfo.of(Optional.empty(), -1));\n+        assertThrows(IllegalArgumentException.class, () -> MethodParameterInfo.ofParameter(Optional.empty(), 65536));\n+    }\n+\n+    @Test\n+    public void testModule() {\n+        assertDoesNotThrow(() -> ModuleAttribute.of(ConstantPoolBuilder.of().moduleEntry(ModuleDesc.of(\"java.base\")),\n+                65535, null, List.of(), List.of(), List.of(), List.of(), List.of()));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleAttribute.of(ConstantPoolBuilder.of().moduleEntry(ModuleDesc.of(\"java.base\")),\n+                -1, null, List.of(), List.of(), List.of(), List.of(), List.of()));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleAttribute.of(ConstantPoolBuilder.of().moduleEntry(ModuleDesc.of(\"java.base\")),\n+                65536, null, List.of(), List.of(), List.of(), List.of(), List.of()));\n+        ModuleAttribute.of(ModuleDesc.of(\"java.base\"), b -> {\n+            assertThrows(IllegalArgumentException.class, () -> b.moduleFlags(-1));\n+            assertThrows(IllegalArgumentException.class, () -> b.moduleFlags(65536));\n+            b.moduleFlags(0);\n+        });\n+    }\n+\n+    @Test\n+    public void testModuleExport() {\n+        assertDoesNotThrow(() -> ModuleExportInfo.of(PackageDesc.of(\"java.lang\"), 0));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleExportInfo.of(PackageDesc.of(\"java.lang\"), -1));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleExportInfo.of(PackageDesc.of(\"java.lang\"), 65536));\n+    }\n+\n+    @Test\n+    public void testModuleOpen() {\n+        assertDoesNotThrow(() -> ModuleOpenInfo.of(PackageDesc.of(\"java.lang\"), 0));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleOpenInfo.of(PackageDesc.of(\"java.lang\"), -1));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleOpenInfo.of(PackageDesc.of(\"java.lang\"), 65536));\n+    }\n+\n+    @Test\n+    public void testModuleRequire() {\n+        assertDoesNotThrow(() -> ModuleRequireInfo.of(ModuleDesc.of(\"java.base\"), 0, null));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleRequireInfo.of(ModuleDesc.of(\"java.base\"), -1, null));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleRequireInfo.of(ModuleDesc.of(\"java.base\"), 65536, null));\n+    }\n+\n+    @Test\n+    public void testModuleResolution() {\n+        assertDoesNotThrow(() -> ModuleResolutionAttribute.of(256));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleResolutionAttribute.of(-1));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleResolutionAttribute.of(65536));\n+    }\n+\n+    @Test\n+    public void testMethodHandleEntry() {\n+        ConstantPoolBuilder cp = ConstantPoolBuilder.of();\n+        var ref = cp.fieldRefEntry(CD_String, \"a\", CD_int);\n+        \/\/ Intentionally choose an invalid but representable refKind\n+        assertDoesNotThrow(() -> cp.methodHandleEntry(25, ref));\n+        assertThrows(IllegalArgumentException.class, () -> cp.methodHandleEntry(256, ref));\n+        assertThrows(IllegalArgumentException.class, () -> cp.methodHandleEntry(-1, ref));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/SubIntValidationTest.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @run main\/timeout=480 AddTest\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AddTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n- * @run main TestDockerMemoryMetricsSubgroup\n+ * @run main\/timeout=480 TestDockerMemoryMetricsSubgroup\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestDockerMemoryMetricsSubgroup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run driver TestGetFreeSwapSpaceSize\n+ * @run driver\/timeout=480 TestGetFreeSwapSpaceSize\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestGetFreeSwapSpaceSize.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @run driver TestLimitsUpdating\n+ * @run driver\/timeout=480 TestLimitsUpdating\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestLimitsUpdating.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run driver TestPidsLimit\n+ * @run driver\/timeout=480 TestPidsLimit\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestPidsLimit.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n- * @run main\/othervm   -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480   -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -176,1 +176,1 @@\n- * @run main\/othervm   -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480   -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -196,1 +196,1 @@\n- * @run main\/othervm   -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480   -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/BasicExt.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n- * @run main\/othervm\/timeout=300 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *                               Fuzz\n+ * @run main\/othervm\/timeout=1200 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                                Fuzz\n@@ -54,3 +54,3 @@\n- * @run main\/othervm\/timeout=300 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *                               -XX:+PreserveFramePointer\n- *                               Fuzz\n+ * @run main\/othervm\/timeout=1200 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                                -XX:+PreserveFramePointer\n+ *                                Fuzz\n@@ -87,2 +87,1 @@\n-    static float timeoutFactor = Float.parseFloat(System.getProperty(\"test.timeout.factor\", \"1.0\"));\n-    static int COMPILATION_TIMEOUT = (int)(5_000 * timeoutFactor); \/\/ ms\n+    static int COMPILATION_TIMEOUT = (int)(5_000 * Utils.TIMEOUT_FACTOR); \/\/ ms\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/Fuzz.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * @run main\/othervm -Xlog:jfr+streaming+system=trace jdk.jfr.api.consumer.recordingstream.TestClose\n+ * @run main\/othervm\/timeout=480 -Xlog:jfr+streaming+system=trace jdk.jfr.api.consumer.recordingstream.TestClose\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/recordingstream\/TestClose.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n- * @run main\/othervm -Xlog:jfr=warning jdk.jfr.api.metadata.annotations.TestStackFilter\n+ * @run main\/othervm\/timeout=480 -Xlog:jfr=warning jdk.jfr.api.metadata.annotations.TestStackFilter\n","filename":"test\/jdk\/jdk\/jfr\/api\/metadata\/annotations\/TestStackFilter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-* @run main\/othervm jdk.jfr.event.oldobject.TestEmergencyDumpAtOOM\n+* @run main\/othervm\/timeout=480 jdk.jfr.event.oldobject.TestEmergencyDumpAtOOM\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestEmergencyDumpAtOOM.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n- * @run main\/othervm -XX:TLABSize=2k jdk.jfr.event.oldobject.TestObjectDescription\n+ * @run main\/othervm\/timeout=960 -XX:TLABSize=2k jdk.jfr.event.oldobject.TestObjectDescription\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestObjectDescription.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @run main jdk.jfr.event.profiling.TestCPUTimeSampleMultipleRecordings\n+ * @run main\/timeout=480 jdk.jfr.event.profiling.TestCPUTimeSampleMultipleRecordings\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeSampleMultipleRecordings.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n- * @run main\/othervm jdk.jfr.jvm.TestModularImage\n+ * @run main\/othervm\/timeout=480 jdk.jfr.jvm.TestModularImage\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestModularImage.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Point;\n+import java.awt.color.ColorSpace;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorConvertOp;\n+import java.awt.image.ColorModel;\n+import java.awt.image.SampleModel;\n+import java.awt.image.WritableRaster;\n+import java.io.File;\n+\n+import javax.imageio.ImageIO;\n+\n+import static java.awt.image.BufferedImage.TYPE_3BYTE_BGR;\n+import static java.awt.image.BufferedImage.TYPE_4BYTE_ABGR;\n+import static java.awt.image.BufferedImage.TYPE_4BYTE_ABGR_PRE;\n+import static java.awt.image.BufferedImage.TYPE_INT_ARGB;\n+import static java.awt.image.BufferedImage.TYPE_INT_ARGB_PRE;\n+import static java.awt.image.BufferedImage.TYPE_INT_BGR;\n+import static java.awt.image.BufferedImage.TYPE_INT_RGB;\n+import static java.awt.image.BufferedImage.TYPE_USHORT_GRAY;\n+\n+\/**\n+ * @test\n+ * @bug 8366208\n+ * @summary Verifies ColorConvertOp works correctly with BufferedImage and\n+ *          semi-custom raster\n+ *\/\n+public final class FilterSemiCustomImages {\n+\n+    private static final int W = 144;\n+    private static final int H = 123;\n+\n+    private static final int[] TYPES = {\n+            TYPE_INT_RGB, TYPE_INT_ARGB, TYPE_INT_ARGB_PRE, TYPE_INT_BGR,\n+            TYPE_3BYTE_BGR, TYPE_4BYTE_ABGR, TYPE_4BYTE_ABGR_PRE,\n+            TYPE_USHORT_GRAY\n+    };\n+\n+    private static final int[] CSS = {\n+            ColorSpace.CS_CIEXYZ, ColorSpace.CS_GRAY, ColorSpace.CS_LINEAR_RGB,\n+            ColorSpace.CS_PYCC, ColorSpace.CS_sRGB\n+    };\n+\n+    private static final class CustomRaster extends WritableRaster {\n+        CustomRaster(SampleModel sampleModel, Point origin) {\n+            super(sampleModel, origin);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        for (int fromIndex : CSS) {\n+            for (int toIndex : CSS) {\n+                if (fromIndex != toIndex) {\n+                    for (int type : TYPES) {\n+                        test(fromIndex, toIndex, type);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void test(int fromIndex, int toIndex, int type)\n+            throws Exception\n+    {\n+        ColorSpace fromCS = ColorSpace.getInstance(fromIndex);\n+        ColorSpace toCS = ColorSpace.getInstance(toIndex);\n+        ColorConvertOp op = new ColorConvertOp(fromCS, toCS, null);\n+\n+        \/\/ standard source -> standard dst\n+        BufferedImage srcGold = new BufferedImage(W, H, type);\n+        fill(srcGold);\n+        BufferedImage dstGold = new BufferedImage(W, H, type);\n+        op.filter(srcGold, dstGold);\n+\n+        \/\/ custom source -> standard dst\n+        BufferedImage srcCustom = makeCustomBI(srcGold);\n+        fill(srcCustom);\n+        BufferedImage dst = new BufferedImage(W, H, type);\n+        op.filter(srcCustom, dst);\n+        verify(dstGold, dst);\n+\n+        \/\/ standard source -> custom dst\n+        BufferedImage src = new BufferedImage(W, H, type);\n+        fill(src);\n+        BufferedImage dstCustom = makeCustomBI(dstGold);\n+        op.filter(src, dstCustom);\n+        verify(dstGold, dstCustom);\n+\n+        \/\/ custom source -> custom dst\n+        srcCustom = makeCustomBI(srcGold);\n+        fill(srcCustom);\n+        dstCustom = makeCustomBI(dstGold);\n+        op.filter(srcCustom, dstCustom);\n+        verify(dstGold, dstCustom);\n+    }\n+\n+    private static BufferedImage makeCustomBI(BufferedImage bi) {\n+        ColorModel cm = bi.getColorModel();\n+        SampleModel sm = bi.getSampleModel();\n+        CustomRaster cr = new CustomRaster(sm, new Point());\n+        return new BufferedImage(cm, cr, bi.isAlphaPremultiplied(), null) {\n+            @Override\n+            public int getType() {\n+                return bi.getType();\n+            }\n+        };\n+    }\n+\n+    private static void fill(BufferedImage image) {\n+        int width = image.getWidth();\n+        int height = image.getHeight();\n+        for (int x = 0; x < width; ++x) {\n+            for (int y = 0; y < height; ++y) {\n+                \/\/ alpha channel may be calculated slightly differently on\n+                \/\/ different code paths, so only check fully transparent and\n+                \/\/ fully opaque pixels\n+                Color c = new Color(y * 255 \/ (height - 1),\n+                                    x * 255 \/ (width - 1),\n+                                    x % 255,\n+                                    (x % 2 == 0) ? 0 : 255);\n+                image.setRGB(x, y, c.getRGB());\n+            }\n+        }\n+    }\n+\n+    private static void verify(BufferedImage dstGold, BufferedImage dst)\n+            throws Exception\n+    {\n+        for (int x = 0; x < W; ++x) {\n+            for (int y = 0; y < H; ++y) {\n+                if (dst.getRGB(x, y) != dstGold.getRGB(x, y)) {\n+                    ImageIO.write(dst, \"png\", new File(\"custom.png\"));\n+                    ImageIO.write(dstGold, \"png\", new File(\"gold.png\"));\n+                    throw new RuntimeException(\"Test failed.\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/cmm\/ColorConvertOp\/FilterSemiCustomImages.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.test.lib.Utils;\n","filename":"test\/jdk\/sun\/jvmstat\/monitor\/MonitoredVm\/MonitorVmStartTerminate.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,5 +37,8 @@\n-import java.net.*;\n-import java.util.*;\n-import java.io.*;\n-import javax.net.ssl.*;\n-import java.security.Security;\n+\n+import java.io.PrintStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.net.URL;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n@@ -43,1 +46,4 @@\n-import java.security.KeyFactory;\n+import java.security.SecureRandom;\n+import java.security.Security;\n+import java.security.cert.X509Certificate;\n+\n@@ -45,3 +51,0 @@\n-import java.security.cert.CertificateFactory;\n-import java.security.spec.*;\n-import java.security.interfaces.*;\n@@ -50,355 +53,16 @@\n-\n-\/*\n- * Certificates and key used in the test.\n- *\n- * TLS server certificate:\n- * server private key:\n- * -----BEGIN RSA PRIVATE KEY-----\n- * Proc-Type: 4,ENCRYPTED\n- * DEK-Info: DES-EDE3-CBC,D9AE407F6D0E389A\n- *\n- * WPrA7TFol\/cQCcp9oHnXWNpYlvRbbIcQj0m+RKT2Iuzfus+DHt3Zadf8nJpKfX2e\n- * h2rnhlzCN9M7djRDooZKDOPCsdBn51Au7HlZF3S3Opgo7D8XFM1a8t1Je4ke14oI\n- * nw6QKYsBblRziPnP2PZ0zvX24nOv7bbY8beynlJHGs00VWSFdoH2DS0aE1p6D+3n\n- * ptJuJ75dVfZFK4X7162APlNXevX8D6PEQpSiRw1rjjGGcnvQ4HdWk3BxDVDcCNJb\n- * Y1aGNRxsjTDvPi3R9Qx2M+W03QzEPx4SR3ZHVskeSJHaetM0TM\/w\/45Paq4GokXP\n- * ZeTnbEx1xmjkA7h+t4doLL4watx5F6yLsJzu8xB3lt\/1EtmkYtLz1t7X4BetPAXz\n- * zS69X\/VwhKfsOI3qXBWuL2oHPyhDmT1gcaUQwEPSV6ogHEEQEDXdiUS8heNK13KF\n- * TCQYFkETvV2BLxUhV1hypPzRQ6tUpJiAbD5KmoK2lD9slshG2QtvKQq0\/bgkDY5J\n- * LhDHV2dtcZ3kDPkkZXpbcJQvoeH3d09C5sIsuTFo2zgNR6oETHUc5TzP6FY2YYRa\n- * QcK5HcmtsRRiXFm01ac+aMejJUIujjFt84SiKWT\/73vC8AmY4tYcJBLjCg4XIxSH\n- * fdDFLL1YZENNO5ivlp8mdiHqcawx+36L7DrEZQ8RZt6cqST5t\/+XTdM74s6k81GT\n- * pNsa82P2K2zmIUZ\/DL2mKjW1vfRByw1NQFEBkN3vdyZxYfM\/JyUzX4hbjXBEkh9Q\n- * QYrcwLKLjis2QzSvK04B3bvRzRb+4ocWiso8ZPAXAIxZFBWDpTMM2A==\n- * -----END RSA PRIVATE KEY-----\n- *\n- * -----BEGIN RSA PRIVATE KEY-----\n- * MIICXAIBAAKBgQClrFscN6LdmYktsnm4j9VIpecchBeNaZzGrG358h0fORna03Ie\n- * buxEzHCk3LoAMPagTz1UemFqzFfQCn+VKBg\/mtmU8hvIJIh+\/p0PPftXUwizIDPU\n- * PxdHFNHN6gjYDnVOr77M0uyvqXpJ38LZrLgkQJCmA1Yq0DAFQCxPq9l0iQIDAQAB\n- * AoGAbqcbg1E1mkR99uOJoNeQYKFOJyGiiXTMnXV1TseC4+PDfQBU7Dax35GcesBi\n- * CtapIpFKKS5D+ozY6b7ZT8ojxuQ\/uHLPAvz0WDR3ds4iRF8tyu71Q1ZHcQsJa17y\n- * yO7UbkSSKn\/Mp9Rb+\/dKqftUGNXVFLqgHBOzN2s3We3bbbECQQDYBPKOg3hkaGHo\n- * OhpHKqtQ6EVkldihG\/3i4WejRonelXN+HRh1KrB2HBx0M8D\/qAzP1i3rNSlSHer4\n- * 59YRTJnHAkEAxFX\/sVYSn07BHv9Zhn6XXct\/Cj43z\/tKNbzlNbcxqQwQerw3IH51\n- * 8UH2YOA+GD3lXbKp+MytoFLWv8zg4YT\/LwJAfqan75Z1R6lLffRS49bIiq8jwE16\n- * rTrUJ+kv8jKxMqc9B3vXkxpsS1M\/+4E8bqgAmvpgAb8xcsvHsBd9ErdukQJBAKs2\n- * j67W75BrPjBI34pQ1LEfp56IGWXOrq1kF8IbCjxv3+MYRT6Z6UJFkpRymNPNDjsC\n- * dgUYgITiGJHUGXuw3lMCQHEHqo9ZtXz92yFT+VhsNc29B8m\/sqUJdtCcMd\/jGpAF\n- * u6GHufjqIZBpQsk63wbwESAPZZ+kk1O1kS5GIRLX608=\n- * -----END RSA PRIVATE KEY-----\n- *\n- * Private-Key: (1024 bit)\n- * modulus:\n- *     00:a5:ac:5b:1c:37:a2:dd:99:89:2d:b2:79:b8:8f:\n- *     d5:48:a5:e7:1c:84:17:8d:69:9c:c6:ac:6d:f9:f2:\n- *     1d:1f:39:19:da:d3:72:1e:6e:ec:44:cc:70:a4:dc:\n- *     ba:00:30:f6:a0:4f:3d:54:7a:61:6a:cc:57:d0:0a:\n- *     7f:95:28:18:3f:9a:d9:94:f2:1b:c8:24:88:7e:fe:\n- *     9d:0f:3d:fb:57:53:08:b3:20:33:d4:3f:17:47:14:\n- *     d1:cd:ea:08:d8:0e:75:4e:af:be:cc:d2:ec:af:a9:\n- *     7a:49:df:c2:d9:ac:b8:24:40:90:a6:03:56:2a:d0:\n- *     30:05:40:2c:4f:ab:d9:74:89\n- * publicExponent: 65537 (0x10001)\n- * privateExponent:\n- *     6e:a7:1b:83:51:35:9a:44:7d:f6:e3:89:a0:d7:90:\n- *     60:a1:4e:27:21:a2:89:74:cc:9d:75:75:4e:c7:82:\n- *     e3:e3:c3:7d:00:54:ec:36:b1:df:91:9c:7a:c0:62:\n- *     0a:d6:a9:22:91:4a:29:2e:43:fa:8c:d8:e9:be:d9:\n- *     4f:ca:23:c6:e4:3f:b8:72:cf:02:fc:f4:58:34:77:\n- *     76:ce:22:44:5f:2d:ca:ee:f5:43:56:47:71:0b:09:\n- *     6b:5e:f2:c8:ee:d4:6e:44:92:2a:7f:cc:a7:d4:5b:\n- *     fb:f7:4a:a9:fb:54:18:d5:d5:14:ba:a0:1c:13:b3:\n- *     37:6b:37:59:ed:db:6d:b1\n- * prime1:\n- *     00:d8:04:f2:8e:83:78:64:68:61:e8:3a:1a:47:2a:\n- *     ab:50:e8:45:64:95:d8:a1:1b:fd:e2:e1:67:a3:46:\n- *     89:de:95:73:7e:1d:18:75:2a:b0:76:1c:1c:74:33:\n- *     c0:ff:a8:0c:cf:d6:2d:eb:35:29:52:1d:ea:f8:e7:\n- *     d6:11:4c:99:c7\n- * prime2:\n- *     00:c4:55:ff:b1:56:12:9f:4e:c1:1e:ff:59:86:7e:\n- *     97:5d:cb:7f:0a:3e:37:cf:fb:4a:35:bc:e5:35:b7:\n- *     31:a9:0c:10:7a:bc:37:20:7e:75:f1:41:f6:60:e0:\n- *     3e:18:3d:e5:5d:b2:a9:f8:cc:ad:a0:52:d6:bf:cc:\n- *     e0:e1:84:ff:2f\n- * exponent1:\n- *     7e:a6:a7:ef:96:75:47:a9:4b:7d:f4:52:e3:d6:c8:\n- *     8a:af:23:c0:4d:7a:ad:3a:d4:27:e9:2f:f2:32:b1:\n- *     32:a7:3d:07:7b:d7:93:1a:6c:4b:53:3f:fb:81:3c:\n- *     6e:a8:00:9a:fa:60:01:bf:31:72:cb:c7:b0:17:7d:\n- *     12:b7:6e:91\n- * exponent2:\n- *     00:ab:36:8f:ae:d6:ef:90:6b:3e:30:48:df:8a:50:\n- *     d4:b1:1f:a7:9e:88:19:65:ce:ae:ad:64:17:c2:1b:\n- *     0a:3c:6f:df:e3:18:45:3e:99:e9:42:45:92:94:72:\n- *     98:d3:cd:0e:3b:02:76:05:18:80:84:e2:18:91:d4:\n- *     19:7b:b0:de:53\n- * coefficient:\n- *     71:07:aa:8f:59:b5:7c:fd:db:21:53:f9:58:6c:35:\n- *     cd:bd:07:c9:bf:b2:a5:09:76:d0:9c:31:df:e3:1a:\n- *     90:05:bb:a1:87:b9:f8:ea:21:90:69:42:c9:3a:df:\n- *     06:f0:11:20:0f:65:9f:a4:93:53:b5:91:2e:46:21:\n- *     12:d7:eb:4f\n- *\n- *\n- * server certificate:\n- * Data:\n- *     Version: 3 (0x2)\n- *     Serial Number: 7 (0x7)\n- *     Signature Algorithm: md5WithRSAEncryption\n- *     Issuer: C=US, ST=Some-State, L=Some-City, O=Some-Org\n- *     Validity\n- *         Not Before: Dec  8 03:27:57 2008 GMT\n- *         Not After : Aug 25 03:27:57 2028 GMT\n- *     Subject: C=US, ST=Some-State, L=Some-City, O=Some-Org, OU=SSL-Server, CN=localhost\n- *     Subject Public Key Info:\n- *         Public Key Algorithm: rsaEncryption\n- *         RSA Public Key: (1024 bit)\n- *             Modulus (1024 bit):\n- *                 00:a5:ac:5b:1c:37:a2:dd:99:89:2d:b2:79:b8:8f:\n- *                 d5:48:a5:e7:1c:84:17:8d:69:9c:c6:ac:6d:f9:f2:\n- *                 1d:1f:39:19:da:d3:72:1e:6e:ec:44:cc:70:a4:dc:\n- *                 ba:00:30:f6:a0:4f:3d:54:7a:61:6a:cc:57:d0:0a:\n- *                 7f:95:28:18:3f:9a:d9:94:f2:1b:c8:24:88:7e:fe:\n- *                 9d:0f:3d:fb:57:53:08:b3:20:33:d4:3f:17:47:14:\n- *                 d1:cd:ea:08:d8:0e:75:4e:af:be:cc:d2:ec:af:a9:\n- *                 7a:49:df:c2:d9:ac:b8:24:40:90:a6:03:56:2a:d0:\n- *                 30:05:40:2c:4f:ab:d9:74:89\n- *             Exponent: 65537 (0x10001)\n- *     X509v3 extensions:\n- *         X509v3 Basic Constraints:\n- *             CA:FALSE\n- *         X509v3 Key Usage:\n- *             Digital Signature, Non Repudiation, Key Encipherment\n- *         X509v3 Subject Key Identifier:\n- *             ED:6E:DB:F4:B5:56:C8:FB:1A:06:61:3F:0F:08:BB:A6:04:D8:16:54\n- *         X509v3 Authority Key Identifier:\n- *             keyid:FA:B9:51:BF:4C:E7:D9:86:98:33:F9:E7:CB:1E:F1:33:49:F7:A8:14\n- *\n- *         X509v3 Subject Alternative Name: critical\n- *             IP Address:127.0.0.1\n- * Signature Algorithm: md5WithRSAEncryption\n- *\n- * -----BEGIN CERTIFICATE-----\n- * MIICnzCCAgigAwIBAgIBBzANBgkqhkiG9w0BAQQFADBJMQswCQYDVQQGEwJVUzET\n- * MBEGA1UECBMKU29tZS1TdGF0ZTESMBAGA1UEBxMJU29tZS1DaXR5MREwDwYDVQQK\n- * EwhTb21lLU9yZzAeFw0wODEyMDgwMzI3NTdaFw0yODA4MjUwMzI3NTdaMHIxCzAJ\n- * BgNVBAYTAlVTMRMwEQYDVQQIEwpTb21lLVN0YXRlMRIwEAYDVQQHEwlTb21lLUNp\n- * dHkxETAPBgNVBAoTCFNvbWUtT3JnMRMwEQYDVQQLEwpTU0wtU2VydmVyMRIwEAYD\n- * VQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAKWsWxw3\n- * ot2ZiS2yebiP1Uil5xyEF41pnMasbfnyHR85GdrTch5u7ETMcKTcugAw9qBPPVR6\n- * YWrMV9AKf5UoGD+a2ZTyG8gkiH7+nQ89+1dTCLMgM9Q\/F0cU0c3qCNgOdU6vvszS\n- * 7K+peknfwtmsuCRAkKYDVirQMAVALE+r2XSJAgMBAAGjbjBsMAkGA1UdEwQCMAAw\n- * CwYDVR0PBAQDAgXgMB0GA1UdDgQWBBTtbtv0tVbI+xoGYT8PCLumBNgWVDAfBgNV\n- * HSMEGDAWgBT6uVG\/TOfZhpgz+efLHvEzSfeoFDASBgNVHREBAf8ECDAGhwR\/AAAB\n- * MA0GCSqGSIb3DQEBBAUAA4GBAFJjItCtCBZcjD69wdqfIbKmRFa6eJAjR6LcoDva\n- * cKC\/sDOLelpspiZ66Zb0Xdv5qQ7QrfOXt3K8QqJKRMdZLF9WfUfy0gJDM32ub91h\n- * pu+TmcGPs+6RdrAQcuvU1ZDV9X8SMj7BtKaim4d5sqFw1npncKiA5xFn8vOYwdun\n- * nZif\n- * -----END CERTIFICATE-----\n- *\n- *\n- * TLS client certificate:\n- * client private key:\n- * ----BEGIN RSA PRIVATE KEY-----\n- * Proc-Type: 4,ENCRYPTED\n- * DEK-Info: DES-EDE3-CBC,FA2A435CD35A9390\n- *\n- * Z+Y2uaETbsUWIyJUyVu1UV2G4rgFYJyACZT6Tp1KjRtxflSh2kXkJ9MpuXMXA0V4\n- * Yy3fDzPqCL9NJmQAYRlAx\/W\/+j4F5EyMWDIx8fUxzONRZyoiwF7jLm+KscAfv6Pf\n- * q7ItWOdj3z7IYrwlB8YIGd3F2cDKT3S+lYRk7rKb\/qT7itbuHnY4Ardh3yl+MZak\n- * jBp+ELUlRsUqSr1V0LoM+0rCCykarpyfhpxEcqsrl0v9Cyi5uhU50\/oKv5zql3SH\n- * l2ImgDjp3batAs8+Bd4NF2aqi0a7Hy44JUHxRm4caZryU\/i\/D9N1MbuM6882HLat\n- * 5N0G+NaIUfywa8mjwq2D5aiit18HqKA6XeRRYeJ5Dvu9DCO4GeFSwcUFIBMI0L46\n- * 7s114+oDodg57pMgITi+04vmUxvqlN9aiyd7f5Fgd7PeHGeOdbMz1NaJLJaPI9++\n- * NakK8eK9iwT\/Gdq0Uap5\/CHW7vCT5PO+h3HY0STH0lWStXhdWnFO04zTdywsbSp+\n- * DLpHeFT66shfeUlxR0PsCbG9vPRt\/QmGLeYQZITppWo\/ylSq4j+pRIuXvuWHdBRN\n- * rTZ8QF4Y7AxQUXVz1j1++s6ZMHTzaK2i9HrhmDs1MbJl+QwWre3Xpv3LvTVz3k5U\n- * wX8kuY1m3STt71QCaRWENq5sRaMImLxZbxc\/ivFl9RAzUqo4NCxLod\/QgA4iLqtO\n- * ztnlpzwlC\/F8HbQ1oqYWwnZAPhzU\/cULtstl+Yrws2c2atO323LbPXZqbASySgig\n- * sNpFXQMObdfP6LN23bY+1SvtK7V4NUTNhpdIc6INQAQ=\n- * -----END RSA PRIVATE KEY-----\n- *\n- * -----BEGIN RSA PRIVATE KEY-----\n- * MIICWwIBAAKBgQC78EA2rCZUTvSjWgAvaSFvuXo6k+yi9uGOx2PYLxIwmS6w8o\/4\n- * Jy0keCiE9wG\/jUR53TvSVfPOPLJbIX3v\/TNKsaP\/xsibuQ98QTWX+ds6BWAFFa9Z\n- * F5KjEK0WHOQHU6+odqJWKpLT+SjgeM9eH0irXBnd4WdDunWN9YKsQ5JEGwIDAQAB\n- * AoGAEbdqNj0wN85hnWyEi\/ObJU8UyKTdL9eaF72QGfcF\/fLSxfd3vurihIeXOkGW\n- * tpn4lIxYcVGM9CognhqgJpl11jFTQzn1KqZ+NEJRKkCHA4hDabKJbSC9fXHvRwrf\n- * BsFpZqgiNxp3HseUTiwnaUVeyPgMt\/jAj5nB5Sib+UyUxrECQQDnNQBiF2aifEg6\n- * zbJOOC7he5CHAdkFxSxWVFVHL6EfXfqdLVkUohMbgZv+XxyIeU2biOExSg49Kds3\n- * FOKgTau1AkEA0Bd1haj6QuCo8I0AXm2WO+MMTZMTvtHD\/bGjKNM+fT4I8rKYnQRX\n- * 1acHdqS9Xx2rNJqZgkMmpESIdPR2fc4yjwJALFeM6EMmqvj8\/VIf5UJ\/Mz14fXwM\n- * PEARfckUxd9LnnFutCBTWlKvKXJVEZb6KO5ixPaegc57Jp3Vbh3yTN44lQJADD\/1\n- * SSMDaIB1MYP7a5Oj7m6VQNPRq8AJe5vDcRnOae0G9dKRrVyeFxO4GsHj6\/+BHp2j\n- * P8nYMn9eURQ7DXjf\/QJAAQzMlWnKGSO8pyTDtnQx3hRMoUkOEhmNq4bQhLkYqtnY\n- * FcqpUQ2qMjW+NiNWk5HnTrMS3L9EdJobMUzaNZLy4w==\n- * -----END RSA PRIVATE KEY-----\n- *\n- * Private-Key: (1024 bit)\n- * modulus:\n- *     00:bb:f0:40:36:ac:26:54:4e:f4:a3:5a:00:2f:69:\n- *     21:6f:b9:7a:3a:93:ec:a2:f6:e1:8e:c7:63:d8:2f:\n- *     12:30:99:2e:b0:f2:8f:f8:27:2d:24:78:28:84:f7:\n- *     01:bf:8d:44:79:dd:3b:d2:55:f3:ce:3c:b2:5b:21:\n- *     7d:ef:fd:33:4a:b1:a3:ff:c6:c8:9b:b9:0f:7c:41:\n- *     35:97:f9:db:3a:05:60:05:15:af:59:17:92:a3:10:\n- *     ad:16:1c:e4:07:53:af:a8:76:a2:56:2a:92:d3:f9:\n- *     28:e0:78:cf:5e:1f:48:ab:5c:19:dd:e1:67:43:ba:\n- *     75:8d:f5:82:ac:43:92:44:1b\n- * publicExponent: 65537 (0x10001)\n- * privateExponent:\n- *     11:b7:6a:36:3d:30:37:ce:61:9d:6c:84:8b:f3:9b:\n- *     25:4f:14:c8:a4:dd:2f:d7:9a:17:bd:90:19:f7:05:\n- *     fd:f2:d2:c5:f7:77:be:ea:e2:84:87:97:3a:41:96:\n- *     b6:99:f8:94:8c:58:71:51:8c:f4:2a:20:9e:1a:a0:\n- *     26:99:75:d6:31:53:43:39:f5:2a:a6:7e:34:42:51:\n- *     2a:40:87:03:88:43:69:b2:89:6d:20:bd:7d:71:ef:\n- *     47:0a:df:06:c1:69:66:a8:22:37:1a:77:1e:c7:94:\n- *     4e:2c:27:69:45:5e:c8:f8:0c:b7:f8:c0:8f:99:c1:\n- *     e5:28:9b:f9:4c:94:c6:b1\n- * prime1:\n- *     00:e7:35:00:62:17:66:a2:7c:48:3a:cd:b2:4e:38:\n- *     2e:e1:7b:90:87:01:d9:05:c5:2c:56:54:55:47:2f:\n- *     a1:1f:5d:fa:9d:2d:59:14:a2:13:1b:81:9b:fe:5f:\n- *     1c:88:79:4d:9b:88:e1:31:4a:0e:3d:29:db:37:14:\n- *     e2:a0:4d:ab:b5\n- * prime2:\n- *     00:d0:17:75:85:a8:fa:42:e0:a8:f0:8d:00:5e:6d:\n- *     96:3b:e3:0c:4d:93:13:be:d1:c3:fd:b1:a3:28:d3:\n- *     3e:7d:3e:08:f2:b2:98:9d:04:57:d5:a7:07:76:a4:\n- *     bd:5f:1d:ab:34:9a:99:82:43:26:a4:44:88:74:f4:\n- *     76:7d:ce:32:8f\n- * exponent1:\n- *     2c:57:8c:e8:43:26:aa:f8:fc:fd:52:1f:e5:42:7f:\n- *     33:3d:78:7d:7c:0c:3c:40:11:7d:c9:14:c5:df:4b:\n- *     9e:71:6e:b4:20:53:5a:52:af:29:72:55:11:96:fa:\n- *     28:ee:62:c4:f6:9e:81:ce:7b:26:9d:d5:6e:1d:f2:\n- *     4c:de:38:95\n- * exponent2:\n- *     0c:3f:f5:49:23:03:68:80:75:31:83:fb:6b:93:a3:\n- *     ee:6e:95:40:d3:d1:ab:c0:09:7b:9b:c3:71:19:ce:\n- *     69:ed:06:f5:d2:91:ad:5c:9e:17:13:b8:1a:c1:e3:\n- *     eb:ff:81:1e:9d:a3:3f:c9:d8:32:7f:5e:51:14:3b:\n- *     0d:78:df:fd\n- * coefficient:\n- *     01:0c:cc:95:69:ca:19:23:bc:a7:24:c3:b6:74:31:\n- *     de:14:4c:a1:49:0e:12:19:8d:ab:86:d0:84:b9:18:\n- *     aa:d9:d8:15:ca:a9:51:0d:aa:32:35:be:36:23:56:\n- *     93:91:e7:4e:b3:12:dc:bf:44:74:9a:1b:31:4c:da:\n- *     35:92:f2:e3\n- *\n- * client certificate:\n- * Data:\n- *     Version: 3 (0x2)\n- *     Serial Number: 6 (0x6)\n- *     Signature Algorithm: md5WithRSAEncryption\n- *     Issuer: C=US, ST=Some-State, L=Some-City, O=Some-Org\n- *     Validity\n- *         Not Before: Dec  8 03:27:34 2008 GMT\n- *         Not After : Aug 25 03:27:34 2028 GMT\n- *     Subject: C=US, ST=Some-State, L=Some-City, O=Some-Org, OU=SSL-Client, CN=localhost\n- *     Subject Public Key Info:\n- *         Public Key Algorithm: rsaEncryption\n- *         RSA Public Key: (1024 bit)\n- *             Modulus (1024 bit):\n- *                 00:bb:f0:40:36:ac:26:54:4e:f4:a3:5a:00:2f:69:\n- *                 21:6f:b9:7a:3a:93:ec:a2:f6:e1:8e:c7:63:d8:2f:\n- *                 12:30:99:2e:b0:f2:8f:f8:27:2d:24:78:28:84:f7:\n- *                 01:bf:8d:44:79:dd:3b:d2:55:f3:ce:3c:b2:5b:21:\n- *                 7d:ef:fd:33:4a:b1:a3:ff:c6:c8:9b:b9:0f:7c:41:\n- *                 35:97:f9:db:3a:05:60:05:15:af:59:17:92:a3:10:\n- *                 ad:16:1c:e4:07:53:af:a8:76:a2:56:2a:92:d3:f9:\n- *                 28:e0:78:cf:5e:1f:48:ab:5c:19:dd:e1:67:43:ba:\n- *                 75:8d:f5:82:ac:43:92:44:1b\n- *             Exponent: 65537 (0x10001)\n- *     X509v3 extensions:\n- *         X509v3 Basic Constraints:\n- *             CA:FALSE\n- *         X509v3 Key Usage:\n- *             Digital Signature, Non Repudiation, Key Encipherment\n- *         X509v3 Subject Key Identifier:\n- *             CD:BB:C8:85:AA:91:BD:FD:1D:BE:CD:67:7C:FF:B3:E9:4C:A8:22:E6\n- *         X509v3 Authority Key Identifier:\n- *             keyid:FA:B9:51:BF:4C:E7:D9:86:98:33:F9:E7:CB:1E:F1:33:49:F7:A8:14\n- *\n- *         X509v3 Subject Alternative Name: critical\n- *             IP Address:127.0.0.1\n- * Signature Algorithm: md5WithRSAEncryption\n- *\n- * -----BEGIN CERTIFICATE-----\n- * MIICnzCCAgigAwIBAgIBBjANBgkqhkiG9w0BAQQFADBJMQswCQYDVQQGEwJVUzET\n- * MBEGA1UECBMKU29tZS1TdGF0ZTESMBAGA1UEBxMJU29tZS1DaXR5MREwDwYDVQQK\n- * EwhTb21lLU9yZzAeFw0wODEyMDgwMzI3MzRaFw0yODA4MjUwMzI3MzRaMHIxCzAJ\n- * BgNVBAYTAlVTMRMwEQYDVQQIEwpTb21lLVN0YXRlMRIwEAYDVQQHEwlTb21lLUNp\n- * dHkxETAPBgNVBAoTCFNvbWUtT3JnMRMwEQYDVQQLEwpTU0wtQ2xpZW50MRIwEAYD\n- * VQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBALvwQDas\n- * JlRO9KNaAC9pIW+5ejqT7KL24Y7HY9gvEjCZLrDyj\/gnLSR4KIT3Ab+NRHndO9JV\n- * 8848slshfe\/9M0qxo\/\/GyJu5D3xBNZf52zoFYAUVr1kXkqMQrRYc5AdTr6h2olYq\n- * ktP5KOB4z14fSKtcGd3hZ0O6dY31gqxDkkQbAgMBAAGjbjBsMAkGA1UdEwQCMAAw\n- * CwYDVR0PBAQDAgXgMB0GA1UdDgQWBBTNu8iFqpG9\/R2+zWd8\/7PpTKgi5jAfBgNV\n- * HSMEGDAWgBT6uVG\/TOfZhpgz+efLHvEzSfeoFDASBgNVHREBAf8ECDAGhwR\/AAAB\n- * MA0GCSqGSIb3DQEBBAUAA4GBACjj9PS+W6XOF7toFMwMOv\/AemZeBOpcEF1Ei1Hx\n- * HjvB6EOHkMY8tFm5OPzkiWiK3+s3awpSW0jWdzMYwrQJ3\/klMsPDpI7PEuirqwHP\n- * i5Wyl\/vk7jmfWVcBO9MVhPUo4BYl4vS9aj6JA5QbkbkB95LOgT\/BowY0WmHeVsXC\n- * I9aw\n- * -----END CERTIFICATE-----\n- *\n- *\n- *\n- * Trusted CA certificate:\n- * Certificate:\n- *   Data:\n- *     Version: 3 (0x2)\n- *     Serial Number: 0 (0x0)\n- *     Signature Algorithm: md5WithRSAEncryption\n- *     Issuer: C=US, ST=Some-State, L=Some-City, O=Some-Org\n- *     Validity\n- *         Not Before: Dec  8 02:43:36 2008 GMT\n- *         Not After : Aug 25 02:43:36 2028 GMT\n- *     Subject: C=US, ST=Some-State, L=Some-City, O=Some-Org\n- *     Subject Public Key Info:\n- *         Public Key Algorithm: rsaEncryption\n- *         RSA Public Key: (1024 bit)\n- *             Modulus (1024 bit):\n- *                 00:cb:c4:38:20:07:be:88:a7:93:b0:a1:43:51:2d:\n- *                 d7:8e:85:af:54:dd:ad:a2:7b:23:5b:cf:99:13:53:\n- *                 99:45:7d:ee:6d:ba:2d:bf:e3:ad:6e:3d:9f:1a:f9:\n- *                 03:97:e0:17:55:ae:11:26:57:de:01:29:8e:05:3f:\n- *                 21:f7:e7:36:e8:2e:37:d7:48:ac:53:d6:60:0e:c7:\n- *                 50:6d:f6:c5:85:f7:8b:a6:c5:91:35:72:3c:94:ee:\n- *                 f1:17:f0:71:e3:ec:1b:ce:ca:4e:40:42:b0:6d:ee:\n- *                 6a:0e:d6:e5:ad:3c:0f:c9:ba:82:4f:78:f8:89:97:\n- *                 89:2a:95:12:4c:d8:09:2a:e9\n- *             Exponent: 65537 (0x10001)\n- *     X509v3 extensions:\n- *         X509v3 Subject Key Identifier:\n- *             FA:B9:51:BF:4C:E7:D9:86:98:33:F9:E7:CB:1E:F1:33:49:F7:A8:14\n- *         X509v3 Authority Key Identifier:\n- *             keyid:FA:B9:51:BF:4C:E7:D9:86:98:33:F9:E7:CB:1E:F1:33:49:F7:A8:14\n- *             DirName:\/C=US\/ST=Some-State\/L=Some-City\/O=Some-Org\n- *             serial:00\n- *\n- *         X509v3 Basic Constraints:\n- *             CA:TRUE\n- *  Signature Algorithm: md5WithRSAEncryption\n- *\n- * -----BEGIN CERTIFICATE-----\n- * MIICrDCCAhWgAwIBAgIBADANBgkqhkiG9w0BAQQFADBJMQswCQYDVQQGEwJVUzET\n- * MBEGA1UECBMKU29tZS1TdGF0ZTESMBAGA1UEBxMJU29tZS1DaXR5MREwDwYDVQQK\n- * EwhTb21lLU9yZzAeFw0wODEyMDgwMjQzMzZaFw0yODA4MjUwMjQzMzZaMEkxCzAJ\n- * BgNVBAYTAlVTMRMwEQYDVQQIEwpTb21lLVN0YXRlMRIwEAYDVQQHEwlTb21lLUNp\n- * dHkxETAPBgNVBAoTCFNvbWUtT3JnMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKB\n- * gQDLxDggB76Ip5OwoUNRLdeOha9U3a2ieyNbz5kTU5lFfe5tui2\/461uPZ8a+QOX\n- * 4BdVrhEmV94BKY4FPyH35zboLjfXSKxT1mAOx1Bt9sWF94umxZE1cjyU7vEX8HHj\n- * 7BvOyk5AQrBt7moO1uWtPA\/JuoJPePiJl4kqlRJM2Akq6QIDAQABo4GjMIGgMB0G\n- * A1UdDgQWBBT6uVG\/TOfZhpgz+efLHvEzSfeoFDBxBgNVHSMEajBogBT6uVG\/TOfZ\n- * hpgz+efLHvEzSfeoFKFNpEswSTELMAkGA1UEBhMCVVMxEzARBgNVBAgTClNvbWUt\n- * U3RhdGUxEjAQBgNVBAcTCVNvbWUtQ2l0eTERMA8GA1UEChMIU29tZS1PcmeCAQAw\n- * DAYDVR0TBAUwAwEB\/zANBgkqhkiG9w0BAQQFAAOBgQBcIm534U123Hz+rtyYO5uA\n- * ofd81G6FnTfEAV8Kw9fGyyEbQZclBv34A9JsFKeMvU4OFIaixD7nLZ\/NZ+IWbhmZ\n- * LovmJXyCkOufea73pNiZ+f\/4\/ScZaIlM\/PRycQSqbFNd4j9Wott+08qxHPLpsf3P\n- * 6Mvf0r1PNTY2hwTJLJmKtg==\n- * -----END CERTIFICATE---\n- *\/\n+import jdk.test.lib.security.CertificateBuilder;\n+import jdk.test.lib.security.CertificateBuilder.KeyUsage;\n+import sun.security.x509.AuthorityKeyIdentifierExtension;\n+import sun.security.x509.GeneralName;\n+import sun.security.x509.GeneralNames;\n+import sun.security.x509.KeyIdentifier;\n+import sun.security.x509.SerialNumber;\n+import sun.security.x509.X500Name;\n+\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n@@ -408,2 +72,0 @@\n-    static Map cookies;\n-    ServerSocket ss;\n@@ -424,202 +86,8 @@\n-    \/*\n-     * Where do we find the keystores?\n-     *\/\n-    static String trusedCertStr =\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIICrDCCAhWgAwIBAgIBADANBgkqhkiG9w0BAQQFADBJMQswCQYDVQQGEwJVUzET\\n\" +\n-        \"MBEGA1UECBMKU29tZS1TdGF0ZTESMBAGA1UEBxMJU29tZS1DaXR5MREwDwYDVQQK\\n\" +\n-        \"EwhTb21lLU9yZzAeFw0wODEyMDgwMjQzMzZaFw0yODA4MjUwMjQzMzZaMEkxCzAJ\\n\" +\n-        \"BgNVBAYTAlVTMRMwEQYDVQQIEwpTb21lLVN0YXRlMRIwEAYDVQQHEwlTb21lLUNp\\n\" +\n-        \"dHkxETAPBgNVBAoTCFNvbWUtT3JnMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKB\\n\" +\n-        \"gQDLxDggB76Ip5OwoUNRLdeOha9U3a2ieyNbz5kTU5lFfe5tui2\/461uPZ8a+QOX\\n\" +\n-        \"4BdVrhEmV94BKY4FPyH35zboLjfXSKxT1mAOx1Bt9sWF94umxZE1cjyU7vEX8HHj\\n\" +\n-        \"7BvOyk5AQrBt7moO1uWtPA\/JuoJPePiJl4kqlRJM2Akq6QIDAQABo4GjMIGgMB0G\\n\" +\n-        \"A1UdDgQWBBT6uVG\/TOfZhpgz+efLHvEzSfeoFDBxBgNVHSMEajBogBT6uVG\/TOfZ\\n\" +\n-        \"hpgz+efLHvEzSfeoFKFNpEswSTELMAkGA1UEBhMCVVMxEzARBgNVBAgTClNvbWUt\\n\" +\n-        \"U3RhdGUxEjAQBgNVBAcTCVNvbWUtQ2l0eTERMA8GA1UEChMIU29tZS1PcmeCAQAw\\n\" +\n-        \"DAYDVR0TBAUwAwEB\/zANBgkqhkiG9w0BAQQFAAOBgQBcIm534U123Hz+rtyYO5uA\\n\" +\n-        \"ofd81G6FnTfEAV8Kw9fGyyEbQZclBv34A9JsFKeMvU4OFIaixD7nLZ\/NZ+IWbhmZ\\n\" +\n-        \"LovmJXyCkOufea73pNiZ+f\/4\/ScZaIlM\/PRycQSqbFNd4j9Wott+08qxHPLpsf3P\\n\" +\n-        \"6Mvf0r1PNTY2hwTJLJmKtg==\\n\" +\n-        \"-----END CERTIFICATE-----\";\n-\n-    static String serverCertStr =\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIICnzCCAgigAwIBAgIBBzANBgkqhkiG9w0BAQQFADBJMQswCQYDVQQGEwJVUzET\\n\" +\n-        \"MBEGA1UECBMKU29tZS1TdGF0ZTESMBAGA1UEBxMJU29tZS1DaXR5MREwDwYDVQQK\\n\" +\n-        \"EwhTb21lLU9yZzAeFw0wODEyMDgwMzI3NTdaFw0yODA4MjUwMzI3NTdaMHIxCzAJ\\n\" +\n-        \"BgNVBAYTAlVTMRMwEQYDVQQIEwpTb21lLVN0YXRlMRIwEAYDVQQHEwlTb21lLUNp\\n\" +\n-        \"dHkxETAPBgNVBAoTCFNvbWUtT3JnMRMwEQYDVQQLEwpTU0wtU2VydmVyMRIwEAYD\\n\" +\n-        \"VQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAKWsWxw3\\n\" +\n-        \"ot2ZiS2yebiP1Uil5xyEF41pnMasbfnyHR85GdrTch5u7ETMcKTcugAw9qBPPVR6\\n\" +\n-        \"YWrMV9AKf5UoGD+a2ZTyG8gkiH7+nQ89+1dTCLMgM9Q\/F0cU0c3qCNgOdU6vvszS\\n\" +\n-        \"7K+peknfwtmsuCRAkKYDVirQMAVALE+r2XSJAgMBAAGjbjBsMAkGA1UdEwQCMAAw\\n\" +\n-        \"CwYDVR0PBAQDAgXgMB0GA1UdDgQWBBTtbtv0tVbI+xoGYT8PCLumBNgWVDAfBgNV\\n\" +\n-        \"HSMEGDAWgBT6uVG\/TOfZhpgz+efLHvEzSfeoFDASBgNVHREBAf8ECDAGhwR\/AAAB\\n\" +\n-        \"MA0GCSqGSIb3DQEBBAUAA4GBAFJjItCtCBZcjD69wdqfIbKmRFa6eJAjR6LcoDva\\n\" +\n-        \"cKC\/sDOLelpspiZ66Zb0Xdv5qQ7QrfOXt3K8QqJKRMdZLF9WfUfy0gJDM32ub91h\\n\" +\n-        \"pu+TmcGPs+6RdrAQcuvU1ZDV9X8SMj7BtKaim4d5sqFw1npncKiA5xFn8vOYwdun\\n\" +\n-        \"nZif\\n\" +\n-        \"-----END CERTIFICATE-----\";\n-\n-    static String clientCertStr =\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIICnzCCAgigAwIBAgIBBjANBgkqhkiG9w0BAQQFADBJMQswCQYDVQQGEwJVUzET\\n\" +\n-        \"MBEGA1UECBMKU29tZS1TdGF0ZTESMBAGA1UEBxMJU29tZS1DaXR5MREwDwYDVQQK\\n\" +\n-        \"EwhTb21lLU9yZzAeFw0wODEyMDgwMzI3MzRaFw0yODA4MjUwMzI3MzRaMHIxCzAJ\\n\" +\n-        \"BgNVBAYTAlVTMRMwEQYDVQQIEwpTb21lLVN0YXRlMRIwEAYDVQQHEwlTb21lLUNp\\n\" +\n-        \"dHkxETAPBgNVBAoTCFNvbWUtT3JnMRMwEQYDVQQLEwpTU0wtQ2xpZW50MRIwEAYD\\n\" +\n-        \"VQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBALvwQDas\\n\" +\n-        \"JlRO9KNaAC9pIW+5ejqT7KL24Y7HY9gvEjCZLrDyj\/gnLSR4KIT3Ab+NRHndO9JV\\n\" +\n-        \"8848slshfe\/9M0qxo\/\/GyJu5D3xBNZf52zoFYAUVr1kXkqMQrRYc5AdTr6h2olYq\\n\" +\n-        \"ktP5KOB4z14fSKtcGd3hZ0O6dY31gqxDkkQbAgMBAAGjbjBsMAkGA1UdEwQCMAAw\\n\" +\n-        \"CwYDVR0PBAQDAgXgMB0GA1UdDgQWBBTNu8iFqpG9\/R2+zWd8\/7PpTKgi5jAfBgNV\\n\" +\n-        \"HSMEGDAWgBT6uVG\/TOfZhpgz+efLHvEzSfeoFDASBgNVHREBAf8ECDAGhwR\/AAAB\\n\" +\n-        \"MA0GCSqGSIb3DQEBBAUAA4GBACjj9PS+W6XOF7toFMwMOv\/AemZeBOpcEF1Ei1Hx\\n\" +\n-        \"HjvB6EOHkMY8tFm5OPzkiWiK3+s3awpSW0jWdzMYwrQJ3\/klMsPDpI7PEuirqwHP\\n\" +\n-        \"i5Wyl\/vk7jmfWVcBO9MVhPUo4BYl4vS9aj6JA5QbkbkB95LOgT\/BowY0WmHeVsXC\\n\" +\n-        \"I9aw\\n\" +\n-        \"-----END CERTIFICATE-----\";\n-\n-\n-    static byte serverPrivateExponent[] = {\n-        (byte)0x6e, (byte)0xa7, (byte)0x1b, (byte)0x83,\n-        (byte)0x51, (byte)0x35, (byte)0x9a, (byte)0x44,\n-        (byte)0x7d, (byte)0xf6, (byte)0xe3, (byte)0x89,\n-        (byte)0xa0, (byte)0xd7, (byte)0x90, (byte)0x60,\n-        (byte)0xa1, (byte)0x4e, (byte)0x27, (byte)0x21,\n-        (byte)0xa2, (byte)0x89, (byte)0x74, (byte)0xcc,\n-        (byte)0x9d, (byte)0x75, (byte)0x75, (byte)0x4e,\n-        (byte)0xc7, (byte)0x82, (byte)0xe3, (byte)0xe3,\n-        (byte)0xc3, (byte)0x7d, (byte)0x00, (byte)0x54,\n-        (byte)0xec, (byte)0x36, (byte)0xb1, (byte)0xdf,\n-        (byte)0x91, (byte)0x9c, (byte)0x7a, (byte)0xc0,\n-        (byte)0x62, (byte)0x0a, (byte)0xd6, (byte)0xa9,\n-        (byte)0x22, (byte)0x91, (byte)0x4a, (byte)0x29,\n-        (byte)0x2e, (byte)0x43, (byte)0xfa, (byte)0x8c,\n-        (byte)0xd8, (byte)0xe9, (byte)0xbe, (byte)0xd9,\n-        (byte)0x4f, (byte)0xca, (byte)0x23, (byte)0xc6,\n-        (byte)0xe4, (byte)0x3f, (byte)0xb8, (byte)0x72,\n-        (byte)0xcf, (byte)0x02, (byte)0xfc, (byte)0xf4,\n-        (byte)0x58, (byte)0x34, (byte)0x77, (byte)0x76,\n-        (byte)0xce, (byte)0x22, (byte)0x44, (byte)0x5f,\n-        (byte)0x2d, (byte)0xca, (byte)0xee, (byte)0xf5,\n-        (byte)0x43, (byte)0x56, (byte)0x47, (byte)0x71,\n-        (byte)0x0b, (byte)0x09, (byte)0x6b, (byte)0x5e,\n-        (byte)0xf2, (byte)0xc8, (byte)0xee, (byte)0xd4,\n-        (byte)0x6e, (byte)0x44, (byte)0x92, (byte)0x2a,\n-        (byte)0x7f, (byte)0xcc, (byte)0xa7, (byte)0xd4,\n-        (byte)0x5b, (byte)0xfb, (byte)0xf7, (byte)0x4a,\n-        (byte)0xa9, (byte)0xfb, (byte)0x54, (byte)0x18,\n-        (byte)0xd5, (byte)0xd5, (byte)0x14, (byte)0xba,\n-        (byte)0xa0, (byte)0x1c, (byte)0x13, (byte)0xb3,\n-        (byte)0x37, (byte)0x6b, (byte)0x37, (byte)0x59,\n-        (byte)0xed, (byte)0xdb, (byte)0x6d, (byte)0xb1\n-    };\n-\n-    static byte serverModulus[] = {\n-        (byte)0x00,\n-        (byte)0xa5, (byte)0xac, (byte)0x5b, (byte)0x1c,\n-        (byte)0x37, (byte)0xa2, (byte)0xdd, (byte)0x99,\n-        (byte)0x89, (byte)0x2d, (byte)0xb2, (byte)0x79,\n-        (byte)0xb8, (byte)0x8f, (byte)0xd5, (byte)0x48,\n-        (byte)0xa5, (byte)0xe7, (byte)0x1c, (byte)0x84,\n-        (byte)0x17, (byte)0x8d, (byte)0x69, (byte)0x9c,\n-        (byte)0xc6, (byte)0xac, (byte)0x6d, (byte)0xf9,\n-        (byte)0xf2, (byte)0x1d, (byte)0x1f, (byte)0x39,\n-        (byte)0x19, (byte)0xda, (byte)0xd3, (byte)0x72,\n-        (byte)0x1e, (byte)0x6e, (byte)0xec, (byte)0x44,\n-        (byte)0xcc, (byte)0x70, (byte)0xa4, (byte)0xdc,\n-        (byte)0xba, (byte)0x00, (byte)0x30, (byte)0xf6,\n-        (byte)0xa0, (byte)0x4f, (byte)0x3d, (byte)0x54,\n-        (byte)0x7a, (byte)0x61, (byte)0x6a, (byte)0xcc,\n-        (byte)0x57, (byte)0xd0, (byte)0x0a, (byte)0x7f,\n-        (byte)0x95, (byte)0x28, (byte)0x18, (byte)0x3f,\n-        (byte)0x9a, (byte)0xd9, (byte)0x94, (byte)0xf2,\n-        (byte)0x1b, (byte)0xc8, (byte)0x24, (byte)0x88,\n-        (byte)0x7e, (byte)0xfe, (byte)0x9d, (byte)0x0f,\n-        (byte)0x3d, (byte)0xfb, (byte)0x57, (byte)0x53,\n-        (byte)0x08, (byte)0xb3, (byte)0x20, (byte)0x33,\n-        (byte)0xd4, (byte)0x3f, (byte)0x17, (byte)0x47,\n-        (byte)0x14, (byte)0xd1, (byte)0xcd, (byte)0xea,\n-        (byte)0x08, (byte)0xd8, (byte)0x0e, (byte)0x75,\n-        (byte)0x4e, (byte)0xaf, (byte)0xbe, (byte)0xcc,\n-        (byte)0xd2, (byte)0xec, (byte)0xaf, (byte)0xa9,\n-        (byte)0x7a, (byte)0x49, (byte)0xdf, (byte)0xc2,\n-        (byte)0xd9, (byte)0xac, (byte)0xb8, (byte)0x24,\n-        (byte)0x40, (byte)0x90, (byte)0xa6, (byte)0x03,\n-        (byte)0x56, (byte)0x2a, (byte)0xd0, (byte)0x30,\n-        (byte)0x05, (byte)0x40, (byte)0x2c, (byte)0x4f,\n-        (byte)0xab, (byte)0xd9, (byte)0x74, (byte)0x89\n-    };\n-\n-    static byte clientPrivateExponent[] = {\n-        (byte)0x11, (byte)0xb7, (byte)0x6a, (byte)0x36,\n-        (byte)0x3d, (byte)0x30, (byte)0x37, (byte)0xce,\n-        (byte)0x61, (byte)0x9d, (byte)0x6c, (byte)0x84,\n-        (byte)0x8b, (byte)0xf3, (byte)0x9b, (byte)0x25,\n-        (byte)0x4f, (byte)0x14, (byte)0xc8, (byte)0xa4,\n-        (byte)0xdd, (byte)0x2f, (byte)0xd7, (byte)0x9a,\n-        (byte)0x17, (byte)0xbd, (byte)0x90, (byte)0x19,\n-        (byte)0xf7, (byte)0x05, (byte)0xfd, (byte)0xf2,\n-        (byte)0xd2, (byte)0xc5, (byte)0xf7, (byte)0x77,\n-        (byte)0xbe, (byte)0xea, (byte)0xe2, (byte)0x84,\n-        (byte)0x87, (byte)0x97, (byte)0x3a, (byte)0x41,\n-        (byte)0x96, (byte)0xb6, (byte)0x99, (byte)0xf8,\n-        (byte)0x94, (byte)0x8c, (byte)0x58, (byte)0x71,\n-        (byte)0x51, (byte)0x8c, (byte)0xf4, (byte)0x2a,\n-        (byte)0x20, (byte)0x9e, (byte)0x1a, (byte)0xa0,\n-        (byte)0x26, (byte)0x99, (byte)0x75, (byte)0xd6,\n-        (byte)0x31, (byte)0x53, (byte)0x43, (byte)0x39,\n-        (byte)0xf5, (byte)0x2a, (byte)0xa6, (byte)0x7e,\n-        (byte)0x34, (byte)0x42, (byte)0x51, (byte)0x2a,\n-        (byte)0x40, (byte)0x87, (byte)0x03, (byte)0x88,\n-        (byte)0x43, (byte)0x69, (byte)0xb2, (byte)0x89,\n-        (byte)0x6d, (byte)0x20, (byte)0xbd, (byte)0x7d,\n-        (byte)0x71, (byte)0xef, (byte)0x47, (byte)0x0a,\n-        (byte)0xdf, (byte)0x06, (byte)0xc1, (byte)0x69,\n-        (byte)0x66, (byte)0xa8, (byte)0x22, (byte)0x37,\n-        (byte)0x1a, (byte)0x77, (byte)0x1e, (byte)0xc7,\n-        (byte)0x94, (byte)0x4e, (byte)0x2c, (byte)0x27,\n-        (byte)0x69, (byte)0x45, (byte)0x5e, (byte)0xc8,\n-        (byte)0xf8, (byte)0x0c, (byte)0xb7, (byte)0xf8,\n-        (byte)0xc0, (byte)0x8f, (byte)0x99, (byte)0xc1,\n-        (byte)0xe5, (byte)0x28, (byte)0x9b, (byte)0xf9,\n-        (byte)0x4c, (byte)0x94, (byte)0xc6, (byte)0xb1\n-    };\n-\n-    static byte clientModulus[] = {\n-        (byte)0x00,\n-        (byte)0xbb, (byte)0xf0, (byte)0x40, (byte)0x36,\n-        (byte)0xac, (byte)0x26, (byte)0x54, (byte)0x4e,\n-        (byte)0xf4, (byte)0xa3, (byte)0x5a, (byte)0x00,\n-        (byte)0x2f, (byte)0x69, (byte)0x21, (byte)0x6f,\n-        (byte)0xb9, (byte)0x7a, (byte)0x3a, (byte)0x93,\n-        (byte)0xec, (byte)0xa2, (byte)0xf6, (byte)0xe1,\n-        (byte)0x8e, (byte)0xc7, (byte)0x63, (byte)0xd8,\n-        (byte)0x2f, (byte)0x12, (byte)0x30, (byte)0x99,\n-        (byte)0x2e, (byte)0xb0, (byte)0xf2, (byte)0x8f,\n-        (byte)0xf8, (byte)0x27, (byte)0x2d, (byte)0x24,\n-        (byte)0x78, (byte)0x28, (byte)0x84, (byte)0xf7,\n-        (byte)0x01, (byte)0xbf, (byte)0x8d, (byte)0x44,\n-        (byte)0x79, (byte)0xdd, (byte)0x3b, (byte)0xd2,\n-        (byte)0x55, (byte)0xf3, (byte)0xce, (byte)0x3c,\n-        (byte)0xb2, (byte)0x5b, (byte)0x21, (byte)0x7d,\n-        (byte)0xef, (byte)0xfd, (byte)0x33, (byte)0x4a,\n-        (byte)0xb1, (byte)0xa3, (byte)0xff, (byte)0xc6,\n-        (byte)0xc8, (byte)0x9b, (byte)0xb9, (byte)0x0f,\n-        (byte)0x7c, (byte)0x41, (byte)0x35, (byte)0x97,\n-        (byte)0xf9, (byte)0xdb, (byte)0x3a, (byte)0x05,\n-        (byte)0x60, (byte)0x05, (byte)0x15, (byte)0xaf,\n-        (byte)0x59, (byte)0x17, (byte)0x92, (byte)0xa3,\n-        (byte)0x10, (byte)0xad, (byte)0x16, (byte)0x1c,\n-        (byte)0xe4, (byte)0x07, (byte)0x53, (byte)0xaf,\n-        (byte)0xa8, (byte)0x76, (byte)0xa2, (byte)0x56,\n-        (byte)0x2a, (byte)0x92, (byte)0xd3, (byte)0xf9,\n-        (byte)0x28, (byte)0xe0, (byte)0x78, (byte)0xcf,\n-        (byte)0x5e, (byte)0x1f, (byte)0x48, (byte)0xab,\n-        (byte)0x5c, (byte)0x19, (byte)0xdd, (byte)0xe1,\n-        (byte)0x67, (byte)0x43, (byte)0xba, (byte)0x75,\n-        (byte)0x8d, (byte)0xf5, (byte)0x82, (byte)0xac,\n-        (byte)0x43, (byte)0x92, (byte)0x44, (byte)0x1b\n-    };\n+    static X509Certificate trustedCert;\n+\n+    static X509Certificate serverCert;\n+\n+    static X509Certificate clientCert;\n+\n+    static KeyPair serverKeys;\n+    static KeyPair clientKeys;\n@@ -642,1 +110,1 @@\n-    static boolean debug = false;\n+    static boolean debug = Boolean.getBoolean(\"test.debug\");\n@@ -653,2 +121,2 @@\n-        SSLContext context = getSSLContext(trusedCertStr, serverCertStr,\n-            serverModulus, serverPrivateExponent, passphrase);\n+        SSLContext context = getSSLContext(trustedCert, serverCert,\n+            serverKeys, passphrase);\n@@ -709,2 +177,2 @@\n-            SSLContext context = getSSLContext(trusedCertStr, clientCertStr,\n-                clientModulus, clientPrivateExponent, passphrase);\n+            SSLContext context = getSSLContext(trustedCert, clientCert,\n+                    clientKeys, passphrase);\n@@ -758,0 +226,59 @@\n+    private static X509Certificate createTrustedCert(KeyPair caKeys) throws Exception {\n+        SecureRandom random = new SecureRandom();\n+\n+        KeyIdentifier kid = new KeyIdentifier(caKeys.getPublic());\n+        GeneralNames gns = new GeneralNames();\n+        GeneralName name = new GeneralName(new X500Name(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\"));\n+        gns.add(name);\n+        BigInteger serialNumber = BigInteger.valueOf(random.nextLong(1000000)+1);\n+        return CertificateBuilder.newCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                caKeys.getPublic(), caKeys.getPublic())\n+                .setSerialNumber(serialNumber)\n+                .addExtension(new AuthorityKeyIdentifierExtension(kid, gns,\n+                        new SerialNumber(serialNumber)))\n+                .addBasicConstraintsExt(true, true, -1)\n+                .setOneHourValidity()\n+                .build(null, caKeys.getPrivate(), \"MD5WithRSA\");\n+    }\n+\n+    private static void setupCertificates() throws Exception {\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n+        KeyPair caKeys = kpg.generateKeyPair();\n+        serverKeys = kpg.generateKeyPair();\n+        clientKeys = kpg.generateKeyPair();\n+\n+        trustedCert = createTrustedCert(caKeys);\n+        if (debug) {\n+            System.out.println(\"----------- Trusted Cert -----------\");\n+            CertificateBuilder.printCertificate(trustedCert, System.out);\n+        }\n+\n+        serverCert = CertificateBuilder.newCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                serverKeys.getPublic(), caKeys.getPublic(),\n+                KeyUsage.DIGITAL_SIGNATURE, KeyUsage.NONREPUDIATION, KeyUsage.KEY_ENCIPHERMENT)\n+                .addBasicConstraintsExt(false, false, -1)\n+                .addExtension(CertificateBuilder.createIPSubjectAltNameExt(true, \"127.0.0.1\"))\n+                .setOneHourValidity()\n+                .build(trustedCert, caKeys.getPrivate(), \"MD5WithRSA\");\n+        if (debug) {\n+            System.out.println(\"----------- Server Cert -----------\");\n+            CertificateBuilder.printCertificate(serverCert, System.out);\n+        }\n+\n+        clientCert = CertificateBuilder.newCertificateBuilder(\n+                \"CN=localhost, OU=SSL-Client, O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                clientKeys.getPublic(), caKeys.getPublic(),\n+                KeyUsage.DIGITAL_SIGNATURE, KeyUsage.NONREPUDIATION, KeyUsage.KEY_ENCIPHERMENT)\n+                .addExtension(CertificateBuilder.createIPSubjectAltNameExt(true, \"127.0.0.1\"))\n+                .addBasicConstraintsExt(false, false, -1)\n+                .setOneHourValidity()\n+                .build(trustedCert, caKeys.getPrivate(), \"MD5WithRSA\");\n+        if (debug) {\n+            System.out.println(\"----------- Client Cert -----------\");\n+            CertificateBuilder.printCertificate(clientCert, System.out);\n+        }\n+    }\n+\n@@ -765,1 +292,1 @@\n-        if (debug)\n+        if (debug) {\n@@ -767,0 +294,3 @@\n+        }\n+\n+        setupCertificates();\n@@ -858,11 +388,2 @@\n-    private static SSLContext getSSLContext(String trusedCertStr,\n-            String keyCertStr, byte[] modulus,\n-            byte[] privateExponent, char[] passphrase) throws Exception {\n-\n-        \/\/ generate certificate from cert string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(trusedCertStr.getBytes());\n-        Certificate trusedCert = cf.generateCertificate(is);\n-        is.close();\n+    private static SSLContext getSSLContext(X509Certificate trustedCert,\n+            X509Certificate keyCert, KeyPair key, char[] passphrase) throws Exception {\n@@ -871,1 +392,1 @@\n-        KeyStore ks = KeyStore.getInstance(\"JKS\");\n+        KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n@@ -875,15 +396,1 @@\n-        ks.setCertificateEntry(\"RSA Export Signer\", trusedCert);\n-\n-        if (keyCertStr != null) {\n-            \/\/ generate the private key.\n-            RSAPrivateKeySpec priKeySpec = new RSAPrivateKeySpec(\n-                                            new BigInteger(modulus),\n-                                            new BigInteger(privateExponent));\n-            KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n-            RSAPrivateKey priKey =\n-                    (RSAPrivateKey)kf.generatePrivate(priKeySpec);\n-\n-            \/\/ generate certificate chain\n-            is = new ByteArrayInputStream(keyCertStr.getBytes());\n-            Certificate keyCert = cf.generateCertificate(is);\n-            is.close();\n+        ks.setCertificateEntry(\"RSA Export Signer\", trustedCert);\n@@ -891,0 +398,1 @@\n+        if (keyCert != null) {\n@@ -893,1 +401,1 @@\n-            chain[1] = trusedCert;\n+            chain[1] = trustedCert;\n@@ -896,1 +404,1 @@\n-            ks.setKeyEntry(\"Whatever\", priKey, passphrase, chain);\n+            ks.setKeyEntry(\"Whatever\", key.getPrivate(), passphrase, chain);\n@@ -905,1 +413,1 @@\n-        if (keyCertStr != null) {\n+        if (keyCert != null) {\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/IPIdentities.java","additions":112,"deletions":604,"binary":false,"changes":716,"status":"modified"},{"patch":"@@ -0,0 +1,3 @@\n+modules = \\\n+    java.base\/sun.security.util \\\n+    java.base\/sun.security.x509\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/TEST.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,5 +47,5 @@\n- * @run main\/othervm\/timeout=150 TestMaxCachedBufferSize\n- * @run main\/othervm\/timeout=150 -Djdk.nio.maxCachedBufferSize=0 TestMaxCachedBufferSize\n- * @run main\/othervm\/timeout=150 -Djdk.nio.maxCachedBufferSize=2000 TestMaxCachedBufferSize\n- * @run main\/othervm\/timeout=150 -Djdk.nio.maxCachedBufferSize=100000 TestMaxCachedBufferSize\n- * @run main\/othervm\/timeout=150 -Djdk.nio.maxCachedBufferSize=10000000 TestMaxCachedBufferSize\n+ * @run main\/othervm\/timeout=600 TestMaxCachedBufferSize\n+ * @run main\/othervm\/timeout=600 -Djdk.nio.maxCachedBufferSize=0 TestMaxCachedBufferSize\n+ * @run main\/othervm\/timeout=600 -Djdk.nio.maxCachedBufferSize=2000 TestMaxCachedBufferSize\n+ * @run main\/othervm\/timeout=600 -Djdk.nio.maxCachedBufferSize=100000 TestMaxCachedBufferSize\n+ * @run main\/othervm\/timeout=600 -Djdk.nio.maxCachedBufferSize=10000000 TestMaxCachedBufferSize\n","filename":"test\/jdk\/sun\/nio\/ch\/TestMaxCachedBufferSize.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n- * @run junit\/timeout=10 TestEncoderReplaceUTF16\n- * @run junit\/timeout=10\/othervm -XX:-CompactStrings TestEncoderReplaceUTF16\n+ * @run junit\/timeout=40 TestEncoderReplaceUTF16\n+ * @run junit\/timeout=40\/othervm -XX:-CompactStrings TestEncoderReplaceUTF16\n","filename":"test\/jdk\/sun\/nio\/cs\/TestEncoderReplaceUTF16.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n- * @run main EdDSATest\n+ * @run main\/timeout=480 EdDSATest\n","filename":"test\/jdk\/sun\/security\/ec\/ed\/EdDSATest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/othervm IncludeRandom\n+ * @run main\/othervm\/timeout=480 IncludeRandom\n","filename":"test\/jdk\/sun\/security\/krb5\/config\/IncludeRandom.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main\/othervm Constructors\n+ * @run main\/othervm\/timeout=480 Constructors\n","filename":"test\/jdk\/sun\/security\/krb5\/name\/Constructors.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import jtreg.SkippedException;\n+\n@@ -49,2 +51,1 @@\n-            System.out.println(\"Not supported by provider, skipping\");\n-            return;\n+            throw new SkippedException(\"Algorithm ARCFOUR is not supported by provider, skipping\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/ReinitCipher.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,4 +32,1 @@\n-import java.io.PrintStream;\n-import java.security.*;\n-import java.security.spec.*;\n-import java.util.Random;\n+import jtreg.SkippedException;\n@@ -37,2 +34,6 @@\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n+import java.security.GeneralSecurityException;\n+import java.security.InvalidAlgorithmParameterException;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n@@ -40,0 +41,1 @@\n+import java.security.spec.AlgorithmParameterSpec;\n@@ -51,3 +53,2 @@\n-            System.out.println(\"Skip testing \" + p.getName() +\n-                    \", no support for \" + mode);\n-            return;\n+            throw new SkippedException(\"Skip testing \" + p.getName() +\n+                                       \", no support for \" + mode);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/Test4512704.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,5 +34,14 @@\n-import java.security.*;\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n-import java.math.*;\n-import java.io.*;\n+import jtreg.SkippedException;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import javax.crypto.Cipher;\n+import javax.crypto.CipherInputStream;\n+import javax.crypto.CipherOutputStream;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+import java.security.GeneralSecurityException;\n+import java.security.Provider;\n+import java.util.Arrays;\n+import java.util.Random;\n@@ -40,1 +49,0 @@\n-import java.util.*;\n@@ -58,3 +66,2 @@\n-            System.out.println(\"Skip testing \" + p.getName() +\n-                    \", no support for \" + mode);\n-            return;\n+            throw new SkippedException(\"Skip testing \" + p.getName() +\n+                                       \", no support for \" + mode);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestCICOWithGCM.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jtreg.SkippedException;\n+\n@@ -47,1 +49,0 @@\n-\/\/        test(\"CCM\", p);\n@@ -56,3 +57,2 @@\n-            System.out.println(\"Skip testing \" + p.getName() +\n-                    \", no support for \" + mode);\n-            return;\n+            throw new SkippedException(\"Skip testing \" + p.getName() +\n+                                       \", no support for \" + mode);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestCICOWithGCMAndAAD.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-import jdk.test.lib.Utils;\n+import jtreg.SkippedException;\n@@ -73,2 +73,1 @@\n-            System.out.println(\"Skip; no support for \" + ALGO);\n-            return;\n+            throw new SkippedException(\"Skip; no support for \" + ALGO);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestChaChaPoly.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @build jdk.test.lib.Convert\n@@ -34,1 +33,2 @@\n-import java.util.*;\n+import jtreg.SkippedException;\n+\n@@ -39,1 +39,0 @@\n-import javax.crypto.spec.ChaCha20ParameterSpec;\n@@ -44,1 +43,5 @@\n-import jdk.test.lib.Convert;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n@@ -129,2 +132,1 @@\n-            System.out.println(\"Skip; no support for \" + ALGO);\n-            return;\n+            throw new SkippedException(\"Skip; no support for \" + ALGO);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestChaChaPolyKAT.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,2 @@\n-import java.util.*;\n+import jtreg.SkippedException;\n+\n@@ -38,1 +39,0 @@\n-import javax.crypto.spec.ChaCha20ParameterSpec;\n@@ -41,1 +41,0 @@\n-import javax.crypto.AEADBadTagException;\n@@ -45,0 +44,5 @@\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n@@ -241,2 +245,1 @@\n-            System.out.println(\"Skip; no support for \" + CIPHER_ALGO);\n-            return;\n+            throw new SkippedException(\"Skip; no support for \" + CIPHER_ALGO);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestChaChaPolyNoReuse.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jtreg.SkippedException;\n+\n@@ -35,1 +37,0 @@\n-import java.security.Key;\n@@ -40,1 +41,0 @@\n-import javax.crypto.spec.ChaCha20ParameterSpec;\n@@ -63,2 +63,1 @@\n-            System.out.println(\"Skip; no support for \" + ALGO);\n-            return;\n+            throw new SkippedException(\"Skip; no support for \" + ALGO);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestChaChaPolyOutputSize.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jtreg.SkippedException;\n+\n@@ -41,0 +43,1 @@\n+import java.util.ArrayList;\n@@ -42,0 +45,1 @@\n+import java.util.List;\n@@ -48,3 +52,3 @@\n-    private static String[] TRANSFORMATIONS = {\n-        \"AES\/ECB\/PKCS5Padding\", \"AES\/GCM\/NoPadding\",\n-        \"RSA\/ECB\/PKCS1Padding\"\n+    private static final String[] TRANSFORMATIONS = {\n+            \"AES\/ECB\/PKCS5Padding\", \"AES\/GCM\/NoPadding\",\n+            \"RSA\/ECB\/PKCS1Padding\"\n@@ -53,2 +57,2 @@\n-    private static byte[] BYTES16 =\n-            Arrays.copyOf(TRANSFORMATIONS[0].getBytes(), 16);\n+    private static final byte[] BYTES16 =\n+            Arrays.copyOf(\"AES\/ECB\/PKCS5Padding\".getBytes(), 16);\n@@ -100,2 +104,15 @@\n-        for (String t : TRANSFORMATIONS) {\n-            checkModes(t, p);\n+        List<String> skipped = new ArrayList<>();\n+        for (final String t : TRANSFORMATIONS) {\n+            try {\n+                checkModes(t, p);\n+            } catch (SkippedException skippedException) {\n+                \/\/ printing to System.out, so it's easier to see which test it relates to\n+                skippedException.printStackTrace(System.out);\n+                skipped.add(t);\n+            }\n+        }\n+\n+        if (!skipped.isEmpty()) {\n+            throw new SkippedException(\"Some tests skipped: \" + skipped);\n+        } else {\n+            System.out.println(\"All tests passed\");\n@@ -103,1 +120,0 @@\n-        System.out.println(\"All tests passed\");\n@@ -110,2 +126,1 @@\n-            System.out.println(\"Skip \" + t + \" due to \" + e.getMessage());\n-            return;\n+            throw new SkippedException(\"Skip \" + t + \" due to \" + e.getMessage());\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestCipherMode.java","additions":26,"deletions":11,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,7 @@\n-import java.security.*;\n+import jtreg.SkippedException;\n+\n+import java.security.AlgorithmParameters;\n+import java.security.GeneralSecurityException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Provider;\n@@ -36,3 +42,5 @@\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n-import java.math.*;\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n@@ -40,1 +48,1 @@\n-import java.util.*;\n+import java.util.Arrays;\n@@ -80,3 +88,2 @@\n-            System.out.println(\"Skip testing \" + p.getName() +\n-                    \", no support for \" + mode);\n-            return;\n+            throw new SkippedException(\"Skip testing \" + p.getName() +\n+                                       \", no support for \" + mode);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestGCMKeyAndIvCheck.java","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jtreg.SkippedException;\n+\n@@ -314,3 +316,2 @@\n-            System.out.println(\"Skip testing \" + p.getName() +\n-                    \", no support for \" + transformation);\n-            return;\n+            throw new SkippedException(\"Skip testing \" + p.getName() +\n+                                       \", no support for \" + transformation);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestKATForGCM.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+import jtreg.SkippedException;\n@@ -58,2 +59,1 @@\n-            System.out.println(\"Not supported by provider, skipping\");\n-            return;\n+            throw new SkippedException(\"Algorithm \" + RSA_ALGOS[0] + \" is not supported by provider, skipping\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestRSACipher.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+import jtreg.SkippedException;\n@@ -57,2 +58,1 @@\n-            System.out.println(RSA_ALGOS[0] + \" unsupported, skipping\");\n-            return;\n+            throw new SkippedException(RSA_ALGOS[0] + \" unsupported, skipping\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestRSACipherWrap.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import jtreg.SkippedException;\n@@ -52,2 +53,1 @@\n-            System.out.println(\"Not supported by provider, skipping\");\n-            return;\n+            throw new SkippedException(\"Algorithm RSA\/ECB\/NoPadding is not supported by provider, skipping\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestRawRSACipher.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import jtreg.SkippedException;\n+\n@@ -40,0 +42,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -47,5 +51,1 @@\n-    private static class CI { \/\/ class for holding Cipher Information\n-\n-        String transformation;\n-        String keyAlgo;\n-        int dataSize;\n+    private record CI (String transformation, String keyAlgo, int dataSize){}  \/\/ record for holding Cipher Information\n@@ -53,6 +53,0 @@\n-        CI(String transformation, String keyAlgo, int dataSize) {\n-            this.transformation = transformation;\n-            this.keyAlgo = keyAlgo;\n-            this.dataSize = dataSize;\n-        }\n-    }\n@@ -60,24 +54,24 @@\n-        new CI(\"ARCFOUR\", \"ARCFOUR\", 400),\n-        new CI(\"RC4\", \"RC4\", 401),\n-        new CI(\"DES\/CBC\/NoPadding\", \"DES\", 400),\n-        new CI(\"DESede\/CBC\/NoPadding\", \"DESede\", 160),\n-        new CI(\"AES\/CBC\/NoPadding\", \"AES\", 4800),\n-        new CI(\"Blowfish\/CBC\/NoPadding\", \"Blowfish\", 24),\n-        new CI(\"DES\/cbc\/PKCS5Padding\", \"DES\", 6401),\n-        new CI(\"DESede\/CBC\/PKCS5Padding\", \"DESede\", 402),\n-        new CI(\"AES\/CBC\/PKCS5Padding\", \"AES\", 30),\n-        new CI(\"Blowfish\/CBC\/PKCS5Padding\", \"Blowfish\", 19),\n-        new CI(\"DES\/ECB\/NoPadding\", \"DES\", 400),\n-        new CI(\"DESede\/ECB\/NoPadding\", \"DESede\", 160),\n-        new CI(\"AES\/ECB\/NoPadding\", \"AES\", 4800),\n-        new CI(\"DES\/ECB\/PKCS5Padding\", \"DES\", 32),\n-        new CI(\"DES\/ECB\/PKCS5Padding\", \"DES\", 6400),\n-        new CI(\"DESede\/ECB\/PKCS5Padding\", \"DESede\", 400),\n-        new CI(\"AES\/ECB\/PKCS5Padding\", \"AES\", 64),\n-\n-        new CI(\"DES\", \"DES\", 6400),\n-        new CI(\"DESede\", \"DESede\", 408),\n-        new CI(\"AES\", \"AES\", 128),\n-\n-        new CI(\"AES\/CTR\/NoPadding\", \"AES\", 3200),\n-        new CI(\"AES\/CTS\/NoPadding\", \"AES\", 3200),\n+            new CI(\"ARCFOUR\", \"ARCFOUR\", 400),\n+            new CI(\"RC4\", \"RC4\", 401),\n+            new CI(\"DES\/CBC\/NoPadding\", \"DES\", 400),\n+            new CI(\"DESede\/CBC\/NoPadding\", \"DESede\", 160),\n+            new CI(\"AES\/CBC\/NoPadding\", \"AES\", 4800),\n+            new CI(\"Blowfish\/CBC\/NoPadding\", \"Blowfish\", 24),\n+            new CI(\"DES\/cbc\/PKCS5Padding\", \"DES\", 6401),\n+            new CI(\"DESede\/CBC\/PKCS5Padding\", \"DESede\", 402),\n+            new CI(\"AES\/CBC\/PKCS5Padding\", \"AES\", 30),\n+            new CI(\"Blowfish\/CBC\/PKCS5Padding\", \"Blowfish\", 19),\n+            new CI(\"DES\/ECB\/NoPadding\", \"DES\", 400),\n+            new CI(\"DESede\/ECB\/NoPadding\", \"DESede\", 160),\n+            new CI(\"AES\/ECB\/NoPadding\", \"AES\", 4800),\n+            new CI(\"DES\/ECB\/PKCS5Padding\", \"DES\", 32),\n+            new CI(\"DES\/ECB\/PKCS5Padding\", \"DES\", 6400),\n+            new CI(\"DESede\/ECB\/PKCS5Padding\", \"DESede\", 400),\n+            new CI(\"AES\/ECB\/PKCS5Padding\", \"AES\", 64),\n+\n+            new CI(\"DES\", \"DES\", 6400),\n+            new CI(\"DESede\", \"DESede\", 408),\n+            new CI(\"AES\", \"AES\", 128),\n+\n+            new CI(\"AES\/CTR\/NoPadding\", \"AES\", 3200),\n+            new CI(\"AES\/CTS\/NoPadding\", \"AES\", 3200),\n@@ -93,1 +87,1 @@\n-        boolean status = true;\n+        List<CI> skippedList = new ArrayList<>();\n@@ -96,2 +90,1 @@\n-            for (int i = 0; i < TEST_LIST.length; i++) {\n-                CI currTest = TEST_LIST[i];\n+            for (CI currTest : TEST_LIST) {\n@@ -126,1 +119,2 @@\n-                            nsae);\n+                                       nsae);\n+                    skippedList.add(currTest);\n@@ -134,0 +128,4 @@\n+\n+        if (!skippedList.isEmpty()){\n+            throw new SkippedException(\"Some tests skipped: \" + skippedList);\n+        }\n@@ -137,2 +135,2 @@\n-            AlgorithmParameters params, int firstBlkSize,\n-            byte[] in, byte[] answer) throws Exception {\n+                             AlgorithmParameters params, int firstBlkSize,\n+                             byte[] in, byte[] answer) throws Exception {\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestSymmCiphers.java","additions":40,"deletions":42,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import jtreg.SkippedException;\n+\n@@ -42,0 +44,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -50,4 +54,1 @@\n-    private static class CI { \/\/ class for holding Cipher Information\n-        String transformation;\n-        String keyAlgo;\n-        int dataSize;\n+    private record CI (String transformation, String keyAlgo, int dataSize){}  \/\/ record for holding Cipher Information\n@@ -55,6 +56,1 @@\n-        CI(String transformation, String keyAlgo, int dataSize) {\n-            this.transformation = transformation;\n-            this.keyAlgo = keyAlgo;\n-            this.dataSize = dataSize;\n-        }\n-    }\n+    private static final StringBuffer debugBuf = new StringBuffer();\n@@ -62,11 +58,11 @@\n-    private static final CI TEST_LIST[] = {\n-        new CI(\"ARCFOUR\", \"ARCFOUR\", 400),\n-        new CI(\"RC4\", \"RC4\", 401),\n-        new CI(\"DES\/CBC\/NoPadding\", \"DES\", 400),\n-        new CI(\"DESede\/CBC\/NoPadding\", \"DESede\", 160),\n-        new CI(\"AES\/CBC\/NoPadding\", \"AES\", 4800),\n-        new CI(\"Blowfish\/CBC\/NoPadding\", \"Blowfish\", 24),\n-        new CI(\"AES\/CTR\/NoPadding\", \"AES\", 1600),\n-        new CI(\"AES\/CTR\/NoPadding\", \"AES\", 65),\n-        new CI(\"AES\/CTS\/NoPadding\", \"AES\", 1600),\n-        new CI(\"AES\/CTS\/NoPadding\", \"AES\", 65),\n+    private static final CI[] TEST_LIST = {\n+            new CI(\"ARCFOUR\", \"ARCFOUR\", 400),\n+            new CI(\"RC4\", \"RC4\", 401),\n+            new CI(\"DES\/CBC\/NoPadding\", \"DES\", 400),\n+            new CI(\"DESede\/CBC\/NoPadding\", \"DESede\", 160),\n+            new CI(\"AES\/CBC\/NoPadding\", \"AES\", 4800),\n+            new CI(\"Blowfish\/CBC\/NoPadding\", \"Blowfish\", 24),\n+            new CI(\"AES\/CTR\/NoPadding\", \"AES\", 1600),\n+            new CI(\"AES\/CTR\/NoPadding\", \"AES\", 65),\n+            new CI(\"AES\/CTS\/NoPadding\", \"AES\", 1600),\n+            new CI(\"AES\/CTS\/NoPadding\", \"AES\", 65),\n@@ -75,2 +71,0 @@\n-    private static final StringBuffer debugBuf = new StringBuffer();\n-\n@@ -79,1 +73,1 @@\n-        boolean status = true;\n+        List<CI> skippedList = new ArrayList<>();\n@@ -82,2 +76,1 @@\n-            for (int i = 0; i < TEST_LIST.length; i++) {\n-                CI currTest = TEST_LIST[i];\n+            for (CI currTest : TEST_LIST) {\n@@ -87,1 +80,1 @@\n-                        KeyGenerator.getInstance(currTest.keyAlgo, p);\n+                            KeyGenerator.getInstance(currTest.keyAlgo, p);\n@@ -91,1 +84,1 @@\n-                               System.getProperty(\"test.provider.name\", \"SunJCE\"));\n+                            System.getProperty(\"test.provider.name\", \"SunJCE\"));\n@@ -101,1 +94,1 @@\n-                         plainTxt, answer);\n+                            plainTxt, answer);\n@@ -106,1 +99,1 @@\n-                         answer, answer2);\n+                            answer, answer2);\n@@ -111,0 +104,1 @@\n+                    skippedList.add(currTest);\n@@ -118,0 +112,4 @@\n+\n+        if (!skippedList.isEmpty()){\n+            throw new SkippedException(\"Some tests skipped: \" + skippedList);\n+        }\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestSymmCiphersNoPad.java","additions":29,"deletions":31,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- * @run main\/othervm\/timeout=30 TestHKDF\n+ * @run main\/othervm\/timeout=120 TestHKDF\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KDF\/TestHKDF.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @run main TestDefaultSize\n+ * @run main\/timeout=480 TestDefaultSize\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyPairGenerator\/TestDefaultSize.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * @run main\/othervm\/timeout=30 ImportKeyToP12\n+ * @run main\/othervm\/timeout=120 ImportKeyToP12\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyStore\/ImportKeyToP12.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @run main\/othervm\/timeout=30 -DCUSTOM_P11_CONFIG_NAME=p11-nss-sensitive.txt TestLargeSecretKeys\n+ * @run main\/othervm\/timeout=120 -DCUSTOM_P11_CONFIG_NAME=p11-nss-sensitive.txt TestLargeSecretKeys\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Mac\/TestLargeSecretKeys.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @run main\/othervm KeytoolOpensslInteropTest true\n+ * @run main\/othervm\/timeout=480 KeytoolOpensslInteropTest true\n@@ -51,1 +51,1 @@\n- * @run main\/othervm KeytoolOpensslInteropTest false\n+ * @run main\/othervm\/timeout=480 KeytoolOpensslInteropTest false\n","filename":"test\/jdk\/sun\/security\/pkcs12\/KeytoolOpensslInteropTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @run main Launcher\n+ * @run main\/timeout=480 Launcher\n@@ -49,1 +49,1 @@\n- * @run main\/othervm -Xcomp Launcher\n+ * @run main\/othervm\/timeout=480 -Xcomp Launcher\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/Launcher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @library \/test\/lib\n@@ -42,0 +43,1 @@\n+import jdk.test.lib.Utils;\n@@ -140,2 +142,1 @@\n-        float timeoutFactor = Float.parseFloat(System.getProperty(\"test.timeout.factor\", \"1.0\"));\n-        baseSocket.setSoTimeout((int)(1000 * timeoutFactor));\n+        baseSocket.setSoTimeout((int)(1000 * Utils.TIMEOUT_FACTOR));\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/SSLSocketCloseHang.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -65,4 +65,4 @@\n- * @run main\/othervm CertChecking false SunX509\n- * @run main\/othervm CertChecking true SunX509\n- * @run main\/othervm CertChecking false PKIX\n- * @run main\/othervm CertChecking true PKIX\n+ * @run main\/othervm\/timeout=480 CertChecking false SunX509\n+ * @run main\/othervm\/timeout=480 CertChecking true SunX509\n+ * @run main\/othervm\/timeout=480 CertChecking false PKIX\n+ * @run main\/othervm\/timeout=480 CertChecking true PKIX\n","filename":"test\/jdk\/sun\/security\/ssl\/X509KeyManager\/CertChecking.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main\/timeout=240 ConciseJarsigner\n+ * @run main\/timeout=960 ConciseJarsigner\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/ConciseJarsigner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n- * @run testng InsufficientSectionDelimiter\n+ * @run testng\/timeout=480 InsufficientSectionDelimiter\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/InsufficientSectionDelimiter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,2 @@\n- * @run main\/othervm RestrictedAlgo RESTRICT\n- * @run main\/othervm RestrictedAlgo NO_RESTRICT\n+ * @run main\/othervm\/timeout=480 RestrictedAlgo RESTRICT\n+ * @run main\/othervm\/timeout=480 RestrictedAlgo NO_RESTRICT\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/RestrictedAlgo.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n- * @run testng SectionNameContinuedVsLineBreak\n+ * @run testng\/timeout=480 SectionNameContinuedVsLineBreak\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/SectionNameContinuedVsLineBreak.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n- * @run main\/timeout=600 TimestampCheck\n+ * @run main\/timeout=2400 TimestampCheck\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/TimestampCheck.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng\/timeout=300 GenerateAll\n+ * @run testng\/timeout=1200 GenerateAll\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/GenerateAll.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @run main ReadJar\n+ * @run main\/timeout=480 ReadJar\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/ReadJar.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main TrustedCert\n+ * @run main\/timeout=480 TrustedCert\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/fakecacerts\/TrustedCert.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n- * @run main\/othervm -XX:+UsePerfData TestJcmdSanity\n+ * @run main\/othervm\/timeout=480 -XX:+UsePerfData TestJcmdSanity\n","filename":"test\/jdk\/sun\/tools\/jcmd\/TestJcmdSanity.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main BasicLauncherTest\n+ * @run main\/timeout=480 BasicLauncherTest\n","filename":"test\/jdk\/sun\/tools\/jhsdb\/BasicLauncherTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng Bug8139107\n+ * @run testng\/timeout=480 Bug8139107\n@@ -59,1 +59,0 @@\n-\n","filename":"test\/jdk\/sun\/util\/resources\/TimeZone\/Bug8139107.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run main\/othervm -Xmx1g -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLink100Modules\n+ * @run main\/othervm\/timeout=480 -Xmx1g -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLink100Modules\n","filename":"test\/jdk\/tools\/jlink\/JLink100Modules.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,9 @@\n+import tests.JImageGenerator;\n+\n+import java.io.BufferedOutputStream;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.attribute.ModuleAttribute;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.constant.ModuleDesc;\n+import java.lang.constant.PackageDesc;\n@@ -27,3 +36,4 @@\n-import java.util.Arrays;\n-import java.util.StringJoiner;\n-import java.util.spi.ToolProvider;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n@@ -31,1 +41,5 @@\n-import tests.JImageGenerator;\n+import static java.lang.classfile.ClassFile.ACC_MANDATED;\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.constant.ConstantDescs.CD_String;\n+import static java.lang.constant.ConstantDescs.CD_void;\n@@ -39,2 +53,1 @@\n- * @library ..\/lib\n- * @enablePreview\n+ * @library ..\/lib \/test\/lib\n@@ -42,3 +55,0 @@\n- *          jdk.jlink\/jdk.tools.jlink.internal\n- *          jdk.jlink\/jdk.tools.jlink.plugin\n- *          jdk.jlink\/jdk.tools.jmod\n@@ -46,1 +56,0 @@\n- *          jdk.compiler\n@@ -48,1 +57,1 @@\n- * @run main\/othervm -Xmx1g -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLink20000Packages\n+ * @run main\/othervm -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLink20000Packages\n@@ -51,11 +60,3 @@\n-    private static final ToolProvider JAVAC_TOOL = ToolProvider.findFirst(\"javac\")\n-            .orElseThrow(() -> new RuntimeException(\"javac tool not found\"));\n-\n-    static void report(String command, String[] args) {\n-        System.out.println(command + \" \" + String.join(\" \", Arrays.asList(args)));\n-    }\n-\n-    static void javac(String[] args) {\n-        report(\"javac\", args);\n-        JAVAC_TOOL.run(System.out, System.err, args);\n-    }\n+    private static final ClassDesc CD_System = ClassDesc.of(\"java.lang.System\");\n+    private static final ClassDesc CD_PrintStream = ClassDesc.of(\"java.io.PrintStream\");\n+    private static final MethodTypeDesc MTD_void_String = MethodTypeDesc.of(CD_void, CD_String);\n@@ -64,1 +65,4 @@\n-        Path src = Paths.get(\"bug8321413\");\n+        String moduleName = \"bug8321413x\";\n+        Path src = Paths.get(moduleName);\n+        Files.createDirectories(src);\n+        Path jarPath = src.resolve(moduleName +\".jar\");\n@@ -66,7 +70,0 @@\n-        Path mainModulePath = src.resolve(\"bug8321413x\");\n-\n-        StringJoiner mainModuleInfoContent = new StringJoiner(\";\\n  exports \", \"module bug8321413x {\\n  exports \", \";\\n}\");\n-\n-        for (int i = 0; i < 20000; i++) {\n-            String packageName = \"p\" + i;\n-            String className = \"C\" + i;\n@@ -74,8 +71,27 @@\n-            Path packagePath = Files.createDirectories(mainModulePath.resolve(packageName));\n-\n-            StringBuilder classContent = new StringBuilder(\"package \");\n-            classContent.append(packageName).append(\";\\n\");\n-            classContent.append(\"class \").append(className).append(\" {}\\n\");\n-            Files.writeString(packagePath.resolve(className + \".java\"), classContent.toString());\n-\n-            mainModuleInfoContent.add(packageName);\n+        \/\/ Generate module with 20000 classes in unique packages\n+        try (JarOutputStream out = new JarOutputStream(new BufferedOutputStream(Files.newOutputStream(jarPath)))) {\n+            Set<String> packageNames = new HashSet<>();\n+            for (int i = 0; i < 20_000; i++) {\n+                String packageName = \"p\" + i;\n+                packageNames.add(packageName);\n+\n+                \/\/ Generate a class file for this package\n+                String className = \"C\" + i;\n+                byte[] classData = ClassFile.of().build(ClassDesc.of(packageName, className), cb -> {});\n+                out.putNextEntry(new JarEntry(packageName + \"\/\" + className +\".class\"));\n+                out.write(classData);\n+            }\n+\n+            \/\/ Write the main class\n+            out.putNextEntry(new JarEntry(\"testpackage\/JLink20000PackagesTest.class\"));\n+            out.write(generateMainClass());\n+            packageNames.add(\"testpackage\");\n+\n+            \/\/ Write the module descriptor\n+            byte[] moduleInfo = ClassFile.of().buildModule(ModuleAttribute.of(\n+                    ModuleDesc.of(moduleName), mab -> {\n+                        mab.requires(ModuleDesc.of(\"java.base\"), ACC_MANDATED, null);\n+                        packageNames.forEach(pkgName -> mab.exports(PackageDesc.of(pkgName), 0));\n+                    }));\n+            out.putNextEntry(new JarEntry(\"module-info.class\"));\n+            out.write(moduleInfo);\n@@ -84,24 +100,0 @@\n-        \/\/ create module reading the generated modules\n-        Path mainModuleInfo = mainModulePath.resolve(\"module-info.java\");\n-        Files.writeString(mainModuleInfo, mainModuleInfoContent.toString());\n-\n-        Path mainClassDir = mainModulePath.resolve(\"testpackage\");\n-        Files.createDirectories(mainClassDir);\n-\n-        Files.writeString(mainClassDir.resolve(\"JLink20000PackagesTest.java\"), \"\"\"\n-                package testpackage;\n-\n-                public class JLink20000PackagesTest {\n-                    public static void main(String[] args) throws Exception {\n-                        System.out.println(\"JLink20000PackagesTest started.\");\n-                    }\n-                }\n-                \"\"\");\n-\n-        String out = src.resolve(\"out\").toString();\n-        javac(new String[]{\n-                \"-d\", out,\n-                \"--module-source-path\", src.toString(),\n-                \"--module\", \"bug8321413x\"\n-        });\n-\n@@ -109,1 +101,0 @@\n-                .modulePath(out)\n@@ -111,1 +102,2 @@\n-                .addMods(\"bug8321413x\")\n+                .addJars(jarPath)\n+                .addMods(moduleName)\n@@ -120,0 +112,1 @@\n+                \/\/ Option is useful to verify build image\n@@ -121,1 +114,1 @@\n-                \"-m\", \"bug8321413x\/testpackage.JLink20000PackagesTest\");\n+                \"-m\", moduleName + \"\/testpackage.JLink20000PackagesTest\");\n@@ -129,0 +122,18 @@\n+\n+    \/**\n+     * Generate test class with main() does\n+     * System.out.println(\"JLink20000PackagesTest started.\");\n+     *\/\n+    private static byte[] generateMainClass() {\n+        return ClassFile.of().build(ClassDesc.of(\"testpackage\", \"JLink20000PackagesTest\"),\n+                cb -> {\n+                    cb.withMethod(\"main\", MethodTypeDesc.of(CD_void, CD_String.arrayType()),\n+                            ACC_PUBLIC | ACC_STATIC, mb -> {\n+                                mb.withCode(cob -> cob.getstatic(CD_System, \"out\", CD_PrintStream)\n+                                        .ldc(\"JLink20000PackagesTest started.\")\n+                                        .invokevirtual(CD_PrintStream, \"println\", MTD_void_String)\n+                                        .return_()\n+                                );\n+                            });\n+                });\n+    }\n","filename":"test\/jdk\/tools\/jlink\/JLink20000Packages.java","additions":77,"deletions":66,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n- * @run main\/othervm -Xmx1g JLinkTest\n+ * @run main\/othervm\/timeout=480 -Xmx1g JLinkTest\n","filename":"test\/jdk\/tools\/jlink\/JLinkTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n- * @run junit\/othervm\/timeout=180 -Xmx1g IncludeLocalesPluginTest\n+ * @run junit\/othervm\/timeout=720 -Xmx1g IncludeLocalesPluginTest\n","filename":"test\/jdk\/tools\/jlink\/plugins\/IncludeLocalesPluginTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * @run main\/othervm -Xmx1g JavaSEReproducibleTest\n+ * @run main\/othervm\/timeout=480 -Xmx1g JavaSEReproducibleTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/JavaSEReproducibleTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=1440 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/DmgContentTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n- * @run main\/othervm -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=480 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/MacFileAssociationsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m\n+ * @run main\/othervm\/timeout=1440 -Xmx512m\n@@ -66,1 +66,1 @@\n- * @run main\/othervm\/timeout=540 -Xmx512m\n+ * @run main\/othervm\/timeout=2160 -Xmx512m\n","filename":"test\/jdk\/tools\/jpackage\/share\/AddLauncherTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n- * @run main\/othervm -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=480 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppLauncherSubstTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=1440 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppVersionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n- * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=2880 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/share\/BasicTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n- * @run main\/othervm\/timeout=720 -Xmx512m\n+ * @run main\/othervm\/timeout=2880 -Xmx512m\n","filename":"test\/jdk\/tools\/jpackage\/share\/IconTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n- * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=2880 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/share\/InOutPathTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n- * @run main\/othervm\/timeout=540 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=4000 -Xmx512m jdk.jpackage.test.Main\n@@ -81,1 +81,1 @@\n- * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=4000 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/share\/InstallDirTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=2840 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/share\/JavaOptionsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n- * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=2880 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/share\/MainClassTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n- * @run main\/othervm\/timeout=540 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=2160 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/share\/MultiNameTwoPhaseTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n- * @run main\/othervm\/timeout=720 -Xmx512m\n+ * @run main\/othervm\/timeout=2880 -Xmx512m\n","filename":"test\/jdk\/tools\/jpackage\/share\/PostImageScriptTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run main\/othervm -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=480 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinNoRestartTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main InstanceMainTest\n+ * @run main\/timeout=480 InstanceMainTest\n","filename":"test\/jdk\/tools\/launcher\/InstanceMainTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -426,1 +426,1 @@\n-            return linkableRuntime ? jars : jmods + File.pathSeparator + jars;\n+            return (linkableRuntime || jmods.isEmpty()) ? jars : jmods + File.pathSeparator + jars;\n@@ -657,1 +657,1 @@\n-            return jmods + File.pathSeparator + jars;\n+            return jmods.isEmpty() ? jars : jmods + File.pathSeparator + jars;\n","filename":"test\/jdk\/tools\/lib\/tests\/JImageGenerator.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -124,0 +124,1 @@\n+        map.put(\"vm.cds.nocoops.archive.available\", this::vmCDSNocoopsArchiveAvailable);\n@@ -443,0 +444,10 @@\n+    \/**\n+     * Check for CDS no compressed oops archive existence.\n+     *\n+     * @return true if CDS archive classes_nocoops.jsa exists in the JDK to be tested.\n+     *\/\n+    protected String vmCDSNocoopsArchiveAvailable() {\n+        Path archive = Paths.get(System.getProperty(\"java.home\"), \"lib\", \"server\", \"classes_nocoops.jsa\");\n+        return \"\" + (\"true\".equals(vmCDS()) && Files.exists(archive));\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,2 @@\n+jdk\/jshell\/ToolSimpleTest.java                                                  8366582    windows-x64\n+jdk\/jshell\/ToolLocalSimpleTest.java                                             8366582    windows-x64\n","filename":"test\/langtools\/ProblemList.txt","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * @run main TestRedirectLinks\n+ * @run main\/timeout=480 TestRedirectLinks\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testLinkOption\/TestRedirectLinks.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng ClassesTest\n+ * @run testng\/timeout=480 ClassesTest\n","filename":"test\/langtools\/jdk\/jshell\/ClassesTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,0 +75,7 @@\n+        Path classDirPath = getClassDir();\n+        Path baseDir = classDirPath.resolve(directory);\n+        Path jarPath = baseDir.resolve(jarName);\n+        jar(directory, jarPath, files);\n+    }\n+\n+    public void jar(Path directory, Path jarPath, String...files) {\n@@ -79,1 +86,0 @@\n-        Path jarPath = baseDir.resolve(jarName);\n","filename":"test\/langtools\/jdk\/jshell\/Compiler.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @run testng CompletionSuggestionTest\n+ * @run testng\/timeout=480 CompletionSuggestionTest\n@@ -837,0 +837,16 @@\n+\n+    public void testCustomClassPathIndexing() {\n+        Path p1 = outDir.resolve(\"dir1\");\n+        compiler.compile(p1,\n+                \"package p1.p2;\\n\" +\n+                \"public class Test {\\n\" +\n+                \"}\",\n+                \"package p1.p3;\\n\" +\n+                \"public class Test {\\n\" +\n+                \"}\");\n+        String jarName = \"test.jar\";\n+        compiler.jar(p1, jarName, \"p1\/p2\/Test.class\", \"p1\/p3\/Test.class\");\n+        addToClasspath(compiler.getPath(p1.resolve(jarName)));\n+\n+        assertCompletion(\"p1.|\", \"p2.\", \"p3.\");\n+    }\n","filename":"test\/langtools\/jdk\/jshell\/CompletionSuggestionTest.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,3 +38,1 @@\n-    private static float timeoutFactor = Float.parseFloat(System.getProperty(\"test.timeout.factor\", \"1.0\"));\n-\n-    private static final int TIMEOUT = (int)(2000 * timeoutFactor);\n+    private static final int TIMEOUT = (int)(2000 * Double.parseDouble(System.getProperty(\"test.timeout.factor\", \"1.0\")));\n","filename":"test\/langtools\/jdk\/jshell\/HangingRemoteAgent.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng JdiHangingLaunchExecutionControlTest\n+ * @run testng\/timeout=480 JdiHangingLaunchExecutionControlTest\n","filename":"test\/langtools\/jdk\/jshell\/JdiHangingLaunchExecutionControlTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run testng JdiHangingListenExecutionControlTest\n+ * @run testng\/timeout=480 JdiHangingListenExecutionControlTest\n","filename":"test\/langtools\/jdk\/jshell\/JdiHangingListenExecutionControlTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.lang.reflect.Method;\n@@ -569,0 +570,30 @@\n+    public void assertCompletions(boolean after, String input, String expectedCompletionsPattern) {\n+        if (!after) {\n+            try {\n+                Class<?> sourceCodeAnalysisImpl = Class.forName(\"jdk.jshell.SourceCodeAnalysisImpl\");\n+                Method waitBackgroundTaskFinished = sourceCodeAnalysisImpl.getDeclaredMethod(\"waitCurrentBackgroundTasksFinished\");\n+\n+                waitBackgroundTaskFinished.setAccessible(true);\n+                waitBackgroundTaskFinished.invoke(null);\n+            } catch (ReflectiveOperationException ex) {\n+                throw new AssertionError(ex.getMessage(), ex);\n+            }\n+\n+            setCommandInput(input + \"\\t\");\n+        } else {\n+            assertOutput(getCommandOutput().trim(), \"\", \"command output: \" + input);\n+            assertOutput(getCommandErrorOutput(), \"\", \"command error: \" + input);\n+            assertOutput(getUserOutput(), \"\", \"user output: \" + input);\n+            assertOutput(getUserErrorOutput(), \"\", \"user error: \" + input);\n+            String actualOutput = getTerminalOutput();\n+            Pattern compiledPattern =\n+                    Pattern.compile(expectedCompletionsPattern, Pattern.DOTALL);\n+            if (!compiledPattern.asMatchPredicate().test(actualOutput)) {\n+                throw new AssertionError(\"Actual output:\\n\" +\n+                                         actualOutput + \"\\n\" +\n+                                         \"does not match expected pattern: \" +\n+                                         expectedCompletionsPattern);\n+            }\n+        }\n+    }\n+\n","filename":"test\/langtools\/jdk\/jshell\/ReplToolTesting.java","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,257 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8177650\n+ * @summary Verify JShell tool code completion\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.jdeps\/com.sun.tools.javap\n+ *          jdk.jshell\/jdk.jshell:+open\n+ *          jdk.jshell\/jdk.internal.jshell.tool\n+ *          java.desktop\n+ * @build toolbox.ToolBox toolbox.JarTask toolbox.JavacTask\n+ * @build ReplToolTesting TestingInputStream Compiler\n+ * @run testng ToolCompletionTest\n+ *\/\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import org.testng.annotations.Test;\n+\n+public class ToolCompletionTest extends ReplToolTesting {\n+\n+    private final Compiler compiler = new Compiler();\n+    private final Path outDir = Paths.get(\"tool_completion_test\");\n+\n+    @Test\n+    public void testClassPathOnCmdLineIndexing() {\n+        Path p1 = outDir.resolve(\"dir1\");\n+        compiler.compile(p1,\n+                \"\"\"\n+                package p1.p2;\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p3;\n+                public class Test {\n+                }\n+                \"\"\");\n+        String jarName = \"test.jar\";\n+        compiler.jar(p1, jarName, \"p1\/p2\/Test.class\", \"p1\/p3\/Test.class\");\n+\n+        test(false, new String[]{\"--no-startup\", \"--class-path\", compiler.getPath(p1.resolve(jarName)).toString()},\n+                (a) -> assertCompletions(a, \"p1.\", \".*p2\\\\..*p3\\\\..*\"),\n+                 \/\/cancel the input, so that JShell can be finished:\n+                (a) -> assertCommand(a, \"\\003\", null)\n+                );\n+    }\n+\n+    @Test\n+    public void testClassPathViaEnvIndexing() {\n+        Path p1 = outDir.resolve(\"dir1\");\n+        compiler.compile(p1,\n+                \"\"\"\n+                package p1.p2;\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p3;\n+                public class Test {\n+                }\n+                \"\"\");\n+        String jarName = \"test.jar\";\n+        compiler.jar(p1, jarName, \"p1\/p2\/Test.class\", \"p1\/p3\/Test.class\");\n+\n+        test(false, new String[]{\"--no-startup\"},\n+                (a) -> assertCommand(a, \"\/env --class-path \" + compiler.getPath(p1.resolve(jarName)).toString(), null),\n+                (a) -> assertCompletions(a, \"p1.\", \".*p2\\\\..*p3\\\\..*\"),\n+                 \/\/cancel the input, so that JShell can be finished:\n+                (a) -> assertCommand(a, \"\\003\", null)\n+                );\n+    }\n+\n+    @Test\n+    public void testClassPathChangeIndexing() {\n+        \/\/verify that changing the classpath has effect:\n+        Path dir1 = outDir.resolve(\"dir1\");\n+        compiler.compile(dir1,\n+                \"\"\"\n+                package p1.p2;\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p3;\n+                public class Test {\n+                }\n+                \"\"\");\n+        String jarName1 = \"test1.jar\";\n+        compiler.jar(dir1, jarName1, \"p1\/p2\/Test.class\", \"p1\/p3\/Test.class\");\n+\n+        Path dir2 = outDir.resolve(\"dir2\");\n+        compiler.compile(dir2,\n+                \"\"\"\n+                package p1.p5;\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p6;\n+                public class Test {\n+                }\n+                \"\"\");\n+        String jarName2 = \"test2.jar\";\n+        compiler.jar(dir2, jarName2, \"p1\/p5\/Test.class\", \"p1\/p6\/Test.class\");\n+\n+        test(false, new String[]{\"--no-startup\", \"--class-path\", compiler.getPath(dir1.resolve(jarName1)).toString()},\n+                (a) -> assertCommand(a, \"1\", null),\n+                (a) -> assertCommand(a, \"\/env --class-path \" + compiler.getPath(dir2.resolve(jarName2)).toString(), null),\n+                (a) -> assertCompletions(a, \"p1.\", \".*p5\\\\..*p6\\\\..*\"),\n+                 \/\/cancel the input, so that JShell can be finished:\n+                (a) -> assertCommand(a, \"\\003\", null)\n+                );\n+    }\n+\n+    @Test\n+    public void testModulePathOnCmdLineIndexing() {\n+        Path p1 = outDir.resolve(\"dir1\");\n+        compiler.compile(p1,\n+                \"\"\"\n+                module m {\n+                    exports p1.p2;\n+                    exports p1.p3;\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p2;\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p3;\n+                public class Test {\n+                }\n+                \"\"\");\n+        String jarName = \"test.jar\";\n+        compiler.jar(p1, jarName, \"p1\/p2\/Test.class\", \"p1\/p3\/Test.class\");\n+\n+        test(false, new String[]{\"--no-startup\", \"--module-path\", compiler.getPath(p1.resolve(jarName)).toString()},\n+                (a) -> assertCompletions(a, \"p1.\", \".*p2\\\\..*p3\\\\..*\"),\n+                 \/\/cancel the input, so that JShell can be finished:\n+                (a) -> assertCommand(a, \"\\003\", null)\n+                );\n+    }\n+\n+    @Test\n+    public void testModulePathOnCmdLineIndexing2() throws IOException {\n+        Path p1 = outDir.resolve(\"dir1\");\n+        compiler.compile(p1,\n+                \"\"\"\n+                module m {\n+                    exports p1.p2;\n+                    exports p1.p3;\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p2;\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p3;\n+                public class Test {\n+                }\n+                \"\"\");\n+        String jarName = \"test.jar\";\n+        Path lib = outDir.resolve(\"lib\");\n+        Files.createDirectories(lib);\n+        compiler.jar(p1, lib.resolve(jarName), \"p1\/p2\/Test.class\", \"p1\/p3\/Test.class\");\n+\n+        test(false, new String[]{\"--no-startup\", \"--module-path\", lib.toString()},\n+                (a) -> assertCompletions(a, \"p1.\", \".*p2\\\\..*p3\\\\..*\"),\n+                 \/\/cancel the input, so that JShell can be finished:\n+                (a) -> assertCommand(a, \"\\003\", null)\n+                );\n+    }\n+\n+    @Test\n+    public void testUpgradeModulePathIndexing() {\n+        Path p1 = outDir.resolve(\"dir1\");\n+        compiler.compile(p1,\n+                \"\"\"\n+                module m {\n+                    exports p1.p2;\n+                    exports p1.p3;\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p2;\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p3;\n+                public class Test {\n+                }\n+                \"\"\");\n+        String jarName = \"test.jar\";\n+        compiler.jar(p1, jarName, \"p1\/p2\/Test.class\", \"p1\/p3\/Test.class\");\n+\n+        test(false, new String[]{\"--no-startup\", \"-C--upgrade-module-path\", \"-C\" + compiler.getPath(p1.resolve(jarName)).toString()},\n+                (a) -> assertCompletions(a, \"p1.\", \".*p2\\\\..*p3\\\\..*\"),\n+                 \/\/cancel the input, so that JShell can be finished:\n+                (a) -> assertCommand(a, \"\\003\", null)\n+                );\n+    }\n+\n+    @Test\n+    public void testBootClassPathPrepend() {\n+        Path p1 = outDir.resolve(\"dir1\");\n+        compiler.compile(p1,\n+                \"\"\"\n+                package p1.p2;\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p3;\n+                public class Test {\n+                }\n+                \"\"\");\n+        String jarName = \"test.jar\";\n+        compiler.jar(p1, jarName, \"p1\/p2\/Test.class\", \"p1\/p3\/Test.class\");\n+\n+        test(false, new String[]{\"--no-startup\", \"-C-Xbootclasspath\/p:\" + compiler.getPath(p1.resolve(jarName)).toString(), \"-C--source=8\"},\n+                (a) -> assertCompletions(a, \"p1.\", \".*p2\\\\..*p3\\\\..*\"),\n+                 \/\/cancel the input, so that JShell can be finished:\n+                (a) -> assertCommand(a, \"\\003\", null)\n+                );\n+    }\n+}\n","filename":"test\/langtools\/jdk\/jshell\/ToolCompletionTest.java","additions":257,"deletions":0,"binary":false,"changes":257,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run testng\/othervm ToolLocalSimpleTest\n+ * @run testng\/othervm\/timeout=480 ToolLocalSimpleTest\n","filename":"test\/langtools\/jdk\/jshell\/ToolLocalSimpleTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run testng ToolSimpleTest\n+ * @run testng\/timeout=480 ToolSimpleTest\n","filename":"test\/langtools\/jdk\/jshell\/ToolSimpleTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -148,12 +148,1 @@\n-    private static final long TIMEOUT;\n-\n-    static {\n-        long factor;\n-\n-        try {\n-            factor = (long) Double.parseDouble(System.getProperty(\"test.timeout.factor\", \"1\"));\n-        } catch (NumberFormatException ex) {\n-            factor = 1;\n-        }\n-        TIMEOUT = 60_000 * factor;\n-    }\n+    private static final long TIMEOUT = (long) (60_000 * Double.parseDouble(System.getProperty(\"test.timeout.factor\", \"1.0\")));\n","filename":"test\/langtools\/jdk\/jshell\/UITesting.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run testng VariablesTest\n+ * @run testng\/timeout=480 VariablesTest\n","filename":"test\/langtools\/jdk\/jshell\/VariablesTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run main MineField\n+ * @run main\/timeout=480 MineField\n","filename":"test\/langtools\/tools\/javac\/Paths\/MineField.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main WildcardMineField\n+ * @run main\/timeout=480 WildcardMineField\n","filename":"test\/langtools\/tools\/javac\/Paths\/WildcardMineField.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm CheckExamples\n+ * @run main\/othervm\/timeout=480 CheckExamples\n","filename":"test\/langtools\/tools\/javac\/diags\/CheckExamples.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/othervm RunExamples\n+ * @run main\/othervm\/timeout=480 RunExamples\n","filename":"test\/langtools\/tools\/javac\/diags\/RunExamples.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @run main CheckAttributedTree -q -r -et ERRONEOUS .\n+ * @run main\/timeout=480 CheckAttributedTree -q -r -et ERRONEOUS .\n","filename":"test\/langtools\/tools\/javac\/failover\/CheckAttributedTree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run testng MultiReleaseJarTest\n+ * @run testng\/timeout=480 MultiReleaseJarTest\n","filename":"test\/langtools\/tools\/javac\/file\/MultiReleaseJar\/MultiReleaseJarTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @run main\/timeout=480 GenericConstructorAndDiamondTest\n","filename":"test\/langtools\/tools\/javac\/generics\/diamond\/7030150\/GenericConstructorAndDiamondTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @run main NegativeCyclicDependencyTest\n+ * @run main\/timeout=480 NegativeCyclicDependencyTest\n","filename":"test\/langtools\/tools\/javac\/importscope\/NegativeCyclicDependencyTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main LambdaParserTest\n+ * @run main\/timeout=480 LambdaParserTest\n","filename":"test\/langtools\/tools\/javac\/lambda\/LambdaParserTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -9,0 +9,2 @@\n+\n+timeout.default.seconds=480\n","filename":"test\/langtools\/tools\/javac\/lambda\/bridge\/template_tests\/TEST.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @run main\/timeout=480  IntersectionTargetTypeTest\n","filename":"test\/langtools\/tools\/javac\/lambda\/intersection\/IntersectionTargetTypeTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8362237\n- * @summary Test source launcher with specific VM behaviors\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.launcher\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          java.base\/jdk.internal.module\n- * @build toolbox.JavaTask toolbox.JavacTask toolbox.TestRunner toolbox.ToolBox\n- * @run main\/othervm -XX:-StackTraceInThrowable SourceLauncherStackTraceTest\n- *\/\n-\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.List;\n-\n-import toolbox.TestRunner;\n-\n-\/\/\/ SourceLauncherTest runs the source launcher in the same VM, so we must\n-\/\/\/ use another test to run specific tests with specific VM flags\n-public class SourceLauncherStackTraceTest extends TestRunner {\n-\n-    \/\/ Inheritance will shadow all parent tests\n-    SourceLauncherTest parent = new SourceLauncherTest();\n-\n-    SourceLauncherStackTraceTest() {\n-        super(System.err);\n-    }\n-\n-    public static void main(String... args) throws Exception {\n-        SourceLauncherStackTraceTest t = new SourceLauncherStackTraceTest();\n-        t.runTests(m -> new Object[] { Paths.get(m.getName()) });\n-    }\n-\n-    \/*\n-     * Tests in which main throws an exception without a stacktrace.\n-     *\/\n-    @Test\n-    public void testTargetException2(Path base) throws IOException {\n-        parent.tb.writeJavaFiles(base, \"\"\"\n-                public class TestLauncher {\n-                    public static TestLauncher test() {\n-                        throw new RuntimeException(\"No trace\");\n-                    }\n-\n-                    public static void main(String[] args) {\n-                        \/\/ This will throw a RuntimeException without\n-                        \/\/ a stack trace due to VM options\n-                        test();\n-                    }\n-                }\n-                \"\"\");\n-        Path file = base.resolve(\"TestLauncher.java\");\n-        SourceLauncherTest.Result r = parent.run(file, List.of(), List.of(\"3\"));\n-        parent.checkEmpty(\"stdout\", r.stdOut());\n-        parent.checkEmpty(\"stderr\", r.stdErr());\n-        parent.checkTrace(\"exception\", r.exception(), \"java.lang.RuntimeException: No trace\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherStackTraceTest.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -27,0 +27,1 @@\n+ *      8362237\n@@ -717,0 +718,23 @@\n+    \/*\n+     * Tests in which main throws a traceless exception.\n+     *\/\n+    @Test\n+    public void testTracelessTargetException(Path base) throws IOException {\n+        tb.writeJavaFiles(base, \"\"\"\n+            class TestLauncherException extends RuntimeException {\n+                TestLauncherException() {\n+                    super(\"No trace\", null, true, false); \/\/ No writable trace\n+                }\n+\n+                public static void main(String... args) {\n+                    throw new TestLauncherException();\n+                }\n+            }\n+            \"\"\");\n+        Path file = base.resolve(\"TestLauncherException.java\");\n+        SourceLauncherTest.Result r = run(file, List.of(), List.of(\"3\"));\n+        checkEmpty(\"stdout\", r.stdOut());\n+        checkEmpty(\"stderr\", r.stdErr());\n+        checkTrace(\"exception\", r.exception(), \"TestLauncherException: No trace\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n- * @run junit CreateSymbolsReproducibleTest\n+ * @run junit\/timeout=480 CreateSymbolsReproducibleTest\n","filename":"test\/langtools\/tools\/javac\/platform\/createsymbols\/CreateSymbolsReproducibleTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run main JavacTreeScannerTest -q -r .\n+ * @run main\/timeout=480 JavacTreeScannerTest -q -r .\n","filename":"test\/langtools\/tools\/javac\/tree\/JavacTreeScannerTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n- * @run main SourceDocTreeScannerTest -q -r .\n+ * @run main\/timeout=480 SourceDocTreeScannerTest -q -r .\n","filename":"test\/langtools\/tools\/javac\/tree\/SourceDocTreeScannerTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run main SourceTreeScannerTest -q -r .\n+ * @run main\/timeout=480 SourceTreeScannerTest -q -r .\n","filename":"test\/langtools\/tools\/javac\/tree\/SourceTreeScannerTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @run main\/timeout=480 TestComparisons\n","filename":"test\/langtools\/tools\/javac\/types\/TestComparisons.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run junit IteratorsTest\n+ * @run junit\/timeout=480 IteratorsTest\n","filename":"test\/langtools\/tools\/javac\/util\/IteratorsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm Warn5\n+ * @run main\/othervm\/timeout=480 Warn5\n","filename":"test\/langtools\/tools\/javac\/varargs\/warning\/Warn5.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,6 +105,0 @@\n-    \/** The timeout factor for slow systems. *\/\n-    public static final float timeoutFactor;\n-    static {\n-        String ttf = System.getProperty(\"test.timeout.factor\");\n-        timeoutFactor = (ttf == null) ? 1.0f : Float.parseFloat(ttf);\n-    }\n@@ -485,2 +479,2 @@\n-    private static final int RETRY_DELETE_MILLIS = isWindows() ? (int)(500 * timeoutFactor): 0;\n-    private static final int MAX_RETRY_DELETE_MILLIS = isWindows() ? (int)(15 * 1000 * timeoutFactor) : 0;\n+    private static final int RETRY_DELETE_MILLIS = isWindows() ? 500 : 0;\n+    private static final int MAX_RETRY_DELETE_MILLIS = isWindows() ? 60 * 1000 : 0;\n","filename":"test\/langtools\/tools\/lib\/toolbox\/ToolBox.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -231,3 +231,0 @@\n-    \/\/ This property is passed to child test processes\n-    public static final String TestTimeoutFactor = System.getProperty(\"test.timeout.factor\", \"1.0\");\n-\n@@ -436,1 +433,1 @@\n-        cmd.add(\"-Dtest.timeout.factor=\" + TestTimeoutFactor);\n+        cmd.add(\"-Dtest.timeout.factor=\" + Utils.TIMEOUT_FACTOR);\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSTestUtils.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.security.cert.*;\n+import java.security.cert.Extension;\n@@ -29,4 +31,0 @@\n-import java.security.cert.X509Certificate;\n-import java.security.cert.CertificateException;\n-import java.security.cert.CertificateFactory;\n-import java.security.cert.Extension;\n@@ -59,0 +57,1 @@\n+\n@@ -103,0 +102,83 @@\n+    public enum KeyUsage {\n+        DIGITAL_SIGNATURE,\n+        NONREPUDIATION,\n+        KEY_ENCIPHERMENT,\n+        DATA_ENCIPHERMENT,\n+        KEY_AGREEMENT,\n+        KEY_CERT_SIGN,\n+        CRL_SIGN,\n+        ENCIPHER_ONLY,\n+        DECIPHER_ONLY;\n+    }\n+\n+    \/**\n+     * Create a new CertificateBuilder instance. This method sets the subject name,\n+     * public key, authority key id, and serial number.\n+     *\n+     * @param subjectName entity associated with the public key\n+     * @param publicKey the entity's public key\n+     * @param caKey public key of certificate signer\n+     * @param keyUsages list of key uses\n+     * @return\n+     * @throws CertificateException\n+     * @throws IOException\n+     *\/\n+    public static CertificateBuilder newCertificateBuilder(String subjectName,\n+                           PublicKey publicKey, PublicKey caKey, KeyUsage... keyUsages)\n+            throws CertificateException, IOException {\n+        SecureRandom random = new SecureRandom();\n+\n+        boolean [] keyUsage = new boolean[KeyUsage.values().length];\n+        for (KeyUsage ku : keyUsages) {\n+            keyUsage[ku.ordinal()] = true;\n+        }\n+\n+        CertificateBuilder builder = new CertificateBuilder()\n+                .setSubjectName(subjectName)\n+                .setPublicKey(publicKey)\n+                .setSerialNumber(BigInteger.valueOf(random.nextLong(1000000)+1))\n+                .addSubjectKeyIdExt(publicKey)\n+                .addAuthorityKeyIdExt(caKey);\n+        if (keyUsages.length != 0) {\n+            builder.addKeyUsageExt(keyUsage);\n+        }\n+        return builder;\n+    }\n+\n+    \/**\n+     * Create a Subject Alternative Name extension for the given DNS name\n+     * @param critical Sets the extension to critical or non-critical\n+     * @param dnsName DNS name to use in the extension\n+     * @throws IOException\n+     *\/\n+    public static SubjectAlternativeNameExtension createDNSSubjectAltNameExt(\n+            boolean critical, String dnsName) throws IOException {\n+        GeneralNames gns = new GeneralNames();\n+        gns.add(new GeneralName(new DNSName(dnsName)));\n+        return new SubjectAlternativeNameExtension(critical, gns);\n+    }\n+\n+    \/**\n+     * Create a Subject Alternative Name extension for the given IP address\n+     * @param critical Sets the extension to critical or non-critical\n+     * @param ipAddress IP address to use in the extension\n+     * @throws IOException\n+     *\/\n+    public static SubjectAlternativeNameExtension createIPSubjectAltNameExt(\n+            boolean critical, String ipAddress) throws IOException {\n+        GeneralNames gns = new GeneralNames();\n+        gns.add(new GeneralName(new IPAddressName(ipAddress)));\n+        return new SubjectAlternativeNameExtension(critical, gns);\n+    }\n+\n+    public static void printCertificate(X509Certificate certificate, PrintStream ps) {\n+        try {\n+            Base64.Encoder encoder = Base64.getEncoder();\n+            ps.println(\"-----BEGIN CERTIFICATE-----\");\n+            ps.println(encoder.encodeToString(certificate.getEncoded()));\n+            ps.println(\"-----END CERTIFICATE-----\");\n+        } catch (CertificateEncodingException exc) {\n+            exc.printStackTrace(ps);\n+        }\n+    }\n+\n@@ -180,0 +262,5 @@\n+    public CertificateBuilder setOneHourValidity() {\n+        return setNotBefore(Date.from(Instant.now().minus(5, ChronoUnit.MINUTES)))\n+                .setNotAfter(Date.from(Instant.now().plus(1, ChronoUnit.HOURS)));\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/security\/CertificateBuilder.java","additions":91,"deletions":4,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jdk.test.lib.Utils;\n@@ -35,4 +36,0 @@\n-    \/\/ The jtreg testing timeout factor.\n-    private static final double TIMEOUT_FACTOR = Double.valueOf(\n-            System.getProperty(\"test.timeout.factor\", \"1.0\"));\n-\n@@ -60,1 +57,1 @@\n-        return waitFor(booleanSupplier, Math.round(1000L * TIMEOUT_FACTOR));\n+        return waitFor(booleanSupplier, Math.round(1000L * Utils.TIMEOUT_FACTOR));\n","filename":"test\/lib\/jdk\/test\/lib\/util\/ForceGC.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025 IBM Corporation. All rights reserved.\n@@ -265,0 +266,14 @@\n+    @Benchmark\n+    public void convertD2LBits() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resL[i] = Double.doubleToLongBits(doubles[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertD2LBitsRaw() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resL[i] = Double.doubleToRawLongBits(doubles[i]);\n+        }\n+    }\n+\n@@ -272,0 +287,14 @@\n+    @Benchmark\n+    public void convertF2IBits() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resI[i] = Float.floatToIntBits(floats[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertF2IBitsRaw() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resI[i] = (int) Float.floatToRawIntBits(floats[i]);\n+        }\n+    }\n+\n@@ -307,0 +336,7 @@\n+    @Benchmark\n+    public void convertIBits2F() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resF[i] = Float.intBitsToFloat(ints[i]);\n+        }\n+    }\n+\n@@ -328,0 +364,7 @@\n+    @Benchmark\n+    public void convertLBits2D() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resD[i] = Double.longBitsToDouble(longs[i]);\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/TypeVectorOperations.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,308 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 1, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 1)\n+public abstract class VectorAliasing {\n+    @Param({\/*\"512\",  \"1024\", *\/  \"10000\"})\n+    public int SIZE;\n+\n+    public static int INVAR_ZERO = 0;\n+\n+    \/\/ For all types we have an \"a\" and \"b\" series. Each series is an alias to the same array.\n+    private byte[] aB;\n+    private byte[] bB;\n+\n+    private int[] aI;\n+    private int[] bI;\n+\n+    private long[] aL;\n+    private long[] bL;\n+\n+    private int iteration = 0;\n+\n+    @Param(\"0\")\n+    private int seed;\n+    private Random r = new Random(seed);\n+\n+    @Setup\n+    public void init() {\n+        aB = new byte[SIZE];\n+        bB = new byte[SIZE];\n+\n+        aI = new int[SIZE];\n+        bI = new int[SIZE];\n+\n+        aL = new long[SIZE];\n+        bL = new long[SIZE];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            aB[i] = (byte) r.nextInt();\n+            bB[i] = (byte) r.nextInt();\n+\n+            aI[i] = r.nextInt();\n+            bI[i] = r.nextInt();\n+\n+            aL[i] = r.nextLong();\n+            bL[i] = r.nextLong();\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void copy_B(byte[] a, byte b[]) {\n+        for (int i = 0; i < a.length; i++) {\n+            b[i] = a[i];\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void copy_B(byte[] a, byte b[], int aOffset, int bOffset, int size) {\n+        for (int i = 0; i < size; i++) {\n+            b[i + bOffset] = a[i + aOffset];\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void copy_I(int[] a, int[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            b[i] = a[i];\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void copy_I(int[] a, int[] b, int aOffset, int bOffset, int size) {\n+        for (int i = 0; i < size; i++) {\n+            b[i + bOffset] = a[i + aOffset];\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void copy_L(long[] a, long[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            b[i] = a[i];\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void copy_L(long[] a, long[] b, int aOffset, int bOffset, int size) {\n+        for (int i = 0; i < size; i++) {\n+            b[i + bOffset] = a[i + aOffset];\n+        }\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes with static analysis, since using same index -> iterations trivially independent.\n+    public void bench_copy_array_B_sameIndex_noalias() {\n+        copy_B(bB, aB);\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes with static analysis, since using same index -> iterations trivially independent.\n+    public void bench_copy_array_B_sameIndex_alias() {\n+        copy_B(aB, aB);\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    public void bench_copy_array_B_differentIndex_noalias() {\n+        copy_B(bB, aB, 0, 0, aB.length);\n+    }\n+\n+    @Benchmark\n+    \/\/ never vectorizes, with our without runtime check\n+    public void bench_copy_array_B_differentIndex_alias() {\n+        copy_B(aB, aB, 0, 0, aB.length);\n+    }\n+\n+    @Benchmark\n+    \/\/ Requires multiversioning for vectorization.\n+    \/\/ With only the predicate, we will eventually deopt and compile without vectorization.\n+    public void bench_copy_array_B_differentIndex_mixed() {\n+        if ((iteration++) % 2 == 0) {\n+            copy_B(bB, aB, 0, 0, aB.length); \/\/ noalias\n+        } else {\n+            copy_B(aB, aB, 0, 0, aB.length); \/\/ alias\n+        }\n+    }\n+\n+    \/\/ No overlap -> expect vectoirzation.\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    @Benchmark\n+    public void bench_copy_array_B_half() {\n+        copy_B(aB, aB, 0, aB.length \/ 2, aB.length \/ 2);\n+    }\n+\n+    \/\/ Overlap, but never alias -> expect vectorization.\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    @Benchmark\n+    public void bench_copy_array_B_partial_overlap() {\n+        copy_B(aB, aB, 0, aB.length \/ 4, aB.length \/ 4 * 3);\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes with static analysis, since using same index -> iterations trivially independent.\n+    public void bench_copy_array_I_sameIndex_noalias() {\n+        copy_I(bI, aI);\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes with static analysis, since using same index -> iterations trivially independent.\n+    public void bench_copy_array_I_sameIndex_alias() {\n+        copy_I(aI, aI);\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    public void bench_copy_array_I_differentIndex_noalias() {\n+        copy_I(bI, aI, 0, 0, aI.length);\n+    }\n+\n+    @Benchmark\n+    \/\/ never vectorizes, with our without runtime check\n+    public void bench_copy_array_I_differentIndex_alias() {\n+        copy_I(aI, aI, 0, 0, aI.length);\n+    }\n+\n+    @Benchmark\n+    \/\/ Requires multiversioning for vectorization.\n+    \/\/ With only the predicate, we will eventually deopt and compile without vectorization.\n+    public void bench_copy_array_I_differentIndex_mixed() {\n+        if ((iteration++) % 2 == 0) {\n+            copy_I(bI, aI, 0, 0, aI.length); \/\/ noalias\n+        } else {\n+            copy_I(aI, aI, 0, 0, aI.length); \/\/ alias\n+        }\n+    }\n+\n+    \/\/ No overlap -> expect vectoirzation.\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    @Benchmark\n+    public void bench_copy_array_I_half() {\n+        copy_I(aI, aI, 0, aI.length \/ 2, aI.length \/ 2);\n+    }\n+\n+    \/\/ Overlap, but never alias -> expect vectorization.\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    @Benchmark\n+    public void bench_copy_array_I_partial_overlap() {\n+        copy_I(aI, aI, 0, aI.length \/ 4, aI.length \/ 4 * 3);\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes with static analysis, since using same index -> iterations trivially independent.\n+    public void bench_copy_array_L_sameIndex_noalias() {\n+        copy_L(bL, aL);\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes with static analysis, since using same index -> iterations trivially independent.\n+    public void bench_copy_array_L_sameIndex_alias() {\n+        copy_L(aL, aL);\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    public void bench_copy_array_L_differentIndex_noalias() {\n+        copy_L(bL, aL, 0, 0, aL.length);\n+    }\n+\n+    @Benchmark\n+    \/\/ never vectorizes, with our without runtime check\n+    public void bench_copy_array_L_differentIndex_alias() {\n+        copy_L(aL, aL, 0, 0, aL.length);\n+    }\n+\n+    @Benchmark\n+    \/\/ Requires multiversioning for vectorization.\n+    \/\/ With only the predicate, we will eventually deopt and compile without vectorization.\n+    public void bench_copy_array_L_differentIndex_mixed() {\n+        if ((iteration++) % 2 == 0) {\n+            copy_L(bL, aL, 0, 0, aL.length); \/\/ noalias\n+        } else {\n+            copy_L(aL, aL, 0, 0, aL.length); \/\/ alias\n+        }\n+    }\n+\n+    \/\/ No overlap -> expect vectoirzation.\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    @Benchmark\n+    public void bench_copy_array_L_half() {\n+        copy_L(aL, aL, 0, aL.length \/ 2, aL.length \/ 2);\n+    }\n+\n+    \/\/ Overlap, but never alias -> expect vectorization.\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    @Benchmark\n+    public void bench_copy_array_L_partial_overlap() {\n+        copy_L(aL, aL, 0, aL.length \/ 4, aL.length \/ 4 * 3);\n+    }\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:+UseSuperWord\",\n+        \"-XX:+UnlockDiagnosticVMOptions\",\n+        \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"\n+    })\n+    public static class VectorAliasingSuperWordWithoutSpeculativeAliasingChecks extends VectorAliasing {}\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:+UseSuperWord\",\n+        \"-XX:+UnlockDiagnosticVMOptions\",\n+        \"-XX:-UseAutoVectorizationPredicate\"\n+    })\n+    public static class VectorAliasingSuperWordWithoutAutoVectorizationPredicate extends VectorAliasing {}\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:+UseSuperWord\",\n+        \"-XX:+UnlockDiagnosticVMOptions\",\n+        \"-XX:-LoopMultiversioning\"\n+    })\n+    public static class VectorAliasingSuperWordWithoutMultiversioning extends VectorAliasing {}\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:+UseSuperWord\",\n+        \"-XX:+UnlockDiagnosticVMOptions\",\n+        \"-XX:AutoVectorizationOverrideProfitability=0\"\n+    })\n+    public static class VectorAliasingSuperWordPretendNotProfitable extends VectorAliasing {}\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:+UseSuperWord\"\n+    })\n+    public static class VectorAliasingSuperWord extends VectorAliasing {}\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:-UseSuperWord\"\n+    })\n+    public static class VectorAliasingNoSuperWord extends VectorAliasing {}\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorAliasing.java","additions":308,"deletions":0,"binary":false,"changes":308,"status":"added"}]}