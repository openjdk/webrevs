{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,2 @@\n+import sun.jvmstat.monitor.MonitoredHost;\n+\n@@ -231,1 +233,1 @@\n-        return new File(findTargetProcessTmpDirectory(pid, ns_pid), \".java_pid\" + ns_pid);\n+        return new File(findTargetProcessTmpDirectory(pid), \".java_pid\" + ns_pid);\n@@ -246,1 +248,1 @@\n-            f = new File(findTargetProcessTmpDirectory(pid, ns_pid), fn.toString());\n+            f = new File(findTargetProcessTmpDirectory(pid), fn.toString());\n@@ -252,2 +254,2 @@\n-    private String findTargetProcessTmpDirectory(long pid, long ns_pid) throws AttachNotSupportedException, IOException {\n-        final var procPidRoot = PROC.resolve(Long.toString(pid)).resolve(ROOT_TMP);\n+    private String findTargetProcessTmpDirectory(long pid) throws AttachNotSupportedException {\n+        final var tmpOnProcPidRoot = PROC.resolve(Long.toString(pid)).resolve(ROOT_TMP);\n@@ -264,6 +266,2 @@\n-         * with the target\/attachee process, we can try, except in the case where the ns_pid also exists in this pid ns\n-         * which is ambiguous, if we share \/tmp with the intended target, the attach will succeed, if we do not,\n-         * then we will potentially attempt to attach to some arbitrary process with the same pid (in this pid ns)\n-         * as that of the intended target (in its * pid ns).\n-         *\n-         * so in that case we should prehaps throw - or risk sending SIGQUIT to some arbitrary process... which could kill it\n+         * with the target\/attachee process, so we should check whether \/tmp on both is same. This method would throw\n+         * AttachNotSupportedException if they are different because we cannot make a connection with target VM.\n@@ -271,1 +269,1 @@\n-         * however we can also check the target pid's signal masks to see if it catches SIGQUIT and only do so if in\n+         * In addition, we can also check the target pid's signal masks to see if it catches SIGQUIT and only do so if in\n@@ -274,2 +272,0 @@\n-         *\n-         * note that if pid == ns_pid we are in a shared pid ns with the target and may (potentially) share \/tmp\n@@ -278,1 +274,30 @@\n-        return (Files.isWritable(procPidRoot) ? procPidRoot : TMPDIR).toString();\n+        try {\n+            if (Files.isWritable(tmpOnProcPidRoot)) {\n+                return tmpOnProcPidRoot.toString();\n+            } else if (Files.isSameFile(tmpOnProcPidRoot, TMPDIR)) {\n+                return TMPDIR.toString();\n+            } else {\n+                throw new AttachNotSupportedException(\"Unable to access the filesystem of the target process\");\n+            }\n+        } catch (IOException ioe) {\n+            try {\n+                boolean found = MonitoredHost.getMonitoredHost(\"\/\/localhost\")\n+                                             .activeVms()\n+                                             .stream()\n+                                             .anyMatch(i -> pid == i.intValue());\n+                if (found) {\n+                    \/\/ We can use \/tmp because target process is on same host\n+                    \/\/ even if we cannot access \/proc\/<PID>\/root.\n+                    \/\/ The process with capsh\/setcap would fall this pattern.\n+                    return TMPDIR.toString();\n+                } else {\n+                    throw new AttachNotSupportedException(\"Unable to access the filesystem of the target process\", ioe);\n+                }\n+            } catch (AttachNotSupportedException e) {\n+                \/\/ AttachNotSupportedException happened in above should go through\n+                throw e;\n+            } catch (Exception e) {\n+                \/\/ Other exceptions would be wrapped with AttachNotSupportedException\n+                throw new AttachNotSupportedException(\"Unable to access the filesystem of the target process\", e);\n+            }\n+        }\n","filename":"src\/jdk.attach\/linux\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":40,"deletions":15,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,11 @@\n+    \/**\n+     * Constructs an <code>AttachNotSupportedException<\/code> with\n+     * the specified cause.\n+     *\n+     * @param   message the detail message.\n+     * @param   cause   the cause of this exception.\n+     *\/\n+    public AttachNotSupportedException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+\n","filename":"src\/jdk.attach\/share\/classes\/com\/sun\/tools\/attach\/AttachNotSupportedException.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2026, NTT DATA\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n+\n+import com.sun.tools.attach.VirtualMachine;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.thread.ProcessThread;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/*\n+ * @test\n+ * @bug 8226919 8373867\n+ * @summary Test to make sure attach target process which is not dumpable.\n+ * @library \/test\/lib\n+ * @modules jdk.attach\n+ * @requires os.family == \"linux\"\n+ *\n+ * @run main\/timeout=200 TestWithoutDumpableProcess\n+ *\/\n+public class TestWithoutDumpableProcess {\n+\n+    private static final String EXPECTED_PROP_KEY = \"attach.test\";\n+    private static final String EXPECTED_PROP_VALUE = \"true\";\n+\n+    public static class Debuggee {\n+\n+        \/\/ Disable dumpable attribute via prctl(2)\n+        private static void disableDumpable() throws Throwable {\n+            var linker = Linker.nativeLinker();\n+            var prctl = linker.downcallHandle(linker.defaultLookup().findOrThrow(\"prctl\"),\n+                                              FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.JAVA_INT, ValueLayout.JAVA_LONG),\n+                                              Linker.Option.firstVariadicArg(1), Linker.Option.captureCallState(\"errno\"));\n+            var errnoSeg = Arena.global().allocate(Linker.Option.captureStateLayout());\n+            final int PR_SET_DUMPABLE = 4; \/\/ from linux\/prctl.h\n+\n+            int ret = (int)prctl.invoke(errnoSeg, PR_SET_DUMPABLE, 0L);\n+            if (ret == -1){\n+                var hndErrno = Linker.Option\n+                                     .captureStateLayout()\n+                                     .varHandle(MemoryLayout.PathElement.groupElement(\"errno\"));\n+                int errno = (int)hndErrno.get(errnoSeg, 0L);\n+                throw new RuntimeException(\"prctl: errno=\" + errno);\n+            }\n+        }\n+\n+        public static void main(String[] args) throws Throwable {\n+            disableDumpable();\n+            IO.println(Application.READY_MSG);\n+\n+            while (IO.readln().equals(Application.SHUTDOWN_MSG));\n+        }\n+\n+        public static ProcessThread start() {\n+            var args = new String[]{\n+                \"--enable-native-access=ALL-UNNAMED\",\n+                String.format(\"-D%s=%s\", EXPECTED_PROP_KEY, EXPECTED_PROP_VALUE), Debuggee.class.getName()\n+            };\n+            var pb = ProcessTools.createLimitedTestJavaProcessBuilder(args);\n+            var pt = new ProcessThread(\"runApplication\", Application.READY_MSG::equals, pb);\n+            pt.start();\n+            return pt;\n+        }\n+\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        var pt = Debuggee.start();\n+        var vm = VirtualMachine.attach(Long.toString(pt.getPid()));\n+        var val = vm.getSystemProperties().getProperty(EXPECTED_PROP_KEY);\n+\n+        Asserts.assertNotNull(val, \"Expected sysprop not found\");\n+        Asserts.assertEquals(val, \"true\", \"Unexpected sysprop value\");\n+    }\n+\n+}\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/TestWithoutDumpableProcess.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"}]}