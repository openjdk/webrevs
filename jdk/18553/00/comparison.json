{"files":[{"patch":"@@ -85,13 +85,0 @@\n-\/* Place holders for the old native interface. *\/\n-\n-long\n-sun_awt_image_GifImageDecoder_parseImage()\n-{\n-  return 0;\n-}\n-\n-void\n-sun_awt_image_GifImageDecoder_initIDs()\n-{\n-}\n-\n","filename":"src\/java.desktop\/share\/native\/libawt\/awt\/image\/gif\/gifdecoder.c","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-IMGEXTERN jfieldID g_RasterBaseRasterID;\n","filename":"src\/java.desktop\/share\/native\/libawt\/awt\/image\/imageInitIDs.h","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -880,14 +880,0 @@\n-INLINE BOOL RectInMonitorRect(RECT *rCheck, RECT *rContainer)\n-{\n-    \/\/ Assumption: left <= right, top <= bottom\n-    if (rCheck->left >= rContainer->left &&\n-        rCheck->right <= rContainer->right &&\n-        rCheck->top >= rContainer->top &&\n-        rCheck->bottom <= rContainer->bottom)\n-    {\n-        return TRUE;\n-    } else {\n-        return FALSE;\n-    }\n-}\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/windows\/GDIRenderer.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -256,38 +256,0 @@\n-static BOOL GDIWinSD_CheckMonitorArea(GDIWinSDOps *wsdo,\n-                                     SurfaceDataBounds *bounds,\n-                                     HDC hDC)\n-{\n-    HWND hW = wsdo->window;\n-    BOOL retCode = TRUE;\n-\n-    J2dTraceLn(J2D_TRACE_INFO, \"GDIWinSD_CheckMonitorArea\");\n-    int numScreens;\n-    {\n-        Devices::InstanceAccess devices;\n-        numScreens = devices->GetNumDevices();\n-    }\n-    if( numScreens > 1 ) {\n-\n-        LPMONITORINFO miInfo;\n-        RECT rSect ={0,0,0,0};\n-        RECT rView ={bounds->x1, bounds->y1, bounds->x2, bounds->y2};\n-        retCode = FALSE;\n-\n-        miInfo = wsdo->device->GetMonitorInfo();\n-\n-        POINT ptOrig = {0, 0};\n-        ::ClientToScreen(hW, &ptOrig);\n-        ::OffsetRect(&rView,\n-            (ptOrig.x), (ptOrig.y));\n-\n-        ::IntersectRect(&rSect,&rView,&(miInfo->rcMonitor));\n-\n-        if( FALSE == ::IsRectEmpty(&rSect) ) {\n-            if( TRUE == ::EqualRect(&rSect,&rView) ) {\n-                retCode = TRUE;\n-            }\n-        }\n-    }\n-    return retCode;\n-}\n-\n@@ -555,105 +517,0 @@\n-static jboolean GDIWinSD_SimpleClip(JNIEnv *env, GDIWinSDOps *wsdo,\n-                                   SurfaceDataBounds *bounds,\n-                                   HDC hDC)\n-{\n-    RECT rClip;\n-\n-    J2dTraceLn(J2D_TRACE_INFO, \"GDIWinSD_SimpleClip\");\n-    if (hDC == NULL) {\n-        return JNI_FALSE;\n-    }\n-\n-    int nComplexity = ::GetClipBox(hDC, &rClip);\n-\n-    switch (nComplexity) {\n-    case COMPLEXREGION:\n-        {\n-            J2dTraceLn(J2D_TRACE_VERBOSE,\n-                       \"  complex clipping region\");\n-            \/\/ if complex user\/system clip, more detailed testing required\n-            \/\/ check to see if the view itself has a complex clip.\n-            \/\/ ::GetClipBox is only API which returns overlapped window status\n-            \/\/ so we set the rView as our clip, and then see if resulting\n-            \/\/ clip is complex.\n-            \/\/ Only other way to figure this out would be to walk the\n-            \/\/ overlapping windows (no API to get the actual visible clip\n-            \/\/ list).  Then we'd still have to merge that info with the\n-            \/\/ clip region for the dc (if it exists).\n-            \/\/ REMIND: we can cache the CreateRectRgnIndirect result,\n-            \/\/ and only override with ::SetRectRgn\n-\n-            \/\/ First, create a region handle (need existing HRGN for\n-            \/\/ the following call).\n-            HRGN rgnSave = ::CreateRectRgn(0, 0, 0, 0);\n-            int  clipStatus = ::GetClipRgn(hDC, rgnSave);\n-            if (-1 == clipStatus) {\n-                J2dTraceLn(J2D_TRACE_WARNING,\n-                           \"GDIWinSD_SimpleClip: failed due to clip status\");\n-                ::DeleteObject(rgnSave);\n-                return JNI_FALSE;\n-            }\n-            HRGN rgnBounds = ::CreateRectRgn(\n-                bounds->x1 - wsdo->insets.left,\n-                bounds->y1 - wsdo->insets.top,\n-                bounds->x2 - wsdo->insets.left,\n-                bounds->y2 - wsdo->insets.top);\n-            ::SelectClipRgn(hDC, rgnBounds);\n-            nComplexity = ::GetClipBox(hDC, &rClip);\n-            ::SelectClipRgn(hDC, clipStatus? rgnSave: NULL);\n-            ::DeleteObject(rgnSave);\n-            ::DeleteObject(rgnBounds);\n-\n-            \/\/ Now, test the new clip box.  If it's still not a\n-            \/\/ SIMPLE region, then our bounds must intersect part of\n-            \/\/ the clipping article\n-            if (SIMPLEREGION != nComplexity) {\n-                J2dTraceLn(J2D_TRACE_WARNING,\n-                           \"GDIWinSD_SimpleClip: failed due to complexity\");\n-                return JNI_FALSE;\n-            }\n-        }\n-        \/\/ NOTE: No break here - we want to fall through into the\n-        \/\/ SIMPLE case, adjust our bounds by the new rClip rect\n-        \/\/ and make sure that our locking bounds are not empty.\n-    case SIMPLEREGION:\n-        J2dTraceLn(J2D_TRACE_VERBOSE, \"  simple clipping region\");\n-        \/\/ Constrain the bounds to the given clip box\n-        if (bounds->x1 < rClip.left) {\n-            bounds->x1 = rClip.left;\n-        }\n-        if (bounds->y1 < rClip.top) {\n-            bounds->y1 = rClip.top;\n-        }\n-        if (bounds->x2 > rClip.right) {\n-            bounds->x2 = rClip.right;\n-        }\n-        if (bounds->y2 > rClip.bottom) {\n-            bounds->y2 = rClip.bottom;\n-        }\n-        \/\/ If the bounds are 0 or negative, then the bounds have\n-        \/\/ been obscured by the clip box, so return FALSE\n-        if ((bounds->x2 <= bounds->x1) ||\n-            (bounds->y2 <= bounds->y1)) {\n-            \/\/ REMIND: We should probably do something different here\n-            \/\/ instead of simply returning FALSE.  Since the bounds are\n-            \/\/ empty we won't end up drawing anything, so why spend the\n-            \/\/ effort of returning false and having GDI do a LOCK_BY_DIB?\n-            \/\/ Perhaps we need a new lock code that will indicate that we\n-            \/\/ shouldn't bother drawing?\n-            J2dTraceLn(J2D_TRACE_WARNING,\n-                       \"GDIWinSD_SimpleClip: failed due to empty bounds\");\n-            return JNI_FALSE;\n-        }\n-        break;\n-    case NULLREGION:\n-    case ERROR:\n-    default:\n-        J2dTraceLn1(J2D_TRACE_ERROR,\n-                   \"GDIWinSD_SimpleClip: failed due to incorrect complexity=%d\",\n-                    nComplexity);\n-        return JNI_FALSE;\n-    }\n-\n-    return JNI_TRUE;\n-}\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/windows\/GDIWindowSurfaceData.cpp","additions":0,"deletions":143,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -47,21 +47,0 @@\n-\n-static BOOL IsSupportedLevel(HANDLE hPrinter, DWORD dwLevel) {\n-    BOOL isSupported = FALSE;\n-    DWORD cbBuf = 0;\n-    LPBYTE pPrinter = NULL;\n-\n-    DASSERT(hPrinter != NULL);\n-\n-    VERIFY(::GetPrinter(hPrinter, dwLevel, NULL, 0, &cbBuf) == 0);\n-    if (::GetLastError() == ERROR_INSUFFICIENT_BUFFER) {\n-        pPrinter = new BYTE[cbBuf];\n-        if (::GetPrinter(hPrinter, dwLevel, pPrinter, cbBuf, &cbBuf)) {\n-            isSupported = TRUE;\n-        }\n-        delete[] pPrinter;\n-    }\n-\n-    return isSupported;\n-}\n-\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/WPrinterJob.cpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -255,35 +255,0 @@\n-struct EnvHolder\n-{\n-    JavaVM *m_pVM;\n-    JNIEnv *m_env;\n-    bool    m_isOwner;\n-    EnvHolder(\n-        JavaVM *pVM,\n-        LPCSTR name = \"COM holder\",\n-        jint ver = JNI_VERSION_1_2)\n-    : m_pVM(pVM),\n-      m_env((JNIEnv *)JNU_GetEnv(pVM, ver)),\n-      m_isOwner(false)\n-    {\n-        if (NULL == m_env) {\n-            JavaVMAttachArgs attachArgs;\n-            attachArgs.version  = ver;\n-            attachArgs.name     = const_cast<char *>(name);\n-            attachArgs.group    = NULL;\n-            jint status = m_pVM->AttachCurrentThread(\n-                (void**)&m_env,\n-                &attachArgs);\n-            m_isOwner = (NULL!=m_env);\n-        }\n-    }\n-    ~EnvHolder() {\n-        if (m_isOwner) {\n-            m_pVM->DetachCurrentThread();\n-        }\n-    }\n-    operator bool()  const { return NULL!=m_env; }\n-    bool operator !()  const { return NULL==m_env; }\n-    operator JNIEnv*() const { return m_env; }\n-    JNIEnv* operator ->() const { return m_env; }\n-};\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt.h","additions":0,"deletions":35,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -83,1 +83,0 @@\n-static HWND g_hwndDown = NULL;\n@@ -201,4 +200,0 @@\n-static BOOL bLeftShiftIsDown = false;\n-static BOOL bRightShiftIsDown = false;\n-static UINT lastShiftKeyPressed = 0; \/\/ init to safe value\n-\n@@ -1295,1 +1290,0 @@\n-        WIN_MSG(WM_AWT_PRINT_COMPONENT)\n@@ -1301,2 +1295,0 @@\n-        WIN_MSG(WM_AWT_FORWARD_BYTE)\n-        WIN_MSG(WM_AWT_SET_SCROLL_INFO)\n@@ -1308,4 +1300,0 @@\n-        WIN_MSG(WM_AWT_PRE_KEYDOWN)\n-        WIN_MSG(WM_AWT_PRE_KEYUP)\n-        WIN_MSG(WM_AWT_PRE_SYSKEYDOWN)\n-        WIN_MSG(WM_AWT_PRE_SYSKEYUP)\n@@ -1323,1 +1311,0 @@\n-        WIN_MSG(WM_AWT_SETCURSOR,)\n@@ -1327,2 +1314,0 @@\n-        WIN_MSG(WM_AWT_EXECUTE_SYNC,)\n-        WIN_MSG(WM_AWT_CURSOR_SYNC)\n@@ -1332,2 +1317,0 @@\n-        WIN_MSG(WM_AWT_SHOWCURSOR)\n-        WIN_MSG(WM_AWT_HIDECURSOR)\n@@ -1420,6 +1403,0 @@\n-      case WM_AWT_SHOWCURSOR:\n-          ::ShowCursor(TRUE);\n-          break;\n-      case WM_AWT_HIDECURSOR:\n-          ::ShowCursor(FALSE);\n-          break;\n@@ -1843,4 +1820,0 @@\n-      case WM_AWT_FORWARD_BYTE:\n-          mr = HandleEvent( (MSG *) lParam, (BOOL) wParam);\n-          break;\n-\n@@ -1979,7 +1952,0 @@\n-      case WM_AWT_SET_SCROLL_INFO: {\n-          SCROLLINFO *si = (SCROLLINFO *) lParam;\n-          ::SetScrollInfo(GetHWnd(), (int) wParam, si, TRUE);\n-          delete si;\n-          mr = mrConsume;\n-          break;\n-      }\n@@ -5236,83 +5202,0 @@\n-void AwtComponent::SendFocusEvent(jint id, HWND opposite)\n-{\n-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);\n-\n-    CriticalSection::Lock l(GetLock());\n-    if (GetPeer(env) == NULL) {\n-        \/* event received during termination. *\/\n-        return;\n-    }\n-\n-    static jclass focusEventCls;\n-    if (focusEventCls == NULL) {\n-        jclass focusEventClsLocal\n-            = env->FindClass(\"java\/awt\/event\/FocusEvent\");\n-        DASSERT(focusEventClsLocal);\n-        CHECK_NULL(focusEventClsLocal);\n-        focusEventCls = (jclass)env->NewGlobalRef(focusEventClsLocal);\n-        env->DeleteLocalRef(focusEventClsLocal);\n-    }\n-\n-    static jmethodID focusEventConst;\n-    if (focusEventConst == NULL) {\n-        focusEventConst =\n-            env->GetMethodID(focusEventCls, \"<init>\",\n-                             \"(Ljava\/awt\/Component;IZLjava\/awt\/Component;)V\");\n-        DASSERT(focusEventConst);\n-        CHECK_NULL(focusEventConst);\n-    }\n-\n-    static jclass sequencedEventCls;\n-    if (sequencedEventCls == NULL) {\n-        jclass sequencedEventClsLocal =\n-            env->FindClass(\"java\/awt\/SequencedEvent\");\n-        DASSERT(sequencedEventClsLocal);\n-        CHECK_NULL(sequencedEventClsLocal);\n-        sequencedEventCls =\n-            (jclass)env->NewGlobalRef(sequencedEventClsLocal);\n-        env->DeleteLocalRef(sequencedEventClsLocal);\n-    }\n-\n-    static jmethodID sequencedEventConst;\n-    if (sequencedEventConst == NULL) {\n-        sequencedEventConst =\n-            env->GetMethodID(sequencedEventCls, \"<init>\",\n-                             \"(Ljava\/awt\/AWTEvent;)V\");\n-        DASSERT(sequencedEventConst);\n-        CHECK_NULL(sequencedEventConst);\n-    }\n-\n-    if (env->EnsureLocalCapacity(3) < 0) {\n-        return;\n-    }\n-\n-    jobject target = GetTarget(env);\n-    jobject jOpposite = NULL;\n-    if (opposite != NULL) {\n-        AwtComponent *awtOpposite = AwtComponent::GetComponent(opposite);\n-        if (awtOpposite != NULL) {\n-            jOpposite = awtOpposite->GetTarget(env);\n-        }\n-    }\n-    jobject focusEvent = env->NewObject(focusEventCls, focusEventConst,\n-                                        target, id, JNI_FALSE, jOpposite);\n-    DASSERT(!safe_ExceptionOccurred(env));\n-    DASSERT(focusEvent != NULL);\n-    if (jOpposite != NULL) {\n-        env->DeleteLocalRef(jOpposite); jOpposite = NULL;\n-    }\n-    env->DeleteLocalRef(target); target = NULL;\n-    CHECK_NULL(focusEvent);\n-\n-    jobject sequencedEvent = env->NewObject(sequencedEventCls,\n-                                            sequencedEventConst,\n-                                            focusEvent);\n-    DASSERT(!safe_ExceptionOccurred(env));\n-    DASSERT(sequencedEvent != NULL);\n-    env->DeleteLocalRef(focusEvent); focusEvent = NULL;\n-    CHECK_NULL(sequencedEvent);\n-    SendEvent(sequencedEvent);\n-\n-    env->DeleteLocalRef(sequencedEvent);\n-}\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Component.cpp","additions":0,"deletions":117,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -405,7 +405,0 @@\n-    \/*\n-     * Allocate and initialize a new java.awt.event.FocusEvent, and\n-     * post it to the peer's target object.  No response is expected\n-     * from the target.\n-     *\/\n-    void SendFocusEvent(jint id, HWND opposite);\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Component.h","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -522,1 +522,1 @@\n-        ::SetCursor(hCursor); \/\/ don't need WM_AWT_SETCURSOR\n+        ::SetCursor(hCursor);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Cursor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,54 +73,0 @@\n-static void DumpRegion(HRGN rgn) {\n-    DWORD size = ::GetRegionData(rgn, 0, NULL);\n-    char* buffer = (char *)safe_Malloc(size);\n-    memset(buffer, 0, size);\n-    LPRGNDATA rgndata = (LPRGNDATA)buffer;\n-    rgndata->rdh.dwSize = sizeof(RGNDATAHEADER);\n-    rgndata->rdh.iType = RDH_RECTANGLES;\n-    VERIFY(::GetRegionData(rgn, size, rgndata));\n-\n-    RECT* r = (RECT*)(buffer + rgndata->rdh.dwSize);\n-    for (DWORD i=0; i<rgndata->rdh.nCount; i++) {\n-        if ( !::IsRectEmpty(r) ) {\n-            DTrace_PrintImpl(\"\\trect %d %d %d %d\\n\", r->left, r->top, r->right, r->bottom);\n-        }\n-        r++;\n-    }\n-\n-    free(buffer);\n-}\n-\n-\/*\n- * DTRACE print callback to dump HDC clip region bounding rectangle\n- *\/\n-void DumpClipRectangle(const char * file, int line, int argc, const char * fmt, va_list arglist) {\n-    const char *msg = va_arg(arglist, const char *);\n-    HDC         hdc = va_arg(arglist, HDC);\n-    RECT        r;\n-\n-    DASSERT(argc == 2 && hdc != NULL);\n-    DASSERT(msg != NULL);\n-\n-    ::GetClipBox(hdc, &r);\n-    DTrace_PrintImpl(\"%s: hdc=%x, %d %d %d %d\\n\", msg, hdc, r.left, r.top, r.right, r.bottom);\n-}\n-\n-\/*\n- * DTRACE print callback to dump window's update region bounding rectangle\n- *\/\n-void DumpUpdateRectangle(const char * file, int line, int argc, const char * fmt, va_list arglist) {\n-    const char *msg = va_arg(arglist, const char *);\n-    HWND        hwnd = va_arg(arglist, HWND);\n-    RECT        r;\n-\n-    DASSERT(argc == 2 && ::IsWindow(hwnd));\n-    DASSERT(msg != NULL);\n-\n-    ::GetUpdateRect(hwnd, &r, FALSE);\n-    HRGN rgn = ::CreateRectRgn(0,0,1,1);\n-    int updated = ::GetUpdateRgn(hwnd, rgn, FALSE);\n-    DTrace_PrintImpl(\"%s: hwnd=%x, %d %d %d %d\\n\", msg, hwnd, r.left, r.top, r.right, r.bottom);\n-    DumpRegion(rgn);\n-    DeleteObject(rgn);\n-}\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Debug.cpp","additions":0,"deletions":54,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -57,8 +57,0 @@\n-    extern void DumpClipRectangle(const char * file, int line, int argc, const char * fmt, va_list arglist);\n-    extern void DumpUpdateRectangle(const char * file, int line, int argc, const char * fmt, va_list arglist);\n-\n-    #define AWT_DUMP_UPDATE_RECTANGLE(_msg, _hwnd) \\\n-        _DTrace_Template(DumpUpdateRectangle, 2, \"\", (_msg), (_hwnd), 0, 0, 0, 0, 0, 0)\n-\n-    #define AWT_DUMP_CLIP_RECTANGLE(_msg, _hwnd) \\\n-        _DTrace_Template(DumpClipRectangle, 2, \"\", (_msg), (_hwnd), 0, 0, 0, 0, 0, 0)\n@@ -74,3 +66,0 @@\n-    #define AWT_DUMP_UPDATE_RECTANGLE(_msg, _hwnd) ((void)0)\n-    #define AWT_DUMP_CLIP_RECTANGLE(_msg, _hwnd) ((void)0)\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Debug.h","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -157,1 +157,0 @@\n-        static FORMATETC fm = {0};\n@@ -1269,2 +1268,0 @@\n-DECLARE_JAVA_CLASS(awtIEClazz, \"java\/awt\/event\/InputEvent\")\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_DnDDS.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -267,1 +267,0 @@\n-        static jclass           awtIEClazz;\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_DnDDS.h","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1267,1 +1267,1 @@\n-            AwtWindow::WinThreadExecProc(args);\n+            DASSERT(FALSE);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Frame.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -177,47 +177,0 @@\n-\/\/\n-\/\/ (static)\n-\/\/ Switches to Windows thread via SendMessage and synchronously\n-\/\/ calls AwtObject::WinThreadExecProc with the given command id\n-\/\/ and parameters.\n-\/\/\n-\/\/ Useful for writing code that needs to be synchronized with\n-\/\/ what's happening on the Windows thread.\n-\/\/\n-LRESULT AwtObject::WinThreadExec(\n-    jobject                             peerObject,\n-    UINT                                cmdId,\n-    LPARAM                              param1,\n-    LPARAM                              param2,\n-    LPARAM                              param3,\n-    LPARAM                              param4 )\n-{\n-    DASSERT( peerObject != NULL);\n-\n-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);\n-    \/\/ since we pass peerObject to another thread we must\n-    \/\/   make a global ref\n-    jobject peerObjectGlobalRef = env->NewGlobalRef(peerObject);\n-\n-    ExecuteArgs         args;\n-    LRESULT         retVal;\n-\n-    \/\/ setup arguments\n-    args.cmdId = cmdId;\n-    args.param1 = param1;\n-    args.param2 = param2;\n-    args.param3 = param3;\n-    args.param4 = param4;\n-\n-    \/\/ call WinThreadExecProc on the toolkit thread\n-    retVal = AwtToolkit::GetInstance().SendMessage(WM_AWT_EXECUTE_SYNC,\n-                                                   (WPARAM)peerObjectGlobalRef,\n-                                                   (LPARAM)&args);\n-    return retVal;\n-}\n-\n-LRESULT AwtObject::WinThreadExecProc(ExecuteArgs * args)\n-{\n-    DASSERT(FALSE); \/\/ no default handler\n-    return 0L;\n-}\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Object.cpp","additions":0,"deletions":47,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -123,5 +123,0 @@\n-    \/\/ execute given code on Windows message-pump thread\n-    static LRESULT WinThreadExec(jobject peerObject, UINT cmdId, LPARAM param1 = 0L, LPARAM param2 = 0L, LPARAM param3 = 0L, LPARAM param4 = 0L);\n-    \/\/ callback function to execute code on Windows message-pump thread\n-    virtual LRESULT WinThreadExecProc(AwtObject::ExecuteArgs * args);\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Object.h","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -66,5 +66,0 @@\n-\/*** Private Constants ***\/\n-\n-static const char *kJavaIntStr = \"I\";\n-static const char *kJavaLongStr = \"J\";\n-\n@@ -310,3 +305,0 @@\n-static jboolean jFontToWFontA(JNIEnv *env, HDC printDC, jstring fontName,\n-                        jfloat fontSize, jboolean isBold, jboolean isItalic,\n-                        jint rotation, jfloat awScale);\n@@ -318,4 +310,0 @@\n-static int CALLBACK fontEnumProcA(ENUMLOGFONTEXA  *logfont,\n-                                  NEWTEXTMETRICEX  *lpntme,\n-                                  int FontType,\n-                                  LPARAM lParam);\n@@ -2256,125 +2244,0 @@\n-\/**\n- * Try to convert a java font to a GDI font. On entry, 'printDC',\n- * is the device context we want to draw into. 'fontName' is\n- * the name of the font to be matched and 'fontSize' is the\n- * size of the font in device coordinates. If there is an\n- * equivalent GDI font then this function sets that font\n- * into 'printDC' and returns a 'true'. If there is no equivalent\n- * font then 'false' is returned.\n- *\/\n-static jboolean jFontToWFontA(JNIEnv *env, HDC printDC, jstring fontName,\n-                        jfloat fontSize, jboolean isBold, jboolean isItalic,\n-                        jint rotation, jfloat awScale)\n-{\n-    LOGFONTA lf;\n-    LOGFONTA matchedLogFont;\n-    BOOL foundFont = false;     \/\/ Assume we didn't find a matching GDI font.\n-\n-    memset(&matchedLogFont, 0, sizeof(matchedLogFont));\n-\n-    LPCWSTR fontNameW = JNU_GetStringPlatformChars(env, fontName, NULL);\n-\n-\n-    \/* Some fontnames of Non-ASCII fonts like 'MS Minchou' are themselves\n-     * Non-ASCII.  They are assumed to be written in Unicode.\n-     * Hereby, they are converted into platform codeset.\n-     *\/\n-    int maxlen = static_cast<int>(sizeof(lf.lfFaceName)) - 1;\n-    \/\/ maxlen is int due to cbMultiByte parameter is int\n-    int destLen = WideCharToMultiByte(CP_ACP,        \/\/ convert to ASCII code page\n-                                      0,             \/\/ flags\n-                                      fontNameW,     \/\/ Unicode string\n-                                      -1,            \/\/ Unicode length is calculated automatically\n-                                      lf.lfFaceName, \/\/ Put ASCII string here\n-                                      maxlen,        \/\/ max len\n-                                      NULL,          \/\/ default handling of unmappables\n-                                      NULL);         \/\/ do not care if def char is used\n-\n-    \/* If WideCharToMultiByte succeeded then the number\n-     * of bytes it copied into the face name buffer will\n-     * be greater than zero and we just need to NULL terminate\n-     * the string. If there was an error then the number of\n-     * bytes copied is zero and we can not match the font.\n-     *\/\n-    if (destLen > 0) {\n-\n-        DASSERT(destLen < sizeof(lf.lfFaceName));\n-        lf.lfFaceName[destLen] = '\\0';\n-        lf.lfCharSet = DEFAULT_CHARSET;\n-        lf.lfPitchAndFamily = 0;\n-\n-        foundFont = !EnumFontFamiliesExA((HDC)printDC, &lf,\n-                                        (FONTENUMPROCA) fontEnumProcA,\n-                                        (LPARAM) &matchedLogFont, 0);\n-    }\n-\n-\n-    if (foundFont) {\n-\n-        \/* Build a font of the requested size with no\n-         * width modifications. A negative font height\n-         * tells GDI that we want that values absolute\n-         * value as the font's point size. If the font\n-         * is successfully built then set it as the current\n-         * GDI font.\n-         *\/\n-        matchedLogFont.lfHeight = -ROUND_TO_LONG(fontSize);\n-        matchedLogFont.lfWidth = 0;\n-        matchedLogFont.lfEscapement = rotation;\n-        matchedLogFont.lfOrientation = rotation;\n-        matchedLogFont.lfUnderline = 0;\n-        matchedLogFont.lfStrikeOut = 0;\n-\n-        \/* Force bold or italic if requested. The font name\n-           such as Arial Bold may have already set a weight\n-           so here we just try to increase it.\n-        *\/\n-        if (isBold) {\n-            matchedLogFont.lfWeight = embolden(matchedLogFont.lfWeight);\n-        } else {\n-            matchedLogFont.lfWeight = FW_REGULAR;\n-        }\n-\n-        if (isItalic) {\n-            matchedLogFont.lfItalic = 0xff;     \/\/ TRUE\n-        }  else {\n-            matchedLogFont.lfItalic = FALSE;\n-        }\n-\n-        HFONT font = CreateFontIndirectA(&matchedLogFont);\n-        if (font) {\n-            HFONT oldFont = (HFONT)::SelectObject(printDC, font);\n-            if (oldFont != NULL) {\n-                ::DeleteObject(oldFont);\n-                if (awScale != 1.0) {\n-                    TEXTMETRIC tm;\n-                    DWORD avgWidth;\n-                    GetTextMetrics(printDC, &tm);\n-                    avgWidth = tm.tmAveCharWidth;\n-                    matchedLogFont.lfWidth = (LONG)((fabs)(avgWidth*awScale));\n-                    font = CreateFontIndirectA(&matchedLogFont);\n-                    if (font) {\n-                        oldFont = (HFONT)::SelectObject(printDC, font);\n-                        if (oldFont != NULL) {\n-                            ::DeleteObject(oldFont);\n-                            GetTextMetrics(printDC, &tm);\n-                        } else {\n-                            foundFont = false;\n-                        }\n-                    } else {\n-                        foundFont = false;\n-                    }\n-                }\n-            } else {\n-                foundFont = false;\n-            }\n-        } else {\n-            foundFont = false;\n-        }\n-    }\n-\n-    JNU_ReleaseStringPlatformChars(env, fontName, fontNameW);\n-\n-    return foundFont ? JNI_TRUE : JNI_FALSE;\n-}\n-\n@@ -2515,23 +2378,0 @@\n-    if (matchedLogFont != NULL) {\n-        *matchedLogFont = logfont->elfLogFont;\n-    }\n-\n-    return stop;\n-}\n-\n-\/**\n- * Invoked by GDI as a result of the EnumFontFamiliesExA\n- * call this routine choses a GDI font that matches\n- * a Java font. When a match is found then function\n- * returns a zero result to terminate the EnumFontFamiliesExA\n- * call. The information about the chosen font is copied into\n- * the LOGFONTA structure pointed to by 'lParam'.\n- *\/\n-static int CALLBACK fontEnumProcA(ENUMLOGFONTEXA *logfont,\/\/ logical-font data\n-                    NEWTEXTMETRICEX *lpntme,              \/\/ physical-font data\n-                    int FontType,                         \/\/ type of font\n-                    LPARAM lParam)\n-{\n-    LOGFONTA *matchedLogFont = (LOGFONTA *) lParam;\n-    int stop = 0;          \/\/ Take the first style found.\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_PrintJob.cpp","additions":0,"deletions":160,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -914,14 +914,0 @@\n-      case WM_AWT_EXECUTE_SYNC: {\n-          jobject peerObject = (jobject)wParam;\n-          AwtObject* object = (AwtObject *)JNI_GET_PDATA(peerObject);\n-          DASSERT( !IsBadReadPtr(object, sizeof(AwtObject)));\n-          AwtObject::ExecuteArgs *args = (AwtObject::ExecuteArgs *)lParam;\n-          DASSERT(!IsBadReadPtr(args, sizeof(AwtObject::ExecuteArgs)));\n-          LRESULT result = 0;\n-          if (object != NULL)\n-          {\n-              result = object->WinThreadExecProc(args);\n-          }\n-          env->DeleteGlobalRef(peerObject);\n-          return result;\n-      }\n@@ -1283,4 +1269,0 @@\n-      case WM_AWT_SETCURSOR: {\n-          ::SetCursor((HCURSOR)wParam);\n-          return TRUE;\n-      }\n@@ -1972,6 +1954,0 @@\n-void AwtToolkit::SetHeapCheck(long flag) {\n-    if (flag) {\n-        printf(\"heap checking not supported with this build\\n\");\n-    }\n-}\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Toolkit.cpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -416,1 +416,0 @@\n-    INLINE void SetHeapCheck(long flag);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Toolkit.h","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -715,10 +715,0 @@\n-\/**\n- * Disables offscreen acceleration for this device.  This\n- * sets a flag in the java object that is used to determine\n- * whether offscreen surfaces can be created on the device.\n- *\/\n-void AwtWin32GraphicsDevice::DisableOffscreenAcceleration()\n-{\n-    \/\/ REMIND: noop for now\n-}\n-\n@@ -738,1 +728,0 @@\n-    DisableOffscreenAcceleration();\n@@ -805,16 +794,0 @@\n-void AwtWin32GraphicsDevice::DisableOffscreenAccelerationForDevice(\n-    HMONITOR hMonitor)\n-{\n-    Devices::InstanceAccess devices;\n-    if (hMonitor == NULL) {\n-        devices->GetDevice(0)->DisableOffscreenAcceleration();\n-    } else {\n-        int devicesNum = devices->GetNumDevices();\n-        for (int i = 0; i < devicesNum; ++i) {\n-            if (devices->GetDevice(i)->GetMonitor() == hMonitor) {\n-                devices->GetDevice(i)->DisableOffscreenAcceleration();\n-            }\n-        }\n-    }\n-}\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Win32GraphicsDevice.cpp","additions":0,"deletions":27,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -67,1 +67,0 @@\n-    void                    DisableOffscreenAcceleration();\n@@ -99,1 +98,0 @@\n-    static void             DisableOffscreenAccelerationForDevice(HMONITOR hMonitor);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Win32GraphicsDevice.h","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -183,11 +183,0 @@\n-struct OLEHolder\n-{\n-    OLEHolder()\n-    : m_hr(::OleInitialize(NULL))\n-    {}\n-\n-    ~OLEHolder(){}\n-    operator bool() const { return S_OK==SUCCEEDED(m_hr); }\n-    HRESULT m_hr;\n-};\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_ole.h","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -212,1 +212,0 @@\n-    WM_AWT_PRINT_COMPONENT,\n@@ -218,2 +217,0 @@\n-    WM_AWT_FORWARD_BYTE,\n-    WM_AWT_SET_SCROLL_INFO,\n@@ -225,4 +222,0 @@\n-    WM_AWT_PRE_KEYDOWN,\n-    WM_AWT_PRE_KEYUP,\n-    WM_AWT_PRE_SYSKEYDOWN,\n-    WM_AWT_PRE_SYSKEYUP,\n@@ -244,1 +237,0 @@\n-    WM_AWT_SETCURSOR,\n@@ -248,1 +240,0 @@\n-    WM_AWT_EXECUTE_SYNC,\n@@ -251,1 +242,0 @@\n-    WM_AWT_CURSOR_SYNC,\n@@ -255,2 +245,0 @@\n-    WM_AWT_SHOWCURSOR,\n-    WM_AWT_HIDECURSOR,\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awtmsg.h","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"}]}