{"files":[{"patch":"@@ -946,0 +946,1 @@\n+    _method_JvmtiHideEvents,\n@@ -1850,0 +1851,5 @@\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_JvmtiHideEvents_signature): {\n+      if (_location != _in_method)  break;  \/\/ only allow for methods\n+      if (!privileged)              break;  \/\/ only allow in privileged code\n+      return _method_JvmtiHideEvents;\n+    }\n@@ -1937,0 +1943,2 @@\n+  if (has_annotation(_method_JvmtiHideEvents))\n+    m->set_jvmti_hide_events();\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -309,0 +309,1 @@\n+  template(jdk_internal_vm_annotation_JvmtiHideEvents_signature,       \"Ljdk\/internal\/vm\/annotation\/JvmtiHideEvents;\")  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+   flag(jvmti_hide_events         , 1 << 21) \\\n","filename":"src\/hotspot\/share\/oops\/constMethodFlags.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -749,0 +749,3 @@\n+  bool jvmti_hide_events() const { return constMethod()->jvmti_hide_events(); }\n+  void set_jvmti_hide_events() { constMethod()->set_jvmti_hide_events(); }\n+\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -587,1 +587,0 @@\n-\n@@ -655,0 +654,23 @@\n+\/\/ An unmounted vthread may have an empty stack.\n+\/\/ Otherwise, it always has the yield0() and yield() frames we need to hide.\n+\/\/ The methods yield0() and yield() are annotated with the @JvmtiHideEvents.\n+javaVFrame*\n+JvmtiEnvBase::skip_yield_frames_for_unmounted_vthread(javaVFrame* jvf) {\n+  if (jvf == nullptr) {\n+    return jvf; \/\/ empty stack is possible\n+  }\n+  assert(jvf->method()->jvmti_hide_events(), \"sanity check\");\n+  assert(jvf->method()->method_holder() == vmClasses::Continuation_klass(), \"expected Continuation class\");\n+  jvf = jvf->java_sender(); \/\/ skip yield0 frame\n+\n+  assert(jvf != nullptr && jvf->method()->jvmti_hide_events(), \"sanity check\");\n+  assert(jvf->method()->method_holder() == vmClasses::Continuation_klass(), \"expected Continuation class\");\n+  jvf = jvf->java_sender(); \/\/ skip yield frame\n+  return jvf;\n+}\n+\n+\/\/ A thread may have an empty stack.\n+\/\/ Otherwise, some top frames may heed to be hidden.\n+\/\/ Two cases are processed below:\n+\/\/ - top frame is annotated with @JvmtiMountTransition: just skip top frames with annotated methods\n+\/\/ - JavaThread is in VTMS transition: skip top frames until a frame annotated with @ChangesCurrentThread is found\n@@ -657,3 +679,2 @@\n-  \/\/ The second condition is needed to hide notification methods.\n-  if (!is_in_VTMS_transition && (jvf == nullptr || !jvf->method()->jvmti_mount_transition())) {\n-    return jvf;  \/\/ No frames to skip.\n+  if (jvf == nullptr) {\n+    return jvf; \/\/ empty stack is possible\n@@ -661,5 +682,3 @@\n-  \/\/ Find jvf with a method annotated with @JvmtiMountTransition.\n-  for ( ; jvf != nullptr; jvf = jvf->java_sender()) {\n-    if (jvf->method()->jvmti_mount_transition()) {  \/\/ Cannot actually appear in an unmounted continuation; they're never frozen.\n-      jvf = jvf->java_sender();  \/\/ Skip annotated method.\n-      break;\n+  if (jvf->method()->jvmti_mount_transition()) {\n+    \/\/ Skip frames annotated with @JvmtiMountTransition.\n+    for ( ; jvf != nullptr && jvf->method()->jvmti_mount_transition(); jvf = jvf->java_sender()) {\n@@ -667,2 +686,3 @@\n-    if (jvf->method()->changes_current_thread()) {\n-      break;\n+  } else if (is_in_VTMS_transition) {\n+    \/\/ Skip frames above the frame annotated with @ChangesCurrentThread.\n+    for ( ; jvf != nullptr && !jvf->method()->changes_current_thread(); jvf = jvf->java_sender()) {\n@@ -670,1 +690,0 @@\n-    \/\/ Skip frame above annotated method.\n@@ -681,11 +700,0 @@\n-javaVFrame*\n-JvmtiEnvBase::check_and_skip_hidden_frames(oop vthread, javaVFrame* jvf) {\n-  JvmtiThreadState* state = java_lang_Thread::jvmti_thread_state(vthread);\n-  if (state == nullptr) {\n-    \/\/ nothing to skip\n-    return jvf;\n-  }\n-  jvf = check_and_skip_hidden_frames(java_lang_Thread::is_in_VTMS_transition(vthread), jvf);\n-  return jvf;\n-}\n-\n@@ -710,0 +718,1 @@\n+    assert(!java_thread->is_in_VTMS_transition(), \"invariant\");\n@@ -711,1 +720,1 @@\n-    jvf = check_and_skip_hidden_frames(java_thread, jvf);\n+    jvf = check_and_skip_hidden_frames(false, jvf);\n@@ -715,1 +724,1 @@\n-    jvf = check_and_skip_hidden_frames(vthread, jvf);\n+    jvf = skip_yield_frames_for_unmounted_vthread(jvf);\n@@ -728,5 +737,3 @@\n-  \/\/ Skip hidden frames only for carrier threads\n-  \/\/ which are in non-temporary VTMS transition.\n-  if (jt->is_in_VTMS_transition()) {\n-    jvf = check_and_skip_hidden_frames(jt, jvf);\n-  }\n+\n+  \/\/ Skip hidden frames for carrier threads only.\n+  jvf = check_and_skip_hidden_frames(jt, jvf);\n@@ -1335,1 +1342,3 @@\n-  if (jvf->method()->is_native() || (depth == 0 && state->top_frame_is_exiting())) {\n+  if (jvf->method()->is_native() ||\n+      (depth == 0 && state->top_frame_is_exiting()) ||\n+      (state->is_virtual() && jvf->method()->jvmti_hide_events())) {\n@@ -1992,1 +2001,0 @@\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":40,"deletions":32,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -369,0 +369,1 @@\n+  static javaVFrame* skip_yield_frames_for_unmounted_vthread(javaVFrame* jvf);\n@@ -371,1 +372,0 @@\n-  static javaVFrame* check_and_skip_hidden_frames(oop vthread, javaVFrame* jvf);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -836,5 +836,0 @@\n-  Thread* cur_thread = Thread::current();\n-  oop cont = java_lang_VirtualThread::continuation(_vthread_h());\n-  assert(cont != nullptr, \"vthread contintuation must not be null\");\n-\n-  javaVFrame* jvf = nullptr;\n@@ -848,0 +843,1 @@\n+  javaVFrame* jvf = JvmtiEnvBase::get_vthread_jvf(_vthread_h()); \n@@ -849,15 +845,0 @@\n-  if (is_cont_mounted) {\n-    vframeStream vfs(java_thread);\n-\n-    if (!vfs.at_end()) {\n-      jvf = vfs.asJavaVFrame();\n-      jvf = JvmtiEnvBase::check_and_skip_hidden_frames(java_thread, jvf);\n-    }\n-  } else {\n-    vframeStream vfs(cont);\n-\n-    if (!vfs.at_end()) {\n-      jvf = vfs.asJavaVFrame();\n-      jvf = JvmtiEnvBase::check_and_skip_hidden_frames(_vthread_h(), jvf);\n-    }\n-  }\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -256,1 +256,1 @@\n-\/\/ no-op if thread is non-null and not a virtual thread\n+\/\/ disable VTMS transitions for all threads if thread is nullptr or a platform thread\n@@ -269,0 +269,11 @@\n+  oop thread_oop = JNIHandles::resolve_external_guard(thread);\n+\n+  \/\/ Target can be virtual or platform thread.\n+  \/\/ If target is a platform thread then we have to disable VTMS transitions for all threads.\n+  \/\/ It is by several reasons:\n+  \/\/ - carrier threads can mount virtual threads which may cause incorrect behavior\n+  \/\/ - there is no mechanism to disable transitions for a specific carrier thread yet\n+  if (!java_lang_VirtualThread::is_instance(thread_oop)) {\n+    _thread = nullptr; \/\/ target is a platform thread, switch to disabling VTMS transitions for all threads\n+  }\n+\n@@ -319,3 +330,2 @@\n-  if (!java_lang_VirtualThread::is_instance(vth())) {\n-    return; \/\/ no-op if _thread is not a virtual thread\n-  }\n+  assert(java_lang_VirtualThread::is_instance(vth()), \"sanity check\");\n+\n@@ -471,1 +481,1 @@\n-        if (ml.wait(10)) {\n+        if (ml.wait(200)) {\n@@ -528,1 +538,1 @@\n-        if (ml.wait(10)) {\n+        if (ml.wait(200)) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+import jdk.internal.vm.annotation.JvmtiHideEvents;\n@@ -216,0 +217,1 @@\n+                @JvmtiHideEvents\n@@ -217,1 +219,6 @@\n-                    vthread.run(task);\n+                    vthread.notifyJvmtiStart(); \/\/ notify JVMTI\n+                    try {\n+                        vthread.run(task);\n+                    } finally {\n+                        vthread.notifyJvmtiEnd(); \/\/ notify JVMTI\n+                    }\n@@ -392,3 +399,0 @@\n-        \/\/ notify JVMTI, may post VirtualThreadStart event\n-        notifyJvmtiStart();\n-\n@@ -408,14 +412,8 @@\n-            try {\n-                \/\/ pop any remaining scopes from the stack, this may block\n-                StackableScope.popAll();\n-\n-                \/\/ emit JFR event if enabled\n-                if (VirtualThreadEndEvent.isTurnedOn()) {\n-                    var event = new VirtualThreadEndEvent();\n-                    event.javaThreadId = threadId();\n-                    event.commit();\n-                }\n-\n-            } finally {\n-                \/\/ notify JVMTI, may post VirtualThreadEnd event\n-                notifyJvmtiEnd();\n+            \/\/ pop any remaining scopes from the stack, this may block\n+            StackableScope.popAll();\n+\n+            \/\/ emit JFR event if enabled\n+            if (VirtualThreadEndEvent.isTurnedOn()) {\n+                var event = new VirtualThreadEndEvent();\n+                event.javaThreadId = threadId();\n+                event.commit();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.internal.vm.annotation.JvmtiHideEvents;\n@@ -308,0 +309,1 @@\n+    @JvmtiHideEvents\n@@ -319,0 +321,1 @@\n+    @JvmtiHideEvents\n@@ -343,0 +346,1 @@\n+    @JvmtiHideEvents\n@@ -355,0 +359,1 @@\n+    @JvmtiHideEvents\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/Continuation.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.vm.annotation;\n+\n+import java.lang.annotation.*;\n+\n+\/**\n+ * A method may be annotated with JvmtiHideEvents to hint it is not\n+ * desirable to sent JVMTI events in context of the annotated method.\n+ *\n+ * @implNote\n+ * This annotation is only used for some VirtualThread and Continuation methods.\n+ *\/\n+@Target({ElementType.METHOD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface JvmtiHideEvents {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/JvmtiHideEvents.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -31,2 +31,5 @@\n- * A method is annotated as \"jvmti mount transition\" if it starts\n- * or ends virtual thread mount state transition (VTMS transition).\n+ * A method may be annotated with JvmtiMountTransition to hint\n+ * it is desirable to omit it from JVMTI stack traces.\n+ * Normally, a method is annotated with @JvmtiMountTransition if it starts\n+ * or ends Virtual Thread Mount State (VTMS) transition, so the thread\n+ * identity is undefined or different at method entry and exit.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/JvmtiMountTransition.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-        checkFrames(vThread1, false, 13);\n+        checkFrames(vThread1, false, 11);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetFrameCount\/framecnt01\/framecnt01.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8341273\n+ * @summary Verifies JVMTI properly hides frames which are in VTMS transition\n+ * @run main\/othervm\/native -agentlib:CheckHiddenFrames CheckHiddenFrames\n+ *\/\n+\n+public class CheckHiddenFrames {\n+    static native boolean checkHidden(Thread t);\n+\n+    static void sleep(long millis) {\n+        try {\n+            Thread.sleep(millis);\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Thread thread = Thread.startVirtualThread(CheckHiddenFrames::test);\n+        System.out.println(\"Started virtual thread: \" + thread);\n+\n+        if (!checkHidden(thread)) {\n+            thread.interrupt();\n+            throw new RuntimeException(\"CheckHiddenFrames failed!\");\n+        }\n+        thread.interrupt();\n+        thread.join();\n+    }\n+\n+    static void test() {\n+        sleep(1000000);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/CheckHiddenFrames\/CheckHiddenFrames.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.hpp\"\n+\n+extern \"C\" {\n+\n+const int MAX_COUNT = 50;\n+static jvmtiEnv *jvmti = nullptr;\n+\n+static char*\n+get_frame_method_name(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread, jint depth) {\n+  jmethodID method = nullptr;\n+  jlocation location = 0;\n+\n+  jvmtiError err = jvmti->GetFrameLocation(thread, 0, &method, &location);\n+  check_jvmti_status(jni, err, \"get_method_name_at_depth: error in JVMTI GetFrameLocation\");\n+\n+  return get_method_name(jvmti, jni, method);\n+}\n+\n+static bool\n+method_must_be_hidden(char* mname) {\n+  return strcmp(mname, \"yield\")  == 0 ||\n+         strcmp(mname, \"yield0\") == 0;\n+}\n+\n+static jboolean\n+check_top_frames_location(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n+  jboolean status = JNI_TRUE;\n+\n+  for (int depth = 0; depth < 2; depth++) {\n+    char* mname = get_frame_method_name(jvmti, jni, thread, depth);\n+\n+    if (method_must_be_hidden(mname)) {\n+      LOG(\"Failed: GetFrameLocation returned info for frame expected to be hidden: frame[%d]=%s\\n\", depth, mname);\n+      status = JNI_FALSE;\n+    }\n+    deallocate(jvmti, jni, mname);\n+  }\n+  return status;\n+}\n+\n+static jboolean\n+check_top_frames_in_stack_trace(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n+  jboolean status = JNI_TRUE;\n+  jvmtiFrameInfo frameInfo[MAX_COUNT];\n+  jint count1 = 0;\n+  jint count2 = 0;\n+\n+  jvmtiError err = jvmti->GetStackTrace(thread, 0, MAX_COUNT, frameInfo, &count1);\n+  check_jvmti_status(jni, err, \"check_top_frames_in_stack_trace: error in JVMTI GetStackTrace\");\n+\n+  for (int depth = 0; depth < 2; depth++) {\n+    char* mname = get_method_name(jvmti, jni, frameInfo[depth].method);\n+\n+    if (method_must_be_hidden(mname)) {\n+      LOG(\"Failed: GetStackTrace returned info for frame expected to be hidden: frame[%d]=%s\\n\", depth, mname);\n+      status = JNI_FALSE;\n+    }\n+    deallocate(jvmti, jni, mname);\n+  }\n+\n+  err = jvmti->GetFrameCount(thread, &count2);\n+  check_jvmti_status(jni, err, \"check_top_frames_in_stack_trace: error in JVMTI GetFrameCount\");\n+\n+  if (count1 != count2) {\n+    LOG(\"Failed: frame counts returned by GetStackTrace and GetFrameCount do not match: %d!=%d\\n\", count1, count2);\n+    status = JNI_FALSE;\n+  }\n+  return status;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_CheckHiddenFrames_checkHidden(JNIEnv *jni, jclass clazz, jthread thread) {\n+  jboolean status = JNI_TRUE;\n+\n+  wait_for_state(jvmti, jni, thread, JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT);\n+  print_stack_trace(jvmti, jni, thread);\n+\n+\n+  if (!check_top_frames_location(jvmti, jni, thread)) {\n+    status = JNI_FALSE;\n+  }\n+  if (!check_top_frames_in_stack_trace(jvmti, jni, thread)) {\n+    status = JNI_FALSE;\n+  }\n+  return status;\n+}\n+\n+extern JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  LOG(\"Agent_OnLoad started\\n\");\n+  if (jvm->GetEnv((void **)(&jvmti), JVMTI_VERSION) != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+  LOG(\"Agent_OnLoad finished\\n\");\n+  return JNI_OK;\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/CheckHiddenFrames\/libCheckHiddenFrames.cpp","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"}]}