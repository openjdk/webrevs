{"files":[{"patch":"@@ -586,2 +586,4 @@\n-  jvf = JvmtiEnvBase::check_and_skip_hidden_frames(java_thread, jvf);\n-\n+  \/\/ There should not be any VTMS transition here. This is for safety.\n+  if (java_thread->is_in_VTMS_transition()) {\n+    jvf = JvmtiEnvBase::check_and_skip_hidden_frames(java_thread, jvf);\n+  }\n@@ -662,0 +664,3 @@\n+  \/\/ Two cases with the annotated methods to skip on the top:\n+  \/\/  - is_in_VTMS_transition == false and two top annotated methods are yield and yield0\n+  \/\/  - is_in_VTMS_transition = true and some methods followed by a motifyJvmti* method\n@@ -663,1 +668,2 @@\n-    if (jvf->method()->jvmti_mount_transition()) {  \/\/ Cannot actually appear in an unmounted continuation; they're never frozen.\n+    if (jvf->method()->jvmti_mount_transition()) {\n+      \/\/ The yield and yield0 may appear in an unmounted continuation.\n@@ -665,1 +671,1 @@\n-      break;\n+      continue;\n@@ -670,1 +676,6 @@\n-    \/\/ Skip frame above annotated method.\n+    if (is_in_VTMS_transition) {\n+      \/\/ Skip frames above annotated method.\n+    } else {\n+      \/\/ Stop at first frame with non-annotated method.\n+      break;\n+    }\n@@ -677,1 +688,5 @@\n-  jvf = check_and_skip_hidden_frames(jt->is_in_VTMS_transition(), jvf);\n+  bool is_virtual = java_lang_VirtualThread::is_instance(jt->jvmti_vthread());\n+\n+  if (is_virtual || jt->is_in_VTMS_transition()) { \/\/ filter out pure continuations\n+    jvf = check_and_skip_hidden_frames(jt->is_in_VTMS_transition(), jvf);\n+  }\n@@ -683,4 +698,2 @@\n-  JvmtiThreadState* state = java_lang_Thread::jvmti_thread_state(vthread);\n-  if (state == nullptr) {\n-    \/\/ nothing to skip\n-    return jvf;\n+  if (java_lang_VirtualThread::is_instance(vthread)) { \/\/ paranoid check for safety\n+    jvf = check_and_skip_hidden_frames(java_lang_Thread::is_in_VTMS_transition(vthread), jvf);\n@@ -688,1 +701,0 @@\n-  jvf = check_and_skip_hidden_frames(java_lang_Thread::is_in_VTMS_transition(vthread), jvf);\n@@ -728,2 +740,2 @@\n-  \/\/ Skip hidden frames only for carrier threads\n-  \/\/ which are in non-temporary VTMS transition.\n+\n+  \/\/ There should not be any VTMS transition here. This is for safety.\n@@ -731,0 +743,2 @@\n+    \/\/ Skip hidden frames only for carrier threads\n+    \/\/ which are in non-temporary VTMS transition.\n@@ -1992,0 +2006,2 @@\n+  oop thread_oop = JNIHandles::resolve_external_guard(target);\n+  bool is_virtual = java_lang_VirtualThread::is_instance(thread_oop);\n@@ -1993,1 +2009,4 @@\n-  JvmtiVTMSTransitionDisabler disabler(target);\n+  \/\/ Target can be virtual or platform thread.\n+  \/\/ Disable VTMS transition for one thread if it is virtual.\n+  \/\/ Otherwise, disable VTMS transitions for all threads.\n+  JvmtiVTMSTransitionDisabler disabler(is_virtual ? target : nullptr);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":33,"deletions":14,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -1813,1 +1813,2 @@\n-  if (mh->jvmti_mount_transition() || thread->is_in_any_VTMS_transition()) {\n+  \/\/ pure continuations have no VTMS transitions but they use methods annotated with JvmtiMountTransition\n+  if ((mh->jvmti_mount_transition() && state->is_virtual()) || thread->is_in_any_VTMS_transition()) {\n@@ -1897,1 +1898,2 @@\n-  if (mh->jvmti_mount_transition() || thread->is_in_any_VTMS_transition()) {\n+  \/\/ pure continuations have no VTMS transitions but they use methods annotated with JvmtiMountTransition\n+  if ((mh->jvmti_mount_transition() && state->is_virtual()) || thread->is_in_any_VTMS_transition()) {\n@@ -1973,1 +1975,2 @@\n-  if (mh->jvmti_mount_transition() || thread->is_in_any_VTMS_transition()) {\n+  \/\/ pure continuations have no VTMS transitions but they use methods annotated with JvmtiMountTransition\n+  if ((mh->jvmti_mount_transition() && state->is_virtual()) || thread->is_in_any_VTMS_transition()) {\n@@ -2137,1 +2140,2 @@\n-      if (mh->jvmti_mount_transition() || thread->is_in_any_VTMS_transition()) {\n+      \/\/ pure continuations have no VTMS transitions but they use methods annotated with JvmtiMountTransition\n+      if ((mh->jvmti_mount_transition() && state->is_virtual()) || thread->is_in_any_VTMS_transition()) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1118,2 +1118,0 @@\n-  \/\/ we'd rather not yield inside methods annotated with @JvmtiMountTransition\n-  assert(!ContinuationHelper::Frame::frame_method(f)->jvmti_mount_transition(), \"\");\n@@ -1173,2 +1171,0 @@\n-  \/\/ we'd rather not yield inside methods annotated with @JvmtiMountTransition\n-  assert(!ContinuationHelper::Frame::frame_method(f)->jvmti_mount_transition(), \"\");\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.vm.annotation.JvmtiMountTransition;\n@@ -343,0 +344,1 @@\n+    @JvmtiMountTransition\n@@ -355,0 +357,1 @@\n+    @JvmtiMountTransition\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/Continuation.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-        checkFrames(vThread1, false, 13);\n+        checkFrames(vThread1, false, 11);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetFrameCount\/framecnt01\/framecnt01.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=virtual\n+ * @bug 8341273\n+ * @summary Verifies JVMTI properly hides frames which are in VTMS transition\n+ * @run main\/othervm\/native -agentlib:CheckHiddenFrames CheckHiddenFrames\n+ *\/\n+\n+public class CheckHiddenFrames {\n+    private static final String AGENT_LIB = \"CheckHiddenFrames\";\n+    static native boolean checkHidden(Thread t);\n+\n+    static void sleep(long millis) {\n+        try {\n+            Thread.sleep(millis);\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Thread thread = Thread.ofVirtual().unstarted(CheckHiddenFrames::test);\n+        thread.start();\n+        System.out.println(\"Started virtual thread: \" + thread);\n+\n+        if (!checkHidden(thread)) {\n+            thread.interrupt();\n+            throw new RuntimeException(\"CheckHiddenFrames failed!\");\n+        }\n+        thread.interrupt();\n+        thread.join();\n+    }\n+\n+    static void test() {\n+        sleep(1000000);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/CheckHiddenFrames\/CheckHiddenFrames.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.hpp\"\n+\n+extern \"C\" {\n+\n+const int MAX_COUNT = 50;\n+static jvmtiEnv *jvmti = nullptr;\n+\n+static char*\n+get_frame_method_name(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread, jint depth) {\n+  jmethodID method = nullptr;\n+  jlocation location = 0;\n+\n+  jvmtiError err = jvmti->GetFrameLocation(thread, 0, &method, &location);\n+  check_jvmti_status(jni, err, \"get_method_name_at_depth: error in JVMTI GetFrameLocation\");\n+\n+  return get_method_name(jvmti, jni, method);\n+}\n+\n+static bool\n+method_must_be_hidden(char* mname) {\n+  return strcmp(mname, \"yield\")  == 0 ||\n+         strcmp(mname, \"yield0\") == 0;\n+}\n+\n+static jboolean\n+check_top_frames_location(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n+  jboolean status = JNI_TRUE;\n+\n+  for (int depth = 0; depth < 2; depth++) {\n+    char* mname = get_frame_method_name(jvmti, jni, thread, depth);\n+\n+    if (method_must_be_hidden(mname)) {\n+      LOG(\"Failed: GetFrameLocation returned info for frame expected to be hidden: frame[%d]=%s\\n\", depth, mname);\n+      status = JNI_FALSE;\n+    }\n+    deallocate(jvmti, jni, mname);\n+  }\n+  return status;\n+}\n+\n+static jboolean\n+check_top_frames_in_stack_trace(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n+  jboolean status = JNI_TRUE;\n+  jvmtiFrameInfo frameInfo[MAX_COUNT];\n+  jint count1 = 0;\n+  jint count2 = 0;\n+\n+  jvmtiError err = jvmti->GetStackTrace(thread, 0, MAX_COUNT, frameInfo, &count1);\n+  check_jvmti_status(jni, err, \"check_top_frames_in_stack_trace: error in JVMTI GetStackTrace\");\n+\n+  for (int depth = 0; depth < 2; depth++) {\n+    char* mname = get_method_name(jvmti, jni, frameInfo[depth].method);\n+\n+    if (method_must_be_hidden(mname)) {\n+      LOG(\"Failed: GetStackTrace returned info for frame expected to be hidden: frame[%d]=%s\\n\", depth, mname);\n+      status = JNI_FALSE;\n+    }\n+    deallocate(jvmti, jni, mname);\n+  }\n+\n+  err = jvmti->GetFrameCount(thread, &count2);\n+  check_jvmti_status(jni, err, \"check_top_frames_in_stack_trace: error in JVMTI GetFrameCount\");\n+\n+  if (count1 != count2) {\n+    LOG(\"Failed: frame counts returned by GetStackTrace and GetFrameCount do not match: %d!=%d\\n\", count1, count2);\n+    status = JNI_FALSE;\n+  }\n+  return status;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_CheckHiddenFrames_checkHidden(JNIEnv *jni, jclass clazz, jthread thread) {\n+  jboolean status = JNI_TRUE;\n+\n+  wait_for_state(jvmti, jni, thread, JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT);\n+  print_stack_trace(jvmti, jni, thread);\n+\n+\n+  if (!check_top_frames_location(jvmti, jni, thread)) {\n+    status = JNI_FALSE;\n+  }\n+  if (!check_top_frames_in_stack_trace(jvmti, jni, thread)) {\n+    status = JNI_FALSE;\n+  }\n+  return status;\n+}\n+\n+extern JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  LOG(\"Agent_OnLoad started\\n\");\n+  if (jvm->GetEnv((void **)(&jvmti), JVMTI_VERSION) != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+  LOG(\"Agent_OnLoad finished\\n\");\n+  return JNI_OK;\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/CheckHiddenFrames\/libCheckHiddenFrames.cpp","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"}]}