{"files":[{"patch":"@@ -587,1 +587,0 @@\n-\n@@ -655,0 +654,10 @@\n+javaVFrame*\n+JvmtiEnvBase::skip_top_jvmti_annotated_frames(javaVFrame* jvf) {\n+  \/\/ The yield and yield0 may appear in an unmounted virtual thread.\n+  \/\/ The notifyJvmti* may appear in both carrier or virtual threads.\n+  for ( ; jvf != nullptr && jvf->method()->jvmti_mount_transition(); jvf = jvf->java_sender()) {\n+    \/\/ skip frame with jvmti_mount_transition() annotated method\n+  }\n+  return jvf;\n+}\n+\n@@ -663,1 +672,1 @@\n-    if (jvf->method()->jvmti_mount_transition()) {  \/\/ Cannot actually appear in an unmounted continuation; they're never frozen.\n+    if (jvf->method()->jvmti_mount_transition()) {\n@@ -677,1 +686,7 @@\n-  jvf = check_and_skip_hidden_frames(jt->is_in_VTMS_transition(), jvf);\n+  bool is_virtual = java_lang_VirtualThread::is_instance(jt->jvmti_vthread());\n+\n+  if (jt->is_in_VTMS_transition()) {\n+    jvf = check_and_skip_hidden_frames(true, jvf);\n+  } else if (is_virtual || jt->last_continuation() == nullptr) { \/\/ filter out pure continuations\n+    jvf = skip_top_jvmti_annotated_frames(jvf);\n+  }\n@@ -683,4 +698,7 @@\n-  JvmtiThreadState* state = java_lang_Thread::jvmti_thread_state(vthread);\n-  if (state == nullptr) {\n-    \/\/ nothing to skip\n-    return jvf;\n+  assert(java_lang_VirtualThread::is_instance(vthread), \"sanity check\");\n+  if (java_lang_VirtualThread::is_instance(vthread)) { \/\/ paranoid check for safety\n+    if (java_lang_Thread::is_in_VTMS_transition(vthread)) {\n+      jvf = check_and_skip_hidden_frames(true, jvf);\n+    } else {\n+      jvf = skip_top_jvmti_annotated_frames(jvf);\n+    }\n@@ -688,1 +706,0 @@\n-  jvf = check_and_skip_hidden_frames(java_lang_Thread::is_in_VTMS_transition(vthread), jvf);\n@@ -710,0 +727,1 @@\n+    assert(!java_thread->is_in_VTMS_transition(), \"invariant\");\n@@ -715,1 +733,1 @@\n-    jvf = check_and_skip_hidden_frames(vthread, jvf);\n+    jvf = skip_top_jvmti_annotated_frames(jvf);\n@@ -728,5 +746,3 @@\n-  \/\/ Skip hidden frames only for carrier threads\n-  \/\/ which are in non-temporary VTMS transition.\n-  if (jt->is_in_VTMS_transition()) {\n-    jvf = check_and_skip_hidden_frames(jt, jvf);\n-  }\n+\n+  \/\/ Skip hidden frames for carrier threads only.\n+  jvf = check_and_skip_hidden_frames(jt, jvf);\n@@ -1335,1 +1351,2 @@\n-  if (jvf->method()->is_native()) {\n+  if (jvf->method()->is_native() ||\n+     (state->is_virtual() && (jvf->is_vthread_entry() || jvf->method()->jvmti_mount_transition()))) {\n@@ -1992,1 +2009,0 @@\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":32,"deletions":16,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -369,0 +369,1 @@\n+  static javaVFrame* skip_top_jvmti_annotated_frames(javaVFrame* jvf);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1813,1 +1813,3 @@\n-  if (mh->jvmti_mount_transition() || thread->is_in_any_VTMS_transition()) {\n+  \/\/ pure continuations have no VTMS transitions but they use methods annotated with JvmtiMountTransition\n+  if ((mh->jvmti_mount_transition() && (state->is_virtual() || thread->last_continuation() == nullptr)) ||\n+    thread->is_in_any_VTMS_transition()) {\n@@ -1897,1 +1899,3 @@\n-  if (mh->jvmti_mount_transition() || thread->is_in_any_VTMS_transition()) {\n+  \/\/ pure continuations have no VTMS transitions but they use methods annotated with JvmtiMountTransition\n+  if ((mh->jvmti_mount_transition() && (state->is_virtual() || thread->last_continuation() == nullptr)) ||\n+    thread->is_in_any_VTMS_transition()) {\n@@ -1973,1 +1977,3 @@\n-  if (mh->jvmti_mount_transition() || thread->is_in_any_VTMS_transition()) {\n+  \/\/ pure continuations have no VTMS transitions but they use methods annotated with JvmtiMountTransition\n+  if ((mh->jvmti_mount_transition() && (state->is_virtual() || thread->last_continuation() == nullptr)) ||\n+      thread->is_in_any_VTMS_transition()) {\n@@ -2137,1 +2143,3 @@\n-      if (mh->jvmti_mount_transition() || thread->is_in_any_VTMS_transition()) {\n+      \/\/ pure continuations have no VTMS transitions but they use methods annotated with JvmtiMountTransition\n+      if ((mh->jvmti_mount_transition() && (state->is_virtual() || thread->last_continuation() == nullptr)) ||\n+        thread->is_in_any_VTMS_transition()) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -268,0 +268,11 @@\n+  oop thread_oop = JNIHandles::resolve_external_guard(thread);\n+\n+  \/\/ Target can be virtual or platform thread.\n+  \/\/ If traget is a platform thread then we have to disable VTMS transitions for all threads.\n+  \/\/ It is by several reasons:\n+  \/\/ - carrier threads can mount virtual threads which may cause incorrect behavior\n+  \/\/ - there is no mechanism to disable transitions for a specific carrier thread yet\n+  if (!java_lang_VirtualThread::is_instance(thread_oop)) {\n+    _thread = nullptr; \/\/ target is a platform thread, switch to disabling VTMS transitions for all threads\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1118,2 +1118,0 @@\n-  \/\/ we'd rather not yield inside methods annotated with @JvmtiMountTransition\n-  assert(!ContinuationHelper::Frame::frame_method(f)->jvmti_mount_transition(), \"\");\n@@ -1173,2 +1171,0 @@\n-  \/\/ we'd rather not yield inside methods annotated with @JvmtiMountTransition\n-  assert(!ContinuationHelper::Frame::frame_method(f)->jvmti_mount_transition(), \"\");\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -216,0 +216,1 @@\n+                @JvmtiMountTransition\n@@ -217,1 +218,6 @@\n-                    vthread.run(task);\n+                    vthread.notifyJvmtiStart(); \/\/ notify JVMTI\n+                    try {\n+                        vthread.run(task);\n+                    } finally {\n+                        vthread.notifyJvmtiEnd(); \/\/ notify JVMTI\n+                    }\n@@ -392,3 +398,0 @@\n-        \/\/ notify JVMTI, may post VirtualThreadStart event\n-        notifyJvmtiStart();\n-\n@@ -408,14 +411,8 @@\n-            try {\n-                \/\/ pop any remaining scopes from the stack, this may block\n-                StackableScope.popAll();\n-\n-                \/\/ emit JFR event if enabled\n-                if (VirtualThreadEndEvent.isTurnedOn()) {\n-                    var event = new VirtualThreadEndEvent();\n-                    event.javaThreadId = threadId();\n-                    event.commit();\n-                }\n-\n-            } finally {\n-                \/\/ notify JVMTI, may post VirtualThreadEnd event\n-                notifyJvmtiEnd();\n+            \/\/ pop any remaining scopes from the stack, this may block\n+            StackableScope.popAll();\n+\n+            \/\/ emit JFR event if enabled\n+            if (VirtualThreadEndEvent.isTurnedOn()) {\n+                var event = new VirtualThreadEndEvent();\n+                event.javaThreadId = threadId();\n+                event.commit();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":15,"deletions":18,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.vm.annotation.JvmtiMountTransition;\n@@ -343,0 +344,1 @@\n+    @JvmtiMountTransition\n@@ -355,0 +357,1 @@\n+    @JvmtiMountTransition\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/Continuation.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,3 @@\n+ * The Continuation yield and yield0 frames normally are in VTMS transition\n+ * but can be found out of transition in an unmounted virtual thread.\n+ * This inconsistency is the reason why they also need this annotation.\n@@ -35,1 +38,1 @@\n- * This annotation is only used for VirtualThread methods.\n+ * This annotation is only used for some VirtualThread and Continuation methods.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/JvmtiMountTransition.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-        checkFrames(vThread1, false, 13);\n+        checkFrames(vThread1, false, 11);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetFrameCount\/framecnt01\/framecnt01.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8341273\n+ * @summary Verifies JVMTI properly hides frames which are in VTMS transition\n+ * @run main\/othervm\/native -agentlib:CheckHiddenFrames CheckHiddenFrames\n+ *\/\n+\n+public class CheckHiddenFrames {\n+    static native boolean checkHidden(Thread t);\n+\n+    static void sleep(long millis) {\n+        try {\n+            Thread.sleep(millis);\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Thread thread = Thread.startVirtualThread(CheckHiddenFrames::test);\n+        System.out.println(\"Started virtual thread: \" + thread);\n+\n+        if (!checkHidden(thread)) {\n+            thread.interrupt();\n+            throw new RuntimeException(\"CheckHiddenFrames failed!\");\n+        }\n+        thread.interrupt();\n+        thread.join();\n+    }\n+\n+    static void test() {\n+        sleep(1000000);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/CheckHiddenFrames\/CheckHiddenFrames.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.hpp\"\n+\n+extern \"C\" {\n+\n+const int MAX_COUNT = 50;\n+static jvmtiEnv *jvmti = nullptr;\n+\n+static char*\n+get_frame_method_name(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread, jint depth) {\n+  jmethodID method = nullptr;\n+  jlocation location = 0;\n+\n+  jvmtiError err = jvmti->GetFrameLocation(thread, 0, &method, &location);\n+  check_jvmti_status(jni, err, \"get_method_name_at_depth: error in JVMTI GetFrameLocation\");\n+\n+  return get_method_name(jvmti, jni, method);\n+}\n+\n+static bool\n+method_must_be_hidden(char* mname) {\n+  return strcmp(mname, \"yield\")  == 0 ||\n+         strcmp(mname, \"yield0\") == 0;\n+}\n+\n+static jboolean\n+check_top_frames_location(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n+  jboolean status = JNI_TRUE;\n+\n+  for (int depth = 0; depth < 2; depth++) {\n+    char* mname = get_frame_method_name(jvmti, jni, thread, depth);\n+\n+    if (method_must_be_hidden(mname)) {\n+      LOG(\"Failed: GetFrameLocation returned info for frame expected to be hidden: frame[%d]=%s\\n\", depth, mname);\n+      status = JNI_FALSE;\n+    }\n+    deallocate(jvmti, jni, mname);\n+  }\n+  return status;\n+}\n+\n+static jboolean\n+check_top_frames_in_stack_trace(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n+  jboolean status = JNI_TRUE;\n+  jvmtiFrameInfo frameInfo[MAX_COUNT];\n+  jint count1 = 0;\n+  jint count2 = 0;\n+\n+  jvmtiError err = jvmti->GetStackTrace(thread, 0, MAX_COUNT, frameInfo, &count1);\n+  check_jvmti_status(jni, err, \"check_top_frames_in_stack_trace: error in JVMTI GetStackTrace\");\n+\n+  for (int depth = 0; depth < 2; depth++) {\n+    char* mname = get_method_name(jvmti, jni, frameInfo[depth].method);\n+\n+    if (method_must_be_hidden(mname)) {\n+      LOG(\"Failed: GetStackTrace returned info for frame expected to be hidden: frame[%d]=%s\\n\", depth, mname);\n+      status = JNI_FALSE;\n+    }\n+    deallocate(jvmti, jni, mname);\n+  }\n+\n+  err = jvmti->GetFrameCount(thread, &count2);\n+  check_jvmti_status(jni, err, \"check_top_frames_in_stack_trace: error in JVMTI GetFrameCount\");\n+\n+  if (count1 != count2) {\n+    LOG(\"Failed: frame counts returned by GetStackTrace and GetFrameCount do not match: %d!=%d\\n\", count1, count2);\n+    status = JNI_FALSE;\n+  }\n+  return status;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_CheckHiddenFrames_checkHidden(JNIEnv *jni, jclass clazz, jthread thread) {\n+  jboolean status = JNI_TRUE;\n+\n+  wait_for_state(jvmti, jni, thread, JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT);\n+  print_stack_trace(jvmti, jni, thread);\n+\n+\n+  if (!check_top_frames_location(jvmti, jni, thread)) {\n+    status = JNI_FALSE;\n+  }\n+  if (!check_top_frames_in_stack_trace(jvmti, jni, thread)) {\n+    status = JNI_FALSE;\n+  }\n+  return status;\n+}\n+\n+extern JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  LOG(\"Agent_OnLoad started\\n\");\n+  if (jvm->GetEnv((void **)(&jvmti), JVMTI_VERSION) != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+  LOG(\"Agent_OnLoad finished\\n\");\n+  return JNI_OK;\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/CheckHiddenFrames\/libCheckHiddenFrames.cpp","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"}]}