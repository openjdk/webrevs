{"files":[{"patch":"@@ -946,0 +946,1 @@\n+    _method_JvmtiHideEvents,\n@@ -1850,0 +1851,5 @@\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_JvmtiHideEvents_signature): {\n+      if (_location != _in_method)  break;  \/\/ only allow for methods\n+      if (!privileged)              break;  \/\/ only allow in privileged code\n+      return _method_JvmtiHideEvents;\n+    }\n@@ -1937,0 +1943,2 @@\n+  if (has_annotation(_method_JvmtiHideEvents))\n+    m->set_jvmti_hide_events();\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -309,0 +309,1 @@\n+  template(jdk_internal_vm_annotation_JvmtiHideEvents_signature,       \"Ljdk\/internal\/vm\/annotation\/JvmtiHideEvents;\")  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+   flag(jvmti_hide_events         , 1 << 21) \\\n","filename":"src\/hotspot\/share\/oops\/constMethodFlags.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -749,0 +749,3 @@\n+  bool jvmti_hide_events() const { return constMethod()->jvmti_hide_events(); }\n+  void set_jvmti_hide_events() { constMethod()->set_jvmti_hide_events(); }\n+\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -654,1 +654,3 @@\n-\/\/ An unmounted vthread always has the yield0() and yield() frames we need to hide.\n+\/\/ An unmounted vthread may have an empty stack.\n+\/\/ Otherwise, it always has the yield0() and yield() frames we need to hide.\n+\/\/ The methods yield0() and yield() are annotated with the @JvmtiHideEvents.\n@@ -657,2 +659,2 @@\n-  if (jvf == nullptr) { \/\/ check for safety\n-    return jvf;\n+  if (jvf == nullptr) {\n+    return jvf; \/\/ empty stack is possible\n@@ -660,0 +662,2 @@\n+  assert(jvf->method()->jvmti_hide_events(), \"sanity check\");\n+  assert(jvf->method()->method_holder() == vmClasses::Continuation_klass(), \"expected Continuation class\");\n@@ -661,1 +665,3 @@\n-  assert(jvf != nullptr, \"sanity check\");\n+\n+  assert(jvf != nullptr && jvf->method()->jvmti_hide_events(), \"sanity check\");\n+  assert(jvf->method()->method_holder() == vmClasses::Continuation_klass(), \"expected Continuation class\");\n@@ -666,0 +672,5 @@\n+\/\/ A thread may have an empty stack.\n+\/\/ Otherwise, some top frames may heed to be hidden.\n+\/\/ Two cases are processed below:\n+\/\/ - top frame is annotated with @JvmtiMountTransition: just skip top frames with annotated methods\n+\/\/ - JavaThread is in VTMS transition: skip top frames until a frame annotated with @ChangesCurrentThread is found\n@@ -669,1 +680,1 @@\n-    return jvf;\n+    return jvf; \/\/ empty stack is possible\n@@ -689,12 +700,0 @@\n-javaVFrame*\n-JvmtiEnvBase::check_and_skip_hidden_frames(oop vthread, javaVFrame* jvf) {\n-  assert(java_lang_VirtualThread::is_instance(vthread), \"sanity check\");\n-  if (java_lang_Thread::is_in_VTMS_transition(vthread)) {\n-    jvf = check_and_skip_hidden_frames(true, jvf);\n-  } else {\n-    \/\/ if vthread is not in a VTMS transition then it is unmounted\n-    jvf = skip_yield_frames_for_unmounted_vthread(jvf);\n-  }\n-  return jvf;\n-}\n-\n@@ -725,1 +724,1 @@\n-    jvf = check_and_skip_hidden_frames(vthread, jvf);\n+    jvf = skip_yield_frames_for_unmounted_vthread(jvf);\n@@ -1343,2 +1342,3 @@\n-  if (jvf->method()->is_native() || (depth == 0 && state->top_frame_is_exiting()) ||\n-      (state->is_virtual() && (jvf->is_vthread_entry() || jvf->method()->jvmti_mount_transition()))) {\n+  if (jvf->method()->is_native() ||\n+      (depth == 0 && state->top_frame_is_exiting()) ||\n+      (state->is_virtual() && jvf->method()->jvmti_hide_events())) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -372,1 +372,0 @@\n-  static javaVFrame* check_and_skip_hidden_frames(oop vthread, javaVFrame* jvf);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -256,1 +256,1 @@\n-\/\/ no-op if thread is non-null and not a virtual thread\n+\/\/ disable VTMS transitions for all threads if thread is nullptr or a platform thread\n@@ -272,1 +272,1 @@\n-  \/\/ If traget is a platform thread then we have to disable VTMS transitions for all threads.\n+  \/\/ If target is a platform thread then we have to disable VTMS transitions for all threads.\n@@ -330,3 +330,2 @@\n-  if (!java_lang_VirtualThread::is_instance(vth())) {\n-    return; \/\/ no-op if _thread is not a virtual thread\n-  }\n+  assert(java_lang_VirtualThread::is_instance(vth()), \"sanity check\");\n+\n@@ -482,1 +481,1 @@\n-        if (ml.wait(10)) {\n+        if (ml.wait(200)) {\n@@ -539,1 +538,1 @@\n-        if (ml.wait(10)) {\n+        if (ml.wait(200)) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+import jdk.internal.vm.annotation.JvmtiHideEvents;\n@@ -216,1 +217,1 @@\n-                @JvmtiMountTransition\n+                @JvmtiHideEvents\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.internal.vm.annotation.JvmtiHideEvents;\n@@ -308,0 +309,1 @@\n+    @JvmtiHideEvents\n@@ -319,0 +321,1 @@\n+    @JvmtiHideEvents\n@@ -343,0 +346,1 @@\n+    @JvmtiHideEvents\n@@ -355,0 +359,1 @@\n+    @JvmtiHideEvents\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/Continuation.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.vm.annotation;\n+\n+import java.lang.annotation.*;\n+\n+\/**\n+ * A method may be annotated with JvmtiHideEvents to hint it is not\n+ * desirable to sent JVMTI events in context of the annotated method.\n+ *\n+ * @implNote\n+ * This annotation is only used for some VirtualThread and Continuation methods.\n+ *\/\n+@Target({ElementType.METHOD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface JvmtiHideEvents {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/JvmtiHideEvents.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -36,1 +36,0 @@\n- * Specifically, it is used for all the VirtualThread notifyJvmti* methods.\n@@ -39,1 +38,1 @@\n- * This annotation is only used for some VirtualThread and Continuation methods.\n+ * This annotation is only used for the VirtualThread notifyJvmti*  methods.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/JvmtiMountTransition.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}