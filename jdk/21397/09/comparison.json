{"files":[{"patch":"@@ -587,1 +587,0 @@\n-\n@@ -655,0 +654,12 @@\n+\/\/ An unmounted vthread always has the yield0() and yield() frames we need to hide.\n+javaVFrame*\n+JvmtiEnvBase::skip_yield_frames_for_unmounted_vthread(javaVFrame* jvf) {\n+  if (jvf == nullptr) { \/\/ check for safety\n+    return jvf;\n+  }\n+  jvf = jvf->java_sender(); \/\/ skip yield0 frame\n+  assert(jvf != nullptr, \"sanity check\");\n+  jvf = jvf->java_sender(); \/\/ skip yield frame\n+  return jvf;\n+}\n+\n@@ -657,3 +668,2 @@\n-  \/\/ The second condition is needed to hide notification methods.\n-  if (!is_in_VTMS_transition && (jvf == nullptr || !jvf->method()->jvmti_mount_transition())) {\n-    return jvf;  \/\/ No frames to skip.\n+  if (jvf == nullptr) {\n+    return jvf;\n@@ -661,5 +671,3 @@\n-  \/\/ Find jvf with a method annotated with @JvmtiMountTransition.\n-  for ( ; jvf != nullptr; jvf = jvf->java_sender()) {\n-    if (jvf->method()->jvmti_mount_transition()) {  \/\/ Cannot actually appear in an unmounted continuation; they're never frozen.\n-      jvf = jvf->java_sender();  \/\/ Skip annotated method.\n-      break;\n+  if (jvf->method()->jvmti_mount_transition()) {\n+    \/\/ Skip frames annotated with @JvmtiMountTransition.\n+    for ( ; jvf != nullptr && jvf->method()->jvmti_mount_transition(); jvf = jvf->java_sender()) {\n@@ -667,2 +675,3 @@\n-    if (jvf->method()->changes_current_thread()) {\n-      break;\n+  } else if (is_in_VTMS_transition) {\n+    \/\/ Skip frames above the frame annotated with @ChangesCurrentThread.\n+    for ( ; jvf != nullptr && !jvf->method()->changes_current_thread(); jvf = jvf->java_sender()) {\n@@ -670,1 +679,0 @@\n-    \/\/ Skip frame above annotated method.\n@@ -683,4 +691,6 @@\n-  JvmtiThreadState* state = java_lang_Thread::jvmti_thread_state(vthread);\n-  if (state == nullptr) {\n-    \/\/ nothing to skip\n-    return jvf;\n+  assert(java_lang_VirtualThread::is_instance(vthread), \"sanity check\");\n+  if (java_lang_Thread::is_in_VTMS_transition(vthread)) {\n+    jvf = check_and_skip_hidden_frames(true, jvf);\n+  } else {\n+    \/\/ if vthread is not in a VTMS transition then it is unmounted\n+    jvf = skip_yield_frames_for_unmounted_vthread(jvf);\n@@ -688,1 +698,0 @@\n-  jvf = check_and_skip_hidden_frames(java_lang_Thread::is_in_VTMS_transition(vthread), jvf);\n@@ -710,0 +719,1 @@\n+    assert(!java_thread->is_in_VTMS_transition(), \"invariant\");\n@@ -711,1 +721,1 @@\n-    jvf = check_and_skip_hidden_frames(java_thread, jvf);\n+    jvf = check_and_skip_hidden_frames(false, jvf);\n@@ -728,5 +738,3 @@\n-  \/\/ Skip hidden frames only for carrier threads\n-  \/\/ which are in non-temporary VTMS transition.\n-  if (jt->is_in_VTMS_transition()) {\n-    jvf = check_and_skip_hidden_frames(jt, jvf);\n-  }\n+\n+  \/\/ Skip hidden frames for carrier threads only.\n+  jvf = check_and_skip_hidden_frames(jt, jvf);\n@@ -1335,1 +1343,2 @@\n-  if (jvf->method()->is_native() || (depth == 0 && state->top_frame_is_exiting())) {\n+  if (jvf->method()->is_native() || (depth == 0 && state->top_frame_is_exiting()) ||\n+      (state->is_virtual() && (jvf->is_vthread_entry() || jvf->method()->jvmti_mount_transition()))) {\n@@ -1992,1 +2001,0 @@\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":33,"deletions":25,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -369,0 +369,1 @@\n+  static javaVFrame* skip_yield_frames_for_unmounted_vthread(javaVFrame* jvf);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -269,0 +269,11 @@\n+  oop thread_oop = JNIHandles::resolve_external_guard(thread);\n+\n+  \/\/ Target can be virtual or platform thread.\n+  \/\/ If traget is a platform thread then we have to disable VTMS transitions for all threads.\n+  \/\/ It is by several reasons:\n+  \/\/ - carrier threads can mount virtual threads which may cause incorrect behavior\n+  \/\/ - there is no mechanism to disable transitions for a specific carrier thread yet\n+  if (!java_lang_VirtualThread::is_instance(thread_oop)) {\n+    _thread = nullptr; \/\/ target is a platform thread, switch to disabling VTMS transitions for all threads\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -216,0 +216,1 @@\n+                @JvmtiMountTransition\n@@ -217,1 +218,6 @@\n-                    vthread.run(task);\n+                    vthread.notifyJvmtiStart(); \/\/ notify JVMTI\n+                    try {\n+                        vthread.run(task);\n+                    } finally {\n+                        vthread.notifyJvmtiEnd(); \/\/ notify JVMTI\n+                    }\n@@ -392,3 +398,0 @@\n-        \/\/ notify JVMTI, may post VirtualThreadStart event\n-        notifyJvmtiStart();\n-\n@@ -408,14 +411,8 @@\n-            try {\n-                \/\/ pop any remaining scopes from the stack, this may block\n-                StackableScope.popAll();\n-\n-                \/\/ emit JFR event if enabled\n-                if (VirtualThreadEndEvent.isTurnedOn()) {\n-                    var event = new VirtualThreadEndEvent();\n-                    event.javaThreadId = threadId();\n-                    event.commit();\n-                }\n-\n-            } finally {\n-                \/\/ notify JVMTI, may post VirtualThreadEnd event\n-                notifyJvmtiEnd();\n+            \/\/ pop any remaining scopes from the stack, this may block\n+            StackableScope.popAll();\n+\n+            \/\/ emit JFR event if enabled\n+            if (VirtualThreadEndEvent.isTurnedOn()) {\n+                var event = new VirtualThreadEndEvent();\n+                event.javaThreadId = threadId();\n+                event.commit();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":15,"deletions":18,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -31,2 +31,6 @@\n- * A method is annotated as \"jvmti mount transition\" if it starts\n- * or ends virtual thread mount state transition (VTMS transition).\n+ * A method may be annotated with JvmtiMountTransition to hint\n+ * it is desirable to omit it from JVMTI stack traces.\n+ * Normally, a method is annotated with @JvmtiMountTransition if it starts\n+ * or ends Virtual Thread Mount State (VTMS) transition, so the thread\n+ * identity is undefined or different at method entry and exit.\n+ * Specifically, it is used for all the VirtualThread notifyJvmti* methods.\n@@ -35,1 +39,1 @@\n- * This annotation is only used for VirtualThread methods.\n+ * This annotation is only used for some VirtualThread and Continuation methods.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/JvmtiMountTransition.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-        checkFrames(vThread1, false, 13);\n+        checkFrames(vThread1, false, 11);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetFrameCount\/framecnt01\/framecnt01.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8341273\n+ * @summary Verifies JVMTI properly hides frames which are in VTMS transition\n+ * @run main\/othervm\/native -agentlib:CheckHiddenFrames CheckHiddenFrames\n+ *\/\n+\n+public class CheckHiddenFrames {\n+    static native boolean checkHidden(Thread t);\n+\n+    static void sleep(long millis) {\n+        try {\n+            Thread.sleep(millis);\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Thread thread = Thread.startVirtualThread(CheckHiddenFrames::test);\n+        System.out.println(\"Started virtual thread: \" + thread);\n+\n+        if (!checkHidden(thread)) {\n+            thread.interrupt();\n+            throw new RuntimeException(\"CheckHiddenFrames failed!\");\n+        }\n+        thread.interrupt();\n+        thread.join();\n+    }\n+\n+    static void test() {\n+        sleep(1000000);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/CheckHiddenFrames\/CheckHiddenFrames.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.hpp\"\n+\n+extern \"C\" {\n+\n+const int MAX_COUNT = 50;\n+static jvmtiEnv *jvmti = nullptr;\n+\n+static char*\n+get_frame_method_name(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread, jint depth) {\n+  jmethodID method = nullptr;\n+  jlocation location = 0;\n+\n+  jvmtiError err = jvmti->GetFrameLocation(thread, 0, &method, &location);\n+  check_jvmti_status(jni, err, \"get_method_name_at_depth: error in JVMTI GetFrameLocation\");\n+\n+  return get_method_name(jvmti, jni, method);\n+}\n+\n+static bool\n+method_must_be_hidden(char* mname) {\n+  return strcmp(mname, \"yield\")  == 0 ||\n+         strcmp(mname, \"yield0\") == 0;\n+}\n+\n+static jboolean\n+check_top_frames_location(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n+  jboolean status = JNI_TRUE;\n+\n+  for (int depth = 0; depth < 2; depth++) {\n+    char* mname = get_frame_method_name(jvmti, jni, thread, depth);\n+\n+    if (method_must_be_hidden(mname)) {\n+      LOG(\"Failed: GetFrameLocation returned info for frame expected to be hidden: frame[%d]=%s\\n\", depth, mname);\n+      status = JNI_FALSE;\n+    }\n+    deallocate(jvmti, jni, mname);\n+  }\n+  return status;\n+}\n+\n+static jboolean\n+check_top_frames_in_stack_trace(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n+  jboolean status = JNI_TRUE;\n+  jvmtiFrameInfo frameInfo[MAX_COUNT];\n+  jint count1 = 0;\n+  jint count2 = 0;\n+\n+  jvmtiError err = jvmti->GetStackTrace(thread, 0, MAX_COUNT, frameInfo, &count1);\n+  check_jvmti_status(jni, err, \"check_top_frames_in_stack_trace: error in JVMTI GetStackTrace\");\n+\n+  for (int depth = 0; depth < 2; depth++) {\n+    char* mname = get_method_name(jvmti, jni, frameInfo[depth].method);\n+\n+    if (method_must_be_hidden(mname)) {\n+      LOG(\"Failed: GetStackTrace returned info for frame expected to be hidden: frame[%d]=%s\\n\", depth, mname);\n+      status = JNI_FALSE;\n+    }\n+    deallocate(jvmti, jni, mname);\n+  }\n+\n+  err = jvmti->GetFrameCount(thread, &count2);\n+  check_jvmti_status(jni, err, \"check_top_frames_in_stack_trace: error in JVMTI GetFrameCount\");\n+\n+  if (count1 != count2) {\n+    LOG(\"Failed: frame counts returned by GetStackTrace and GetFrameCount do not match: %d!=%d\\n\", count1, count2);\n+    status = JNI_FALSE;\n+  }\n+  return status;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_CheckHiddenFrames_checkHidden(JNIEnv *jni, jclass clazz, jthread thread) {\n+  jboolean status = JNI_TRUE;\n+\n+  wait_for_state(jvmti, jni, thread, JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT);\n+  print_stack_trace(jvmti, jni, thread);\n+\n+\n+  if (!check_top_frames_location(jvmti, jni, thread)) {\n+    status = JNI_FALSE;\n+  }\n+  if (!check_top_frames_in_stack_trace(jvmti, jni, thread)) {\n+    status = JNI_FALSE;\n+  }\n+  return status;\n+}\n+\n+extern JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  LOG(\"Agent_OnLoad started\\n\");\n+  if (jvm->GetEnv((void **)(&jvmti), JVMTI_VERSION) != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+  LOG(\"Agent_OnLoad finished\\n\");\n+  return JNI_OK;\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/CheckHiddenFrames\/libCheckHiddenFrames.cpp","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"}]}