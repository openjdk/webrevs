{"files":[{"patch":"@@ -922,85 +922,95 @@\n-    {\n-        JNI_CHECK_NULL_GOTO(printDC, \"Invalid printDC\", done);\n-\n-        \/* We try to mitigate the effects of floating point rounding errors\n-         * by only setting a value if it would differ from the value in the\n-         * target by at least 0.10 points = 1\/720 inches.\n-         * eg if the values present in the target are close to the calculated\n-         * values then we accept the target.\n-         *\/\n-        const double epsilon = 0.10;\n-\n-        jdouble paperWidth, paperHeight;\n-        jboolean err;\n-        WORD dmPaperSize = getPrintPaperSize(env, &err, self);\n-        if (err) goto done;\n-\n-        double ix, iy, iw, ih, pw, ph;\n-\n-        DASSERT(AwtToolkit::MainThread() != ::GetCurrentThreadId());\n-        jmethodID getID;\n-\n-        jclass paperClass = env->GetObjectClass(origPaper);\n-        JNI_CHECK_NULL_GOTO(paperClass, \"paper class not found\", done);\n-        getID = env->GetMethodID(paperClass, GETWIDTH_STR, GETWIDTH_SIG);\n-        JNI_CHECK_NULL_GOTO(getID, \"no getWidth method\", done);\n-        pw = env->CallDoubleMethod(origPaper, getID);\n-        getID = env->GetMethodID(paperClass, GETHEIGHT_STR, GETHEIGHT_SIG);\n-        JNI_CHECK_NULL_GOTO(getID, \"no getHeight method\", done);\n-        ph = env->CallDoubleMethod(origPaper, getID);\n-        getID = env->GetMethodID(paperClass, GETIMG_X_STR, GETIMG_X_SIG);\n-        JNI_CHECK_NULL_GOTO(getID, \"no getX method\", done);\n-        ix = env->CallDoubleMethod(origPaper, getID);\n-        getID = env->GetMethodID(paperClass, GETIMG_Y_STR, GETIMG_Y_SIG);\n-        JNI_CHECK_NULL_GOTO(getID, \"no getY method\", done);\n-        iy = env->CallDoubleMethod(origPaper, getID);\n-        getID = env->GetMethodID(paperClass, GETIMG_W_STR, GETIMG_W_SIG);\n-        JNI_CHECK_NULL_GOTO(getID, \"no getW method\", done);\n-        iw = env->CallDoubleMethod(origPaper, getID);\n-        getID = env->GetMethodID(paperClass, GETIMG_H_STR, GETIMG_H_SIG);\n-        JNI_CHECK_NULL_GOTO(getID, \"no getH method\", done);\n-        ih = env->CallDoubleMethod(origPaper, getID);\n-\n-        matchPaperSize(printDC, hDevMode, hDevNames, pw, ph,\n-                       &paperWidth, &paperHeight, &dmPaperSize);\n-\n-        \/* Validate margins and imageable area *\/\n-\n-        \/\/ pixels per inch in x and y direction\n-        jint xPixelRes = GetDeviceCaps(printDC, LOGPIXELSX);\n-        jint yPixelRes = GetDeviceCaps(printDC, LOGPIXELSY);\n-\n-        \/\/ x & y coord of printable area in pixels\n-        jint xPixelOrg = GetDeviceCaps(printDC, PHYSICALOFFSETX);\n-        jint yPixelOrg = GetDeviceCaps(printDC, PHYSICALOFFSETY);\n-\n-        \/\/ width & height of printable area in pixels\n-        jint imgPixelWid = GetDeviceCaps(printDC, HORZRES);\n-        jint imgPixelHgt = GetDeviceCaps(printDC, VERTRES);\n-\n-        \/\/ The DC may be obtained when we first selected the printer as a\n-        \/\/ result of a call to setNativePrintService.\n-        \/\/ If the Devmode was obtained later on from the DocumentProperties dialog\n-        \/\/ the DC won't have been updated and its settings may be for PORTRAIT.\n-        \/\/ This may happen in other cases too, but was observed for the above.\n-        \/\/ To get a DC compatible with this devmode we should really call\n-        \/\/ CreateDC() again to get a DC for the devmode we are using.\n-        \/\/ The changes for that are a lot more risk, so to minimize that\n-        \/\/ risk, assume its not LANDSCAPE unless width > height, even if the\n-        \/\/ devmode says its LANDSCAPE.\n-        \/\/ if the values were obtained from a rotated device, swap.\n-        if ((getOrientationFromDevMode2(hDevMode) == DMORIENT_LANDSCAPE) &&\n-            (imgPixelWid > imgPixelHgt)) {\n-          jint tmp;\n-          tmp = xPixelRes;\n-          xPixelRes = yPixelRes;\n-          yPixelRes = tmp;\n-\n-          tmp = xPixelOrg;\n-          xPixelOrg = yPixelOrg;\n-          yPixelOrg = tmp;\n-\n-          tmp = imgPixelWid;\n-          imgPixelWid = imgPixelHgt;\n-          imgPixelHgt = tmp;\n-        }\n+    \/* We try to mitigate the effects of floating point rounding errors\n+     * by only setting a value if it would differ from the value in the\n+     * target by at least 0.10 points = 1\/720 inches.\n+     * eg if the values present in the target are close to the calculated\n+     * values then we accept the target.\n+     *\/\n+    const double epsilon = 0.10;\n+\n+    JNI_CHECK_NULL_GOTO(printDC, \"Invalid printDC\", done);\n+\n+    jdouble paperWidth, paperHeight;\n+    jboolean err;\n+    WORD dmPaperSize;\n+    dmPaperSize = getPrintPaperSize(env, &err, self);\n+    if (err) goto done;\n+\n+    double ix, iy, iw, ih, pw, ph;\n+\n+    DASSERT(AwtToolkit::MainThread() != ::GetCurrentThreadId());\n+    jmethodID getID;\n+\n+    jclass paperClass;\n+    paperClass = env->GetObjectClass(origPaper);\n+    JNI_CHECK_NULL_GOTO(paperClass, \"paper class not found\", done);\n+    getID = env->GetMethodID(paperClass, GETWIDTH_STR, GETWIDTH_SIG);\n+    JNI_CHECK_NULL_GOTO(getID, \"no getWidth method\", done);\n+    pw = env->CallDoubleMethod(origPaper, getID);\n+    getID = env->GetMethodID(paperClass, GETHEIGHT_STR, GETHEIGHT_SIG);\n+    JNI_CHECK_NULL_GOTO(getID, \"no getHeight method\", done);\n+    ph = env->CallDoubleMethod(origPaper, getID);\n+    getID = env->GetMethodID(paperClass, GETIMG_X_STR, GETIMG_X_SIG);\n+    JNI_CHECK_NULL_GOTO(getID, \"no getX method\", done);\n+    ix = env->CallDoubleMethod(origPaper, getID);\n+    getID = env->GetMethodID(paperClass, GETIMG_Y_STR, GETIMG_Y_SIG);\n+    JNI_CHECK_NULL_GOTO(getID, \"no getY method\", done);\n+    iy = env->CallDoubleMethod(origPaper, getID);\n+    getID = env->GetMethodID(paperClass, GETIMG_W_STR, GETIMG_W_SIG);\n+    JNI_CHECK_NULL_GOTO(getID, \"no getW method\", done);\n+    iw = env->CallDoubleMethod(origPaper, getID);\n+    getID = env->GetMethodID(paperClass, GETIMG_H_STR, GETIMG_H_SIG);\n+    JNI_CHECK_NULL_GOTO(getID, \"no getH method\", done);\n+    ih = env->CallDoubleMethod(origPaper, getID);\n+\n+    matchPaperSize(printDC, hDevMode, hDevNames, pw, ph,\n+                   &paperWidth, &paperHeight, &dmPaperSize);\n+\n+    \/* Validate margins and imageable area *\/\n+\n+    \/\/ pixels per inch in x and y direction\n+    jint xPixelRes;\n+    jint yPixelRes;\n+\n+    \/\/ x & y coord of printable area in pixels\n+    jint xPixelOrg;\n+    jint yPixelOrg;\n+\n+    \/\/ width & height of printable area in pixels\n+    jint imgPixelWid;\n+    jint imgPixelHgt;\n+\n+    xPixelRes = GetDeviceCaps(printDC, LOGPIXELSX);\n+    yPixelRes = GetDeviceCaps(printDC, LOGPIXELSY);\n+\n+    xPixelOrg = GetDeviceCaps(printDC, PHYSICALOFFSETX);\n+    yPixelOrg = GetDeviceCaps(printDC, PHYSICALOFFSETY);\n+\n+    imgPixelWid = GetDeviceCaps(printDC, HORZRES);\n+    imgPixelHgt = GetDeviceCaps(printDC, VERTRES);\n+\n+    \/\/ The DC may be obtained when we first selected the printer as a\n+    \/\/ result of a call to setNativePrintService.\n+    \/\/ If the Devmode was obtained later on from the DocumentProperties dialog\n+    \/\/ the DC won't have been updated and its settings may be for PORTRAIT.\n+    \/\/ This may happen in other cases too, but was observed for the above.\n+    \/\/ To get a DC compatible with this devmode we should really call\n+    \/\/ CreateDC() again to get a DC for the devmode we are using.\n+    \/\/ The changes for that are a lot more risk, so to minimize that\n+    \/\/ risk, assume its not LANDSCAPE unless width > height, even if the\n+    \/\/ devmode says its LANDSCAPE.\n+    \/\/ if the values were obtained from a rotated device, swap.\n+    if ((getOrientationFromDevMode2(hDevMode) == DMORIENT_LANDSCAPE) &&\n+        (imgPixelWid > imgPixelHgt)) {\n+      jint tmp;\n+      tmp = xPixelRes;\n+      xPixelRes = yPixelRes;\n+      yPixelRes = tmp;\n+\n+      tmp = xPixelOrg;\n+      xPixelOrg = yPixelOrg;\n+      yPixelOrg = tmp;\n+\n+      tmp = imgPixelWid;\n+      imgPixelWid = imgPixelHgt;\n+      imgPixelHgt = tmp;\n+    }\n@@ -1008,5 +1018,5 @@\n-        \/\/ page imageable area in 1\/72\"\n-        jdouble imgX = (jdouble)((xPixelOrg * 72)\/(jdouble)xPixelRes);\n-        jdouble imgY = (jdouble)((yPixelOrg * 72)\/(jdouble)yPixelRes);\n-        jdouble imgWid = (jdouble)((imgPixelWid * 72)\/(jdouble)xPixelRes);\n-        jdouble imgHgt = (jdouble)((imgPixelHgt * 72)\/(jdouble)yPixelRes);\n+    \/\/ page imageable area in 1\/72\"\n+    jdouble imgX;\n+    jdouble imgY;\n+    jdouble imgWid;\n+    jdouble imgHgt;\n@@ -1014,4 +1024,4 @@\n-        \/* Check each of the individual values is within range.\n-         * Then make sure imageable area is placed within imageable area.\n-         * Allow for a small floating point error in the comparisons\n-         *\/\n+    imgX = (jdouble)((xPixelOrg * 72)\/(jdouble)xPixelRes);\n+    imgY = (jdouble)((yPixelOrg * 72)\/(jdouble)yPixelRes);\n+    imgWid = (jdouble)((imgPixelWid * 72)\/(jdouble)xPixelRes);\n+    imgHgt = (jdouble)((imgPixelHgt * 72)\/(jdouble)yPixelRes);\n@@ -1019,30 +1029,35 @@\n-        if (ix < 0.0 ) {\n-            ix = 0.0;\n-        }\n-        if (iy < 0.0 ) {\n-            iy = 0.0;\n-        }\n-        if (iw < 0.0) {\n-            iw = 0.0;\n-        }\n-        if (ih < 0.0) {\n-            ih = 0.0;\n-        }\n-        if ((ix + epsilon) < imgX) {\n-             ix = imgX;\n-        }\n-        if ((iy + epsilon) < imgY) {\n-             iy = imgY;\n-        }\n-        if (iw + epsilon > imgWid) {\n-            iw = imgWid;\n-        }\n-        if (ih + epsilon > imgHgt) {\n-            ih = imgHgt;\n-        }\n-        if ((ix + iw + epsilon) > (imgX+imgWid)) {\n-            ix = (imgX+imgWid) - iw;\n-        }\n-        if ((iy + ih + epsilon) > (imgY+imgHgt)) {\n-            iy = (imgY+imgHgt) - ih;\n-        }\n+    \/* Check each of the individual values is within range.\n+     * Then make sure imageable area is placed within imageable area.\n+     * Allow for a small floating point error in the comparisons\n+     *\/\n+\n+    if (ix < 0.0 ) {\n+        ix = 0.0;\n+    }\n+    if (iy < 0.0 ) {\n+        iy = 0.0;\n+    }\n+    if (iw < 0.0) {\n+        iw = 0.0;\n+    }\n+    if (ih < 0.0) {\n+        ih = 0.0;\n+    }\n+    if ((ix + epsilon) < imgX) {\n+         ix = imgX;\n+    }\n+    if ((iy + epsilon) < imgY) {\n+         iy = imgY;\n+    }\n+    if (iw + epsilon > imgWid) {\n+        iw = imgWid;\n+    }\n+    if (ih + epsilon > imgHgt) {\n+        ih = imgHgt;\n+    }\n+    if ((ix + iw + epsilon) > (imgX+imgWid)) {\n+        ix = (imgX+imgWid) - iw;\n+    }\n+    if ((iy + ih + epsilon) > (imgY+imgHgt)) {\n+        iy = (imgY+imgHgt) - ih;\n+    }\n@@ -1050,1 +1065,1 @@\n-        DASSERT(AwtToolkit::MainThread() != ::GetCurrentThreadId());\n+    DASSERT(AwtToolkit::MainThread() != ::GetCurrentThreadId());\n@@ -1052,3 +1067,4 @@\n-        jmethodID setSizeID = env->GetMethodID(paperClass,\n-                                        SETSIZE_STR, SETSIZE_SIG);\n-        JNI_CHECK_NULL_GOTO(setSizeID, \"no setSize method\", done);\n+    jmethodID setSizeID;\n+    setSizeID = env->GetMethodID(paperClass,\n+                              SETSIZE_STR, SETSIZE_SIG);\n+    JNI_CHECK_NULL_GOTO(setSizeID, \"no setSize method\", done);\n@@ -1056,3 +1072,4 @@\n-        jmethodID setImageableID = env->GetMethodID(paperClass,\n-                                            SETIMAGEABLE_STR, SETIMAGEABLE_SIG);\n-        JNI_CHECK_NULL_GOTO(setImageableID, \"no setImageable method\", done);\n+    jmethodID setImageableID;\n+    setImageableID = env->GetMethodID(paperClass,\n+                              SETIMAGEABLE_STR, SETIMAGEABLE_SIG);\n+    JNI_CHECK_NULL_GOTO(setImageableID, \"no setImageable method\", done);\n@@ -1060,3 +1077,2 @@\n-        env->CallVoidMethod(newPaper, setSizeID, paperWidth, paperHeight);\n-        env->CallVoidMethod(newPaper, setImageableID, ix, iy, iw, ih);\n-    }\n+    env->CallVoidMethod(newPaper, setSizeID, paperWidth, paperHeight);\n+    env->CallVoidMethod(newPaper, setImageableID, ix, iy, iw, ih);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_PrintJob.cpp","additions":150,"deletions":134,"binary":false,"changes":284,"status":"modified"}]}