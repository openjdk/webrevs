{"files":[{"patch":"@@ -565,2 +565,2 @@\n-    TOOLCHAIN_CFLAGS_JVM=\"-nologo -MD -Zc:preprocessor -Zc:strictStrings -Zc:inline -utf-8 -MP\"\n-    TOOLCHAIN_CFLAGS_JDK=\"-nologo -MD -Zc:preprocessor -Zc:strictStrings -Zc:inline -utf-8 -Zc:wchar_t-\"\n+    TOOLCHAIN_CFLAGS_JVM=\"-nologo -MD -Zc:preprocessor -Zc:strictStrings -Zc:inline -permissive- -utf-8 -MP\"\n+    TOOLCHAIN_CFLAGS_JDK=\"-nologo -MD -Zc:preprocessor -Zc:strictStrings -Zc:inline -permissive- -utf-8 -Zc:wchar_t-\"\n","filename":"make\/autoconf\/flags-cflags.m4","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2261,1 +2261,1 @@\n-    return ::signal(sig, handler);\n+    return CAST_FROM_FN_PTR(void*, ::signal(sig, handler));\n@@ -2912,2 +2912,4 @@\n-  if (InterceptOSException) goto exit;\n-  DWORD exception_code = exceptionInfo->ExceptionRecord->ExceptionCode;\n+  if (InterceptOSException) {\n+    goto exit;\n+  } else {\n+    DWORD exception_code = exceptionInfo->ExceptionRecord->ExceptionCode;\n@@ -2915,1 +2917,1 @@\n-  address pc = (address)exceptionInfo->ContextRecord->Pc;\n+    address pc = (address)exceptionInfo->ContextRecord->Pc;\n@@ -2917,1 +2919,1 @@\n-  address pc = (address) exceptionInfo->ContextRecord->Rip;\n+    address pc = (address) exceptionInfo->ContextRecord->Rip;\n@@ -2919,1 +2921,1 @@\n-  address pc = (address) exceptionInfo->ContextRecord->Eip;\n+    address pc = (address) exceptionInfo->ContextRecord->Eip;\n@@ -2921,1 +2923,1 @@\n-  Thread* t = Thread::current_or_null_safe();\n+    Thread* t = Thread::current_or_null_safe();\n@@ -2923,3 +2925,4 @@\n-  if (exception_code != EXCEPTION_BREAKPOINT) {\n-    report_error(t, exception_code, pc, exceptionInfo->ExceptionRecord,\n-                exceptionInfo->ContextRecord);\n+    if (exception_code != EXCEPTION_BREAKPOINT) {\n+      report_error(t, exception_code, pc, exceptionInfo->ExceptionRecord,\n+                  exceptionInfo->ContextRecord);\n+    }\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-    _p[0] = '\\0';\n+    _p[0] = (T) '\\0';\n@@ -126,1 +126,1 @@\n-    _p[0] = '\\0';\n+    _p[0] = (T) '\\0';\n","filename":"src\/hotspot\/os\/windows\/symbolengine.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-void* AnyObj::operator new(size_t size, Arena *arena) throw() {\n+void* AnyObj::operator new(size_t size, Arena *arena) {\n","filename":"src\/hotspot\/share\/memory\/allocation.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-void D3DGlyphCache_FlushGlyphVertexCache();\n+static void D3DGlyphCache_FlushGlyphVertexCache();\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/d3d\/D3DGlyphCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -214,2 +214,3 @@\n-    PDATA pData;\n-    JNI_CHECK_PEER_GOTO(canvas, ret);\n+    {\n+        PDATA pData;\n+        JNI_CHECK_PEER_GOTO(canvas, ret);\n@@ -217,3 +218,4 @@\n-    AwtCanvas *c = (AwtCanvas*)pData;\n-    c->m_eraseBackground = doErase;\n-    c->m_eraseBackgroundOnResize = doEraseOnResize;\n+        AwtCanvas *c = (AwtCanvas*)pData;\n+        c->m_eraseBackground = doErase;\n+        c->m_eraseBackgroundOnResize = doEraseOnResize;\n+    }\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Canvas.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -6371,12 +6371,14 @@\n-        PDATA pData;\n-        JNI_CHECK_PEER_GOTO(self, ret);\n-        awtComponent = (AwtComponent *)pData;\n-        JNI_CHECK_PEER_GOTO(parent, ret);\n-        awtParent = (AwtComponent *)pData;\n-\n-        HWND selfWnd = awtComponent->GetHWnd();\n-        HWND parentWnd = awtParent->GetHWnd();\n-        if (::IsWindow(selfWnd) && ::IsWindow(parentWnd)) {\n-            \/\/ Shouldn't trigger native focus change\n-            \/\/ (only the proxy may be the native focus owner).\n-            ::SetParent(selfWnd, parentWnd);\n+        {\n+            PDATA pData;\n+            JNI_CHECK_PEER_GOTO(self, ret);\n+            awtComponent = (AwtComponent *)pData;\n+            JNI_CHECK_PEER_GOTO(parent, ret);\n+            awtParent = (AwtComponent *)pData;\n+\n+            HWND selfWnd = awtComponent->GetHWnd();\n+            HWND parentWnd = awtParent->GetHWnd();\n+            if (::IsWindow(selfWnd) && ::IsWindow(parentWnd)) {\n+                \/\/ Shouldn't trigger native focus change\n+                \/\/ (only the proxy may be the native focus owner).\n+                ::SetParent(selfWnd, parentWnd);\n+            }\n@@ -6384,0 +6386,1 @@\n+\n@@ -6546,2 +6549,3 @@\n-    gis->insets->left = gis->insets->top =\n-        gis->insets->right = gis->insets->bottom = 0;\n+    {\n+        gis->insets->left = gis->insets->top =\n+            gis->insets->right = gis->insets->bottom = 0;\n@@ -6549,3 +6553,3 @@\n-    PDATA pData;\n-    JNI_CHECK_PEER_GOTO(self, ret);\n-    AwtComponent *component = (AwtComponent *)pData;\n+        PDATA pData;\n+        JNI_CHECK_PEER_GOTO(self, ret);\n+        AwtComponent *component = (AwtComponent *)pData;\n@@ -6553,1 +6557,2 @@\n-    component->GetInsets(gis->insets);\n+        component->GetInsets(gis->insets);\n+    }\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Component.cpp","additions":23,"deletions":18,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-#include <awt.h>\n@@ -45,0 +44,4 @@\n+\/\/ Moved here as we don't want to pull in the redefined allocation functions\n+#include \"awt_ole.h\"\n+#include \"awt_DCHolder.h\"\n+\n@@ -46,0 +49,1 @@\n+#include \"awt.h\"\n@@ -57,3 +61,0 @@\n-#include \"awt_ole.h\"\n-#include \"awt_DCHolder.h\"\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_DnDDS.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"awt_ole.h\"\n@@ -34,1 +35,0 @@\n-#include \"awt_ole.h\"\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_DnDDT.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1350,10 +1350,0 @@\n-    JNI_CHECK_PEER_GOTO(self, ret);\n-    f = (AwtFrame *)pData;\n-    HWND hwnd = f->GetHWnd();\n-    if (::IsWindow(hwnd))\n-    {\n-        DASSERT(!IsBadReadPtr(f, sizeof(AwtFrame)));\n-\n-        BOOL iconify = (state & java_awt_Frame_ICONIFIED) != 0;\n-        BOOL zoom = (state & java_awt_Frame_MAXIMIZED_BOTH)\n-                        == java_awt_Frame_MAXIMIZED_BOTH;\n@@ -1361,5 +1351,40 @@\n-        DTRACE_PRINTLN4(\"WFramePeer.setState:%s%s ->%s%s\",\n-                  f->isIconic() ? \" iconic\" : \"\",\n-                  f->isZoomed() ? \" zoomed\" : \"\",\n-                  iconify       ? \" iconic\" : \"\",\n-                  zoom          ? \" zoomed\" : \"\");\n+    {\n+        JNI_CHECK_PEER_GOTO(self, ret);\n+        f = (AwtFrame *)pData;\n+        HWND hwnd = f->GetHWnd();\n+        if (::IsWindow(hwnd)) {\n+            DASSERT(!IsBadReadPtr(f, sizeof(AwtFrame)));\n+\n+            BOOL iconify = (state & java_awt_Frame_ICONIFIED) != 0;\n+            BOOL zoom = (state & java_awt_Frame_MAXIMIZED_BOTH)\n+                            == java_awt_Frame_MAXIMIZED_BOTH;\n+\n+            DTRACE_PRINTLN4(\"WFramePeer.setState:%s%s ->%s%s\",\n+                      f->isIconic() ? \" iconic\" : \"\",\n+                      f->isZoomed() ? \" zoomed\" : \"\",\n+                      iconify       ? \" iconic\" : \"\",\n+                      zoom          ? \" zoomed\" : \"\");\n+\n+            if (::IsWindowVisible(hwnd)) {\n+                BOOL focusable = f->IsFocusableWindow();\n+\n+                WINDOWPLACEMENT wp;\n+                ::ZeroMemory(&wp, sizeof(wp));\n+                wp.length = sizeof(wp);\n+                ::GetWindowPlacement(hwnd, &wp);\n+\n+                \/\/ Iconify first.\n+                \/\/ If both iconify & zoom are TRUE, handle this case\n+                \/\/ with wp.flags field below.\n+                if (iconify) {\n+                    wp.showCmd = focusable ? SW_MINIMIZE : SW_SHOWMINNOACTIVE;\n+                } else if (zoom) {\n+                    wp.showCmd = focusable ? SW_SHOWMAXIMIZED : SW_MAXIMIZE;\n+                } else { \/\/ zoom == iconify == FALSE\n+                    wp.showCmd = focusable ? SW_RESTORE : SW_SHOWNOACTIVATE;\n+                }\n+                if (zoom && iconify) {\n+                    wp.flags |= WPF_RESTORETOMAXIMIZED;\n+                } else {\n+                    wp.flags &= ~WPF_RESTORETOMAXIMIZED;\n+                }\n@@ -1367,2 +1392,3 @@\n-        if (::IsWindowVisible(hwnd)) {\n-            BOOL focusable = f->IsFocusableWindow();\n+                if (!zoom) {\n+                    f->m_forceResetZoomed = TRUE;\n+                }\n@@ -1370,4 +1396,4 @@\n-            WINDOWPLACEMENT wp;\n-            ::ZeroMemory(&wp, sizeof(wp));\n-            wp.length = sizeof(wp);\n-            ::GetWindowPlacement(hwnd, &wp);\n+                \/\/ The SetWindowPlacement() causes the WmSize() invocation\n+                \/\/  which, in turn, actually updates the m_iconic & m_zoomed flags\n+                \/\/  as well as sends Java event (WINDOW_STATE_CHANGED.)\n+                ::SetWindowPlacement(hwnd, &wp);\n@@ -1375,12 +1401,1 @@\n-            \/\/ Iconify first.\n-            \/\/ If both iconify & zoom are TRUE, handle this case\n-            \/\/ with wp.flags field below.\n-            if (iconify) {\n-                wp.showCmd = focusable ? SW_MINIMIZE : SW_SHOWMINNOACTIVE;\n-            } else if (zoom) {\n-                wp.showCmd = focusable ? SW_SHOWMAXIMIZED : SW_MAXIMIZE;\n-            } else { \/\/ zoom == iconify == FALSE\n-                wp.showCmd = focusable ? SW_RESTORE : SW_SHOWNOACTIVATE;\n-            }\n-            if (zoom && iconify) {\n-                wp.flags |= WPF_RESTORETOMAXIMIZED;\n+                f->m_forceResetZoomed = FALSE;\n@@ -1388,2 +1403,1 @@\n-                wp.flags &= ~WPF_RESTORETOMAXIMIZED;\n-            }\n+                DTRACE_PRINTLN(\"  not visible, just recording the requested state\");\n@@ -1391,2 +1405,2 @@\n-            if (!zoom) {\n-                f->m_forceResetZoomed = TRUE;\n+                f->setIconic(iconify);\n+                f->setZoomed(zoom);\n@@ -1394,12 +1408,0 @@\n-\n-            \/\/ The SetWindowPlacement() causes the WmSize() invocation\n-            \/\/  which, in turn, actually updates the m_iconic & m_zoomed flags\n-            \/\/  as well as sends Java event (WINDOW_STATE_CHANGED.)\n-            ::SetWindowPlacement(hwnd, &wp);\n-\n-            f->m_forceResetZoomed = FALSE;\n-        } else {\n-            DTRACE_PRINTLN(\"  not visible, just recording the requested state\");\n-\n-            f->setIconic(iconify);\n-            f->setZoomed(zoom);\n@@ -1408,0 +1410,1 @@\n+\n@@ -1580,9 +1583,0 @@\n-    JNI_CHECK_PEER_GOTO(peer, ret);\n-    AwtFrame *f = (AwtFrame *)pData;\n-\n-    \/\/ dialog here may be NULL, for example, if the blocker is a native dialog\n-    \/\/ however, we need to install\/unistall modal hooks anyway\n-    JNI_CHECK_PEER_GOTO(blockerPeer, ret);\n-    AwtDialog *d = (AwtDialog *)pData;\n-\n-    if ((f != NULL) && ::IsWindow(f->GetHWnd()))\n@@ -1590,39 +1584,35 @@\n-        \/\/ get an HWND of the toplevel window this embedded frame is within\n-        HWND fHWnd = f->GetHWnd();\n-        while (::GetParent(fHWnd) != NULL) {\n-            fHWnd = ::GetParent(fHWnd);\n-        }\n-        \/\/ we must get a toplevel hwnd here, however due to some strange\n-        \/\/ behaviour of Java Plugin (a bug?) when running in IE at\n-        \/\/ this moment the embedded frame hasn't been placed into the\n-        \/\/ browser yet and fHWnd is not a toplevel, so we shouldn't install\n-        \/\/ the hook here\n-        if ((::GetWindowLong(fHWnd, GWL_STYLE) & WS_CHILD) == 0) {\n-            \/\/ if this toplevel is created in another thread, we should install\n-            \/\/ the modal hook into it to track window activation and mouse events\n-            DWORD fThread = ::GetWindowThreadProcessId(fHWnd, NULL);\n-            if (fThread != AwtToolkit::GetInstance().MainThread()) {\n-                \/\/ check if this thread has been already blocked\n-                BlockedThreadStruct *blockedThread = (BlockedThreadStruct *)sm_BlockedThreads.get((void *)((intptr_t)fThread));\n-                if (blocked) {\n-                    if (blockedThread == NULL) {\n-                        blockedThread = new BlockedThreadStruct;\n-                        blockedThread->framesCount = 1;\n-                        blockedThread->modalHook = ::SetWindowsHookEx(WH_CBT, (HOOKPROC)AwtDialog::ModalFilterProc,\n-                                                                      0, fThread);\n-                        blockedThread->mouseHook = ::SetWindowsHookEx(WH_MOUSE, (HOOKPROC)AwtDialog::MouseHookProc_NonTT,\n-                                                                      0, fThread);\n-                        sm_BlockedThreads.put((void *)((intptr_t)fThread), blockedThread);\n-                    } else {\n-                        blockedThread->framesCount++;\n-                    }\n-                } else {\n-                    \/\/ see the comment above: if Java Plugin behaviour when running in IE\n-                    \/\/ was right, blockedThread would be always not NULL here\n-                    if (blockedThread != NULL) {\n-                        DASSERT(blockedThread->framesCount > 0);\n-                        if ((blockedThread->framesCount) == 1) {\n-                            ::UnhookWindowsHookEx(blockedThread->modalHook);\n-                            ::UnhookWindowsHookEx(blockedThread->mouseHook);\n-                            sm_BlockedThreads.remove((void *)((intptr_t)fThread));\n-                            delete blockedThread;\n+        JNI_CHECK_PEER_GOTO(peer, ret);\n+        AwtFrame *f = (AwtFrame *)pData;\n+\n+        \/\/ dialog here may be NULL, for example, if the blocker is a native dialog\n+        \/\/ however, we need to install\/unistall modal hooks anyway\n+        JNI_CHECK_PEER_GOTO(blockerPeer, ret);\n+        AwtDialog *d = (AwtDialog *)pData;\n+\n+        if ((f != NULL) && ::IsWindow(f->GetHWnd())) {\n+            \/\/ get an HWND of the toplevel window this embedded frame is within\n+            HWND fHWnd = f->GetHWnd();\n+            while (::GetParent(fHWnd) != NULL) {\n+                fHWnd = ::GetParent(fHWnd);\n+            }\n+            \/\/ we must get a toplevel hwnd here, however due to some strange\n+            \/\/ behaviour of Java Plugin (a bug?) when running in IE at\n+            \/\/ this moment the embedded frame hasn't been placed into the\n+            \/\/ browser yet and fHWnd is not a toplevel, so we shouldn't install\n+            \/\/ the hook here\n+            if ((::GetWindowLong(fHWnd, GWL_STYLE) & WS_CHILD) == 0) {\n+                \/\/ if this toplevel is created in another thread, we should install\n+                \/\/ the modal hook into it to track window activation and mouse events\n+                DWORD fThread = ::GetWindowThreadProcessId(fHWnd, NULL);\n+                if (fThread != AwtToolkit::GetInstance().MainThread()) {\n+                    \/\/ check if this thread has been already blocked\n+                    BlockedThreadStruct *blockedThread = (BlockedThreadStruct *)sm_BlockedThreads.get((void *)((intptr_t)fThread));\n+                    if (blocked) {\n+                        if (blockedThread == NULL) {\n+                            blockedThread = new BlockedThreadStruct;\n+                            blockedThread->framesCount = 1;\n+                            blockedThread->modalHook = ::SetWindowsHookEx(WH_CBT, (HOOKPROC)AwtDialog::ModalFilterProc,\n+                                                                          0, fThread);\n+                            blockedThread->mouseHook = ::SetWindowsHookEx(WH_MOUSE, (HOOKPROC)AwtDialog::MouseHookProc_NonTT,\n+                                                                          0, fThread);\n+                            sm_BlockedThreads.put((void *)((intptr_t)fThread), blockedThread);\n@@ -1630,1 +1620,15 @@\n-                            blockedThread->framesCount--;\n+                            blockedThread->framesCount++;\n+                        }\n+                    } else {\n+                        \/\/ see the comment above: if Java Plugin behaviour when running in IE\n+                        \/\/ was right, blockedThread would be always not NULL here\n+                        if (blockedThread != NULL) {\n+                            DASSERT(blockedThread->framesCount > 0);\n+                            if ((blockedThread->framesCount) == 1) {\n+                                ::UnhookWindowsHookEx(blockedThread->modalHook);\n+                                ::UnhookWindowsHookEx(blockedThread->mouseHook);\n+                                sm_BlockedThreads.remove((void *)((intptr_t)fThread));\n+                                delete blockedThread;\n+                            } else {\n+                                blockedThread->framesCount--;\n+                            }\n@@ -1637,0 +1641,1 @@\n+\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Frame.cpp","additions":103,"deletions":98,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -38,4 +38,4 @@\n-    static jfieldID AwtPrintDialog::controlID;\n-    static jfieldID AwtPrintDialog::parentID;\n-    static jfieldID AwtPrintDialog::pageID;\n-    static jmethodID AwtPrintDialog::setHWndMID;\n+    static jfieldID controlID;\n+    static jfieldID parentID;\n+    static jfieldID pageID;\n+    static jmethodID setHWndMID;\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_PrintDialog.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+jfieldID AwtPrintDialog::pageID;\n+\n@@ -212,1 +214,0 @@\n-jfieldID AwtPrintDialog::pageID;\n@@ -531,13 +532,0 @@\n-    HWND parentID = AwtPrintControl::getParentID(env, self);\n-    if (parentID != NULL && ::IsWindow(parentID)) {\n-        \/\/ windows native modality is requested (used by JavaFX).\n-        setup.hwndOwner = parentID;\n-    }\n-    \/*\n-      Fix for 6488834.\n-      To disable Win32 native parent modality we have to set\n-      hwndOwner field to either NULL or some hidden window. For\n-      parentless dialogs we use NULL to show them in the taskbar,\n-      and for all other dialogs AwtToolkit's HWND is used.\n-    *\/\n-    else if (awtParent != NULL)\n@@ -545,6 +533,20 @@\n-        setup.hwndOwner = AwtToolkit::GetInstance().GetHWnd();\n-    }\n-    else\n-    {\n-        setup.hwndOwner = NULL;\n-    }\n+        HWND parentID = AwtPrintControl::getParentID(env, self);\n+        if (parentID != NULL && ::IsWindow(parentID)) {\n+            \/\/ windows native modality is requested (used by JavaFX).\n+            setup.hwndOwner = parentID;\n+        }\n+        \/*\n+          Fix for 6488834.\n+          To disable Win32 native parent modality we have to set\n+          hwndOwner field to either NULL or some hidden window. For\n+          parentless dialogs we use NULL to show them in the taskbar,\n+          and for all other dialogs AwtToolkit's HWND is used.\n+        *\/\n+        else if (awtParent != NULL)\n+        {\n+            setup.hwndOwner = AwtToolkit::GetInstance().GetHWnd();\n+        }\n+        else\n+        {\n+            setup.hwndOwner = NULL;\n+        }\n@@ -552,26 +554,20 @@\n-    setup.hDevMode = NULL;\n-    setup.hDevNames = NULL;\n-    setup.Flags = PSD_RETURNDEFAULT | PSD_DEFAULTMINMARGINS;\n-    \/\/ setup.ptPaperSize =\n-    \/\/ setup.rtMinMargin =\n-    \/\/ setup.rtMargin =\n-    setup.hInstance = NULL;\n-    setup.lCustData = (LPARAM)peerGlobalRef;\n-    setup.lpfnPageSetupHook = reinterpret_cast<LPPAGESETUPHOOK>(pageDlgHook);\n-    setup.lpfnPagePaintHook = NULL;\n-    setup.lpPageSetupTemplateName = NULL;\n-    setup.hPageSetupTemplate = NULL;\n-\n-\n-    \/* Because the return default flag is set, this first call\n-     * will not display the dialog but will return default values, inc\n-     * including hDevMode, hDevName, ptPaperSize, and rtMargin values.\n-     * We can use the devmode to set the orientation of the page\n-     * and the size of the page.\n-     * The units used by the user is also needed.\n-     *\/\n-    if (AwtPrintControl::getPrintHDMode(env, self) == NULL ||\n-        AwtPrintControl::getPrintHDName(env,self) == NULL) {\n-        (void)::PageSetupDlg(&setup);\n-        \/* check if hDevMode and hDevNames are set.\n-         * If both are null, then there is no default printer.\n+        setup.hDevMode = NULL;\n+        setup.hDevNames = NULL;\n+        setup.Flags = PSD_RETURNDEFAULT | PSD_DEFAULTMINMARGINS;\n+        \/\/ setup.ptPaperSize =\n+        \/\/ setup.rtMinMargin =\n+        \/\/ setup.rtMargin =\n+        setup.hInstance = NULL;\n+        setup.lCustData = (LPARAM)peerGlobalRef;\n+        setup.lpfnPageSetupHook = reinterpret_cast<LPPAGESETUPHOOK>(pageDlgHook);\n+        setup.lpfnPagePaintHook = NULL;\n+        setup.lpPageSetupTemplateName = NULL;\n+        setup.hPageSetupTemplate = NULL;\n+\n+\n+        \/* Because the return default flag is set, this first call\n+         * will not display the dialog but will return default values, inc\n+         * including hDevMode, hDevName, ptPaperSize, and rtMargin values.\n+         * We can use the devmode to set the orientation of the page\n+         * and the size of the page.\n+         * The units used by the user is also needed.\n@@ -579,11 +575,13 @@\n-        if ((setup.hDevMode == NULL) && (setup.hDevNames == NULL)) {\n-            doIt = JNI_FALSE;\n-            goto done;\n-        }\n-    } else {\n-        int measure = PSD_INTHOUSANDTHSOFINCHES;\n-        int sz = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_IMEASURE, NULL, 0);\n-        if (sz > 0) {\n-          LPTSTR str = (LPTSTR)SAFE_SIZE_ARRAY_ALLOC(safe_Malloc, sizeof(TCHAR), sz);\n-          if (str != NULL) {\n-            sz = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_IMEASURE, str, sz);\n+        if (AwtPrintControl::getPrintHDMode(env, self) == NULL ||\n+            AwtPrintControl::getPrintHDName(env,self) == NULL) {\n+            (void)::PageSetupDlg(&setup);\n+            \/* check if hDevMode and hDevNames are set.\n+             * If both are null, then there is no default printer.\n+             *\/\n+            if ((setup.hDevMode == NULL) && (setup.hDevNames == NULL)) {\n+                doIt = JNI_FALSE;\n+                goto done;\n+            }\n+        } else {\n+            int measure = PSD_INTHOUSANDTHSOFINCHES;\n+            int sz = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_IMEASURE, NULL, 0);\n@@ -591,2 +589,9 @@\n-              if (_tcscmp(TEXT(\"0\"), str) == 0) {\n-                measure = PSD_INHUNDREDTHSOFMILLIMETERS;\n+              LPTSTR str = (LPTSTR)SAFE_SIZE_ARRAY_ALLOC(safe_Malloc, sizeof(TCHAR), sz);\n+              if (str != NULL) {\n+                sz = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_IMEASURE, str, sz);\n+                if (sz > 0) {\n+                  if (_tcscmp(TEXT(\"0\"), str) == 0) {\n+                    measure = PSD_INHUNDREDTHSOFMILLIMETERS;\n+                  }\n+                }\n+                free((LPTSTR)str);\n@@ -595,2 +600,3 @@\n-            free((LPTSTR)str);\n-          }\n+            setup.Flags |= measure;\n+            setup.hDevMode = AwtPrintControl::getPrintHDMode(env, self);\n+            setup.hDevNames = AwtPrintControl::getPrintHDName(env, self);\n@@ -598,24 +604,6 @@\n-        setup.Flags |= measure;\n-        setup.hDevMode = AwtPrintControl::getPrintHDMode(env, self);\n-        setup.hDevNames = AwtPrintControl::getPrintHDName(env, self);\n-    }\n-    \/* Move page size and orientation from the PageFormat object\n-     * into the Windows setup structure so that the format can\n-     * be displayed in the dialog.\n-     *\/\n-    pageFormatToSetup(env, self, page, &setup, AwtPrintControl::getPrintDC(env, self));\n-    if (env->ExceptionCheck()) {\n-        doIt = JNI_FALSE;\n-        goto done;\n-    }\n-\n-    setup.lpfnPageSetupHook = reinterpret_cast<LPPAGESETUPHOOK>(pageDlgHook);\n-    setup.Flags = PSD_ENABLEPAGESETUPHOOK | PSD_MARGINS;\n-\n-    AwtDialog::CheckInstallModalHook();\n-\n-    BOOL ret = ::PageSetupDlg(&setup);\n-    if (ret) {\n-\n-        jobject paper = getPaper(env, page);\n-        if (paper == NULL) {\n+        \/* Move page size and orientation from the PageFormat object\n+         * into the Windows setup structure so that the format can\n+         * be displayed in the dialog.\n+         *\/\n+        pageFormatToSetup(env, self, page, &setup, AwtPrintControl::getPrintDC(env, self));\n+        if (env->ExceptionCheck()) {\n@@ -625,6 +613,0 @@\n-        int units = setup.Flags & PSD_INTHOUSANDTHSOFINCHES ?\n-                                                MM_HIENGLISH :\n-                                                MM_HIMETRIC;\n-        POINT paperSize;\n-        RECT margins;\n-        jint orientation;\n@@ -632,15 +614,36 @@\n-        \/* The printer may have been changed, and we track that change,\n-         * but then need to get a new DC for the current printer so that\n-         * we validate the paper size correctly\n-         *\/\n-        if (setup.hDevNames != NULL) {\n-            DEVNAMES* names = (DEVNAMES*)::GlobalLock(setup.hDevNames);\n-            if (names != NULL) {\n-                LPTSTR printer = (LPTSTR)names+names->wDeviceOffset;\n-                SAVE_CONTROLWORD\n-                HDC newDC = ::CreateDC(TEXT(\"WINSPOOL\"), printer, NULL, NULL);\n-                RESTORE_CONTROLWORD\n-                if (newDC != NULL) {\n-                    HDC oldDC = AwtPrintControl::getPrintDC(env, self);\n-                    if (oldDC != NULL) {\n-                         ::DeleteDC(oldDC);\n+        setup.lpfnPageSetupHook = reinterpret_cast<LPPAGESETUPHOOK>(pageDlgHook);\n+        setup.Flags = PSD_ENABLEPAGESETUPHOOK | PSD_MARGINS;\n+\n+        AwtDialog::CheckInstallModalHook();\n+\n+        BOOL ret = ::PageSetupDlg(&setup);\n+        if (ret) {\n+\n+            jobject paper = getPaper(env, page);\n+            if (paper == NULL) {\n+                doIt = JNI_FALSE;\n+                goto done;\n+            }\n+            int units = setup.Flags & PSD_INTHOUSANDTHSOFINCHES ?\n+                                                    MM_HIENGLISH :\n+                                                    MM_HIMETRIC;\n+            POINT paperSize;\n+            RECT margins;\n+            jint orientation;\n+\n+            \/* The printer may have been changed, and we track that change,\n+             * but then need to get a new DC for the current printer so that\n+             * we validate the paper size correctly\n+             *\/\n+            if (setup.hDevNames != NULL) {\n+                DEVNAMES* names = (DEVNAMES*)::GlobalLock(setup.hDevNames);\n+                if (names != NULL) {\n+                    LPTSTR printer = (LPTSTR)names+names->wDeviceOffset;\n+                    SAVE_CONTROLWORD\n+                    HDC newDC = ::CreateDC(TEXT(\"WINSPOOL\"), printer, NULL, NULL);\n+                    RESTORE_CONTROLWORD\n+                    if (newDC != NULL) {\n+                        HDC oldDC = AwtPrintControl::getPrintDC(env, self);\n+                        if (oldDC != NULL) {\n+                             ::DeleteDC(oldDC);\n+                        }\n@@ -648,0 +651,1 @@\n+                    AwtPrintControl::setPrintDC(env, self, newDC);\n@@ -649,1 +653,1 @@\n-                AwtPrintControl::setPrintDC(env, self, newDC);\n+                ::GlobalUnlock(setup.hDevNames);\n@@ -651,2 +655,0 @@\n-            ::GlobalUnlock(setup.hDevNames);\n-        }\n@@ -654,4 +656,4 @@\n-        \/* Get the Windows paper and margins description.\n-        *\/\n-        retrievePaperInfo(&setup, &paperSize, &margins, &orientation,\n-                          AwtPrintControl::getPrintDC(env, self));\n+            \/* Get the Windows paper and margins description.\n+            *\/\n+            retrievePaperInfo(&setup, &paperSize, &margins, &orientation,\n+                              AwtPrintControl::getPrintDC(env, self));\n@@ -659,30 +661,31 @@\n-        \/* Convert the Windows' paper and margins description\n-         * and place them into a Paper instance.\n-         *\/\n-        setPaperValues(env, paper, &paperSize, &margins, units);\n-         if (env->ExceptionCheck()) {\n-             doIt = JNI_FALSE;\n-             goto done;\n-         }\n-        \/*\n-         * Put the updated Paper instance and the orientation into\n-         * the PageFormat.\n-         *\/\n-        setPaper(env, page, paper);\n-        if (env->ExceptionCheck()) {\n-             doIt = JNI_FALSE;\n-             goto done;\n-        }\n-        setPageFormatOrientation(env, page, orientation);\n-        if (env->ExceptionCheck()) {\n-             doIt = JNI_FALSE;\n-             goto done;\n-        }\n-        if (setup.hDevMode != NULL) {\n-            DEVMODE *devmode = (DEVMODE *)::GlobalLock(setup.hDevMode);\n-            if (devmode != NULL) {\n-                if (devmode->dmFields & DM_PAPERSIZE) {\n-                    jboolean err = setPrintPaperSize(env, self, devmode->dmPaperSize);\n-                    if (err) {\n-                        doIt = JNI_FALSE;\n-                        goto done;\n+            \/* Convert the Windows' paper and margins description\n+             * and place them into a Paper instance.\n+             *\/\n+            setPaperValues(env, paper, &paperSize, &margins, units);\n+             if (env->ExceptionCheck()) {\n+                 doIt = JNI_FALSE;\n+                 goto done;\n+             }\n+            \/*\n+             * Put the updated Paper instance and the orientation into\n+             * the PageFormat.\n+             *\/\n+            setPaper(env, page, paper);\n+            if (env->ExceptionCheck()) {\n+                 doIt = JNI_FALSE;\n+                 goto done;\n+            }\n+            setPageFormatOrientation(env, page, orientation);\n+            if (env->ExceptionCheck()) {\n+                 doIt = JNI_FALSE;\n+                 goto done;\n+            }\n+            if (setup.hDevMode != NULL) {\n+                DEVMODE *devmode = (DEVMODE *)::GlobalLock(setup.hDevMode);\n+                if (devmode != NULL) {\n+                    if (devmode->dmFields & DM_PAPERSIZE) {\n+                        jboolean err = setPrintPaperSize(env, self, devmode->dmPaperSize);\n+                        if (err) {\n+                            doIt = JNI_FALSE;\n+                            goto done;\n+                        }\n@@ -691,0 +694,1 @@\n+                ::GlobalUnlock(setup.hDevMode);\n@@ -692,1 +696,1 @@\n-            ::GlobalUnlock(setup.hDevMode);\n+            doIt = JNI_TRUE;\n@@ -694,2 +698,0 @@\n-        doIt = JNI_TRUE;\n-    }\n@@ -697,1 +699,1 @@\n-    AwtDialog::CheckUninstallModalHook();\n+        AwtDialog::CheckUninstallModalHook();\n@@ -699,1 +701,1 @@\n-    AwtDialog::ModalActivateNextWindow(NULL, target, peer);\n+        AwtDialog::ModalActivateNextWindow(NULL, target, peer);\n@@ -701,4 +703,4 @@\n-    HGLOBAL oldG = AwtPrintControl::getPrintHDMode(env, self);\n-    if (setup.hDevMode != oldG) {\n-        AwtPrintControl::setPrintHDMode(env, self, setup.hDevMode);\n-    }\n+        HGLOBAL oldG = AwtPrintControl::getPrintHDMode(env, self);\n+        if (setup.hDevMode != oldG) {\n+            AwtPrintControl::setPrintHDMode(env, self, setup.hDevMode);\n+        }\n@@ -706,3 +708,4 @@\n-    oldG = AwtPrintControl::getPrintHDName(env, self);\n-    if (setup.hDevNames != oldG) {\n-        AwtPrintControl::setPrintHDName(env, self, setup.hDevNames);\n+        oldG = AwtPrintControl::getPrintHDName(env, self);\n+        if (setup.hDevNames != oldG) {\n+            AwtPrintControl::setPrintHDName(env, self, setup.hDevNames);\n+        }\n@@ -922,1 +925,2 @@\n-    JNI_CHECK_NULL_GOTO(printDC, \"Invalid printDC\", done);\n+    {\n+        JNI_CHECK_NULL_GOTO(printDC, \"Invalid printDC\", done);\n@@ -924,82 +928,82 @@\n-    \/* We try to mitigate the effects of floating point rounding errors\n-     * by only setting a value if it would differ from the value in the\n-     * target by at least 0.10 points = 1\/720 inches.\n-     * eg if the values present in the target are close to the calculated\n-     * values then we accept the target.\n-     *\/\n-    const double epsilon = 0.10;\n-\n-    jdouble paperWidth, paperHeight;\n-    jboolean err;\n-    WORD dmPaperSize = getPrintPaperSize(env, &err, self);\n-    if (err) goto done;\n-\n-    double ix, iy, iw, ih, pw, ph;\n-\n-    DASSERT(AwtToolkit::MainThread() != ::GetCurrentThreadId());\n-    jmethodID getID;\n-\n-    jclass paperClass = env->GetObjectClass(origPaper);\n-    JNI_CHECK_NULL_GOTO(paperClass, \"paper class not found\", done);\n-    getID = env->GetMethodID(paperClass, GETWIDTH_STR, GETWIDTH_SIG);\n-    JNI_CHECK_NULL_GOTO(getID, \"no getWidth method\", done);\n-    pw = env->CallDoubleMethod(origPaper, getID);\n-    getID = env->GetMethodID(paperClass, GETHEIGHT_STR, GETHEIGHT_SIG);\n-    JNI_CHECK_NULL_GOTO(getID, \"no getHeight method\", done);\n-    ph = env->CallDoubleMethod(origPaper, getID);\n-    getID = env->GetMethodID(paperClass, GETIMG_X_STR, GETIMG_X_SIG);\n-    JNI_CHECK_NULL_GOTO(getID, \"no getX method\", done);\n-    ix = env->CallDoubleMethod(origPaper, getID);\n-    getID = env->GetMethodID(paperClass, GETIMG_Y_STR, GETIMG_Y_SIG);\n-    JNI_CHECK_NULL_GOTO(getID, \"no getY method\", done);\n-    iy = env->CallDoubleMethod(origPaper, getID);\n-    getID = env->GetMethodID(paperClass, GETIMG_W_STR, GETIMG_W_SIG);\n-    JNI_CHECK_NULL_GOTO(getID, \"no getW method\", done);\n-    iw = env->CallDoubleMethod(origPaper, getID);\n-    getID = env->GetMethodID(paperClass, GETIMG_H_STR, GETIMG_H_SIG);\n-    JNI_CHECK_NULL_GOTO(getID, \"no getH method\", done);\n-    ih = env->CallDoubleMethod(origPaper, getID);\n-\n-    matchPaperSize(printDC, hDevMode, hDevNames, pw, ph,\n-                   &paperWidth, &paperHeight, &dmPaperSize);\n-\n-    \/* Validate margins and imageable area *\/\n-\n-    \/\/ pixels per inch in x and y direction\n-    jint xPixelRes = GetDeviceCaps(printDC, LOGPIXELSX);\n-    jint yPixelRes = GetDeviceCaps(printDC, LOGPIXELSY);\n-\n-    \/\/ x & y coord of printable area in pixels\n-    jint xPixelOrg = GetDeviceCaps(printDC, PHYSICALOFFSETX);\n-    jint yPixelOrg = GetDeviceCaps(printDC, PHYSICALOFFSETY);\n-\n-    \/\/ width & height of printable area in pixels\n-    jint imgPixelWid = GetDeviceCaps(printDC, HORZRES);\n-    jint imgPixelHgt = GetDeviceCaps(printDC, VERTRES);\n-\n-    \/\/ The DC may be obtained when we first selected the printer as a\n-    \/\/ result of a call to setNativePrintService.\n-    \/\/ If the Devmode was obtained later on from the DocumentProperties dialog\n-    \/\/ the DC won't have been updated and its settings may be for PORTRAIT.\n-    \/\/ This may happen in other cases too, but was observed for the above.\n-    \/\/ To get a DC compatible with this devmode we should really call\n-    \/\/ CreateDC() again to get a DC for the devmode we are using.\n-    \/\/ The changes for that are a lot more risk, so to minimize that\n-    \/\/ risk, assume its not LANDSCAPE unless width > height, even if the\n-    \/\/ devmode says its LANDSCAPE.\n-    \/\/ if the values were obtained from a rotated device, swap.\n-    if ((getOrientationFromDevMode2(hDevMode) == DMORIENT_LANDSCAPE) &&\n-        (imgPixelWid > imgPixelHgt)) {\n-      jint tmp;\n-      tmp = xPixelRes;\n-      xPixelRes = yPixelRes;\n-      yPixelRes = tmp;\n-\n-      tmp = xPixelOrg;\n-      xPixelOrg = yPixelOrg;\n-      yPixelOrg = tmp;\n-\n-      tmp = imgPixelWid;\n-      imgPixelWid = imgPixelHgt;\n-      imgPixelHgt = tmp;\n-    }\n+        \/* We try to mitigate the effects of floating point rounding errors\n+         * by only setting a value if it would differ from the value in the\n+         * target by at least 0.10 points = 1\/720 inches.\n+         * eg if the values present in the target are close to the calculated\n+         * values then we accept the target.\n+         *\/\n+        const double epsilon = 0.10;\n+\n+        jdouble paperWidth, paperHeight;\n+        jboolean err;\n+        WORD dmPaperSize = getPrintPaperSize(env, &err, self);\n+        if (err) goto done;\n+\n+        double ix, iy, iw, ih, pw, ph;\n+\n+        DASSERT(AwtToolkit::MainThread() != ::GetCurrentThreadId());\n+        jmethodID getID;\n+\n+        jclass paperClass = env->GetObjectClass(origPaper);\n+        JNI_CHECK_NULL_GOTO(paperClass, \"paper class not found\", done);\n+        getID = env->GetMethodID(paperClass, GETWIDTH_STR, GETWIDTH_SIG);\n+        JNI_CHECK_NULL_GOTO(getID, \"no getWidth method\", done);\n+        pw = env->CallDoubleMethod(origPaper, getID);\n+        getID = env->GetMethodID(paperClass, GETHEIGHT_STR, GETHEIGHT_SIG);\n+        JNI_CHECK_NULL_GOTO(getID, \"no getHeight method\", done);\n+        ph = env->CallDoubleMethod(origPaper, getID);\n+        getID = env->GetMethodID(paperClass, GETIMG_X_STR, GETIMG_X_SIG);\n+        JNI_CHECK_NULL_GOTO(getID, \"no getX method\", done);\n+        ix = env->CallDoubleMethod(origPaper, getID);\n+        getID = env->GetMethodID(paperClass, GETIMG_Y_STR, GETIMG_Y_SIG);\n+        JNI_CHECK_NULL_GOTO(getID, \"no getY method\", done);\n+        iy = env->CallDoubleMethod(origPaper, getID);\n+        getID = env->GetMethodID(paperClass, GETIMG_W_STR, GETIMG_W_SIG);\n+        JNI_CHECK_NULL_GOTO(getID, \"no getW method\", done);\n+        iw = env->CallDoubleMethod(origPaper, getID);\n+        getID = env->GetMethodID(paperClass, GETIMG_H_STR, GETIMG_H_SIG);\n+        JNI_CHECK_NULL_GOTO(getID, \"no getH method\", done);\n+        ih = env->CallDoubleMethod(origPaper, getID);\n+\n+        matchPaperSize(printDC, hDevMode, hDevNames, pw, ph,\n+                       &paperWidth, &paperHeight, &dmPaperSize);\n+\n+        \/* Validate margins and imageable area *\/\n+\n+        \/\/ pixels per inch in x and y direction\n+        jint xPixelRes = GetDeviceCaps(printDC, LOGPIXELSX);\n+        jint yPixelRes = GetDeviceCaps(printDC, LOGPIXELSY);\n+\n+        \/\/ x & y coord of printable area in pixels\n+        jint xPixelOrg = GetDeviceCaps(printDC, PHYSICALOFFSETX);\n+        jint yPixelOrg = GetDeviceCaps(printDC, PHYSICALOFFSETY);\n+\n+        \/\/ width & height of printable area in pixels\n+        jint imgPixelWid = GetDeviceCaps(printDC, HORZRES);\n+        jint imgPixelHgt = GetDeviceCaps(printDC, VERTRES);\n+\n+        \/\/ The DC may be obtained when we first selected the printer as a\n+        \/\/ result of a call to setNativePrintService.\n+        \/\/ If the Devmode was obtained later on from the DocumentProperties dialog\n+        \/\/ the DC won't have been updated and its settings may be for PORTRAIT.\n+        \/\/ This may happen in other cases too, but was observed for the above.\n+        \/\/ To get a DC compatible with this devmode we should really call\n+        \/\/ CreateDC() again to get a DC for the devmode we are using.\n+        \/\/ The changes for that are a lot more risk, so to minimize that\n+        \/\/ risk, assume its not LANDSCAPE unless width > height, even if the\n+        \/\/ devmode says its LANDSCAPE.\n+        \/\/ if the values were obtained from a rotated device, swap.\n+        if ((getOrientationFromDevMode2(hDevMode) == DMORIENT_LANDSCAPE) &&\n+            (imgPixelWid > imgPixelHgt)) {\n+          jint tmp;\n+          tmp = xPixelRes;\n+          xPixelRes = yPixelRes;\n+          yPixelRes = tmp;\n+\n+          tmp = xPixelOrg;\n+          xPixelOrg = yPixelOrg;\n+          yPixelOrg = tmp;\n+\n+          tmp = imgPixelWid;\n+          imgPixelWid = imgPixelHgt;\n+          imgPixelHgt = tmp;\n+        }\n@@ -1007,5 +1011,5 @@\n-    \/\/ page imageable area in 1\/72\"\n-    jdouble imgX = (jdouble)((xPixelOrg * 72)\/(jdouble)xPixelRes);\n-    jdouble imgY = (jdouble)((yPixelOrg * 72)\/(jdouble)yPixelRes);\n-    jdouble imgWid = (jdouble)((imgPixelWid * 72)\/(jdouble)xPixelRes);\n-    jdouble imgHgt = (jdouble)((imgPixelHgt * 72)\/(jdouble)yPixelRes);\n+        \/\/ page imageable area in 1\/72\"\n+        jdouble imgX = (jdouble)((xPixelOrg * 72)\/(jdouble)xPixelRes);\n+        jdouble imgY = (jdouble)((yPixelOrg * 72)\/(jdouble)yPixelRes);\n+        jdouble imgWid = (jdouble)((imgPixelWid * 72)\/(jdouble)xPixelRes);\n+        jdouble imgHgt = (jdouble)((imgPixelHgt * 72)\/(jdouble)yPixelRes);\n@@ -1013,4 +1017,4 @@\n-    \/* Check each of the individual values is within range.\n-     * Then make sure imageable area is placed within imageable area.\n-     * Allow for a small floating point error in the comparisons\n-     *\/\n+        \/* Check each of the individual values is within range.\n+         * Then make sure imageable area is placed within imageable area.\n+         * Allow for a small floating point error in the comparisons\n+         *\/\n@@ -1018,30 +1022,30 @@\n-    if (ix < 0.0 ) {\n-        ix = 0.0;\n-    }\n-    if (iy < 0.0 ) {\n-        iy = 0.0;\n-    }\n-    if (iw < 0.0) {\n-        iw = 0.0;\n-    }\n-    if (ih < 0.0) {\n-        ih = 0.0;\n-    }\n-    if ((ix + epsilon) < imgX) {\n-         ix = imgX;\n-    }\n-    if ((iy + epsilon) < imgY) {\n-         iy = imgY;\n-    }\n-    if (iw + epsilon > imgWid) {\n-        iw = imgWid;\n-    }\n-    if (ih + epsilon > imgHgt) {\n-        ih = imgHgt;\n-    }\n-    if ((ix + iw + epsilon) > (imgX+imgWid)) {\n-        ix = (imgX+imgWid) - iw;\n-    }\n-    if ((iy + ih + epsilon) > (imgY+imgHgt)) {\n-        iy = (imgY+imgHgt) - ih;\n-    }\n+        if (ix < 0.0 ) {\n+            ix = 0.0;\n+        }\n+        if (iy < 0.0 ) {\n+            iy = 0.0;\n+        }\n+        if (iw < 0.0) {\n+            iw = 0.0;\n+        }\n+        if (ih < 0.0) {\n+            ih = 0.0;\n+        }\n+        if ((ix + epsilon) < imgX) {\n+             ix = imgX;\n+        }\n+        if ((iy + epsilon) < imgY) {\n+             iy = imgY;\n+        }\n+        if (iw + epsilon > imgWid) {\n+            iw = imgWid;\n+        }\n+        if (ih + epsilon > imgHgt) {\n+            ih = imgHgt;\n+        }\n+        if ((ix + iw + epsilon) > (imgX+imgWid)) {\n+            ix = (imgX+imgWid) - iw;\n+        }\n+        if ((iy + ih + epsilon) > (imgY+imgHgt)) {\n+            iy = (imgY+imgHgt) - ih;\n+        }\n@@ -1049,1 +1053,1 @@\n-    DASSERT(AwtToolkit::MainThread() != ::GetCurrentThreadId());\n+        DASSERT(AwtToolkit::MainThread() != ::GetCurrentThreadId());\n@@ -1051,1 +1055,1 @@\n-    jmethodID setSizeID = env->GetMethodID(paperClass,\n+        jmethodID setSizeID = env->GetMethodID(paperClass,\n@@ -1053,1 +1057,1 @@\n-    JNI_CHECK_NULL_GOTO(setSizeID, \"no setSize method\", done);\n+        JNI_CHECK_NULL_GOTO(setSizeID, \"no setSize method\", done);\n@@ -1055,3 +1059,3 @@\n-    jmethodID setImageableID = env->GetMethodID(paperClass,\n-                                        SETIMAGEABLE_STR, SETIMAGEABLE_SIG);\n-    JNI_CHECK_NULL_GOTO(setImageableID, \"no setImageable method\", done);\n+        jmethodID setImageableID = env->GetMethodID(paperClass,\n+                                            SETIMAGEABLE_STR, SETIMAGEABLE_SIG);\n+        JNI_CHECK_NULL_GOTO(setImageableID, \"no setImageable method\", done);\n@@ -1059,2 +1063,3 @@\n-    env->CallVoidMethod(newPaper, setSizeID, paperWidth, paperHeight);\n-    env->CallVoidMethod(newPaper, setImageableID, ix, iy, iw, ih);\n+        env->CallVoidMethod(newPaper, setSizeID, paperWidth, paperHeight);\n+        env->CallVoidMethod(newPaper, setImageableID, ix, iy, iw, ih);\n+    }\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_PrintJob.cpp","additions":290,"deletions":285,"binary":false,"changes":575,"status":"modified"},{"patch":"@@ -56,0 +56,4 @@\n+jmethodID AwtTextComponent::canAccessClipboardMID;\n+AwtTextComponent::OleCallback AwtTextComponent::sm_oleCallback;\n+WNDPROC AwtTextComponent::sm_pDefWindowProc = NULL;\n+\n@@ -60,2 +64,0 @@\n-jmethodID AwtTextComponent::canAccessClipboardMID;\n-\n@@ -914,2 +916,0 @@\n-AwtTextComponent::OleCallback AwtTextComponent::sm_oleCallback;\n-\n@@ -1043,2 +1043,0 @@\n-WNDPROC AwtTextComponent::sm_pDefWindowProc = NULL;\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_TextComponent.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1025,3 +1025,4 @@\n-    PDATA pData;\n-    JNI_CHECK_PEER_GOTO(self, ret);\n-    AwtWindow *window = (AwtWindow *)pData;\n+    {\n+        PDATA pData;\n+        JNI_CHECK_PEER_GOTO(self, ret);\n+        AwtWindow *window = (AwtWindow *)pData;\n@@ -1029,1 +1030,2 @@\n-    window->RepositionSecurityWarning(env);\n+        window->RepositionSecurityWarning(env);\n+    }\n@@ -3126,7 +3128,8 @@\n-    JNI_CHECK_NULL_GOTO(self, \"peer\", ret);\n-    PDATA pData = JNI_GET_PDATA(self);\n-    if (pData == NULL) {\n-        env->DeleteGlobalRef(self);\n-        delete mds;\n-        return;\n-    }\n+    {\n+        JNI_CHECK_NULL_GOTO(self, \"peer\", ret);\n+        PDATA pData = JNI_GET_PDATA(self);\n+        if (pData == NULL) {\n+            env->DeleteGlobalRef(self);\n+            delete mds;\n+            return;\n+        }\n@@ -3134,4 +3137,5 @@\n-    window = (AwtWindow *)pData;\n-    windowHWnd = window->GetHWnd();\n-    if (::IsWindow(windowHWnd)) {\n-        AwtWindow::SetAndActivateModalBlocker(windowHWnd, blockerHWnd);\n+        window = (AwtWindow *)pData;\n+        windowHWnd = window->GetHWnd();\n+        if (::IsWindow(windowHWnd)) {\n+            AwtWindow::SetAndActivateModalBlocker(windowHWnd, blockerHWnd);\n+        }\n@@ -3155,6 +3159,7 @@\n-    JNI_CHECK_NULL_GOTO(self, \"peer\", ret);\n-    PDATA pData = JNI_GET_PDATA(self);\n-    if (pData == NULL) {\n-        env->DeleteGlobalRef(self);\n-        return;\n-    }\n+    {\n+        JNI_CHECK_NULL_GOTO(self, \"peer\", ret);\n+        PDATA pData = JNI_GET_PDATA(self);\n+        if (pData == NULL) {\n+            env->DeleteGlobalRef(self);\n+            return;\n+        }\n@@ -3162,4 +3167,5 @@\n-    window = (AwtWindow *)pData;\n-    windowHWnd = window->GetHWnd();\n-    if (::IsWindow(windowHWnd)) {\n-        AwtWindow::SetModalBlocker(windowHWnd, NULL);\n+        window = (AwtWindow *)pData;\n+        windowHWnd = window->GetHWnd();\n+        if (::IsWindow(windowHWnd)) {\n+            AwtWindow::SetModalBlocker(windowHWnd, NULL);\n+        }\n@@ -3180,3 +3186,4 @@\n-    PDATA pData;\n-    JNI_CHECK_PEER_GOTO(self, ret);\n-    AwtWindow *window = (AwtWindow *)pData;\n+    {\n+        PDATA pData;\n+        JNI_CHECK_PEER_GOTO(self, ret);\n+        AwtWindow *window = (AwtWindow *)pData;\n@@ -3184,1 +3191,2 @@\n-    window->SetTranslucency(iOpacity, window->isOpaque());\n+        window->SetTranslucency(iOpacity, window->isOpaque());\n+    }\n@@ -3199,3 +3207,4 @@\n-    PDATA pData;\n-    JNI_CHECK_PEER_GOTO(self, ret);\n-    AwtWindow *window = (AwtWindow *)pData;\n+    {\n+        PDATA pData;\n+        JNI_CHECK_PEER_GOTO(self, ret);\n+        AwtWindow *window = (AwtWindow *)pData;\n@@ -3203,1 +3212,2 @@\n-    window->SetTranslucency(window->getOpacity(), isOpaque);\n+        window->SetTranslucency(window->getOpacity(), isOpaque);\n+    }\n@@ -3218,3 +3228,4 @@\n-    PDATA pData;\n-    JNI_CHECK_PEER_GOTO(self, ret);\n-    AwtWindow *window = (AwtWindow *)pData;\n+    {\n+        PDATA pData;\n+        JNI_CHECK_PEER_GOTO(self, ret);\n+        AwtWindow *window = (AwtWindow *)pData;\n@@ -3222,2 +3233,3 @@\n-    window->UpdateWindow(env, data, (int)uws->width, (int)uws->height,\n-                         uws->hBitmap);\n+        window->UpdateWindow(env, data, (int)uws->width, (int)uws->height,\n+                             uws->hBitmap);\n+    }\n@@ -3242,3 +3254,4 @@\n-    PDATA pData;\n-    JNI_CHECK_PEER_GOTO(self, ret);\n-    AwtWindow *window = (AwtWindow *)pData;\n+    {\n+        PDATA pData;\n+        JNI_CHECK_PEER_GOTO(self, ret);\n+        AwtWindow *window = (AwtWindow *)pData;\n@@ -3246,1 +3259,2 @@\n-    window->setFullScreenExclusiveModeState(state != 0);\n+        window->setFullScreenExclusiveModeState(state != 0);\n+    }\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Window.cpp","additions":56,"deletions":42,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -371,3 +371,0 @@\n-    if (value == NULL) {\n-        goto err;\n-    }\n@@ -375,5 +372,4 @@\n-    len = MultiByteToWideChar(CP_UTF8, 0, input, len, value, len+1);\n-    if (len == 0) {\n-        goto err;\n-    }\n-    value[len] = 0;\n+    {\n+        if (value == NULL) {\n+            goto err;\n+        }\n@@ -381,1 +377,5 @@\n-    PP(\"import_name from %ls\", value);\n+        len = MultiByteToWideChar(CP_UTF8, 0, input, len, value, len+1);\n+        if (len == 0) {\n+            goto err;\n+        }\n+        value[len] = 0;\n@@ -383,12 +383,1 @@\n-    if (len > 33 && !wcscmp(value+len-33, L\"@WELLKNOWN:ORG.H5L.REFERALS-REALM\")) {\n-        \/\/ Remove the wellknown referrals realms\n-        value[len-33] = 0;\n-        len -= 33;\n-    } else if (value[len-1] == L'@') {\n-        \/\/ Remove the empty realm. It might come from an NT_EXPORT_NAME.\n-        value[len-1] = 0;\n-        len--;\n-    }\n-    if (len == 0) {\n-        goto err;\n-    }\n+        PP(\"import_name from %ls\", value);\n@@ -396,11 +385,25 @@\n-    if (input_name_type != NULL\n-            && is_same_oid(input_name_type, &HOST_SERVICE_NAME_OID)) {\n-        \/\/ HOST_SERVICE_NAME_OID takes the form of service@host.\n-        for (int i = 0; i < len; i++) {\n-            if (value[i] == L'\\\\') {\n-                i++;\n-                continue;\n-            }\n-            if (value[i] == L'@') {\n-                value[i] = L'\/';\n-                break;\n+        if (len > 33 && !wcscmp(value+len-33, L\"@WELLKNOWN:ORG.H5L.REFERALS-REALM\")) {\n+            \/\/ Remove the wellknown referrals realms\n+            value[len-33] = 0;\n+            len -= 33;\n+        } else if (value[len-1] == L'@') {\n+            \/\/ Remove the empty realm. It might come from an NT_EXPORT_NAME.\n+            value[len-1] = 0;\n+            len--;\n+        }\n+        if (len == 0) {\n+            goto err;\n+        }\n+\n+        if (input_name_type != NULL\n+                && is_same_oid(input_name_type, &HOST_SERVICE_NAME_OID)) {\n+            \/\/ HOST_SERVICE_NAME_OID takes the form of service@host.\n+            for (int i = 0; i < len; i++) {\n+                if (value[i] == L'\\\\') {\n+                    i++;\n+                    continue;\n+                }\n+                if (value[i] == L'@') {\n+                    value[i] = L'\/';\n+                    break;\n+                }\n@@ -408,0 +411,1 @@\n+            PP(\"Host-based service now %ls\", value);\n@@ -409,6 +413,8 @@\n-        PP(\"Host-based service now %ls\", value);\n-    }\n-    PP(\"import_name to %ls\", value);\n-    gss_name_struct* name = new gss_name_struct;\n-    if (name == NULL) {\n-        goto err;\n+        PP(\"import_name to %ls\", value);\n+        gss_name_struct* name = new gss_name_struct;\n+        if (name == NULL) {\n+            goto err;\n+        }\n+        name->name = value;\n+        *output_name = (gss_name_t) name;\n+        return GSS_S_COMPLETE;\n@@ -416,3 +422,1 @@\n-    name->name = value;\n-    *output_name = (gss_name_t) name;\n-    return GSS_S_COMPLETE;\n+\n@@ -531,31 +535,37 @@\n-    if (!fullname) {\n-        goto err;\n-    }\n-    PP(\"Make fullname: %ls -> %ls\", name, fullname);\n-    int len;\n-    size_t namelen = wcslen(fullname);\n-    if (namelen > 255) {\n-        goto err;\n-    }\n-    len = (int)namelen;\n-    \/\/ We only deal with not-so-long names.\n-    \/\/ 04 01 00 ** 06 ** OID len:int32 name\n-    int mechLen = KRB5_OID.length;\n-    char* buffer = (char*) malloc(10 + mechLen + len);\n-    if (buffer == NULL) {\n-        goto err;\n-    }\n-    buffer[0] = 4;\n-    buffer[1] = 1;\n-    buffer[2] = 0;\n-    buffer[3] = 2 + mechLen;\n-    buffer[4] = 6;\n-    buffer[5] = mechLen;\n-    memcpy_s(buffer + 6, mechLen, KRB5_OID.elements, mechLen);\n-    buffer[6 + mechLen] = buffer[7 + mechLen] = buffer[8 + mechLen] = 0;\n-    buffer[9 + mechLen] = (char)len;\n-    len = WideCharToMultiByte(CP_UTF8, 0, fullname, len,\n-                buffer+10+mechLen, len, NULL, NULL);\n-    if (len == 0) {\n-        free(buffer);\n-        goto err;\n+\n+    {\n+        if (!fullname) {\n+            goto err;\n+        }\n+        PP(\"Make fullname: %ls -> %ls\", name, fullname);\n+        int len;\n+        size_t namelen = wcslen(fullname);\n+        if (namelen > 255) {\n+            goto err;\n+        }\n+        len = (int)namelen;\n+        \/\/ We only deal with not-so-long names.\n+        \/\/ 04 01 00 ** 06 ** OID len:int32 name\n+        int mechLen = KRB5_OID.length;\n+        char* buffer = (char*) malloc(10 + mechLen + len);\n+        if (buffer == NULL) {\n+            goto err;\n+        }\n+        buffer[0] = 4;\n+        buffer[1] = 1;\n+        buffer[2] = 0;\n+        buffer[3] = 2 + mechLen;\n+        buffer[4] = 6;\n+        buffer[5] = mechLen;\n+        memcpy_s(buffer + 6, mechLen, KRB5_OID.elements, mechLen);\n+        buffer[6 + mechLen] = buffer[7 + mechLen] = buffer[8 + mechLen] = 0;\n+        buffer[9 + mechLen] = (char)len;\n+        len = WideCharToMultiByte(CP_UTF8, 0, fullname, len,\n+                    buffer+10+mechLen, len, NULL, NULL);\n+        if (len == 0) {\n+            free(buffer);\n+            goto err;\n+        }\n+        exported_name->length = 10 + mechLen + len;\n+        exported_name->value = buffer;\n+        result = GSS_S_COMPLETE;\n@@ -563,3 +573,1 @@\n-    exported_name->length = 10 + mechLen + len;\n-    exported_name->value = buffer;\n-    result = GSS_S_COMPLETE;\n+\n@@ -907,52 +915,56 @@\n-    int flag = flag_gss_to_sspi(req_flags) | ISC_REQ_ALLOCATE_MEMORY;\n-\n-    outBuffDesc.ulVersion = SECBUFFER_VERSION;\n-    outBuffDesc.cBuffers = 1;\n-    outBuffDesc.pBuffers = &outSecBuff;\n-\n-    outSecBuff.BufferType = SECBUFFER_TOKEN;\n-\n-    if (!firstTime) {\n-        inBuffDesc.ulVersion = SECBUFFER_VERSION;\n-        inBuffDesc.cBuffers = 1;\n-        inBuffDesc.pBuffers = &inSecBuff;\n-\n-        inSecBuff.BufferType = SECBUFFER_TOKEN;\n-        inSecBuff.cbBuffer = (ULONG)input_token->length;\n-        inSecBuff.pvBuffer = input_token->value;\n-    } else if (!pc->phCred) {\n-        if (isSPNEGO && initiator_cred_handle\n-                && initiator_cred_handle->phCredS) {\n-            PP(\"Find SPNEGO credentials\");\n-            pc->phCred = initiator_cred_handle->phCredS;\n-            pc->isLocalCred = FALSE;\n-        } else if (!isSPNEGO && initiator_cred_handle\n-                && initiator_cred_handle->phCredK) {\n-            PP(\"Find Kerberos credentials\");\n-            pc->phCred = initiator_cred_handle->phCredK;\n-            pc->isLocalCred = FALSE;\n-        } else {\n-            PP(\"No credentials provided, acquire myself\");\n-            newCred = new CredHandle;\n-            if (!newCred) {\n-                goto err;\n-            }\n-            SEC_WINNT_AUTH_IDENTITY_EX auth;\n-            ZeroMemory(&auth, sizeof(auth));\n-            auth.Version = SEC_WINNT_AUTH_IDENTITY_VERSION;\n-            auth.Length = sizeof(auth);\n-            auth.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;\n-            auth.PackageList = (unsigned short*)L\"Kerberos\";\n-            auth.PackageListLength = 8;\n-            ss = AcquireCredentialsHandle(\n-                    NULL,\n-                    (LPWSTR)(isSPNEGO ? L\"Negotiate\" : L\"Kerberos\"),\n-                    SECPKG_CRED_OUTBOUND,\n-                    NULL,\n-                    isSPNEGO ? &auth : NULL,\n-                    NULL,\n-                    NULL,\n-                    newCred,\n-                    &lifeTime);\n-            if (!(SEC_SUCCESS(ss))) {\n-                goto err;\n+    {\n+        int flag = flag_gss_to_sspi(req_flags) | ISC_REQ_ALLOCATE_MEMORY;\n+\n+        outBuffDesc.ulVersion = SECBUFFER_VERSION;\n+        outBuffDesc.cBuffers = 1;\n+        outBuffDesc.pBuffers = &outSecBuff;\n+\n+        outSecBuff.BufferType = SECBUFFER_TOKEN;\n+\n+        if (!firstTime) {\n+            inBuffDesc.ulVersion = SECBUFFER_VERSION;\n+            inBuffDesc.cBuffers = 1;\n+            inBuffDesc.pBuffers = &inSecBuff;\n+\n+            inSecBuff.BufferType = SECBUFFER_TOKEN;\n+            inSecBuff.cbBuffer = (ULONG)input_token->length;\n+            inSecBuff.pvBuffer = input_token->value;\n+        } else if (!pc->phCred) {\n+            if (isSPNEGO && initiator_cred_handle\n+                    && initiator_cred_handle->phCredS) {\n+                PP(\"Find SPNEGO credentials\");\n+                pc->phCred = initiator_cred_handle->phCredS;\n+                pc->isLocalCred = FALSE;\n+            } else if (!isSPNEGO && initiator_cred_handle\n+                    && initiator_cred_handle->phCredK) {\n+                PP(\"Find Kerberos credentials\");\n+                pc->phCred = initiator_cred_handle->phCredK;\n+                pc->isLocalCred = FALSE;\n+            } else {\n+                PP(\"No credentials provided, acquire myself\");\n+                newCred = new CredHandle;\n+                if (!newCred) {\n+                    goto err;\n+                }\n+                SEC_WINNT_AUTH_IDENTITY_EX auth;\n+                ZeroMemory(&auth, sizeof(auth));\n+                auth.Version = SEC_WINNT_AUTH_IDENTITY_VERSION;\n+                auth.Length = sizeof(auth);\n+                auth.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;\n+                auth.PackageList = (unsigned short*)L\"Kerberos\";\n+                auth.PackageListLength = 8;\n+                ss = AcquireCredentialsHandle(\n+                        NULL,\n+                        (LPWSTR)(isSPNEGO ? L\"Negotiate\" : L\"Kerberos\"),\n+                        SECPKG_CRED_OUTBOUND,\n+                        NULL,\n+                        isSPNEGO ? &auth : NULL,\n+                        NULL,\n+                        NULL,\n+                        newCred,\n+                        &lifeTime);\n+                if (!(SEC_SUCCESS(ss))) {\n+                    goto err;\n+                }\n+                pc->phCred = newCred;\n+                pc->isLocalCred = TRUE;\n@@ -960,21 +972,19 @@\n-            pc->phCred = newCred;\n-            pc->isLocalCred = TRUE;\n-        }\n-    }\n-    ss = InitializeSecurityContext(\n-            pc->phCred,\n-            firstTime ? NULL : &pc->hCtxt,\n-            outName,\n-            flag,\n-            0,\n-            SECURITY_NATIVE_DREP,\n-            firstTime ? NULL : &inBuffDesc,\n-            0,\n-            &pc->hCtxt,\n-            &outBuffDesc,\n-            &outFlag,\n-            &lifeTime);\n-\n-    if (!SEC_SUCCESS(ss)) {\n-        PP(\"InitializeSecurityContext failed\");\n-        goto err;\n+        }\n+        ss = InitializeSecurityContext(\n+                pc->phCred,\n+                firstTime ? NULL : &pc->hCtxt,\n+                outName,\n+                flag,\n+                0,\n+                SECURITY_NATIVE_DREP,\n+                firstTime ? NULL : &inBuffDesc,\n+                0,\n+                &pc->hCtxt,\n+                &outBuffDesc,\n+                &outFlag,\n+                &lifeTime);\n+\n+        if (!SEC_SUCCESS(ss)) {\n+            PP(\"InitializeSecurityContext failed\");\n+            goto err;\n+        }\n","filename":"src\/java.security.jgss\/windows\/native\/libsspi_bridge\/sspi.cpp","additions":158,"deletions":148,"binary":false,"changes":306,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+static\n","filename":"src\/java.security.jgss\/windows\/native\/libw2k_lsa_auth\/NativeCreds.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1028,1 +1028,1 @@\n-        EXCEPTION_CHECK(\"Getting ParentWithRole - call to CallObjectMethod()\", (AccessibleContext)0);\n+        EXCEPTION_CHECK(\"Getting ParentWithRole - call to CallObjectMethod()\", reinterpret_cast<jobject>((AccessibleContext) 0));\n@@ -1098,1 +1098,1 @@\n-        EXCEPTION_CHECK(\"Getting ParentWithRoleElseRoot - call to CallObjectMethod()\", (AccessibleContext)0);\n+        EXCEPTION_CHECK(\"Getting ParentWithRoleElseRoot - call to CallObjectMethod()\", reinterpret_cast<jobject>((AccessibleContext) 0));\n@@ -1155,1 +1155,1 @@\n-        EXCEPTION_CHECK(\"Getting ActiveDescendent - call to CallObjectMethod()\", (AccessibleContext)0);\n+        EXCEPTION_CHECK(\"Getting ActiveDescendent - call to CallObjectMethod()\", reinterpret_cast<jobject>((AccessibleContext) 0));\n@@ -1164,1 +1164,1 @@\n-        return (AccessibleContext)0;\n+        return reinterpret_cast<jobject>((AccessibleContext) 0);\n","filename":"src\/jdk.accessibility\/windows\/native\/libjavaaccessbridge\/AccessBridgeJavaEntryPoints.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}