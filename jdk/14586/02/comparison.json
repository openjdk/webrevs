{"files":[{"patch":"@@ -868,0 +868,13 @@\n+                                                                            \\\n+  develop(bool, PrintLoopConditionalPropagation, false,                     \\\n+          \"Trace Loop Conditional Propagation pass\")                        \\\n+                                                                            \\\n+  product(bool, UseLoopConditionalPropagation, true,                        \\\n+          \"Perform Loop Conditional Propagation pass\")                      \\\n+                                                                            \\\n+  develop(bool, VerifyLoopConditionalPropagation, false,                    \\\n+          \"expensive Loop Conditional Propagation verification\")            \\\n+                                                                            \\\n+  product(bool, LoopConditionalPropagationALot, false,                      \\\n+          \"run Loop Conditional Propagation on every round of loop opts\")   \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -58,2 +58,4 @@\n-    if( !n ) continue;          \/\/ Missing inputs are TOP\n-    if( phase->type(n) == Type::CONTROL )\n+    if (n == nullptr) {\n+        continue;          \/\/ Missing inputs are TOP\n+    }\n+    if (phase->type(n, n) == Type::CONTROL) {\n@@ -61,0 +63,1 @@\n+    }\n@@ -1302,2 +1305,2 @@\n-    if (r->in(i) && phase->type(r->in(i)) == Type::CONTROL) {\n-      const Type* ti = phase->type(in(i));\n+    if (r->in(i) && phase->type(r->in(i), r->in(i)) == Type::CONTROL) {\n+      const Type* ti = phase->type(in(i), r->in(i));\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -449,1 +449,1 @@\n-  static const TypeInt* filtered_int_type(PhaseGVN* phase, Node* val, Node* if_proj);\n+  static const Type* filtered_int_type(PhaseValues* phase, Node* val, Node* if_proj, BasicType bt);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1080,0 +1080,1 @@\n+  set_run_loop_conditional_propagation(true);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -365,0 +365,2 @@\n+  bool                  _run_loop_conditional_propagation; \/\/ Switched off to prevent further runs of loop conditional propagation\n+\n@@ -645,0 +647,3 @@\n+  bool              run_loop_conditional_propagation() const           { return _run_loop_conditional_propagation; }\n+  void          set_run_loop_conditional_propagation(bool z)           { _run_loop_conditional_propagation = z; }\n+\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -655,1 +655,1 @@\n-const TypeInt* IfNode::filtered_int_type(PhaseGVN* gvn, Node* val, Node* if_proj) {\n+const Type* IfNode::filtered_int_type(PhaseValues* phase, Node* val, Node* if_proj, BasicType bt) {\n@@ -660,23 +660,23 @@\n-    if (iff->in(1) && iff->in(1)->is_Bool()) {\n-      BoolNode* bol = iff->in(1)->as_Bool();\n-      if (bol->in(1) && bol->in(1)->is_Cmp()) {\n-        const CmpNode* cmp  = bol->in(1)->as_Cmp();\n-        if (cmp->in(1) == val) {\n-          const TypeInt* cmp2_t = gvn->type(cmp->in(2))->isa_int();\n-          if (cmp2_t != nullptr) {\n-            jint lo = cmp2_t->_lo;\n-            jint hi = cmp2_t->_hi;\n-            BoolTest::mask msk = if_proj->Opcode() == Op_IfTrue ? bol->_test._test : bol->_test.negate();\n-            switch (msk) {\n-            case BoolTest::ne: {\n-              \/\/ If val is compared to its lower or upper bound, we can narrow the type\n-              const TypeInt* val_t = gvn->type(val)->isa_int();\n-              if (val_t != nullptr && !val_t->singleton() && cmp2_t->is_con()) {\n-                if (val_t->_lo == lo) {\n-                  return TypeInt::make(val_t->_lo + 1, val_t->_hi, val_t->_widen);\n-                } else if (val_t->_hi == hi) {\n-                  return TypeInt::make(val_t->_lo, val_t->_hi - 1, val_t->_widen);\n-                }\n-              }\n-              \/\/ Can't refine type\n-              return nullptr;\n+    if (iff->in(1)) {\n+      Node* iff1 = iff->in(1);\n+      if (iff->is_OuterStripMinedLoopEnd()) {\n+#ifdef ASSERT\n+        iff->as_OuterStripMinedLoopEnd()->inner_loop()->verify_strip_mined(1);\n+#endif\n+        assert(iff->in(0)->in(0)->in(0)->is_CountedLoopEnd(), \"bad strip mined loop shape\");\n+        \/\/ Exit condition of skeleton outer strip mined loop is exit condition of inner loop\n+        iff1 = iff->in(0)->in(0)->in(0)->in(1);\n+      }\n+      if (iff1->Opcode() == Op_OpaqueInitializedAssertionPredicate) {\n+        \/\/ Look at the actual condition\n+        iff1 = iff1->in(1);\n+      }\n+      if (iff1->is_Bool()) {\n+        bool taken = if_proj->Opcode() == Op_IfTrue;\n+        BoolNode* bol = iff1->as_Bool();\n+        if (bol->in(1) && bol->in(1)->is_Cmp()) {\n+          const CmpNode* cmp = bol->in(1)->as_Cmp();\n+          if (cmp->in(1) == val || cmp->in(2) == val) {\n+            const Type* other_t = phase->type(cmp->in(1) == val ? cmp->in(2) : cmp->in(1));\n+            if (other_t == Type::TOP) {\n+              return Type::TOP;\n@@ -684,6 +684,17 @@\n-            case BoolTest::eq:\n-              return cmp2_t;\n-            case BoolTest::lt:\n-              lo = TypeInt::INT->_lo;\n-              if (hi != min_jint) {\n-                hi = hi - 1;\n+            const TypeInteger* other_int_t = other_t->is_integer(bt);\n+            jlong lo = other_int_t->lo_as_long();\n+            jlong hi = other_int_t->hi_as_long();\n+            assert(hi >= lo, \"dead?\");\n+            BoolTest test = bol->_test;\n+            if (cmp->in(2) == val && cmp->in(1) != val) {\n+              test = test.commute();\n+            }\n+            BoolTest::mask msk = taken ? test._test : test.negate();\n+\n+            if (cmp->Opcode() == Op_Cmp_unsigned(bt)) {\n+              if (lo >= 0 && (msk == BoolTest::lt || msk == BoolTest::le)) {\n+                lo = 0;\n+                if (msk == BoolTest::lt) {\n+                  hi = hi - 1;\n+                }\n+                return TypeInteger::make(lo, hi, other_int_t->_widen, bt);\n@@ -691,7 +702,45 @@\n-              break;\n-            case BoolTest::le:\n-              lo = TypeInt::INT->_lo;\n-              break;\n-            case BoolTest::gt:\n-              if (lo != max_jint) {\n-                lo = lo + 1;\n+            } else {\n+              assert(cmp->Opcode() == Op_Cmp(bt), \"should be signed comparison\");\n+              switch (msk) {\n+                case BoolTest::ne: {\n+                  \/\/ If val is compared to its lower or upper bound, we can narrow the type\n+                  const TypeInteger* val_t = phase->type(val)->isa_integer(bt);\n+                  if (val_t != nullptr && other_int_t->is_con()) {\n+                    if (val_t->singleton()) {\n+                      if (val_t->lo_as_long() == lo) {\n+                        return Type::TOP;\n+                      }\n+                    } else {\n+                      if (val_t->lo_as_long() == lo) {\n+                        return TypeInteger::make(val_t->lo_as_long() + 1, val_t->hi_as_long(), val_t->_widen, bt);\n+                      } else if (val_t->hi_as_long() == hi) {\n+                        return TypeInteger::make(val_t->lo_as_long(), val_t->hi_as_long() - 1, val_t->_widen, bt);\n+                      }\n+                    }\n+                  }\n+                  \/\/ Can't refine type\n+                  return nullptr;\n+                }\n+                case BoolTest::eq:\n+                  return other_t;\n+                case BoolTest::lt:\n+                  lo = TypeInteger::bottom(bt)->lo_as_long();\n+                  if (hi != min_signed_integer(bt)) {\n+                    hi = hi - 1;\n+                  }\n+                  break;\n+                case BoolTest::le:\n+                  lo = TypeInteger::bottom(bt)->lo_as_long();\n+                  break;\n+                case BoolTest::gt:\n+                  if (lo != max_signed_integer(bt)) {\n+                    lo = lo + 1;\n+                  }\n+                  hi = TypeInteger::bottom(bt)->hi_as_long();\n+                  break;\n+                case BoolTest::ge:\n+                  \/\/ lo unchanged\n+                  hi = TypeInteger::bottom(bt)->hi_as_long();\n+                  break;\n+                default:\n+                  break;\n@@ -699,8 +748,1 @@\n-              hi = TypeInt::INT->_hi;\n-              break;\n-            case BoolTest::ge:\n-              \/\/ lo unchanged\n-              hi = TypeInt::INT->_hi;\n-              break;\n-            default:\n-              break;\n+              return TypeInteger::make(lo, hi, other_int_t->_widen, bt);\n@@ -708,2 +750,0 @@\n-            const TypeInt* rtn_t = TypeInt::make(lo, hi, cmp2_t->_widen);\n-            return rtn_t;\n@@ -909,2 +949,4 @@\n-  const TypeInt* lo_type = IfNode::filtered_int_type(igvn, n, otherproj);\n-  const TypeInt* hi_type = IfNode::filtered_int_type(igvn, n, success);\n+  const Type* t = IfNode::filtered_int_type(igvn, n, otherproj, T_INT);\n+  const TypeInt* lo_type = t != nullptr && t->isa_int() ? t->is_int() : nullptr;\n+  t = IfNode::filtered_int_type(igvn, n, success, T_INT);\n+  const TypeInt* hi_type = t != nullptr && t->isa_int() ? t->is_int() : nullptr;\n@@ -1045,1 +1087,1 @@\n-    const TypeInt* failtype = filtered_int_type(igvn, n, proj);\n+    const Type* failtype = filtered_int_type(igvn, n, proj, T_INT);\n@@ -1047,1 +1089,1 @@\n-      const TypeInt* type2 = filtered_int_type(igvn, n, fail);\n+      const Type* type2 = filtered_int_type(igvn, n, fail, T_INT);\n@@ -1049,6 +1091,8 @@\n-        failtype = failtype->join(type2)->is_int();\n-        if (failtype->empty()) {\n-          \/\/ previous if determines the result of this if so\n-          \/\/ replace Bool with constant\n-          igvn->replace_input_of(this, 1, igvn->intcon(success->_con));\n-          return true;\n+        failtype = failtype->join(type2);\n+        if (failtype->isa_int()) {\n+          if (failtype->empty()) {\n+            \/\/ previous if determines the result of this if so\n+            \/\/ replace Bool with constant\n+            igvn->replace_input_of(this, 1, igvn->intcon(success->_con));\n+            return true;\n+          }\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":101,"deletions":57,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -0,0 +1,1815 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+  The goal of this pass is to optimize redundant conditions such as\n+  the second one in:\n+\n+  if (i < 10) {\n+    if (i < 42) {\n+\n+  In the branch of the first if, the type of i can be narrowed down to\n+  [min_jint, 9] which can then be used to constant fold the second\n+  condition.\n+\n+  The compiler already keeps track of type[n] for every node in the\n+  current compilation unit. That's not sufficient to optimize the\n+  snippet above though because the type of i can only be narrowed in\n+  some section of the control flow (that is a subset of all\n+  controls). The solution is to build a new table that tracks the type\n+  of n at every control c\n+\n+  type'[n, root] = type[n] \/\/ initialized from igvn's type table\n+  type'[n, c] = type[n, idom(c)]\n+\n+  This pass start by iterating over the CFG looking for conditions such as:\n+\n+  if (i < 10) {\n+\n+  that allows narrowing the type of i and update the type' table\n+  accordingly.\n+\n+  At a region r:\n+\n+  type'[n, r] = meet(type'[n, r->in(1)], type'[n, r->in(2)]...)\n+\n+  For a Phi phi at a region r:\n+\n+  type'[phi, r] = meet(type'[phi->in(1), r->in(1)], type'[phi->in(2), r->in(2)]...)\n+\n+  Once a type is narrowed, uses are enqueued and their types are\n+  computed by calling the Value() methods. Value() methods retrieve\n+  types from the type table, not the type' table. To address that\n+  issue while leaving Value() methods unchanged, before calling\n+  Value() at c, the type table is updated so:\n+\n+  type[n] = type'[n, c]\n+\n+  An exception is for Phi::Value which needs to retrieve the type of\n+  nodes are various controls: there, a new type(Node* n, Node* c)\n+  method is used.\n+\n+  For most n and c, type'[n, c] is likely the same as type[n], the\n+  type recorded in the global igvn table (there shouldn't be many\n+  nodes at only a few control for which we can narrow the type\n+  down). As a consequence, the types'[n, c] table is implemented as:\n+\n+  - At c, narrowed down types are stored in a GrowableArray. Each\n+    entry records the previous type at idom(c) and the narrowed down\n+    type at c.\n+\n+  - The GrowableArray of type updates is recorded in a hash table\n+    indexed by c.\n+\n+  This pass operates in 2 steps:\n+\n+  - the Analyzer first iterates over the graph looking for conditions that\n+    narrow the types of some nodes and propagate type updates to uses\n+    until a fix point.\n+\n+  - the Transformer transforms the graph so newly found constant nodes are folded.\n+\n+*\/\n+\n+#include \"memory\/resourceArea.hpp\"\n+#include \"opto\/node.hpp\"\n+#include \"opto\/loopConditionalPropagation.hpp\"\n+#include \"opto\/callnode.hpp\"\n+#include \"opto\/castnode.hpp\"\n+#include \"opto\/movenode.hpp\"\n+#include \"opto\/predicates.hpp\"\n+#include \"opto\/opaquenode.hpp\"\n+#include \"opto\/loopConditionalPropagation.hpp\"\n+\n+#ifdef ASSERT\n+void PhaseConditionalPropagation::TypeTable::NodeTypesList::dump() const {\n+  tty->print(\"For iteration %d at control\", _iterations); _control->dump(\"\"); tty->print_cr(\" :\");\n+  for (int i = 0; i < _node_types.length(); i++) {\n+    tty->print(\"  \"); _node_types.at(i)._node->dump(\"\"); tty->print(\" \");\n+    _node_types.at(i)._before->dump();\n+    tty->print (\" -> \");\n+    _node_types.at(i)._after->dump();\n+    tty->cr();\n+  }\n+}\n+#endif\n+\n+PhaseConditionalPropagation::TypeTable::TypeTable(PhaseConditionalPropagation& conditional_propagation)\n+        : _node_types_list_table(nullptr),\n+          _conditional_propagation(conditional_propagation),\n+          _phase(conditional_propagation._phase) {\n+  _node_types_list_table = new NodeTypesListTable(8, _conditional_propagation._rpo_list.size());\n+}\n+\n+template<class Callback> bool PhaseConditionalPropagation::TypeTable::apply_between_controls_internal(Node* c, Node* dom, Callback callback) const {\n+  assert(_conditional_propagation.is_dominator(dom, c), \"dom should be the dominator\");\n+  NodeTypesList* node_types_list = node_types_list_at(c);\n+  NodeTypesList* dom_node_types_list = node_types_list_at(dom);\n+  \/\/ c inherits types from its dominators so if c has no types, dominator control must have none either unless c is in a\n+  \/\/ loop and dominator is above the loop: types at the loop head are the result of the merge of the entry and backedge\n+  \/\/ types. The backedge types are not yet computed so the result of the merge is empty.\n+  while (true) {\n+    assert(node_types_list != nullptr || dom_node_types_list == nullptr ||\n+           c->unique_ctrl_out()->is_Loop() ||\n+           _conditional_propagation.is_dominator(c->unique_ctrl_out(), c) ||\n+           _phase->C->has_irreducible_loop(), \"no types expected at dom ctrl if there's no type at current ctrl\");\n+    if (node_types_list == nullptr) {\n+      return false;\n+    }\n+    if (!node_types_list->below(dom_node_types_list, _conditional_propagation)) {\n+      return false;\n+    }\n+    if (callback(node_types_list)) {\n+      return true;\n+    }\n+    node_types_list = node_types_list->prev();\n+  }\n+  return false;\n+}\n+\n+const Type* PhaseConditionalPropagation::TypeTable::find_type_between(const Node* n, Node* c, Node* dom) const {\n+  const Type* res = nullptr;\n+  auto find_type = [&, n](NodeTypesList* node_types_list) {\n+    int l = node_types_list->find(n);\n+    if (l != -1) {\n+      res = node_types_list->type_at(l);\n+      return true;\n+    }\n+    return false;\n+  };\n+  apply_between_controls_internal(c, dom, find_type);\n+  return res;\n+}\n+\n+const Type* PhaseConditionalPropagation::TypeTable::find_prev_type_between(const Node* n, Node* c, Node* dom) const {\n+  const Type* res = nullptr;\n+  auto find_type = [&, n](NodeTypesList* node_types_list) {\n+      int l = node_types_list->find(n);\n+      if (l != -1) {\n+        res = node_types_list->prev_type_at(l);\n+      }\n+      return false;\n+  };\n+  apply_between_controls_internal(c, dom, find_type);\n+  return res;\n+}\n+\n+const Type* PhaseConditionalPropagation::TypeTable::type(Node* n, Node* c) const {\n+  NodeTypesList* node_types_list = node_types_list_at(c);\n+  if (node_types_list == nullptr || node_types_list->control() != c) {\n+    return nullptr;\n+  }\n+  return node_types_list->type_if_present(n);\n+}\n+\n+template <class Callback> void PhaseConditionalPropagation::TypeTable::apply_at_control(Node* c, Callback callback) const {\n+  NodeTypesList* node_types_list = node_types_list_at(c);\n+  if (node_types_list != nullptr && node_types_list->control() == c) {\n+    for (int i = 0; i < node_types_list->length(); i++) {\n+      Node* node = node_types_list->node_at(i);\n+      const Type* t = node_types_list->type_at(i);\n+      const Type* prev_t = node_types_list->prev_type_at(i);\n+      callback(node, t, prev_t);\n+    }\n+  }\n+}\n+\n+template <class Callback> void PhaseConditionalPropagation::TypeTable::apply_at_control_with_updates(Node* c, Callback callback) const {\n+  NodeTypesList* node_types_list = node_types_list_at(c);\n+  if (node_types_list != nullptr && node_types_list->control() == c) {\n+    for (int i = 0; i < node_types_list->length(); ) {\n+      Node* node = node_types_list->node_at(i);\n+      const Type* t = node_types_list->type_at(i);\n+      const Type* prev_t = node_types_list->prev_type_at(i);\n+      callback(node, t, prev_t);\n+      if (t == prev_t) {\n+        node_types_list->remove_at(i);\n+      } else {\n+        if (t != node_types_list->type_at(i)) {\n+          node_types_list->set_type_at(i, t);\n+        }\n+        if (prev_t != node_types_list->prev_type_at(i)) {\n+          node_types_list->set_prev_type_at(i, prev_t);\n+        }\n+        i++;\n+      }\n+    }\n+  }\n+}\n+\n+bool PhaseConditionalPropagation::TypeTable::has_types_at_control(Node* c) const {\n+  NodeTypesList* node_types_list = node_types_list_at(c);\n+  return node_types_list != nullptr && node_types_list->control() == c &&  node_types_list->length() > 0;\n+}\n+\n+\n+const Type* PhaseConditionalPropagation::WriteableTypeTable::type_at_current_ctrl(Node* n) const {\n+  const Type* n_t = nullptr;\n+  if (_current_node_types_list != nullptr) {\n+    n_t = _current_node_types_list->type_if_present(n);\n+  }\n+  return n_t;\n+}\n+\n+const Type* PhaseConditionalPropagation::WriteableTypeTable::prev_iteration_type(Node* n) const {\n+  if (_prev_node_types_list != nullptr) {\n+    return _prev_node_types_list->type_if_present(n);\n+  }\n+  return nullptr;\n+}\n+\n+const Type* PhaseConditionalPropagation::WriteableTypeTable::prev_iteration_type(Node* n, Node* c) const {\n+  if (_prev_node_types_list != nullptr && _prev_node_types_list->control() == c) {\n+    return _prev_node_types_list->type_if_present(n);\n+  }\n+  return nullptr;\n+}\n+\n+template <class Callback> void PhaseConditionalPropagation::WriteableTypeTable::apply_at_prev_iteration(Callback callback) const {\n+  if (_prev_node_types_list != nullptr) {\n+    for (int i = 0; i < _prev_node_types_list->length(); ++i) {\n+      Node* node = _prev_node_types_list->node_at(i);\n+      const Type* t = _prev_node_types_list->type_at(i);\n+      const Type* prev_t = _prev_node_types_list->prev_type_at(i);\n+      callback(node, t, prev_t);\n+    }\n+  }\n+}\n+\n+template <class Callback> void PhaseConditionalPropagation::WriteableTypeTable::apply_between_controls(Node* c, Node* dom, Callback callback) const {\n+  auto apply_callback = [&](NodeTypesList* node_types_list) {\n+      for (int i = 0; i < node_types_list->length(); ++i) {\n+        Node* node = node_types_list->node_at(i);\n+        const Type* t = node_types_list->type_at(i);\n+        const Type* prev_t = node_types_list->prev_type_at(i);\n+        callback(node, node_types_list->control(), t, prev_t);\n+      }\n+      return false;\n+  };\n+  apply_between_controls_internal(c, dom, apply_callback);\n+}\n+\n+int PhaseConditionalPropagation::WriteableTypeTable::count_updates_between_controls(Node* c, Node* dom) const {\n+  int cnt = 0;\n+  auto count_updates = [&](NodeTypesList* node_types_list) {\n+      cnt += node_types_list->length();\n+      return false;\n+  };\n+  apply_between_controls_internal(c, dom, count_updates);\n+  return cnt;\n+}\n+\n+void PhaseConditionalPropagation::WriteableTypeTable::set_current_control(Node* c, bool verify, int iterations) {\n+  Node* dom = _phase->idom(c);\n+  _current_node_types_list = node_types_list_at(c);\n+  _dom_node_types_list = node_types_list_at(dom);\n+  _prev_node_types_list = nullptr;\n+  \/\/ no types previously recorded at this control? inherit those (if any) from the dominator\n+  if (_current_node_types_list == nullptr) {\n+    _current_node_types_list = _dom_node_types_list;\n+    if (_current_node_types_list != nullptr) {\n+      _node_types_list_table->put(c, _current_node_types_list);\n+      _node_types_list_table->maybe_grow(load_factor);\n+    }\n+    return;\n+  }\n+  assert(iterations > 1, \"types already recorded only if there was a previous pass\");\n+  if (_current_node_types_list == _dom_node_types_list) {\n+    \/\/ no change\n+    return;\n+  }\n+  \/\/ On a previous iteration, we inherited some types from a dominating control but, now, dominator has some new types,\n+  \/\/ inherit those.\n+  if (_current_node_types_list->control() != c) {\n+    assert(_dom_node_types_list != nullptr, \"control have types if dominator doesn't\");\n+    _current_node_types_list = _dom_node_types_list;\n+    _node_types_list_table->put(c, _current_node_types_list);\n+    _node_types_list_table->maybe_grow(load_factor);\n+    return;\n+  }\n+  \/\/ On a previous iteration, we recorded some types at this control. Make a copy. The algorithm then works on that copy\n+  \/\/ and possibly makes some updates. Figuring whether progress happened is then done by comparing the types from the\n+  \/\/ previous iteration with the possibly updated copy.\n+  _prev_node_types_list = _current_node_types_list->copy();\n+  if ((_dom_node_types_list != nullptr && _dom_node_types_list->iterations() > _current_node_types_list->iterations()) || verify) {\n+    if (_dom_node_types_list != nullptr && _dom_node_types_list->iterations() > _current_node_types_list->iterations()) {\n+      assert(verify || _dom_node_types_list->iterations() == iterations, \"dom types should have been updated already\");\n+      _current_node_types_list->set_iterations(_dom_node_types_list->iterations());\n+    }\n+    assert(_dom_node_types_list == nullptr || !_conditional_propagation.is_dominator(_current_node_types_list->control(), _dom_node_types_list->control()),\n+           \"control for dominator types shouldn't be below control for current control's types\");\n+    _current_node_types_list->set_prev(_dom_node_types_list);\n+  }\n+}\n+\n+bool PhaseConditionalPropagation::WriteableTypeTable::record_type(Node* c, Node* n, const Type* prev_t,\n+                                                                  const Type* new_t, int iterations) {\n+  if (_current_node_types_list == _dom_node_types_list) {\n+    _current_node_types_list = new NodeTypesList(_dom_node_types_list, c, iterations);\n+    _node_types_list_table->put(c, _current_node_types_list);\n+    _node_types_list_table->maybe_grow(load_factor);\n+  }\n+  int i = _current_node_types_list->find(n);\n+  if (i == -1) {\n+    _current_node_types_list->push_node(n, prev_t, new_t);\n+    return true;\n+  }\n+  if (_current_node_types_list->type_at(i) != new_t) {\n+    \/\/ Update already recorded type\n+    const Type* old_t = _current_node_types_list->type_at(i);\n+    assert(narrows_type(old_t, new_t), \"new type should be narrower than old one\");\n+    _current_node_types_list->set_type_at(i, new_t);\n+    return true;\n+  }\n+  return false;\n+}\n+\n+\/\/ Have types improved at this control on this iteration?\n+bool PhaseConditionalPropagation::WriteableTypeTable::types_improved(Node* c, int iterations, bool verify) const {\n+  bool progress = false;\n+  if (_prev_node_types_list == nullptr) {\n+    if (_current_node_types_list != nullptr && _current_node_types_list->length() > 0 && _current_node_types_list->control() == c) {\n+      \/\/ Previous iteration (if there was one) didn't record any type but current one did\n+      progress = true;\n+    }\n+  } else {\n+    int j = 0;\n+    assert(_current_node_types_list->control() == c, \"we only track previous types at current control\");\n+    \/\/ Go over types for current and previous iterations and compare them\n+    for (int i = 0; i < _current_node_types_list->length(); ++i) {\n+      Node* n = _current_node_types_list->node_at(i);\n+      const Type* current_t = _current_node_types_list->type_at(i);\n+      \/\/ NodeTypesList is sorted by node _idx\n+      for (; j < _prev_node_types_list->length() && _prev_node_types_list->node_at(j)->_idx < n->_idx; j++) {\n+      }\n+      if (j < _prev_node_types_list->length() && _prev_node_types_list->node_at(j) == n) {\n+        const Type* prev_t = _prev_node_types_list->type_at(j);\n+        assert(prev_t == prev_iteration_type(n, c), \"cross check that we found the right type\");\n+        assert(narrows_type(prev_t, current_t), \"type at current iteration should narrow type at prev iteration\");\n+        if (prev_t != current_t) {\n+          \/\/ Some node has a type at the current and at the previous iteration and it's not the same: we made progress\n+          progress = true;\n+        }\n+        j++;\n+      } else {\n+        assert(_prev_node_types_list->find(n) == -1, \"cross check that n is missing from prev types\");\n+        assert(prev_iteration_type(n, c) == nullptr, \"cross check that n is missing from prev types\");\n+        \/\/ We recorded a new type\n+        if (current_t != _current_node_types_list->prev_type_at(i)) {\n+          \/\/ When verifying, nodes are enqueued eagerly. It's only progress then if the node whose type is updated is\n+          \/\/ used below the current control\n+          if (!verify || _conditional_propagation.is_dominator(_conditional_propagation.get_early_ctrl(n), c)) {\n+            progress = true;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  if (progress) {\n+    \/\/ There was progress at this iteration\n+    _current_node_types_list->set_iterations(iterations);\n+  }\n+  return progress;\n+}\n+\n+bool PhaseConditionalPropagation::WorkQueue::enqueue_for_delayed_processing(Node* n, Node* c) {\n+  assert(!n->is_Root(), \"Root should never be processed\");\n+  if (_enqueued.test_set(n->_idx)) {\n+    assert((*_work_queues->get(c))->contains(n), \"should already be enqueued\");\n+    return false;\n+  }\n+  assert(c != _current_ctrl, \"should be enqueued on _wq\");\n+  GrowableArray<Node*>** wq_ptr = _work_queues->get(c);\n+  GrowableArray<Node*>* wq = nullptr;\n+  if (wq_ptr != nullptr) {\n+    wq = *wq_ptr;\n+  } else {\n+    wq = new GrowableArray<Node*>();\n+    _work_queues->put(c, wq);\n+    _work_queues->maybe_grow(load_factor);\n+  }\n+  assert(!wq->contains(n), \"should be enqueued only once\");\n+  wq->push(n);\n+  return true;\n+}\n+\n+\/\/ Keep track of control of the main algorithm\n+void PhaseConditionalPropagation::WorkQueue::set_current_control(Node* c) {\n+  _current_ctrl = c;\n+  GrowableArray<Node*>* work_queue = work_queue_at(c);\n+  if (work_queue != nullptr) {\n+    while (!work_queue->is_empty()) {\n+      Node* n = work_queue->pop();\n+      _wq.push(n);\n+      assert(_enqueued.test(n->_idx), \"enqueued node should be marked\");\n+      _enqueued.remove(n->_idx);\n+    }\n+    _work_queues->remove(c);\n+  }\n+}\n+\n+bool PhaseConditionalPropagation::WorkQueue::enqueue(Node* n, Node* c) {\n+  if (c == _current_ctrl) {\n+    _wq.push(n);\n+    return false;\n+  }\n+  return enqueue_for_delayed_processing(n, c);\n+}\n+\n+#ifdef ASSERT\n+void PhaseConditionalPropagation::WorkQueue::dump() const {\n+  auto dump_entries = [&](Node* c, GrowableArray<Node*>* queue) {\n+    c->dump();\n+    for (int i = 0; i < queue->length(); i++) {\n+      Node* n = queue->at(i);\n+      n->dump();\n+    }\n+    return true;\n+  };\n+  _work_queues->iterate(dump_entries);\n+}\n+#endif\n+\n+\n+\/\/ Some node had its type narrowed at control c and u is a candidate for processing. At what control should it be\n+\/\/ enqueued?\n+Node* PhaseConditionalPropagation::Analyzer::compute_queue_control(Node* u) const {\n+  if (!_phase->has_node(u) || u->is_Root()) {\n+    return nullptr;\n+  }\n+  Node* u_c = _phase->find_non_split_ctrl(_phase->ctrl_or_self(u));\n+  \/\/ Always process Phi\/Region at their control\n+  if (u->is_Phi() || u->is_Region()) {\n+    assert(u_c == u->in(0), \"strange control\");\n+    return u_c;\n+  }\n+  if (_current_ctrl == u_c) {\n+    return _current_ctrl;\n+  }\n+  \/\/ A change of type at c cannot affect a CFG node that's not at a dominated control\n+  if (u->is_CFG()) {\n+    if (_conditional_propagation.is_dominator(_current_ctrl, u_c)) {\n+      return u_c;\n+    }\n+    return nullptr;\n+  }\n+  if (_conditional_propagation.is_dominator(_current_ctrl, u_c)) {\n+    \/\/ u's control is dominated by current control. Enqueue at early control so we keep track of the earliest control\n+    \/\/ at which its type can be narrowed\n+    u_c = _phase->find_non_split_ctrl(_conditional_propagation.get_early_ctrl(u));\n+    if (_conditional_propagation.is_dominator(_current_ctrl, u_c)) {\n+      return u_c;\n+    }\n+    return _current_ctrl;\n+  }\n+  \/\/ Process a data node whose control dominates the current control right away\n+  if (_conditional_propagation.is_dominator(u_c, _current_ctrl)) {\n+    return _current_ctrl;\n+  }\n+  \/\/ Type update at control c can't affect this node\n+  return nullptr;\n+}\n+\n+Node* PhaseConditionalPropagation::Analyzer::compute_queue_control(Node* u, bool at_current_ctrl) {\n+  Node* queue_control = compute_queue_control(u);\n+  if (at_current_ctrl && queue_control != _current_ctrl) {\n+    return nullptr;\n+  }\n+  return queue_control;\n+}\n+\n+void PhaseConditionalPropagation::Analyzer::enqueue_use(Node* n, Node* queue_control) {\n+  if (queue_control == nullptr) {\n+    return;\n+  }\n+  if (queue_control == _current_ctrl) {\n+    enqueue(n, _current_ctrl);\n+    return;\n+  }\n+  if (_verify) {\n+    \/\/ enqueue use early as a stress test\n+    if (n->is_Phi()) {\n+      if (n->in(0) == _current_ctrl) {\n+        enqueue(n, _current_ctrl);\n+        return;\n+      }\n+    } else if (n->is_Region()) {\n+      if (n == _current_ctrl) {\n+        enqueue(n, _current_ctrl);\n+        return;\n+      }\n+    } else if (n->is_CFG()) {\n+      enqueue(n, _current_ctrl);\n+    } else {\n+      if (n->in(0) == nullptr) {\n+        enqueue(n, _current_ctrl);\n+        return;\n+      }\n+      assert(n->in(0)->is_CFG(), \"control input of data node should be control node\");\n+      if (_conditional_propagation.is_dominator(n->in(0), _current_ctrl)) {\n+        enqueue(n, _current_ctrl);\n+        return;\n+      }\n+    }\n+  }\n+  enqueue(n, queue_control);\n+}\n+\n+void PhaseConditionalPropagation::Analyzer::enqueue_uses(const Node* n, bool at_current_ctrl) {\n+  assert(_phase->has_node(n), \"dead node?\");\n+  for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+    Node* u = n->fast_out(i);\n+    Node* queue_control = compute_queue_control(u, at_current_ctrl);\n+    if (queue_control == nullptr) {\n+      continue;\n+    }\n+    enqueue_use(u, queue_control);\n+    if (u->Opcode() == Op_AddI || u->Opcode() == Op_SubI) {\n+      for (DUIterator_Fast i2max, i2 = u->fast_outs(i2max); i2 < i2max; i2++) {\n+        Node* uu = u->fast_out(i2);\n+        if (uu->Opcode() == Op_CmpU) {\n+          enqueue_use(uu, compute_queue_control(uu, at_current_ctrl));\n+          if (_iterations > 1) {\n+            maybe_enqueue_if_projections_from_cmp(uu);\n+          }\n+        }\n+      }\n+    }\n+    if (u->is_AllocateArray()) {\n+      for (DUIterator_Fast i2max, i2 = u->fast_outs(i2max); i2 < i2max; i2++) {\n+        Node* uu = u->fast_out(i2);\n+        if (uu->is_Proj() && uu->as_Proj()->_con == TypeFunc::Control) {\n+          Node* catch_node = uu->find_out_with(Op_Catch);\n+          if (catch_node != nullptr) {\n+            assert(compute_queue_control(catch_node) != _current_ctrl, \"\");\n+            enqueue_use(catch_node, compute_queue_control(catch_node, at_current_ctrl));\n+          }\n+        }\n+      }\n+    }\n+    if (u->Opcode() == Op_OpaqueZeroTripGuard) {\n+      Node* cmp = u->unique_out();\n+      enqueue_use(cmp, compute_queue_control(cmp, at_current_ctrl));\n+      if (_iterations > 1) {\n+        maybe_enqueue_if_projections_from_cmp(cmp);\n+      }\n+    }\n+    if (u->is_Opaque1() && u->as_Opaque1()->original_loop_limit() == n) {\n+      for (DUIterator_Fast i2max, i2 = u->fast_outs(i2max); i2 < i2max; i2++) {\n+        Node* uu = u->fast_out(i2);\n+        if (uu->Opcode() == Op_CmpI || uu->Opcode() == Op_CmpL) {\n+          Node* phi = uu->as_Cmp()->countedloop_phi(u);\n+          if (phi != nullptr) {\n+            enqueue_use(phi, compute_queue_control(phi, at_current_ctrl));\n+          }\n+        }\n+      }\n+    }\n+    if (u->Opcode() == Op_CmpI || u->Opcode() == Op_CmpL) {\n+      Node* phi = u->as_Cmp()->countedloop_phi(n);\n+      if (phi != nullptr) {\n+        enqueue_use(phi, compute_queue_control(phi, at_current_ctrl));\n+      }\n+    }\n+\n+    if (_iterations > 1) {\n+      \/\/ If this node feeds into a condition that feeds into an If, mark the if as needing work (for iterations > 1)\n+      maybe_enqueue_if_projections_from_cmp(u);\n+\n+      if (u->Opcode() == Op_ConvL2I) {\n+        for (DUIterator_Fast jmax, j = u->fast_outs(jmax); j < jmax; j++) {\n+          Node* u2 = u->fast_out(j);\n+          maybe_enqueue_if_projections_from_cmp(u2);\n+        }\n+      }\n+    }\n+\n+    if (u->is_Region()) {\n+      for (DUIterator_Fast jmax, j = u->fast_outs(jmax); j < jmax; j++) {\n+        Node* uu = u->fast_out(j);\n+        if (uu->is_Phi()) {\n+          enqueue_use(uu, compute_queue_control(uu, at_current_ctrl));\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ The type of one of the inputs of a cmp was narrowed. We may be able to narrow the type of the other input further.\n+\/\/ Enqueue the if projections for processing\n+void PhaseConditionalPropagation::Analyzer::maybe_enqueue_if_projections_from_cmp(const Node* u) {\n+  if (!(u->Opcode() == Op_CmpI || u->Opcode() == Op_CmpL || u->Opcode() == Op_CmpU || u->Opcode() == Op_CmpUL)) {\n+    return;\n+  }\n+  for (DUIterator_Fast jmax, j = u->fast_outs(jmax); j < jmax; j++) {\n+    Node* u2 = u->fast_out(j);\n+    if (u2->is_Bool()) {\n+      for (DUIterator_Fast kmax, k = u2->fast_outs(kmax); k < kmax; k++) {\n+        Node* u3 = u2->fast_out(k);\n+        if (u3->is_If()) {\n+          maybe_enqueue_if_projections(u3->as_If());\n+        } else if (u3->Opcode() == Op_OpaqueInitializedAssertionPredicate) {\n+          for (DUIterator_Fast lmax, l = u3->fast_outs(lmax); l < lmax; l++) {\n+            Node* u4 = u3->fast_out(l);\n+            if (u4->is_If()) {\n+              maybe_enqueue_if_projections(u4->as_If());\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+void PhaseConditionalPropagation::Analyzer::maybe_enqueue_if_projections(IfNode* iff) {\n+  if (!_conditional_propagation.is_dominator(_current_ctrl, iff)) {\n+    return;\n+  }\n+  if (iff->is_CountedLoopEnd() && iff->as_CountedLoopEnd()->loopnode() != nullptr &&\n+      iff->as_CountedLoopEnd()->loopnode()->is_strip_mined()) {\n+    iff = iff->as_CountedLoopEnd()->loopnode()->outer_loop_end();\n+  }\n+  ProjNode* proj_false = iff->proj_out(0);\n+  ProjNode* proj_true = iff->proj_out(1);\n+  assert(!_visited.test(proj_false->_idx), \"already processed in this pass\");\n+  assert(!_visited.test(proj_true->_idx), \"already processed in this pass\");\n+  enqueue(proj_false, proj_false);\n+  enqueue(proj_true, proj_true);\n+}\n+\n+const PhaseConditionalPropagation::TypeTable* PhaseConditionalPropagation::Analyzer::analyze(int rounds) {\n+#ifdef ASSERT\n+  \/\/ The algorithm should need no more than 2 passes when the graph has no loop (one to narrow types, one to check for\n+  \/\/ no extra progress) or no more than 3 passes at most with loops (one to narrow types, one to propagate types at loop\n+  \/\/ heads, one to check for no extra progress).\n+  \/\/ However sometimes the type of a Phi at a Loop narrows slowly iteration after iteration (see PhaseValues::saturate)\n+  \/\/ so a few extra rounds might be needed. The following variable keeps track of that.\n+  int extra_rounds_loop_variable = 0;\n+  \/\/ Sometimes on entry to this optimization, for some nodes, a call to Value() would return a narrower type (because\n+  \/\/ some graph transformation in thi loop opts pass and Value hasn't been called yet). This can cause a few extra\n+  \/\/ rounds to be needed to reach a fix point. They are counted by the following variable.\n+  int extra_rounds_type_init = 0;\n+  bool has_infinite_loop = false;\n+#endif\n+  do {\n+    _iterations++;\n+    assert(_iterations - extra_rounds_loop_variable - extra_rounds_type_init >= 0, \"inconsistent number of iterations\");\n+    assert(_iterations - extra_rounds_type_init <= 2 || _phase->ltree_root()->_child != nullptr || has_infinite_loop, \"not converging?\");\n+    assert(_iterations - extra_rounds_loop_variable - extra_rounds_type_init <= 3 || _phase->_has_irreducible_loops, \"not converging?\");\n+    assert(_iterations < 100, \"not converging\");\n+\n+    bool extra_loop_variable = false;\n+    bool extra_type_init = false;\n+\n+#ifdef ASSERT\n+    _progress = false;\n+    _visited.clear();\n+#endif\n+\n+    if (_iterations == 1) {\n+      \/\/ Go over the entire cfg looking for conditions that allow type narrowing\n+      for (int i = _rpo_list.size() - 2; i >= 0; i--) {\n+        Node* c = _rpo_list.at(i);\n+        _current_ctrl = c;\n+        _work_queue->set_current_control(c);\n+        DEBUG_ONLY(has_infinite_loop = has_infinite_loop || (c->in(0)->Opcode() == Op_NeverBranch));\n+\n+        merge_with_dominator_types();\n+#ifdef ASSERT\n+        _visited.set(c->_idx);\n+#endif\n+        one_iteration(extra_loop_variable, extra_type_init);\n+      }\n+    } else {\n+      \/\/ Another pass of the entire cfg but this time, only process those controls that were marked at previous iteration\n+      for (int i = _rpo_list.size() - 2; i >= 0; i--) {\n+        Node* c = _rpo_list.at(i);\n+        _current_ctrl = c;\n+        _work_queue->set_current_control(c);\n+#ifdef ASSERT\n+        _visited.set(c->_idx);\n+#endif\n+        \/\/ If we recorded a narrowed type at this control for a node n on a previous pass and on this pass, we narrowed\n+        \/\/ the type of n at some dominating control, we need to merge the 2 updates.\n+        merge_with_dominator_types();\n+        \/\/ Was control marked as needing work?\n+        if (!_work_queue->is_empty(c)) {\n+          one_iteration(extra_loop_variable, extra_type_init);\n+        } else {\n+          if (c->is_Region()) {\n+            uint j;\n+            for (j = 1; j < c->req(); ++j) {\n+              Node* in = _conditional_propagation.known_updates(c->in(j));\n+              if (_type_table->iterations_at(in) == _iterations) {\n+                break;\n+              }\n+            }\n+            if (j < c->req()) {\n+              \/\/ Process region because there was some update along some of the CFG inputs\n+              one_iteration(extra_loop_variable, extra_type_init);\n+            }\n+          }\n+        }\n+      }\n+    }\n+#ifdef ASSERT\n+    if (extra_loop_variable) {\n+      extra_rounds_loop_variable++;\n+    } else if (extra_type_init) {\n+      extra_rounds_type_init++;\n+    }\n+#endif\n+    rounds--;\n+    if (rounds <= 0) {\n+      break;\n+    }\n+#ifdef ASSERT\n+    if (!_progress && !_work_queue->all_empty()) {\n+      _work_queue->dump();\n+    }\n+#endif\n+    assert(_progress == !_work_queue->all_empty(), \"\");\n+  } while (!_work_queue->all_empty());\n+\n+#ifdef ASSERT\n+  if (!_work_queue->all_empty()) {\n+    _work_queue->dump();\n+    fatal(\"work queue is not empty\");\n+  }\n+#endif\n+\n+#ifdef ASSERT\n+  if (VerifyLoopConditionalPropagation) {\n+    _verify = true;\n+    \/\/ Verify we've indeed reached a fixed point\n+    _iterations++;\n+    bool extra_loop_variable = false;\n+    bool extra_type_init = false;\n+    _visited.clear();\n+    for (int i = _rpo_list.size() - 2; i >= 0; i--) {\n+      Node* c = _rpo_list.at(i);\n+      _current_ctrl = c;\n+      _work_queue->set_current_control(c);\n+\n+      merge_with_dominator_types();\n+      bool progress = one_iteration(extra_loop_variable, extra_type_init);\n+      if (extra_type_init) {\n+        break;\n+      }\n+      assert(!progress, \"didn't reach a fix point\");\n+    }\n+    assert(extra_type_init || verify_wq_empty(), \"verification fails\");\n+  }\n+#endif\n+\n+  sync_global_types_with_types_at_control(_phase->C->root());\n+  return _type_table;\n+}\n+\n+bool PhaseConditionalPropagation::Analyzer::one_iteration(bool &extra_loop_variable, bool &extra_type_init) {\n+  Node* dom = _phase->idom(_current_ctrl);\n+\n+  if (_current_ctrl->is_Region()) {\n+    handle_region(dom, extra_loop_variable);\n+  } else if (_current_ctrl->is_IfProj()) {\n+    handle_ifproj();\n+  } else if (_current_ctrl->is_CatchProj() && _current_ctrl->in(0)->in(0)->in(0)->is_AllocateArray() &&\n+             _current_ctrl->as_CatchProj()->_con == CatchProjNode::fall_through_index) {\n+    \/\/ If the allocation succeeds, length is > 0 and less than max supported size\n+    AllocateArrayNode* alloc = _current_ctrl->in(0)->in(0)->in(0)->as_AllocateArray();\n+    sync_global_types_with_types_at_control(dom);\n+    analyze_allocate_array(alloc);\n+  }\n+\n+  propagate_types(extra_loop_variable);\n+\n+  if (VerifyLoopConditionalPropagation) {\n+    verify(extra_type_init);\n+  }\n+  return _type_table->types_improved(_current_ctrl, _iterations, _verify);\n+}\n+\n+void PhaseConditionalPropagation::Analyzer::propagate_types(bool &extra_type_init) {\n+  if (_work_queue->is_empty(_current_ctrl)) {\n+    return;\n+  }\n+  sync_global_types_with_types_at_control(_current_ctrl);\n+  while (!_work_queue->is_empty(_current_ctrl)) {\n+    Node* n = _work_queue->pop(_current_ctrl);\n+    assert(_verify || !n->is_CFG() || _conditional_propagation.is_dominator(_phase->find_non_split_ctrl(_phase->ctrl_or_self(n)), _current_ctrl),\n+           \"only CFG nodes that dominate current control\");\n+    const Type* t = n->Value(this);\n+    const Type* current_type = PhaseValues::type(n);\n+    if (n->is_Phi() && _iterations > 1) {\n+      t = current_type->filter(t);\n+      const Type* prev_type = _type_table->prev_iteration_type(n);\n+      if (prev_type != nullptr) {\n+        const Type* prev_t = t;\n+        t = prev_type->filter(t);\n+        assert(t == prev_t, \"current type should be narrower than prev type\");\n+        if (!(n->in(0)->is_CountedLoop() &&\n+              n->in(0)->as_CountedLoop()->phi() == n &&\n+              PhaseValues::type(n->in(0)->in(LoopNode::EntryControl)) != Type::TOP &&\n+              PhaseValues::type(n->in(LoopNode::EntryControl)) != Type::TOP)) {\n+          t = saturate(t, prev_type, nullptr);\n+        }\n+      }\n+      if (_current_ctrl->is_Loop() && t != prev_type) {\n+        extra_type_init = true;\n+      }\n+    }\n+    t = current_type->filter(t);\n+    if (t != current_type) {\n+#ifdef ASSERT\n+      assert(narrows_type(current_type, t), \"new type should be narrower\");\n+#endif\n+      set_type(n, t, current_type);\n+      enqueue_uses(n);\n+    }\n+  }\n+}\n+\n+void PhaseConditionalPropagation::Analyzer::handle_ifproj() {\n+  IfNode* iff = _current_ctrl->in(0)->as_If();\n+  if (!(iff->is_CountedLoopEnd() && iff->as_CountedLoopEnd()->loopnode() != nullptr &&\n+        iff->as_CountedLoopEnd()->loopnode()->is_strip_mined())) {\n+    Node* bol = iff->in(1);\n+    if (iff->is_OuterStripMinedLoopEnd()) {\n+      assert(iff->in(0)->in(0)->in(0)->is_CountedLoopEnd(), \"broken strip mined loop\");\n+      bol = iff->in(0)->in(0)->in(0)->in(1);\n+    }\n+    if (bol->Opcode() == Op_OpaqueInitializedAssertionPredicate) {\n+      bol = bol->in(1);\n+    }\n+    if (bol->is_Bool()) {\n+      Node* cmp = bol->in(1);\n+      if (cmp->Opcode() == Op_CmpI || cmp->Opcode() == Op_CmpU ||\n+          cmp->Opcode() == Op_CmpL || cmp->Opcode() == Op_CmpUL) {\n+        Node* cmp1 = cmp->in(1);\n+        Node* cmp2 = cmp->in(2);\n+        \/\/ skip counted loop exit condition as limits can be updated later on by unrolling, RC elimination\n+        if (_current_ctrl->is_IfFalse()) {\n+          CountedLoopNode* loop = nullptr;\n+          if (iff->is_CountedLoopEnd()) {\n+            loop = iff->as_CountedLoopEnd()->loopnode();\n+          } else if (iff->is_OuterStripMinedLoopEnd()) {\n+            loop = iff->as_OuterStripMinedLoopEnd()->inner_loop();\n+          }\n+          if (loop != nullptr && loop->incr() == cmp1) {\n+            return;\n+          }\n+        }\n+\n+        sync_global_types_with_types_at_control(iff);\n+        analyze_if(cmp, cmp1);\n+        analyze_if(cmp, cmp2);\n+      }\n+    }\n+  }\n+}\n+\n+void PhaseConditionalPropagation::Analyzer::handle_region(Node* dom, bool &extra_loop_variable) {\n+  \/\/ Look for nodes whose types are narrowed between this region and the dominator control on all region's inputs\n+  \/\/ First find the region's input that has the smallest number of type updates to keep work as low as possible\n+  uint in_idx = 1;\n+  int num_types = max_jint;\n+  for (uint i = 1; i < _current_ctrl->req(); ++i) {\n+    Node* in = _current_ctrl->in(i);\n+    int cnt = _type_table->count_updates_between_controls(in, dom);\n+    if (cnt < num_types) {\n+      in_idx = i;\n+      num_types = cnt;\n+    }\n+  }\n+  Node* in = _current_ctrl->in(in_idx);\n+  auto improve_type = [&](Node* n, Node* ignored_c, const Type* ignored_t, const Type* ignored_prev_t) {\n+      const Type* t = _type_table->find_type_between(n, in, dom);\n+      \/\/ and check if the type was updated from other region inputs\n+      uint k = 1;\n+      for (; k < _current_ctrl->req(); k++) {\n+        if (k == in_idx) {\n+          continue;\n+        }\n+        Node* other_in = _current_ctrl->in(k);\n+        const Type* type_at_in = _type_table->find_type_between(n, other_in, dom);\n+        if (type_at_in == nullptr) {\n+          break;\n+        }\n+        t = t->meet_speculative(type_at_in);\n+      }\n+      \/\/ If that's the case, record type update\n+      if (k == _current_ctrl->req()) {\n+        const Type* dom_type = _type_table->find_prev_type_between(n, in, dom);\n+\n+        assert(t == t->filter(dom_type), \"\");\n+        if (_iterations > 1) {\n+          t = dom_type->filter(t); \/\/ for consistency with merge_with_dominator_types()\n+          const Type* prev_t = t;\n+          const Type* prev_round_t = _type_table->prev_iteration_type(n, _current_ctrl);\n+          if (prev_round_t == nullptr && _iterations > 2) {\n+            \/\/ we may have lost the prev type if it was recorded at least 2 iterations before. Use dominator type\n+            \/\/ conservatively:\n+            \/\/ iteration i: type of n narrowed at c\n+            \/\/ iteration i+1: type of n narrowed at c, prev type from iteration i factored it\n+            \/\/ iteration i+2: dominator type of n narrowed down for some reason, type of n at c removed because redundant\n+            \/\/ iteration i+3: type of n narrowed at c, no prev type from iteration i+2 at c\n+            prev_round_t = dom_type;\n+          }\n+          if (prev_round_t != nullptr) {\n+            t = prev_round_t->filter(t);\n+            assert(t == prev_t, \"new type should be narrower than previous round type\");\n+            t = saturate(t, prev_round_t, nullptr);\n+            if (_current_ctrl->is_Loop() && t != prev_round_t) {\n+              extra_loop_variable = true;\n+            }\n+          }\n+          t = dom_type->filter(t);\n+        } else {\n+          assert(t == t->filter(dom_type), \"\");\n+          t = dom_type->filter(t);\n+        }\n+\n+        if (t != dom_type) {\n+          assert(narrows_type(dom_type, t), \"new type should be narrower\");\n+          if (_type_table->record_type(_current_ctrl, n, dom_type, t, _iterations) || _verify) {\n+            enqueue_uses(n);\n+          }\n+        }\n+      }\n+  };\n+  _type_table->apply_between_controls(in, dom, improve_type);\n+}\n+\n+void PhaseConditionalPropagation::Analyzer::analyze_allocate_array(const AllocateArrayNode* alloc) {\n+  Node* length = alloc->in(AllocateArrayNode::ALength);\n+  Node* klass = alloc->in(AllocateNode::KlassNode);\n+  const Type* klass_t = PhaseValues::type(klass);\n+  if (klass_t != Type::TOP) {\n+    const TypeOopPtr* ary_type = klass_t->is_klassptr()->as_instance_type();\n+    const TypeInt* length_type = PhaseValues::type(length)->isa_int();\n+    if (ary_type->isa_aryptr() && length_type != nullptr) {\n+      const Type* narrow_length_type = ary_type->is_aryptr()->narrow_size_type(length_type);\n+      narrow_length_type = length_type->filter(narrow_length_type);\n+      assert(narrows_type(length_type, narrow_length_type), \"new type should be narrower\");\n+      if (narrow_length_type != length_type) {\n+        if (_type_table->record_type(_current_ctrl, length, length_type, narrow_length_type, _iterations) || _verify) {\n+          enqueue_uses(length);\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+void PhaseConditionalPropagation::Analyzer::analyze_if(const Node* cmp, Node* n) {\n+  const Type* t = IfNode::filtered_int_type(this, n, _current_ctrl, (cmp->Opcode() == Op_CmpI || cmp->Opcode() == Op_CmpU) ? T_INT : T_LONG);\n+  if (t != nullptr) {\n+    const Type* n_t = type_at_current_ctrl(n);\n+    const Type* new_n_t = n_t->filter(t);\n+    assert(narrows_type(n_t, new_n_t), \"new type should be narrower\");\n+    if (n_t != new_n_t) {\n+      assert(narrows_type(n_t, new_n_t, true), \"\");\n+#ifdef ASSERT\n+      _conditional_propagation.record_condition(_current_ctrl);\n+#endif\n+      if (_type_table->record_type(_current_ctrl, n, n_t, new_n_t, _iterations) || _verify) {\n+        enqueue_uses(n);\n+      }\n+    }\n+    if (n->Opcode() == Op_ConvL2I) {\n+      Node* in = n->in(1);\n+      const Type* in_t = PhaseValues::type(in);\n+\n+      if (in_t->isa_long() && in_t->is_long()->_lo >= min_jint && in_t->is_long()->_hi <= max_jint) {\n+        const Type* t_as_long = t->isa_int()\n+                                  ? TypeLong::make(t->is_int()->_lo, t->is_int()->_hi, t->is_int()->_widen)\n+                                  : Type::TOP;\n+        const Type* new_in_t = in_t->filter(t_as_long);\n+        assert(narrows_type(in_t, new_in_t), \"new type should be narrower\");\n+        if (in_t != new_in_t) {\n+#ifdef ASSERT\n+          _conditional_propagation.record_condition(_current_ctrl);\n+#endif\n+          if (_type_table->record_type(_current_ctrl, in, in_t, new_in_t, _iterations) || _verify) {\n+            enqueue_uses(in);\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+void PhaseConditionalPropagation::Analyzer::enqueue(Node* n, Node* c) {\n+  if (_work_queue->enqueue(n, c)) {\n+#ifdef ASSERT\n+    maybe_set_progress(n, c);\n+#endif\n+  }\n+}\n+\n+\/\/ Global type table's content is in sync with types at _current_types_ctrl. We want type of n at some other control c\n+const Type* PhaseConditionalPropagation::Analyzer::type(const Node* n, Node* c) const {\n+  if (_current_types_ctrl == _phase->C->root()) {\n+    const Type* res = PhaseValues::type(n);\n+    return res;\n+  }\n+  Node* lca = _phase->dom_lca_internal(_current_types_ctrl, c);\n+  \/\/ find last update between lca and c\n+  const Type* res = _type_table->find_type_between(n, c, lca);\n+  if (res != nullptr) {\n+    return res;\n+  }\n+  \/\/ if none, find before type of first update between current control and lca\n+  res = _type_table->find_prev_type_between(n, _current_types_ctrl, lca);\n+  if (res != nullptr) {\n+    return res;\n+  }\n+  \/\/ if none, go with the type at _current_types_ctrl\n+  res = PhaseValues::type(n);\n+  return res;\n+}\n+\n+void PhaseConditionalPropagation::Analyzer::merge_with_dominator_types() {\n+  _type_table->set_current_control(_current_ctrl, verify(), _iterations);\n+  if (!_verify && (_iterations == 1 || !_type_table->has_types_at_control(_current_ctrl))) {\n+    return;\n+  }\n+  Node* dom = _phase->idom(_current_ctrl);\n+  if (!_verify && (_type_table->iterations_at(dom) != _iterations)) {\n+    \/\/ no updates to types at dom in this iteration\n+    return;\n+  }\n+  sync_global_types_with_types_at_control(dom);\n+  auto merge_types = [&](Node* node, const Type*& t, const Type*& prev_t) {\n+      const Type* dom_t = PhaseValues::type(node);\n+      const Type* new_t = dom_t->filter(t);\n+      \/\/ Updates at this control at a previous iteration combined with updates at a dominating control at the current\n+      \/\/ iteration could allow some progress to be made.\n+      \/\/ For instance: c = a + b\n+      \/\/ on iteration i, a's type is updated at control c\n+      \/\/ on iteration j (j > i), b's type is updated at some control dominating c\n+      \/\/ when we process control c at j, we should enqueue c for processing because narrowed type of a and b could lead\n+      \/\/ to a narrowed type for c\n+      enqueue_uses(node, true);\n+      if (new_t == dom_t) {\n+#ifdef ASSERT\n+        \/\/ During verification types can be narrowed at control dominating early control for the node. We have reached\n+        \/\/ the early control for the node, merging with dominating control results in the type before verification.\n+        if (verify() && _verify_wq.member(node) &&\n+            _phase->find_non_split_ctrl(_conditional_propagation.get_early_ctrl(node)) == _current_ctrl &&\n+            _type_table->prev_iteration_type(node, _current_ctrl) == new_t) {\n+          _verify_wq.remove(node);\n+        }\n+#endif\n+        enqueue_uses(node);\n+      } else {\n+        if (new_t != t) {\n+          assert(!verify(), \"should have reached fixed point\");\n+          enqueue_uses(node);\n+        }\n+      }\n+      prev_t = dom_t;\n+      t = new_t;\n+  };\n+  _type_table->apply_at_control_with_updates(_current_ctrl, merge_types);\n+}\n+\n+\/\/ PhaseValues::_types is in sync with types at _current_types_ctrl, we want to update it to be in sync with types at c\n+void PhaseConditionalPropagation::Analyzer::sync_global_types_with_types_at_control(Node* c) {\n+  Node* lca = _phase->dom_lca_internal(_current_types_ctrl, c);\n+  \/\/ Update PhaseValues::_types to lca by undoing every update between _current_ctrl and lca\n+  auto sync_type_up = [&](Node* n, Node* c, const Type* ignored_t, const Type* prev_t) {\n+      PhaseValues::set_type(n, prev_t);\n+  };\n+  _type_table->apply_between_controls(_current_types_ctrl, lca, sync_type_up);\n+\n+  \/\/ Update PhaseValues::_types to c by applying every update between lca and c\n+  auto sync_type_down = [&](Node* n, Node* c, const Type* t, const Type* ignored_prev_t) {\n+      _stack.push({ n, t} );\n+  };\n+  _type_table->apply_between_controls(c, lca, sync_type_down);\n+\n+  while (!_stack.is_empty()) {\n+    NodeTypePair node_type = _stack.pop();\n+    PhaseValues::set_type(node_type._n, node_type._t);\n+  }\n+\n+  _current_types_ctrl = c;\n+}\n+\n+#ifdef ASSERT\n+void PhaseConditionalPropagation::Analyzer::verify(bool& extra_type_init) {\n+  Node* dom = _phase->idom(_current_ctrl);\n+  sync_global_types_with_types_at_control(dom);\n+\n+  auto verify_current = [&](Node* node, const Type* t, const Type* prev_t) {\n+      assert(prev_t != t, \"should have recorded a type change\");\n+      assert(prev_t == PhaseValues::type(node), \"prev should be type at dom\");\n+      assert(narrows_type(PhaseValues::type(node), t), \"only type narrowing\");\n+      const Type* prev_round_t = _type_table->prev_iteration_type(node, _current_ctrl);\n+      assert(prev_round_t == nullptr || narrows_type(prev_round_t, t), \"should narrow from one round to the other\");\n+      assert(!verify() || !_conditional_propagation.is_dominator(_conditional_propagation.get_early_ctrl(node), _current_ctrl) ||\n+             prev_round_t == t, \"there should be no more progress once we've reached verification\");\n+      \/\/ When verify() is true, prev round type is expected to be the final type\n+      if (prev_round_t != nullptr) {\n+        \/\/ Types at this round and at previous round are the same: verification doesn't find a narrower type so previous\n+        \/\/ pass did reach the best type for this node at this control. No need to track the node further.\n+        if (prev_round_t == t && verify() && _verify_wq.member(node) &&\n+            _phase->find_non_split_ctrl(_conditional_propagation.get_early_ctrl(node)) == _current_ctrl) {\n+          _verify_wq.remove(node);\n+        }\n+      } else {\n+        \/\/ When verifying, nodes are enqueued for processing immediately (rather than at their early control), so new\n+        \/\/ types can be recorded at an earlier control than in previous passes. We keep track of them here.\n+        if (verify() &&\n+            !_conditional_propagation.is_dominator(_conditional_propagation.get_early_ctrl(node), _current_ctrl)) {\n+          _verify_wq.push(node);\n+        }\n+      }\n+  };\n+  _type_table->apply_at_control(_current_ctrl, verify_current);\n+  sync_global_types_with_types_at_control(_current_ctrl);\n+  auto verify_prev = [&](Node* node, const Type* t, const Type* prev_t) {\n+      const Type* current_round_t = _type_table->type(node, _current_ctrl);\n+      assert(current_round_t == nullptr || narrows_type(t, current_round_t),\n+             \"should narrow from one round to the other\");\n+      assert(!verify() || t == PhaseValues::type(node), \"\");\n+  };\n+  _type_table->apply_at_prev_iteration(verify_prev);\n+\n+  sync_global_types_with_types_at_control(_phase->C->root());\n+  auto verify_current2 = [&](Node* node, const Type* t, const Type* prev_t) {\n+      if (PhaseValues::type(node) != node->Value(this) &&\n+          prev_t == PhaseValues::type(node)) {\n+        if (t == PhaseValues::type(node)->filter(node->Value(this))) {\n+          extra_type_init = true;\n+        } else if (node->is_Phi() && _current_ctrl->is_Loop() && _type_table->type(node->in(LoopNode::LoopBackControl), _current_ctrl) != nullptr) {\n+          assert(narrows_type(PhaseValues::type(node)->filter(node->Value(this)), t), \"\");\n+          extra_type_init = true;\n+        }\n+      }\n+  };\n+  _type_table->apply_at_control(_current_ctrl, verify_current2);\n+}\n+\n+#endif\n+\n+const Type* PhaseConditionalPropagation::Analyzer::type_at_current_ctrl(Node* n) const {\n+  assert(_current_types_ctrl == _phase->idom(_current_ctrl), \"logic assumes PhaseValues::type() returns type at dominator\");\n+  const Type* n_t = _type_table->type_at_current_ctrl(n);\n+  if (n_t == nullptr) {\n+    n_t = PhaseValues::type(n);\n+  }\n+  return n_t;\n+}\n+\n+ProjNode* PhaseConditionalPropagation::Transformer::always_taken_if_proj(IfNode* iff) {\n+  assert(!iff->in(0)->is_top(), \"\");\n+  Node* bol = iff->in(1);\n+  const TypeInt* bol_t = bol->bottom_type()->is_int();\n+  if (bol->Opcode() == Op_OpaqueInitializedAssertionPredicate) {\n+    bol_t = TypeInt::ONE;\n+  }\n+  if (bol_t->is_con()) {\n+    return iff->proj_out(bol_t->get_con());\n+  }\n+  return nullptr;\n+}\n+\n+\/\/ Transform the graph: constant fold subgraphs that were found constant by the Analyzer\n+void PhaseConditionalPropagation::Transformer::do_transform() {\n+  _controls.push(_phase->C->root());\n+  for (uint i = 0; i < _controls.size(); i++) {\n+    Node* c = _controls.at(i);\n+\n+    if (c->is_CatchProj() && c->in(0)->in(0)->in(0)->is_AllocateArray()) {\n+      const Type* t = _type_table->find_type_between(c, c, _phase->C->root());\n+      if (t == Type::TOP) {\n+        _phase->igvn().replace_node(c, _phase->C->top());\n+        _phase->C->set_major_progress();\n+        continue;\n+      }\n+    }\n+\n+    assert(c->_idx >= _unique || _type_table->find_type_between(c, c, _phase->C->root()) != Type::TOP,\n+           \"for If we don't follow dead projections\");\n+    transform_helper(c);\n+\n+    if (c->is_If()) {\n+      IfNode* iff = c->as_If();\n+      Node* always_taken_proj = always_taken_if_proj(iff);\n+      if (always_taken_proj != nullptr) {\n+        assert(_type_table->type(always_taken_proj, always_taken_proj) != Type::TOP, \"should not be dead\");\n+        _controls.push(always_taken_proj);\n+        continue;\n+      }\n+    } else if (c->is_IfProj()) {\n+      IfNode* iff = c->in(0)->as_If();\n+      if (iff->in(0)->is_top()) {\n+        continue;\n+      }\n+      Node* always_taken_proj = always_taken_if_proj(iff);\n+      if (always_taken_proj != nullptr && always_taken_proj != c) {\n+        continue;\n+      }\n+    }\n+\n+    for (DUIterator i = c->outs(); c->has_out(i); i++) {\n+      Node* u = c->out(i);\n+      if (u->is_CFG()) {\n+        _controls.push(u);\n+      }\n+    }\n+  }\n+}\n+\n+bool PhaseConditionalPropagation::Transformer::related_node(Node* n, Node* c) {\n+  assert(_wq.size() == 0, \"need to start from an empty work list\");\n+  _wq.push(n);\n+  for (uint i = 0; i < _wq.size(); i++) {\n+    Node* node = _wq.at(i);\n+    assert(!node->is_CFG(), \"only following data nodes\");\n+    for (DUIterator_Fast jmax, j = node->fast_outs(jmax); j < jmax; j++) {\n+      Node* u = node->fast_out(j);\n+      if (!_phase->has_node(u)) {\n+        continue;\n+      }\n+      if (u->is_CFG()) {\n+        if (_conditional_propagation.is_dominator(u, c) || _conditional_propagation.is_dominator(c, u)) {\n+          _wq.clear();\n+          return true;\n+        }\n+      } else if (u->is_Phi()) {\n+        for (uint k = 1; k < u->req(); k++) {\n+          if (u->in(k) == node && !u->in(0)->in(k)->is_top() &&\n+              (_conditional_propagation.is_dominator(u->in(0)->in(k), c) || _conditional_propagation.is_dominator(c, u->in(0)->in(k)))) {\n+            _wq.clear();\n+            return true;\n+          }\n+        }\n+      } else {\n+        _wq.push(u);\n+      }\n+    }\n+  }\n+  _wq.clear();\n+  return false;\n+}\n+\n+bool PhaseConditionalPropagation::Transformer::is_safe_for_replacement(Node* c, Node* node, Node* use) const {\n+  \/\/ if the exit test of a counted loop doesn't constant fold, preserve the shape of the exit test\n+  Node* node_c = _phase->get_ctrl(node);\n+  IdealLoopTree* loop = _phase->get_loop(node_c);\n+  Node* head = loop->_head;\n+  if (head->is_BaseCountedLoop()) {\n+    BaseCountedLoopNode* cl = head->as_BaseCountedLoop();\n+    if (cl->is_valid_counted_loop(cl->bt())) {\n+      Node* cmp = cl->loopexit()->cmp_node();\n+      if (((node == cl->phi() && use == cl->incr()) ||\n+           (node == cl->incr() && use == cmp))) {\n+        const Type* cmp_t = _type_table->find_type_between(cmp, cl->loopexit(), _phase->idom(c));\n+        if (cmp_t == nullptr || !cmp_t->singleton()) {\n+          return false;\n+        }\n+      }\n+    }\n+  }\n+  if (use->is_CallStaticJava() && use->as_CallStaticJava()->is_uncommon_trap()) {\n+    \/\/ Constant folding at uncommon traps can go wrong:\n+    \/\/\n+    \/\/ if (0 >=u array.length) {  \/\/ range check from array[0]\n+    \/\/   uncommon_trap(); \/\/ array.length constant folded as 0 here\n+    \/\/ }\n+    \/\/ ..\n+    \/\/ if (1 >=u array.length) {  \/\/ range check from array[1]\n+    \/\/   uncommon_trap();\n+    \/\/ }\n+    \/\/ transformed by RC smearing into:\n+    \/\/ if (1 >=u array.length) {\n+    \/\/   uncommon_trap(); \/\/ array.length constant folded as 0 here but could actually be 1\n+    \/\/ }\n+    \/\/ ..\n+    return false;\n+  }\n+  return true;\n+}\n+\n+\/*\n+ With the following code snippet:\n+ if (i - 1) > 0) {\n+    \/\/ i - 1 in [1, max]\n+   if (i == 0) {\n+     \/\/ i - 1 is both -1 and [1, max] so top\n+\n+ The second if is redundant but first if updates the type of i-1, not i alone, we can't tell i != 0.\n+ Because i-1 becomes top in the second if branch, we can tell that branch is dead\n+ *\/\n+void PhaseConditionalPropagation::Transformer::transform_when_top_seen(Node* c, Node* node, const Type* t) {\n+  if (t->singleton()) {\n+    if (node->is_CFG()) {\n+      return;\n+    }\n+    if (t == Type::TOP) {\n+#ifdef ASSERT\n+      if (PrintLoopConditionalPropagation) {\n+        tty->print(\"top at %d\", c->_idx);\n+        node->dump();\n+      }\n+#endif\n+      if (c->is_IfProj()) {\n+        \/\/ make sure the node has some use that dominates or are dominated by the current control\n+        if (!related_node(node, c)) {\n+          return;\n+        }\n+        IfNode* iff = c->in(0)->as_If();\n+        if (iff->in(0)->is_top()) {\n+          return;\n+        }\n+        Node* bol = iff->in(1);\n+        const Type* bol_t = bol->bottom_type();\n+        if (bol->Opcode() == Op_OpaqueInitializedAssertionPredicate) {\n+          bol_t = TypeInt::ONE;\n+        }\n+        const Type* new_bol_t = TypeInt::make(1 - c->as_IfProj()->_con);\n+        if (bol_t != new_bol_t) {\n+          assert((c->is_IfProj() && _conditional_propagation.condition_recorded(c)), \"only for conditions that saw some type narrowing\");\n+          jint new_bol_con = new_bol_t->is_int()->get_con();\n+          if (bol_t->is_int()->is_con() && bol_t->is_int()->get_con() != new_bol_con) {\n+            \/\/ We already constant folded the condition to the opposite constant: this path is dead\n+            create_halt_node(iff->in(0));\n+            _phase->igvn().replace_input_of(iff, 0, _phase->C->top());\n+          } else {\n+#ifndef PRODUCT\n+            Atomic::inc(&PhaseIdealLoop::_loop_conditional_constants);\n+#endif\n+#ifndef PRODUCT\n+            Atomic::inc(&PhaseIdealLoop::_loop_conditional_test);\n+#endif\n+            Node* con = _phase->igvn().makecon(new_bol_t);\n+            _phase->set_ctrl(con, _phase->C->root());\n+            _phase->igvn().rehash_node_delayed(iff);\n+            iff->set_req_X(1, con, &_phase->igvn());\n+            _phase->C->set_major_progress();\n+          }\n+#ifdef ASSERT\n+          if (PrintLoopConditionalPropagation) {\n+            tty->print_cr(\"killing path\");\n+            node->dump();\n+            bol_t->dump();\n+            tty->cr();\n+            new_bol_t->dump();\n+            tty->cr();\n+            c->dump();\n+          }\n+#endif\n+        }\n+      } else if (node->is_Type() && related_node(node, c)) {\n+        node->as_Type()->make_paths_from_here_dead(&_phase->igvn(), _phase, \"conditional propagation\");\n+        _phase->C->set_major_progress();\n+      }\n+    }\n+  }\n+}\n+\n+void PhaseConditionalPropagation::Transformer::create_halt_node(Node* c) const {\n+  Node* frame = new ParmNode(_phase->C->start(), TypeFunc::FramePtr);\n+  _phase->register_new_node(frame, _phase->C->start());\n+  Node* halt = new HaltNode(c, frame, \"dead path discovered by PhaseConditionalPropagation\");\n+  _phase->igvn().add_input_to(_phase->igvn().C->root(), halt);\n+  _phase->register_control(halt, _phase->ltree_root(), c);\n+}\n+\n+void PhaseConditionalPropagation::Transformer::transform_when_constant_seen(Node* c, Node* node, const Type* t, const Type* prev_t) {\n+  if (t->singleton()) {\n+    if (node->is_CFG()) {\n+      return;\n+    } {\n+      Node* con = nullptr;\n+      for (DUIterator i = node->outs(); node->has_out(i); i++) {\n+        Node* use = node->out(i);\n+        if (use->is_Phi()) {\n+          Node* r = use->in(0);\n+          int nb_deleted = 0;\n+          for (uint j = 1; j < use->req(); ++j) {\n+            if (use->in(j) == node && !r->in(j)->is_top() && _conditional_propagation.is_dominator(c, r->in(j)) &&\n+                is_safe_for_replacement_at_phi(node, use, r, j)) {\n+              if (con == NULL) {\n+                con = _phase->igvn().makecon(t);\n+                _phase->set_ctrl(con, _phase->igvn().C->root());\n+              }\n+              _phase->igvn().replace_input_of(use, j, con);\n+#ifndef PRODUCT\n+              Atomic::inc(&PhaseIdealLoop::_loop_conditional_constants);\n+#endif\n+\n+              nb_deleted++;\n+#ifdef ASSERT\n+              if (PrintLoopConditionalPropagation) {\n+                tty->print_cr(\"constant folding\");\n+                node->dump();\n+                tty->print(\"input %d of \", j);\n+                use->dump();\n+                prev_t->dump();\n+                tty->cr();\n+                t->dump();\n+                tty->cr();\n+              }\n+#endif\n+            }\n+          }\n+          if (nb_deleted > 0) {\n+            --i;\n+          }\n+        } else if (_conditional_propagation.is_dominator(c, _phase->ctrl_or_self(use)) &&\n+                   is_safe_for_replacement(c, node, use)) {\n+          pin_array_access_nodes_if_needed(node, t, use, c);\n+          pin_uses_if_needed(t, use, c);\n+          if (con == nullptr) {\n+            con = _phase->igvn().makecon(t);\n+            _phase->set_ctrl(con, _phase->igvn().C->root());\n+          }\n+          _phase->igvn().rehash_node_delayed(use);\n+          int nb = use->replace_edge(node, con, &_phase->igvn());\n+          --i;\n+#ifndef PRODUCT\n+          Atomic::add(&PhaseIdealLoop::_loop_conditional_constants, nb);\n+#endif\n+#ifdef ASSERT\n+          if (PrintLoopConditionalPropagation) {\n+            tty->print_cr(\"constant folding\");\n+            node->dump();\n+            use->dump();\n+            prev_t->dump();\n+            tty->cr();\n+            t->dump();\n+            tty->cr();\n+          }\n+#endif\n+          if (use->is_If()) {\n+#ifndef PRODUCT\n+            Atomic::inc(&PhaseIdealLoop::_loop_conditional_test);\n+#endif\n+            _phase->C->set_major_progress();\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Eliminating a condition that guards an array access: we need to pin the array access otherwise, it could float if it's\n+\/\/ dependent on a new condition that ends up being replaced by an identical dominating one.\n+void PhaseConditionalPropagation::Transformer::pin_array_access_nodes_if_needed(const Node* node, const Type* t, const Node* use,\n+                                                                                Node* c) const {\n+  if (t == Type::TOP) {\n+    return;\n+  }\n+  if (node->is_Bool()) {\n+    if (use->is_RangeCheck() && node->in(1)->is_Cmp()) {\n+      IfNode* iff = use->as_If();\n+      int con = t->is_int()->get_con();\n+      pin_array_access_nodes(c, iff, con);\n+    }\n+  } else if (node->is_Cmp()) {\n+    if (use->is_Bool()) {\n+      BoolNode* bol = use->as_Bool();\n+      for (DUIterator_Fast imax, i = use->fast_outs(imax); i < imax; i++) {\n+        Node* u = use->fast_out(i);\n+        if (u->is_RangeCheck()) {\n+          pin_array_access_nodes(c, u->as_If(), bol->_test.cc2logical(t)->is_int()->get_con());\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ With something like:\n+\/\/ int div = i \/ (i + j)\n+\/\/ if (i == some_constant) {\n+\/\/   res += div;\n+\/\/ }\n+\/\/ Given, div is only used in the if block, i is replaced with some_constant in the division.\n+\/\/ Now, Let's say i gets a value different from some_constant but j gets -some_constant. The division by i + j wouldn't\n+\/\/ fault but, with i constant folded to some_constant, it does fault and shouldn't be scheduled outside the if block.\n+void PhaseConditionalPropagation::Transformer::pin_uses_if_needed(const Type* t, Node* use, Node* c) {\n+  assert(_wq.size() == 0, \"need to start from an empty work list\");\n+  if (t == Type::TOP) {\n+    return;\n+  }\n+  _wq.push(use);\n+  for (uint i = 0; i < _wq.size(); ++i) {\n+    Node* n = _wq.at(i);\n+    if (n->is_CFG() || n->is_Phi() || n->bottom_type() == Type::MEMORY) {\n+      continue;\n+    }\n+    if (n->is_div_or_mod(T_INT) || n->is_div_or_mod(T_LONG)) {\n+      if (n->in(0) != nullptr && n->in(0) != c) {\n+        Node* early_ctrl = _phase->compute_early_ctrl(n, _phase->get_ctrl(n));\n+        if (early_ctrl != c && _conditional_propagation.is_dominator(early_ctrl, c)) {\n+          _phase->igvn().replace_input_of(n, 0, c);\n+        }\n+      }\n+    } else if (n->is_Load()) {\n+      if (n->in(0) != nullptr && n->in(0) != c) {\n+        Node* early_ctrl = _phase->compute_early_ctrl(n, _phase->get_ctrl(n));\n+        if (early_ctrl != c && _conditional_propagation.is_dominator(early_ctrl, c)) {\n+          Node* clone = n->pin_array_access_node();\n+          if (clone != nullptr) {\n+            clone->set_req(0, c);\n+            _phase->register_new_node(clone, c);\n+            _phase->igvn().replace_node(n, clone);\n+          }\n+        }\n+      }\n+    }\n+    for (DUIterator_Fast jmax, j = n->fast_outs(jmax); j < jmax; j++) {\n+      Node* u = n->fast_out(j);\n+      if (_conditional_propagation.is_dominator(c, _phase->ctrl_or_self(u))) {\n+        _wq.push(u);\n+      }\n+    }\n+  }\n+  _wq.clear();\n+}\n+\n+void PhaseConditionalPropagation::Transformer::pin_array_access_nodes(Node* c, const IfNode* iff, int con) const {\n+  ProjNode* proj = iff->proj_out(con);\n+  for (DUIterator i = proj->outs(); proj->has_out(i); i++) {\n+    Node* u = proj->out(i);\n+    if (u->depends_only_on_test()) {\n+      Node* clone = u->pin_array_access_node();\n+      if (clone != nullptr) {\n+        clone->set_req(0, c);\n+        _phase->register_new_node(clone, _phase->get_ctrl(u));\n+        _phase->igvn().replace_node(u, clone);\n+        --i;\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ We don't want to constant fold only the iv incr if the cmp doesn't constant fold as well\n+bool PhaseConditionalPropagation::Transformer::is_safe_for_replacement_at_phi(Node* node, Node* use, Node* r, uint j) const {\n+  if (!(r->is_BaseCountedLoop() &&\n+        j == LoopNode::LoopBackControl &&\n+        use == r->as_BaseCountedLoop()->phi() &&\n+        node == r->as_BaseCountedLoop()->incr())) {\n+    return false;\n+  }\n+  BaseCountedLoopNode* cl = r->as_BaseCountedLoop();\n+  if (!cl->is_valid_counted_loop(cl->bt())) {\n+    return true;\n+  }\n+  BaseCountedLoopEndNode* le = cl->loopexit();\n+  const Type* cmp_type = _type_table->find_type_between(le->cmp_node(), le, _phase->idom(r));\n+  return cmp_type != nullptr && cmp_type->singleton();\n+}\n+\n+void PhaseConditionalPropagation::Transformer::transform_helper(Node* c) {\n+  auto transform_top = [&](Node* node, const Type* t, const Type* prev_t) {\n+    transform_when_top_seen(c, node, t);\n+  };\n+  _type_table->apply_at_control(c, transform_top);\n+  auto transform_constant = [&](Node* node, const Type* t, const Type* prev_t) {\n+    transform_when_constant_seen(c, node, t, prev_t);\n+  };\n+  _type_table->apply_at_control(c, transform_constant);\n+}\n+\n+\/\/ Compute and cache early control for data nodes\n+PhaseConditionalPropagation::EarlyCtrls::EarlyCtrls(Node_Stack& nstack, PhaseConditionalPropagation& conditional_propagation)\n+  : _nstack(nstack), _phase(conditional_propagation._phase), _conditional_propagation(conditional_propagation) {\n+  _node_to_ctrl_table = new NodeToCtrl(8, _phase->C->live_nodes());\n+}\n+\n+Node* PhaseConditionalPropagation::EarlyCtrls::known_early_ctrl(Node* n) const {\n+  if (n->is_CFG()) {\n+    return n;\n+  }\n+  if (n->pinned()) {\n+    return n->in(0);\n+  }\n+  Node** c_ptr = _node_to_ctrl_table->get(n);\n+  if (c_ptr != nullptr) {\n+    assert(*c_ptr == _phase->compute_early_ctrl(n, _phase->ctrl_or_self(n)), \"\");\n+    return *c_ptr;\n+  }\n+  return nullptr;\n+}\n+\n+Node* PhaseConditionalPropagation::EarlyCtrls::compute_early_ctrl(Node* u) {\n+  _nstack.push(u, 0);\n+  Node* early_c = nullptr;\n+  _intermediate_results.push(nullptr); \/\/ current early ctrl: unknown\n+  do {\n+    assert(_nstack.size() == _intermediate_results.size(), \"should be in sync\");\n+    Node* n = _nstack.node();\n+    uint idx = _nstack.index();\n+    if (idx >= n->req()) {\n+      assert(early_c == _phase->compute_early_ctrl(n, _phase->get_ctrl(n)), \"incorrect result\");\n+      assert(_node_to_ctrl_table->get(n) == nullptr, \"shouldn't have been cached already\");\n+      _node_to_ctrl_table->put(n, early_c);\n+      _node_to_ctrl_table->maybe_grow(load_factor);\n+      _nstack.pop();\n+      Node* in_c = early_c;\n+      \/\/ pop intermediate result for early ctrl and compute updated one\n+      early_c = update_early_ctrl(_intermediate_results.pop(), in_c);\n+    } else {\n+      Node* in = n->in(idx);\n+      idx++;\n+      _nstack.set_index(idx);\n+      if (in != nullptr) {\n+        Node* in_c = known_early_ctrl(in);\n+        if (in_c == nullptr) {\n+          _nstack.push(in, 0);\n+          _intermediate_results.push(early_c); \/\/ save intermediate result for early control\n+          early_c = nullptr;\n+        } else {\n+          early_c = update_early_ctrl(early_c, in_c);\n+        }\n+      }\n+    }\n+  } while (_nstack.is_nonempty());\n+  assert(early_c == _phase->compute_early_ctrl(u, _phase->get_ctrl(u)), \"incorrect result\");\n+  return early_c;\n+}\n+\n+\/\/ Compute and cache early control for data node\n+Node* PhaseConditionalPropagation::EarlyCtrls::get_early_ctrl(Node* u) {\n+  assert(_nstack.is_empty(), \"non empty stack\");\n+  Node* early_c = known_early_ctrl(u);\n+  if (early_c != nullptr) {\n+    return early_c;\n+  }\n+  return compute_early_ctrl(u);\n+}\n+\n+Node* PhaseConditionalPropagation::EarlyCtrls::update_early_ctrl(Node* early_c, Node* in_c) {\n+  if (early_c == nullptr || _conditional_propagation.is_dominator(early_c, in_c)) {\n+    return in_c;\n+  }\n+  return early_c;\n+}\n+\n+const PhaseConditionalPropagation::TypeTable* PhaseConditionalPropagation::analyze(int rounds) {\n+  Analyzer analyzer(*this, _visited, _rpo_list);\n+  return analyzer.analyze(rounds);\n+}\n+\n+void PhaseConditionalPropagation::analyze_and_transform(int rounds) {\n+  const TypeTable* type_table;\n+  {\n+    TraceTime tt(\"loop conditional propagation analyze\", UseNewCode);\n+    type_table = analyze(rounds);\n+  }\n+  {\n+    TraceTime tt(\"loop conditional propagation transform\", UseNewCode);\n+    do_transform(type_table);\n+  }\n+}\n+\n+#ifdef ASSERT\n+bool PhaseConditionalPropagation::narrows_type(const Type* old_t, const Type* new_t, bool strictly) {\n+  if (old_t == new_t) {\n+    return !strictly;\n+  }\n+\n+  if (new_t == Type::TOP) {\n+    return true;\n+  }\n+\n+  if (old_t == Type::TOP) {\n+    return false;\n+  }\n+\n+  if (!new_t->isa_int() && !new_t->isa_long()) {\n+    return true;\n+  }\n+\n+  assert(old_t->isa_int() || old_t->isa_long(), \"can't be narrower\");\n+  assert((old_t->isa_int() != nullptr) == (new_t->isa_int() != nullptr), \"should be same basic type\");\n+\n+  BasicType bt = new_t->isa_int() ? T_INT : T_LONG;\n+\n+  const TypeInteger* new_int = new_t->is_integer(bt);\n+  const TypeInteger* old_int = old_t->is_integer(bt);\n+\n+  if (new_int->lo_as_long() < old_int->lo_as_long()) {\n+    return false;\n+  }\n+\n+  if (new_int->hi_as_long() > old_int->hi_as_long()) {\n+    return false;\n+  }\n+\n+  return true;\n+}\n+#endif\n+\n+void PhaseConditionalPropagation::do_transform(const TypeTable* type_table) {\n+  Transformer transformer(*this, type_table);\n+  transformer.do_transform();\n+}\n+\n+PhaseConditionalPropagation::DominatorTree::DominatorTree(const Node_List& rpo_list, PhaseIdealLoop* phase):\n+  _nodes(nullptr) {\n+  _nodes = new DomTreeTable(8, rpo_list.size());\n+\n+  for (int i = rpo_list.size() - 1; i >= 0; i--) {\n+    Node* n = rpo_list.at(i);\n+    DomTreeNode* dt_n = new DomTreeNode(n);\n+    _nodes->put(n, dt_n);\n+    _nodes->maybe_grow(load_factor);\n+    if (n->is_Root()) {\n+      continue;\n+    }\n+    Node* dom = phase->idom(n);\n+    DomTreeNode** dt_dom = _nodes->get(dom);\n+    dt_n->_sibling = (*dt_dom)->_child;\n+    (*dt_dom)->_child = dt_n;\n+  }\n+  {\n+    ResourceMark rm;\n+    GrowableArray<DomTreeNode*> stack;\n+    stack.push(*_nodes->get(phase->C->root()));\n+    uint i = 1;\n+    while (stack.is_nonempty()) {\n+      DomTreeNode* current = stack.top();\n+      DomTreeNode* next = current->_child;\n+      if (next != nullptr) {\n+        stack.push(next);\n+        next->_pre = i;\n+        i++;\n+      } else {\n+        do {\n+          current = stack.pop();\n+          current->_post = i;\n+          i++;\n+          next = current->_sibling;\n+          if (next != nullptr) {\n+            stack.push(next);\n+            next->_pre = i;\n+            i++;\n+            break;\n+          }\n+        } while (stack.is_nonempty());\n+      }\n+    }\n+  }\n+}\n+\n+PhaseConditionalPropagation::PhaseConditionalPropagation(PhaseIdealLoop* phase, VectorSet &visited, Node_Stack &nstack,\n+                                                         Node_List &rpo_list)\n+  : _phase(phase),\n+    _visited(visited),\n+    _rpo_list(rpo_list),\n+    _early_ctrls(nstack, *this),\n+    _dominator_tree(nullptr) {\n+  assert(nstack.is_empty(), \"non empty stack as argument\");\n+  assert(_rpo_list.size() == 0, \"non empty list as argument\");\n+  phase->rpo(phase->C->root(), nstack, _visited, _rpo_list);\n+  _dominator_tree = new DominatorTree(_rpo_list, _phase);\n+  \/\/ Remove control nodes at which no type update is possible\n+  int shift = 0;\n+  for (uint i = 0; i < _rpo_list.size(); ++i) {\n+    Node* n = _rpo_list.at(i);\n+    if (n->is_MultiBranch()) {\n+      \/\/ no type update at non projections.\n+      shift++;\n+    } else if (shift > 0) {\n+      _rpo_list.map(i - shift, n);\n+    }\n+  }\n+  while (shift > 0) {\n+    shift--;\n+    _rpo_list.pop();\n+  }\n+}\n+\n+void PhaseIdealLoop::conditional_elimination(VectorSet &visited, Node_Stack &nstack, Node_List &rpo_list, int rounds) {\n+  TraceTime tt(\"loop conditional propagation\", UseNewCode);\n+  PhaseConditionalPropagation pcp(this, visited, nstack, rpo_list);\n+  pcp.analyze_and_transform(rounds);\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/loopConditionalPropagation.cpp","additions":1815,"deletions":0,"binary":false,"changes":1815,"status":"added"},{"patch":"@@ -0,0 +1,565 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OPTO_LOOPCONDITIONALPROPAGATION_HPP\n+#define SHARE_OPTO_LOOPCONDITIONALPROPAGATION_HPP\n+\n+#include \"opto\/indexSet.hpp\"\n+#include \"opto\/loopnode.hpp\"\n+#include \"opto\/rootnode.hpp\"\n+\n+class PhaseConditionalPropagation :  public StackObj {\n+private:\n+  \/\/ As part of this optimization the type of node n can be narrowed to a new type t at a control c\n+  \/\/ This class keeps the mapping of (n, c) -> t\n+  class TypeTable : public ResourceObj {\n+  protected:\n+    \/\/ The (n, c) -> t mapping is kept with a table that maps a control to a list of type updates:\n+    \/\/ c -> [(n1, t1), (n2, t2)...]\n+    \/\/ The reason for this is that it's common to have to iterate over all updates at a particular control\n+    \/\/ This class implements the list of type updates [(n1, t1), (n2, t2)...]\n+    class NodeTypesList : public ResourceObj {\n+    private:\n+      \/\/ This is one entry (n, t) in the list [(n1, t1), (n2, t2)...]\n+      class NodeTypes {\n+      public:\n+        NodeTypes(Node* node, const Type* before, const Type* after)\n+          : _node(node), _before(before), _after(after) {\n+        }\n+\n+        NodeTypes()\n+          : _node(nullptr), _before(nullptr), _after(nullptr) {\n+        }\n+\n+        Node* _node; \/\/ the node whose type is narrowed\n+        const Type* _before; \/\/ the current type (before narrowing)\n+        const Type* _after; \/\/ the narrowed type\n+      };\n+\n+      GrowableArray<NodeTypes> _node_types; \/\/ the list of updates [(n1, t1), (n2, t2)...]\n+      \/\/ We are at some control where some nodes have their types narrowed\n+      \/\/ If we go up the dominator tree, there may be some controls at which some nodes had their type narrowed\n+      \/\/ _prev points to the type updates we would encounter first if we were to follow the dominator tree.\n+      \/\/ This is useful to iterate over all type updates between the current control and some dominating control: follow\n+      \/\/ _prev links comparing their _control with the dominating control we want to stop at\n+      NodeTypesList* _prev;\n+      Node* _control; \/\/ control at which the update happens\n+      int _iterations; \/\/ iterations of main algorithm at which this was last updated\n+\n+      NodeTypesList(NodeTypesList* prev, Node* control, int size, int interations)\n+        : _node_types(size), _prev(prev), _control(control), _iterations(interations) {\n+      }\n+\n+    public:\n+      NodeTypesList(NodeTypesList* prev, Node* control, int iterations)\n+        : _prev(prev), _control(control), _iterations(iterations) {\n+      }\n+\n+      int length() const {\n+        return _node_types.length();\n+      }\n+\n+      Node* node_at(int i) const {\n+        return _node_types.at(i)._node;\n+      }\n+\n+      const Type* prev_type_at(int i) const {\n+        return _node_types.at(i)._before;\n+      }\n+\n+      const Type* type_at(int i) const {\n+        return _node_types.at(i)._after;\n+      }\n+\n+      const Type* type_if_present(Node* n) {\n+        int i = find(n);\n+        if (i == -1) {\n+          return nullptr;\n+        }\n+        return _node_types.at(i)._after;\n+      }\n+\n+      const Type* prev_type_if_present(Node* n) {\n+        int i = find(n);\n+        if (i == -1) {\n+          return nullptr;\n+        }\n+        return _node_types.at(i)._before;\n+      }\n+\n+      void set_type_at(int i, const Type* t) {\n+        _node_types.at(i)._after = t;\n+      }\n+\n+      void set_prev_type_at(int i, const Type* t) {\n+        _node_types.at(i)._before = t;\n+      }\n+\n+      bool contains(Node* n) {\n+        return find(n) != -1;\n+      }\n+\n+      void remove_at(int i) {\n+        _node_types.remove_at(i);\n+      }\n+\n+      static int compare_for_find(const Node* const&n, const NodeTypes &e) {\n+        return n->_idx - e._node->_idx;\n+      }\n+\n+      static int compare_for_push_node(const NodeTypes &e1, const NodeTypes &e2) {\n+        return e1._node->_idx - e2._node->_idx;\n+      }\n+\n+      int find(const Node* n) {\n+        bool found = false;\n+        int res = _node_types.find_sorted<const Node*, compare_for_find>(n, found);\n+        if (!found) {\n+          return -1;\n+        }\n+        return res;\n+      }\n+\n+      void push_node(Node* node, const Type* old_t, const Type* new_t) {\n+        _node_types.insert_sorted<compare_for_push_node>(NodeTypes(node, old_t, new_t));\n+        assert(find(node) != -1 && _node_types.at(find(node))._node == node, \"\");\n+      }\n+\n+      NodeTypesList* prev() const {\n+        return _prev;\n+      }\n+\n+      bool below(NodeTypesList* dom_node_types_list, PhaseConditionalPropagation& conditional_propagation) const {\n+        return this != dom_node_types_list && (dom_node_types_list == nullptr ||\n+          !conditional_propagation.is_dominator(control(), dom_node_types_list->control()));\n+      }\n+\n+      void set_prev(NodeTypesList* prev) {\n+        _prev = prev;\n+      }\n+\n+      Node* control() const {\n+        return _control;\n+      }\n+\n+      NodeTypesList* copy() const {\n+        NodeTypesList* c = new NodeTypesList(_prev, _control, _node_types.length(), _iterations);\n+        for (int i = 0; i < _node_types.length(); ++i) {\n+          c->_node_types.push(_node_types.at(i));\n+        }\n+        return c;\n+      }\n+\n+      void set_iterations(int iterations) {\n+        _iterations = iterations;\n+      }\n+\n+      int iterations() const {\n+        return _iterations;\n+      }\n+\n+#ifdef ASSERT\n+      void dump() const;\n+#endif\n+    };\n+\n+    \/\/ The c -> [(n1, t1), (n2, t2)...] mapping is kept in a hash table indexed by c\n+    using NodeTypesListTable = ResizeableResourceHashtable<Node*, NodeTypesList*, AnyObj::RESOURCE_AREA, mtInternal>;\n+    NodeTypesListTable* _node_types_list_table;\n+\n+    NodeTypesList* node_types_list_at(Node* c) const {\n+      NodeTypesList** node_types_list_ptr = _node_types_list_table->get(_conditional_propagation.known_updates(c));\n+      if (node_types_list_ptr == nullptr) {\n+        return nullptr;\n+      }\n+      return *node_types_list_ptr;\n+    }\n+\n+    const Type* type_if_present(Node* c, Node* n) const {\n+      NodeTypesList* node_types_list = node_types_list_at(c);\n+      if (node_types_list == nullptr) {\n+        return nullptr;\n+      }\n+      return node_types_list->type_if_present(n);\n+    }\n+\n+    PhaseConditionalPropagation &_conditional_propagation;\n+    PhaseIdealLoop* _phase;\n+\n+    TypeTable(PhaseConditionalPropagation &conditional_propagation);\n+    template <class Callback> bool apply_between_controls_internal(Node* c, Node* dom, Callback callback) const;\n+  public:\n+\n+    const Type* find_type_between(const Node* n, Node* c, Node* dom) const;\n+\n+    const Type* find_prev_type_between(const Node* n, Node* c, Node* dom) const;\n+\n+    const Type* type(Node* n, Node* c) const ;\n+\n+    template <class Callback> void apply_at_control(Node* c, Callback callback) const;\n+    template <class Callback> void apply_at_control_with_updates(Node* c, Callback callback) const;\n+    bool has_types_at_control(Node* c) const;\n+  };\n+\n+  \/\/ A TypeTable that can be updated. First phase of the transformation analyzes the graph and collects new types. It\n+  \/\/ uses a WriteableTypeTable. Second phase transforms the graph based on the new types but doesn't make any updates\n+  \/\/ to types: it uses the read only TypeTable.\n+  class WriteableTypeTable : public TypeTable {\n+  private:\n+    \/\/ To avoid repetitive queries, we cache some pointers to NodeTypesList\n+    NodeTypesList* _current_node_types_list; \/\/ the one we're currently updating (at _current_ctrl)\n+    NodeTypesList* _dom_node_types_list; \/\/ The one at the immediate dominator\n+    NodeTypesList* _prev_node_types_list; \/\/ The one from the previous iterations of the main algorithm\n+\n+  public:\n+\n+    WriteableTypeTable(PhaseConditionalPropagation &conditional_propagation)\n+            : TypeTable(conditional_propagation),\n+              _current_node_types_list(nullptr),\n+              _dom_node_types_list(nullptr),\n+              _prev_node_types_list(nullptr) {\n+    }\n+\n+    void set_current_control(Node* c, bool verify, int iterations);\n+    bool record_type(Node* c, Node* n, const Type* prev_t,\n+                     const Type* new_t, int iterations);\n+    bool types_improved(Node* c, int iterations, bool verify) const;\n+    const Type* type_at_current_ctrl(Node* n) const;\n+\n+    const Type* prev_iteration_type(Node* n) const;\n+    const Type* prev_iteration_type(Node* n, Node* c) const;\n+\n+    int iterations_at(Node* c) {\n+      NodeTypesList* node_types_list = node_types_list_at(c);\n+      if (node_types_list == nullptr) {\n+        return -1;\n+      }\n+      return node_types_list->iterations();\n+    }\n+\n+    template <class Callback> void apply_between_controls(Node* c, Node* dom, Callback callback) const;\n+    int count_updates_between_controls(Node* c, Node* dom) const;\n+    template <class Callback> void apply_at_prev_iteration(Callback callback) const;\n+  };\n+\n+  \/\/ When the type of a node is narrowed, there is usually an opportunity to narrow the type of other nodes that depend\n+  \/\/ on that node but, in the general case, processing those nodes only make sense once the main algorithm has reached\n+  \/\/ a particular control. With this WorkQueue implementation, nodes are enqueued for processing at some particular\n+  \/\/ control.\n+  class WorkQueue : public ResourceObj {\n+  private:\n+    \/\/ A mapping from some control to a list of nodes that need processing\n+    using WorkQueues = ResizeableResourceHashtable<Node*, GrowableArray<Node*>*, AnyObj::RESOURCE_AREA, mtInternal>;\n+    WorkQueues* _work_queues;\n+    \/\/ A cheap way to check if a node was already enqueued\n+    VectorSet _enqueued;\n+    \/\/ As an optimization, keep track of the current control the main algorithm is analyzing and if a node is enqueued\n+    \/\/ at _current_ctrl, push it on the Unique_Node_List below\n+    Unique_Node_List _wq;\n+    Node* _current_ctrl;\n+\n+    GrowableArray<Node*>* work_queue_at(Node* c) const {\n+      GrowableArray<Node*>** work_queue_ptr = _work_queues->get(c);\n+      if (work_queue_ptr == nullptr) {\n+        return nullptr;\n+      }\n+      return *work_queue_ptr;\n+    }\n+\n+    bool enqueue_for_delayed_processing(Node* n, Node* c);\n+\n+  public:\n+    WorkQueue(Node* root, uint max_elements) :\n+            _current_ctrl(root) {\n+      _work_queues = new WorkQueues(8, max_elements);\n+    }\n+\n+    bool enqueued(const Node* n) {\n+      return _enqueued.test(n->_idx) || _wq.member(n);\n+    }\n+\n+    bool is_empty(Node* c) const {\n+      if (c == _current_ctrl) {\n+        assert(work_queue_at(c) == nullptr, \"\");\n+        return _wq.size() == 0;\n+      }\n+      return work_queue_at(c) == nullptr;\n+    }\n+\n+    bool all_empty() const {\n+      assert((_work_queues->number_of_entries() == 0) == _enqueued.is_empty(), \"inconsistency\");\n+      return _work_queues->number_of_entries() == 0;\n+    }\n+\n+    Node* pop(Node* c) {\n+      assert(c == _current_ctrl && work_queue_at(c) == nullptr, \"\");\n+      return _wq.pop();\n+    }\n+\n+    void dump() const PRODUCT_RETURN;\n+\n+    void set_current_control(Node* c);\n+    bool enqueue(Node* n, Node* c);\n+  };\n+\n+  \/\/ First phase of the transformation: collect types\n+  class Analyzer : public PhaseIterGVN {\n+  private:\n+\n+    PhaseConditionalPropagation& _conditional_propagation;\n+    PhaseIdealLoop* _phase;\n+    int _iterations;\n+    WorkQueue* _work_queue;\n+    bool _verify;\n+#ifdef ASSERT\n+    VectorSet& _visited;\n+    bool _progress;\n+#endif\n+    Node_List &_rpo_list;\n+    WriteableTypeTable* _type_table;\n+    Node* _current_ctrl;\n+\n+    void enqueue_use(Node* n, Node* queue_control);\n+    Node* compute_queue_control(Node* u) const;\n+    Node* compute_queue_control(Node* u, bool at_current_ctrl);\n+    void maybe_enqueue_if_projections_from_cmp(const Node* u);\n+    void maybe_enqueue_if_projections(IfNode* iff);\n+    void handle_region(Node* dom, bool &extra_loop_variable);\n+    void handle_ifproj();\n+    void propagate_types(bool &extra_type_init);\n+    void analyze_allocate_array(const AllocateArrayNode* alloc);\n+    void analyze_if(const Node* cmp, Node* n);\n+    bool one_iteration(bool &extra_loop_variable, bool &extra_type_init);\n+    void merge_with_dominator_types();\n+    void verify(bool& extra_type_init) PRODUCT_RETURN;\n+    struct NodeTypePair {\n+      Node* _n;\n+      const Type* _t;\n+    };\n+    GrowableArray<NodeTypePair> _stack; \/\/ This is needed by sync()\n+    void sync_global_types_with_types_at_control(Node* c);\n+    Node* _current_types_ctrl;\n+\n+#ifdef ASSERT\n+    \/\/ During verification, nodes are enqueued for verification as soon as the type of one input is narrowed. So a node\n+    \/\/ can have its type narrowed at a control that dominates early control for the node. Outside of verification that\n+    \/\/ can't happen. Track nodes for which that happens and make sure they all have the same type during and before\n+    \/\/ verification at early control for the node.\n+    Unique_Node_List _verify_wq;\n+    bool verify_wq_empty() const {\n+      return _verify_wq.size() == 0;\n+    }\n+#endif\n+\n+  private:\n+    const Type* type_at_current_ctrl(Node* n) const;\n+\n+  public:\n+    Analyzer(PhaseConditionalPropagation &conditional_propagation, VectorSet& visited, Node_List& rpo_list)\n+    : PhaseIterGVN(&conditional_propagation._phase->igvn()),\n+      _conditional_propagation(conditional_propagation),\n+      _phase(conditional_propagation._phase),\n+      _iterations(0),\n+      _work_queue(nullptr),\n+      _verify(false),\n+#ifdef ASSERT\n+      _visited(visited),\n+      _progress(true),\n+#endif\n+      _rpo_list(rpo_list),\n+      _type_table(nullptr),\n+      _current_ctrl(nullptr),\n+      _current_types_ctrl(conditional_propagation._phase->C->root()) {\n+      _work_queue = new WorkQueue(_phase->C->root(), _conditional_propagation._rpo_list.size());\n+      _type_table = new WriteableTypeTable(_conditional_propagation);\n+    }\n+    const TypeTable* analyze(int rounds);\n+\n+#ifdef ASSERT\n+    void maybe_set_progress(Node* n, Node* c) {\n+      if (_visited.test(c->_idx)) {\n+        _progress = true;\n+        assert(n->is_Phi() || n->is_Region(), \"only backedges\");\n+      }\n+    }\n+#endif\n+\n+    void enqueue_uses(const Node* n, bool at_current_ctrl = false);\n+\n+    int iterations() const {\n+      return _iterations;\n+    }\n+\n+    bool verify() const {\n+      return _verify;\n+    }\n+    const Type* type(const Node* n, Node* c) const;\n+\n+    void set_type(Node* n, const Type* t, const Type* old_t) {\n+      _type_table->record_type(_current_types_ctrl, n, old_t, t, _iterations);\n+      PhaseValues::set_type(n, t);\n+    }\n+\n+    void enqueue(Node* n, Node* c);\n+  };\n+\n+  \/\/ Second phase of the transformation: transform the graph from types collected by first phase\n+  class Transformer : public ResourceObj {\n+  private:\n+    PhaseConditionalPropagation& _conditional_propagation;\n+    PhaseIdealLoop* _phase;\n+    Unique_Node_List _controls;\n+    Unique_Node_List _wq;\n+    const TypeTable* _type_table;\n+    uint _unique;\n+\n+    void transform_when_top_seen(Node* c, Node* node, const Type* t);\n+    void transform_when_constant_seen(Node* c, Node* node, const Type* t, const Type* prev_t);\n+    void transform_helper(Node* c);\n+    bool is_safe_for_replacement(Node* c, Node* node, Node* use) const;\n+    bool is_safe_for_replacement_at_phi(Node* node, Node* use, Node* r, uint j) const;\n+    void pin_array_access_nodes(Node* c, const IfNode* iff, int con) const;\n+    void pin_uses_if_needed(const Type* t, Node* use, Node* c);\n+    void pin_array_access_nodes_if_needed(const Node* node, const Type* t, const Node* use, Node* c) const;\n+    bool related_node(Node* n, Node* c);\n+    void create_halt_node(Node* c) const;\n+\n+  public:\n+    Transformer(PhaseConditionalPropagation& conditional_propagation, const TypeTable* type_table)\n+            : _conditional_propagation(conditional_propagation),\n+              _phase(conditional_propagation._phase),\n+              _type_table(type_table),\n+              _unique(_conditional_propagation._phase->C->unique()) {\n+    }\n+\n+    ProjNode* always_taken_if_proj(IfNode* iff);\n+\n+    void do_transform();\n+  };\n+\n+  \/\/ Utility class: main algorithm needs early control for some nodes. Rather than recompute it, cache the result\n+  class EarlyCtrls {\n+  private:\n+    Node_Stack& _nstack;\n+    Node_List _intermediate_results;\n+    PhaseIdealLoop* _phase;\n+    PhaseConditionalPropagation& _conditional_propagation;\n+    using NodeToCtrl = ResizeableResourceHashtable<Node*, Node*, AnyObj::RESOURCE_AREA, mtInternal>;\n+    NodeToCtrl* _node_to_ctrl_table;\n+\n+    Node* known_early_ctrl(Node* n) const;\n+\n+    Node* compute_early_ctrl(Node* u);\n+\n+    Node* update_early_ctrl(Node* early_c, Node* in_c);\n+\n+  public:\n+    EarlyCtrls(Node_Stack& nstack, PhaseConditionalPropagation& conditional_propagation);\n+    Node* get_early_ctrl(Node* u);\n+  };\n+\n+  Node* known_updates(Node* c) const {\n+    return _phase->find_non_split_ctrl(c);\n+  }\n+\n+  PhaseIdealLoop* _phase;\n+  VectorSet& _visited;\n+  Node_List &_rpo_list;\n+\n+#ifdef ASSERT\n+  VectorSet _conditions;\n+  void record_condition(Node* c) {\n+    _conditions.set(c->_idx);\n+  }\n+  bool condition_recorded(Node* c) const {\n+    return _conditions.test(c->_idx);\n+  }\n+#endif\n+\n+  EarlyCtrls _early_ctrls;\n+  Node* get_early_ctrl(Node* u) {\n+    return _early_ctrls.get_early_ctrl(u);\n+  }\n+\n+  const TypeTable* analyze(int rounds);\n+  void do_transform(const TypeTable* type_table);\n+\n+  static const int load_factor = 8;\n+\n+  \/\/ Utility class: main algorithm makes heavy use of dominator check. This provides a faster check. It requires a new\n+  \/\/ tree structure to be constructed (A node in the tree is for one control and it is an immediate dominator for its\n+  \/\/ children: it is the existing idom structure upside down) and traversed so each node of the tree is annotated with\n+  \/\/ its pre and post order positions.\n+  class DominatorTree : public ResourceObj {\n+  private:\n+    class DomTreeNode : public ResourceObj {\n+    public:\n+      DomTreeNode* _child;\n+      DomTreeNode* _sibling;\n+      Node* _node;\n+      uint _pre;\n+      uint _post;\n+\n+      DomTreeNode(Node* node) : _child(nullptr), _sibling(nullptr), _node(node), _pre(0), _post(0) {\n+      }\n+    };\n+    \/\/ Node to tree node hash table\n+    using DomTreeTable = ResizeableResourceHashtable<Node*, DomTreeNode*, AnyObj::RESOURCE_AREA, mtInternal>;\n+    DomTreeTable* _nodes;\n+  public:\n+    DominatorTree(const Node_List& rpo_list, PhaseIdealLoop* phase);\n+\n+    \/\/           n1 (pre =0, post = 13)\n+    \/\/         \/                 \\\n+    \/\/        n2 (1,6)             n5 (7, 12)\n+    \/\/       \/  \\                 \/  \\\n+    \/\/(2,3) n3    n4 (4,5) (8,9) n6   n7 (10, 11)\n+    \/\/\n+    \/\/ n1 dominates n4 because 0 < 4 and 5 < 13\n+    \/\/ n2 doesn't dominates n7: 1 < 10 but 11 > 6\n+    bool is_dominator(Node* dominator, Node* m) const {\n+      DomTreeNode* dom_n = *_nodes->get(dominator);\n+      DomTreeNode* dom_m = *_nodes->get(m);\n+      return dom_n->_pre < dom_m->_pre && dom_n->_post > dom_m->_post;\n+    }\n+  };\n+  DominatorTree* _dominator_tree;\n+\n+public:\n+  PhaseConditionalPropagation(PhaseIdealLoop* phase, VectorSet &visited, Node_Stack &nstack, Node_List &rpo_list);\n+\n+  void analyze_and_transform(int rounds);\n+\n+#ifdef ASSERT\n+  static bool narrows_type(const Type* old_t, const Type* new_t, bool strictly = false);\n+#endif\n+\n+  bool is_dominator(Node* dominator, Node* m) const {\n+    assert(_phase->is_dominator(dominator, m) == (dominator == m || _dominator_tree->is_dominator(dominator, m)), \"\");\n+    return (dominator == m || _dominator_tree->is_dominator(dominator, m));\n+  }\n+\n+};\n+\n+#endif \/\/ SHARE_OPTO_LOOPCONDITIONALPROPAGATION_HPP\n","filename":"src\/hotspot\/share\/opto\/loopConditionalPropagation.hpp","additions":565,"deletions":0,"binary":false,"changes":565,"status":"added"},{"patch":"@@ -81,0 +81,1 @@\n+        !le->in(0)->is_top() &&\n@@ -794,0 +795,5 @@\n+\n+  if (head->phi() == nullptr) {\n+    return false;\n+  }\n+\n@@ -3353,2 +3359,2 @@\n-        const TypeInt* if_t = IfNode::filtered_int_type(&_igvn, val, pred);\n-        if (if_t != nullptr) {\n+        const Type* if_t = IfNode::filtered_int_type(&_igvn, val, pred, T_INT);\n+        if (if_t != nullptr && if_t->isa_int()) {\n@@ -3356,1 +3362,1 @@\n-            rtn_t = if_t;\n+            rtn_t = if_t->is_int();\n@@ -4323,3 +4329,5 @@\n-    int stride_con  = cl->stride_con();\n-    if (stride_con > 0) tty->print(\"+\");\n-    tty->print(\"%d\", stride_con);\n+    if (cl->stride() != nullptr) {\n+      int stride_con  = cl->stride_con();\n+      if (stride_con > 0) tty->print(\"+\");\n+      tty->print(\"%d\", stride_con);\n+    }\n@@ -4875,0 +4883,7 @@\n+  \/\/ Stress loop conditional propagation: run early, run as long as there is progress\n+  if (!C->major_progress() && UseLoopConditionalPropagation && LoopConditionalPropagationALot) {\n+    visited.clear();\n+    int rounds = max_jint;\n+    conditional_elimination(visited, nstack, worklist, rounds);\n+  }\n+\n@@ -4925,0 +4940,20 @@\n+  \/\/ Standard way of running loop conditional propagation: run only once because it's expensive\n+  if (UseLoopConditionalPropagation && !LoopConditionalPropagationALot) {\n+    if (!C->major_progress()) {\n+      if (C->run_loop_conditional_propagation()) {\n+        visited.clear();\n+        int rounds = max_jint;\n+        conditional_elimination(visited, nstack, worklist, rounds);\n+        C->set_run_loop_conditional_propagation(false);\n+#ifndef PRODUCT\n+        if (C->major_progress()) {\n+          Atomic::inc(&PhaseIdealLoop::_loop_conditional_progress);\n+        }\n+#endif\n+      }\n+    } else {\n+      \/\/ If we made some progress since we last tried Loop Conditional Propagation, give it another try\n+      C->set_run_loop_conditional_propagation(true);\n+    }\n+  }\n+\n@@ -4978,0 +5013,3 @@\n+volatile int PhaseIdealLoop::_loop_conditional_constants = 0;\n+volatile int PhaseIdealLoop::_loop_conditional_test = 0;\n+volatile int PhaseIdealLoop::_loop_conditional_progress = 0;\n@@ -4979,1 +5017,1 @@\n-  tty->print_cr(\"PhaseIdealLoop=%d, sum _unique=%d, long loops=%d\/%d\/%d\", _loop_invokes, _loop_work, _long_loop_counted_loops, _long_loop_nests, _long_loop_candidates);\n+  tty->print_cr(\"PhaseIdealLoop=%d, sum _unique=%d, long loops=%d\/%d\/%d, conditional=%d\/%d\/%d\", _loop_invokes, _loop_work, _long_loop_counted_loops, _long_loop_nests, _long_loop_candidates, _loop_conditional_constants, _loop_conditional_test,  _loop_conditional_progress);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":45,"deletions":7,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -152,2 +152,2 @@\n-      in(1) != nullptr && phase->type(in(1)) != Type::TOP &&\n-      in(2) != nullptr && phase->type(in(2)) != Type::TOP;\n+      in(1) != nullptr && phase->type(in(1), in(1)) != Type::TOP &&\n+      in(2) != nullptr && phase->type(in(2), in(2)) != Type::TOP;\n@@ -592,0 +592,3 @@\n+  CountedLoopNode* inner_loop() const {\n+    return unique_ctrl_out()->as_CountedLoop();\n+  }\n@@ -617,0 +620,8 @@\n+\n+  OuterStripMinedLoopNode* outer_loop() const {\n+    return proj_out(true)->unique_ctrl_out()->as_OuterStripMinedLoop();\n+  }\n+\n+  CountedLoopNode* inner_loop() const {\n+    return outer_loop()->inner_loop();\n+  }\n@@ -974,10 +985,0 @@\n-  \/\/ Helper function for directing control inputs away from CFG split points.\n-  Node *find_non_split_ctrl( Node *ctrl ) const {\n-    if (ctrl != nullptr) {\n-      if (ctrl->is_MultiBranch()) {\n-        ctrl = ctrl->in(0);\n-      }\n-      assert(ctrl->is_CFG(), \"CFG\");\n-    }\n-    return ctrl;\n-  }\n@@ -1123,0 +1124,11 @@\n+  \/\/ Helper function for directing control inputs away from CFG split points.\n+  Node *find_non_split_ctrl( Node *ctrl ) const {\n+    if (ctrl != nullptr) {\n+      if (ctrl->is_MultiBranch()) {\n+        ctrl = ctrl->in(0);\n+      }\n+      assert(ctrl->is_CFG(), \"CFG\");\n+    }\n+    return ctrl;\n+  }\n+\n@@ -1755,0 +1767,3 @@\n+  static volatile int _loop_conditional_constants;\n+  static volatile int _loop_conditional_test;\n+  static volatile int _loop_conditional_progress;\n@@ -1836,0 +1851,2 @@\n+\n+  void conditional_elimination(VectorSet& visited, Node_Stack& nstack, Node_List& rpo_list, int rounds);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":29,"deletions":12,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -202,0 +202,7 @@\n+\n+const Type* OpaqueZeroTripGuardNode::Value(PhaseGVN* phase) const {\n+  if (phase->type(in(1)) == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  return bottom_type();\n+}\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+  virtual const Type* Value(PhaseGVN* phase) const;\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1470,21 +1470,0 @@\n-\/\/ Return counted loop Phi if as a counted loop exit condition, cmp\n-\/\/ compares the induction variable with n\n-static PhiNode* countedloop_phi_from_cmp(CmpNode* cmp, Node* n) {\n-  for (DUIterator_Fast imax, i = cmp->fast_outs(imax); i < imax; i++) {\n-    Node* bol = cmp->fast_out(i);\n-    for (DUIterator_Fast i2max, i2 = bol->fast_outs(i2max); i2 < i2max; i2++) {\n-      Node* iff = bol->fast_out(i2);\n-      if (iff->is_BaseCountedLoopEnd()) {\n-        BaseCountedLoopEndNode* cle = iff->as_BaseCountedLoopEnd();\n-        if (cle->limit() == n) {\n-          PhiNode* phi = cle->phi();\n-          if (phi != nullptr) {\n-            return phi;\n-          }\n-        }\n-      }\n-    }\n-  }\n-  return nullptr;\n-}\n-\n@@ -1540,1 +1519,1 @@\n-      Node* phi = countedloop_phi_from_cmp(use->as_Cmp(), n);\n+      Node* phi = use->as_Cmp()->countedloop_phi(n);\n@@ -2005,1 +1984,1 @@\n-void PhaseCCP::push_counted_loop_phi(Unique_Node_List& worklist, Node* parent, const Node* use) {\n+void PhaseCCP::push_counted_loop_phi(Unique_Node_List& worklist, const Node* parent, const Node* use) {\n@@ -2008,1 +1987,1 @@\n-    PhiNode* phi = countedloop_phi_from_cmp(use->as_Cmp(), parent);\n+    PhiNode* phi = use->as_Cmp()->countedloop_phi(parent);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":3,"deletions":24,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -288,0 +288,5 @@\n+\n+  \/\/ Type of n at control c: by default same type of n except for loop conditional propagation\n+  virtual const Type* type(const Node* n, Node* c) const {\n+    return type(n);\n+  }\n@@ -624,1 +629,1 @@\n-  static void push_counted_loop_phi(Unique_Node_List& worklist, Node* parent, const Node* use);\n+  static void push_counted_loop_phi(Unique_Node_List& worklist, const Node* parent, const Node* use);\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -682,0 +682,21 @@\n+\/\/ Return counted loop Phi if as a counted loop exit condition, cmp\n+\/\/ compares the induction variable with n\n+PhiNode* CmpNode::countedloop_phi(const Node* n) const {\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+    Node* bol = fast_out(i);\n+    for (DUIterator_Fast i2max, i2 = bol->fast_outs(i2max); i2 < i2max; i2++) {\n+      Node* iff = bol->fast_out(i2);\n+      if (iff->is_BaseCountedLoopEnd()) {\n+        BaseCountedLoopEndNode* cle = iff->as_BaseCountedLoopEnd();\n+        if (cle->limit() == n) {\n+          PhiNode* phi = cle->phi();\n+          if (phi != nullptr) {\n+            return phi;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -158,0 +158,1 @@\n+  PhiNode* countedloop_phi(const Node* n) const;\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1215,0 +1215,1 @@\n+  case Control:\n@@ -2510,1 +2511,1 @@\n-    if (_fields[i]->empty())  return true;\n+    if (!_fields[i]->empty())  return false;\n@@ -2512,1 +2513,1 @@\n-  return false;\n+  return true;\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -151,1 +151,2 @@\n-                    \"UseZvbb\"\n+                    \"UseZvbb\",\n+                    \"UseLoopConditionalPropagation\"\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8275202\n+ * @summary C2: optimize out more redundant conditions\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:-UseOnStackReplacement TestArrayAccessAboveRCAfterLoopConditionalPropagation\n+ *\/\n+\n+public class TestArrayAccessAboveRCAfterLoopConditionalPropagation {\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        int[] array = new int[10];\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(0, true, 0);\n+            test1(0, false, 0);\n+            test2(0, true, 0);\n+            test2(0, false, 0);\n+        }\n+        try {\n+            test1(-1, true, 0);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test2(-1, true, 0);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+    }\n+\n+    private static int test1(int i, boolean flag, int j) {\n+        int k;\n+        for (k = 0; k < 10; k++) {\n+        }\n+        int l;\n+        for (l = 1; l < 2; l *= 2) {\n+        }\n+        if (j == 44 - l ) {\n+        }\n+        int[] array = new int[100];\n+        int v = 0;\n+        if (flag) {\n+            if (i < 0) {\n+            }\n+            if (i >= 10) {\n+            }\n+            if (j == 42) {\n+            }\n+            v = array[i];\n+            volatileField = 42;\n+        } else {\n+            if (i < 0) {\n+            }\n+            if (i >= 10) {\n+            }\n+            if (j == 42) {\n+            }\n+            v = array[i];\n+            volatileField = 42;\n+        }\n+        return v;\n+    }\n+\n+    private static int test2(int i, boolean flag, int j) {\n+        int k;\n+        for (k = 0; k < 10; k++) {\n+        }\n+        int l;\n+        for (l = 1; l < 2; l *= 2) {\n+        }\n+        if (j == 44 - l ) {\n+        }\n+        int[] array = new int[1];\n+        int v = 0;\n+        if (flag) {\n+            if (i - 1 != -1) {\n+            }\n+            if (j == 42) {\n+            }\n+            \/\/ i - 1 = -1 (i == 0)\n+            \/\/ i <u 1 => i == 0\n+            v = array[i];\n+            volatileField = 42;\n+        } else {\n+            if (i - 1  != -1) {\n+            }\n+            if (j == 42) {\n+            }\n+            v = array[i];\n+            volatileField = 42;\n+        }\n+        return v;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopconditionalpropagation\/TestArrayAccessAboveRCAfterLoopConditionalPropagation.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8275202\n+ * @summary C2: optimize out more redundant conditions\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:-UseOnStackReplacement\n+ *                   -XX:CompileOnly=TestCMoveAndIf::test -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+StressIGVN -XX:StressSeed=314529597 -XX:+AbortVMOnCompilationFailure\n+ *                   -XX:+LoopConditionalPropagationALot TestCMoveAndIf\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:-UseOnStackReplacement\n+ *                   -XX:CompileOnly=TestCMoveAndIf::test -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+StressIGVN -XX:+AbortVMOnCompilationFailure\n+ *                   -XX:+LoopConditionalPropagationALot TestCMoveAndIf\n+ *\/\n+\n+\n+public class TestCMoveAndIf {\n+    private static volatile int barrier;\n+\n+    public static void main(String[] args) {\n+        int[] array = new int[1000];\n+        for (int i = 0; i < 20_000; i++) {\n+            test(-100);\n+            test(100);\n+            testHelper(1000, array);\n+        }\n+    }\n+\n+    private static void test(int stop) {\n+        int[] src = new int[8];\n+        if (stop > 6) {\n+            stop = 6;\n+        }\n+        stop = stop + 1;\n+        barrier = 0x42;\n+        if (stop <= 0) {\n+            stop = 0;\n+        }\n+        barrier = 0x42;\n+        testHelper(stop+1, src);\n+    }\n+\n+    private static void testHelper(int stop, int[] src) {\n+        for (int i = 0; i < stop; i += 2) {\n+            int v = src[i];\n+            if (v != 0) {\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopconditionalpropagation\/TestCMoveAndIf.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8275202\n+ * @summary C2: optimize out more redundant conditions\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:CompileOnly=TestConditionKillsRC::test -XX:LoopUnrollLimit=1000 TestConditionKillsRC\n+ *\/\n+\n+public class TestConditionKillsRC {\n+\n+    static volatile int barrier;\n+\n+    public static void main(String[] args) {\n+        byte[] array = new byte[1000];\n+        for (int i = 0; i < 20_000; i++) {\n+            test(16);\n+            testHelper(1000, array);\n+        }\n+    }\n+\n+    private static void test(int stop) {\n+        byte[] array = new byte[16];\n+        testHelper(stop, array);\n+    }\n+\n+    private static void testHelper(int stop, byte[] array) {\n+        for (int i = 0; i < stop; i++) {\n+            if (i < array.length) {\n+                if (i % 2 == 0) {\n+                    array[0] = 42;\n+                } else {\n+                    array[i] = 42;\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopconditionalpropagation\/TestConditionKillsRC.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8275202\n+ * @summary C2: optimize out more redundant conditions\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:-UseOnStackReplacement TestConstantFoldingAtTrap\n+ *\/\n+\n+public class TestConstantFoldingAtTrap {\n+    public static void main(String[] args) {\n+        int[] array = new int[2];\n+        for (int i = 0; i < 20_000; i++) {\n+            if (test1(array, true) != 2) {\n+                throw new RuntimeException();\n+            }\n+            if (test2(2, true) != 2) {\n+                throw new RuntimeException();\n+            }\n+        }\n+        array = new int[1];\n+        final int res = test1(array, false);\n+        if (res != 1) {\n+            throw new RuntimeException(\"Wrong result :\" + res);\n+        }\n+        if (test2(1, false) != 1) {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private static int test1(int[] array, boolean flag) {\n+        final int length = array.length;\n+        if (length <= 2) {\n+            int v = array[0]; \/\/ length = 0 at rc unc\n+            v += length;\n+            if (flag) {\n+                v += array[1]; \/\/ range check replaces dominating one\n+            }\n+            return v;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ Same without LoadRange node. Doesn't fail.\n+    private static int test2(int length, boolean flag) {\n+        int[] array = new int[length];\n+        length = array.length;\n+        if (length <= 2) {\n+            int v = array[0];\n+            v += length;\n+            if (flag) {\n+                v += array[1];\n+            }\n+            return v;\n+        }\n+        return 0;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopconditionalpropagation\/TestConstantFoldingAtTrap.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8275202\n+ * @summary C2: optimize out more redundant conditions\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:-UseOnStackReplacement\n+ *                   -XX:+LoopConditionalPropagationALot -XX:-UseLoopPredicate TestConstantIVAtEndOfMainLoop\n+ *\n+ *\n+ *\/\n+public class TestConstantIVAtEndOfMainLoop {\n+    private static volatile int volatileField;\n+    private static int field;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            final int res = test1(0, 0);\n+            if (res != 2 + 999) {\n+                throw new RuntimeException(res + \" != \" + 1001);\n+            }\n+        }\n+    }\n+\n+    private static int test1(int parallel_iv, int loop_invariant) {\n+        int l;\n+        for (l = 0; l < 10; l++) {\n+\n+        }\n+        l = l \/10;\n+        int k;\n+        for (k = 0; k < 10; k+=l) {\n+\n+        }\n+        k = k \/10;\n+        int j;\n+        for (j = 0; j < 10; j+=k) {\n+\n+        }\n+        j = j \/10;\n+        int m = 2;\n+        for (int i = 0; i < 1000; i+=k) {\n+            if ((k - 1) * i + loop_invariant != 0) {\n+\n+            }\n+            volatileField = parallel_iv;\n+            parallel_iv += m;\n+            volatileField = parallel_iv - (i + 1) * j;\n+            m = j;\n+        }\n+        return parallel_iv;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopconditionalpropagation\/TestConstantIVAtEndOfMainLoop.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8275202\n+ * @summary C2: optimize out more redundant conditions\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:-UseOnStackReplacement\n+ *                   -XX:CompileOnly=TestDivWithZeroScheduledEarly::test* -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+StressGCM -XX:StressSeed=77497032 -XX:+LoopConditionalPropagationALot TestDivWithZeroScheduledEarly\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:-UseOnStackReplacement\n+ *                   -XX:CompileOnly=TestDivWithZeroScheduledEarly::test* -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+StressGCM -XX:+LoopConditionalPropagationALot TestDivWithZeroScheduledEarly\n+ *\/\n+\n+public class TestDivWithZeroScheduledEarly {\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            inlined1(0, 0, 100, 1, 1000);\n+            inlined1(1, 0, 100, 1, 0);\n+            inlined1(100, 0, 100, 1, 0);\n+            test1(0, 100, 1, 0);\n+            inlined2(0, 0, 100, 1, 1000, 0);\n+            inlined2(1, 0, 100, 1, 0, 0);\n+            inlined2(100, 0, 100, 1, 0, 0);\n+            test2(0, 100, 1, 0, 0);\n+        }\n+    }\n+\n+    private static int test1(int start, int stop, int j, int early) {\n+        int l;\n+        for (l = 10; l > 0; l--) {\n+\n+        }\n+        return inlined1(l, start, stop, j, early);\n+    }\n+\n+    private static int inlined1(int k, int start, int stop, int j, int early) {\n+        int res = 0;\n+        for (int i = start; i < stop; i++) {\n+            int div = i \/ (i + j);\n+            if (i == early) {\n+                if (i + j == k) {\n+                    res += div;\n+                }\n+                break;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    private static int test2(int start, int stop, int j, int early, int l) {\n+        int k;\n+        for (k = 10; k > 0; k--) {\n+\n+        }\n+        return inlined2(k, start, stop, j, early, l);\n+    }\n+\n+    private static int inlined2(int k, int start, int stop, int j, int early, int l) {\n+        int res = 0;\n+        for (int i = start; i < stop; i++) {\n+            int div = i \/ (i + j - l);\n+            if (i == early) {\n+                if (i + j == k) {\n+                    res += div;\n+                }\n+                break;\n+            }\n+        }\n+        return res;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopconditionalpropagation\/TestDivWithZeroScheduledEarly.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8275202\n+ * @summary C2: optimize out more redundant conditions\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:-UseOnStackReplacement -XX:-TieredCompilation TestEliminatedRCCausesDeadCast\n+ *\/\n+\n+public class TestEliminatedRCCausesDeadCast {\n+    private static int intField = 10;\n+    static volatile int barrier;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(8, true);\n+            testhelper(11, false, 11);\n+            test2(8, true);\n+            testhelper2(11, false, 11);\n+        }\n+    }\n+\n+\n+    private static int test2(int j, boolean flag) {\n+        return testhelper2(j, flag, 8);\n+    }\n+\n+    private static int testhelper2(int j, boolean flag, int arraySize) {\n+        if (flag) {\n+            barrier = 0x42;\n+            return intField;\n+        } else {\n+            int i = 5;\n+            for (; i < 6; i *= 2);\n+            int[] array = new int[arraySize];\n+            if (j > arraySize) {\n+            }\n+            barrier = 0x42;\n+            \/\/ j = [min, 8]\n+            if (i < 0) {\n+            }\n+            barrier = 0x42;\n+            if (i >= j) {\n+            }\n+            barrier = 0x42;\n+            \/\/ i = [0, 7]\n+            int v = 0;\n+            for (int k = 1; k < arraySize; k *= 2) {\n+                array[k] = k;\n+                v += array[i];\n+            }\n+            return v;\n+        }\n+    }\n+\n+    private static int test1(int j, boolean flag) {\n+        return testhelper(j, flag, 8);\n+    }\n+\n+    private static int testhelper(int j, boolean flag, int arraySize) {\n+        if (flag) {\n+            barrier = 0x42;\n+            return intField;\n+        } else {\n+            int i = 5;\n+            for (; i < 6; i *= 2);\n+            int[] array = new int[arraySize];\n+            if (j > arraySize) {\n+            }\n+            barrier = 0x42;\n+            \/\/ j = [min, 8]\n+            if (i < 0) {\n+            }\n+            barrier = 0x42;\n+            if (i >= j) {\n+            }\n+            barrier = 0x42;\n+            \/\/ i = [0, 7]\n+            int v = array[i];\n+            return v;\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopconditionalpropagation\/TestEliminatedRCCausesDeadCast.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8275202\n+ * @summary C2: optimize out more redundant conditions\n+ * @run main\/othervm -XX:-BackgroundCompilation TestLSMDeadInLoopPredication\n+ *\/\n+\n+\n+public class TestLSMDeadInLoopPredication {\n+    private static volatile int barrier;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test(false, 100);\n+            testHelper(100, 1000);\n+            test2(false, 100);\n+            testHelper2(100, 1000);\n+        }\n+    }\n+\n+    private static void test(boolean flag, int stop) {\n+        for (int i = 0; i < 10; i++) {\n+            testHelper(stop, 1);\n+            if (i % 2 == 0) {\n+                if (flag) {\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void testHelper(int stop, int stop2) {\n+        int j = 0;\n+        for(;;) {\n+            synchronized (new Object()) {\n+            }\n+            barrier = 0x42;\n+            if (j+1 > stop2) {\n+                break;\n+            }\n+            j++;\n+            if (j >= stop) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    private static void test2(boolean flag, int stop) {\n+        for (int i = 0; i < 10; i++) {\n+            testHelper2(stop, 0);\n+            if (i % 2 == 0) {\n+                if (flag) {\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void testHelper2(int stop, int stop2) {\n+        int j = 0;\n+        for(;;) {\n+            synchronized (new Object()) {\n+            }\n+            barrier = 0x42;\n+            if (j > stop2) {\n+                break;\n+            }\n+            j++;\n+            if (j >= stop) {\n+                break;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopconditionalpropagation\/TestLSMDeadInLoopPredication.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,763 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopconditionalpropagation;\n+\n+import compiler.lib.ir_framework.*;\n+\n+import java.util.Objects;\n+\n+\/*\n+ * @test\n+ * @bug 8275202\n+ * @summary C2: optimize out more redundant conditions\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopconditionalpropagation.TestLoopConditionalPropagation\n+ *\/\n+\n+public class TestLoopConditionalPropagation {\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:+LoopConditionalPropagationALot\", \"-XX:-LoopUnswitching\", \"-XX:-RangeCheckElimination\", \"-XX:+UseLoopPredicate\");\n+        TestFramework.runWithFlags(\"-XX:+LoopConditionalPropagationALot\", \"-XX:-LoopUnswitching\", \"-XX:+RangeCheckElimination\", \"-XX:-UseLoopPredicate\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"1\"})\n+    @Arguments(values={Argument.NUMBER_42})\n+    @Warmup(10_000)\n+    private void test1(int i) {\n+        if (i < 42) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        if (i < 10) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"3\"})\n+    @Arguments(values={Argument.NUMBER_42, Argument.BOOLEAN_TOGGLE_FIRST_TRUE})\n+    @Warmup(10_000)\n+    private static void test2(int i, boolean flag) {\n+        if (flag) {\n+            if (i < 42) {\n+                throw new RuntimeException(\"never taken\");\n+            }\n+        } else {\n+            if (i < 42) {\n+                throw new RuntimeException(\"never taken\");\n+            }\n+        }\n+        if (i < 10) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+    }\n+\n+\n+    @DontInline\n+    private static void notInlined() {\n+\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"2\"})\n+    @Arguments(values={Argument.NUMBER_42, Argument.BOOLEAN_TOGGLE_FIRST_TRUE})\n+    @Warmup(10_000)\n+    private static void test3(int i, boolean flag) {\n+        if (flag) {\n+            if (i < 42) {\n+                throw new RuntimeException(\"never taken\");\n+            }\n+        } else {\n+            i = 100;\n+        }\n+        notInlined();\n+        if (i < 10) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+    }\n+\n+\n+    static volatile int volatileField;\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"3\"})\n+    @Arguments(values={Argument.NUMBER_42, Argument.NUMBER_42})\n+    @Warmup(10_000)\n+    private static void test4(int i, int k) {\n+        if (i < 42) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        for (int j = 1; j < 4; j *= 2) {\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            if (i < 10) {\n+                throw new RuntimeException(\"never taken\");\n+            }\n+            if (k < 42) {\n+                throw new RuntimeException(\"never taken\");\n+            }\n+            i = k;\n+        }\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"2\"})\n+    @IR(failOn = {IRNode.ADD_I, IRNode.MUL_I})\n+    @Arguments(values={Argument.NUMBER_42})\n+    @Warmup(10_000)\n+    private static int test5(int i) {\n+        if (i < 42) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        notInlined();\n+        if (i > 42) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        return (i + 5) * 100;\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"3\"})\n+    @Arguments(values={Argument.NUMBER_42, Argument.NUMBER_42, Argument.NUMBER_42})\n+    @Warmup(10_000)\n+    private static void test6(int i, int j, int k) {\n+        if (i < 42) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        if (j < i) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        if (k < j) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        if (k < 10) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"1\"})\n+    @Arguments(values={Argument.NUMBER_42})\n+    @Warmup(10_000)\n+    private static void test7(int i) {\n+        if (i < 0 || i >= 43) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        if (i < -1) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"1\"})\n+    @Arguments(values={Argument.NUMBER_42})\n+    @Warmup(10_000)\n+    private static void test8(int i) {\n+        if (i < 0 || i >= 43) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        if (i > 42) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"1\"})\n+    @Arguments(values={Argument.NUMBER_42})\n+    @Warmup(10_000)\n+    private static void test9(long i) {\n+        if (i < 42) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        if (i < 10) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"1\"})\n+    @Arguments(values={Argument.NUMBER_42})\n+    @Warmup(10_000)\n+    private static void test10(int i) {\n+        if (i - 1 <= 0) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        if (i == 0) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"1\"})\n+    @Arguments(values={Argument.BOOLEAN_TOGGLE_FIRST_TRUE, Argument.NUMBER_42})\n+    @Warmup(10_000)\n+    private static void test11(boolean flag, int i) {\n+        if (i - 1 <= 0) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        if (flag) {\n+            if (i == 0) {\n+                throw new RuntimeException(\"never taken\");\n+            }\n+        } else {\n+            if (i == 0) {\n+                throw new RuntimeException(\"never taken\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"2\"})\n+    @Arguments(values={Argument.NUMBER_42, Argument.NUMBER_42})\n+    @Warmup(10_000)\n+    private static void test12(int i, int j) {\n+        if (i < 42) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        \/\/ i >= 42\n+        if (i > j) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        \/\/ i <= j => j >= 42\n+        if (j < 10) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+    }\n+\n+    static volatile int barrier;\n+\n+    static class C {\n+        float field;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_I, \"2\"})\n+    private static int test13(int[] array, int i, C c, boolean flag) {\n+        int dummy = array[0];\n+        int v = 0;\n+        int j = 1;\n+\n+        for (; j < 2; j *= 2) ;\n+\n+        test13Helper(j, c);\n+\n+        if (flag) {\n+            if (array.length > 42) {\n+                if (i >= 0) {\n+                    if (i <= 42) {\n+                        float f = c.field;\n+                        v = array[i];\n+                    }\n+                }\n+            }\n+        } else {\n+            if (array.length > 42) {\n+                if (i >= 0) {\n+                    if (i <= 42) {\n+                        float f = c.field;\n+                        v = array[i];\n+                    }\n+                }\n+            }\n+        }\n+\n+        return v;\n+    }\n+\n+    @ForceInline\n+    private static void test13Helper(int j, C c) {\n+        if (j == 2) {\n+            float f = c.field;\n+        } else {\n+            barrier = 0x42;\n+        }\n+    }\n+\n+    @Run(test = \"test13\")\n+    @Warmup(10_000)\n+    public static void test13Runner() {\n+        C c = new C();\n+        test13Helper(42, c);\n+        test13Helper(2, c);\n+\n+        int[] array1 = new int[100];\n+        int[] array2 = new int[1];\n+        test13(array1, 0, c, true);\n+        test13(array1, 99, c, true);\n+        test13(array2, 0, c, true);\n+        test13(array1, 0, c, false);\n+        test13(array1, 99, c, false);\n+        test13(array2, 0, c, false);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"4\"})\n+    @Arguments(values={Argument.NUMBER_42, Argument.NUMBER_42, Argument.NUMBER_42})\n+    @Warmup(10_000)\n+    private static void test14(int i, int k, int l) {\n+        if (i < 42) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        for (int j = 1; j < 4; j *= 2) {\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            \/\/ i >= 42\n+            if (l < i) {\n+                throw new RuntimeException(\"never taken\");\n+            }\n+            \/\/ l >= 42\n+            if (l < 10) {\n+                throw new RuntimeException(\"never taken\");\n+            }\n+            if (k < 42) {\n+                throw new RuntimeException(\"never taken\");\n+            }\n+            i = k;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF, \"6\"})\n+    @Arguments(values={Argument.NUMBER_42, Argument.NUMBER_42, Argument.NUMBER_42, Argument.RANDOM_EACH})\n+    @Warmup(10_000)\n+    private static void test15(int i, int k, int l, boolean flag) {\n+        if (i < 42) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        for (int j = 1; j < 4; j *= 2) {\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            \/\/ i >= 42\n+            if (flag) {\n+                if (l < i) {\n+                    throw new RuntimeException(\"never taken\");\n+                }\n+            } else {\n+                if (l < i) {\n+                    throw new RuntimeException(\"never taken\");\n+                }\n+            }\n+            \/\/ l >= 42\n+            if (l < 10) {\n+                throw new RuntimeException(\"never taken\");\n+            }\n+            if (k < 42) {\n+                throw new RuntimeException(\"never taken\");\n+            }\n+            i = k;\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseLoopPredicate\", \"true\"}, failOn = {IRNode.COUNTED_LOOP})\n+    @IR(applyIf = {\"UseLoopPredicate\", \"false\"}, counts = {IRNode.COUNTED_LOOP, \"2\"}, failOn = {IRNode.COUNTED_LOOP_MAIN})\n+    private static float test16(int start, int stop) {\n+        float[] array = new float[1000];\n+        if (start < 0) {\n+\n+        }\n+        if (stop > 1000) {\n+\n+        }\n+        float v = 0;\n+        for (int i = start; i < stop; i++) {\n+            v = array[i];\n+        }\n+        return v;\n+    }\n+\n+    @Run(test = \"test16\")\n+    @Warmup(10_000)\n+    public static void test16Runner() {\n+        test16(0, 1000);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.COUNTED_LOOP})\n+    private static float test17(int start, int stop, boolean flag) {\n+        float[] array = new float[1000];\n+        float v = 0;\n+        if (start >= 0 && stop <=  1000) {\n+            for (int i = start; i < stop; i++) {\n+                if (flag) {\n+                    v = array[i];\n+                } else {\n+                    v = array[i];\n+                }\n+            }\n+        }\n+        return v;\n+    }\n+\n+    @Run(test = \"test17\")\n+    @Warmup(10_000)\n+    public static void test17Runner() {\n+        test17(0, 1000, true);\n+        test17(0, 1000, false);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.COUNTED_LOOP, IRNode.LONG_COUNTED_LOOP}, counts = {IRNode.LOOP, \"1\"})\n+    private static float test18(long start, long stop) {\n+        if (start < 0) {\n+\n+        }\n+        if (stop > 1000) {\n+\n+        }\n+        float v = 0;\n+        for (long i = start; i < stop; i++) {\n+            Objects.checkIndex(i, 1000);\n+        }\n+        return v;\n+    }\n+\n+    @Run(test = \"test18\")\n+    @Warmup(10_000)\n+    public static void test18Runner() {\n+        test18(0, 1000);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_I, \"1\"})\n+    private static int test19(int i) {\n+        int[] array = new int[10];\n+        if (i < 0) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        volatileField = 42;\n+        if (i >= 10) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        int v = 0;\n+        for (int j = 0; j < 100; j++) {\n+            v += array[i];\n+        }\n+        return v;\n+    }\n+\n+    @Run(test = \"test19\")\n+    @Warmup(10_000)\n+    public static void test19Runner() {\n+        test19(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopconditionalpropagation\/TestLoopConditionalPropagation.java","additions":763,"deletions":0,"binary":false,"changes":763,"status":"added"},{"patch":"@@ -0,0 +1,242 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8275202\n+ * @summary C2: optimize out more redundant conditions\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:-TieredCompilation -XX:-UseOnStackReplacement\n+ *                   -XX:CompileCommand=dontinline,compiler.loopconditionalpropagation.TestLoopPredicateAndConditionalElimination::notInlined1\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+LoopConditionalPropagationALot compiler.loopconditionalpropagation.TestLoopPredicateAndConditionalElimination\n+ *\/\n+\n+package compiler.loopconditionalpropagation;\n+\n+public class TestLoopPredicateAndConditionalElimination {\n+    private static volatile int volatileBarrier;\n+    private static float floatField;\n+\n+    public static void main(String[] args) {\n+        float[] array = new float[1000];\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(false, 0);\n+            inlined1(0, array, 42, true, 0);\n+            inlined1(0, array, 2, true, 0);\n+            test2(false, 0, 1000, 1000);\n+            inlined2(0, array, 42, true, 0, 1000, 1000);\n+            inlined2(0, array, 2, true, 0, 1000, 1000);\n+            test3(false, 0);\n+            inlined3(0, array, -42, true, 0);\n+            inlined3(0, array, 2, true, 0);\n+            test4(false, 0);\n+            inlined4(0, array, 42, true, 0);\n+            inlined4(0, array, 2, true, 0);\n+        }\n+    }\n+\n+    private static float test1(boolean flag, int other) {\n+        float[] array = new float[1000];\n+        notInlined1(array);\n+        int j = 1;\n+        for (; j < 2; j *= 2) {\n+        }\n+        int k = 1;\n+        for (; k < 2; k *= 2) {\n+        }\n+        final float v = inlined1(k - 3, array, j, flag, other);\n+        return v;\n+    }\n+\n+    private static float inlined1(int start, float[] array, int j, boolean flag, int other) {\n+        float v = 0;\n+        if (flag) {\n+            if (other < 0) {\n+            }\n+            volatileBarrier = 42;\n+            if (start < other) {\n+            }\n+            for (int i = start; i < 1000; i++) {\n+                v = array[i];\n+                if (j == 2) {\n+                    break;\n+                }\n+            }\n+        } else {\n+            volatileBarrier = 42;\n+            v = floatField;\n+        }\n+        return v;\n+    }\n+    private static float test2(boolean flag, int other, int stop, int other2) {\n+        float[] array = new float[1000];\n+        notInlined1(array);\n+        int j = 1;\n+        for (; j < 2; j *= 2) {\n+        }\n+        int k = 1;\n+        for (; k < 2; k *= 2) {\n+        }\n+        final float v = inlined2(k * 1000, array, j, flag, other, stop, other2);\n+        return v;\n+    }\n+\n+    private static float inlined2(int start, float[] array, int j, boolean flag, int other, int stop, int other2) {\n+        float v = 0;\n+        if (flag) {\n+            if (other < 0) {\n+            }\n+            if (start < other) {\n+            }\n+            if (other2 > 1000) {\n+            }\n+            if (stop > other2) {\n+            }\n+            if (start < stop) {\n+                int i = start;\n+                do {\n+                    synchronized (new Object()) {\n+                    }\n+                    v = array[i];\n+                    if (j == 2) {\n+                        break;\n+                    }\n+                    i++;\n+                } while (i < stop);\n+            } else {\n+                volatileBarrier = 42;\n+                v = floatField;\n+            }\n+        } else {\n+            volatileBarrier = 42;\n+            v = floatField;\n+        }\n+        return v;\n+    }\n+\n+    private static float test3(boolean flag, int other) {\n+        float[] array = new float[1000];\n+        notInlined1(array);\n+        int j = 1;\n+        for (; j < 2; j *= 2) {\n+        }\n+        int k = 1;\n+        for (; k < 2; k *= 2) {\n+        }\n+        final float v = inlined3(k - 3, array, j, flag, other);\n+        return v;\n+    }\n+\n+    private static int[] intArray = new int[10];\n+    private static int intField;\n+    private static int otherIntField;\n+    private static boolean[] boolArray = {true, false, true, false, true, false, true, false, true, false};\n+\n+    static class C {\n+        int intField;\n+    }\n+\n+    private static C c = new C();\n+\n+    private static float inlined3(int start, float[] array, int j, boolean flag, int other) {\n+        float v = 0;\n+        if (flag) {\n+            int k;\n+            int idx = 0;\n+            for (k = 0; k < 10; k++) {\n+                final boolean[] localBoolArray = boolArray;\n+                if (localBoolArray == null) {\n+                }\n+                if (localBoolArray[k]) {\n+                    idx = c.intField;\n+                } else {\n+                    idx = c.intField;\n+                }\n+                if (localBoolArray[(k + 1) %10]) {\n+                        otherIntField = 42;\n+                }\n+                idx = idx - c.intField;\n+            }\n+            if (other < 0) {\n+            }\n+            volatileBarrier = 42;\n+            if (start < other) {\n+            }\n+            if (start >= 1000) {\n+            }\n+            if (Long.compareUnsigned(((long) start) + idx, array.length) >= 0) {\n+\n+            }\n+            for (int i = start; i < 1000; i++) {\n+                v = array[i + idx];\n+                if (j == 2) {\n+                    break;\n+                }\n+            }\n+        } else {\n+            volatileBarrier = 42;\n+            v = floatField;\n+        }\n+        return v;\n+    }\n+\n+    private static float test4(boolean flag, int other) {\n+        float[] array = new float[1000];\n+        notInlined1(array);\n+        int j = 1;\n+        for (; j < 2; j *= 2) {\n+        }\n+        int k = 1;\n+        for (; k < 2; k *= 2) {\n+        }\n+        int l;\n+        for (l = 0; l < 10; l += k) {\n+\n+        }\n+        final float v = inlined4(l - 11, array, j, flag, other);\n+        return v;\n+    }\n+\n+    private static float inlined4(int start, float[] array, int j, boolean flag, int other) {\n+        float v = 0;\n+        if (flag) {\n+            if (other < 0) {\n+            }\n+            volatileBarrier = 42;\n+            if (start < other) {\n+            }\n+            for (int i = start; i < 1000; i++) {\n+                v = array[i];\n+                if (j == 2) {\n+                    break;\n+                }\n+            }\n+        } else {\n+            volatileBarrier = 42;\n+            v = floatField;\n+        }\n+        return v;\n+    }\n+\n+    private static void notInlined1(float[] array) {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopconditionalpropagation\/TestLoopPredicateAndConditionalElimination.java","additions":242,"deletions":0,"binary":false,"changes":242,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8275202\n+ * @summary C2: optimize out more redundant conditions\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:-UseOnStackReplacement\n+ *                   -XX:CompileOnly=TestOOBoundsArrayLoadScheduledEarly::test1 -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+StressGCM -XX:+LoopConditionalPropagationALot TestOOBoundsArrayLoadScheduledEarly\n+ *\/\n+\n+public class TestOOBoundsArrayLoadScheduledEarly {\n+\n+    public static void main(String[] args) {\n+        int[] array = new int[1000];\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(array, 0, 0);\n+            test1(array, 1, 0);\n+        }\n+        test1(array, Integer.MAX_VALUE,  -Integer.MAX_VALUE);\n+    }\n+\n+    private static int test1(int[] array, int i, int j) {\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+        i = Math.max(i, 0);\n+        int v = array[i + j];\n+        if (i == 0) {\n+            return v;\n+        }\n+        return 0;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopconditionalpropagation\/TestOOBoundsArrayLoadScheduledEarly.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8275202\n+ * @summary C2: optimize out more redundant conditions\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:-UseOnStackReplacement -XX:CompileOnly=TestOverUnrolled::test -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN -XX:StressSeed=1183221360 TestOverUnrolled\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:-UseOnStackReplacement -XX:CompileOnly=TestOverUnrolled::test -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN TestOverUnrolled\n+ *\/\n+\n+public class TestOverUnrolled {\n+    public static void main(String[] args) {\n+        int[] array = new int[1000];\n+        for (int i = 0; i < 20_000; i++) {\n+            test(8);\n+            testHelper(1000, array);\n+        }\n+    }\n+\n+    private static void test(int stop) {\n+        int[] src = new int[8];\n+        if (stop > 8 || stop < 0) {\n+        }\n+        testHelper(stop, src);\n+    }\n+\n+    private static void testHelper(int stop, int[] src) {\n+        for (int i = 0; i < stop; i += 2) {\n+            int v = src[i];\n+            if (v != 0) {\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopconditionalpropagation\/TestOverUnrolled.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -67,1 +67,1 @@\n-    @IR(counts = {IRNode.IF, \"4\"})\n+    @IR(counts = {IRNode.IF, \"3\"})\n@@ -77,1 +77,1 @@\n-    @IR(counts = {IRNode.IF, \"4\"})\n+    @IR(counts = {IRNode.IF, \"3\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/TestPredicatesBasic.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}