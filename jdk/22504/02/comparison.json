{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @LastModified: May 2022\n+ * @LastModified: Dec 2024\n@@ -1200,1 +1200,4 @@\n-          \"Use of the extension element ''{0}'' is not allowed when the secure processing feature is set to true.\"},\n+        \"Use of the extension function ''{0}'' is not allowed when extension \"\n+              + \"functions are disabled by the secure processing feature or \"\n+              + \"the property ''jdk.xml.enableExtensionFunctions''. \"\n+              + \"To enable extension functions, set ''jdk.xml.enableExtensionFunctions'' to ''true''.\"},\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/res\/XSLTErrorResources.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n- * @LastModified: Nov 2017\n+ * @LastModified: Dec 2024\n@@ -961,1 +961,1 @@\n-    private List<Method> findMethods() {\n+    private List<Method> findMethods() throws TypeCheckError {\n@@ -963,2 +963,2 @@\n-          List<Method> result = null;\n-          final String namespace = _fname.getNamespace();\n+        List<Method> result = null;\n+        final String namespace = _fname.getNamespace();\n@@ -966,1 +966,1 @@\n-          if (_className != null && _className.length() > 0) {\n+        if (_className != null && _className.length() > 0) {\n@@ -974,8 +974,13 @@\n-                    \/\/Check if FSP and SM - only then process with loading\n-                    if (namespace != null && isSecureProcessing\n-                            && isExtensionFunctionEnabled\n-                            && (namespace.startsWith(JAVA_EXT_XALAN)\n-                            || namespace.startsWith(JAVA_EXT_XSLTC)\n-                            || namespace.startsWith(JAVA_EXT_XALAN_OLD)\n-                            || namespace.startsWith(XALAN_CLASSPACKAGE_NAMESPACE))) {\n-                        _clazz = getXSLTC().loadExternalFunction(_className);\n+                    \/\/ the property has the precedence\n+                    if (isExtensionFunctionEnabled) {\n+                        if (getXSLTC().hasExtensionClassLoader()) {\n+                            _clazz = getXSLTC().loadExternalFunction(_className);\n+                        } else {\n+                            _clazz = ObjectFactory.findProviderClass(_className, true);\n+                        }\n+                        if (_clazz == null) {\n+                            final ErrorMsg msg\n+                                    = new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, _className);\n+                            getParser().reportError(Constants.ERROR, msg);\n+                            return null;\n+                        }\n@@ -983,1 +988,1 @@\n-                        _clazz = ObjectFactory.findProviderClass(_className, true);\n+                        throw new TypeCheckError(ErrorMsg.UNSUPPORTED_EXT_FUNC_ERR, _className);\n@@ -985,5 +990,0 @@\n-\n-                if (_clazz == null) {\n-                  final ErrorMsg msg =\n-                        new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, _className);\n-                  getParser().reportError(Constants.ERROR, msg);\n@@ -991,16 +991,15 @@\n-              }\n-\n-              final String methodName = _fname.getLocalPart();\n-              final Method[] methods = _clazz.getMethods();\n-\n-              for (int i = 0; i < methods.length; i++) {\n-                final int mods = methods[i].getModifiers();\n-                \/\/ Is it public and same number of args ?\n-                if (Modifier.isPublic(mods)\n-                    && methods[i].getName().equals(methodName)\n-                    && methods[i].getParameterTypes().length == nArgs)\n-                {\n-                  if (result == null) {\n-                    result = new ArrayList<>();\n-                  }\n-                  result.add(methods[i]);\n+\n+                final String methodName = _fname.getLocalPart();\n+                final Method[] methods = _clazz.getMethods();\n+\n+                for (int i = 0; i < methods.length; i++) {\n+                    final int mods = methods[i].getModifiers();\n+                    \/\/ Is it public and same number of args ?\n+                    if (Modifier.isPublic(mods)\n+                            && methods[i].getName().equals(methodName)\n+                            && methods[i].getParameterTypes().length == nArgs) {\n+                        if (result == null) {\n+                            result = new ArrayList<>();\n+                        }\n+                        result.add(methods[i]);\n+                    }\n@@ -1008,5 +1007,3 @@\n-              }\n-            }\n-            catch (ClassNotFoundException e) {\n-                  final ErrorMsg msg = new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, _className);\n-                  getParser().reportError(Constants.ERROR, msg);\n+            } catch (ClassNotFoundException e) {\n+                final ErrorMsg msg = new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, _className);\n+                getParser().reportError(Constants.ERROR, msg);\n@@ -1014,2 +1011,2 @@\n-          }\n-          return result;\n+        }\n+        return result;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/compiler\/FunctionCall.java","additions":40,"deletions":43,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n- * @LastModified: Jan 2022\n+ * @LastModified: Dec 2024\n@@ -294,0 +294,4 @@\n+    boolean hasExtensionClassLoader() {\n+        return _extensionClassLoader != null;\n+    }\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/compiler\/XSLTC.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @LastModified: Nov 2024\n+ * @LastModified: Dec 2024\n@@ -555,0 +555,9 @@\n+        \/*\n+         * Note to translators:  property name \"jdk.xml.enableExtensionFunctions\"\n+         * and value \"true\" should not be translated.\n+         *\/\n+        {ErrorMsg.UNSUPPORTED_EXT_FUNC_ERR,\n+        \"Use of the extension function ''{0}'' is not allowed when extension \"\n+              + \"functions are disabled by the secure processing feature or \"\n+              + \"the property ''jdk.xml.enableExtensionFunctions''. \"\n+              + \"To enable extension functions, set ''jdk.xml.enableExtensionFunctions'' to ''true''.\"},\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/compiler\/util\/ErrorMessages.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * @LastModified: Nov 2024\n+ * @LastModified: Dec 2024\n@@ -108,0 +108,1 @@\n+    public static final String UNSUPPORTED_EXT_FUNC_ERR = \"UNSUPPORTED_EXT_FUNC_ERR\";\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/compiler\/util\/ErrorMsg.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,2 +2,1 @@\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +27,1 @@\n+ * @LastModified: Dec 2024\n@@ -278,1 +278,4 @@\n-        \"Use of the extension function ''{0}'' is not allowed when the secure processing feature is set to true.\"},\n+        \"Use of the extension function ''{0}'' is not allowed when extension \"\n+              + \"functions are disabled by the secure processing feature or \"\n+              + \"the property ''jdk.xml.enableExtensionFunctions''. \"\n+              + \"To enable extension functions, set ''jdk.xml.enableExtensionFunctions'' to ''true''.\"},\n@@ -281,1 +284,4 @@\n-        \"Use of the extension element ''{0}'' is not allowed when the secure processing feature is set to true.\"},\n+        \"Use of the extension element ''{0}'' is not allowed when extension \"\n+              + \"functions are disabled by the secure processing feature or \"\n+              + \"the property ''jdk.xml.enableExtensionFunctions''. \"\n+              + \"To enable extension functions, set ''jdk.xml.enableExtensionFunctions'' to ''true''.\"},\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/runtime\/ErrorMessages.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -78,1 +78,0 @@\n-import jdk.xml.internal.SecuritySupport;\n@@ -91,1 +90,1 @@\n- * @LastModified: Nov 2024\n+ * @LastModified: Dec 2024\n@@ -219,1 +218,1 @@\n-    private boolean _isNotSecureProcessing = true;\n+    private boolean _isNotSecureProcessing = false;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/trax\/TransformerFactoryImpl.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,1 @@\n- * @LastModified: July 2023\n+ * @LastModified: Dec 2024\n@@ -209,1 +209,1 @@\n-    private boolean _isSecureProcessing = false;\n+    private boolean _isSecureProcessing = true;\n@@ -295,0 +295,1 @@\n+        _isSecureProcessing = _tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/trax\/TransformerImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-                null, null, true, false, true, true),\n+                null, null, false, false, true, true),\n@@ -385,7 +385,1 @@\n-            if (!getSystemProperty(feature, feature.systemProperty())) {\n-                \/\/if system property is not found, try the older form if any\n-                String oldName = feature.systemPropertyOld();\n-                if (oldName != null) {\n-                    getSystemProperty(feature, oldName);\n-                }\n-            }\n+            getSystemProperty(feature, feature.systemProperty());\n@@ -405,0 +399,5 @@\n+            if (value == null && feature.systemPropertyOld() != null) {\n+                \/\/ legacy system property\n+                value = System.getProperty(feature.systemPropertyOld());\n+            }\n+\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/JdkXmlFeatures.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -60,3 +60,2 @@\n-# The value type is boolean and the default value is true (allowing\n-# extension functions). The following entry overrides the default value and\n-# disallows extension functions:\n+# The value type is boolean and the default value is false (disallowing\n+# extension functions).\n@@ -64,1 +63,1 @@\n-# jdk.xml.enableExtensionFunctions=false\n+jdk.xml.enableExtensionFunctions=false\n","filename":"src\/java.xml\/share\/conf\/jaxp.properties","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+import org.testng.Assert;\n@@ -63,0 +64,3 @@\n+    public static final String CLS_DIR = System.getProperty(\"test.classes\");\n+    public static final String SRC_DIR = System.getProperty(\"test.src\");\n+    public static final boolean isWindows = System.getProperty(\"os.name\").contains(\"Windows\");\n@@ -376,0 +380,28 @@\n+    \/**\n+     * Asserts the run does not cause a Throwable. May be replaced with JUnit 5.\n+     * @param runnable the runnable\n+     * @param message the message if the test fails\n+     *\/\n+    public static void assertDoesNotThrow(Assert.ThrowingRunnable runnable, String message) {\n+        try {\n+            runnable.run();\n+        } catch (Throwable t) {\n+            Assert.fail(message + \"\\n Exception thrown: \" + t.getMessage());\n+        }\n+    }\n+\n+    \/**\n+     * Returns the System identifier (URI) of the source.\n+     * @param path the path to the source\n+     * @return the System identifier\n+     *\/\n+    public static String getSystemId(String path) {\n+        if (path == null) return null;\n+        String xmlSysId = \"file:\/\/\" + path;\n+        if (isWindows) {\n+            path = path.replace('\\\\', '\/');\n+            xmlSysId = \"file:\/\/\/\" + path;\n+        }\n+        return xmlSysId;\n+    }\n+\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/libs\/jaxp\/library\/JAXPTestUtilities.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-        {\"true\", \"false\", \"continue\", \"allow\", \"2500\", \"100000\",\n+        {\"false\", \"false\", \"continue\", \"allow\", \"2500\", \"100000\",\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/ImplProperties.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import org.testng.annotations.BeforeClass;\n@@ -42,1 +41,1 @@\n- * @bug 6513892\n+ * @bug 6513892 8343001\n@@ -48,6 +47,0 @@\n-    @BeforeClass\n-    public void setup(){\n-        if (System.getSecurityManager() != null)\n-            System.setSecurityManager(null);\n-    }\n-\n@@ -58,0 +51,1 @@\n+            tf.setFeature(\"jdk.xml.enableExtensionFunctions\", true);\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/transform\/Bug6513892.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n- * @bug 8157830 8228854\n+ * @bug 8157830 8228854 8343001\n@@ -55,1 +55,1 @@\n- * @run testng\/othervm transform.ErrorListenerTest\n+ * @run testng\/othervm -Djdk.xml.enableExtensionFunctions=true transform.ErrorListenerTest\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/transform\/ErrorListenerTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.io.InputStream;\n@@ -28,1 +27,0 @@\n-\n@@ -31,1 +29,0 @@\n-import javax.xml.transform.TransformerConfigurationException;\n@@ -36,1 +33,3 @@\n-\n+import static jaxp.library.JAXPTestUtilities.SRC_DIR;\n+import static jaxp.library.JAXPTestUtilities.assertDoesNotThrow;\n+import static jaxp.library.JAXPTestUtilities.getSystemId;\n@@ -38,0 +37,1 @@\n+import org.testng.annotations.DataProvider;\n@@ -39,0 +39,1 @@\n+import static transform.XSLTFunctionsTest.SP_ENABLE_EXTENSION_FUNCTION_SPEC;\n@@ -42,0 +43,1 @@\n+ * @bug 8343001 8343001\n@@ -44,1 +46,2 @@\n- * @summary Test XSLT shall report TransformerException for unsafe xsl when FEATURE_SECURE_PROCESSING is true.\n+ * @summary Verifies that XSLT reports TransformerException as it processes xsl\n+ * using extension functions while FEATURE_SECURE_PROCESSING is set to true.\n@@ -47,4 +50,8 @@\n-    @Test\n-    public void testSecureProcessing() {\n-        boolean _isSecureMode = System.getSecurityManager() != null;\n-        \/\/ SECURE_PROCESSING == false\n+    \/**\n+     * Test state\n+     *\/\n+    public static enum TestState {\n+        DEFAULT,  \/\/ the default state\n+        SETFSP,   \/\/ set FEATURE_SECURE_PROCESSING\n+        SETPROPERTY; \/\/ set the enalbeExtensionFunctions property\n+    }\n@@ -52,3 +59,49 @@\n-        \/\/ the style sheet\n-        InputStream xslStream = this.getClass().getResourceAsStream(\"SecureProcessingTest.xsl\");\n-        StreamSource xslSource = new StreamSource(xslStream);\n+    @DataProvider(name = \"extFunc\")\n+    public Object[][] getExtFuncSettings() throws Exception {\n+        return new Object[][] {\n+            \/\/ by default, Extension Functions are disallowed\n+            { TestState.DEFAULT, true, null, false, TransformerException.class},\n+            \/\/ set FSP=true, Extension Functions are disallowed\n+            { TestState.SETFSP, true, null, false, TransformerException.class},\n+            \/\/ turning off FSP does not enable Extension Functions\n+            { TestState.SETFSP, false, null, false, TransformerException.class},\n+            \/\/ between FSP and the Extension Functions property (jdk.xml.enableExtensionFunctions),\n+            \/\/ the later takes precedence\n+            { TestState.SETPROPERTY, true, SP_ENABLE_EXTENSION_FUNCTION_SPEC, false, TransformerException.class},\n+            { TestState.SETPROPERTY, true, SP_ENABLE_EXTENSION_FUNCTION_SPEC, true, null},\n+        };\n+    }\n+    \/**\n+     * Verifies the effect of FEATURE_SECURE_PROCESSING (FSP) and the precedence\n+     * between FSP and the Extension Functions property.\n+     *\n+     * @param testState the state of the test\n+     * @param fspValue the FSP value to be set\n+     * @param property the Extension Functions property\n+     * @param propertyValue the property value\n+     * @param expectedThrow the expected throw if the specified DTD can not be\n+     *                      resolved.\n+     * @throws Exception if the test fails\n+     *\/\n+    @Test(dataProvider = \"extFunc\")\n+    public void testFSP(TestState testState, boolean fspValue, String property,\n+            boolean propertyValue, Class<Throwable> expectedThrow)\n+            throws Exception {\n+        final TransformerFactory tf = TransformerFactory.newInstance();\n+        switch (testState) {\n+            case DEFAULT:\n+                break;\n+            case SETFSP:\n+                tf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, fspValue);\n+                break;\n+            case SETPROPERTY:\n+                tf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, fspValue);\n+                tf.setFeature(property, propertyValue);\n+                break;\n+        }\n+        if (expectedThrow == null) {\n+            assertDoesNotThrow(() -> runTransform(tf), \"Unexpected exception.\");\n+        } else {\n+            Assert.assertThrows(expectedThrow, () -> runTransform(tf));\n+        }\n+    }\n@@ -56,3 +109,4 @@\n-        \/\/ the xml source\n-        InputStream xmlStream = this.getClass().getResourceAsStream(\"SecureProcessingTest.xml\");\n-        StreamSource xmlSource = new StreamSource(xmlStream);\n+    private void runTransform(TransformerFactory tf)\n+            throws Exception {\n+        StreamSource xslSource = new StreamSource(getSystemId(SRC_DIR + \"\/SecureProcessingTest.xsl\"));\n+        StreamSource xmlSource = new StreamSource(getSystemId(SRC_DIR + \"\/SecureProcessingTest.xml\"));\n@@ -63,72 +117,2 @@\n-\n-        \/\/ the transformer\n-        TransformerFactory transformerFactory = null;\n-        Transformer transformer = null;\n-\n-        \/\/ transform with a non-secure Transformer\n-        \/\/ expect success\n-        String xmlResult;\n-        if (!_isSecureMode) { \/\/ jaxp secure feature can not be turned off when\n-                              \/\/ security manager is present\n-            try {\n-                transformerFactory = TransformerFactory.newInstance();\n-                transformerFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, false);\n-                transformer = transformerFactory.newTransformer(xslSource);\n-                transformer.transform(xmlSource, xmlResultStream);\n-            } catch (TransformerConfigurationException ex) {\n-                ex.printStackTrace();\n-                Assert.fail(ex.toString());\n-            } catch (TransformerException ex) {\n-                ex.printStackTrace();\n-                Assert.fail(ex.toString());\n-            }\n-\n-            \/\/ expected success\n-            \/\/ and the result is ...\n-            xmlResult = xmlResultString.toString();\n-            System.out.println(\"Transformation result (SECURE_PROCESSING == false) = \\\"\" + xmlResult + \"\\\"\");\n-        }\n-\n-        \/\/ now do same transformation but with SECURE_PROCESSING == true\n-        \/\/ expect Exception\n-        boolean exceptionCaught = false;\n-\n-        \/\/ the style sheet\n-        xslStream = this.getClass().getResourceAsStream(\"SecureProcessingTest.xsl\");\n-        xslSource = new StreamSource(xslStream);\n-\n-        \/\/ the xml source\n-        xmlStream = this.getClass().getResourceAsStream(\"SecureProcessingTest.xml\");\n-        xmlSource = new StreamSource(xmlStream);\n-\n-        \/\/ the xml result\n-        xmlResultString = new StringWriter();\n-        xmlResultStream = new StreamResult(xmlResultString);\n-\n-        \/\/ the transformer\n-        transformerFactory = null;\n-        transformer = null;\n-\n-        \/\/ transform with a secure Transformer\n-        try {\n-            transformerFactory = TransformerFactory.newInstance();\n-            transformerFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n-            transformer = transformerFactory.newTransformer(xslSource);\n-            transformer.transform(xmlSource, xmlResultStream);\n-        } catch (TransformerConfigurationException ex) {\n-            ex.printStackTrace();\n-            Assert.fail(ex.toString());\n-        } catch (TransformerException ex) {\n-            \/\/ expected failure\n-            System.out.println(\"expected failure: \" + ex.toString());\n-            ex.printStackTrace(System.out);\n-            exceptionCaught = true;\n-        }\n-\n-        \/\/ unexpected success?\n-        if (!exceptionCaught) {\n-            \/\/ and the result is ...\n-            xmlResult = xmlResultString.toString();\n-            System.err.println(\"Transformation result (SECURE_PROCESSING == true) = \\\"\" + xmlResult + \"\\\"\");\n-            Assert.fail(\"SECURITY_PROCESSING == true, expected failure but got result: \\\"\" + xmlResult + \"\\\"\");\n-        }\n+        Transformer transformer = tf.newTransformer(xslSource);\n+        transformer.transform(xmlSource, xmlResultStream);\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/transform\/SecureProcessingTest.java","additions":71,"deletions":87,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.io.FilePermission;\n@@ -39,0 +38,4 @@\n+import static jaxp.library.JAXPTestUtilities.SRC_DIR;\n+import static jaxp.library.JAXPTestUtilities.assertDoesNotThrow;\n+import static jaxp.library.JAXPTestUtilities.getSystemId;\n+import static jaxp.library.JAXPTestUtilities.getSystemProperty;\n@@ -40,0 +43,1 @@\n+import static org.testng.Assert.assertEquals;\n@@ -42,4 +46,0 @@\n-import static org.testng.Assert.assertEquals;\n-import static jaxp.library.JAXPTestUtilities.clearSystemProperty;\n-import static jaxp.library.JAXPTestUtilities.setSystemProperty;\n-import static jaxp.library.JAXPTestUtilities.getSystemProperty;\n@@ -49,0 +49,1 @@\n+ * @bug 8062518 8153082 8165116 8343001\n@@ -56,0 +57,15 @@\n+    @DataProvider(name = \"propertyName\")\n+    public static Object[][] getSettings() {\n+        return new Object[][] {\n+            \/\/ legacy property name\n+            {ORACLE_ENABLE_EXTENSION_FUNCTION, true, true, null},\n+            {ORACLE_ENABLE_EXTENSION_FUNCTION, true, false, TransformerException.class},\n+            \/\/ legacy system property name\n+            {SP_ENABLE_EXTENSION_FUNCTION, false, true, null},\n+            {SP_ENABLE_EXTENSION_FUNCTION, false, false, TransformerException.class},\n+            \/\/ current property and system property name\n+            {SP_ENABLE_EXTENSION_FUNCTION_SPEC, true, true, null},\n+            {SP_ENABLE_EXTENSION_FUNCTION_SPEC, true, false, TransformerException.class},\n+        };\n+    }\n+\n@@ -89,3 +105,9 @@\n-     * @bug 8161454\n-     * Verifies that the new \/ correct name is supported, as is the old \/ incorrect\n-     * one for compatibility\n+     * @bug 8161454 8343001\n+     * Verifies that legacy property names are continually supported for compatibility.\n+     *\n+     * @param property the property name\n+     * @param isAPIProperty indicates whether the property can be set via the factory\n+     * @param value the property value\n+     * @param expectedThrow the expected throw if the specified DTD can not be\n+     *                      resolved.\n+     * @throws Exception if the test fails\n@@ -93,37 +115,7 @@\n-    @Test\n-    public void testNameChange() {\n-\n-        boolean feature;\n-        TransformerFactory tf = TransformerFactory.newInstance();\n-        feature = tf.getFeature(ORACLE_ENABLE_EXTENSION_FUNCTION);\n-        System.out.println(\"Default setting: \" + feature);\n-        \/\/ The default: true if no SecurityManager, false otherwise\n-        Assert.assertTrue(feature == getDefault());\n-\n-        setSystemProperty(SP_ENABLE_EXTENSION_FUNCTION, getDefaultOpposite());\n-        tf = TransformerFactory.newInstance();\n-        feature = tf.getFeature(ORACLE_ENABLE_EXTENSION_FUNCTION);\n-        System.out.println(\"After setting \" + SP_ENABLE_EXTENSION_FUNCTION + \": \" + feature);\n-        clearSystemProperty(SP_ENABLE_EXTENSION_FUNCTION);\n-        \/\/ old\/incorrect name is still supported\n-        Assert.assertTrue(feature != getDefault());\n-\n-        setSystemProperty(SP_ENABLE_EXTENSION_FUNCTION_SPEC, getDefaultOpposite());\n-        tf = TransformerFactory.newInstance();\n-        feature = tf.getFeature(ORACLE_ENABLE_EXTENSION_FUNCTION);\n-        System.out.println(\"After setting \" + SP_ENABLE_EXTENSION_FUNCTION_SPEC + \": \" + feature);\n-        clearSystemProperty(SP_ENABLE_EXTENSION_FUNCTION_SPEC);\n-        \/\/ new\/correct name is effective\n-        Assert.assertTrue(feature != getDefault());\n-    }\n-\n-    final boolean isSecure;\n-    {\n-        String runSecMngr = getSystemProperty(\"runSecMngr\");\n-        isSecure = runSecMngr != null && runSecMngr.equals(\"true\");\n-    }\n-\n-    \/\/ The default: true if no SecurityManager, false otherwise\n-    private boolean getDefault() {\n-        if (isSecure) {\n-            return false;\n+    @Test(dataProvider = \"propertyName\")\n+    public void testNameChange(String property, boolean isAPIProperty,\n+            boolean value, Class<Throwable> expectedThrow)\n+            throws Exception {\n+        if (expectedThrow == null) {\n+            assertDoesNotThrow(() -> runTransform(property, isAPIProperty, value),\n+                    \"Extension Functions property is set to \" + value + \" but exception is thrown.\");\n@@ -131,1 +123,2 @@\n-            return true;\n+            Assert.assertThrows(expectedThrow,\n+                () -> runTransform(property, isAPIProperty, value));\n@@ -135,6 +128,19 @@\n-    \/\/ Gets a String value that is opposite to the default value\n-    private String getDefaultOpposite() {\n-        if (isSecure) {\n-            return \"true\";\n-        } else {\n-            return \"false\";\n+    private void runTransform(String property, boolean isAPIProperty, boolean value)\n+            throws Exception {\n+        StreamSource xslSource = new StreamSource(getSystemId(SRC_DIR + \"\/SecureProcessingTest.xsl\"));\n+        StreamSource xmlSource = new StreamSource(getSystemId(SRC_DIR + \"\/SecureProcessingTest.xml\"));\n+\n+        \/\/ the xml result\n+        StringWriter xmlResultString = new StringWriter();\n+        StreamResult xmlResultStream = new StreamResult(xmlResultString);\n+\n+        if (!isAPIProperty) {\n+            System.setProperty(property, Boolean.toString(value));\n+        }\n+        TransformerFactory tf = TransformerFactory.newInstance();\n+        if (isAPIProperty) {\n+            tf.setFeature(property, value);\n+        }\n+        Transformer transformer = tf.newTransformer(xslSource);\n+        if (!isAPIProperty) {\n+            System.clearProperty(property);\n@@ -142,0 +148,1 @@\n+        transformer.transform(xmlSource, xmlResultStream);\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/transform\/XSLTFunctionsTest.java","additions":59,"deletions":52,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8032908 8081392\n+ * @bug 8032908 8081392 8343001\n@@ -31,1 +31,1 @@\n- * @run main\/othervm XSLT\n+ * @run main\/othervm -Djdk.xml.enableExtensionFunctions=true XSLT\n","filename":"test\/jdk\/javax\/xml\/jaxp\/common\/8032908\/XSLT.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8024707\n+ * @bug 8024707 8343001\n@@ -29,1 +29,1 @@\n- * @run main\/othervm XSLT\n+ * @run main\/othervm -Djdk.xml.enableExtensionFunctions=true XSLT\n","filename":"test\/jdk\/javax\/xml\/jaxp\/parsers\/8024707\/XSLT.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @bug 8004476\n+ * @bug 8004476 8343001\n@@ -80,1 +80,1 @@\n-     * by default, extension function is enabled\n+     * As of JDK-8343001, extension function is disabled by default.\n@@ -87,1 +87,0 @@\n-            System.out.println(\"testExtFunc: OK\");\n@@ -91,1 +90,2 @@\n-            fail(ex.getMessage());\n+            \/\/expected since extension function is disallowed\n+            System.out.println(\"testExtFunc: OK\");\n","filename":"test\/jdk\/javax\/xml\/jaxp\/transform\/8004476\/XSLTExFuncTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}