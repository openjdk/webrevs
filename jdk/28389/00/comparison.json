{"files":[{"patch":"@@ -4189,0 +4189,26 @@\n+#ifdef ASSERT\n+\n+\/\/ Clone Template Assertion Predicates to a target loop. The target loop is the original, not-cloned loop.\n+\/\/ This is currently only used for StressDuplicateLoopBackedge.\n+class CloneAssertionPredicatesVisitor : public PredicateVisitor {\n+  ClonePredicateToTargetLoop _clone_predicate_to_loop;\n+  PhaseIdealLoop* const _phase;\n+\n+public:\n+  CloneAssertionPredicatesVisitor(LoopNode* target_loop_head,\n+                                 const NodeInSingleLoopBody &node_in_loop_body,\n+                                 PhaseIdealLoop* phase)\n+    : _clone_predicate_to_loop(target_loop_head, node_in_loop_body, phase),\n+      _phase(phase) {\n+  }\n+  NONCOPYABLE(CloneAssertionPredicatesVisitor);\n+\n+  using PredicateVisitor::visit;\n+\n+  void visit(const TemplateAssertionPredicate& template_assertion_predicate) override {\n+    _clone_predicate_to_loop.clone_template_assertion_predicate(template_assertion_predicate);\n+    template_assertion_predicate.kill(_phase->igvn());\n+  }\n+};\n+\n+#endif \/\/ ASSERT\n@@ -4257,0 +4283,1 @@\n+#ifdef ASSERT\n@@ -4275,1 +4302,3 @@\n-  } else {\n+  } else\n+#endif \/\/ASSERT\n+  {\n@@ -4466,0 +4495,11 @@\n+#ifdef ASSERT\n+  if (StressDuplicateBackedge && head->is_CountedLoop()) {\n+    \/\/ The Template Assertion Predicates from the old counted loop are now at the new outer loop - clone them to\n+    \/\/ the inner counted loop and kill the old ones.\n+    PredicateIterator predicate_iterator(outer_head->in(LoopNode::EntryControl));\n+    NodeInSingleLoopBody node_in_body(this, loop);\n+    CloneAssertionPredicatesVisitor clone_assertion_predicates_visitor(head, node_in_body, this);\n+    predicate_iterator.for_each(clone_assertion_predicates_visitor);\n+  }\n+#endif \/\/ ASSERT\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- *      -XX:StressSeed=1870557292\n+ *      -XX:StressSeed=1870557292 -XX:-StressDuplicateBackedge\n@@ -46,1 +46,1 @@\n- *      -XX:+StressLoopPeeling -XX:+VerifyLoopOptimizations\n+ *      -XX:+StressLoopPeeling -XX:+VerifyLoopOptimizations -XX:-StressDuplicateBackedge\n@@ -48,1 +48,1 @@\n- * @run main compiler.loopopts.TestVerifyLoopOptimizationsHitsMemLimit\n+ * @run main\/othervm -XX:-StressDuplicateBackedge compiler.loopopts.TestVerifyLoopOptimizationsHitsMemLimit\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestVerifyLoopOptimizationsHitsMemLimit.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -144,0 +144,13 @@\n+ *                   compiler.predicates.assertion.TestAssertionPredicates DataUpdate\n+ *\/\n+\n+\/*\n+ * @test id=DataUpdateZGC\n+ * @key randomness\n+ * @bug 8288981 8350577\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.gc.Z\n+ * @run main\/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+AbortVMOnCompilationFailure -XX:+UseZGC\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-KillPathsReachableByDeadTypeNode\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/assertion\/TestAssertionPredicates.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8360510\n+ * @summary Test that StressDuplicateBackedge correctly clones Template Assertion Predicates to the inner counted loop.\n+ * @run main\/othervm -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:+StressDuplicateBackedge\n+ *                   compiler.predicates.assertion.TestStressDuplicateBackedgeWithAssertionPredicate\n+ *\/\n+\n+package compiler.predicates.assertion;\n+\n+public class TestStressDuplicateBackedgeWithAssertionPredicate {\n+    static int[] iArr = new int[100];\n+    static int iFld;\n+    static long lFld;\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 10000; i++) {\n+            test();\n+        }\n+    }\n+\n+    static void test() {\n+        \/\/ 5) Once the inner loop is removed, we can apply the duplicate backedge optimization\n+        \/\/    even though it is a counted loop: This is stressed with StressDuplicateLoopBackedge.\n+        \/\/ 6) We do the following transformation with current mainline:\n+        \/\/\n+        \/\/\n+        \/\/                                     Template Assertion\n+        \/\/      Template Assertion                 Predicates\n+        \/\/          Predicates                         |\n+        \/\/              |              ====>          ...\n+        \/\/             ...                             |\n+        \/\/              |                             Loop\n+        \/\/          CountedLoop                        |\n+        \/\/                                        Counted Loop\n+        \/\/\n+        \/\/ The Template Assertion Predicates are still at the outer loop. As a result, we find them to\n+        \/\/ be useless in the next predicate elimination call with EliminateUselessPredicates because\n+        \/\/ they cannot be found from the inner counted loop. However, we have verification code in place\n+        \/\/ that checks that we can only find useless Template Assertion Predicates if the associated\n+        \/\/ counted loop node is dead. This is not the case and we crash with an assertion failure.\n+        \/\/\n+        \/\/ The fix is to move the Template Assertion Predicates to the inner counted loop.\n+        for (int i = 0; i < 100; i++) {\n+            \/\/ 3) Loop Predication will hoist this range checkout out of the loop with Template\n+            \/\/    Assertion Predicates.\n+            iArr[i] = 34;\n+\n+            \/\/ 1) We need an inner loop to make sure the outer counter loop is not strip mined.\n+            \/\/    Otherwise, we cannot apply the duplicate backedge optimization to the outer loop.\n+            \/\/ 4) Found to be empty and removed.\n+            for (int j = 0; j < 10; j++) {}\n+\n+            \/\/ 2) We need some region inside the outer loop, otherwise, we cannot apply the duplicate\n+            \/\/    backedge optimization.\n+            if (i == 3) {\n+                lFld = 34;\n+            } else {\n+                iFld = 2;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/assertion\/TestStressDuplicateBackedgeWithAssertionPredicate.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"}]}