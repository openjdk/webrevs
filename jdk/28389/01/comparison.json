{"files":[{"patch":"@@ -4183,0 +4183,27 @@\n+#ifdef ASSERT\n+\n+\/\/ Moves Template Assertion Predicates to a target loop by cloning and killing the old ones. The target loop is the\n+\/\/ original, not-cloned loop. This is currently only used with StressLoopBackedge which is a develop flag only and\n+\/\/ false with product builds. We can therefore guard it with an ifdef. More details can be found at the use-site.\n+class MoveAssertionPredicatesVisitor : public PredicateVisitor {\n+  ClonePredicateToTargetLoop _clone_predicate_to_loop;\n+  PhaseIdealLoop* const _phase;\n+\n+public:\n+  MoveAssertionPredicatesVisitor(LoopNode* target_loop_head,\n+                                 const NodeInSingleLoopBody &node_in_loop_body,\n+                                 PhaseIdealLoop* phase)\n+    : _clone_predicate_to_loop(target_loop_head, node_in_loop_body, phase),\n+      _phase(phase) {\n+  }\n+  NONCOPYABLE(MoveAssertionPredicatesVisitor);\n+\n+  using PredicateVisitor::visit;\n+\n+  void visit(const TemplateAssertionPredicate& template_assertion_predicate) override {\n+    _clone_predicate_to_loop.clone_template_assertion_predicate(template_assertion_predicate);\n+    template_assertion_predicate.kill(_phase->igvn());\n+  }\n+};\n+#endif \/\/ ASSERT\n+\n@@ -4251,0 +4278,1 @@\n+#ifdef ASSERT\n@@ -4269,1 +4297,3 @@\n-  } else {\n+  } else\n+#endif \/\/ASSERT\n+  {\n@@ -4460,0 +4490,13 @@\n+#ifdef ASSERT\n+  if (StressDuplicateBackedge && head->is_CountedLoop()) {\n+    \/\/ The Template Assertion Predicates from the old counted loop are now at the new outer loop - clone them to\n+    \/\/ the inner counted loop and kill the old ones. We only need to do this with debug builds because\n+    \/\/ StressDuplicateBackedge is a devlop flag and false by default. Without StressDuplicateBackedge 'head' will be a\n+    \/\/ non-counted loop, and thus we have no Template Assertion Predicates above the old loop to move down.\n+    PredicateIterator predicate_iterator(outer_head->in(LoopNode::EntryControl));\n+    NodeInSingleLoopBody node_in_body(this, loop);\n+    MoveAssertionPredicatesVisitor move_assertion_predicates_visitor(head, node_in_body, this);\n+    predicate_iterator.for_each(move_assertion_predicates_visitor);\n+  }\n+#endif \/\/ ASSERT\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":44,"deletions":1,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- *      -XX:StressSeed=1870557292\n+ *      -XX:StressSeed=1870557292 -XX:-StressDuplicateBackedge\n@@ -46,1 +46,1 @@\n- *      -XX:+StressLoopPeeling -XX:+VerifyLoopOptimizations\n+ *      -XX:+StressLoopPeeling -XX:+VerifyLoopOptimizations -XX:-StressDuplicateBackedge\n@@ -48,1 +48,1 @@\n- * @run main compiler.loopopts.TestVerifyLoopOptimizationsHitsMemLimit\n+ * @run main\/othervm -XX:-StressDuplicateBackedge compiler.loopopts.TestVerifyLoopOptimizationsHitsMemLimit\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestVerifyLoopOptimizationsHitsMemLimit.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -144,0 +144,13 @@\n+ *                   compiler.predicates.assertion.TestAssertionPredicates DataUpdate\n+ *\/\n+\n+\/*\n+ * @test id=DataUpdateZGC\n+ * @key randomness\n+ * @bug 8288981 8350577 0360510\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.gc.Z\n+ * @run main\/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+AbortVMOnCompilationFailure -XX:+UseZGC\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-KillPathsReachableByDeadTypeNode\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/assertion\/TestAssertionPredicates.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8360510\n+ * @summary Test that StressDuplicateBackedge correctly clones Template Assertion Predicates to the inner counted loop.\n+ * @run main\/othervm -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:+StressDuplicateBackedge\n+ *                   compiler.predicates.assertion.TestStressDuplicateBackedgeWithAssertionPredicate\n+ * @run main compiler.predicates.assertion.TestStressDuplicateBackedgeWithAssertionPredicate\n+ *\/\n+\n+package compiler.predicates.assertion;\n+\n+public class TestStressDuplicateBackedgeWithAssertionPredicate {\n+    static int[] iArr = new int[100];\n+    static int iFld;\n+    static long lFld;\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 10000; i++) {\n+            test();\n+        }\n+    }\n+\n+    static void test() {\n+        \/\/ 5) Once the inner loop is removed, we can apply the duplicate backedge optimization\n+        \/\/    even though it is a counted loop: This is stressed with StressDuplicateLoopBackedge.\n+        \/\/ 6) We do the following transformation with current mainline:\n+        \/\/\n+        \/\/                                     Template Assertion\n+        \/\/      Template Assertion                 Predicates\n+        \/\/          Predicates                         |\n+        \/\/              |              ====>          ...\n+        \/\/             ...                             |\n+        \/\/              |                             Loop       # Outer Non-Counted Loop (new)\n+        \/\/          CountedLoop                        |\n+        \/\/                                        Counted Loop   # Inner Counted Loop (old)\n+        \/\/\n+        \/\/ 7) After the transformation, the Template Assertion Predicates are still at the Outer Non-Counted Loop.\n+        \/\/    As a result, we find them to be useless in the next predicate elimination call with\n+        \/\/    EliminateUselessPredicates because they cannot be found from the Inner counted Loop (we stop at\n+        \/\/    Loop which is not a predicate). However, we have verification code in place that checks that we\n+        \/\/    can only find useless Template Assertion Predicates if the associated counted loop node is dead.\n+        \/\/    This is not the case and we crash with an assertion failure.\n+        \/\/\n+        \/\/   The fix is to move the Template Assertion Predicates to the Inner Counted Loop again.\n+        for (int i = 0; i < 100; i++) {\n+            \/\/ 3) Loop Predication will hoist this range checkout out of the loop with Template\n+            \/\/    Assertion Predicates.\n+            iArr[i] = 34;\n+\n+            \/\/ 1) We need an inner empty loop to make sure the outer counter loop is not strip mined.\n+            \/\/    Otherwise, we cannot apply the duplicate backedge optimization to the outer loop.\n+            \/\/ 4) Found to be empty and removed.\n+            for (int j = 0; j < 10; j++) {}\n+\n+            \/\/ 2) We need some region inside the outer loop, otherwise, we cannot apply the duplicate\n+            \/\/    backedge optimization.\n+            if (i == 3) {\n+                lFld = 34;\n+            } else {\n+                iFld = 2;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/assertion\/TestStressDuplicateBackedgeWithAssertionPredicate.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"}]}