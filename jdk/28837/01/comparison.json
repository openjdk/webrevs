{"files":[{"patch":"@@ -330,0 +330,1 @@\n+  size_t old_memory_allocated_during_old_marking = 0;\n@@ -338,1 +339,4 @@\n-    live_data += live_bytes;\n+    if (!region->was_promoted_in_place()) {\n+      live_data += live_bytes;\n+    }\n+    \/\/ else, regions that were promoted in place had 0 old live data at mark start\n@@ -377,1 +381,1 @@\n-  \/\/ TODO: subtract from live_data bytes promoted during concurrent GC.\n+  \/\/ As currently implemented, region->get_live_data_bytes() represents bytes concurrently marked.  This is SATB value\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -226,1 +226,0 @@\n-\n@@ -254,0 +253,1 @@\n+    region->set_promoted_in_place();\n@@ -292,0 +292,1 @@\n+      r->set_promoted_in_place();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalEvacuationTask.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -265,0 +265,1 @@\n+  bool _promoted_in_place;\n@@ -357,0 +358,6 @@\n+  inline void set_promoted_in_place() {\n+    _promoted_in_place = true;\n+  }\n+  inline bool was_promoted_in_place() {\n+    return _promoted_in_place;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -155,0 +155,1 @@\n+  _promoted_in_place = false;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}