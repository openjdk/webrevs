{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-  #define UNALLOCATED 4    \/\/ rsp, rbp, r15, r10\n+  #define UNALLOCATED 3    \/\/ rsp, r15, r10\n@@ -52,1 +52,2 @@\n-  pd_nof_caller_save_cpu_regs_frame_map = pd_nof_cpu_regs_frame_map - UNALLOCATED,  \/\/ number of registers killed by calls\n+  \/\/ number of registers killed by calls. rbp is callee saved.\n+  pd_nof_caller_save_cpu_regs_frame_map = pd_nof_cpu_regs_frame_map - UNALLOCATED LP64_ONLY(-1),\n@@ -56,1 +57,1 @@\n-  pd_nof_cpu_regs_reg_alloc = pd_nof_caller_save_cpu_regs_frame_map,  \/\/ number of registers that are visible to register allocator\n+  pd_nof_cpu_regs_reg_alloc = pd_nof_cpu_regs_frame_map - UNALLOCATED,  \/\/ number of registers that are visible to register allocator\n@@ -63,1 +64,1 @@\n-  pd_last_cpu_reg = NOT_LP64(5) LP64_ONLY(11),\n+  pd_last_cpu_reg = NOT_LP64(5) LP64_ONLY(12),\n@@ -65,1 +66,1 @@\n-  pd_last_byte_reg = NOT_LP64(5) LP64_ONLY(11),\n+  pd_last_byte_reg = NOT_LP64(5) LP64_ONLY(12),\n","filename":"src\/hotspot\/cpu\/x86\/c1_Defs_x86.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -181,3 +181,15 @@\n-  \/\/ r12 is allocated conditionally. With compressed oops it holds\n-  \/\/ the heapbase value and is not visible to the allocator.\n-  map_register(11, r12);  r12_opr = LIR_OprFact::single_cpu(11);\n+\n+  \/\/ r12 is not visible when UseCompressedOops is enabled.\n+  \/\/ rbp is not visible when PreserveFramePointer is enabled.\n+  \/\/\n+  \/\/ If !PreserveFramePointer && UseCompressedOops, rbp should be in front.\n+  \/\/ If PreserveFramePointer && !UseCompressedOops, r12 should be in front.\n+  \/\/ Otherwise, the order doesn't matter\n+  if (!PreserveFramePointer && UseCompressedOops) {\n+    map_register(11, rbp);  rbp_opr = LIR_OprFact::single_cpu(11);\n+    map_register(12, r12);  r12_opr = LIR_OprFact::single_cpu(12);\n+  } else {\n+    map_register(11, r12);  r12_opr = LIR_OprFact::single_cpu(11);\n+    map_register(12, rbp);  rbp_opr = LIR_OprFact::single_cpu(12);\n+  }\n+\n@@ -185,4 +197,3 @@\n-  map_register(12, r10);  r10_opr = LIR_OprFact::single_cpu(12);\n-  map_register(13, r15);  r15_opr = LIR_OprFact::single_cpu(13);\n-  map_register(14, rsp);\n-  map_register(15, rbp);\n+  map_register(13, r10);  r10_opr = LIR_OprFact::single_cpu(13);\n+  map_register(14, r15);  r15_opr = LIR_OprFact::single_cpu(14);\n+  map_register(15, rsp);\n@@ -216,1 +227,7 @@\n-  _caller_save_cpu_regs[11] = r12_opr;\n+\n+  if (!UseCompressedOops) {\n+    assert(nof_caller_save_cpu_regs() == 12, \"sanity check\");\n+    _caller_save_cpu_regs[11] = r12_opr;\n+  } else {\n+    assert(nof_caller_save_cpu_regs() == 11, \"sanity check\");\n+  }\n@@ -282,0 +299,1 @@\n+#ifndef _LP64\n@@ -283,0 +301,1 @@\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/c1_FrameMap_x86.cpp","additions":28,"deletions":9,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,3 +150,15 @@\n-    \/\/ Reduce the number of available regs (to free r12) in case of compressed oops\n-    if (UseCompressedOops) return range - 1;\n-    return range;\n+    \/\/ Reduce the number of available regs conditionally\n+    int subtrahend = 0;\n+    \/\/ Free rbp if PreserveFramePointer is enabled\n+    if (PreserveFramePointer) {\n+      subtrahend += 1;\n+    }\n+    \/\/ Free r12 if UseCompressedOops is enabled\n+    if (UseCompressedOops) {\n+      subtrahend += 1;\n+    }\n+    return range - subtrahend;\n+  }\n+\n+  static int adjust_caller_save_reg_range(int range) {\n+    return UseCompressedOops ? range - 1 : range;\n@@ -159,1 +171,1 @@\n-  static int nof_caller_save_cpu_regs() { return adjust_reg_range(pd_nof_caller_save_cpu_regs_frame_map); }\n+  static int nof_caller_save_cpu_regs() { return adjust_caller_save_reg_range(pd_nof_caller_save_cpu_regs_frame_map); }\n","filename":"src\/hotspot\/cpu\/x86\/c1_FrameMap_x86.hpp","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,7 +35,13 @@\n-  \/\/ rsp and rbp, r10, r15 (numbers [12,15]) are ignored\n-  \/\/ r12 (number 11) is conditional on compressed oops.\n-  assert(FrameMap::r12_opr->cpu_regnr() == 11, \"wrong assumption below\");\n-  assert(FrameMap::r10_opr->cpu_regnr() == 12, \"wrong assumption below\");\n-  assert(FrameMap::r15_opr->cpu_regnr() == 13, \"wrong assumption below\");\n-  assert(FrameMap::rsp_opr->cpu_regnrLo() == 14, \"wrong assumption below\");\n-  assert(FrameMap::rbp_opr->cpu_regnrLo() == 15, \"wrong assumption below\");\n+  \/\/ rbp (number 11 or 12) is conditional on PreserveFramePointer\n+  \/\/ r12 (number 11 or 12) is conditional on compressed oops.\n+  if (!PreserveFramePointer && UseCompressedOops) {\n+    assert(FrameMap::rbp_opr->cpu_regnr() == 11, \"wrong assumption below\");\n+    assert(FrameMap::r12_opr->cpu_regnr() == 12, \"wrong assumption below\");\n+  } else {\n+    assert(FrameMap::r12_opr->cpu_regnr() == 11, \"wrong assumption below\");\n+    assert(FrameMap::rbp_opr->cpu_regnr() == 12, \"wrong assumption below\");\n+  }\n+  \/\/ r10, r15 and rsp (numbers [13,15]) are ignored\n+  assert(FrameMap::r10_opr->cpu_regnr() == 13, \"wrong assumption below\");\n+  assert(FrameMap::r15_opr->cpu_regnr() == 14, \"wrong assumption below\");\n+  assert(FrameMap::rsp_opr->cpu_regnrLo() == 15, \"wrong assumption below\");\n@@ -63,2 +69,1 @@\n-  return true; \/\/ no callee-saved registers on Intel\n-\n+  return assigned_reg < FrameMap::nof_caller_save_cpu_regs();\n","filename":"src\/hotspot\/cpu\/x86\/c1_LinearScan_x86.hpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -5755,0 +5755,1 @@\n+#ifndef _LP64\n@@ -5773,0 +5774,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 8, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 8, time = 2, timeUnit = TimeUnit.SECONDS)\n+public abstract class C1PreserveFramePointer {\n+\n+    @Benchmark\n+    public long calculate() {\n+        return calculate(12345678L);\n+    }\n+\n+    public static long calculate(long x) {\n+        long v0 = x + 1L;\n+        long v1 = x + 2L;\n+        long v2 = x + 3L;\n+        long v3 = x + 4L;\n+        long v4 = x + 5L;\n+        long v5 = x + 6L;\n+        long v6 = x + 7L;\n+        long v7 = x + 8L;\n+        long v8 = x + 9L;\n+        long v9 = x + 10L;\n+        long v10 = x + 11L;\n+        long v11 = x + 12L;\n+        long v12 = x + 13L;\n+        return v0 + v1 + v2 + v3 + v4 + v5 + v6 +\n+               v7 + v8 + v9 + v10 + v11 + v12;\n+    }\n+\n+    @Fork(value = 2, jvmArgsPrepend = { \"-XX:+PreserveFramePointer\", \"-XX:-Inline\", \"-XX:TieredStopAtLevel=1\"})\n+    public static class WithPreserveFramePointer extends C1PreserveFramePointer {}\n+\n+    @Fork(value = 2, jvmArgsPrepend = { \"-XX:-PreserveFramePointer\", \"-XX:-Inline\", \"-XX:TieredStopAtLevel=1\"})\n+    public static class WithoutPreserveFramePointer extends C1PreserveFramePointer {}\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/C1PreserveFramePointer.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"}]}