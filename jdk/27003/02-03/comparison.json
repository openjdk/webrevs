{"files":[{"patch":"@@ -26,1 +26,0 @@\n-#include \"runtime\/mutexLocker.hpp\"\n@@ -277,1 +276,0 @@\n-    MemTracker::NmtVirtualMemoryLocker nvml;\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -229,1 +229,3 @@\n-  VMATree(const VMATree& other) : _tree(other._tree) {}\n+  VMATree(const VMATree& other) : _tree() {\n+    assert(other._tree.copy_into(_tree), \"VMATree dies on OOM\");\n+  }\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -415,0 +415,1 @@\n+\n@@ -454,5 +455,19 @@\n-  RBTree(const RBTree& other) : BaseType(), _allocator() {\n-    static_assert(std::is_copy_constructible<K>::value, \"Key type must be copy-constructible when copying a RBTree\");\n-    static_assert(std::is_copy_constructible<V>::value, \"Value type must be copy-constructible when copying a RBTree\");\n-    other.visit_in_order([&](auto node) {\n-      this->upsert(node->key(), node->val());\n+  NONCOPYABLE(RBTree);\n+  ~RBTree() { remove_all(); }\n+\n+  bool copy_into(RBTree& other) {\n+    assert(std::is_copy_constructible<K>::value, \"Key type must be copy-constructible when copying a RBTree\");\n+    assert(std::is_copy_constructible<V>::value, \"Value type must be copy-constructible when copying a RBTree\");\n+    enum Dir { Left, Right };\n+    struct node_pair { NodeType* current; NodeType* other_parent; Dir d; }\n+    struct stack {\n+      node_pair stack[64];\n+      int idx = 0;\n+      stack() : idx(0) {}\n+      node_pair pop() { idx--; return stack[idx]; };\n+      void push(node_pair n) { stack[idx] = n; idx++; };\n+      bool is_empty() { return idx == 0; };\n+    };\n+\n+    stack visit_stack;\n+    if (this->_root == nullptr)  {\n@@ -460,1 +475,24 @@\n-    });\n+    }\n+    other._root = other.allocate_node(this->_root->key());\n+    if (other._root == nullptr) return false;\n+    other._root->val() = this->_root->val();\n+\n+    visit_stack.push({this->_root->_left, other._root, Left});\n+    visit_stack.push({this->_root->_right, other._root, Right});\n+    while (!visit_stack.is_empty()) {\n+      node_pair n = visit_stack.pop();\n+      if (n.current == nullptr) continue;\n+      NodeType* new_node = other.allocate_node(n.current->key());\n+      new_node->val() = n.current->val();\n+      if (new_node == nullptr) {\n+        return false;\n+      }\n+      if (n.dir == Left) {\n+        n.other_parent->_left = new_node;\n+      } else {\n+        n.other_parent->_right = new_node;\n+      }\n+      visit_stack.push({n.current->_left, new_node, Left});\n+      visit_stack.push({n.current->_right, new_node, Right});\n+    }\n+    return true;\n@@ -462,2 +500,0 @@\n-  RBTree& operator=(const RBTree& other) = delete;\n-  ~RBTree() { remove_all(); }\n","filename":"src\/hotspot\/share\/utilities\/rbTree.hpp","additions":44,"deletions":8,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -41,4 +41,1 @@\n-    {\n-      MemTracker::NmtVirtualMemoryLocker nvml;\n-      VirtualMemoryTracker::Instance::add_reserved_region(stack_end, stack_size, CALLER_PC, mtThreadStack);\n-    }\n+    VirtualMemoryTracker::Instance::add_reserved_region(stack_end, stack_size, CALLER_PC, mtThreadStack);\n@@ -47,4 +44,1 @@\n-    {\n-      MemTracker::NmtVirtualMemoryLocker nvml;\n-      VirtualMemoryTracker::Instance::snapshot_thread_stacks();\n-    }\n+    VirtualMemoryTracker::Instance::snapshot_thread_stacks();\n@@ -117,4 +111,1 @@\n-    {\n-      MemTracker::NmtVirtualMemoryLocker nvml;\n-      ReservedMemoryRegion rmr_found = VirtualMemoryTracker::Instance::tree()->find_reserved_region((address)base);\n-    }\n+    ReservedMemoryRegion rmr_found = VirtualMemoryTracker::Instance::tree()->find_reserved_region((address)base);\n@@ -126,12 +117,9 @@\n-    {\n-      MemTracker::NmtVirtualMemoryLocker nvml;\n-      VirtualMemoryTracker::Instance::tree()->visit_committed_regions(rmr_found, [&](const CommittedMemoryRegion& cmr){\n-        if (cmr.size() == size) {\n-          return false;\n-        } else {\n-          precise_tracking_supported = true;\n-          check_covered_pages(cmr.base(), cmr.size(), (address)base, touch_pages, page_num);\n-        }\n-        return true;\n-      });\n-    }\n+    VirtualMemoryTracker::Instance::tree()->visit_committed_regions(rmr_found, [&](const CommittedMemoryRegion& cmr){\n+      if (cmr.size() == size) {\n+        return false;\n+      } else {\n+        precise_tracking_supported = true;\n+        check_covered_pages(cmr.base(), cmr.size(), (address)base, touch_pages, page_num);\n+      }\n+      return true;\n+    });\n@@ -148,4 +136,2 @@\n-    {\n-      VirtualMemoryTracker::Instance::remove_released_region((address)base, size);\n-      rmr_found = VirtualMemoryTracker::Instance::tree()->find_reserved_region((address)base);\n-    }\n+    VirtualMemoryTracker::Instance::remove_released_region((address)base, size);\n+    rmr_found = VirtualMemoryTracker::Instance::tree()->find_reserved_region((address)base);\n","filename":"test\/hotspot\/gtest\/runtime\/test_committed_virtualmemory.cpp","additions":14,"deletions":28,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  vmt.tree()->visit_committed_regions(rmr, [&](CommittedMemoryRegion& region) {\n+  VirtualMemoryTracker::Instance::tree()->visit_committed_regions(rmr, [&](CommittedMemoryRegion& region) {\n","filename":"test\/hotspot\/gtest\/runtime\/test_virtualMemoryTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}