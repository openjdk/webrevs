{"files":[{"patch":"@@ -459,0 +459,1 @@\n+    assert(other.size() == 0, \"You can only copy into an empty RBTree\");\n@@ -461,2 +462,2 @@\n-    enum Dir { Left, Right };\n-    struct node_pair { const RBNode<K, V>* current; RBNode<K, V>* other_parent; Dir d; };\n+    enum class Dir { Left, Right };\n+    struct node_pair { const IntrusiveRBNode* current; IntrusiveRBNode* other_parent; Dir dir; };\n@@ -476,2 +477,2 @@\n-    RBNode<K, V>* root = (RBNode<K, V>*)this->_root;\n-    (RBNode<K, V>*&)other._root = other.allocate_node(root->key());\n+    RBNode<K, V>* root = static_cast<RBNode<K, V>*>(this->_root);\n+    other._root = other.allocate_node(root->key(), root->val());\n@@ -479,1 +480,0 @@\n-    (RBNode<K, V>*)other._root->val() = root->val();\n@@ -481,2 +481,2 @@\n-    visit_stack.push({this->_root->_left, other._root, Left});\n-    visit_stack.push({this->_root->_right, other._root, Right});\n+    visit_stack.push({this->_root->_left, other._root, Dir::Left});\n+    visit_stack.push({this->_root->_right, other._root, Dir::Right});\n@@ -485,3 +485,3 @@\n-      if (n.current == nullptr) continue;\n-      RBNode<K, V>* new_node = other.allocate_node(n.current->key());\n-      new_node->val() = n.current->val();\n+      const RBNode<K, V>* current = static_cast<const RBNode<K, V>*>(n.current);\n+      if (current == nullptr) continue;\n+      RBNode<K, V>* new_node = other.allocate_node(current->key(), current->val());\n@@ -491,1 +491,1 @@\n-      if (n.dir == Left) {\n+      if (n.dir == Dir::Left) {\n@@ -498,2 +498,2 @@\n-      visit_stack.push({n.current->_left, new_node, Left});\n-      visit_stack.push({n.current->_right, new_node, Right});\n+      visit_stack.push({n.current->_left, new_node, Dir::Left});\n+      visit_stack.push({n.current->_right, new_node, Dir::Right});\n@@ -501,0 +501,2 @@\n+    other._num_nodes = this->_num_nodes;\n+    DEBUG_ONLY(other._expected_visited = this->_expected_visited);\n","filename":"src\/hotspot\/share\/utilities\/rbTree.hpp","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1082,0 +1082,39 @@\n+TEST_VM_F(RBTreeTest, TestCopyInto) {\n+  {\n+    RBTreeInt rbtree1;\n+    RBTreeInt rbtree2;\n+\n+    rbtree1.copy_into(rbtree2);\n+    rbtree2.verify_self();\n+  }\n+\n+  RBTreeInt rbtree1;\n+  RBTreeInt rbtree2;\n+\n+  int size = 1000;\n+  for (int i = 0; i < size; i++) {\n+    rbtree1.upsert(i, i);\n+  }\n+\n+  rbtree1.copy_into(rbtree2);\n+  rbtree2.verify_self();\n+\n+  ResourceMark rm;\n+  GrowableArray<int> allocations(size);\n+  int size1 = 0;\n+  rbtree1.visit_in_order([&](RBTreeIntNode* node) {\n+    size1++;\n+    allocations.append(node->key());\n+    return true;\n+  });\n+\n+  int size2 = 0;\n+  rbtree2.visit_in_order([&](RBTreeIntNode* node) {\n+    EXPECT_EQ(node->key(), allocations.at(size2++));\n+    return true;\n+  });\n+\n+  EXPECT_EQ(size1, size2);\n+  EXPECT_EQ(rbtree1.size(), rbtree2.size());\n+  EXPECT_EQ(size2, static_cast<int>(rbtree2.size()));\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_rbtree.cpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"}]}