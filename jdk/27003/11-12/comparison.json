{"files":[{"patch":"@@ -457,47 +457,1 @@\n-  bool copy_into(RBTree& other) const {\n-    assert(other.size() == 0, \"You can only copy into an empty RBTree\");\n-    assert(std::is_copy_constructible<K>::value, \"Key type must be copy-constructible when copying a RBTree\");\n-    assert(std::is_copy_constructible<V>::value, \"Value type must be copy-constructible when copying a RBTree\");\n-    enum class Dir { Left, Right };\n-    struct node_pair { const IntrusiveRBNode* current; IntrusiveRBNode* other_parent; Dir dir; };\n-    struct stack {\n-      node_pair s[64];\n-      int idx = 0;\n-      stack() : idx(0) {}\n-      node_pair pop() { idx--; return s[idx]; };\n-      void push(node_pair n) { s[idx] = n; idx++; };\n-      bool is_empty() { return idx == 0; };\n-    };\n-\n-    stack visit_stack;\n-    if (this->_root == nullptr)  {\n-      return true;\n-    }\n-    RBNode<K, V>* root = static_cast<RBNode<K, V>*>(this->_root);\n-    other._root = other.allocate_node(root->key(), root->val());\n-    if (other._root == nullptr) return false;\n-\n-    visit_stack.push({this->_root->_left, other._root, Dir::Left});\n-    visit_stack.push({this->_root->_right, other._root, Dir::Right});\n-    while (!visit_stack.is_empty()) {\n-      node_pair n = visit_stack.pop();\n-      const RBNode<K, V>* current = static_cast<const RBNode<K, V>*>(n.current);\n-      if (current == nullptr) continue;\n-      RBNode<K, V>* new_node = other.allocate_node(current->key(), current->val());\n-      if (new_node == nullptr) {\n-        return false;\n-      }\n-      if (n.dir == Dir::Left) {\n-        n.other_parent->_left = new_node;\n-      } else {\n-        n.other_parent->_right = new_node;\n-      }\n-      new_node->set_parent(n.other_parent);\n-      new_node->_parent |= n.current->_parent & 0x1;\n-      visit_stack.push({n.current->_left, new_node, Dir::Left});\n-      visit_stack.push({n.current->_right, new_node, Dir::Right});\n-    }\n-    other._num_nodes = this->_num_nodes;\n-    DEBUG_ONLY(other._expected_visited = this->_expected_visited);\n-    return true;\n-  }\n+  bool copy_into(RBTree& other) const;\n","filename":"src\/hotspot\/share\/utilities\/rbTree.hpp","additions":1,"deletions":47,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -752,0 +752,49 @@\n+template<typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+bool RBTree<K, V, COMPARATOR, ALLOCATOR>::copy_into(RBTree& other) {\n+  assert(other.size() == 0, \"You can only copy into an empty RBTree\");\n+  assert(std::is_copy_constructible<K>::value, \"Key type must be copy-constructible when copying a RBTree\");\n+  assert(std::is_copy_constructible<V>::value, \"Value type must be copy-constructible when copying a RBTree\");\n+  enum class Dir { Left, Right };\n+  struct node_pair { const IntrusiveRBNode* current; IntrusiveRBNode* other_parent; Dir dir; };\n+  struct stack {\n+    node_pair s[64];\n+    int idx = 0;\n+    stack() : idx(0) {}\n+    node_pair pop() { idx--; return s[idx]; };\n+    void push(node_pair n) { s[idx] = n; idx++; };\n+    bool is_empty() { return idx == 0; };\n+  };\n+\n+  stack visit_stack;\n+  if (this->_root == nullptr)  {\n+    return true;\n+  }\n+  RBNode<K, V>* root = static_cast<RBNode<K, V>*>(this->_root);\n+  other._root = other.allocate_node(root->key(), root->val());\n+  if (other._root == nullptr) return false;\n+\n+  visit_stack.push({this->_root->_left, other._root, Dir::Left});\n+  visit_stack.push({this->_root->_right, other._root, Dir::Right});\n+  while (!visit_stack.is_empty()) {\n+    node_pair n = visit_stack.pop();\n+    const RBNode<K, V>* current = static_cast<const RBNode<K, V>*>(n.current);\n+    if (current == nullptr) continue;\n+    RBNode<K, V>* new_node = other.allocate_node(current->key(), current->val());\n+    if (new_node == nullptr) {\n+      return false;\n+    }\n+    if (n.dir == Dir::Left) {\n+      n.other_parent->_left = new_node;\n+    } else {\n+      n.other_parent->_right = new_node;\n+    }\n+    new_node->set_parent(n.other_parent);\n+    new_node->_parent |= n.current->_parent & 0x1;\n+    visit_stack.push({n.current->_left, new_node, Dir::Left});\n+    visit_stack.push({n.current->_right, new_node, Dir::Right});\n+  }\n+  other._num_nodes = this->_num_nodes;\n+  DEBUG_ONLY(other._expected_visited = this->_expected_visited);\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/rbTree.inline.hpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"}]}