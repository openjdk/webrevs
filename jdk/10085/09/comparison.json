{"files":[{"patch":"@@ -94,0 +94,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -1699,0 +1700,1 @@\n+  TrimNative::initialize();\n@@ -2678,0 +2680,1 @@\n+  TrimNative::PauseThenTrimMark trim_native_pause;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -1231,0 +1232,2 @@\n+  TrimNative::PauseMark trim_native_pause;\n+\n@@ -1446,0 +1449,2 @@\n+  TrimNative::PauseThenTrimMark trim_native_pause;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -178,0 +178,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -193,0 +194,2 @@\n+\n+  TrimNative::initialize();\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -1712,0 +1713,3 @@\n+  \/\/ Pause native trimming for the duration of the GC\n+  TrimNative::PauseThenTrimMark trim_native_pause;\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -693,2 +693,20 @@\n-          constraint(GCCardSizeInBytesConstraintFunc,AtParse)\n-  \/\/ end of GC_FLAGS\n+          constraint(GCCardSizeInBytesConstraintFunc,AtParse)               \\\n+                                                                            \\\n+  product(bool, TrimNativeHeap, false, EXPERIMENTAL,                        \\\n+          \"GC will attempt to trim the native heap periodically and \"       \\\n+          \"at the end of a GC cycle.\")                                      \\\n+                                                                            \\\n+  product(uint, TrimNativeHeapInterval, 30, EXPERIMENTAL,                   \\\n+          \"If TrimNativeHeap is enabled: interval, in seconds, in which \"   \\\n+          \"the GC will attempt to trim the native heap. If \"                \\\n+          \"TrimNativeHeapAdaptiveStepDown is enabled, the JVM may lower \"   \\\n+          \"the frequency of trimming.\"                                      \\\n+          \"A value of 0 disables periodic trimming altogether while still \" \\\n+          \"trimming after a GC cycle.\")                                     \\\n+          range(0, (24 * 60 * 60))                                          \\\n+                                                                            \\\n+  product(bool, TrimNativeHeapAdaptiveStepDown, false, EXPERIMENTAL,        \\\n+          \"If TrimNativeHeap and periodic trimming are enabled: if true, \"  \\\n+          \"the GC may step down trimming frequency if needed. \")            \\\n+                                                                            \\\n+          \/\/ end of GC_FLAGS\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -203,0 +204,2 @@\n+\n+  TrimNative::initialize();\n@@ -508,0 +511,2 @@\n+  TrimNative::PauseThenTrimMark trim_native_pause;\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,281 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questioSns.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/concurrentGCThread.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"gc\/shared\/trimNative.hpp\"\n+#include \"gc\/shared\/trimNativeStepDown.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+class NativeTrimmerThread : public ConcurrentGCThread {\n+\n+  Monitor* _lock;\n+\n+  \/\/ Periodic trimming state\n+  const int64_t _interval_ms;\n+  const bool _periodic_trim_enabled;\n+  const bool _adaptive_stepdown_enabled;\n+\n+  int64_t _next_trim_time;\n+  int64_t _next_trim_time_saved; \/\/ for pause\n+\n+  \/\/ Adaptive step-down\n+  TrimNativeStepDownControl _stepdown_control;\n+  static const int _min_stepdown_factor = 2; \/\/ 2 * interval length\n+  static const int _max_stepdown_factor = 8; \/\/ 8 * interval length\n+  static const int64_t _stepdown_factor_reset_after = 60 * 1000;\n+  int64_t _last_stepdown_time;\n+  int _last_stepdown_factor;\n+\n+  void update_stepdown_factor(int64_t tnow) {\n+    if (tnow > (_last_stepdown_time + _stepdown_factor_reset_after)) {\n+      _last_stepdown_factor = _min_stepdown_factor;\n+    } else {\n+      _last_stepdown_factor = MIN2(_last_stepdown_factor + 1, _max_stepdown_factor);\n+    }\n+  }\n+\n+  static const int64_t never = INT64_MAX;\n+\n+  static int64_t now() { return os::javaTimeMillis(); }\n+\n+  void run_service() override {\n+\n+    log_info(gc, trim)(\"NativeTrimmer start.\");\n+\n+    int64_t ntt = 0;\n+    int64_t tnow = 0;\n+\n+    for (;;) {\n+      \/\/ 1 - Wait for _next_trim_time. Handle spurious wakeups and shutdown.\n+      {\n+        MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+        do {\n+          tnow = now();\n+          ntt = _next_trim_time;\n+          if (ntt == never) {\n+            ml.wait(0); \/\/ infinite sleep\n+          } else if (ntt > tnow) {\n+            ml.wait(ntt - tnow); \/\/ sleep till next point\n+          }\n+          if (should_terminate()) {\n+            log_info(gc, trim)(\"NativeTrimmer stop.\");\n+            return;\n+          }\n+          tnow = now();\n+          ntt = _next_trim_time;\n+        } while (ntt > tnow);\n+      }\n+\n+      \/\/ 2 - Trimming happens outside of lock protection. GC threads can issue new commands\n+      \/\/     concurrently.\n+      const bool explicitly_scheduled = (ntt == 0);\n+      TrimResult result = execute_trim_and_log(explicitly_scheduled);\n+\n+      \/\/ 3 - Update _next_trim_time; but give concurrent setters preference.\n+      {\n+        MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+        tnow = now();\n+        int64_t ntt2 = _next_trim_time;\n+\n+        if (ntt2 == ntt) { \/\/ not changed concurrently?\n+\n+          if (_periodic_trim_enabled) {\n+            int64_t interval_length = _interval_ms;\n+\n+            \/\/ Handle adaptive stepdown. If heuristic recommends step-down, we prolong the\n+            \/\/ wait interval by a factor that gets progressively larger with subsequent step-downs.\n+            \/\/ Factor is capped and gets reset after a while.\n+            if (_adaptive_stepdown_enabled) {\n+              _stepdown_control.feed(result);\n+\n+              if (_stepdown_control.recommend_step_down()) {\n+                _last_stepdown_factor =\n+                    \/\/ increase or reset step-down factor depending on how many step-downs we had and\n+                    \/\/ how long they are ago.\n+                    (tnow > (_last_stepdown_time + _stepdown_factor_reset_after)) ?\n+                    _min_stepdown_factor :\n+                    MIN2(_last_stepdown_factor + 1, _max_stepdown_factor);\n+\n+                _last_stepdown_time = tnow;\n+                interval_length = _interval_ms * _last_stepdown_factor;\n+                log_debug(gc, trim)(\"NativeTrimmer: long pause (\" INT64_FORMAT \" ms)\", interval_length);\n+              }\n+            }\n+            _next_trim_time = tnow + interval_length;\n+\n+          } else {\n+            \/\/ periodic trim disabled\n+            _next_trim_time = never;\n+          }\n+        }\n+      } \/\/ Mutex scope\n+    }\n+  }\n+\n+  void stop_service() override {\n+    MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+    ml.notify_all();\n+  }\n+\n+  \/\/ Execute the native trim, log results.\n+  \/\/ Return true if trim succeeded *and* we have valid size change data.\n+  TrimResult execute_trim_and_log(bool explicitly_scheduled) const {\n+    assert(os::can_trim_native_heap(), \"Unexpected\");\n+    const int64_t tnow = now();\n+    os::size_change_t sc;\n+    Ticks start = Ticks::now();\n+    log_debug(gc, trim)(\"Trim native heap started...\");\n+    if (os::trim_native_heap(&sc)) {\n+      Tickspan trim_time = (Ticks::now() - start);\n+      if (sc.after != SIZE_MAX) {\n+        const size_t delta = sc.after < sc.before ? (sc.before - sc.after) : (sc.after - sc.before);\n+        const char sign = sc.after < sc.before ? '-' : '+';\n+        log_info(gc, trim)(\"Trim native heap (%s): RSS+Swap: \" PROPERFMT \"->\" PROPERFMT \" (%c\" PROPERFMT \"), %1.3fms\",\n+                           (explicitly_scheduled ? \"explicit\" : \"periodic\"),\n+                           PROPERFMTARGS(sc.before), PROPERFMTARGS(sc.after), sign, PROPERFMTARGS(delta),\n+                           trim_time.seconds() * 1000);\n+        return TrimResult(tnow, now() - tnow, sc.before, sc.after);\n+      } else {\n+        log_info(gc, trim)(\"Trim native heap (no details)\");\n+      }\n+    }\n+    return TrimResult();\n+  }\n+\n+public:\n+\n+  NativeTrimmerThread() :\n+    _lock(new (std::nothrow) PaddedMonitor(Mutex::nosafepoint, \"NativeTrimmer_lock\")),\n+    _interval_ms(TrimNativeHeapInterval * 1000),\n+    _periodic_trim_enabled(TrimNativeHeapInterval > 0),\n+    _adaptive_stepdown_enabled(TrimNativeHeapAdaptiveStepDown),\n+    _next_trim_time(0),\n+    _next_trim_time_saved(0),\n+    _last_stepdown_time(0),\n+    _last_stepdown_factor(_min_stepdown_factor)\n+  {\n+    set_name(\"Native Heap Trimmer\");\n+    _next_trim_time = _periodic_trim_enabled ? (now() + _interval_ms) : never;\n+    create_and_start();\n+  }\n+\n+  void pause() {\n+    if (!_periodic_trim_enabled) {\n+      return;\n+    }\n+    {\n+      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+      _next_trim_time_saved = _next_trim_time;\n+      _next_trim_time = never;\n+      ml.notify_all();\n+    }\n+    log_debug(gc, trim)(\"NativeTrimmer pause\");\n+  }\n+\n+  void unpause() {\n+    if (!_periodic_trim_enabled) {\n+      return;\n+    }\n+    {\n+      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+      _next_trim_time = _next_trim_time_saved;\n+      ml.notify_all();\n+    }\n+    log_debug(gc, trim)(\"NativeTrimmer unpause\");\n+  }\n+\n+  void unpause_and_trim() {\n+    {\n+      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+      _next_trim_time = 0;\n+      ml.notify_all();\n+    }\n+    if (_periodic_trim_enabled) {\n+      log_debug(gc, trim)(\"NativeTrimmer unpause + request explicit trim\");\n+    } else {\n+      log_debug(gc, trim)(\"NativeTrimmer request explicit trim\");\n+    }\n+  }\n+\n+}; \/\/ NativeTrimmer\n+\n+static NativeTrimmerThread* g_trimmer_thread = nullptr;\n+\n+\/\/\/ GCTrimNative outside facing methods\n+\n+void TrimNative::initialize() {\n+  if (TrimNativeHeap) {\n+    if (!os::can_trim_native_heap()) {\n+      FLAG_SET_ERGO(TrimNativeHeap, false);\n+      log_info(gc, trim)(\"Native trim not supported on this platform.\");\n+      return;\n+    }\n+\n+    log_info(gc, trim)(\"Native trim enabled.\");\n+\n+    if (TrimNativeHeapInterval == 0) {\n+      if (TrimNativeHeapAdaptiveStepDown) {\n+        FLAG_SET_ERGO(TrimNativeHeapAdaptiveStepDown, false);\n+      }\n+      log_info(gc, trim)(\"Periodic native trim disabled.\");\n+    } else {\n+      log_info(gc, trim)(\"Periodic native trim enabled (interval: %u seconds, dynamic step-down %s)\",\n+                         TrimNativeHeapInterval, (TrimNativeHeapAdaptiveStepDown ? \"enabled\" : \"disabled\"));\n+    }\n+    g_trimmer_thread = new NativeTrimmerThread();\n+  }\n+}\n+\n+void TrimNative::cleanup() {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->stop();\n+  }\n+}\n+\n+void TrimNative::pause_periodic_trim() {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->pause();\n+  }\n+}\n+\n+void TrimNative::unpause_periodic_trim() {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->unpause();\n+  }\n+}\n+\n+void TrimNative::schedule_trim() {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->unpause_and_trim();\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/trimNative.cpp","additions":281,"deletions":0,"binary":false,"changes":281,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_TRIMNATIVE_HPP\n+#define SHARE_GC_SHARED_TRIMNATIVE_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+\n+class TrimNative : public AllStatic {\n+public:\n+\n+  static void initialize();\n+  static void cleanup();\n+\n+  \/\/ Pause periodic trim (if enabled).\n+  static void pause_periodic_trim();\n+\n+  \/\/ Unpause periodic trim (if enabled).\n+  static void unpause_periodic_trim();\n+\n+  \/\/ Schedule an explicit trim now.\n+  \/\/ If periodic trims are enabled and had been paused, they are unpaused\n+  \/\/ and the interval is reset.\n+  static void schedule_trim();\n+\n+  \/\/ Pause periodic trimming while in scope; when leaving scope,\n+  \/\/ resume periodic trimming.\n+  struct PauseMark {\n+    PauseMark()   { pause_periodic_trim(); }\n+    ~PauseMark()  { unpause_periodic_trim(); }\n+  };\n+\n+  \/\/ Pause periodic trimming while in scope; when leaving scope,\n+  \/\/ trim immediately and resume periodic trimming with a new interval.\n+  struct PauseThenTrimMark {\n+    PauseThenTrimMark()   { pause_periodic_trim(); }\n+    ~PauseThenTrimMark()  { schedule_trim(); }\n+  };\n+\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_TRIMNATIVE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/trimNative.hpp","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questioSns.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/trimNativeStepDown.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+void TrimResult::print_on(outputStream* st) const {\n+  st->print(\"time: \" INT64_FORMAT \", duration \" INT64_FORMAT\n+            \", rss1: \" SIZE_FORMAT \", rss2: \" SIZE_FORMAT \" (\" SSIZE_FORMAT \")\",\n+            _time, _duration, _rss_before, _rss_after, size_reduction());\n+}\n+\n+\/\/ Given two results of subsequent trims, returns true if the first trim is considered\n+\/\/ \"bad\" - a trim that had been not worth the cost.\n+bool TrimNativeStepDownControl::is_bad_trim(const TrimResult& r, const TrimResult& r_followup) {\n+  assert(r.is_valid() && r_followup.is_valid(), \"Sanity\");\n+\n+  const int64_t tinterval = r.interval_time(r_followup);\n+  assert(tinterval >= 0, \"negative interval? \" INT64_FORMAT, tinterval);\n+  if (tinterval == 0) {\n+    return false;\n+  }\n+  assert(tinterval >= r.duration(), \"trim duration cannot be larger than trim interval (\"\n+         INT64_FORMAT \", \" INT64_FORMAT \")\", tinterval, r.duration());\n+\n+  \/\/ Cost: ratio of trim time to total interval time (which contains trim time)\n+  const double ratio_trim_time_to_interval_time =\n+      (double)r.duration() \/ (double)tinterval;\n+  assert(ratio_trim_time_to_interval_time >= 0, \"Sanity\");\n+\n+  \/\/ Any ratio of less than 1% trim time to interval time we regard as harmless\n+  \/\/ (e.g. less than 10ms for 1second of interval)\n+  if (ratio_trim_time_to_interval_time < 0.01) {\n+    return false;\n+  }\n+\n+  \/\/ Benefit: Ratio of lasting size reduction to RSS before the first trim.\n+  const double rss_gain_ratio = (double)r.calc_lasting_gain(r_followup) \/ (double)r.rss_before();\n+\n+  \/\/ We consider paying 1% (or more) time-per-interval for\n+  \/\/ 1% (or less, maybe even negative) rss size reduction as bad.\n+  bool bad = ratio_trim_time_to_interval_time > rss_gain_ratio;\n+\n+  return false;\n+}\n+\n+bool TrimNativeStepDownControl::recommend_step_down() const {\n+  struct { int trims, bad, ignored; } counts = { 0, 0, 0 };\n+\n+  const TrimResult* previous = nullptr;\n+  auto trim_evaluater = [&counts, &previous] (const TrimResult* r) {\n+tty->print(\"??  \");\n+r->print_on(tty);\n+    if (!r->is_valid() || previous == nullptr || !previous->is_valid()) {\n+      \/\/ Note: we ignore:\n+      \/\/ - the very youngest trim, since we don't know the\n+      \/\/   RSS bounce back to the next trim yet.\n+      \/\/ - invalid trim results\n+      counts.ignored++;\n+    } else {\n+      counts.trims++;\n+      if (is_bad_trim(*previous, *r)) {\n+        counts.bad++;\n+      }\n+    }\n+tty->cr();\n+    previous = r;\n+  };\n+  _history.iterate_oldest_to_youngest(trim_evaluater);\n+\n+  log_trace(gc, trim)(\"Heuristic says: trims: %d, bad trims: %d, ignored: %d\",\n+                      counts.trims, counts.bad, counts.ignored);\n+\n+  \/\/ If all trims in the history had been bad (excluding the youngest, for which we cannot\n+  \/\/ evaluate the lasting gains yet), step down.\n+  return counts.ignored <= 1 && counts.bad == counts.trims;\n+}\n+\n+void TrimNativeStepDownControl::feed(const TrimResult& r) {\n+  _history.add(r);\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/trimNativeStepDown.cpp","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_TRIMNATIVESTEPDOWN_HPP\n+#define SHARE_GC_SHARED_TRIMNATIVESTEPDOWN_HPP\n+\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class outputStream;\n+\n+\/\/\/\/\/\/\/ Support for TrimNativeHeapAdaptiveStepDown \/\/\/\/\/\/\n+\/\/\n+\/\/ Small heuristic to check if periodic trimming has been fruitful so far.\n+\/\/ If this heuristic finds trimming to be harmful, we will inject one longer\n+\/\/ trim interval (GCTrimNativeIntervalMax).\n+\/\/\n+\/\/ Trimming costs are the trim itself plus the re-aquisition costs of memory should the\n+\/\/ released memory be malloced again. Trimming gains are the memory reduction over time.\n+\/\/ Lasting gains are good; gains that don't last are not.\n+\/\/\n+\/\/ There are roughly three usage pattern:\n+\/\/ - rare malloc spikes interspersed with long idle periods. Trimming is beneficial\n+\/\/   since the relieved memory pressure holds for a long time.\n+\/\/ - a constant low-intensity malloc drone. Trimming does not help much here but its\n+\/\/   harmless too since trimming is cheap if it does not recover much.\n+\/\/ - frequent malloc spikes with short idle periods; trimmed memory will be re-aquired\n+\/\/   after only a short relief; here, trimming could be harmful since we pay a lot for\n+\/\/   not much relief. We want to alleviate these scenarios.\n+\/\/\n+\/\/ Putting numbers on these things is difficult though. We cannot observe malloc\n+\/\/ load directly, only RSS. For every trim we know the RSS reduction (from, to). So\n+\/\/ for subsequent trims we also can glean from (<next sample>.from) whether RSS bounced\n+\/\/ back. But that is quite vague since RSS may have been influenced by a ton of other\n+\/\/ developments, especially for longer trim intervals.\n+\/\/\n+\/\/ Therefore this heuristic may produce false positives and negatives. We try to err on\n+\/\/ the side of too much trimming here and to identify only situations that are clearly\n+\/\/ harmful. Note that the GCTrimNativeIntervalMax default (4 * GCTrimNativeInterval)\n+\/\/ is gentle enough for wrong heuristic results to not be too punative.\n+\n+\n+\/\/ A class holding results for a single trim operation.\n+class TrimResult {\n+\n+  \/\/ time (ms) trim happened (javaTimeMillis)\n+  int64_t _time;\n+  \/\/ time (ms) trim itself took.\n+  int64_t _duration;\n+  \/\/ rss\n+  size_t _rss_before, _rss_after;\n+\n+public:\n+\n+  TrimResult() : _time(-1), _duration(0), _rss_before(0), _rss_after(0) {}\n+\n+  TrimResult(int64_t t, int64_t d, size_t rss1, size_t rss2) :\n+    _time(t), _duration(d), _rss_before(rss1), _rss_after(rss2)\n+  {}\n+\n+  int64_t time() const { return _time; }\n+  int64_t duration() const { return _duration; }\n+  size_t rss_before() const { return _rss_before; }\n+  size_t rss_after() const { return _rss_before; }\n+\n+  bool is_valid() const {\n+    return _time >= 0 && _duration >= 0 &&\n+        _rss_before != 0 && _rss_after != 0;\n+  }\n+\n+  \/\/ Returns size reduction; positive if memory was reduced\n+  ssize_t size_reduction() const {\n+    return checked_cast<ssize_t>(_rss_before) -\n+           checked_cast<ssize_t>(_rss_after);\n+  }\n+\n+  \/\/ Return the lasting gain compared with a follow-up trim. Negative numbers mean a loss.\n+  ssize_t calc_lasting_gain(const TrimResult& followup_trim) const {\n+    ssize_t gain = size_reduction();\n+    ssize_t loss = checked_cast<ssize_t>(followup_trim.rss_before()) -\n+                   checked_cast<ssize_t>(rss_after());\n+    return gain - loss;\n+  }\n+\n+  \/\/ Return the interval time between this result and a follow-up trim.\n+  int64_t interval_time(const TrimResult& followup_trim) const {\n+    return followup_trim.time() - time();\n+  }\n+\n+  void print_on(outputStream* st) const;\n+\n+};\n+\n+class TrimNativeStepDownControl {\n+\n+  static const int _trim_history_length = 4;\n+\n+  \/\/ A FIFO of the last n trim results\n+  class TrimHistory {\n+    static const int _max = _trim_history_length;\n+\n+    \/\/ Note: history may contain invalid results; for one, it is\n+    \/\/ initialized with invalid results to keep iterating simple;\n+    \/\/ also invalid results can happen if measuring rss goes wrong.\n+    TrimResult _histo[_max];\n+    int _pos; \/\/ position of next write\n+\n+  public:\n+\n+    TrimHistory() : _pos(0) {}\n+\n+    void add(const TrimResult& result) {\n+      _histo[_pos] = result;\n+      if (++_pos == _max) {\n+        _pos = 0;\n+      }\n+    }\n+\n+    template <class Functor>\n+    void iterate_oldest_to_youngest(Functor f) const {\n+      int idx = _pos;\n+      do {\n+        f(_histo + idx);\n+        if (++idx == _max) {\n+          idx = 0;\n+        }\n+      } while (idx != _pos);\n+    }\n+  };\n+\n+  TrimHistory _history;\n+\n+  static bool is_bad_trim(const TrimResult& r, const TrimResult& r_followup);\n+\n+public:\n+\n+  \/\/ Feed a new trim result into control. It will be added to the history,\n+  \/\/ replacing the oldest result.\n+  \/\/ Adding invalid results is allowed; they will be ignored by the heuristics.\n+  void feed(const TrimResult& r);\n+\n+  \/\/ Returns true if Heuristic recommends stepping down the trim interval\n+  bool recommend_step_down() const;\n+\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_TRIMNATIVESTEPDOWN_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/trimNativeStepDown.hpp","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -48,0 +49,2 @@\n+#include \"utilities\/events.hpp\"\n+\n@@ -283,0 +286,3 @@\n+      \/\/ Expedite next native trim. This also trims if periodic trims are disabled.\n+      TrimNative::schedule_trim();\n+\n@@ -287,0 +293,1 @@\n+\n@@ -425,0 +432,1 @@\n+  TrimNative::PauseMark trim_pause_mark;\n@@ -439,0 +447,1 @@\n+  TrimNative::PauseMark trim_pause_mark;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -628,0 +629,2 @@\n+\n+  TrimNative::initialize();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -177,0 +177,1 @@\n+  f(conc_trim,                                      \"Concurrent Trim\")                 \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -77,0 +78,2 @@\n+  TrimNative::initialize();\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"gc\/shared\/gcVMOperations.hpp\"\n@@ -29,0 +28,2 @@\n+#include \"gc\/shared\/gcVMOperations.hpp\"\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -268,0 +269,1 @@\n+  TrimNative::PauseMark trim_native_pause;\n@@ -322,0 +324,1 @@\n+  TrimNative::PauseMark trim_native_pause;\n@@ -426,0 +429,3 @@\n+\n+    \/\/ Expedite next native trim. This also trims if periodic trims are disabled.\n+    TrimNative::schedule_trim();\n@@ -477,0 +483,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -195,0 +195,1 @@\n+  LOG_TAG(trim) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -478,0 +479,2 @@\n+  TrimNative::cleanup();\n+\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,546 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package gc;\n+\n+\/*\n+ * All these tests test the trim-native feature for all GCs.\n+ * Trim-native is the ability to trim the C-heap as part of the GC cycle.\n+ * This feature is controlled by -XX:+TrimNativeHeap (by default off).\n+ * Trimming happens on full gc for all gcs. Shenandoah and G1 also support\n+ * concurrent trimming (Shenandoah supports this without any ties to java\n+ * heap occupancy).\n+ *\n+ *\/\n+\n+\/\/\/\/ full gc tests \/\/\/\/\/\n+\n+\/*\n+ * @test id=testExplicitTrimOnFullGC-serial\n+ * @summary Test that TrimNativeHeap works with Serial\n+ * @requires vm.gc.Serial\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative testExplicitTrimOnFullGC serial\n+ *\/\n+\n+\/*\n+ * @test id=testExplicitTrimOnFullGC-parallel\n+ * @summary Test that TrimNativeHeap works with Parallel\n+ * @requires vm.gc.Parallel\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative testExplicitTrimOnFullGC parallel\n+ *\/\n+\n+\/*\n+ * @test id=testExplicitTrimOnFullGC-shenandoah\n+ * @summary Test that TrimNativeHeap works with Shenandoah\n+ * @requires vm.gc.Shenandoah\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative testExplicitTrimOnFullGC shenandoah\n+ *\/\n+\n+\/*\n+ * @test id=testExplicitTrimOnFullGC-g1\n+ * @summary Test that TrimNativeHeap works with G1\n+ * @requires vm.gc.G1\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative testExplicitTrimOnFullGC g1\n+ *\/\n+\n+\/*\n+ * @test id=testExplicitTrimOnFullGC-z\n+ * @summary Test that TrimNativeHeap works with Z\n+ * @requires vm.gc.Z\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative testExplicitTrimOnFullGC z\n+ *\/\n+\n+\/\/\/\/ auto mode tests \/\/\/\/\/\n+\n+\/*\n+ * @test id=testPeriodicTrim-serial\n+ * @summary Test that TrimNativeHeap works with Parallel\n+ * @requires vm.gc.Parallel\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative testPeriodicTrim serial\n+ *\/\n+\n+\/*\n+ * @test id=testPeriodicTrim-parallel\n+ * @summary Test that TrimNativeHeap works with Parallel\n+ * @requires vm.gc.Parallel\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative testPeriodicTrim parallel\n+ *\/\n+\n+\/*\n+ * @test id=testPeriodicTrim-shenandoah\n+ * @summary Test that TrimNativeHeap works with Shenandoah\n+ * @requires vm.gc.Shenandoah\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative testPeriodicTrim shenandoah\n+ *\/\n+\n+\/*\n+ * @test id=testPeriodicTrim-g1\n+ * @summary Test that TrimNativeHeap works with G1\n+ * @requires vm.gc.G1\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative testPeriodicTrim g1\n+ *\/\n+\n+\/*\n+ * @test id=testPeriodicTrim-z\n+ * @summary Test that TrimNativeHeap works with Z\n+ * @requires vm.gc.Z\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative testPeriodicTrim z\n+ *\/\n+\n+\/\/\/\/ testPeriodicTrimDisabled test \/\/\/\/\/\n+\n+\/*\n+ * @test id=testPeriodicTrimDisabled-serial\n+ * @summary Test that TrimNativeHeap works with Parallel\n+ * @requires vm.gc.Parallel\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative testPeriodicTrimDisabled serial\n+ *\/\n+\n+\/*\n+ * @test id=testPeriodicTrimDisabled-parallel\n+ * @summary Test that TrimNativeHeap works with Parallel\n+ * @requires vm.gc.Parallel\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative testPeriodicTrimDisabled parallel\n+ *\/\n+\n+\/*\n+ * @test id=testPeriodicTrimDisabled-shenandoah\n+ * @summary Test that TrimNativeHeap works with Shenandoah\n+ * @requires vm.gc.Shenandoah\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative testPeriodicTrimDisabled shenandoah\n+ *\/\n+\n+\/*\n+ * @test id=testPeriodicTrimDisabled-g1\n+ * @summary Test that TrimNativeHeap works with G1\n+ * @requires vm.gc.G1\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative testPeriodicTrimDisabled g1\n+ *\/\n+\n+\/*\n+ * @test id=testPeriodicTrimDisabled-z\n+ * @summary Test that TrimNativeHeap works with Z\n+ * @requires vm.gc.Z\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative testPeriodicTrimDisabled z\n+ *\/\n+\n+\/\/ Other tests\n+\n+\/*\n+ * @test id=testOffByDefault\n+ * @summary Test that -GCTrimNative disables the feature\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative testOffByDefault\n+ *\/\n+\n+\/*\n+ * @test id=testOffExplicit\n+ * @summary Test that GCTrimNative is off by default\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative testOffExplicit\n+ *\/\n+\n+\/*\n+ * @test id=testOffOnNonCompliantPlatforms\n+ * @summary Test that GCTrimNative is off on unsupportive platforms\n+ * @requires (os.family!=\"linux\") | vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative testOffOnNonCompliantPlatforms\n+ *\/\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.IOException;\n+import java.rmi.RemoteException;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class TestTrimNative {\n+\n+    \/\/ Actual RSS increase is a lot larger than 4 MB. Depends on glibc overhead, and NMT malloc headers in debug VMs.\n+    \/\/ We need small-grained allocations to make sure they actually increase RSS (all touched) and to see the\n+    \/\/ glibc-retaining-memory effect.\n+    static final int szAllocations = 16;\n+    static final int totalAllocationsSize = 16 * 1024 * 1024; \/\/ 16 MB total\n+    static final int numAllocations = totalAllocationsSize \/ szAllocations;\n+\n+    static long[] ptrs = new long[numAllocations];\n+\n+    enum Unit {\n+        B(1), K(1024), M(1024*1024), G(1024*1024*1024);\n+        public final long size;\n+        Unit(long size) { this.size = size; }\n+    }\n+\n+    enum GC {\n+        serial, parallel, g1, shenandoah, z;\n+        String getSwitchName() {\n+            String s = name();\n+            return \"-XX:+Use\" + s.substring(0, 1).toUpperCase() + s.substring(1) + \"GC\";\n+        }\n+        boolean isZ() { return this == GC.z; }\n+        boolean isSerial() { return this == GC.serial; }\n+        boolean isParallel() { return this == GC.parallel; }\n+        boolean isG1() { return this == GC.g1; }\n+        boolean isShenandoah() { return this == GC.shenandoah; }\n+    }\n+\n+    private static OutputAnalyzer runTestWithOptions(String[] extraOptions, String[] testArgs) throws IOException {\n+\n+        List<String> allOptions = new ArrayList<String>();\n+        allOptions.add(\"-XX:+UnlockExperimentalVMOptions\");\n+        allOptions.addAll(Arrays.asList(extraOptions));\n+        allOptions.add(\"-Xmx128m\");\n+        allOptions.add(\"-Xms128m\"); \/\/ Stabilize RSS\n+        allOptions.add(\"-XX:+AlwaysPreTouch\"); \/\/ Stabilize RSS\n+        allOptions.add(\"-Xlog:gc+trim=debug\");\n+        allOptions.add(\"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+\n+        allOptions.add(TestTrimNative.class.getName());\n+        allOptions.add(\"RUN\");\n+        allOptions.addAll(Arrays.asList(testArgs));\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(allOptions.toArray(new String[0]));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        return output;\n+\n+    }\n+\n+    private static void checkExpectedLogMessages(OutputAnalyzer output, boolean expectEnabled,\n+                                                 int expectedInterval, boolean expectAutoStepDown) {\n+        if (expectEnabled) {\n+            output.shouldContain(\"Native trim enabled\");\n+            if (expectedInterval > 0) {\n+                output.shouldContain(\"Periodic native trim enabled (interval: \" + expectedInterval +\n+                        \" seconds, dynamic step-down \" + (expectAutoStepDown ? \"enabled\" : \"disabled\") + \")\");\n+                output.shouldContain(\"NativeTrimmer start\");\n+                output.shouldContain(\"NativeTrimmer stop\");\n+            } else {\n+                output.shouldContain(\"Periodic native trim disabled\");\n+            }\n+\n+        } else {\n+            output.shouldNotContain(\"Native trim\");\n+        }\n+    }\n+\n+    \/**\n+     * Given JVM output, look for a log line that describes a successful negative trim. The total amount of trims\n+     * should be matching about what the test program allocated.\n+     * like this:\n+     * \"[2.053s][debug][gc,trim] Trim native heap (retain size: 5120K): RSS+Swap: 271M->223M (-49112K), 2.834ms\"\n+     * (Note: we use the \"properXXX\" print routines, therefore units can differ)\n+     * Check that the sum of all trim log lines comes to a total RSS reduction in the MB range\n+     * @param output\n+     * @param minPeriodicTrimsExpected min number of periodic trim lines expected in UL log\n+     * @param maxPeriodicTrimsExpected min number of periodic trim lines expected in UL log\n+     * @param minExplicitTrimsExpected min number of explicit trim lines expected in UL log\n+     * @param maxExplicitTrimsExpected min number of explicit trim lines expected in UL log\n+     *\/\n+    private static void parseOutputAndLookForNegativeTrim(OutputAnalyzer output, int minPeriodicTrimsExpected,\n+                                                          int maxPeriodicTrimsExpected, int minExplicitTrimsExpected,\n+                                                          int maxExplicitTrimsExpected) {\n+        output.reportDiagnosticSummary();\n+        List<String> lines = output.asLines();\n+        Pattern pat = Pattern.compile(\".*\\\\[gc,trim\\\\] Trim native heap \\\\((explicit|periodic)\\\\)\" +\n+                \".*RSS\\\\+Swap: (\\\\d+)([BKMG])->(\\\\d+)([BKMG]).*\");\n+        int numExplicitTrimsFound = 0;\n+        int numPeriodicTrimsFound = 0;\n+        long rssReductionTotal = 0;\n+        for (String line : lines) {\n+            Matcher mat = pat.matcher(line);\n+            if (mat.matches()) {\n+                String explicitOrPeriodic = mat.group(1);\n+                boolean periodic = false;\n+                switch (explicitOrPeriodic) {\n+                    case \"explicit\": periodic = false; break;\n+                    case \"periodic\": periodic = true; break;\n+                    default: throw new RuntimeException(\"Invalid line \\\"\" + line + \"\\\"\");\n+                }\n+                long rss1 = Long.parseLong(mat.group(2)) * Unit.valueOf(mat.group(3)).size;\n+                long rss2 = Long.parseLong(mat.group(4)) * Unit.valueOf(mat.group(5)).size;\n+                System.out.println(\"Parsed Trim Line. Periodic: \" + periodic + \", rss1: \" + rss1 + \" rss2: \" + rss2);\n+                if (rss1 > rss2) {\n+                    rssReductionTotal += (rss1 - rss2);\n+                }\n+                if (periodic) {\n+                    numPeriodicTrimsFound ++;\n+                } else {\n+                    numExplicitTrimsFound ++;\n+                }\n+            }\n+            if (numPeriodicTrimsFound > maxPeriodicTrimsExpected) {\n+                throw new RuntimeException(\"Abnormal high number of periodic trim attempts found (more than \" + maxPeriodicTrimsExpected +\n+                        \"). Does the interval setting not work?\");\n+            }\n+            if (numExplicitTrimsFound > maxExplicitTrimsExpected) {\n+                throw new RuntimeException(\"Abnormal high number of explicit trim attempts found (more than \" + maxExplicitTrimsExpected +\n+                        \"). Does the interval setting not work?\");\n+            }\n+        }\n+        if (numPeriodicTrimsFound < minPeriodicTrimsExpected) {\n+            throw new RuntimeException(\"We found fewer (periodic) trim lines in UL log than expected (expected at least \" + minPeriodicTrimsExpected +\n+                    \", found \" + numPeriodicTrimsFound + \").\");\n+        }\n+        if (numExplicitTrimsFound < minExplicitTrimsExpected) {\n+            throw new RuntimeException(\"We found fewer (explicit) trim lines in UL log than expected (expected at least \" + minExplicitTrimsExpected +\n+                    \", found \" + numExplicitTrimsFound + \").\");\n+        }\n+        \/\/ This is very fuzzy. Test program malloced X bytes, then freed them again and trimmed. But the log line prints change in RSS.\n+        \/\/ Which, of course, is influenced by a lot of other factors. But we expect to see *some* reasonable reduction in RSS\n+        \/\/ due to trimming.\n+        float fudge = 0.7f;\n+        \/\/ On ppc, we see a vastly diminished return (~3M reduction instead of ~200), I suspect because of the underlying\n+        \/\/ 64k pages lead to a different geometry. Manual tests with larger reclaim sizes show that autotrim works. For\n+        \/\/ this test, we just reduce the fudge factor.\n+        if (Platform.isPPC()) { \/\/ le and be both\n+            fudge = 0.01f;\n+        }\n+        long expectedMinimalReduction = (long) (totalAllocationsSize * fudge);\n+        if (rssReductionTotal < expectedMinimalReduction) {\n+            throw new RuntimeException(\"We did not see the expected RSS reduction in the UL log. Expected (with fudge)\" +\n+                    \" to see at least a combined reduction of \" + expectedMinimalReduction + \".\");\n+        }\n+    }\n+\n+    final static int DEFAULT_TRIM_INTERVAL = 30;\n+    final static boolean DEFAULT_AUTOSTEP = false;\n+\n+    \/\/ Test explicit trim on full gc\n+    static private final void testExplicitTrimOnFullGC(GC gc) throws IOException {\n+        System.out.println(\"testExplicitTrimOnFullGC\");\n+        int sleeptime_secs = 2;\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { gc.getSwitchName(), \"-XX:+TrimNativeHeap\" },\n+                new String[] { \"true\" \/* full gc *\/, String.valueOf(sleeptime_secs * 1000) \/* ms after peak *\/ }\n+        );\n+\n+        checkExpectedLogMessages(output, true, DEFAULT_TRIM_INTERVAL, DEFAULT_AUTOSTEP);\n+\n+        \/\/ We expect to see at least one pause (because we pause during STW gc cycles) followed by an reqested immediate trim\n+        output.shouldContain(\"NativeTrimmer pause\");\n+        output.shouldContain(\"NativeTrimmer unpause + request explicit trim\");\n+\n+        int minPeriodicTrimsExpected = 0;\n+        int maxPeriodicTrimsExpected = 10;\n+        int minExplicitTrimsExpected = 1;\n+        int maxExplicitTrimsExpected = 10;\n+\n+        parseOutputAndLookForNegativeTrim(output,\n+                0, \/*  minPeriodicTrimsExpected *\/\n+                10,  \/*  maxPeriodicTrimsExpected *\/\n+                1, \/*  minExplicitTrimsExpected *\/\n+                10 \/*  maxExplicitTrimsExpected *\/\n+        );\n+    }\n+\n+    \/\/ Test periodic trim with very short trim interval. We explicitly don't do a GC to not get an explicite trim\n+    \/\/ \"stealing\" our gains.\n+    static private final void testPeriodicTrim(GC gc) throws IOException {\n+        System.out.println(\"testPeriodicTrim\");\n+        long t1 = System.currentTimeMillis();\n+        int sleeptime_secs = 4;\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { gc.getSwitchName(), \"-XX:+TrimNativeHeap\", \"-XX:TrimNativeHeapInterval=1\" },\n+                new String[] { \"false\" \/* no full gc *\/, String.valueOf(sleeptime_secs * 1000) \/* ms after peak *\/ }\n+        );\n+        long t2 = System.currentTimeMillis();\n+        int runtime_s = (int)((t2 - t1) \/ 1000);\n+\n+        checkExpectedLogMessages(output, true, 1, DEFAULT_AUTOSTEP);\n+\n+        \/\/ With an interval time of 1 second and a runtime of 6..x seconds we expect to see x periodic trim\n+        \/\/ log lines (+- fudge factor).\n+        parseOutputAndLookForNegativeTrim(output,\n+                runtime_s - 4, \/*  minPeriodicTrimsExpected *\/\n+                runtime_s,  \/*  maxPeriodicTrimsExpected *\/\n+                0, \/*  minExplicitTrimsExpected *\/\n+                10 \/*  maxExplicitTrimsExpected *\/\n+        );\n+\n+    }\n+\n+    static private final void testPeriodicTrimDisabled(GC gc) throws IOException {\n+        System.out.println(\"testPeriodicTrimDisabled\");\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { gc.getSwitchName(), \"-XX:+TrimNativeHeap\", \"-XX:TrimNativeHeapInterval=0\" },\n+                new String[] { \"true\" \/* full gc *\/, \"4000\" \/* ms after peak *\/ }\n+        );\n+        checkExpectedLogMessages(output, true, 0, DEFAULT_AUTOSTEP);\n+\n+        \/\/ We expect only explicit trims, no periodic trims\n+        parseOutputAndLookForNegativeTrim(output,\n+                0, \/*  minPeriodicTrimsExpected *\/\n+                0,  \/*  maxPeriodicTrimsExpected *\/\n+                1, \/*  minExplicitTrimsExpected *\/\n+                10 \/*  maxExplicitTrimsExpected *\/\n+        );\n+    }\n+\n+    \/\/ Test that trim-native gets disabled on platforms that don't support it.\n+    static private final void testOffOnNonCompliantPlatforms() throws IOException {\n+        if (Platform.isLinux() && !Platform.isMusl()) {\n+            throw new RemoteException(\"Don't call me for Linux glibc\");\n+        }\n+        \/\/ Logic is shared, so no need to test with every GC. Just use the default GC.\n+        System.out.println(\"testOffOnNonCompliantPlatforms\");\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { \"-XX:+TrimNativeHeap\" },\n+                new String[] { \"true\" \/* full gc *\/, \"2000\" \/* ms after peak *\/ }\n+        );\n+        checkExpectedLogMessages(output, false, 0, false);\n+    }\n+\n+    \/\/ Test trim native is disabled if explicitly switched off\n+    static private final void testOffExplicit() throws IOException {\n+        \/\/ Logic is shared, so no need to test with every GC. Just use the default GC.\n+        System.out.println(\"testOffExplicit\");\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { \"-XX:-TrimNativeHeap\" },\n+                new String[] { \"true\" \/* full gc *\/, \"2000\" \/* ms after peak *\/ }\n+        );\n+        checkExpectedLogMessages(output, false, 0, false);\n+    }\n+\n+    \/\/ Test that trim-native is disabled by default\n+    static private final void testOffByDefault() throws IOException {\n+        \/\/ Logic is shared, so no need to test with every GC. Just use the default GC.\n+        System.out.println(\"testOffByDefault\");\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { },\n+                new String[] { \"true\" \/* full gc *\/, \"2000\" \/* ms after peak *\/ }\n+        );\n+        checkExpectedLogMessages(output, false, 0, false);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (args.length == 0) {\n+            throw new RuntimeException(\"Argument error\");\n+        }\n+\n+        if (args[0].equals(\"RUN\")) {\n+            boolean doFullGC = Boolean.parseBoolean(args[1]);\n+\n+            System.out.println(\"Will spike now...\");\n+            for (int i = 0; i < numAllocations; i++) {\n+                ptrs[i] = Unsafe.getUnsafe().allocateMemory(szAllocations);\n+                Unsafe.getUnsafe().putByte(ptrs[i], (byte)0);\n+                Unsafe.getUnsafe().putByte(ptrs[i] + szAllocations \/ 2, (byte)0);\n+            }\n+            for (int i = 0; i < numAllocations; i++) {\n+                Unsafe.getUnsafe().freeMemory(ptrs[i]);\n+            }\n+            System.out.println(\"Done spiking.\");\n+\n+            if (doFullGC) {\n+                System.out.println(\"GC...\");\n+                System.gc();\n+            }\n+\n+            \/\/ give GC time to react\n+            int time = Integer.parseInt(args[2]);\n+            System.out.println(\"Sleeping...\");\n+            Thread.sleep(time);\n+            System.out.println(\"Done.\");\n+\n+            return;\n+\n+        } else if (args[0].equals(\"testExplicitTrimOnFullGC\")) {\n+            final GC gc = GC.valueOf(args[1]);\n+            testExplicitTrimOnFullGC(gc);\n+        } else if (args[0].equals(\"testPeriodicTrim\")) {\n+            final GC gc = GC.valueOf(args[1]);\n+            testPeriodicTrim(gc);\n+        } else if (args[0].equals(\"testPeriodicTrimDisabled\")) {\n+            final GC gc = GC.valueOf(args[1]);\n+            testPeriodicTrimDisabled(gc);\n+        } else if (args[0].equals(\"testOffOnNonCompliantPlatforms\")) {\n+            testOffOnNonCompliantPlatforms();\n+        } else if (args[0].equals(\"testOffExplicit\")) {\n+            testOffExplicit();\n+        } else if (args[0].equals(\"testOffByDefault\")) {\n+            testOffByDefault();\n+        } else {\n+            throw new RuntimeException(\"Invalid test \" + args[0]);\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/TestTrimNative.java","additions":546,"deletions":0,"binary":false,"changes":546,"status":"added"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.test.lib.Platform;\n@@ -34,1 +35,1 @@\n- * @requires (os.family==\"linux\") & !vm.musl\n+ * @requires os.family == \"linux\"\n@@ -45,1 +46,5 @@\n-        output.shouldMatch(\".*Trim native heap: RSS\\\\+Swap: \\\\d+[BKM]->\\\\d+[BKM].*\");\n+        if (Platform.isMusl()) {\n+            output.shouldContain(\"Not available\");\n+        } else {\n+            output.shouldMatch(\"Trim native heap: RSS\\\\+Swap: \\\\d+[BKMG]->\\\\d+[BKMG] \\\\(-\\\\d+[BKMG]\\\\)\");\n+        }\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/TrimLibcHeapTest.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"}]}