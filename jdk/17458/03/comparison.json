{"files":[{"patch":"@@ -3283,0 +3283,1 @@\n+                    rendererPane.removeAll();\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicTreeUI.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,208 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6507038\n+ * @summary Verifies memory leak in BasicTreeUI TreeCellRenderer\n+ * @run main TreeCellRendererLeakTest\n+ *\/\n+\n+import java.awt.Component;\n+import java.util.concurrent.CountDownLatch;\n+\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+import javax.swing.JTabbedPane;\n+import javax.swing.JTree;\n+import javax.swing.SwingUtilities;\n+import javax.swing.tree.DefaultMutableTreeNode;\n+import javax.swing.tree.DefaultTreeCellRenderer;\n+import javax.swing.tree.DefaultTreeModel;\n+import javax.swing.tree.TreeNode;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+\n+public class TreeCellRendererLeakTest {\n+\n+    static int smCount = 0;\n+\n+    private static JFrame frame;\n+    private JPanel jPanel1;\n+    private JPanel jPanel2;\n+    private JScrollPane jScrollPane1;\n+    private JTabbedPane jTabbedPane1;\n+    private JTree jTree1;\n+\n+    static CountDownLatch testDone;\n+\n+    ArrayList<WeakReference<JLabel>> weakRefArrLabel = new ArrayList(50);\n+\n+    \/\/ Custom TreeCellRenderer\n+    public class TreeCellRenderer extends DefaultTreeCellRenderer {\n+\n+        public TreeCellRenderer() {}\n+\n+        \/\/ Create a new JLabel every time\n+        public Component getTreeCellRendererComponent(\n+                JTree tree,\n+                Object value,\n+                boolean sel,\n+                boolean expanded,\n+                boolean leaf,\n+                int row,\n+                boolean hasFocus) {\n+            JLabel label = new JLabel();\n+            label.setText(\"TreeNode: \" + value.toString());\n+            if (sel) {\n+                label.setBackground(getBackgroundSelectionColor());\n+            } else {\n+                label.setBackground(getBackgroundNonSelectionColor());\n+            }\n+\n+            weakRefArrLabel.add(smCount++, new WeakReference<JLabel>(label));\n+            return label;\n+        }\n+    }\n+\n+    public TreeCellRendererLeakTest() {\n+        initComponents();\n+        jTree1.setCellRenderer(new TreeCellRenderer());\n+        Thread updateThread = new Thread(this::runChanges);\n+        updateThread.setDaemon(true);\n+        updateThread.start();\n+        Thread infoThread = new Thread(this::runInfo);\n+        infoThread.setDaemon(true);\n+        infoThread.start();\n+    }\n+\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\" Generated Code \">\n+    private void initComponents() {\n+        jTabbedPane1 = new javax.swing.JTabbedPane();\n+        jPanel1 = new javax.swing.JPanel();\n+        jScrollPane1 = new javax.swing.JScrollPane();\n+        jTree1 = new javax.swing.JTree();\n+        jPanel2 = new javax.swing.JPanel();\n+\n+        jPanel1.setLayout(new java.awt.BorderLayout());\n+\n+        jScrollPane1.setViewportView(jTree1);\n+\n+        jPanel1.add(jScrollPane1, java.awt.BorderLayout.CENTER);\n+\n+        jTabbedPane1.addTab(\"tab1\", jPanel1);\n+\n+        jPanel2.setLayout(new java.awt.BorderLayout());\n+\n+        jTabbedPane1.addTab(\"tab2\", jPanel2);\n+\n+        jTabbedPane1.setSelectedIndex(1);\n+\n+        frame = new JFrame();\n+        frame.getContentPane().add(jTabbedPane1, java.awt.BorderLayout.CENTER);\n+\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\/\/ <\/editor-fold>\n+\n+    public static void main(String args[]) throws Exception {\n+        try {\n+            testDone = new CountDownLatch(1);\n+            SwingUtilities.invokeAndWait(() -> {\n+                TreeCellRendererLeakTest tf = new TreeCellRendererLeakTest();\n+            });\n+            testDone.await();\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    \/\/ Periodically cause a nodeChanged() for one of the nodes\n+    public void runChanges() {\n+        long count = 0;\n+        long time = System.currentTimeMillis();\n+        long tm = System.currentTimeMillis();\n+        while ((tm - time) < (15 * 1000)) {\n+            final long currentCount = count;\n+            try {\n+                SwingUtilities.invokeAndWait(new Runnable( ) {\n+                    public void run( ) {\n+                        DefaultTreeModel model = (DefaultTreeModel) jTree1.getModel();\n+                        TreeNode root = (TreeNode) model.getRoot();\n+                        DefaultMutableTreeNode n = (DefaultMutableTreeNode) model.getChild(root, 0);\n+                        n.setUserObject(\"runcount \" + currentCount);\n+                        model.nodeChanged(n);\n+                    }\n+                });\n+                count++;\n+                Thread.sleep(1000);\n+                tm = System.currentTimeMillis();\n+                System.out.println(\"time elapsed \" + (tm - time)\/1000 + \" s\");\n+            } catch (InterruptedException ex) {\n+                break;\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }\n+        testDone.countDown();\n+    }\n+\n+    \/\/ Print number of uncollected JLabels\n+    public void runInfo() {\n+        long time = System.currentTimeMillis();\n+        long initialCnt = smCount;\n+        while ((System.currentTimeMillis() - time) < (15 * 1000)) {\n+            System.gc();\n+            System.out.println(\"Live JLabels:\" + smCount);\n+            try {\n+                Thread.sleep(1000);\n+            } catch (InterruptedException ex) {\n+                ex.printStackTrace();\n+            }\n+        }\n+\n+        System.out.println(\"\\ncleanedup LabelCount \" + getCleanedUpLabelCount());\n+        if (getCleanedUpLabelCount() == 0) {\n+            throw new RuntimeException(\"TreeCellRenderer component leaked\");\n+        }\n+    }\n+\n+    private int getCleanedUpLabelCount() {\n+        int count = 0;\n+        for (WeakReference<JLabel> ref : weakRefArrLabel) {\n+            if (ref.get() == null) {\n+                count++;\n+            }\n+        }\n+        return count;\n+    }\n+\n+}\n","filename":"test\/jdk\/javax\/swing\/plaf\/basic\/BasicTreeUI\/TreeCellRendererLeakTest.java","additions":208,"deletions":0,"binary":false,"changes":208,"status":"added"}]}