{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -3283,1 +3283,4 @@\n-                    \/\/ Only ever removed when UI changes, this is OK!\n+                    \/\/ Remove previously added components to prevent leak\n+                    \/\/ and add the current component returned by cellrenderer for\n+                    \/\/ painting and other measurements\n+                    rendererPane.removeAll();\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicTreeUI.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6507038\n+ * @key headful\n+ * @summary Verifies memory leak in BasicTreeUI TreeCellRenderer\n+ * @run main TreeCellRendererLeakTest\n+ *\/\n+\n+import java.awt.Component;\n+import java.lang.ref.PhantomReference;\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+import javax.swing.JTabbedPane;\n+import javax.swing.JTree;\n+import javax.swing.SwingUtilities;\n+import javax.swing.tree.DefaultMutableTreeNode;\n+import javax.swing.tree.DefaultTreeCellRenderer;\n+import javax.swing.tree.DefaultTreeModel;\n+import javax.swing.tree.TreeNode;\n+\n+public final class TreeCellRendererLeakTest {\n+\n+    private static JFrame frame;\n+    private JPanel jPanel1;\n+    private JPanel jPanel2;\n+    private JScrollPane jScrollPane1;\n+    private JTabbedPane jTabbedPane1;\n+    private JTree jTree1;\n+    private DefaultMutableTreeNode defTreeNode;\n+    private DefaultTreeModel model;\n+\n+    private static final CountDownLatch testDone = new CountDownLatch(1);\n+\n+    \/\/ Access to referenceList and referenceQueue is guarded by referenceList\n+    private static final List<Reference<JLabel>> referenceList = new ArrayList<>(50);\n+    private static final ReferenceQueue<JLabel> referenceQueue = new ReferenceQueue<>();\n+\n+\n+    \/\/ Custom TreeCellRenderer\n+    public static final class TreeCellRenderer extends DefaultTreeCellRenderer {\n+\n+        public TreeCellRenderer() {}\n+\n+        \/\/ Create a new JLabel every time\n+        @Override\n+        public Component getTreeCellRendererComponent(\n+                JTree tree,\n+                Object value,\n+                boolean sel,\n+                boolean expanded,\n+                boolean leaf,\n+                int row,\n+                boolean hasFocus) {\n+            JLabel label = new JLabel();\n+            label.setText(\"TreeNode: \" + value.toString());\n+            if (sel) {\n+                label.setBackground(getBackgroundSelectionColor());\n+            } else {\n+                label.setBackground(getBackgroundNonSelectionColor());\n+            }\n+\n+            synchronized (referenceList) {\n+                referenceList.add(new PhantomReference<>(label, referenceQueue));\n+            }\n+            return label;\n+        }\n+    }\n+\n+    public TreeCellRendererLeakTest() {\n+        initComponents();\n+        jTree1.setCellRenderer(new TreeCellRenderer());\n+        Thread updateThread = new Thread(this::runChanges);\n+        updateThread.setDaemon(true);\n+        updateThread.start();\n+        Thread infoThread = new Thread(this::runInfo);\n+        infoThread.setDaemon(true);\n+        infoThread.start();\n+    }\n+\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\" Generated Code \">\n+    private void initComponents() {\n+        jTabbedPane1 = new javax.swing.JTabbedPane();\n+        jPanel1 = new javax.swing.JPanel();\n+        jScrollPane1 = new javax.swing.JScrollPane();\n+        jTree1 = new javax.swing.JTree();\n+        jPanel2 = new javax.swing.JPanel();\n+\n+        jPanel1.setLayout(new java.awt.BorderLayout());\n+\n+        jScrollPane1.setViewportView(jTree1);\n+\n+        jPanel1.add(jScrollPane1, java.awt.BorderLayout.CENTER);\n+\n+        jTabbedPane1.addTab(\"tab1\", jPanel1);\n+\n+        jPanel2.setLayout(new java.awt.BorderLayout());\n+\n+        jTabbedPane1.addTab(\"tab2\", jPanel2);\n+\n+        jTabbedPane1.setSelectedIndex(1);\n+\n+        model = (DefaultTreeModel) jTree1.getModel();\n+        TreeNode root = (TreeNode) model.getRoot();\n+        defTreeNode = (DefaultMutableTreeNode) model.getChild(root, 0);\n+\n+        frame = new JFrame();\n+        frame.getContentPane().add(jTabbedPane1, java.awt.BorderLayout.CENTER);\n+\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\/\/ <\/editor-fold>\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            SwingUtilities.invokeAndWait(() -> {\n+                new TreeCellRendererLeakTest();\n+            });\n+            testDone.await();\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    \/\/ Periodically cause a nodeChanged() for one of the nodes\n+    public void runChanges() {\n+        long count = 0;\n+        long time = System.currentTimeMillis();\n+        long tm = System.currentTimeMillis();\n+        while ((tm - time) < (15 * 1000)) {\n+            final long currentCount = count;\n+            try {\n+                SwingUtilities.invokeAndWait(() -> {\n+                    defTreeNode.setUserObject(\"runcount \" + currentCount);\n+                    model.nodeChanged(defTreeNode);\n+                });\n+                count++;\n+                Thread.sleep(1000);\n+                tm = System.currentTimeMillis();\n+                System.out.println(\"time elapsed \" + (tm - time)\/1000 + \" s\");\n+            } catch (InterruptedException ex) {\n+                break;\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }\n+        testDone.countDown();\n+    }\n+\n+    \/\/ Print number of uncollected JLabels\n+    public void runInfo() {\n+        final long time = System.currentTimeMillis();\n+        long removedLabels = 0;\n+        while ((System.currentTimeMillis() - time) < (15 * 1000)) {\n+            System.gc();\n+\n+            int start;\n+            int removed = 0;\n+            int left;\n+            \/\/ Remove dead references\n+            synchronized (referenceList) {\n+                start = referenceList.size();\n+                Reference<?> ref;\n+                while ((ref = referenceQueue.poll()) != null) {\n+                    referenceList.remove(ref);\n+                    removed++;\n+                }\n+                left = referenceList.size();\n+            }\n+            removedLabels += removed;\n+            System.out.println(\"Live JLabels: \" + start + \" - \" + removed + \" = \" + left);\n+            System.out.println(\"All time removed: \" + removedLabels);\n+            try {\n+                Thread.sleep(1000);\n+            } catch (InterruptedException ex) {\n+                ex.printStackTrace();\n+                break;\n+            }\n+        }\n+\n+        System.out.println(\"\\nCleaned up labels: \" + removedLabels);\n+        if (removedLabels == 0) {\n+            throw new RuntimeException(\"TreeCellRenderer component leaked\");\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/javax\/swing\/plaf\/basic\/BasicTreeUI\/TreeCellRendererLeakTest.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"}]}