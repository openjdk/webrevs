{"files":[{"patch":"@@ -3283,0 +3283,3 @@\n+                    for (int i = 0; i < rendererPane.getComponentCount(); i++) {\n+                        rendererPane.remove(i);\n+                    }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicTreeUI.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,207 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6507038\n+ * @summary Verifies memory leak in BasicTreeUI TreeCellRenderer \n+ * @run main TreeCellRendererLeakTest\n+ *\/\n+\n+import java.awt.Component;\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+import javax.swing.JTabbedPane;\n+import javax.swing.JTree;\n+import javax.swing.SwingUtilities;\n+import javax.swing.tree.DefaultMutableTreeNode;\n+import javax.swing.tree.DefaultTreeCellRenderer;\n+import javax.swing.tree.DefaultTreeModel;\n+import javax.swing.tree.TreeNode;\n+\n+public class TreeCellRendererLeakTest {\n+    \n+    static long smCount = 0;\n+    static boolean done;    \n+\n+    private static JFrame frame;\n+    private JPanel jPanel1;\n+    private JPanel jPanel2;\n+    private JScrollPane jScrollPane1;\n+    private JTabbedPane jTabbedPane1;\n+    private JTree jTree1;\n+    \/\/ End of variables declaration\n+    \n+    \/\/ JLabel with an instance counter\n+    public class TestLabel extends JLabel {\n+        public TestLabel() {\n+            smCount++;\n+        }\n+        \n+        public void finalize( ) {\n+            smCount--;\n+        }\n+    }\n+    \n+    \/\/ Custom TreeCellRenderer\n+    public class TreeCellRenderer extends DefaultTreeCellRenderer {\n+        \n+        public TreeCellRenderer( ) {\n+        }\n+        \n+        \/\/ Create a new JLabel every time\n+        public Component getTreeCellRendererComponent(\n+                JTree tree,\n+                Object value,\n+                boolean sel,\n+                boolean expanded,\n+                boolean leaf,\n+                int row,\n+                boolean hasFocus) {\n+            JLabel label = new TestLabel( );\n+            label.setText(\"TreeNode: \" + value.toString());\n+            if (sel) {\n+                label.setBackground(getBackgroundSelectionColor());\n+            } else {\n+                label.setBackground(getBackgroundNonSelectionColor());\n+            }\n+            \n+            return label;\n+        }\n+    }\n+    \n+    public TreeCellRendererLeakTest() {\n+        initComponents();\n+        jTree1.setCellRenderer(new TreeCellRenderer());\n+        Thread updateThread = new Thread(new Runnable( ) {\n+            public void run( ) {\n+                runChanges( );\n+            }\n+        });\n+        updateThread.setDaemon(true);\n+        updateThread.start();\n+        Thread infoThread = new Thread(new Runnable( ) {\n+            public void run( ) {\n+                runInfo( );\n+            }\n+        });\n+        infoThread.setDaemon(true);\n+        infoThread.start();\n+    }\n+    \n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\" Generated Code \">\n+    private void initComponents() {\n+        jTabbedPane1 = new javax.swing.JTabbedPane();\n+        jPanel1 = new javax.swing.JPanel();\n+        jScrollPane1 = new javax.swing.JScrollPane();\n+        jTree1 = new javax.swing.JTree();\n+        jPanel2 = new javax.swing.JPanel();\n+\n+        jPanel1.setLayout(new java.awt.BorderLayout());\n+\n+        jScrollPane1.setViewportView(jTree1);\n+\n+        jPanel1.add(jScrollPane1, java.awt.BorderLayout.CENTER);\n+\n+        jTabbedPane1.addTab(\"tab1\", jPanel1);\n+\n+        jPanel2.setLayout(new java.awt.BorderLayout());\n+\n+        jTabbedPane1.addTab(\"tab2\", jPanel2);\n+\n+        jTabbedPane1.setSelectedIndex(1);\n+\n+        frame = new JFrame();\n+        frame.getContentPane().add(jTabbedPane1, java.awt.BorderLayout.CENTER);\n+\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\/\/ <\/editor-fold>\n+    \n+    public static void main(String args[]) throws Exception {\n+        try {\n+            SwingUtilities.invokeAndWait(() -> {\n+                TreeCellRendererLeakTest tf = new TreeCellRendererLeakTest();\n+            });\n+            while (!done) {\n+                Thread.sleep(100);\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        } \n+    }\n+    \n+    \/\/ Periodically cause a nodeChanged() for one of the nodes\n+    public void runChanges() {\n+        long count = 0;\n+        long time = System.currentTimeMillis();\n+        long tm = System.currentTimeMillis();\n+        while ((tm - time) < (30 * 1000)) {\n+            final long currentCount = count;\n+            try {\n+                SwingUtilities.invokeAndWait(new Runnable( ) {\n+                    public void run( ) {\n+                        DefaultTreeModel model = (DefaultTreeModel) jTree1.getModel();\n+                        TreeNode root = (TreeNode) model.getRoot();\n+                        DefaultMutableTreeNode n = (DefaultMutableTreeNode) model.getChild(root, 0);\n+                        n.setUserObject(\"runcount \" + currentCount);\n+                        model.nodeChanged(n);\n+                    }\n+                });\n+                count++;\n+                Thread.sleep(1000);\n+                tm = System.currentTimeMillis();\n+                System.out.println(\"time elapsed \" + (tm - time));\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+            }\n+        }\n+        done = true;\n+    }\n+    \n+    \/\/ Print number of uncollected TestLabels\n+    public void runInfo( ) {\n+        long time = System.currentTimeMillis();\n+        long initialCnt = smCount;\n+        while ((System.currentTimeMillis() - time) < (30 * 1000)) {\n+            System.gc();\n+            System.err.println(\"Live TestLabels:\" + smCount);\n+            try {\n+                Thread.sleep(1000);\n+            } catch (InterruptedException ex) {\n+                ex.printStackTrace();\n+            }\n+        }\n+        if (smCount - initialCnt > 50) {\n+            throw new RuntimeException(\"TreeCellRenderer component leaked\");\n+        }\n+    }\n+    \n+}\n","filename":"test\/jdk\/javax\/swing\/plaf\/basic\/BasicTreeUI\/TreeCellRendererLeakTest.java","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"}]}