{"files":[{"patch":"@@ -33,0 +33,1 @@\n+#include \"cppstdlib\/new.hpp\"\n@@ -138,2 +139,2 @@\n-         (_dc_and_los == 0) &&\n-         (_shadow_state == 0);\n+         (dc_and_los() == 0) &&\n+         (shadow_state() == 0);\n@@ -148,2 +149,2 @@\n-  assert(_dc_and_los == 0, \"inv\");\n-  assert(_shadow_state == 0, \"inv\");\n+  assert(dc_and_los() == 0, \"inv\");\n+  assert(shadow_state() == 0, \"inv\");\n@@ -299,1 +300,3 @@\n-  memset(_region_data + beg_region, 0, region_cnt * sizeof(RegionData));\n+  for (size_t i = beg_region; i < end_region; i++) {\n+    ::new (&_region_data[i]) RegionData{};\n+  }\n@@ -1297,1 +1300,1 @@\n-void PSParallelCompact::adjust_in_space_helper(SpaceId id, volatile uint* claim_counter, Func&& on_stripe) {\n+void PSParallelCompact::adjust_in_space_helper(SpaceId id, Atomic<uint>* claim_counter, Func&& on_stripe) {\n@@ -1310,1 +1313,1 @@\n-    uint counter = AtomicAccess::fetch_then_add(claim_counter, num_regions_per_stripe);\n+    uint counter = claim_counter->fetch_then_add(num_regions_per_stripe);\n@@ -1320,1 +1323,1 @@\n-void PSParallelCompact::adjust_in_old_space(volatile uint* claim_counter) {\n+void PSParallelCompact::adjust_in_old_space(Atomic<uint>* claim_counter) {\n@@ -1351,1 +1354,1 @@\n-void PSParallelCompact::adjust_in_young_space(SpaceId id, volatile uint* claim_counter) {\n+void PSParallelCompact::adjust_in_young_space(SpaceId id, Atomic<uint>* claim_counter) {\n@@ -1365,1 +1368,1 @@\n-void PSParallelCompact::adjust_pointers_in_spaces(uint worker_id, volatile uint* claim_counters) {\n+void PSParallelCompact::adjust_pointers_in_spaces(uint worker_id, Atomic<uint>* claim_counters) {\n@@ -1379,2 +1382,2 @@\n-  volatile bool                              _code_cache_claimed;\n-  volatile uint _claim_counters[PSParallelCompact::last_space_id] = {};\n+  Atomic<bool>                               _code_cache_claimed;\n+  Atomic<uint> _claim_counters[PSParallelCompact::last_space_id];\n@@ -1383,2 +1386,2 @@\n-    return AtomicAccess::load(&_code_cache_claimed) == false\n-        && AtomicAccess::cmpxchg(&_code_cache_claimed, false, true) == false;\n+    return _code_cache_claimed.load_relaxed() == false\n+        && _code_cache_claimed.compare_set(false, true);\n@@ -1396,0 +1399,3 @@\n+    for (unsigned int i = PSParallelCompact::old_space_id; i < PSParallelCompact::last_space_id; ++i) {\n+      ::new (&_claim_counters[i]) Atomic<uint>{};\n+    }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":20,"deletions":14,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-#include \"runtime\/atomicAccess.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -239,1 +239,1 @@\n-    size_t live_obj_size() const { return _dc_and_los & los_mask; }\n+    size_t live_obj_size() const { return dc_and_los() & los_mask; }\n@@ -271,3 +271,3 @@\n-    bool available() const { return _dc_and_los < dc_one; }\n-    bool claimed()   const { return _dc_and_los >= dc_claimed; }\n-    bool completed() const { return _dc_and_los >= dc_completed; }\n+    bool available() const { return dc_and_los() < dc_one; }\n+    bool claimed()   const { return dc_and_los() >= dc_claimed; }\n+    bool completed() const { return dc_and_los() >= dc_completed; }\n@@ -318,1 +318,1 @@\n-    int shadow_state() { return _shadow_state; }\n+    int shadow_state() { return _shadow_state.load_relaxed(); }\n@@ -342,2 +342,2 @@\n-    region_sz_t volatile _dc_and_los;\n-    int         volatile _shadow_state;\n+    Atomic<region_sz_t>  _dc_and_los;\n+    Atomic<int>          _shadow_state;\n@@ -345,0 +345,1 @@\n+    region_sz_t dc_and_los() const { return _dc_and_los.load_relaxed(); }\n@@ -414,1 +415,1 @@\n-  return _dc_and_los & dc_mask;\n+  return dc_and_los() & dc_mask;\n@@ -428,1 +429,1 @@\n-  _dc_and_los = (count << dc_shift) | live_sz;\n+  _dc_and_los.store_relaxed((count << dc_shift) | live_sz);\n@@ -434,1 +435,1 @@\n-  _dc_and_los = destination_count_raw() | (region_sz_t)words;\n+  _dc_and_los.store_relaxed(destination_count_raw() | (region_sz_t)words);\n@@ -439,3 +440,3 @@\n-  assert(_dc_and_los < dc_claimed, \"already claimed\");\n-  assert(_dc_and_los >= dc_one, \"count would go negative\");\n-  AtomicAccess::add(&_dc_and_los, dc_mask);\n+  assert(dc_and_los() < dc_claimed, \"already claimed\");\n+  assert(dc_and_los() >= dc_one, \"count would go negative\");\n+  _dc_and_los.add_then_fetch(dc_mask);\n@@ -447,1 +448,1 @@\n-  _dc_and_los = dc_completed | (region_sz_t) live_obj_size();\n+  _dc_and_los.store_relaxed(dc_completed | (region_sz_t) live_obj_size());\n@@ -455,1 +456,1 @@\n-    _dc_and_los |= dc_claimed;\n+    _dc_and_los.store_relaxed(dc_and_los() | dc_claimed);\n@@ -464,1 +465,1 @@\n-  AtomicAccess::add(&_dc_and_los, static_cast<region_sz_t>(words));\n+  _dc_and_los.add_then_fetch(static_cast<region_sz_t>(words));\n@@ -470,2 +471,1 @@\n-  const region_sz_t old = AtomicAccess::cmpxchg(&_dc_and_los, los, dc_claimed | los);\n-  return old == los;\n+  return _dc_and_los.compare_set(los, dc_claimed | los);\n@@ -475,1 +475,1 @@\n-  return AtomicAccess::cmpxchg(&_shadow_state, UnusedRegion, NormalRegion) == UnusedRegion;\n+  return _shadow_state.compare_set(UnusedRegion, NormalRegion);\n@@ -479,2 +479,2 @@\n-  if (_shadow_state != UnusedRegion) return false;\n-  return AtomicAccess::cmpxchg(&_shadow_state, UnusedRegion, ShadowRegion) == UnusedRegion;\n+  if (shadow_state() != UnusedRegion) return false;\n+  return _shadow_state.compare_set(UnusedRegion, ShadowRegion);\n@@ -484,1 +484,1 @@\n-  int old = AtomicAccess::cmpxchg(&_shadow_state, ShadowRegion, FilledShadow);\n+  int old = _shadow_state.compare_exchange(ShadowRegion, FilledShadow);\n@@ -489,1 +489,1 @@\n-  return AtomicAccess::cmpxchg(&_shadow_state, FilledShadow, CopiedShadow) == FilledShadow;\n+  return _shadow_state.compare_set(FilledShadow, CopiedShadow);\n@@ -493,1 +493,1 @@\n-  int old = AtomicAccess::cmpxchg(&_shadow_state, ShadowRegion, NormalRegion);\n+  int old = _shadow_state.compare_exchange(ShadowRegion, NormalRegion);\n@@ -767,1 +767,1 @@\n-  static void adjust_in_space_helper(SpaceId id, volatile uint* claim_counter, Func&& on_stripe);\n+  static void adjust_in_space_helper(SpaceId id, Atomic<uint>* claim_counter, Func&& on_stripe);\n@@ -769,1 +769,1 @@\n-  static void adjust_in_old_space(volatile uint* claim_counter);\n+  static void adjust_in_old_space(Atomic<uint>* claim_counter);\n@@ -771,1 +771,1 @@\n-  static void adjust_in_young_space(SpaceId id, volatile uint* claim_counter);\n+  static void adjust_in_young_space(SpaceId id, Atomic<uint>* claim_counter);\n@@ -773,1 +773,1 @@\n-  static void adjust_pointers_in_spaces(uint worker_id, volatile uint* claim_counter);\n+  static void adjust_pointers_in_spaces(uint worker_id, Atomic<uint>* claim_counter);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"}]}