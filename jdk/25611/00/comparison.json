{"files":[{"patch":"@@ -357,1 +357,3 @@\n-    humongous_start = _hrm.expand_and_allocate_humongous(obj_regions);\n+    if (obj_regions <= num_available_regions()) {\n+      humongous_start = _hrm.expand_and_allocate_humongous(obj_regions);\n+    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -972,1 +972,1 @@\n-    return num_inactive_regions() == 0 && num_free_regions() == 0;\n+    return num_available_regions() == 0;\n@@ -991,1 +991,1 @@\n-  uint num_available_regions() const { return _hrm.num_available_regions(); }\n+  uint num_available_regions() const { return num_free_regions() + num_inactive_regions(); }\n@@ -997,1 +997,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -480,4 +480,0 @@\n-  \/\/ Check if we can actually satisfy the allocation.\n-  if (num_regions > num_available_regions()) {\n-    return G1_NO_HRM_INDEX;\n-  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -242,2 +242,0 @@\n-  uint num_available_regions() const { return num_free_regions() + num_inactive_regions(); }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}