{"files":[{"patch":"@@ -2852,1 +2852,1 @@\n-JNI_CRITICAL_RELEASE_ENTRY(void, jni_ReleasePrimitiveArrayCritical(JNIEnv *env, jarray array, void *carray, jint mode))\n+JNI_ENTRY(void, jni_ReleasePrimitiveArrayCritical(JNIEnv *env, jarray array, void *carray, jint mode))\n@@ -2891,1 +2891,1 @@\n-JNI_CRITICAL_RELEASE_ENTRY(void, jni_ReleaseStringCritical(JNIEnv *env, jstring str, const jchar *chars))\n+JNI_ENTRY(void, jni_ReleaseStringCritical(JNIEnv *env, jstring str, const jchar *chars))\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-  static inline void transition_from_native(JavaThread *thread, JavaThreadState to, bool check_asyncs = true, bool with_exit_check = true) {\n+  static inline void transition_from_native(JavaThread *thread, JavaThreadState to, bool check_asyncs = true) {\n@@ -106,5 +106,1 @@\n-    if (with_exit_check) {\n-      SafepointMechanism::process_if_requested_with_exit_check(thread, to != _thread_in_Java ? false : check_asyncs);\n-    } else {\n-      SafepointMechanism::process_if_requested(thread, true \/* allow_suspend *\/, to != _thread_in_Java ? false : check_asyncs);\n-    }\n+    SafepointMechanism::process_if_requested_with_exit_check(thread, to != _thread_in_Java ? false : check_asyncs);\n@@ -187,12 +183,0 @@\n-class ThreadInVMfromNativeNoExitCheck : public ThreadStateTransition {\n-  ResetNoHandleMark __rnhm;\n- public:\n-  ThreadInVMfromNativeNoExitCheck(JavaThread* thread) : ThreadStateTransition(thread) {\n-    transition_from_native(thread, _thread_in_vm, true \/* check asyncs *\/, false \/* with_exit_check *\/);\n-  }\n-  ~ThreadInVMfromNativeNoExitCheck() {\n-    \/\/ We cannot assert !_thread->owns_locks() since we have valid cases where\n-    \/\/ we call known native code using this wrapper holding locks.\n-    transition_from_vm(_thread, _thread_in_native);\n-  }\n-};\n@@ -382,11 +366,0 @@\n-#define JNI_CRITICAL_RELEASE_ENTRY(result_type, header)              \\\n-extern \"C\" {                                                         \\\n-  result_type JNICALL header {                                       \\\n-    JavaThread* thread=JavaThread::thread_from_jni_environment(env); \\\n-    assert(thread == Thread::current(), \"JNIEnv is only valid in same thread\"); \\\n-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \\\n-    ThreadInVMfromNativeNoExitCheck __tiv(thread);                   \\\n-    DEBUG_ONLY(VMNativeEntryWrapper __vew;)                          \\\n-    VM_ENTRY_BASE(result_type, header, thread)                       \\\n-    WeakPreserveExceptionMark __wem(thread);\n-\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":2,"deletions":29,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1055,1 +1055,4 @@\n-  if (is_obj_deopt_suspend()) {\n+  \/\/ We mustn't block for object deopt if the thread is\n+  \/\/ currently executing in a JNI critical region, as that\n+  \/\/ can cause deadlock because the GCLocker is held.\n+  if (is_obj_deopt_suspend() && !in_critical()) {\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}