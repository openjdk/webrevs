{"files":[{"patch":"@@ -2852,1 +2852,1 @@\n-JNI_ENTRY(void, jni_ReleasePrimitiveArrayCritical(JNIEnv *env, jarray array, void *carray, jint mode))\n+JNI_CRITICAL_RELEASE_ENTRY(void, jni_ReleasePrimitiveArrayCritical(JNIEnv *env, jarray array, void *carray, jint mode))\n@@ -2891,1 +2891,1 @@\n-JNI_ENTRY(void, jni_ReleaseStringCritical(JNIEnv *env, jstring str, const jchar *chars))\n+JNI_CRITICAL_RELEASE_ENTRY(void, jni_ReleaseStringCritical(JNIEnv *env, jstring str, const jchar *chars))\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-  static inline void transition_from_native(JavaThread *thread, JavaThreadState to, bool check_asyncs = true) {\n+  static inline void transition_from_native(JavaThread *thread, JavaThreadState to, bool check_asyncs = true, bool with_exit_check = true) {\n@@ -106,1 +106,5 @@\n-    SafepointMechanism::process_if_requested_with_exit_check(thread, to != _thread_in_Java ? false : check_asyncs);\n+    if (with_exit_check) {\n+      SafepointMechanism::process_if_requested_with_exit_check(thread, to != _thread_in_Java ? false : check_asyncs);\n+    } else {\n+      SafepointMechanism::process_if_requested(thread, true \/* allow_suspend *\/, to != _thread_in_Java ? false : check_asyncs);\n+    }\n@@ -183,0 +187,12 @@\n+class ThreadInVMfromNativeNoExitCheck : public ThreadStateTransition {\n+  ResetNoHandleMark __rnhm;\n+ public:\n+  ThreadInVMfromNativeNoExitCheck(JavaThread* thread) : ThreadStateTransition(thread) {\n+    transition_from_native(thread, _thread_in_vm, true \/* check asyncs *\/, false \/* with_exit_check *\/);\n+  }\n+  ~ThreadInVMfromNativeNoExitCheck() {\n+    \/\/ We cannot assert !_thread->owns_locks() since we have valid cases where\n+    \/\/ we call known native code using this wrapper holding locks.\n+    transition_from_vm(_thread, _thread_in_native);\n+  }\n+};\n@@ -366,0 +382,11 @@\n+#define JNI_CRITICAL_RELEASE_ENTRY(result_type, header)              \\\n+extern \"C\" {                                                         \\\n+  result_type JNICALL header {                                       \\\n+    JavaThread* thread=JavaThread::thread_from_jni_environment(env); \\\n+    assert(thread == Thread::current(), \"JNIEnv is only valid in same thread\"); \\\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \\\n+    ThreadInVMfromNativeNoExitCheck __tiv(thread);                   \\\n+    DEBUG_ONLY(VMNativeEntryWrapper __vew;)                          \\\n+    VM_ENTRY_BASE(result_type, header, thread)                       \\\n+    WeakPreserveExceptionMark __wem(thread);\n+\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"}]}