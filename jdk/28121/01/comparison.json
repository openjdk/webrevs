{"files":[{"patch":"@@ -80,0 +80,1 @@\n+#include \"oops\/constantPool.inline.hpp\"\n@@ -85,0 +86,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -522,1 +524,13 @@\n-static void rewrite_nofast_bytecode(const methodHandle& method) {\n+\/\/ In AOTCache workflow, when dumping preimage, the constant pool entries are stored in unresolved state.\n+\/\/ So the fast version of getfield\/putfield needs to be converted to nofast version.\n+\/\/ When dumping the final image in the assembly phase, these nofast versions are converted back to fast versions\n+\/\/ if the constant pool entry refered by these bytecodes is stored in resolved state.\n+\/\/ Same principle applies to static and dynamic archives. If the constant pool entry is in resolved state, then\n+\/\/ the fast version of the bytecodes can be preserved, else use the nofast version.\n+\/\/\n+\/\/ The fast versions of aload_0 (i.e. _fast_Xaccess_0) merges the bytecode pair (aload_0, fast_Xgetfield).\n+\/\/ If the fast version of aload_0 is preserved in AOTCache, then the JVMTI notifications for field access and\n+\/\/ breakpoint events will be skipped for the second bytecode (fast_Xgetfield) in the pair.\n+\/\/ Same holds for fast versions of iload_0. So for these bytecodes, nofast version is used.\n+static void rewrite_bytecodes(const methodHandle& method) {\n+  ConstantPool* cp = method->constants();\n@@ -524,0 +538,9 @@\n+  Bytecodes::Code new_code;\n+\n+  LogStreamHandle(Trace, aot, resolve) lsh;\n+  if (lsh.is_enabled()) {\n+    lsh.print(\"Rewriting bytecodes for \");\n+    method()->print_external_name(&lsh);\n+    lsh.print(\"\\n\");\n+  }\n+\n@@ -526,5 +549,59 @@\n-    switch (opcode) {\n-    case Bytecodes::_getfield:      *bcs.bcp() = Bytecodes::_nofast_getfield;      break;\n-    case Bytecodes::_putfield:      *bcs.bcp() = Bytecodes::_nofast_putfield;      break;\n-    case Bytecodes::_aload_0:       *bcs.bcp() = Bytecodes::_nofast_aload_0;       break;\n-    case Bytecodes::_iload: {\n+    \/\/ Use current opcode as the default value of new_code\n+    new_code = opcode;\n+    switch(opcode) {\n+    case Bytecodes::_getfield: {\n+      uint rfe_index = bcs.get_index_u2();\n+      bool is_resolved = cp->is_resolved(rfe_index, opcode);\n+      if (is_resolved) {\n+        assert(!CDSConfig::is_dumping_preimage_static_archive(), \"preimage should not have resolved field references\");\n+        ResolvedFieldEntry* rfe = cp->resolved_field_entry_at(bcs.get_index_u2());\n+        switch(rfe->tos_state()) {\n+        case btos:\n+          \/\/ fallthrough\n+        case ztos: new_code = Bytecodes::_fast_bgetfield; break;\n+        case atos: new_code = Bytecodes::_fast_agetfield; break;\n+        case itos: new_code = Bytecodes::_fast_igetfield; break;\n+        case ctos: new_code = Bytecodes::_fast_cgetfield; break;\n+        case stos: new_code = Bytecodes::_fast_sgetfield; break;\n+        case ltos: new_code = Bytecodes::_fast_lgetfield; break;\n+        case ftos: new_code = Bytecodes::_fast_fgetfield; break;\n+        case dtos: new_code = Bytecodes::_fast_dgetfield; break;\n+        default:\n+          ShouldNotReachHere();\n+          break;\n+        }\n+      } else {\n+        new_code = Bytecodes::_nofast_getfield;\n+      }\n+      break;\n+    }\n+    case Bytecodes::_putfield: {\n+      uint rfe_index = bcs.get_index_u2();\n+      bool is_resolved = cp->is_resolved(rfe_index, opcode);\n+      if (is_resolved) {\n+        assert(!CDSConfig::is_dumping_preimage_static_archive(), \"preimage should not have resolved field references\");\n+        ResolvedFieldEntry* rfe = cp->resolved_field_entry_at(bcs.get_index_u2());\n+        switch(rfe->tos_state()) {\n+        case btos: new_code = Bytecodes::_fast_bputfield; break;\n+        case ztos: new_code = Bytecodes::_fast_zputfield; break;\n+        case atos: new_code = Bytecodes::_fast_aputfield; break;\n+        case itos: new_code = Bytecodes::_fast_iputfield; break;\n+        case ctos: new_code = Bytecodes::_fast_cputfield; break;\n+        case stos: new_code = Bytecodes::_fast_sputfield; break;\n+        case ltos: new_code = Bytecodes::_fast_lputfield; break;\n+        case ftos: new_code = Bytecodes::_fast_fputfield; break;\n+        case dtos: new_code = Bytecodes::_fast_dputfield; break;\n+        default:\n+          ShouldNotReachHere();\n+          break;\n+        }\n+      } else {\n+        new_code = Bytecodes::_nofast_putfield;\n+      }\n+      break;\n+    }\n+    case Bytecodes::_aload_0:\n+      \/\/ Revert _fast_Xaccess_0 or _aload_0 to _nofast_aload_0\n+      new_code = Bytecodes::_nofast_aload_0;\n+      break;\n+    case Bytecodes::_iload:\n@@ -532,1 +609,1 @@\n-        *bcs.bcp() = Bytecodes::_nofast_iload;\n+        new_code = Bytecodes::_nofast_iload;\n@@ -535,0 +612,2 @@\n+    default:\n+      break;\n@@ -536,1 +615,5 @@\n-    default: break;\n+    if (opcode != new_code) {\n+      *bcs.bcp() = new_code;\n+      if (lsh.is_enabled()) {\n+        lsh.print_cr(\"%d:%s -> %s\", bcs.bci(), Bytecodes::name(opcode), Bytecodes::name(new_code));\n+      }\n@@ -544,1 +627,1 @@\n-void AOTMetaspace::rewrite_nofast_bytecodes_and_calculate_fingerprints(Thread* thread, InstanceKlass* ik) {\n+void AOTMetaspace::rewrite_bytecodes_and_calculate_fingerprints(Thread* thread, InstanceKlass* ik) {\n@@ -548,1 +631,1 @@\n-      rewrite_nofast_bytecode(m);\n+      rewrite_bytecodes(m);\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.cpp","additions":93,"deletions":10,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-  static void rewrite_nofast_bytecodes_and_calculate_fingerprints(Thread* thread, InstanceKlass* ik);\n+  static void rewrite_bytecodes_and_calculate_fingerprints(Thread* thread, InstanceKlass* ik);\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -955,1 +955,1 @@\n-      AOTMetaspace::rewrite_nofast_bytecodes_and_calculate_fingerprints(Thread::current(), ik);\n+      AOTMetaspace::rewrite_bytecodes_and_calculate_fingerprints(Thread::current(), ik);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}