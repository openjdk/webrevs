{"files":[{"patch":"@@ -370,0 +370,8 @@\n+  product(uint, SuperWordAutomaticAlignment, 1, DIAGNOSTIC,                 \\\n+          \"0 = Disabled (unless AlignVector is enabled)\"                    \\\n+          \"Else: align with a load or store of the largest vector width,\"   \\\n+          \"      and if there are loads and stores of the largest width:\"   \\\n+          \"1 = Prefer alignment with vector store (default)\"                \\\n+          \"2 = Prefer alignment with vector load.\")                         \\\n+          range(0, 2)                                                       \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2668,1 +2668,12 @@\n-    if (vw > max_aw) {\n+    \/\/ Generally, we prefer to align with the largest memory op (load or store).\n+    \/\/ If there are multiple, then SuperWordAutomaticAlignment determines if we\n+    \/\/ prefer loads or stores.\n+    \/\/ When a load or store is misaligned, this can lead to the load or store\n+    \/\/ being split, when it goes over a cache line. Most CPUs can schedule\n+    \/\/ more loads than stores per cycle (often 2 loads and 1 store). Hence,\n+    \/\/ it is worse if a store is split, and less bad if a load is split.\n+    \/\/ By default, we have SuperWordAutomaticAlignment=1, i.e. we align with a\n+    \/\/ load if possible, to avoid splitting that load.\n+    bool prefer_store = mem_ref != nullptr && SuperWordAutomaticAlignment == 1 && mem_ref->is_Load() && p0->is_Store();\n+    bool prefer_load  = mem_ref != nullptr && SuperWordAutomaticAlignment == 2 && mem_ref->is_Store() && p0->is_Load();\n+    if (vw > max_aw || (vw == max_aw && (prefer_load || prefer_store))) {\n@@ -2695,0 +2706,10 @@\n+\n+  if (!VLoop::vectors_should_be_aligned() && SuperWordAutomaticAlignment == 0) {\n+#ifdef ASSERT\n+    if (_trace._align_vector) {\n+      tty->print_cr(\"\\nVTransform::adjust_pre_loop_limit_to_align_main_loop_vectors: disabled.\");\n+    }\n+#endif\n+    return;\n+  }\n+\n@@ -2915,0 +2936,1 @@\n+    TRACE_ALIGN_VECTOR_NODE(invar_variable);\n@@ -2924,0 +2946,1 @@\n+    TRACE_ALIGN_VECTOR_NODE(invar_scale_con);\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * The purpose of this benchmark is to see the effect of automatic alignment in auto vectorization.\n+ *\n+ * Note: If you are interested in a nice visualization of load and store misalignment, please look\n+ *       at the benchmark {@link VectorAutoAlignmentVisualization}.\n+ *\/\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 2, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 1)\n+public abstract class VectorAutoAlignment {\n+    @Param({\"1024\", \"1152\", \"1280\", \"1408\", \"1536\", \"1664\", \"1792\", \"1920\", \"1984\", \"2048\", \"2114\",\n+            \"2176\", \"2304\", \"2432\", \"2560\", \"2688\", \"2816\", \"2944\", \"3072\", \"3200\", \"3328\", \"3456\",\n+            \"3584\", \"3712\", \"3840\", \"3968\", \"4096\", \"4224\", \"4352\", \"4480\"})\n+    public int SIZE;\n+\n+    private MemorySegment ms;\n+\n+    @Setup\n+    public void init() throws Throwable {\n+        long totalSize = 4L * SIZE + 4L * SIZE;\n+        long alignment = 4 * 1024; \/\/ 4k = page size\n+        ms = Arena.ofAuto().allocate(totalSize, alignment);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void kernel1L1S(int offset_load, int offset_store) {\n+        for (int i = 0; i < SIZE - \/* slack for offset *\/ 32; i++) {\n+            int v = ms.get(ValueLayout.JAVA_INT_UNALIGNED, 4L * i + 4L * offset_load + 4L * SIZE);\n+            ms.set(ValueLayout.JAVA_INT_UNALIGNED, 4L * i + 4L * offset_store, v);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void bench1L1S() throws Throwable {\n+        \/\/ Go over all possible offsets, to get an average performance.\n+        for (int offset_load = 0; offset_load < 32; offset_load++) {\n+            for (int offset_store = 0; offset_store < 32; offset_store++) {\n+                kernel1L1S(offset_load, offset_store);\n+            }\n+        }\n+    }\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:-UseSuperWord\"\n+    })\n+    public static class NoVectorization extends VectorAutoAlignment {}\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:SuperWordAutomaticAlignment=0\"\n+    })\n+    public static class NoAutoAlign extends VectorAutoAlignment {}\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:SuperWordAutomaticAlignment=1\"\n+    })\n+    public static class AlignStore extends VectorAutoAlignment {}\n+\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:SuperWordAutomaticAlignment=2\"\n+    })\n+    public static class AlignLoad extends VectorAutoAlignment {}\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorAutoAlignment.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/*\n+\n+  The purpose of this benchmark is to see the effect of automatic alignment in auto vectorization.\n+  It is recommended to view the differing results when using SuperWordAutomaticAlignment.\n+\n+  Without automatic alignment, i.e. SuperWordAutomaticAlignment=0, we may get a plot like below, for bench1L1S:\n+\n+  OFFSET_STORE\n+  ^\n+  | ###############|X\n+  | ---------------0-  <--- store aligned\n+  | ##############X|#\n+  | #############X#|#\n+  | ############X##|#\n+  | ###########X###|#\n+  | ##########X####|#\n+  | #########X#####|#\n+  | ########X######|#\n+  | #######X#######|#\n+  | ######X########|#\n+  | #####X#########|#\n+  | ####X##########|#\n+  | ###X###########|#\n+  | ##X############|#\n+  | #X#############|#\n+  | X##############|#\n+    ---OFFSET_LOAD ---->\n+\n+                   ^\n+     loads aligned |\n+\n+  #: lowest performance, both misaligned and also relatively misaligned.\n+  X: low performance, both misaligned but relatively aligned.\n+  |: medium performance, load aligned, store misaligned.\n+  -: good performance, load misaligned, store aligned.\n+  0: extreme performance, load and store aligned.\n+\n+  Why is case \"-\" better than \"|\"? I.e. why are misaligned stores worse than misaligned loads?\n+  Misalignment means that a load or store goes over a cache line, and is split into two loads\n+  or stores. Most CPU's can execute 2 loads and 1 store per cycle, that is at least a partial\n+  explanation why we are more limited on stores than loads.\n+  No splitting, full alignment -> 1 load  and 1 store\n+  Split load, store aligned    -> 2 loads and 1 store\n+  Split store, load aligned    -> 1 load  and 2 stores\n+\n+  The warmup and measurement time is relatively short, but the benchmark already takes 25 min\n+  to go over the whole grid. This leads to some noise, but the pattern is very visible visually.\n+  Hence: this benchmark is more for visualization than for regression testing.\n+  For regression testing, please look at the related VectorAutoAlignment benchmark.\n+\n+  If you want to turn the JMH results into a table, then you may use this Java code.\n+\n+    import java.io.*;\n+    import java.util.ArrayList;\n+\n+    public class Extract {\n+        record Cell(int x, int y, float t) {}\n+\n+        public static void main(String[] args) throws Exception {\n+            String fileName = args[0];\n+            System.out.println(\"Loading from file: \" + fileName);\n+\n+            ArrayList<Cell> cells = new ArrayList<>();\n+\n+            try(BufferedReader br = new BufferedReader(new FileReader(fileName))) {\n+                for(String line; (line = br.readLine()) != null; ) {\n+                    System.out.println(line);\n+                    String[] parts = line.split(\"[ ]+\");\n+                    if (parts.length != 11) { continue; }\n+                    System.out.println(String.join(\" \", parts));\n+                    int x = Integer.parseInt(parts[2]);\n+                    int y = Integer.parseInt(parts[3]);\n+                    float t = Float.parseFloat(parts[7]);\n+                    System.out.println(\"x=\" + x + \", y=\" + y + \", t=\" + t);\n+                    cells.add(new Cell(x, y, t));\n+                }\n+            }\n+\n+            int maxX = cells.stream().mapToInt(c -> c.x).max().getAsInt();\n+            int maxY = cells.stream().mapToInt(c -> c.y).max().getAsInt();\n+            float[][] grid = new float[maxX + 1][maxY + 1];\n+\n+            for (Cell c : cells) {\n+                grid[c.x][c.y] = c.t;\n+            }\n+\n+            for (int x = maxY; x >= 0; x--) {\n+                for (int y = 0; y <= maxY; y++) {\n+                    System.out.print(String.format(\"%.5f \", grid[x][y]));\n+                }\n+                System.out.println();\n+            }\n+            System.out.println(\"x-axis  (->)  LOAD_OFFSET\");\n+            System.out.println(\"y-axis  (up)  STORE_OFFSET\");\n+        }\n+    }\n+\n+ *\/\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 2, time = 200, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 3, time = 200, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(value = 1)\n+public class VectorAutoAlignmentVisualization {\n+    @Param({\"2560\"})\n+    public int SIZE;\n+\n+    @Param({  \"0\",   \"1\",   \"2\",   \"3\",   \"4\",   \"5\",   \"6\",   \"7\",   \"8\",   \"9\",\n+             \"10\",  \"11\",  \"12\",  \"13\",  \"14\",  \"15\",  \"16\",  \"17\",  \"18\",  \"19\",\n+             \"20\",  \"21\",  \"22\",  \"23\",  \"24\",  \"25\",  \"26\",  \"27\",  \"28\",  \"29\",\n+             \"30\",  \"31\"})\n+    public int OFFSET_LOAD;\n+\n+    @Param({  \"0\",   \"1\",   \"2\",   \"3\",   \"4\",   \"5\",   \"6\",   \"7\",   \"8\",   \"9\",\n+             \"10\",  \"11\",  \"12\",  \"13\",  \"14\",  \"15\",  \"16\",  \"17\",  \"18\",  \"19\",\n+             \"20\",  \"21\",  \"22\",  \"23\",  \"24\",  \"25\",  \"26\",  \"27\",  \"28\",  \"29\",\n+             \"30\",  \"31\"})\n+    public int OFFSET_STORE;\n+\n+    @Param({\"2000\"})\n+    public int DISTANCE;\n+\n+    \/\/ To get compile-time constants for OFFSET_LOAD, OFFSET_STORE, and DISTANCE\n+    static final MutableCallSite MUTABLE_CONSTANT_OFFSET_LOAD = new MutableCallSite(MethodType.methodType(int.class));\n+    static final MethodHandle MUTABLE_CONSTANT_OFFSET_LOAD_HANDLE = MUTABLE_CONSTANT_OFFSET_LOAD.dynamicInvoker();\n+    static final MutableCallSite MUTABLE_CONSTANT_OFFSET_STORE = new MutableCallSite(MethodType.methodType(int.class));\n+    static final MethodHandle MUTABLE_CONSTANT_OFFSET_STORE_HANDLE = MUTABLE_CONSTANT_OFFSET_STORE.dynamicInvoker();\n+    static final MutableCallSite MUTABLE_CONSTANT_DISTANCE = new MutableCallSite(MethodType.methodType(int.class));\n+    static final MethodHandle MUTABLE_CONSTANT_DISTANCE_HANDLE = MUTABLE_CONSTANT_DISTANCE.dynamicInvoker();\n+\n+    private MemorySegment ms;\n+\n+    @Setup\n+    public void init() throws Throwable {\n+        long totalSize = 4L * SIZE + 4L * DISTANCE;\n+        long alignment = 4 * 1024; \/\/ 4k = page size\n+        ms = Arena.ofAuto().allocate(totalSize, alignment);\n+\n+        MethodHandle offset_load_con = MethodHandles.constant(int.class, OFFSET_LOAD);\n+        MUTABLE_CONSTANT_OFFSET_LOAD.setTarget(offset_load_con);\n+        MethodHandle offset_store_con = MethodHandles.constant(int.class, OFFSET_STORE);\n+        MUTABLE_CONSTANT_OFFSET_STORE.setTarget(offset_store_con);\n+        MethodHandle distance_con = MethodHandles.constant(int.class, DISTANCE);\n+        MUTABLE_CONSTANT_DISTANCE.setTarget(distance_con);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    private int offset_load_con() throws Throwable {\n+        return (int) MUTABLE_CONSTANT_OFFSET_LOAD_HANDLE.invokeExact();\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    private int offset_store_con() throws Throwable {\n+        return (int) MUTABLE_CONSTANT_OFFSET_STORE_HANDLE.invokeExact();\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    private int distance_con() throws Throwable {\n+        return (int) MUTABLE_CONSTANT_DISTANCE_HANDLE.invokeExact();\n+    }\n+\n+    @Benchmark\n+    public void bench1L1S() throws Throwable {\n+        int offset_load = offset_load_con();\n+        int offset_store = offset_store_con();\n+        int distance = distance_con();\n+        \/\/ Note: the offsets and distance are compile-time constants, which means\n+        \/\/       we can already prove non-aliasing of loads and stores at compile\n+        \/\/       time, which allows vectorization even without any aliasing runtime\n+        \/\/       checks.\n+        for (int i = 0; i < SIZE - \/* slack for offset *\/ 32; i++) {\n+            int v = ms.get(ValueLayout.JAVA_INT_UNALIGNED, 4L * i + 4L * offset_load + 4L * distance);\n+            ms.set(ValueLayout.JAVA_INT_UNALIGNED, 4L * i + 4L * offset_store, v);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorAutoAlignmentVisualization.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"}]}