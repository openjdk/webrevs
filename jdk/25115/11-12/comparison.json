{"files":[{"patch":"@@ -1032,1 +1032,1 @@\n-     * @apiNote Used addExports, Instrumentation::redefineModule, and --add-exports\n+     * @apiNote Used by addExports, Instrumentation::redefineModule, and --add-exports\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -794,1 +794,1 @@\n-     * access if and only if all the following conditions are true, where {@code D} is\n+     * access if and only if all of the following conditions are true, where {@code D} is\n@@ -832,2 +832,2 @@\n-     * if and only if the following conditions are true, where {@code D} is the field's\n-     * {@linkplain #getDeclaringClass() declaring class}:\n+     * if and only if all of the following conditions are true, where {@code D} is the\n+     * field's {@linkplain #getDeclaringClass() declaring class}:\n@@ -838,2 +838,2 @@\n-     * <li>The field is {@code public} and {@code D} is a package that is\n-     *     {@linkplain Module#isExported(String) exported} to all modules.<\/li>\n+     * <li>The field is {@code public} and {@code D} is {@code public} in a package that\n+     *     is {@linkplain Module#isExported(String) exported} to all modules.<\/li>\n@@ -1620,3 +1620,3 @@\n-        String exportOrOpen = Modifier.isPublic(modifiers)\n-                && Modifier.isPublic(clazz.getModifiers()) ? \"exports\" : \"open\";\n-        return String.format(\"%s, %s does not explicitly %s package %s to %s\",\n+        String exportsOrOpens = Modifier.isPublic(modifiers)\n+                && Modifier.isPublic(clazz.getModifiers()) ? \"exports\" : \"opens\";\n+        return String.format(\"%s, %s does not explicitly \\\"%s\\\" package %s to %s\",\n@@ -1625,1 +1625,1 @@\n-                exportOrOpen,\n+                exportsOrOpens,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -469,3 +469,4 @@\n-:   This option allows code in the specified modules to mutate final instance\n-    fields when the field's declaring class is in a package that is open to the\n-    module mutating the field.\n+:   Mutation of final fields is possible with the reflection API of the Java Platform.\n+    _However, it compromises safety and performance in all programs.\n+    This option allows code_ in the specified modules to mutate final fields by reflection.\n+    Attempts by code in any other module to mutate final fields by reflection are deemed _illegal_.\n@@ -473,1 +474,1 @@\n-    *module* can the name of a module on the module path, or `ALL-UNNAMED` to indicate\n+    *module* can be the name of a module on the module path, or `ALL-UNNAMED` to indicate\n@@ -477,1 +478,1 @@\n-:   This option specifies the mode for how illegal final field mutation is handled:\n+:   This option specifies a mode for how _illegal_ final field mutation is handled:\n","filename":"src\/java.base\/share\/man\/java.md","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -476,1 +476,8 @@\n-        assertThrows(IllegalAccessException.class, () -> mutator.set(f, obj, newValue));\n+        var e1 = assertThrows(IllegalAccessException.class, () -> mutator.set(f, obj, newValue));\n+        Module mutatorModule = mutator.getClass().getModule();\n+        if (mutatorModule != testModule) {\n+            assertTrue(e1.getMessage().contains(\"module \" + testModule.getName()\n+                    + \" does not explicitly \\\"exports\\\" package \"\n+                    + f.getDeclaringClass().getPackageName()\n+                    + \" to module \" + mutatorModule.getName()));\n+        }\n@@ -481,1 +488,2 @@\n-        assertThrows(IllegalAccessException.class, () -> mutator.set(f, obj, newValue));\n+        var e2 = assertThrows(IllegalAccessException.class, () -> mutator.set(f, obj, newValue));\n+        assertEquals(e1.getMessage(), e2.getMessage());\n@@ -486,1 +494,2 @@\n-        assertThrows(IllegalAccessException.class, () -> mutator.set(f, obj, newValue));\n+        var e3 = assertThrows(IllegalAccessException.class, () -> mutator.set(f, obj, newValue));\n+        assertEquals(e1.getMessage(), e3.getMessage());\n@@ -518,1 +527,8 @@\n-        assertThrows(IllegalAccessException.class, () -> mutator.set(f, obj, newValue));\n+        var e1 = assertThrows(IllegalAccessException.class, () -> mutator.set(f, obj, newValue));\n+        Module mutatorModule = mutator.getClass().getModule();\n+        if (mutatorModule != testModule) {\n+            assertTrue(e1.getMessage().contains(\"module \" + testModule.getName()\n+                    + \" does not explicitly \\\"opens\\\" package \"\n+                    + f.getDeclaringClass().getPackageName()\n+                    + \" to module \" + mutatorModule.getName()));\n+        }\n@@ -523,1 +539,2 @@\n-        assertThrows(IllegalAccessException.class, () -> mutator.set(f, obj, newValue));\n+        var e2 = assertThrows(IllegalAccessException.class, () -> mutator.set(f, obj, newValue));\n+        assertEquals(e2.getMessage(), e2.getMessage());\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/modules\/test\/test\/TestMain.java","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"}]}