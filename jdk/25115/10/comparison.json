{"files":[{"patch":"@@ -83,0 +83,1 @@\n+  BUILD_JDK_JTREG_LIBRARIES_LDFLAGS_libJNIAttachMutator := -pthread\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -270,11 +270,1 @@\n-      assert(vmClasses::System_klass() != nullptr, \"Check once per vm\");\n-      if (k == vmClasses::System_klass()) {\n-        \/\/ Check offsets for case 2: System.in, System.out, or System.err\n-        if (_offset == java_lang_System::in_offset()  ||\n-            _offset == java_lang_System::out_offset() ||\n-            _offset == java_lang_System::err_offset()) {\n-          _is_constant = false;\n-          return;\n-        }\n-      }\n-      _is_constant = true;\n+      _is_constant = !fd->is_mutable_static_final();\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1870,0 +1870,26 @@\n+static void log_debug_if_final_static_field(JavaThread* current, const char* func_name, InstanceKlass* ik, int offset) {\n+  if (log_is_enabled(Debug, jni)) {\n+    fieldDescriptor fd;\n+    bool found = ik->find_field_from_offset(offset, true, &fd);\n+    assert(found, \"bad field offset\");\n+    assert(fd.is_static(), \"static\/instance mismatch\");\n+    if (fd.is_final() && !fd.is_mutable_static_final()) {\n+      ResourceMark rm(current);\n+      log_debug(jni)(\"%s mutated final static field %s.%s\", func_name, ik->external_name(), fd.name()->as_C_string());\n+    }\n+  }\n+}\n+\n+static void log_debug_if_final_instance_field(JavaThread* current, const char* func_name, InstanceKlass* ik, int offset) {\n+  if (log_is_enabled(Debug, jni)) {\n+    fieldDescriptor fd;\n+    bool found = ik->find_field_from_offset(offset, false, &fd);\n+    assert(found, \"bad field offset\");\n+    assert(!fd.is_static(), \"static\/instance mismatch\");\n+    if (fd.is_final()) {\n+      ResourceMark rm(current);\n+      log_debug(jni)(\"%s mutated final instance field %s.%s\", func_name, ik->external_name(), fd.name()->as_C_string());\n+    }\n+  }\n+}\n+\n@@ -1882,0 +1908,1 @@\n+  log_debug_if_final_instance_field(thread, \"SetObjectField\", InstanceKlass::cast(k), offset);\n@@ -1904,0 +1931,1 @@\n+  log_debug_if_final_instance_field(thread, \"Set<Type>Field\", InstanceKlass::cast(k), offset); \\\n@@ -2075,0 +2103,1 @@\n+  log_debug_if_final_static_field(THREAD, \"SetStaticObjectField\", id->holder(), id->offset());\n@@ -2096,0 +2125,1 @@\n+  log_debug_if_final_static_field(THREAD, \"SetStatic<Type>Field\", id->holder(), id->offset()); \\\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -236,1 +236,1 @@\n-checkStaticFieldID(JavaThread* thr, jfieldID fid, jclass cls, int ftype)\n+checkStaticFieldID(JavaThread* thr, jfieldID fid, jclass cls, int ftype, bool setter)\n@@ -261,0 +261,8 @@\n+\n+  \/* check if setting a final field *\/\n+  if (setter && fd.is_final() && !fd.is_mutable_static_final()) {\n+    ResourceMark rm(thr);\n+    stringStream ss;\n+    ss.print(\"SetStatic<Type>Field called to mutate final static field %s.%s\", k_oop->external_name(), fd.name()->as_C_string());\n+    ReportJNIWarning(thr, ss.as_string());\n+  }\n@@ -264,1 +272,1 @@\n-checkInstanceFieldID(JavaThread* thr, jfieldID fid, jobject obj, int ftype)\n+checkInstanceFieldID(JavaThread* thr, jfieldID fid, jobject obj, int ftype, bool setter)\n@@ -290,2 +298,1 @@\n-  if (!InstanceKlass::cast(k_oop)->find_field_from_offset(offset,\n-                                                              false, &fd))\n+  if (!InstanceKlass::cast(k_oop)->find_field_from_offset(offset, false, &fd))\n@@ -298,0 +305,8 @@\n+\n+  \/* check if setting a final field *\/\n+  if (setter && fd.is_final()) {\n+    ResourceMark rm(thr);\n+    stringStream ss;\n+    ss.print(\"Set<Type>Field called to mutate final instance field %s.%s\", k_oop->external_name(), fd.name()->as_C_string());\n+    ReportJNIWarning(thr, ss.as_string());\n+  }\n@@ -1207,1 +1222,1 @@\n-      checkInstanceFieldID(thr, fieldID, obj, FieldType); \\\n+      checkInstanceFieldID(thr, fieldID, obj, FieldType, false); \\\n@@ -1232,1 +1247,1 @@\n-      checkInstanceFieldID(thr, fieldID, obj, FieldType); \\\n+      checkInstanceFieldID(thr, fieldID, obj, FieldType, true); \\\n@@ -1398,1 +1413,1 @@\n-      checkStaticFieldID(thr, fieldID, clazz, FieldType); \\\n+      checkStaticFieldID(thr, fieldID, clazz, FieldType, false); \\\n@@ -1426,1 +1441,1 @@\n-      checkStaticFieldID(thr, fieldID, clazz, FieldType); \\\n+      checkStaticFieldID(thr, fieldID, clazz, FieldType, true); \\\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":23,"deletions":8,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -320,0 +320,4 @@\n+#define ENABLE_FINAL_FIELD_MUTATION \"enable.final.field.mutation\"\n+#define ENABLE_FINAL_FIELD_MUTATION_LEN 27\n+#define ILLEGAL_FINAL_FIELD_MUTATION \"illegal.final.field.mutation\"\n+#define ILLEGAL_FINAL_FIELD_MUTATION_LEN 28\n@@ -346,1 +350,3 @@\n-        matches_property_suffix(property_suffix, ILLEGAL_NATIVE_ACCESS, ILLEGAL_NATIVE_ACCESS_LEN)) {\n+        matches_property_suffix(property_suffix, ILLEGAL_NATIVE_ACCESS, ILLEGAL_NATIVE_ACCESS_LEN) ||\n+        matches_property_suffix(property_suffix, ENABLE_FINAL_FIELD_MUTATION, ENABLE_FINAL_FIELD_MUTATION_LEN) ||\n+        matches_property_suffix(property_suffix, ILLEGAL_FINAL_FIELD_MUTATION, ILLEGAL_FINAL_FIELD_MUTATION_LEN)) {\n@@ -1812,0 +1818,1 @@\n+static unsigned int enable_final_field_mutation = 0;\n@@ -2276,0 +2283,13 @@\n+    } else if (match_option(option, \"--enable-final-field-mutation=\", &tail)) {\n+      if (!create_numbered_module_property(\"jdk.module.enable.final.field.mutation\", tail, enable_final_field_mutation++)) {\n+        return JNI_ENOMEM;\n+      }\n+    } else if (match_option(option, \"--illegal-final-field-mutation=\", &tail)) {\n+      if (strcmp(tail, \"allow\") == 0 || strcmp(tail, \"warn\") == 0 || strcmp(tail, \"debug\") == 0 || strcmp(tail, \"deny\") == 0) {\n+        PropertyList_unique_add(&_system_properties, \"jdk.module.illegal.final.field.mutation\", tail,\n+                                AddProperty, WriteableProperty, InternalProperty);\n+      } else {\n+        jio_fprintf(defaultStream::error_stream(),\n+                    \"Value specified to --illegal-final-field-mutation not recognized: '%s'\\n\", tail);\n+        return JNI_ERR;\n+      }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -49,0 +49,10 @@\n+bool fieldDescriptor::is_mutable_static_final() const {\n+  InstanceKlass* ik = field_holder();\n+  \/\/ write protected fields (JLS 17.5.4)\n+  if (is_final() && is_static() && ik == vmClasses::System_klass() &&\n+      (offset() == java_lang_System::in_offset() || offset() == java_lang_System::out_offset() || offset() == java_lang_System::err_offset())) {\n+   return true;\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,0 +101,2 @@\n+  bool is_mutable_static_final()  const;\n+\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.lang.reflect.Field;\n@@ -118,0 +119,4 @@\n+    \/\/ true if this module is allowed to mutate final instance fields\n+    @Stable\n+    private boolean enableFinalMutation;\n+\n@@ -265,1 +270,0 @@\n-\n@@ -334,1 +338,1 @@\n-     * Update all unnamed modules to allow access to restricted methods.\n+     * Enable code in all unnamed modules to access restricted methods.\n@@ -336,1 +340,1 @@\n-    static void implAddEnableNativeAccessToAllUnnamed() {\n+    static void addEnableNativeAccessToAllUnnamed() {\n@@ -340,0 +344,40 @@\n+    \/**\n+     * This class exists to avoid using Unsafe during early initialization of Module.\n+     *\/\n+    private static final class EnableFinalMutation {\n+        private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+        private static final long ENABLE_FINAL_MUTATION_OFFSET =\n+                UNSAFE.objectFieldOffset(Module.class, \"enableFinalMutation\");\n+\n+        private static boolean isEnableFinalMutation(Module module) {\n+            return UNSAFE.getBooleanVolatile(module, ENABLE_FINAL_MUTATION_OFFSET);\n+        }\n+\n+        private static boolean tryEnableFinalMutation(Module module) {\n+            return UNSAFE.compareAndSetBoolean(module, ENABLE_FINAL_MUTATION_OFFSET, false, true);\n+        }\n+    }\n+\n+    \/**\n+     * Enable code in all unnamed modules to mutate final instance fields.\n+     *\/\n+    static void addEnableFinalMutationToAllUnnamed() {\n+        EnableFinalMutation.tryEnableFinalMutation(ALL_UNNAMED_MODULE);\n+    }\n+\n+    \/**\n+     * Enable code in this named module to mutate final instance fields.\n+     *\/\n+    boolean tryEnableFinalMutation() {\n+        Module m = isNamed() ? this : ALL_UNNAMED_MODULE;\n+        return EnableFinalMutation.tryEnableFinalMutation(m);\n+    }\n+\n+    \/**\n+     * Return true if code in this module is allowed to mutate final instance fields.\n+     *\/\n+    boolean isFinalMutationEnabled() {\n+        Module m = isNamed() ? this : ALL_UNNAMED_MODULE;\n+        return EnableFinalMutation.isEnableFinalMutation(m);\n+    }\n+\n@@ -720,0 +764,25 @@\n+    \/**\n+     * Returns {@code true} if this module statically opens a package to the given module.\n+     * If the package is opened to the given module via {@code addOpens} then this method\n+     * returns {@code false}.\n+     *\/\n+    boolean isStaticallyOpened(String pn, Module other) {\n+        \/\/ all packages in unnamed modules are open\n+        if (!isNamed())\n+            return true;\n+\n+        \/\/ all packages are open to self\n+        if (other == this && descriptor.packages().contains(pn))\n+            return true;\n+\n+        \/\/ all packages in open and automatic modules are open\n+        if (descriptor.isOpen() || descriptor.isAutomatic())\n+            return descriptor.packages().contains(pn);\n+\n+        \/\/ opened via module descriptor\n+        if (isExplicitlyExportedOrOpened(pn, other, true))\n+            return true;\n+\n+        return false;\n+    }\n+\n@@ -863,1 +932,1 @@\n-            implAddExportsOrOpens(pn, other, \/*open*\/false, \/*syncVM*\/true);\n+            implAddReflectivelyExports(pn, other);\n@@ -870,3 +939,4 @@\n-     * If this module has <em>opened<\/em> a package to at least the caller\n-     * module then update this module to open the package to the given module.\n-     * Opening a package with this method allows all types in the package,\n+     * If this module has <em>opened<\/em> the given package to at least the caller\n+     * module, then update this module to also open the package to the given module.\n+     *\n+     * <p> Opening a package with this method allows all types in the package,\n@@ -874,2 +944,2 @@\n-     * to be reflected on by the given module when using APIs that support\n-     * private access or a way to bypass or suppress default Java language\n+     * to be reflected on by the given module when using APIs that either support\n+     * private access or provide a way to bypass or suppress Java language\n@@ -878,0 +948,5 @@\n+     * <p> Opening a package with this method does not allow the given module to\n+     * {@linkplain Field#set(Object, Object) reflectively set} or {@linkplain\n+     * java.lang.invoke.MethodHandles.Lookup#unreflectSetter(Field) obtain a method\n+     * handle with write access} to a final field declared in a class in the package.\n+     *\n@@ -916,1 +991,1 @@\n-            implAddExportsOrOpens(pn, other, \/*open*\/true, \/*syncVM*\/true);\n+            implAddReflectivelyOpens(pn, other);\n@@ -926,1 +1001,1 @@\n-     * @apiNote This method is for JDK tests only.\n+     * @apiNote Used by Proxy and other dynamic modules.\n@@ -929,1 +1004,1 @@\n-        implAddExportsOrOpens(pn, Module.EVERYONE_MODULE, false, true);\n+        implAddExportsOrOpens(pn, Module.EVERYONE_MODULE, false, true, true);\n@@ -938,1 +1013,1 @@\n-        implAddExportsOrOpens(pn, other, false, true);\n+        implAddExportsOrOpens(pn, other, false, VM.isBooted(), true);\n@@ -944,1 +1019,2 @@\n-     * @apiNote Used by the --add-exports command line option.\n+     * @apiNote Used by the --add-exports command line option and the launcher when\n+     * an executable JAR file has the \"Add-Exports\" attribute in its main manifest.\n@@ -947,1 +1023,1 @@\n-        implAddExportsOrOpens(pn, Module.ALL_UNNAMED_MODULE, false, true);\n+        implAddExportsOrOpens(pn, Module.ALL_UNNAMED_MODULE, false, false, true);\n@@ -957,1 +1033,1 @@\n-        implAddExportsOrOpens(pn.replace('\/', '.'), Module.EVERYONE_MODULE, false, false);\n+        implAddExportsOrOpens(pn.replace('\/', '.'), Module.EVERYONE_MODULE, false, true, false);\n@@ -967,1 +1043,1 @@\n-        implAddExportsOrOpens(pn.replace('\/', '.'), other, false, false);\n+        implAddExportsOrOpens(pn.replace('\/', '.'), other, false, true, false);\n@@ -976,1 +1052,1 @@\n-        implAddExportsOrOpens(pn, Module.EVERYONE_MODULE, true, true);\n+        implAddExportsOrOpens(pn, Module.EVERYONE_MODULE, true, true, true);\n@@ -985,1 +1061,1 @@\n-        implAddExportsOrOpens(pn, other, true, true);\n+        implAddExportsOrOpens(pn, other, true, VM.isBooted(), true);\n@@ -991,1 +1067,2 @@\n-     * @apiNote Used by the --add-opens command line option.\n+     * @apiNote Used by the --add-opens command line option and the launcher when\n+     * an executable JAR file has the \"Add-Opens\" attribute in its main manifest.\n@@ -994,1 +1071,9 @@\n-        implAddExportsOrOpens(pn, Module.ALL_UNNAMED_MODULE, true, true);\n+        implAddExportsOrOpens(pn, Module.ALL_UNNAMED_MODULE, true, false, true);\n+    }\n+\n+    private void implAddReflectivelyExports(String pn, Module other) {\n+        implAddExportsOrOpens(pn, other, false, true, true);\n+    }\n+\n+    private void implAddReflectivelyOpens(String pn, Module other) {\n+        implAddExportsOrOpens(pn, other, true, true, true);\n@@ -999,2 +1084,5 @@\n-     *\n-     * If {@code syncVM} is {@code true} then the VM is notified.\n+     * @param pn package name\n+     * @param other the module to export\/open the package to\n+     * @param open true to open, false to export\n+     * @param reflectively true if exported\/opened reflectively\n+     * @param syncVM true to update the VM\n@@ -1005,0 +1093,1 @@\n+                                       boolean reflectively,\n@@ -1034,1 +1123,1 @@\n-        if (VM.isBooted()) {\n+        if (reflectively) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":113,"deletions":24,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -2099,2 +2099,2 @@\n-            public Module addEnableNativeAccess(Module m) {\n-                return m.implAddEnableNativeAccess();\n+            public void addEnableNativeAccess(Module m) {\n+                m.implAddEnableNativeAccess();\n@@ -2106,1 +2106,1 @@\n-                Module.implAddEnableNativeAccessToAllUnnamed();\n+                Module.addEnableNativeAccessToAllUnnamed();\n@@ -2111,0 +2111,12 @@\n+            public boolean isStaticallyOpened(Module m, String pn, Module other) {\n+                return m.isStaticallyOpened(pn, other);\n+            }\n+            public boolean isFinalMutationEnabled(Module m) {\n+                return m.isFinalMutationEnabled();\n+            }\n+            public boolean tryEnableFinalMutation(Module m) {\n+                return m.tryEnableFinalMutation();\n+            }\n+            public void addEnableFinalMutationToAllUnnamed() {\n+                Module.addEnableFinalMutationToAllUnnamed();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3432,0 +3432,1 @@\n+         * @see <a href=\"{@docRoot}\/java.base\/java\/lang\/reflect\/doc-files\/MutationMethods.html\">Mutation methods<\/a>\n@@ -3438,0 +3439,2 @@\n+            @SuppressWarnings(\"deprecation\")\n+            boolean isAccessible = f.isAccessible();\n@@ -3445,0 +3448,4 @@\n+                \/\/ check if write access to final field allowed\n+                if (!field.isStatic() && isAccessible) {\n+                    SharedSecrets.getJavaLangReflectAccess().checkAllowedToUnreflectFinalSetter(lookupClass, f);\n+                }\n@@ -3449,2 +3456,1 @@\n-            @SuppressWarnings(\"deprecation\")\n-            Lookup lookup = f.isAccessible() ? IMPL_LOOKUP : this;\n+            Lookup lookup = isAccessible ? IMPL_LOOKUP : this;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,12 +163,0 @@\n-     * <p> This method cannot be used to enable {@linkplain Field#set <em>write<\/em>}\n-     * access to a <em>non-modifiable<\/em> final field.  The following fields\n-     * are non-modifiable:\n-     * <ul>\n-     * <li>static final fields declared in any class or interface<\/li>\n-     * <li>final fields declared in a {@linkplain Class#isHidden() hidden class}<\/li>\n-     * <li>final fields declared in a {@linkplain Class#isRecord() record}<\/li>\n-     * <\/ul>\n-     * <p> The {@code accessible} flag when {@code true} suppresses Java language access\n-     * control checks to only enable {@linkplain Field#get <em>read<\/em>} access to\n-     * these non-modifiable final fields.\n-     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessibleObject.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,6 @@\n+import java.lang.annotation.Annotation;\n+import java.net.URL;\n+import java.security.CodeSource;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.Objects;\n@@ -29,0 +35,5 @@\n+import jdk.internal.event.FinalFieldMutationEvent;\n+import jdk.internal.loader.ClassLoaders;\n+import jdk.internal.misc.VM;\n+import jdk.internal.module.ModuleBootstrap;\n+import jdk.internal.module.Modules;\n@@ -38,4 +49,0 @@\n-import java.lang.annotation.Annotation;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.Objects;\n@@ -168,0 +175,21 @@\n+     * {@inheritDoc}\n+     *\n+     * <p>If this reflected object represents a non-final field, and this method is\n+     * used to enable access, then both <em>{@linkplain #get(Object) read}<\/em>\n+     * and <em>{@linkplain #set(Object, Object) write}<\/em> access to the field\n+     * are enabled.\n+     *\n+     * <p>If this reflected object represents a <em>non-modifiable<\/em> final field\n+     * then enabling access only enables read access. Any attempt to {@linkplain\n+     * #set(Object, Object) set} the field value throws an {@code\n+     * IllegalAccessException}. The following fields are non-modifiable:\n+     * <ul>\n+     * <li>static final fields declared in any class or interface<\/li>\n+     * <li>final fields declared in a {@linkplain Class#isRecord() record}<\/li>\n+     * <li>final fields declared in a {@linkplain Class#isHidden() hidden class}<\/li>\n+     * <\/ul>\n+     * <p>If this reflected object represents a non-static final field in a class that\n+     * is not a record class or hidden class, then enabling access will enable read\n+     * access. Whether write access is allowed or not is checked when attempting to\n+     * {@linkplain #set(Object, Object) set} the field value.\n+     *\n@@ -768,5 +796,9 @@\n-     * <li>{@link #setAccessible(boolean) setAccessible(true)} has succeeded for\n-     *     this {@code Field} object;<\/li>\n-     * <li>the field is non-static; and<\/li>\n-     * <li>the field's declaring class is not a {@linkplain Class#isHidden()\n-     *     hidden class}; and<\/li>\n+     * <li>{@link #setAccessible(boolean) setAccessible(true)} has succeeded for this\n+     *     {@code Field} object; and<\/li>\n+     * <li><a href=\"doc-files\/MutationMethods.html\">final field mutation is enabled<\/a>\n+     *     for the caller's module; and<\/li>\n+     * <li>the field's {@linkplain #getDeclaringClass() declaring class} {@code D} is\n+     *     in a package that is {@linkplain Module#isOpen(String, Module) open} to the\n+     *     caller's module. This condition is not met if the module containing\n+     *     {@code D} has been {@linkplain Module#addOpens(String, Module) updated}\n+     *     to open the package to the caller module; and <\/li>\n@@ -774,1 +806,19 @@\n-     *     record class}.<\/li>\n+     *     record class}; and <\/li>\n+     * <li>the field's declaring class is not a {@linkplain Class#isHidden()\n+     *     hidden class}; and <\/li>\n+     * <li>the field is non-static. <\/li>\n+     * <\/ul>\n+     *\n+     * <p>This method may be called by <a href=\"{@docRoot}\/..\/specs\/jni\/index.html\">\n+     * JNI code<\/a> with no caller class on the stack. In that case, and when the\n+     * underlying field is final, this {@code Field} object has <em>write<\/em> access\n+     * if and only if the following conditions are met:\n+     * <ul>\n+     * <li>{@code setAccessible(true)} has succeeded for this {@code Field} object; and<\/li>\n+     * <li>final field mutation is enabled for the unnamed module; and<\/li>\n+     * <li>the field is declared {@code public} and its declaring class is {@code\n+     *     public} in a package that is {@linkplain Module#isExported(String) exported}\n+     *     to all modules; and<\/li>\n+     * <li>the field's declaring class is not a record class; and <\/li>\n+     * <li>the field's declaring class is not a hidden class; and <\/li>\n+     * <li>the field is non-static. <\/li>\n@@ -776,1 +826,2 @@\n-     * If any of the above checks is not met, this method throws an\n+     *\n+     * <p>If any of the above conditions is not met, this method throws an\n@@ -821,0 +872,2 @@\n+     *\n+     * @see <a href=\"doc-files\/MutationMethods.html\">Mutation methods<\/a>\n@@ -831,0 +884,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.set(obj, value);\n@@ -832,1 +891,1 @@\n-            getOverrideFieldAccessor().set(obj, value);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.set(obj, value));\n@@ -870,0 +929,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.setBoolean(obj, z);\n@@ -871,1 +936,1 @@\n-            getOverrideFieldAccessor().setBoolean(obj, z);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.setBoolean(obj, z));\n@@ -909,0 +974,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.setByte(obj, b);\n@@ -910,1 +981,1 @@\n-            getOverrideFieldAccessor().setByte(obj, b);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.setByte(obj, b));\n@@ -948,0 +1019,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.setChar(obj, c);\n@@ -949,1 +1026,1 @@\n-            getOverrideFieldAccessor().setChar(obj, c);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.setChar(obj, c));\n@@ -987,0 +1064,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.setShort(obj, s);\n@@ -988,1 +1071,1 @@\n-            getOverrideFieldAccessor().setShort(obj, s);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.setShort(obj, s));\n@@ -1026,0 +1109,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.setInt(obj, i);\n@@ -1027,1 +1116,1 @@\n-            getOverrideFieldAccessor().setInt(obj, i);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.setInt(obj, i));\n@@ -1065,0 +1154,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.setLong(obj, l);\n@@ -1066,1 +1161,1 @@\n-            getOverrideFieldAccessor().setLong(obj, l);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.setLong(obj, l));\n@@ -1104,0 +1199,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.setFloat(obj, f);\n@@ -1105,1 +1206,1 @@\n-            getOverrideFieldAccessor().setFloat(obj, f);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.setFloat(obj, f));\n@@ -1143,0 +1244,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.setDouble(obj, d);\n@@ -1144,1 +1251,1 @@\n-            getOverrideFieldAccessor().setDouble(obj, d);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.setDouble(obj, d));\n@@ -1307,1 +1414,205 @@\n-}\n+    }\n+\n+    \/**\n+     * A function that sets a field to a value.\n+     *\/\n+    @FunctionalInterface\n+    private interface FieldSetter {\n+        void setFieldValue() throws IllegalAccessException;\n+    }\n+\n+    \/**\n+     * Attempts to set a final field.\n+     *\/\n+    private void setFinal(Class<?> caller, Object obj, FieldSetter setter) throws IllegalAccessException {\n+        if (obj != null && isFinalInstanceInNormalClass()) {\n+            preSetFinal(caller, false);\n+            setter.setFieldValue();\n+            postSetFinal(caller, false);\n+        } else {\n+            \/\/ throws IllegalAccessException if static, or field in record or hidden class\n+            setter.setFieldValue();\n+        }\n+    }\n+\n+    \/**\n+     * Return true if this field is a final instance field in a normal class (not a\n+     * record class or hidden class),\n+     *\/\n+    private boolean isFinalInstanceInNormalClass() {\n+        return Modifier.isFinal(modifiers)\n+                && !Modifier.isStatic(modifiers)\n+                && !clazz.isRecord()\n+                && !clazz.isHidden();\n+    }\n+\n+    \/**\n+     * Check that the caller is allowed to unreflect for mutation a final instance field\n+     * in a normal class.\n+     * @throws IllegalAccessException if not allowed\n+     *\/\n+    void checkAllowedToUnreflectFinalSetter(Class<?> caller) throws IllegalAccessException {\n+        Objects.requireNonNull(caller);\n+        preSetFinal(caller, true);\n+        postSetFinal(caller, true);\n+    }\n+\n+    \/**\n+     * Invoke before attempting to mutate, or unreflect for mutation, a final instance\n+     * field in a normal class.\n+     * @throws IllegalAccessException if not allowed\n+     *\/\n+    private void preSetFinal(Class<?> caller, boolean unreflect) throws IllegalAccessException {\n+        assert isFinalInstanceInNormalClass();\n+\n+        \/\/ check if package is open to caller module\n+        if (caller != null) {\n+            if (!Modules.isStaticallyOpened(clazz.getModule(),\n+                                            clazz.getPackageName(),\n+                                            caller.getModule())) {\n+                throw new IllegalAccessException(notOpenToCallerMessage(caller, unreflect));\n+            }\n+        } else {\n+            \/\/ no java caller, only allowed if field is public in exported package\n+            if (!Reflection.verifyPublicMemberAccess(clazz, modifiers)) {\n+                throw new IllegalAccessException(notAccessibleToNoCallerMessage(unreflect));\n+            }\n+        }\n+\n+        \/\/ check if field mutation is enabled for caller module or illegal final field\n+        \/\/ mutation is allowed\n+        var mode = ModuleBootstrap.illegalFinalFieldMutation();\n+        if (mode == ModuleBootstrap.IllegalFinalFieldMutation.DENY\n+                && !Modules.isFinalMutationEnabled(moduleToCheck(caller))) {\n+            throw new IllegalAccessException(callerNotAllowedToMutateMessage(caller, unreflect));\n+        }\n+    }\n+\n+    \/**\n+     * Invoke after mutating a final instance field, or when unreflecting a final instance\n+     * field for mutation, to print a warning and record a JFR event.\n+     *\/\n+    private void postSetFinal(Class<?> caller, boolean unreflect) {\n+        assert isFinalInstanceInNormalClass();\n+\n+        var mode = ModuleBootstrap.illegalFinalFieldMutation();\n+        if (mode == ModuleBootstrap.IllegalFinalFieldMutation.WARN) {\n+            \/\/ first mutation prints warning\n+            Module moduleToCheck = moduleToCheck(caller);\n+            if (Modules.tryEnableFinalMutation(moduleToCheck)) {\n+                String warningMsg = finalFieldMutationWarning(caller, unreflect);\n+                String targetModule = (caller != null && moduleToCheck.isNamed())\n+                        ? moduleToCheck.getName()\n+                        : \"ALL-UNNAMED\";\n+                VM.initialErr().printf(\"\"\"\n+                        WARNING: %s\n+                        WARNING: Use --enable-final-field-mutation=%s to avoid a warning\n+                        WARNING: Mutating final fields will be blocked in a future release unless final field mutation is enabled\n+                        \"\"\", warningMsg, targetModule);\n+            }\n+        } else if (mode == ModuleBootstrap.IllegalFinalFieldMutation.DEBUG) {\n+            \/\/ print warning and stack trace\n+            var sb = new StringBuilder(finalFieldMutationWarning(caller, unreflect));\n+            StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE)\n+                    .forEach(sf -> {\n+                        sb.append(System.lineSeparator()).append(\"\\tat \" + sf);\n+                    });\n+            VM.initialErr().println(sb);\n+        }\n+\n+        \/\/ record JFR event\n+        FinalFieldMutationEvent.offer(getDeclaringClass(), getName());\n+    }\n+\n+    \/**\n+     * Returns the Module to use for access checks with the given caller.\n+     *\/\n+    private Module moduleToCheck(Class<?> caller) {\n+        if (caller != null) {\n+            return caller.getModule();\n+        } else {\n+            \/\/ no java caller, only allowed if field is public in exported package\n+            return ClassLoaders.appClassLoader().getUnnamedModule();\n+        }\n+    }\n+\n+    \/**\n+     * Returns the warning message to print when this final field is mutated by\n+     * the given possibly-null caller.\n+     *\/\n+    private String finalFieldMutationWarning(Class<?> caller, boolean unreflect) {\n+        assert Modifier.isFinal(modifiers);\n+        String source;\n+        if (caller != null) {\n+            source = caller + \" in \" + caller.getModule();\n+            CodeSource cs = caller.getProtectionDomain().getCodeSource();\n+            if (cs != null) {\n+                URL url = cs.getLocation();\n+                if (url != null) {\n+                    source += \" (\" + url + \")\";\n+                }\n+            }\n+        } else {\n+            source = \"JNI attached thread with no caller frame\";\n+        }\n+        return String.format(\"Final field %s in %s has been %s by %s\",\n+                name,\n+                clazz,\n+                (unreflect) ? \"unreflected for mutation\" : \"mutated reflectively\",\n+                source);\n+    }\n+\n+    \/**\n+     * Returns the message for an IllegalAccessException when a final field cannot be\n+     * mutated because the declaring class is in a package that is not open to caller.\n+     *\/\n+    private String notOpenToCallerMessage(Class<?> caller, boolean unreflect) {\n+        return String.format(\"%s, %s does not explicitly open package %s to %s\",\n+                cannotSetFieldMessage(caller, unreflect),\n+                clazz.getModule(),\n+                clazz.getPackageName(),\n+                caller.getModule());\n+    }\n+\n+    \/**\n+     * Returns the exception message for the IllegalAccessException when this\n+     * final field cannot be mutated because the caller module is not allowed\n+     * to mutate final fields.\n+     *\/\n+    private String callerNotAllowedToMutateMessage(Class<?> caller, boolean unreflect) {\n+        if (caller != null) {\n+            return String.format(\"%s, %s is not allowed to mutate final fields\",\n+                    cannotSetFieldMessage(caller, unreflect),\n+                    caller.getModule());\n+        } else {\n+            return notAccessibleToNoCallerMessage(unreflect);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the message for an IllegalAccessException when a field is not\n+     * accessible to a JNI attached thread.\n+     *\/\n+    private String notAccessibleToNoCallerMessage(boolean unreflect) {\n+        return cannotSetFieldMessage(\"JNI attached thread with no caller frame cannot\", unreflect);\n+    }\n+\n+    \/**\n+     * Returns a message to indicate that the caller cannot set\/unreflect this final field.\n+     *\/\n+    private String cannotSetFieldMessage(Class<?> caller, boolean unreflect) {\n+        return cannotSetFieldMessage(caller + \" (in \" + caller.getModule() + \") cannot\", unreflect);\n+    }\n+\n+    \/**\n+     * Returns a message to indicate that a field cannot be set\/unreflected.\n+     *\/\n+    private String cannotSetFieldMessage(String prefix, boolean unreflect) {\n+        if (unreflect) {\n+            return prefix + \" unreflect final field \" + clazz.getName() + \".\" + name\n+                    + \" (in \" + clazz.getModule() + \") for mutation\";\n+        } else {\n+            return prefix + \" set final field \" + clazz.getName() + \".\" + name\n+                    + \" (in \" + clazz.getModule() + \")\";\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":332,"deletions":21,"binary":false,"changes":353,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,0 +81,5 @@\n+\n+    @Override\n+    public void checkAllowedToUnreflectFinalSetter(Class<?> caller, Field f) throws IllegalAccessException {\n+        f.checkAllowedToUnreflectFinalSetter(caller);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ReflectAccess.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+<!doctype html>\n+<!--\n+ Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+ This code is free software; you can redistribute it and\/or modify it\n+ under the terms of the GNU General Public License version 2 only, as\n+ published by the Free Software Foundation.  Oracle designates this\n+ particular file as subject to the \"Classpath\" exception as provided\n+ by Oracle in the LICENSE file that accompanied this code.\n+\n+ This code is distributed in the hope that it will be useful, but WITHOUT\n+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ version 2 for more details (a copy is included in the LICENSE file that\n+ accompanied this code).\n+\n+ You should have received a copy of the GNU General Public License version\n+ 2 along with this work; if not, write to the Free Software Foundation,\n+ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ or visit www.oracle.com if you need additional information or have any\n+ questions.\n+-->\n+<html lang=\"en\">\n+<head>\n+    <title>Mutation methods<\/title>\n+<\/head>\n+<body>\n+\n+<h1 id=\"mutation\">Mutation methods<\/h1>\n+\n+<p>A number of methods in Java SE API provide <em>write<\/em> access to non-static\n+final fields. This means that Java code can alter the value of a final field\n+after the field has been initialized in a constructor.\n+\n+The methods that provide write access, known as <em>mutation methods<\/em> are:\n+<ul>\n+    <li>{@link java.lang.reflect.Field#set(Object, Object)}<\/li>\n+    <li>{@link java.lang.reflect.Field#setBoolean(Object, boolean)}<\/li>\n+    <li>{@link java.lang.reflect.Field#setByte(Object, byte)}<\/li>\n+    <li>{@link java.lang.reflect.Field#setChar(Object, char)}<\/li>\n+    <li>{@link java.lang.reflect.Field#setInt(Object, int)}<\/li>\n+    <li>{@link java.lang.reflect.Field#setLong(Object, long)}<\/li>\n+    <li>{@link java.lang.reflect.Field#setFloat(Object, float)}<\/li>\n+    <li>{@link java.lang.reflect.Field#setDouble(Object, double)}<\/li>\n+    <li>{@link java.lang.invoke.MethodHandles.Lookup#unreflectSetter(java.lang.reflect.Field)}<\/li>\n+<\/ul>\n+\n+<p> The use of mutation methods to alter the values of final fields is\n+strongly inadvisable because it undermines the correctness of programs written in\n+expectation of final fields being immutable.\n+\n+<p> In the reference implementation, a module can be granted the capability to mutate\n+final instance fields of classes in packages that are open to the module using\n+the command line option <code>--enable-final-field-mutation=M1,M2, ... Mn}<\/code> where\n+<code>M1<\/code>, <code>M2<\/code>, <code>...Mn<\/code> are module names (for the unnamed\n+module, the special value <code>ALL-UNNAMED<\/code> can be used). Mutation of final\n+instance fields of classes from modules not listed by that option is deemed\n+<em>illegal<\/em>.\n+The command line option <code>--illegal-final-field-mutation<\/code> controls how illegal\n+final mutation is handled. Valid values for this command line option are \"warn\", \"allow\",\n+\"debug, and \"deny\".  If this option is not specified then the default is \"warn\" so that\n+illegal final field mutation will result in a warning at runtime.\n+\n+<\/body>\n+<\/html>\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/doc-files\/MutationMethods.html","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -208,1 +208,1 @@\n-     * This method is the same as m1.addReads(m2) but without a permission check.\n+     * This method is the same as m1.addReads(m2) but without a caller check.\n@@ -262,1 +262,1 @@\n-    Module addEnableNativeAccess(Module m);\n+    void addEnableNativeAccess(Module m);\n@@ -265,2 +265,2 @@\n-     * Updates module named {@code name} in layer {@code layer} to allow access to restricted methods.\n-     * Returns true iff the given module exists in the given layer.\n+     * Updates module named {@code name} in layer {@code layer} to allow access to\n+     * restricted methods. Returns true iff the given module exists in the given layer.\n@@ -276,1 +276,2 @@\n-     * Ensure that the given module has native access. If not, warn or throw exception depending on the configuration.\n+     * Ensure that the given module has native access. If not, warn or throw exception\n+     * depending on the configuration.\n@@ -285,0 +286,20 @@\n+    \/**\n+     * Enable code in all unnamed modules to mutate final instance fields.\n+     *\/\n+    void addEnableFinalMutationToAllUnnamed();\n+\n+    \/**\n+     * Enable code in a given module to mutate final instance fields.\n+     *\/\n+    boolean tryEnableFinalMutation(Module m);\n+\n+    \/**\n+     * Return true if code in a given module is allowed to mutate final instance fields.\n+     *\/\n+    boolean isFinalMutationEnabled(Module m);\n+\n+    \/**\n+     * Return true if a given module has statically opened the given package to a given other module.\n+     *\/\n+    boolean isStaticallyOpened(Module module, String pn, Module other);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,0 +70,6 @@\n+\n+    \/**\n+     * Check that the caller is allowed to unreflect for mutation a final instance field\n+     * in a class that is not a record or hidden class.\n+     *\/\n+    void checkAllowedToUnreflectFinalSetter(Class<?> caller, Field f) throws IllegalAccessException;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangReflectAccess.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.event;\n+\n+public class FinalFieldMutationEvent extends Event {\n+    public Class<?> declaringClass;\n+    public String fieldName;\n+\n+    \/**\n+     * Commit a FinalFieldMutationEvent if enabled.\n+     *\/\n+    public static void offer(Class<?> declaringClass, String fieldName) {\n+        if (enabled()) {\n+            var event = new FinalFieldMutationEvent();\n+            event.declaringClass = declaringClass;\n+            event.fieldName = fieldName;\n+            event.commit();\n+        }\n+    }\n+\n+    public static boolean enabled() {\n+        \/\/ Generated by JFR\n+        return false;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/FinalFieldMutationEvent.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -455,1 +455,1 @@\n-        \/\/ add enable native access\n+        \/\/ enable native access to modules specified to --enable-native-access\n@@ -458,0 +458,3 @@\n+        \/\/ allow final mutation by modules specified to --enable-final-field-mutation\n+        addEnableFinalFieldMutation(bootLayer);\n+\n@@ -724,1 +727,0 @@\n-\n@@ -732,1 +734,0 @@\n-\n@@ -739,1 +740,0 @@\n-\n@@ -810,0 +810,1 @@\n+    private static final IllegalFinalFieldMutation ILLEGAL_FINAL_FIELD_MUTATION;\n@@ -817,2 +818,5 @@\n-    public static IllegalNativeAccess illegalNativeAccess() {\n-        return ILLEGAL_NATIVE_ACCESS;\n+    public enum IllegalFinalFieldMutation {\n+        ALLOW,\n+        WARN,\n+        DEBUG,\n+        DENY\n@@ -822,1 +826,1 @@\n-        ILLEGAL_NATIVE_ACCESS = addIllegalNativeAccess();\n+        ILLEGAL_NATIVE_ACCESS = decodeIllegalNativeAccess();\n@@ -825,0 +829,9 @@\n+        ILLEGAL_FINAL_FIELD_MUTATION = decodeIllegalFinalFieldMutation();\n+    }\n+\n+    public static IllegalNativeAccess illegalNativeAccess() {\n+        return ILLEGAL_NATIVE_ACCESS;\n+    }\n+\n+    public static IllegalFinalFieldMutation illegalFinalFieldMutation() {\n+        return ILLEGAL_FINAL_FIELD_MUTATION;\n@@ -884,1 +897,1 @@\n-    private static IllegalNativeAccess addIllegalNativeAccess() {\n+    private static IllegalNativeAccess decodeIllegalNativeAccess() {\n@@ -902,0 +915,65 @@\n+    \/**\n+     * Process the --illegal-final-field-mutation option.\n+     *\/\n+    private static IllegalFinalFieldMutation decodeIllegalFinalFieldMutation() {\n+        String value = getAndRemoveProperty(\"jdk.module.illegal.final.field.mutation\");\n+        if (value == null) {\n+            return IllegalFinalFieldMutation.WARN; \/\/ default\n+        } else if (value.equals(\"allow\")) {\n+            return IllegalFinalFieldMutation.ALLOW;\n+        } else if (value.equals(\"warn\")) {\n+            return IllegalFinalFieldMutation.WARN;\n+        } else if (value.equals(\"debug\")) {\n+            return IllegalFinalFieldMutation.DEBUG;\n+        } else if (value.equals(\"deny\")) {\n+            return IllegalFinalFieldMutation.DENY;\n+        } else {\n+            fail(\"Value specified to --illegal-final-field-mutation not recognized:\"\n+                    + \" '\" + value + \"'\");\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * Process the modules specified to --enable-final-field-mutation and grant the\n+     * capability to mutate finals to specified named modules or all unnamed modules.\n+     *\/\n+    private static void addEnableFinalFieldMutation(ModuleLayer bootLayer) {\n+        for (String name : decodeEnableFinalFieldMutation()) {\n+            if (name.equals(\"ALL-UNNAMED\")) {\n+                JLA.addEnableFinalMutationToAllUnnamed();\n+            } else {\n+                Module m = bootLayer.findModule(name).orElse(null);\n+                if (m != null) {\n+                    JLA.tryEnableFinalMutation(m);\n+                } else {\n+                    warnUnknownModule(\"--enable-final-field-mutation\", name);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns the set of module names specified by --enable-final-field-mutation options.\n+     *\/\n+    private static Set<String> decodeEnableFinalFieldMutation() {\n+        String prefix = \"jdk.module.enable.final.field.mutation.\";\n+        int index = 0;\n+        \/\/ the system property is removed after decoding\n+        String value = getAndRemoveProperty(prefix + index);\n+        Set<String> modules = new HashSet<>();\n+        if (value == null) {\n+            return modules;\n+        }\n+        while (value != null) {\n+            for (String s : value.split(\",\")) {\n+                if (!s.isEmpty()) {\n+                    modules.add(s);\n+                }\n+            }\n+            index++;\n+            value = getAndRemoveProperty(prefix + index);\n+        }\n+        return modules;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleBootstrap.java","additions":86,"deletions":8,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,0 +142,30 @@\n+    \/**\n+     * Enable code in all unnamed modules to mutate final instance fields.\n+     *\/\n+    public static void addEnableFinalMutationToAllUnnamed() {\n+        JLA.addEnableFinalMutationToAllUnnamed();\n+    }\n+\n+    \/**\n+     * Enable code in a given module to mutate final instance fields.\n+     *\/\n+    public static boolean tryEnableFinalMutation(Module m) {\n+        return JLA.tryEnableFinalMutation(m);\n+    }\n+\n+    \/**\n+     * Return true if code in a given module is allowed to mutate final instance fields.\n+     *\/\n+    public static boolean isFinalMutationEnabled(Module m) {\n+        return JLA.isFinalMutationEnabled(m);\n+    }\n+\n+    \/**\n+     * Return true if a given module has statically opened the given package to a given\n+     * other module. \"statically open\" means the module declaration, --add-opens on the\n+     * command line, or Add-Opens in the main manifest of an executable JAR.\n+     *\/\n+    public static boolean isStaticallyOpened(Module m, String pn, Module other) {\n+        return JLA.isStaticallyOpened(m, pn, other);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/Modules.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+    private static final String ENABLE_FINAL_FIELD_MUTATION = \"Enable-Final-Field-Mutation\";\n@@ -650,0 +651,2 @@\n+\n+        \/\/ Enable-Native-Access\n@@ -658,0 +661,10 @@\n+        \/\/ Enable-Final-Field-Mutation\n+        String enableFinalFieldMutation = mainAttrs.getValue(ENABLE_FINAL_FIELD_MUTATION);\n+        if (enableFinalFieldMutation != null) {\n+            if (!enableFinalFieldMutation.equals(\"ALL-UNNAMED\")) {\n+                abort(null, \"java.launcher.jar.error.illegal.effm.value\",\n+                        enableFinalFieldMutation);\n+            }\n+            Modules.addEnableFinalMutationToAllUnnamed();\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -73,0 +73,8 @@\n+\\    --enable-final-field-mutation <module name>[,<module name>...]\\n\\\n+\\                  allow code in the specified modules to mutate final instance fields.\\n\\\n+\\                  <module name> can also be ALL-UNNAMED to indicate code on the class path.\\n\\\n+\\    --illegal-final-field-mutation=<value>\\n\\\n+\\                  allow or deny final field mutation by code in modules for which final\\n\\\n+\\                  field mutation is not explicitly enabled.\\n\\\n+\\                  <value> is one of \"deny\", \"warn\", \"debug\", or \"allow\". The default value is \"warn\".\\n\\\n+\\                  This option will be removed in a future release.\\n\\\n@@ -294,0 +302,2 @@\n+java.launcher.jar.error.illegal.effm.value=\\\n+    Error: illegal value \\\"{0}\\\" for Enable-Final-Field-Mutation manifest attribute. Only 'ALL-UNNAMED' is allowed\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher.properties","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -468,0 +468,32 @@\n+`--enable-final-field-mutation` *module*\\[,*module*...\\]\n+:   This option allows code in the specified modules to mutate final instance\n+    fields when the field's declaring class is in a package that is open to the\n+    module mutating the field.\n+\n+    *module* can the name of a module on the module path, or `ALL-UNNAMED` to indicate\n+    code on the class path.\n+\n+-`--illegal-final-field-mutation=`*parameter*\n+:   This option specifies the mode for how illegal final field mutation is handled:\n+\n+    > **Note:** This option will be removed in a future release.\n+\n+    -   `allow`: This mode allows illegal final field mutation in all modules,\n+        without any warings.\n+\n+    -   `warn`: This mode is identical to `allow` except that a warning message is\n+        issued for the first illegal final field mutation performaed in a module.\n+        This mode is the default for the current JDK but will change in a future\n+        release.\n+\n+    -   `debug`: This mode is identical to `allow` except that a warning message\n+        and stack trace are printed for every illegal final field mutation.\n+\n+    -   `deny`: This mode disables final field mutation. That is, any illegal final\n+        field mutation access causes an `IllegalAccessException`. This mode will\n+        become the default in a future release.\n+\n+    To verify that your application is ready for a future version of the JDK,\n+    run it with `--illegal-final-field-mutation=deny` along with any necessary\n+    `--enable-final-field-mutation` options.\n+\n@@ -704,1 +736,2 @@\n-      or `Get\/ReleaseStringCritical`\n+      or `Get\/ReleaseStringCritical`.\n+    - A JNI call was made to mutate a final field.\n","filename":"src\/java.base\/share\/man\/java.md","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.events;\n+\n+import jdk.jfr.Category;\n+import jdk.jfr.Description;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+import jdk.jfr.internal.Type;\n+import jdk.jfr.internal.MirrorEvent;\n+import jdk.jfr.internal.RemoveFields;\n+\n+@Category(\"Java Application\")\n+@Label(\"Final Field Mutation\")\n+@Name(Type.EVENT_NAME_PREFIX + \"FinalFieldMutation\")\n+@RemoveFields(\"duration\")\n+@StackFilter({\n+        \"java.lang.reflect.Field\",\n+        \"java.lang.reflect.ReflectAccess\",\n+        \"java.lang.invoke.MethodHandles$Lookup\"\n+})\n+public final class FinalFieldMutationEvent extends MirrorEvent {\n+\n+    @Label(\"Declaring Class\")\n+    @Description(\"Declaring class with final field\")\n+    public Class<?> declaringClass;\n+\n+    @Label(\"Field Name\")\n+    @Description(\"Field name of final field\")\n+    public String fieldName;\n+\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/FinalFieldMutationEvent.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -79,0 +79,1 @@\n+        jdk.internal.event.FinalFieldMutationEvent.class,\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JDKEvents.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import jdk.jfr.events.FinalFieldMutationEvent;\n@@ -80,0 +81,1 @@\n+        register(\"jdk.internal.event.FinalFieldMutationEvent\", FinalFieldMutationEvent.class);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MirrorEvents.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -128,0 +128,1 @@\n+                case Type.EVENT_NAME_PREFIX + \"FinalFieldMutation\" -> 4;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformEventType.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -120,0 +120,5 @@\n+    <event name=\"jdk.FinalFieldMutation\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -120,0 +120,5 @@\n+    <event name=\"jdk.FinalFieldMutation\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,356 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.util.Objects;\n+\n+\/**\n+ * Invoked by MutateFinalsTest, either directly or in a child VM, with the name of the\n+ * test method in this class to execute.\n+ *\/\n+\n+public class MutateFinals {\n+\n+    \/**\n+     *  Usage: java MutateFinals <method-name>\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+        invoke(args[0]);\n+    }\n+\n+    \/**\n+     * Invokes the given method.\n+     *\/\n+    static void invoke(String methodName) throws Exception {\n+        Method m = MutateFinals.class.getDeclaredMethod(methodName);\n+        m.invoke(null);\n+    }\n+\n+    \/**\n+     * JNI SetObjectField.\n+     *\/\n+    private static void testJniSetObjectField() throws Exception {\n+        class C {\n+            final Object value;\n+            C(Object value) {\n+                this.value = value;\n+            }\n+        }\n+        Object oldValue = new Object();\n+        Object newValue = new Object();\n+        var obj = new C(oldValue);\n+        jniSetObjectField(obj, newValue);\n+        assertTrue(obj.value == newValue);\n+    }\n+\n+    \/**\n+     * JNI SetBooleanField.\n+     *\/\n+    private static void testJniSetBooleanField() throws Exception {\n+        class C {\n+            final boolean value;\n+            C(boolean value) {\n+                this.value = value;\n+            }\n+        }\n+        var obj = new C(false);\n+        jniSetBooleanField(obj, true);\n+        assertTrue(obj.value);\n+    }\n+\n+    \/**\n+     * JNI SetByteField.\n+     *\/\n+    private static void testJniSetByteField() throws Exception {\n+        class C {\n+            final byte value;\n+            C(byte value) {\n+                this.value = value;\n+            }\n+        }\n+        byte oldValue = (byte) 1;\n+        byte newValue = (byte) 2;\n+        var obj = new C(oldValue);\n+        jniSetByteField(obj, newValue);\n+        assertEquals(newValue, obj.value);\n+    }\n+\n+    \/**\n+     * JNI SetCharField.\n+     *\/\n+    private static void testJniSetCharField() throws Exception {\n+        class C {\n+            final char value;\n+            C(char value) {\n+                this.value = value;\n+            }\n+        }\n+        char oldValue = 'A';\n+        char newValue = 'B';\n+        var obj = new C(oldValue);\n+        jniSetCharField(obj, newValue);\n+        assertEquals(newValue, obj.value);\n+    }\n+\n+    \/**\n+     * JNI SetShortField.\n+     *\/\n+    private static void testJniSetShortField() throws Exception {\n+        class C {\n+            final short value;\n+            C(short value) {\n+                this.value = value;\n+            }\n+        }\n+        short oldValue = (short) 1;\n+        short newValue = (short) 2;\n+        var obj = new C(oldValue);\n+        jniSetShortField(obj, newValue);\n+        assertEquals(newValue, obj.value);\n+    }\n+\n+    \/**\n+     * JNI SetIntField.\n+     *\/\n+    private static void testJniSetIntField() throws Exception {\n+        class C {\n+            final int value;\n+            C(int value) {\n+                this.value = value;\n+            }\n+        }\n+        int oldValue = 1;\n+        int newValue = 2;\n+        var obj = new C(oldValue);\n+        jniSetIntField(obj, newValue);\n+        assertEquals(newValue, obj.value);\n+    }\n+\n+    \/**\n+     * JNI SetLongField.\n+     *\/\n+    private static void testJniSetLongField() throws Exception {\n+        class C {\n+            final long value;\n+            C(long value) {\n+                this.value = value;\n+            }\n+        }\n+        long oldValue = 1L;\n+        long newValue = 2L;\n+        var obj = new C(oldValue);\n+        jniSetLongField(obj, newValue);\n+        assertEquals(newValue, obj.value);\n+    }\n+\n+    \/**\n+     * JNI SetFloatField.\n+     *\/\n+    private static void testJniSetFloatField() throws Exception {\n+        class C {\n+            final float value;\n+            C(float value) {\n+                this.value = value;\n+            }\n+        }\n+        float oldValue = 1.0f;\n+        float newValue = 2.0f;\n+        var obj = new C(oldValue);\n+        jniSetFloatField(obj, newValue);\n+        assertEquals(newValue, obj.value);\n+    }\n+\n+    \/**\n+     * JNI SetDoubleField.\n+     *\/\n+    private static void testJniSetDoubleField() throws Exception {\n+        class C {\n+            final double value;\n+            C(double value) {\n+                this.value = value;\n+            }\n+        }\n+        double oldValue = 1.0d;\n+        double newValue = 2.0d;\n+        var obj = new C(oldValue);\n+        jniSetDoubleField(obj, newValue);\n+        assertEquals(newValue, obj.value);\n+    }\n+\n+    \/**\n+     * JNI SetStaticObjectField.\n+     *\/\n+    private static void testJniSetStaticObjectField() throws Exception {\n+        class C {\n+            static final Object value = new Object();\n+        }\n+        Object newValue = new Object();\n+        jniSetStaticObjectField(C.class, newValue);\n+        assertTrue(C.value == newValue);\n+    }\n+\n+    \/**\n+     * JNI SetStaticBooleanField.\n+     *\/\n+    private static void testJniSetStaticBooleanField() throws Exception {\n+        class C {\n+            static final boolean value = false;\n+        }\n+        jniSetStaticBooleanField(C.class, true);\n+        \/\/ use reflection as field treated as constant by compiler\n+        boolean value = (boolean) C.class.getDeclaredField(\"value\").get(null);\n+        assertTrue(value);\n+    }\n+\n+    \/**\n+     * JNI SetStaticByteField.\n+     *\/\n+    private static void testJniSetStaticByteField() throws Exception {\n+        class C {\n+            static final byte value = (byte) 1;\n+        }\n+        byte newValue = (byte) 2;\n+        jniSetStaticByteField(C.class, newValue);\n+        \/\/ use reflection as field treated as constant by compiler\n+        byte value = (byte) C.class.getDeclaredField(\"value\").get(null);\n+        assertEquals(newValue, value);\n+    }\n+\n+    \/**\n+     * JNI SetStaticCharField.\n+     *\/\n+    private static void testJniSetStaticCharField() throws Exception {\n+        class C {\n+            static final char value = 'A';\n+        }\n+        char newValue = 'B';\n+        jniSetStaticCharField(C.class, newValue);\n+        \/\/ use reflection as field treated as constant by compiler\n+        char value = (char) C.class.getDeclaredField(\"value\").get(null);\n+        assertEquals(newValue, value);\n+    }\n+\n+    \/**\n+     * JNI SetStaticShortField.\n+     *\/\n+    private static void testJniSetStaticShortField() throws Exception {\n+        class C {\n+            static final short value = (short) 1;\n+        }\n+        short newValue = (short) 2;\n+        jniSetStaticShortField(C.class, newValue);\n+        \/\/ use reflection as field treated as constant by compiler\n+        short value = (short) C.class.getDeclaredField(\"value\").get(null);\n+        assertEquals(newValue, value);\n+    }\n+\n+    \/**\n+     * JNI SetStaticIntField.\n+     *\/\n+    private static void testJniSetStaticIntField() throws Exception {\n+        class C {\n+            static final int value = 1;\n+        }\n+        int newValue = 2;\n+        jniSetStaticIntField(C.class, newValue);\n+        \/\/ use reflection as field treated as constant by compiler\n+        int value = (int) C.class.getDeclaredField(\"value\").get(null);\n+        assertEquals(newValue, value);\n+    }\n+\n+    \/**\n+     * JNI SetStaticLongField.\n+     *\/\n+    private static void testJniSetStaticLongField() throws Exception {\n+        class C {\n+            static final long value = 1L;\n+        }\n+        long newValue = 2L;\n+        jniSetStaticLongField(C.class, newValue);\n+        \/\/ use reflection as field treated as constant by compiler\n+        long value = (long) C.class.getDeclaredField(\"value\").get(null);\n+        assertEquals(newValue, value);\n+    }\n+\n+    \/**\n+     * JNI SetStaticFloatField.\n+     *\/\n+    private static void testJniSetStaticFloatField() throws Exception {\n+        class C {\n+            static final float value = 1.0f;\n+        }\n+        float newValue = 2.0f;\n+        jniSetStaticFloatField(C.class, newValue);\n+        \/\/ use reflection as field treated as constant by compiler\n+        float value = (float) C.class.getDeclaredField(\"value\").get(null);\n+        assertEquals(newValue, value);\n+    }\n+\n+    \/**\n+     * JNI SetStaticDoubleField.\n+     *\/\n+    private static void testJniSetStaticDoubleField() throws Exception {\n+        class C {\n+            static final double value = 1.0d;\n+        }\n+        double newValue = 2.0f;\n+        jniSetStaticDoubleField(C.class, newValue);\n+        \/\/ use reflection as field treated as constant by compiler\n+        double value = (double) C.class.getDeclaredField(\"value\").get(null);\n+        assertEquals(newValue, value);\n+    }\n+\n+    private static native void jniSetObjectField(Object obj, Object value);\n+    private static native void jniSetBooleanField(Object obj, boolean value);\n+    private static native void jniSetByteField(Object obj, byte value);\n+    private static native void jniSetCharField(Object obj, char value);\n+    private static native void jniSetShortField(Object obj, short value);\n+    private static native void jniSetIntField(Object obj, int value);\n+    private static native void jniSetLongField(Object obj, long value);\n+    private static native void jniSetFloatField(Object obj, float value);\n+    private static native void jniSetDoubleField(Object obj, double value);\n+\n+    private static native void jniSetStaticObjectField(Class<?> clazz, Object value);\n+    private static native void jniSetStaticBooleanField(Class<?> clazz, boolean value);\n+    private static native void jniSetStaticByteField(Class<?> clazz, byte value);\n+    private static native void jniSetStaticCharField(Class<?> clazz, char value);\n+    private static native void jniSetStaticShortField(Class<?> clazz, short value);\n+    private static native void jniSetStaticIntField(Class<?> clazz, int value);\n+    private static native void jniSetStaticLongField(Class<?> clazz, long value);\n+    private static native void jniSetStaticFloatField(Class<?> clazz, float value);\n+    private static native void jniSetStaticDoubleField(Class<?> clazz, double value);\n+\n+    static {\n+        System.loadLibrary(\"MutateFinals\");\n+    }\n+\n+    private static void assertTrue(boolean e) {\n+        if (!e) throw new RuntimeException(\"Not true as expected\");\n+    }\n+\n+    private static void assertEquals(Object expected, Object actual) {\n+        if (!Objects.equals(expected, actual)) {\n+            throw new RuntimeException(\"Actual: \" + actual + \", expected: \" + expected);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/mutateFinals\/MutateFinals.java","additions":356,"deletions":0,"binary":false,"changes":356,"status":"added"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8353835\n+ * @summary Test JNI SetXXXField methods to set final instance and final static fields\n+ * @key randomness\n+ * @modules java.management\n+ * @library \/test\/lib\n+ * @compile MutateFinals.java\n+ * @run junit\/native\/timeout=300 MutateFinalsTest\n+ *\/\n+\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+class MutateFinalsTest {\n+\n+    static String javaLibraryPath;\n+\n+    @BeforeAll\n+    static void init() {\n+        javaLibraryPath = System.getProperty(\"java.library.path\");\n+    }\n+\n+    \/**\n+     * The names of the test methods that use JNI to set final instance fields.\n+     *\/\n+    static Stream<String> mutateInstanceFieldMethods() {\n+        return Stream.of(\n+                \"testJniSetObjectField\",\n+                \"testJniSetBooleanField\",\n+                \"testJniSetByteField\",\n+                \"testJniSetCharField\",\n+                \"testJniSetShortField\",\n+                \"testJniSetIntField\",\n+                \"testJniSetLongField\",\n+                \"testJniSetFloatField\",\n+                \"testJniSetDoubleField\"\n+        );\n+    }\n+\n+    \/**\n+     * The names of the test methods that use JNI to set final static fields.\n+     *\/\n+    static Stream<String> mutateStaticFieldMethods() {\n+        return Stream.of(\n+                \"testJniSetStaticObjectField\",\n+                \"testJniSetStaticBooleanField\",\n+                \"testJniSetStaticByteField\",\n+                \"testJniSetStaticCharField\",\n+                \"testJniSetStaticShortField\",\n+                \"testJniSetStaticIntField\",\n+                \"testJniSetStaticLongField\",\n+                \"testJniSetStaticFloatField\",\n+                \"testJniSetStaticDoubleField\"\n+        );\n+    }\n+\n+    \/**\n+     * The names of all test methods that use JNI to set final fields.\n+     *\/\n+    static Stream<String> allMutationMethods() {\n+        return Stream.concat(mutateInstanceFieldMethods(), mutateStaticFieldMethods());\n+    }\n+\n+    \/**\n+     * Mutate a final field with JNI.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"allMutationMethods\")\n+    void testMutateFinal(String methodName) throws Exception {\n+        MutateFinals.invoke(methodName);\n+    }\n+\n+    \/**\n+     * Mutate a final instance field with JNI. The test launches a child VM with -Xcheck:jni\n+     * and expects a warning in the output.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"mutateInstanceFieldMethods\")\n+    void testMutateInstanceFinalWithXCheckJni(String methodName) throws Exception {\n+        test(methodName, \"-Xcheck:jni\")\n+            .shouldContain(\"WARNING in native method: Set<Type>Field called to mutate final instance field\")\n+            .shouldHaveExitValue(0);\n+    }\n+\n+    \/**\n+     * Mutate final static fields with JNI. The test launches a child VM with -Xcheck:jni\n+     * and expects a warning in the output.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"mutateStaticFieldMethods\")\n+    void testMutateStaticFinalWithXCheckJni(String methodName) throws Exception {\n+        test(methodName, \"-Xcheck:jni\")\n+            .shouldContain(\"WARNING in native method: SetStatic<Type>Field called to mutate final static field\")\n+            .shouldHaveExitValue(0);\n+    }\n+\n+    \/**\n+     * Mutate a final instance field with JNI. The test launches a child VM with -Xlog\n+     * and expects a log message in the output.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"mutateInstanceFieldMethods\")\n+    void testMutateInstanceFinalWithLogging(String methodName) throws Exception {\n+        String type = methodName.contains(\"Object\") ? \"Object\" : \"<Type>\";\n+        test(methodName, \"-Xlog:jni=debug\")\n+            .shouldContain(\"[debug][jni] Set\" + type + \"Field mutated final instance field\")\n+            .shouldHaveExitValue(0);\n+    }\n+\n+    \/**\n+     * Mutate a final static field with JNI. The test launches a child VM with -Xlog\n+     * and expects a log message in the output.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"mutateStaticFieldMethods\")\n+    void testMutateStaticFinalWithLogging(String methodName) throws Exception {\n+        String type = methodName.contains(\"Object\") ? \"Object\" : \"<Type>\";\n+        test(methodName, \"-Xlog:jni=debug\")\n+            .shouldContain(\"[debug][jni] SetStatic\" + type + \"Field mutated final static field\")\n+            .shouldHaveExitValue(0);\n+    }\n+\n+    \/**\n+     * Launches MutateFinals with the given method name as parameter, and the given VM options.\n+     *\/\n+    private OutputAnalyzer test(String methodName, String... vmopts) throws Exception {\n+        Stream<String> s1 = Stream.of(\n+                \"-Djava.library.path=\" + javaLibraryPath,\n+                \"--enable-native-access=ALL-UNNAMED\");\n+        Stream<String> s2 = Stream.of(vmopts);\n+        Stream<String> s3 = Stream.of(\"MutateFinals\", methodName);\n+        String[] opts = Stream.concat(Stream.concat(s1, s2), s3).toArray(String[]::new);\n+        var outputAnalyzer = ProcessTools\n+                .executeTestJava(opts)\n+                .outputTo(System.err)\n+                .errorTo(System.err);\n+        return outputAnalyzer;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/mutateFinals\/MutateFinalsTest.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include \"jni.h\"\n+\n+JNIEXPORT void JNICALL Java_MutateFinals_jniSetObjectField(JNIEnv *env, jclass ignore, jobject obj, jobject value) {\n+    jclass clazz = (*env)->GetObjectClass(env, obj);\n+    jfieldID fid = (*env)->GetFieldID(env, clazz, \"value\", \"Ljava\/lang\/Object;\");\n+    if (fid != NULL) {\n+        (*env)->SetObjectField(env, obj, fid, value);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_MutateFinals_jniSetBooleanField(JNIEnv *env, jclass ignore, jobject obj, jboolean value) {\n+    jclass clazz = (*env)->GetObjectClass(env, obj);\n+    jfieldID fid = (*env)->GetFieldID(env, clazz, \"value\", \"Z\");\n+    if (fid != NULL) {\n+        (*env)->SetBooleanField(env, obj, fid, value);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_MutateFinals_jniSetByteField(JNIEnv *env, jclass ignore, jobject obj, jbyte value) {\n+    jclass clazz = (*env)->GetObjectClass(env, obj);\n+    jfieldID fid = (*env)->GetFieldID(env, clazz, \"value\", \"B\");\n+    if (fid != NULL) {\n+        (*env)->SetByteField(env, obj, fid, value);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_MutateFinals_jniSetCharField(JNIEnv *env, jclass ignore, jobject obj, jchar value) {\n+    jclass clazz = (*env)->GetObjectClass(env, obj);\n+    jfieldID fid = (*env)->GetFieldID(env, clazz, \"value\", \"C\");\n+    if (fid != NULL) {\n+        (*env)->SetCharField(env, obj, fid, value);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_MutateFinals_jniSetShortField(JNIEnv *env, jclass ignore, jobject obj, jshort value) {\n+    jclass clazz = (*env)->GetObjectClass(env, obj);\n+    jfieldID fid = (*env)->GetFieldID(env, clazz, \"value\", \"S\");\n+    if (fid != NULL) {\n+        (*env)->SetShortField(env, obj, fid, value);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_MutateFinals_jniSetIntField(JNIEnv *env, jclass ignore, jobject obj, jint value) {\n+    jclass clazz = (*env)->GetObjectClass(env, obj);\n+    jfieldID fid = (*env)->GetFieldID(env, clazz, \"value\", \"I\");\n+    if (fid != NULL) {\n+        (*env)->SetIntField(env, obj, fid, value);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_MutateFinals_jniSetLongField(JNIEnv *env, jclass ignore, jobject obj, jlong value) {\n+    jclass clazz = (*env)->GetObjectClass(env, obj);\n+    jfieldID fid = (*env)->GetFieldID(env, clazz, \"value\", \"J\");\n+    if (fid != NULL) {\n+        (*env)->SetLongField(env, obj, fid, value);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_MutateFinals_jniSetFloatField(JNIEnv *env, jclass ignore, jobject obj, jfloat value) {\n+    jclass clazz = (*env)->GetObjectClass(env, obj);\n+    jfieldID fid = (*env)->GetFieldID(env, clazz, \"value\", \"F\");\n+    if (fid != NULL) {\n+        (*env)->SetFloatField(env, obj, fid, value);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_MutateFinals_jniSetDoubleField(JNIEnv *env, jclass ignore, jobject obj, jdouble value) {\n+    jclass clazz = (*env)->GetObjectClass(env, obj);\n+    jfieldID fid = (*env)->GetFieldID(env, clazz, \"value\", \"D\");\n+    if (fid != NULL) {\n+        (*env)->SetDoubleField(env, obj, fid, value);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_MutateFinals_jniSetStaticObjectField(JNIEnv *env, jclass ignore, jclass clazz, jobject value) {\n+    jfieldID fid = (*env)->GetStaticFieldID(env, clazz, \"value\", \"Ljava\/lang\/Object;\");\n+    if (fid != NULL) {\n+        (*env)->SetStaticObjectField(env, clazz, fid, value);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_MutateFinals_jniSetStaticBooleanField(JNIEnv *env, jclass ignore, jclass clazz, jboolean value) {\n+    jfieldID fid = (*env)->GetStaticFieldID(env, clazz, \"value\", \"Z\");\n+    if (fid != NULL) {\n+        (*env)->SetStaticBooleanField(env, clazz, fid, value);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_MutateFinals_jniSetStaticByteField(JNIEnv *env, jclass ignore, jclass clazz, jbyte value) {\n+    jfieldID fid = (*env)->GetStaticFieldID(env, clazz, \"value\", \"B\");\n+    if (fid != NULL) {\n+        (*env)->SetStaticByteField(env, clazz, fid, value);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_MutateFinals_jniSetStaticCharField(JNIEnv *env, jclass ignore, jclass clazz, jchar value) {\n+    jfieldID fid = (*env)->GetStaticFieldID(env, clazz, \"value\", \"C\");\n+    if (fid != NULL) {\n+        (*env)->SetStaticCharField(env, clazz, fid, value);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_MutateFinals_jniSetStaticShortField(JNIEnv *env, jclass ignore, jclass clazz, jshort value) {\n+    jfieldID fid = (*env)->GetStaticFieldID(env, clazz, \"value\", \"S\");\n+    if (fid != NULL) {\n+        (*env)->SetStaticShortField(env, clazz, fid, value);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_MutateFinals_jniSetStaticIntField(JNIEnv *env, jclass ignore, jclass clazz, jint value) {\n+    jfieldID fid = (*env)->GetStaticFieldID(env, clazz, \"value\", \"I\");\n+    if (fid != NULL) {\n+        (*env)->SetStaticIntField(env, clazz, fid, value);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_MutateFinals_jniSetStaticLongField(JNIEnv *env, jclass ignore, jclass clazz, jlong value) {\n+    jfieldID fid = (*env)->GetStaticFieldID(env, clazz, \"value\", \"J\");\n+    if (fid != NULL) {\n+        (*env)->SetStaticLongField(env, clazz, fid, value);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_MutateFinals_jniSetStaticFloatField(JNIEnv *env, jclass ignore, jclass clazz, jfloat value) {\n+    jfieldID fid = (*env)->GetStaticFieldID(env, clazz, \"value\", \"F\");\n+    if (fid != NULL) {\n+        (*env)->SetStaticFloatField(env, clazz, fid, value);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_MutateFinals_jniSetStaticDoubleField(JNIEnv *env, jclass ignore, jclass clazz, jdouble value) {\n+    jfieldID fid = (*env)->GetStaticFieldID(env, clazz, \"value\", \"D\");\n+    if (fid != NULL) {\n+        (*env)->SetStaticDoubleField(env, clazz, fid, value);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/mutateFinals\/libMutateFinals.c","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+ *                                 --enable-final-field-mutation=ALL-UNNAMED\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandlesGeneralTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,2 @@\n- * @run testng\/othervm TestFieldLookupAccessibility\n+ * @run testng\/othervm --enable-final-field-mutation=ALL-UNNAMED -DwriteAccess=true TestFieldLookupAccessibility\n+ * @run testng\/othervm --illegal-final-field-mutation=deny -DwriteAccess=false TestFieldLookupAccessibility\n@@ -33,1 +34,2 @@\n-import org.testng.Assert;\n+import static org.testng.Assert.*;\n+import org.testng.annotations.BeforeClass;\n@@ -51,0 +53,8 @@\n+    static boolean writeAccess;\n+\n+    @BeforeClass\n+    static void setup() {\n+        String s = System.getProperty(\"writeAccess\");\n+        assertNotNull(s);\n+        writeAccess = Boolean.valueOf(s);\n+    }\n@@ -121,1 +131,5 @@\n-                return !(Modifier.isStatic(f.getModifiers()) && Modifier.isFinal(f.getModifiers()));\n+                if (Modifier.isFinal(f.getModifiers())) {\n+                    return !Modifier.isStatic(f.getModifiers()) && writeAccess;\n+                } else {\n+                    return true;\n+                }\n@@ -229,1 +243,1 @@\n-                Assert.assertEquals(actualFieldNames, expected, \"No accessibility failures:\");\n+                assertEquals(actualFieldNames, expected, \"No accessibility failures:\");\n@@ -232,1 +246,1 @@\n-                Assert.assertEquals(actualFieldNames, expected, \"Accessibility failures differ:\");\n+                assertEquals(actualFieldNames, expected, \"Accessibility failures differ:\");\n@@ -237,1 +251,1 @@\n-                Assert.fail(\"Expecting an IllegalArgumentException for all failures \" + actual);\n+                fail(\"Expecting an IllegalArgumentException for all failures \" + actual);\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/accessibility\/TestFieldLookupAccessibility.java","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @run testng\/othervm UnreflectTest\n@@ -30,0 +29,2 @@\n+ * @run junit\/othervm --enable-final-field-mutation=ALL-UNNAMED -DwriteAccess=true UnreflectTest\n+ * @run junit\/othervm --illegal-final-field-mutation=deny -DwriteAccess=false UnreflectTest\n@@ -41,1 +42,0 @@\n-import java.nio.file.Paths;\n@@ -43,2 +43,3 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -46,4 +47,6 @@\n-public class UnreflectTest {\n-    static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n-    static final Class<?> hiddenClass = defineHiddenClass();\n-    private static Class<?> defineHiddenClass() {\n+class UnreflectTest {\n+    static Class<?> hiddenClass;\n+    static boolean writeAccess;\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n@@ -51,9 +54,7 @@\n-        Path cf = Paths.get(classes, \"Fields.class\");\n-        try {\n-            byte[] bytes = Files.readAllBytes(cf);\n-            return MethodHandles.lookup().defineHiddenClass(bytes, true).lookupClass();\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        } catch (IllegalAccessException e) {\n-            throw new RuntimeException(e);\n-        }\n+        Path cf = Path.of(classes, \"Fields.class\");\n+        byte[] bytes = Files.readAllBytes(cf);\n+        hiddenClass = MethodHandles.lookup().defineHiddenClass(bytes, true).lookupClass();\n+\n+        String s = System.getProperty(\"writeAccess\");\n+        assertNotNull(s);\n+        writeAccess = Boolean.valueOf(s);\n@@ -67,1 +68,1 @@\n-    public void testFieldsInNormalClass() throws Throwable {\n+    void testFieldsInNormalClass() throws Throwable {\n@@ -75,1 +76,5 @@\n-        readWriteAccessibleObject(c, \"FINAL\", o, true);\n+        if (writeAccess) {\n+            readWriteAccessibleObject(c, \"FINAL\", o, true);\n+        } else {\n+            readOnlyAccessibleObject(c, \"FINAL\", o, true);\n+        }\n@@ -84,1 +89,1 @@\n-    public void testFieldsInHiddenClass() throws Throwable {\n+    void testFieldsInHiddenClass() throws Throwable {\n@@ -102,1 +107,2 @@\n-    public void testFieldsInRecordClass() throws Throwable {\n+    @Test\n+    void testFieldsInRecordClass() throws Throwable {\n@@ -124,1 +130,2 @@\n-        MethodHandle mh = LOOKUP.unreflectGetter(f);\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        MethodHandle mh = lookup.unreflectGetter(f);\n@@ -127,7 +134,2 @@\n-        try {\n-            LOOKUP.unreflectSetter(f);\n-            assertTrue(false, \"should fail to unreflect a setter for \" + name);\n-        } catch (IllegalAccessException e) {\n-        }\n-\n-        VarHandle vh = LOOKUP.unreflectVarHandle(f);\n+        assertThrows(IllegalAccessException.class, () -> lookup.unreflectSetter(f));\n+        VarHandle vh = lookup.unreflectVarHandle(f);\n@@ -166,1 +168,1 @@\n-        VarHandle vh = LOOKUP.unreflectVarHandle(f);\n+        VarHandle vh = MethodHandles.lookup().unreflectVarHandle(f);\n","filename":"test\/jdk\/java\/lang\/invoke\/unreflect\/UnreflectTest.java","additions":33,"deletions":31,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n- * @build Fields HiddenClassTest\n- * @run testng\/othervm HiddenClassTest\n@@ -29,0 +27,2 @@\n+ * @run junit\/othervm --enable-final-field-mutation=ALL-UNNAMED -DwriteAccess=true HiddenClassTest\n+ * @run junit\/othervm --illegal-final-field-mutation=deny -DwriteAccess=false HiddenClassTest\n@@ -40,2 +40,3 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -43,3 +44,6 @@\n-public class HiddenClassTest {\n-    static final Class<?> hiddenClass = defineHiddenClass();\n-    private static Class<?> defineHiddenClass() {\n+class HiddenClassTest {\n+    static Class<?> hiddenClass;\n+    static boolean writeAccess;\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n@@ -47,9 +51,7 @@\n-        Path cf = Paths.get(classes, \"Fields.class\");\n-        try {\n-            byte[] bytes = Files.readAllBytes(cf);\n-            return MethodHandles.lookup().defineHiddenClass(bytes, true).lookupClass();\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        } catch (IllegalAccessException e) {\n-            throw new RuntimeException(e);\n-        }\n+        Path cf = Path.of(classes, \"Fields.class\");\n+        byte[] bytes = Files.readAllBytes(cf);\n+        hiddenClass = MethodHandles.lookup().defineHiddenClass(bytes, true).lookupClass();\n+\n+        String s = System.getProperty(\"writeAccess\");\n+        assertNotNull(s);\n+        writeAccess = Boolean.valueOf(s);\n@@ -63,1 +65,1 @@\n-    public void testFieldsInNormalClass() throws Throwable {\n+    void testFieldsInNormalClass() throws Throwable {\n@@ -71,1 +73,5 @@\n-        readWriteAccessibleObject(c, \"FINAL\", o, true);\n+        if (writeAccess) {\n+            readWriteAccessibleObject(c, \"FINAL\", o, true);\n+        } else {\n+            readOnlyAccessibleObject(c, \"FINAL\", o, true);\n+        }\n@@ -80,1 +86,1 @@\n-    public void testFieldsInHiddenClass() throws Throwable {\n+    void testFieldsInHiddenClass() throws Throwable {\n@@ -99,5 +105,1 @@\n-        try {\n-            f.set(o, null);\n-            assertTrue(false, \"should fail to set \" + name);\n-        } catch (IllegalAccessException e) {\n-        }\n+        assertThrows(IllegalAccessException.class, () -> f.set(o, null));\n@@ -116,5 +118,1 @@\n-        try {\n-            f.set(o, null);\n-        } catch (IllegalAccessException e) {\n-            throw e;\n-        }\n+        f.set(o, null);\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessibleObject\/HiddenClassTest.java","additions":28,"deletions":30,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @run testng NegativeTest\n@@ -30,0 +29,1 @@\n+ * @run testng\/othervm --enable-final-field-mutation=ALL-UNNAMED NegativeTest\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/NegativeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @run main\/othervm --enable-final-field-mutation=ALL-UNNAMED Set\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/Set.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8353835\n+ * @summary Basic test for JFR FinalFieldMutation event\n+ * @requires vm.hasJFR\n+ * @modules jdk.jfr\/jdk.jfr.events\n+ * @run junit FinalFieldMutationEventTest\n+ * @run junit\/othervm --illegal-final-field-mutation=allow FinalFieldMutationEventTest\n+ * @run junit\/othervm --illegal-final-field-mutation=warn FinalFieldMutationEventTest\n+ * @run junit\/othervm --illegal-final-field-mutation=debug FinalFieldMutationEventTest\n+ * @run junit\/othervm --illegal-final-field-mutation=deny FinalFieldMutationEventTest\n+ *\/\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.stream.Stream;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedClass;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.jfr.events.FinalFieldMutationEvent;\n+import jdk.jfr.events.StackFilter;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class FinalFieldMutationEventTest {\n+    private static final String EVENT_NAME = \"jdk.FinalFieldMutation\";\n+\n+    \/**\n+     * Test class with final field.\n+     *\/\n+    private static class C {\n+        final int value;\n+        C(int value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    \/**\n+     * Test jdk.FinalFieldMutation is recorded when mutating a final field.\n+     *\/\n+    @Test\n+    void testFieldSet() throws Exception {\n+        Field field = C.class.getDeclaredField(\"value\");\n+        field.setAccessible(true);\n+\n+        try (Recording recording = new Recording()) {\n+            recording.enable(EVENT_NAME).withStackTrace();\n+\n+            boolean mutated = false;\n+            recording.start();\n+            try {\n+                var obj = new C(100);\n+                try {\n+                    field.setInt(obj, 200);\n+                    mutated = true;\n+                } catch (IllegalAccessException e) {\n+                    \/\/ denied\n+                }\n+            } finally {\n+                recording.stop();\n+            }\n+\n+            \/\/ FinalFieldMutation event should be recorded if field mutated\n+            List<RecordedEvent> events = find(recording, EVENT_NAME);\n+            System.err.println(events);\n+            if (mutated) {\n+                assertEquals(1, events.size(), \"1 event expected\");\n+                checkEvent(events.get(0), field, \"FinalFieldMutationEventTest::testFieldSet\");\n+            } else {\n+                assertEquals(0, events.size(), \"No events expected\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test jdk.FinalFieldMutation is recorded when unreflecting a field field for mutation.\n+     *\/\n+    @Test\n+    void testUnreflectSetter() throws Exception {\n+        Field field = C.class.getDeclaredField(\"value\");\n+        field.setAccessible(true);\n+\n+        try (Recording recording = new Recording()) {\n+            recording.enable(EVENT_NAME).withStackTrace();\n+\n+            boolean unreflected = false;\n+            recording.start();\n+            try {\n+                MethodHandles.lookup().unreflectSetter(field);\n+                unreflected = true;\n+            } catch (IllegalAccessException e) {\n+                \/\/ denied\n+            } finally {\n+                recording.stop();\n+            }\n+\n+            \/\/ FinalFieldMutation event should be recorded if field unreflected for set\n+            List<RecordedEvent> events = find(recording, EVENT_NAME);\n+            System.err.println(events);\n+            if (unreflected) {\n+                assertEquals(1, events.size(), \"1 event expected\");\n+                checkEvent(events.get(0), field, \"FinalFieldMutationEventTest::testUnreflectSetter\");\n+            } else {\n+                assertEquals(0, events.size(), \"No events expected\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test that a FinalFieldMutationEvent event has the declaringClass and fieldName of\n+     * the given Field, and the expected top frame.\n+     *\/\n+    private void checkEvent(RecordedEvent e, Field f, String expectedTopFrame) {\n+        RecordedClass clazz = e.getClass(\"declaringClass\");\n+        assertNotNull(clazz);\n+        assertEquals(f.getDeclaringClass().getName(), clazz.getName());\n+        assertEquals(f.getName(), e.getString(\"fieldName\"));\n+\n+        \/\/ check the top-frame of the stack trace\n+        RecordedMethod m = e.getStackTrace().getFrames().getFirst().getMethod();\n+        assertEquals(expectedTopFrame, m.getType().getName() + \"::\" + m.getName());\n+    }\n+\n+    \/**\n+     * Tests that FinalFieldMutationEvent's stack filter value names classes\/methods that\n+     * exist. This will help detect stale values when the implementation is refactored.\n+     *\/\n+    @Test\n+    void testFinalFieldMutationEventStackFilter() throws Exception {\n+        String[] filters = FinalFieldMutationEvent.class.getAnnotation(StackFilter.class).value();\n+        for (String filter : filters) {\n+            String[] classAndMethod = filter.split(\"::\");\n+            String cn = classAndMethod[0];\n+\n+            \/\/ throws if class not found\n+            Class<?> clazz = Class.forName(cn);\n+\n+            \/\/ if the filter has a method name then check a method of that name exists\n+            if (classAndMethod.length > 1) {\n+                String mn = classAndMethod[1];\n+                Method method = Stream.of(clazz.getDeclaredMethods())\n+                        .filter(m -> m.getName().equals(mn))\n+                        .findFirst()\n+                        .orElse(null);\n+                assertNotNull(method, cn + \"::\" + mn + \" not found\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns the list of events in the given recording with the given name.\n+     *\/\n+    private List<RecordedEvent> find(Recording recording, String name) throws Exception {\n+        Path recordingFile = recordingFile(recording);\n+        return RecordingFile.readAllEvents(recordingFile)\n+                .stream()\n+                .filter(e -> e.getEventType().getName().equals(name))\n+                .toList();\n+    }\n+\n+    \/**\n+     * Return the file path to the recording file.\n+     *\/\n+    private Path recordingFile(Recording recording) throws Exception {\n+        Path recordingFile = recording.getDestination();\n+        if (recordingFile == null) {\n+            ProcessHandle h = ProcessHandle.current();\n+            recordingFile = Path.of(\"recording-\" + recording.getId() + \"-pid\" + h.pid() + \".jfr\");\n+            recording.dump(recordingFile);\n+        }\n+        return recordingFile;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/FinalFieldMutationEventTest.java","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -0,0 +1,358 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8353835\n+ * @summary Test Field.set and Lookup.unreflectSetter on final instance fields\n+ * @run junit\/othervm -DwriteAccess=true MutateFinalsTest\n+ * @run junit\/othervm --enable-final-field-mutation=ALL-UNNAMED -DwriteAccess=true MutateFinalsTest\n+ * @run junit\/othervm --illegal-final-field-mutation=allow -DwriteAccess=true MutateFinalsTest\n+ * @run junit\/othervm --illegal-final-field-mutation=warn -DwriteAccess=true MutateFinalsTest\n+ * @run junit\/othervm --illegal-final-field-mutation=debug -DwriteAccess=true MutateFinalsTest\n+ * @run junit\/othervm --illegal-final-field-mutation=deny -DwriteAccess=false MutateFinalsTest\n+ *\/\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Field;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class MutateFinalsTest {\n+    static boolean writeAccess;\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        String s = System.getProperty(\"writeAccess\");\n+        assertNotNull(s);\n+        writeAccess = Boolean.valueOf(s);\n+    }\n+\n+    @Test\n+    void testFieldSet() throws Exception {\n+        class C {\n+            final String value;\n+            C(String value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+\n+        String oldValue = \"oldValue\";\n+        String newValue = \"newValue\";\n+        var obj = new C(oldValue);\n+\n+        f.setAccessible(false);\n+        assertThrows(NullPointerException.class, () -> f.set(null, newValue));\n+        assertThrows(IllegalAccessException.class, () -> f.set(obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+\n+        f.setAccessible(true);\n+        assertThrows(NullPointerException.class, () -> f.set(null, newValue));\n+        if (writeAccess) {\n+            assertThrows(IllegalArgumentException.class, () -> f.set(\"not a C\", newValue));\n+            assertThrows(IllegalArgumentException.class, () -> f.set(obj, 100)); \/\/ not a string\n+            f.set(obj, newValue);\n+            assertTrue(obj.value == newValue);\n+        } else {\n+            assertThrows(IllegalAccessException.class, () -> f.set(obj, newValue));\n+            assertTrue(obj.value == oldValue);\n+        }\n+    }\n+\n+    @Test\n+    void testFieldSetBoolean() throws Throwable {\n+        class C {\n+            final boolean value;\n+            C(boolean value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+\n+        boolean oldValue = false;\n+        boolean newValue = true;\n+        var obj = new C(oldValue);\n+\n+        f.setAccessible(false);\n+        assertThrows(NullPointerException.class, () -> f.setBoolean(null, newValue));\n+        assertThrows(IllegalAccessException.class, () -> f.setBoolean(obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+\n+        f.setAccessible(true);\n+        assertThrows(NullPointerException.class, () -> f.setBoolean(null, newValue));\n+        if (writeAccess) {\n+            assertThrows(IllegalArgumentException.class, () -> f.setBoolean(\"not a C\", newValue));\n+            f.setBoolean(obj, newValue);\n+            assertTrue(obj.value == newValue);\n+        } else {\n+            assertThrows(IllegalAccessException.class, () -> f.setBoolean(obj, newValue));\n+            assertTrue(obj.value == oldValue);\n+        }\n+    }\n+\n+    @Test\n+    void testFieldSetByte() throws Exception {\n+        class C {\n+            final byte value;\n+            C(byte value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+\n+        byte oldValue = (byte) 1;\n+        byte newValue = (byte) 2;\n+        var obj = new C(oldValue);\n+\n+        f.setAccessible(false);\n+        assertThrows(NullPointerException.class, () -> f.setByte(null, newValue));\n+        assertThrows(IllegalAccessException.class, () -> f.setByte(obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+\n+        f.setAccessible(true);\n+        assertThrows(NullPointerException.class, () -> f.setByte(null, newValue));\n+        if (writeAccess) {\n+            assertThrows(IllegalArgumentException.class, () -> f.setByte(\"not a C\", newValue));\n+            f.setByte(obj, newValue);\n+            assertTrue(obj.value == newValue);\n+        } else {\n+            assertThrows(IllegalAccessException.class, () -> f.setByte(obj, newValue));\n+            assertTrue(obj.value == oldValue);\n+        }\n+    }\n+\n+    @Test\n+    void testFieldSetChar() throws Exception {\n+        class C {\n+            final char value;\n+            C(char value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+\n+        char oldValue = 'A';\n+        char newValue = 'B';\n+        var obj = new C(oldValue);\n+\n+        f.setAccessible(false);\n+        assertThrows(NullPointerException.class, () -> f.setChar(null, newValue));\n+        assertThrows(IllegalAccessException.class, () -> f.setChar(obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+\n+        f.setAccessible(true);\n+        assertThrows(NullPointerException.class, () -> f.setChar(null, newValue));\n+        if (writeAccess) {\n+            assertThrows(IllegalArgumentException.class, () -> f.setChar(\"not a C\", newValue));\n+            f.setChar(obj, newValue);\n+            assertTrue(obj.value == newValue);\n+        } else {\n+            assertThrows(IllegalAccessException.class, () -> f.setChar(obj, newValue));\n+            assertTrue(obj.value == oldValue);\n+        }\n+    }\n+\n+    @Test\n+    void testFieldSetShort() throws Exception {\n+        class C {\n+            final short value;\n+            C(short value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+\n+        short oldValue = (short) 1;\n+        short newValue = (short) 2;\n+        var obj = new C(oldValue);\n+\n+        f.setAccessible(false);\n+        assertThrows(NullPointerException.class, () -> f.setShort(null, newValue));\n+        assertThrows(IllegalAccessException.class, () -> f.setShort(obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+\n+        f.setAccessible(true);\n+        assertThrows(NullPointerException.class, () -> f.setShort(null, newValue));\n+        if (writeAccess) {\n+            assertThrows(IllegalArgumentException.class, () -> f.setShort(\"not a C\", newValue));\n+            f.setShort(obj, newValue);\n+            assertTrue(obj.value == newValue);\n+        } else {\n+            assertThrows(IllegalAccessException.class, () -> f.setShort(obj, newValue));\n+            assertTrue(obj.value == oldValue);\n+        }\n+    }\n+\n+    @Test\n+    void testFieldSetInt() throws Exception {\n+        class C {\n+            final int value;\n+            C(int value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+\n+        int oldValue = 1;\n+        int newValue = 2;\n+        var obj = new C(oldValue);\n+\n+        f.setAccessible(false);\n+        assertThrows(NullPointerException.class, () -> f.setInt(null, newValue));\n+        assertThrows(IllegalAccessException.class, () -> f.setInt(obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+\n+        f.setAccessible(true);\n+        assertThrows(NullPointerException.class, () -> f.setInt(null, newValue));\n+        if (writeAccess) {\n+            assertThrows(IllegalArgumentException.class, () -> f.setInt(\"not a C\", newValue));\n+            f.setInt(obj, newValue);\n+            assertTrue(obj.value == newValue);\n+        } else {\n+            assertThrows(IllegalAccessException.class, () -> f.setInt(obj, newValue));\n+            assertTrue(obj.value == oldValue);\n+        }\n+    }\n+\n+    @Test\n+    void testFieldSetLong() throws Exception {\n+        class C {\n+            final long value;\n+            C(long value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+\n+        long oldValue = 1L;\n+        long newValue = 2L;\n+        var obj = new C(oldValue);\n+\n+        f.setAccessible(false);\n+        assertThrows(NullPointerException.class, () -> f.setLong(null, newValue));\n+        assertThrows(IllegalAccessException.class, () -> f.setLong(obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+\n+        f.setAccessible(true);\n+        assertThrows(NullPointerException.class, () -> f.setLong(null, newValue));\n+        if (writeAccess) {\n+            assertThrows(IllegalArgumentException.class, () -> f.setLong(\"not a C\", newValue));\n+            f.setLong(obj, newValue);\n+            assertTrue(obj.value == newValue);\n+        } else {\n+            assertThrows(IllegalAccessException.class, () -> f.setLong(obj, newValue));\n+            assertTrue(obj.value == oldValue);\n+        }\n+    }\n+\n+    @Test\n+    void testFieldSetFloat() throws Exception {\n+        class C {\n+            final float value;\n+            C(float value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+\n+        float oldValue = 1.0f;\n+        float newValue = 2.0f;\n+        var obj = new C(oldValue);\n+\n+        f.setAccessible(false);\n+        assertThrows(NullPointerException.class, () -> f.setFloat(null, newValue));\n+        assertThrows(IllegalAccessException.class, () -> f.setFloat(obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+\n+        f.setAccessible(true);\n+        assertThrows(NullPointerException.class, () -> f.setFloat(null, newValue));\n+        if (writeAccess) {\n+            assertThrows(IllegalArgumentException.class, () -> f.setFloat(\"not a C\", newValue));\n+            f.setFloat(obj, newValue);\n+            assertTrue(obj.value == newValue);\n+        } else {\n+            assertThrows(IllegalAccessException.class, () -> f.setFloat(obj, newValue));\n+            assertTrue(obj.value == oldValue);\n+        }\n+    }\n+\n+    @Test\n+    void testFieldSetDouble() throws Exception {\n+        class C {\n+            final double value;\n+            C(double value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+\n+        double oldValue = 1.0d;\n+        double newValue = 2.0d;\n+        var obj = new C(oldValue);\n+\n+        f.setAccessible(false);\n+        assertThrows(NullPointerException.class, () -> f.setDouble(null, newValue));\n+        assertThrows(IllegalAccessException.class, () -> f.setDouble(obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+\n+        f.setAccessible(true);\n+        assertThrows(NullPointerException.class, () -> f.setDouble(null, newValue));\n+        if (writeAccess) {\n+            assertThrows(IllegalArgumentException.class, () -> f.setDouble(\"not a C\", newValue));\n+            f.setDouble(obj, newValue);\n+            assertTrue(obj.value == newValue);\n+        } else {\n+            assertThrows(IllegalAccessException.class, () -> f.setDouble(obj, newValue));\n+            assertTrue(obj.value == oldValue);\n+        }\n+    }\n+\n+    @Test\n+    void testUnreflectSetter() throws Throwable {\n+        class C {\n+            final Object value;\n+            C(Object value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+\n+        Object oldValue = new Object();\n+        var obj = new C(oldValue);\n+\n+        f.setAccessible(false);\n+        assertThrows(IllegalAccessException.class, () -> MethodHandles.lookup().unreflectSetter(f));\n+\n+        f.setAccessible(true);\n+        if (writeAccess) {\n+            Object newValue = new Object();\n+            MethodHandles.lookup().unreflectSetter(f).invoke(obj, newValue);\n+            assertTrue(obj.value == newValue);\n+        } else {\n+            assertThrows(IllegalAccessException.class, () -> MethodHandles.lookup().unreflectSetter(f));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/MutateFinalsTest.java","additions":358,"deletions":0,"binary":false,"changes":358,"status":"added"},{"patch":"@@ -0,0 +1,294 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8353835\n+ * @summary Test the command line option --enable-final-field-mutation\n+ * @library \/test\/lib\n+ * @build CommandLineTestHelper\n+ * @run junit CommandLineTest\n+ *\/\n+\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+class CommandLineTest {\n+\n+    \/\/ helper class name\n+    private static final String HELPER = \"CommandLineTestHelper\";\n+\n+    \/\/ warning output\n+    private static final String WARNING_LINE1 =\n+            \"WARNING: Final field value in class \" + HELPER;\n+    private static final String WARNING_LINE3 =\n+            \"WARNING: Use --enable-final-field-mutation=ALL-UNNAMED to avoid a warning\";\n+    private static final String WARNING_LINE4 =\n+            \"WARNING: Mutating final fields will be blocked in a future release unless final field mutation is enabled\";\n+\n+    \/\/ warning line 2 depends on the method\n+    private static final String WARNING_MUTATED =\n+            \" has been mutated reflectively by class \" + HELPER + \" in unnamed module\";\n+    private static final String WARNING_UNREFLECTED =\n+            \" has been unreflected for mutation by class \" + HELPER + \" in unnamed module\";\n+\n+    \/**\n+     * Test that a warning is printed by default.\n+     *\/\n+    @Test\n+    void testDefault() throws Exception {\n+        test(\"testFieldSetInt\")\n+            .shouldContain(WARNING_LINE1)\n+            .shouldContain(WARNING_MUTATED)\n+            .shouldContain(WARNING_LINE3)\n+            .shouldContain(WARNING_LINE4)\n+            .shouldHaveExitValue(0);\n+\n+        test(\"testUnreflectSetter\")\n+            .shouldContain(WARNING_LINE1)\n+            .shouldContain(WARNING_UNREFLECTED)\n+            .shouldContain(WARNING_LINE3)\n+            .shouldContain(WARNING_LINE4)\n+            .shouldHaveExitValue(0);\n+    }\n+\n+    \/**\n+     * Test allow mutation of finals.\n+     *\/\n+    @Test\n+    void testAllow() throws Exception {\n+        test(\"testFieldSetInt\", \"--illegal-final-field-mutation=allow\")\n+            .shouldNotContain(WARNING_LINE1)\n+            .shouldNotContain(WARNING_MUTATED)\n+            .shouldHaveExitValue(0);\n+\n+        test(\"testFieldSetInt\", \"--enable-final-field-mutation=ALL-UNNAMED\")\n+            .shouldNotContain(WARNING_LINE1)\n+            .shouldNotContain(WARNING_MUTATED)\n+            .shouldHaveExitValue(0);\n+\n+        \/\/ allow ALL-UNNAMED, deny by default\n+        test(\"testFieldSetInt\", \"--enable-final-field-mutation=ALL-UNNAMED\", \"--illegal-final-field-mutation=deny\")\n+            .shouldNotContain(WARNING_LINE1)\n+            .shouldNotContain(WARNING_MUTATED)\n+            .shouldHaveExitValue(0);\n+\n+        test(\"testUnreflectSetter\", \"--illegal-final-field-mutation=allow\")\n+            .shouldNotContain(WARNING_LINE1)\n+            .shouldNotContain(WARNING_UNREFLECTED)\n+            .shouldHaveExitValue(0);\n+\n+        test(\"testUnreflectSetter\", \"--enable-final-field-mutation=ALL-UNNAMED\")\n+            .shouldNotContain(WARNING_LINE1)\n+            .shouldNotContain(WARNING_UNREFLECTED)\n+            .shouldHaveExitValue(0);\n+\n+        \/\/ allow ALL-UNNAMED, deny by default\n+        test(\"testUnreflectSetter\", \"--enable-final-field-mutation=ALL-UNNAMED\", \"--illegal-final-field-mutation=deny\")\n+            .shouldNotContain(WARNING_LINE1)\n+            .shouldNotContain(WARNING_UNREFLECTED)\n+            .shouldHaveExitValue(0);\n+    }\n+\n+    \/**\n+     * Test warn on first mutation or unreflect of a final field.\n+     *\/\n+    @Test\n+    void testWarn() throws Exception {\n+        test(\"testFieldSetInt\", \"--illegal-final-field-mutation=warn\")\n+            .shouldContain(WARNING_LINE1)\n+            .shouldContain(WARNING_MUTATED)\n+            .shouldContain(WARNING_LINE3)\n+            .shouldContain(WARNING_LINE4)\n+            .shouldHaveExitValue(0);\n+\n+        test(\"testUnreflectSetter\", \"--illegal-final-field-mutation=warn\")\n+            .shouldContain(WARNING_LINE1)\n+            .shouldContain(WARNING_UNREFLECTED)\n+            .shouldContain(WARNING_LINE3)\n+            .shouldContain(WARNING_LINE4)\n+            .shouldHaveExitValue(0);\n+\n+        \/\/ should be one warning only, for Field.set\n+        var output = test(\"testFieldSetInt+testUnreflectSetter\", \"--illegal-final-field-mutation=warn\")\n+            .shouldContain(WARNING_MUTATED)\n+            .shouldNotContain(WARNING_UNREFLECTED)\n+            .shouldHaveExitValue(0)\n+            .getOutput();\n+        assertEquals(1, countStrings(output, WARNING_LINE1));\n+        assertEquals(1, countStrings(output, WARNING_LINE3));\n+        assertEquals(1, countStrings(output, WARNING_LINE4));\n+\n+        \/\/ should be one warning only, for Lookup.unreflectSetter\n+        output = test(\"testUnreflectSetter+testFieldSetInt\", \"--illegal-final-field-mutation=warn\")\n+            .shouldNotContain(WARNING_MUTATED)\n+            .shouldContain(WARNING_UNREFLECTED)\n+            .shouldHaveExitValue(0)\n+            .getOutput();\n+        assertEquals(1, countStrings(output, WARNING_LINE1));\n+        assertEquals(1, countStrings(output, WARNING_LINE3));\n+        assertEquals(1, countStrings(output, WARNING_LINE4));\n+    }\n+\n+    \/**\n+     * Test debug mode.\n+     *\/\n+    @Test\n+    void testDebug() throws Exception {\n+        test(\"testFieldSetInt+testUnreflectSetter\", \"--illegal-final-field-mutation=debug\")\n+            .shouldContain(\"Final field value in class \" + HELPER)\n+            .shouldContain(WARNING_MUTATED)\n+            .shouldContain(\"java.lang.reflect.Field.setInt\")\n+            .shouldContain(WARNING_UNREFLECTED)\n+            .shouldContain(\"java.lang.invoke.MethodHandles$Lookup.unreflectSetter\")\n+            .shouldHaveExitValue(0);\n+\n+        test(\"testUnreflectSetter+testFieldSetInt\", \"--illegal-final-field-mutation=debug\")\n+            .shouldContain(\"Final field value in class \" + HELPER)\n+            .shouldContain(WARNING_UNREFLECTED)\n+            .shouldContain(\"java.lang.invoke.MethodHandles$Lookup.unreflectSetter\")\n+            .shouldContain(WARNING_MUTATED)\n+            .shouldContain(\"java.lang.reflect.Field.setInt\")\n+            .shouldHaveExitValue(0);\n+    }\n+\n+    \/**\n+     * Test deny mutation of finals.\n+     *\/\n+    @Test\n+    void testDeny() throws Exception {\n+        test(\"testFieldSetInt\", \"--illegal-final-field-mutation=deny\")\n+            .shouldNotContain(WARNING_LINE1)\n+            .shouldNotContain(WARNING_MUTATED)\n+            .shouldContain(\"java.lang.IllegalAccessException\")\n+            .shouldNotHaveExitValue(0);\n+\n+        test(\"testUnreflectSetter\", \"--illegal-final-field-mutation=deny\")\n+            .shouldNotContain(WARNING_LINE1)\n+            .shouldNotContain(WARNING_UNREFLECTED)\n+            .shouldContain(\"java.lang.IllegalAccessException\")\n+            .shouldNotHaveExitValue(0);\n+    }\n+\n+    \/**\n+     * Test last usage of --illegal-final-field-mutation \"wins\".\n+     *\/\n+    @Test\n+    void testLastOneWins() throws Exception {\n+        test(\"testFieldSetInt\", \"--illegal-final-field-mutation=allow\", \"--illegal-final-field-mutation=deny\")\n+            .shouldNotContain(WARNING_LINE1)\n+            .shouldNotContain(WARNING_MUTATED)\n+            .shouldContain(\"java.lang.IllegalAccessException\")\n+            .shouldNotHaveExitValue(0);\n+\n+        test(\"testFieldSetInt\", \"--illegal-final-field-mutation=deny\", \"--illegal-final-field-mutation=warn\")\n+            .shouldContain(WARNING_LINE1)\n+            .shouldContain(WARNING_MUTATED)\n+            .shouldHaveExitValue(0);\n+    }\n+\n+    \/**\n+     * Test --illegal-final-field-mutation with bad values.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(strings = { \"\", \"bad\" })\n+    void testInvalidValues(String value) throws Exception {\n+        test(\"testFieldSetInt\", \"--illegal-final-field-mutation=\" + value)\n+            .shouldContain(\"Value specified to --illegal-final-field-mutation not recognized\")\n+            .shouldNotHaveExitValue(0);\n+    }\n+\n+    \/**\n+     * Test setting the internal system properties (that correspond to the command line\n+     * options) on the commannd line. They should be ignored.\n+     *\/\n+    @Test\n+    void testSetPropertyOnCommandLine() throws Exception {\n+        \/\/ --enable-final-field-mutation=ALL-UNNAMED\n+        test(\"testFieldSetInt\", \"-Djdk.module.enable.final.field.mutation.0=ALL-UNNAMED\")\n+                .shouldContain(WARNING_LINE1)\n+                .shouldContain(WARNING_MUTATED)\n+                .shouldContain(WARNING_LINE3)\n+                .shouldContain(WARNING_LINE4)\n+                .shouldHaveExitValue(0);\n+\n+        \/\/ --illegal-final-field-mutation=allow\n+        test(\"testFieldSetInt\", \"-Djdk.module.illegal.final.field.mutation=allow\")\n+                .shouldContain(WARNING_LINE1)\n+                .shouldContain(WARNING_MUTATED)\n+                .shouldContain(WARNING_LINE3)\n+                .shouldContain(WARNING_LINE4)\n+                .shouldHaveExitValue(0);\n+    }\n+\n+    \/**\n+     * Test setting the internal system properties (that correspond to the command line\n+     * options) at runtime. They should be ignored.\n+     *\/\n+    @Test\n+    void testSetPropertyAtRuntime() throws Exception {\n+        \/\/ --enable-final-field-mutation=ALL-UNNAMED\n+        test(\"setPropertyIllegalFinalFieldMutationAllow+testFieldSetInt\")\n+            .shouldContain(WARNING_LINE1)\n+            .shouldContain(WARNING_MUTATED)\n+            .shouldContain(WARNING_LINE3)\n+            .shouldContain(WARNING_LINE4)\n+            .shouldHaveExitValue(0);\n+\n+        \/\/ --illegal-final-field-mutation=allow\n+        test(\"setPropertyEnableFinalFieldMutationAllUnnamed+testFieldSetInt\")\n+                .shouldContain(WARNING_LINE1)\n+                .shouldContain(WARNING_MUTATED)\n+                .shouldContain(WARNING_LINE3)\n+                .shouldContain(WARNING_LINE4)\n+                .shouldHaveExitValue(0);\n+    }\n+\n+    \/**\n+     * Launch helper with the given arguments and VM options.\n+     *\/\n+    private OutputAnalyzer test(String action, String... vmopts) throws Exception {\n+        Stream<String> s1 = Stream.of(vmopts);\n+        Stream<String> s2 = Stream.of(HELPER, action);\n+        String[] opts = Stream.concat(s1, s2).toArray(String[]::new);\n+        var outputAnalyzer = ProcessTools\n+                .executeTestJava(opts)\n+                .outputTo(System.err)\n+                .errorTo(System.err);\n+        return outputAnalyzer;\n+    }\n+\n+    \/**\n+     * Counts the number of substrings in the given input string.\n+     *\/\n+    private int countStrings(String input, String substring) {\n+        return input.split(Pattern.quote(substring)).length - 1;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/cli\/CommandLineTest.java","additions":294,"deletions":0,"binary":false,"changes":294,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.invoke.MethodHandles;\n+\n+public class CommandLineTestHelper {\n+\n+    \/**\n+     * The argument is a list of names of no-arg static methods in this class to invoke.\n+     * The names are separated with a '+'.\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+        String[] methodNames = args.length > 0 ? args[0].split(\"\\\\+\") : new String[0];\n+        for (String methodName : methodNames) {\n+            Method m = CommandLineTestHelper.class.getDeclaredMethod(methodName);\n+            m.invoke(null);\n+        }\n+    }\n+\n+    static void testFieldSetInt() throws Exception {\n+        class C {\n+            final int value;\n+            C(int value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+        f.setAccessible(true);\n+        var obj = new C(100);\n+        f.setInt(obj, 200);\n+        if (obj.value != 200) {\n+            throw new RuntimeException(\"Unexpected value: \" + obj.value);\n+        }\n+    }\n+\n+    static void testUnreflectSetter() throws Throwable {\n+        class C {\n+            final int value;\n+            C(int value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+        f.setAccessible(true);\n+        var obj = new C(100);\n+        MethodHandles.lookup().unreflectSetter(f).invoke(obj, 200);\n+        if (obj.value != 200) {\n+            throw new RuntimeException(\"Unexpected value: \" + obj.value);\n+        }\n+    }\n+\n+    \/**\n+     * Set the internal system property that corresponds to the first usage of\n+     * --enable-final-field-mutation.\n+     *\/\n+    static void setPropertyEnableFinalFieldMutationAllUnnamed() {\n+        System.setProperty(\"jdk.module.enable.final.field.mutation.0\", \"ALL-UNNAMED\");\n+    }\n+\n+    \/**\n+     * Set the internal system property that corresponds to --illegal-final-field-mutation.\n+     *\/\n+    static void setPropertyIllegalFinalFieldMutationAllow() {\n+        System.setProperty(\"jdk.module.illegal.final.field.mutation\", \"allow\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/cli\/CommandLineTestHelper.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,227 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8353835\n+ * @summary Test the executable JAR file attribute Enable-Final-Field-Mutation\n+ * @library \/test\/lib\n+ * @build m\/*\n+ * @build ExecutableJarTestHelper jdk.test.lib.util.JarUtils\n+ * @run junit ExecutableJarTest\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+import java.util.jar.Attributes;\n+import java.util.jar.Manifest;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.util.JarUtils;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class ExecutableJarTest {\n+\n+    \/\/ helper class name\n+    private static final String HELPER = \"ExecutableJarTestHelper\";\n+\n+    \/\/ warning output\n+    private static final String WARNING_LINE1 =\n+            \"WARNING: Final field value in class \" + HELPER;\n+\n+    \/\/ warning line 2 depends on the method\n+    private static final String WARNING_MUTATED =\n+            \" has been mutated reflectively by class \" + HELPER + \" in unnamed module\";\n+    private static final String WARNING_UNREFLECTED =\n+            \" has been unreflected for mutation by class \" + HELPER + \" in unnamed module\";\n+\n+    \/**\n+     * Test executable JAR with code that uses Field.set to mutate a final field.\n+     * A warning should be printed.\n+     *\/\n+    @Test\n+    void testFieldSetExpectingWarning() throws Exception {\n+        String jarFile = createExecutableJar(Map.of());\n+        testExecutableJar(jarFile, \"testFieldSetInt\")\n+                .shouldContain(WARNING_LINE1)\n+                .shouldContain(WARNING_MUTATED)\n+                .shouldHaveExitValue(0);\n+    }\n+\n+    \/**\n+     * Test executable JAR with code that uses Lookup.unreflectSetter to get MH to a\n+     * final field. A warning should be printed.\n+     *\/\n+    @Test\n+    void testUnreflectExpectingWarning() throws Exception {\n+        String jarFile = createExecutableJar(Map.of());\n+        testExecutableJar(jarFile, \"testUnreflectSetter\")\n+                .shouldContain(WARNING_LINE1)\n+                .shouldContain(WARNING_UNREFLECTED)\n+                .shouldHaveExitValue(0);\n+    }\n+\n+    \/**\n+     * Test executable JAR with Enable-Final-Field-Mutation attribute and code that uses\n+     * Field.set to mutate a final field. No warning should be printed.\n+     *\/\n+    @Test\n+    void testFieldSetExpectingAllow() throws Exception {\n+        String jarFile = createExecutableJar(Map.of(\"Enable-Final-Field-Mutation\", \"ALL-UNNAMED\"));\n+        testExecutableJar(jarFile, \"testFieldSetInt\")\n+                .shouldNotContain(WARNING_LINE1)\n+                .shouldNotContain(WARNING_MUTATED)\n+                .shouldHaveExitValue(0);\n+    }\n+\n+    \/**\n+     * Test executable JAR with Enable-Final-Field-Mutation attribute and code that uses\n+     * Lookup.unreflectSetter to get MH to a final field. No warning should be printed.\n+     *\/\n+    @Test\n+    void testUnreflectExpectingAllow() throws Exception {\n+        String jarFile = createExecutableJar(Map.of(\"Enable-Final-Field-Mutation\", \"ALL-UNNAMED\"));\n+        testExecutableJar(jarFile, \"testUnreflectSetter\")\n+                .shouldNotContain(WARNING_LINE1)\n+                .shouldNotContain(WARNING_UNREFLECTED)\n+                .shouldHaveExitValue(0);\n+    }\n+\n+    \/**\n+     * Test executable JAR with Enable-Final-Field-Mutation attribute and code that uses\n+     * Field.set to mutate a final field of class in a named module. The package is opened\n+     * with --add-open.\n+     *\/\n+    @Test\n+    void testFieldSetWithAddOpens1() throws Exception {\n+        String jarFile = createExecutableJar(Map.of(\n+                \"Enable-Final-Field-Mutation\", \"ALL-UNNAMED\"));\n+        testExecutableJar(jarFile, \"testFieldInNamedModule\",\n+                \"--illegal-final-field-mutation=deny\",\n+                \"--module-path\", modulePath(),\n+                \"--add-modules\", \"m\",\n+                \"--add-opens\", \"m\/p=ALL-UNNAMED\")\n+                .shouldHaveExitValue(0);\n+    }\n+\n+    \/**\n+     * Test executable JAR with Enable-Final-Field-Mutation attribute and code that uses\n+     * Field.set to mutate a final field of class in a named module. The package is opened\n+     * with with the Add-Opens attribute.\n+     *\/\n+    @Test\n+    void testFieldSetWithAddOpens2() throws Exception {\n+        String jarFile = createExecutableJar(Map.of(\n+                \"Enable-Final-Field-Mutation\", \"ALL-UNNAMED\",\n+                \"Add-Opens\", \"m\/p\"));\n+        testExecutableJar(jarFile, \"testFieldInNamedModule\",\n+                \"--illegal-final-field-mutation=deny\",\n+                \"--module-path\", modulePath(),\n+                \"--add-modules\", \"m\")\n+                .shouldHaveExitValue(0);\n+    }\n+\n+    \/**\n+     * Test executable JAR with Enable-Final-Field-Mutation with that a value that is not\n+     * \"ALL-UNNAMED\".\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"java.base\", \"BadValue\", \" \", \"\"})\n+    void testFinalFieldMutationBadValue(String value) throws Exception {\n+        String jarFile = createExecutableJar(Map.of(\"Enable-Final-Field-Mutation\", value));\n+        testExecutableJar(jarFile, \"testFieldSetInt\")\n+                 .shouldContain(\"Error: illegal value \\\"\" + value + \"\\\" for Enable-Final-Field-Mutation\" +\n+                         \" manifest attribute. Only ALL-UNNAMED is allowed\")\n+                 .shouldNotHaveExitValue(0);\n+     }\n+\n+    \/**\n+     * Launch ExecutableJarTestHelper with the given arguments and VM options.\n+     *\/\n+    private OutputAnalyzer test(String action, String... vmopts) throws Exception {\n+        Stream<String> s1 = Stream.of(vmopts);\n+        Stream<String> s2 = Stream.of(\"ExecutableJarTestHelper\", action);\n+        String[] opts = Stream.concat(s1, s2).toArray(String[]::new);\n+        var outputAnalyzer = ProcessTools\n+                .executeTestJava(opts)\n+                .outputTo(System.err)\n+                .errorTo(System.err);\n+        return outputAnalyzer;\n+    }\n+\n+    \/**\n+     * Launch ExecutableJarTestHelper with the given arguments and VM options.\n+     *\/\n+    private OutputAnalyzer testExecutableJar(String jarFile,\n+                                             String action,\n+                                             String... vmopts) throws Exception {\n+        Stream<String> s1 = Stream.of(vmopts);\n+        Stream<String> s2 = Stream.of(\"-jar\", jarFile, action);\n+        String[] opts = Stream.concat(s1, s2).toArray(String[]::new);\n+        var outputAnalyzer = ProcessTools\n+                .executeTestJava(opts)\n+                .outputTo(System.err)\n+                .errorTo(System.err);\n+        return outputAnalyzer;\n+    }\n+\n+    \/**\n+     * Creates executable JAR named helper.jar with ExecutableJarTestHelper* classes.\n+     *\/\n+    private String createExecutableJar(Map<String, String> map) throws Exception {\n+        Path jarFile = Path.of(\"helper.jar\");\n+        var man = new Manifest();\n+        Attributes attrs = man.getMainAttributes();\n+        attrs.put(Attributes.Name.MANIFEST_VERSION, \"1.0\");\n+        attrs.put(Attributes.Name.MAIN_CLASS, \"ExecutableJarTestHelper\");\n+        map.entrySet().forEach(e -> {\n+            var name = new Attributes.Name(e.getKey());\n+            attrs.put(name, e.getValue());\n+        });\n+        Path dir = Path.of(System.getProperty(\"test.classes\"));\n+        try (Stream<Path> stream = Files.list(dir)) {\n+            Path[] files = Files.list(dir).filter(p -> {\n+                        String fn = p.getFileName().toString();\n+                        return fn.startsWith(\"ExecutableJarTestHelper\") && fn.endsWith(\".class\");\n+                    })\n+                    .toArray(Path[]::new);\n+            JarUtils.createJarFile(jarFile, man, dir, files);\n+        }\n+        return jarFile.toString();\n+    }\n+\n+    \/**\n+     * Return the module path for the modules used by this test.\n+     *\/\n+    private String modulePath() {\n+        return Path.of(System.getProperty(\"test.classes\"), \"modules\").toString();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/jar\/ExecutableJarTest.java","additions":227,"deletions":0,"binary":false,"changes":227,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.invoke.MethodHandles;\n+\n+public class ExecutableJarTestHelper {\n+\n+    \/**\n+     * The argument is a list of names of no-arg static methods in this class to invoke.\n+     * The names are separated with a '+'.\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+        String[] methodNames = args.length > 0 ? args[0].split(\"\\\\+\") : new String[0];\n+        for (String methodName : methodNames) {\n+            Method m = ExecutableJarTestHelper.class.getDeclaredMethod(methodName);\n+            m.invoke(null);\n+        }\n+    }\n+\n+    \/**\n+     * Uses Field.set to mutate a final field.\n+     *\/\n+    static void testFieldSetInt() throws Exception {\n+        class C {\n+            final int value;\n+            C(int value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+        f.setAccessible(true);\n+        var obj = new C(100);\n+        f.setInt(obj, 200);\n+        if (obj.value != 200) {\n+            throw new RuntimeException(\"Unexpected value: \" + obj.value);\n+        }\n+    }\n+\n+    \/**\n+     * Uses Lookup.unreflectSetter to get a method handle to set a final field.\n+     *\/\n+    static void testUnreflectSetter() throws Throwable {\n+        class C {\n+            final int value;\n+            C(int value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+        f.setAccessible(true);\n+        var obj = new C(100);\n+        MethodHandles.lookup().unreflectSetter(f).invoke(obj, 200);\n+        if (obj.value != 200) {\n+            throw new RuntimeException(\"Unexpected value: \" + obj.value);\n+        }\n+    }\n+\n+    \/**\n+     * Uses Field.set to mutate a final field of a class in a named module.\n+     *\/\n+    static void testFieldInNamedModule() throws Exception {\n+        Class<?> c = Class.forName(\"p.C\");\n+        if (!c.getModule().isNamed()) {\n+            throw new RuntimeException(c + \" is not in a named module\");\n+        }\n+        Object obj = c.getDeclaredConstructor(int.class).newInstance(100);\n+        Field f = c.getDeclaredField(\"value\");\n+        f.setAccessible(true);\n+        f.setInt(obj, 200);\n+        int newValue = f.getInt(obj);\n+        if (newValue != 200) {\n+            throw new RuntimeException(\"Unexpected value: \" + newValue);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/jar\/ExecutableJarTestHelper.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Module containing a class with a final field used by ExecutableJarTest.\n+ *\/\n+module m {\n+    exports p;\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/jar\/m\/module-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p;\n+\n+\/**\n+ * A class with a final field used by ExecutableJarTest.\n+ *\/\n+public class C {\n+    private final int value;\n+\n+    public C(int value) {\n+        this.value = value;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/jar\/m\/p\/C.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.util.concurrent.CountDownLatch;\n+\n+\/**\n+ * Launched by JNIAttachMutatorTest to test a JNI attached thread attempting to mutate\n+ * a final field.\n+ *\/\n+\n+public class JNIAttachMutator {\n+    private static final CountDownLatch finished = new CountDownLatch(1);\n+    private static volatile Object obj;\n+    private static volatile Throwable exc;\n+\n+    \/\/ public class, public final field\n+    public static class C1 {\n+        public final int value;\n+        C1(int value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    \/\/ public class, non-public final field\n+    public static class C2 {\n+        final int value;\n+        C2(int value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    \/\/ non-public class, public final field\n+    static class C3 {\n+        public final int value;\n+        C3(int value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    \/**\n+     * Usage: java JNIAttachMutator <classname> <true|false>\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+        String cn = args[0];\n+        boolean expectIAE = Boolean.parseBoolean(args[1]);\n+\n+        Class<?> clazz = Class.forName(args[0]);\n+        Constructor<?> ctor = clazz.getDeclaredConstructor(int.class);\n+        ctor.setAccessible(true);\n+        obj = ctor.newInstance(100);\n+\n+        \/\/ start native thread\n+        startThread();\n+\n+        \/\/ wait for native thread to finish\n+        finished.await();\n+\n+        if (expectIAE) {\n+            if (exc == null) {\n+                \/\/ IAE expected\n+                throw new RuntimeException(\"IllegalAccessException not thrown\");\n+            } else if (!(exc instanceof IllegalAccessException)) {\n+                \/\/ unexpected exception\n+                throw new RuntimeException(exc);\n+            }\n+        } else if (exc != null) {\n+            \/\/ no exception expected\n+            throw new RuntimeException(exc);\n+        }\n+    }\n+\n+    \/**\n+     * Invoked by JNI attached thread to get object.\n+     *\/\n+    static Object getObject() {\n+        return obj;\n+    }\n+\n+    \/**\n+     * Invoked by JNI attached thread to get Field object with accessible enabled.\n+     *\/\n+    static Field getField() throws NoSuchFieldException {\n+        Field f = obj.getClass().getDeclaredField(\"value\");\n+        f.setAccessible(true);\n+        return f;\n+    }\n+\n+    \/**\n+     * Invoked by JNI attached thread when finished.\n+     *\/\n+    static void finish(Throwable ex) {\n+        exc = ex;\n+        finished.countDown();\n+    }\n+\n+    private static native void startThread();\n+\n+    static {\n+        System.loadLibrary(\"JNIAttachMutator\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/jni\/JNIAttachMutator.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8353835\n+ * @summary Test native thread attaching to the VM with JNI AttachCurrentThread and directly\n+ *    invoking Field.set to set a final field\n+ * @library \/test\/lib\n+ * @build m\/*\n+ * @compile JNIAttachMutator.java\n+ * @run junit JNIAttachMutatorTest\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+class JNIAttachMutatorTest {\n+    private static String testClasses;\n+    private static String modulesDir;\n+    private static String javaLibraryPath;\n+\n+    @BeforeAll\n+    static void setup() {\n+        testClasses = System.getProperty(\"test.classes\");\n+        modulesDir = Path.of(testClasses, \"modules\").toString();\n+        javaLibraryPath = System.getProperty(\"java.library.path\");\n+    }\n+\n+    \/**\n+     * Final final mutation allowed. All final fields are public, in public classes,\n+     * and in packages exported to all modules.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"JNIAttachMutator$C1\",     \/\/ unnamed module\n+            \"p.C1\",                    \/\/ named module\n+    })\n+    void testAllowed(String cn) throws Exception {\n+        test(cn, false);\n+    }\n+\n+    \/**\n+     * Final final mutation not allowed.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \/\/ unnamed module\n+            \"JNIAttachMutator$C2\",      \/\/ public class, non-public final field\n+            \"JNIAttachMutator$C3\",      \/\/ non-public class, public final field\n+\n+            \/\/ named module\n+            \"p.C2\",                     \/\/ public class, non-public final field, exported package\n+            \"p.C3\",                     \/\/ non-public class, public final field, exported package\n+            \"q.C\"                       \/\/ public class, public final field, package not exported\n+    })\n+    void testDenied(String cn) throws Exception {\n+        test(cn, true);\n+    }\n+\n+    \/**\n+     * public final field, public class, package exported to some modules.\n+     *\/\n+    @Test\n+    void testQualifiedExports() throws Exception {\n+        test(\"q.C\", true, \"--add-exports\", \"m\/q=ALL-UNNAMED\");\n+    }\n+\n+    \/**\n+     * Launches JNIAttachMutator to test a JNI attached thread mutating a final field.\n+     * @param className the class with the field final\n+     * @param expectIAE if IllegalAccessException is expected\n+     * @param extraOps additional VM options\n+     *\/\n+    private void test(String className, boolean expectIAE, String... extraOps) throws Exception {\n+        Stream<String> s1 = Stream.of(extraOps);\n+        Stream<String> s2 = Stream.of(\n+                \"-cp\", testClasses,\n+                \"-Djava.library.path=\" + javaLibraryPath,\n+                \"--module-path\", modulesDir,\n+                \"--add-modules\", \"m\",\n+                \"--add-opens\", \"m\/p=ALL-UNNAMED\",    \/\/ allow setAccessible\n+                \"--add-opens\", \"m\/q=ALL-UNNAMED\",\n+                \"--enable-native-access=ALL-UNNAMED\",\n+                \"--enable-final-field-mutation=ALL-UNNAMED\",\n+                \"--illegal-final-field-mutation=deny\",\n+                \"JNIAttachMutator\",\n+                className,\n+                expectIAE ? \"true\" : \"false\");\n+        String[] opts = Stream.concat(s1, s2).toArray(String[]::new);\n+        OutputAnalyzer outputAnalyzer = ProcessTools\n+                .executeTestJava(opts)\n+                .outputTo(System.out)\n+                .errorTo(System.out);\n+        outputAnalyzer.shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/jni\/JNIAttachMutatorTest.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <stdio.h>\n+#ifdef _WIN32\n+#include <windows.h>\n+#else\n+#include <pthread.h>\n+#endif\n+#include \"jni.h\"\n+\n+#define STACK_SIZE 0x100000\n+\n+static JavaVM *vm;\n+\n+JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *jvm, void* reserved) {\n+    vm = jvm;\n+    return JNI_VERSION_1_8;\n+}\n+\n+\/**\n+ * Invokes JNIAttachMutator.getObject()\n+ *\/\n+jobject getObject(JNIEnv* env) {\n+    jclass clazz = (*env)->FindClass(env, \"JNIAttachMutator\");\n+    if (clazz == NULL) {\n+        fprintf(stderr, \"FindClass failed\\n\");\n+        return NULL;\n+    }\n+    jmethodID mid = (*env)->GetStaticMethodID(env, clazz, \"getObject\", \"()Ljava\/lang\/Object;\");\n+    if (mid == NULL) {\n+        fprintf(stderr, \"GetMethodID for getObject failed\\n\");\n+        return NULL;\n+    }\n+    jobject obj = (*env)->CallStaticObjectMethod(env, clazz, mid);\n+    if (obj == NULL) {\n+        fprintf(stderr, \"CallObjectMethod to getObject failed\\n\");\n+        return NULL;\n+    }\n+    return obj;\n+}\n+\n+\/**\n+ * Invokes JNIAttachMutator.getField()\n+ *\/\n+jobject getField(JNIEnv* env) {\n+    jclass clazz = (*env)->FindClass(env, \"JNIAttachMutator\");\n+    if (clazz == NULL) {\n+        fprintf(stderr, \"FindClass failed\\n\");\n+        return NULL;\n+    }\n+    jmethodID mid = (*env)->GetStaticMethodID(env, clazz, \"getField\", \"()Ljava\/lang\/reflect\/Field;\");\n+    if (mid == NULL) {\n+        fprintf(stderr, \"GetStaticMethodID for getField failed\\n\");\n+        return NULL;\n+    }\n+    jobject obj = (*env)->CallStaticObjectMethod(env, clazz, mid);\n+    if (obj == NULL) {\n+        fprintf(stderr, \"CallObjectMethod to getField failed\\n\");\n+        return NULL;\n+    }\n+    return obj;\n+}\n+\n+\/**\n+ * Invokes Field.setInt\n+ *\/\n+jboolean setInt(JNIEnv* env, jobject obj, jobject fieldObj, jint newValue) {\n+    jclass fieldClass = (*env)->GetObjectClass(env, fieldObj);\n+    jmethodID mid = (*env)->GetMethodID(env, fieldClass, \"setInt\", \"(Ljava\/lang\/Object;I)V\");\n+    if (mid == NULL) {\n+        fprintf(stderr, \"GetMethodID for Field.setInt failed\\n\");\n+        return JNI_FALSE;\n+    }\n+    (*env)->CallObjectMethod(env, fieldObj, mid, obj, newValue);\n+    return JNI_TRUE;\n+}\n+\n+\/**\n+ * Invokes JNIAttachMutator.finish\n+ *\/\n+void finish(JNIEnv* env, jthrowable ex) {\n+    jclass clazz = (*env)->FindClass(env, \"JNIAttachMutator\");\n+    if (clazz == NULL) {\n+        fprintf(stderr, \"FindClass failed\\n\");\n+        return;\n+    }\n+\n+    \/\/ invoke finish\n+    jmethodID mid = (*env)->GetStaticMethodID(env, clazz, \"finish\", \"(Ljava\/lang\/Throwable;)V\");\n+    if (mid == NULL) {\n+        fprintf(stderr, \"GetStaticMethodID failed\\n\");\n+        return;\n+    }\n+    (*env)->CallStaticVoidMethod(env, clazz, mid, ex);\n+    if ((*env)->ExceptionOccurred(env)) {\n+        fprintf(stderr, \"CallStaticVoidMethod failed\\n\");\n+    }\n+}\n+\n+\/**\n+ * Attach the current thread with JNI AttachCurrentThread.\n+ *\/\n+void* thread_main(void* arg) {\n+    JNIEnv *env;\n+    jint res;\n+    jthrowable ex;\n+\n+    res = (*vm)->AttachCurrentThread(vm, (void **) &env, NULL);\n+    if (res != JNI_OK) {\n+        fprintf(stderr, \"AttachCurrentThread failed: %d\\n\", res);\n+        return NULL;\n+    }\n+\n+    \/\/ invoke JNIAttachMutator.getObject to get the object to test\n+    jobject obj = getObject(env);\n+    if (obj == NULL) {\n+        goto done;\n+    }\n+\n+    \/\/ invoke JNIAttachMutator.getField to get the Field object with access enabled\n+    jobject fieldObj = getField(env);\n+    if (fieldObj == NULL) {\n+        goto done;\n+    }\n+\n+    \/\/ invoke Field.setInt to attempt to set the value to 200\n+    if (!setInt(env, obj, fieldObj, 200)) {\n+        goto done;\n+    }\n+\n+  done:\n+\n+    ex = (*env)->ExceptionOccurred(env);\n+    if (ex != NULL) {\n+        (*env)->ExceptionDescribe(env);\n+        (*env)->ExceptionClear(env);\n+    }\n+    finish(env, ex);\n+\n+    res = (*vm)->DetachCurrentThread(vm);\n+    if (res != JNI_OK) {\n+        fprintf(stderr, \"DetachCurrentThread failed: %d\\n\", res);\n+    }\n+\n+    return NULL;\n+}\n+\n+#ifdef _WIN32\n+static DWORD WINAPI win32_thread_main(void* p) {\n+    thread_main(p);\n+    return 0;\n+}\n+#endif\n+\n+JNIEXPORT void JNICALL Java_JNIAttachMutator_startThread(JNIEnv *env, jclass clazz) {\n+#ifdef _WIN32\n+    HANDLE handle = CreateThread(NULL, STACK_SIZE, win32_thread_main, NULL, 0, NULL);\n+    if (handle == NULL) {\n+        fprintf(stderr, \"CreateThread failed: %d\\n\", GetLastError());\n+    }\n+#else\n+    pthread_t tid;\n+    pthread_attr_t attr;\n+\n+    pthread_attr_init(&attr);\n+    pthread_attr_setstacksize(&attr, STACK_SIZE);\n+    int res = pthread_create(&tid, &attr, thread_main, NULL);\n+    if (res != 0) {\n+        fprintf(stderr, \"pthread_create failed: %d\\n\", res);\n+    }\n+#endif\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/jni\/libJNIAttachMutator.c","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Module containing classes with final fields.\n+ *\/\n+module m {\n+    exports p;\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/jni\/m\/module-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p;\n+\n+\/**\n+ * public class, public final field.\n+ *\/\n+public class C1 {\n+    public final int value;\n+\n+    C1(int value) {\n+        this.value = value;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/jni\/m\/p\/C1.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p;\n+\n+\/**\n+ * public class, non-public final field.\n+ *\/\n+public class C2 {\n+    final int value;\n+\n+    C2(int value) {\n+        this.value = value;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/jni\/m\/p\/C2.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p;\n+\n+\/**\n+ * non-public class, public final field.\n+ *\/\n+class C3 {\n+    public final int value;\n+\n+    C3(int value) {\n+        this.value = value;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/jni\/m\/p\/C3.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package q;\n+\n+\/**\n+ * public class, public final field.\n+ *\/\n+public class C {\n+    public final int value;\n+\n+    public C(int value) {\n+        this.value = value;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/jni\/m\/q\/C.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8353835\n+ * @summary Test mutating final field in m1 from m1, m2 and m3. The package with the final\n+ *     field is open to m2 and not open to m3.\n+ * @build m1\/* m2\/* m3\/*\n+ * @run junit\/othervm -DallowedToMutate=m1,m2 m1\/p1.TestMain\n+ * @run junit\/othervm --illegal-final-field-mutation=allow -DallowedToMutate=m1,m2 m1\/p1.TestMain\n+ * @run junit\/othervm --illegal-final-field-mutation=deny --enable-final-field-mutation=m1 -DallowedToMutate=m1 m1\/p1.TestMain\n+ * @run junit\/othervm --illegal-final-field-mutation=deny --enable-final-field-mutation=m2 -DallowedToMutate=m2 m1\/p1.TestMain\n+ * @run junit\/othervm --illegal-final-field-mutation=deny --enable-final-field-mutation=m1,m2,m3 -DallowedToMutate=m1,m2 m1\/p1.TestMain\n+ * @run junit\/othervm --illegal-final-field-mutation=deny --enable-final-field-mutation=m1,m2,m3 --add-opens m1\/p1=m3 -DallowedToMutate=m1,m2,m3 m1\/p1.TestMain\n+ *\/\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/modules\/Driver.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+@SuppressWarnings(\"module\")\n+module m1 {\n+    requires org.junit.platform.console.standalone;\n+    opens p1 to org.junit.platform.console.standalone, m2;\n+\n+    exports p1;\n+    uses p1.Mutator;\n+    provides p1.Mutator with p1.M1Mutator;\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/modules\/m1\/module-info.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package p1;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Field;\n+\n+public class M1Mutator implements p1.Mutator {\n+\n+    @Override\n+    public void set(Field f, Object obj, Object value) throws IllegalAccessException {\n+        f.set(obj, value);\n+    }\n+\n+    @Override\n+    public void setBoolean(Field f, Object obj, boolean value) throws IllegalAccessException {\n+        f.setBoolean(obj, value);\n+    }\n+\n+    @Override\n+    public void setByte(Field f, Object obj, byte value) throws IllegalAccessException {\n+        f.setByte(obj, value);\n+    }\n+\n+    @Override\n+    public void setChar(Field f, Object obj, char value) throws IllegalAccessException {\n+        f.setChar(obj, value);\n+    }\n+\n+    @Override\n+    public void setShort(Field f, Object obj, short value) throws IllegalAccessException {\n+        f.setShort(obj, value);\n+    }\n+\n+    @Override\n+    public void setInt(Field f, Object obj, int value) throws IllegalAccessException {\n+        f.setInt(obj, value);\n+    }\n+\n+    @Override\n+    public void setLong(Field f, Object obj, long value) throws IllegalAccessException {\n+        f.setLong(obj, value);\n+    }\n+\n+    @Override\n+    public void setFloat(Field f, Object obj, float value) throws IllegalAccessException {\n+        f.setFloat(obj, value);\n+    }\n+\n+    @Override\n+    public void setDouble(Field f, Object obj, double value) throws IllegalAccessException {\n+        f.setDouble(obj, value);\n+    }\n+\n+    @Override\n+    public MethodHandle unreflectSetter(Field f) throws IllegalAccessException {\n+        return MethodHandles.lookup().unreflectSetter(f);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/modules\/m1\/p1\/M1Mutator.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package p1;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.reflect.Field;\n+\n+public interface Mutator {\n+    void set(Field f, Object obj, Object value) throws IllegalAccessException;\n+    void setBoolean(Field f, Object obj, boolean value) throws IllegalAccessException;\n+    void setByte(Field f, Object obj, byte value) throws IllegalAccessException;\n+    void setChar(Field f, Object obj, char value) throws IllegalAccessException;\n+    void setShort(Field f, Object obj, short value) throws IllegalAccessException;\n+    void setInt(Field f, Object obj, int value) throws IllegalAccessException;\n+    void setLong(Field f, Object obj, long value) throws IllegalAccessException;\n+    void setFloat(Field f, Object obj, float value) throws IllegalAccessException;\n+    void setDouble(Field f, Object obj, double value) throws IllegalAccessException;\n+    MethodHandle unreflectSetter(Field f) throws IllegalAccessException;\n+\n+    static Mutator throwing() {\n+        return new Mutator() {\n+            @Override\n+            public void set(Field f, Object obj, Object value) throws IllegalAccessException {\n+                throw new IllegalAccessException();\n+            }\n+            @Override\n+            public void setBoolean(Field f, Object obj, boolean value) throws IllegalAccessException {\n+                throw new IllegalAccessException();\n+            }\n+            @Override\n+            public void setByte(Field f, Object obj, byte value) throws IllegalAccessException {\n+                throw new IllegalAccessException();\n+            }\n+            @Override\n+            public void setChar(Field f, Object obj, char value) throws IllegalAccessException {\n+                throw new IllegalAccessException();\n+            }\n+            @Override\n+            public void setShort(Field f, Object obj, short value) throws IllegalAccessException {\n+                throw new IllegalAccessException();\n+            }\n+            @Override\n+            public void setInt(Field f, Object obj, int value) throws IllegalAccessException {\n+                throw new IllegalAccessException();\n+            }\n+            @Override\n+            public void setLong(Field f, Object obj, long value) throws IllegalAccessException {\n+                throw new IllegalAccessException();\n+            }\n+            @Override\n+            public void setFloat(Field f, Object obj, float value) throws IllegalAccessException {\n+                throw new IllegalAccessException();\n+            }\n+            @Override\n+            public void setDouble(Field f, Object obj, double value) throws IllegalAccessException {\n+                throw new IllegalAccessException();\n+            }\n+            @Override\n+            public MethodHandle unreflectSetter(Field f) throws IllegalAccessException {\n+                throw new IllegalAccessException();\n+            }\n+            @Override\n+            public String toString() {\n+                return \"<throwing>\";\n+            }\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/modules\/m1\/p1\/Mutator.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,538 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package p1;\n+\n+import java.lang.module.ModuleDescriptor;\n+import java.lang.reflect.Field;\n+import java.util.Set;\n+import java.util.ServiceLoader;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/**\n+ * Test mutating final fields from different modules.\n+ *\/\n+class TestMain {\n+    \/\/ the names of the modules that are allowed to mutate finals in m1\/p1\n+    static Set<String> allowedToMutate;\n+\n+    \/\/ the list of all mutators\n+    static List<ServiceLoader.Provider<Mutator>> providers;\n+\n+    \/\/ the module and package name of this class\n+    static Module mainModule;\n+    static String mainPackageName;\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        String s = System.getProperty(\"allowedToMutate\");\n+        String[] names = s.split(\",\");\n+        allowedToMutate = Stream.of(names).collect(Collectors.toSet());\n+        providers = ServiceLoader.load(Mutator.class).stream().toList();\n+        mainModule = TestMain.class.getModule();\n+        mainPackageName = TestMain.class.getPackageName();\n+    }\n+\n+    \/**\n+     * Returns a stream of Mutators that are allowed to mutate final fields in m1\/p1.\n+     *\/\n+    static Stream<Mutator> mutators() {\n+        return providers.stream()\n+                .filter(p -> allowedToMutate.contains(p.type().getModule().getName()))\n+                .map(ServiceLoader.Provider::get);\n+    }\n+\n+    \/**\n+     * Returns a stream of Mutators that can not mutate final fields in m1\/p1.\n+     *\/\n+    static Stream<Mutator> deniedMutators() {\n+        List<Mutator> mutators = providers.stream()\n+                .filter(p -> !allowedToMutate.contains(p.type().getModule().getName()))\n+                .map(ServiceLoader.Provider::get)\n+                .toList();\n+        if (mutators.isEmpty()) {\n+            \/\/ can't return an empty stream at this time\n+            return Stream.of(Mutator.throwing());\n+        } else {\n+            return mutators.stream();\n+        }\n+    }\n+\n+    @ParameterizedTest()\n+    @MethodSource(\"mutators\")\n+    void testFieldSet(Mutator mutator) throws Exception {\n+        class C {\n+            final Object value;\n+            C(Object value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+\n+        Object oldValue = new Object();\n+        Object newValue = new Object();\n+        var obj = new C(oldValue);\n+\n+        f.setAccessible(false);\n+        assertThrows(IllegalAccessException.class, () -> mutator.set(f, obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+\n+        f.setAccessible(true);\n+        mutator.set(f, obj, newValue);\n+        assertTrue(obj.value == newValue);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"mutators\")\n+    void testFieldSetBoolean(Mutator mutator) throws Exception {\n+        class C {\n+            final boolean value;\n+            C(boolean value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+\n+        boolean oldValue = false;\n+        boolean newValue = true;\n+        var obj = new C(oldValue);\n+\n+        f.setAccessible(false);\n+        assertThrows(IllegalAccessException.class, () -> mutator.setBoolean(f, obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+\n+        f.setAccessible(true);\n+        mutator.setBoolean(f, obj, newValue);\n+        assertTrue(obj.value == newValue);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"mutators\")\n+    void testFieldSetByte(Mutator mutator) throws Exception {\n+        class C {\n+            final byte value;\n+            C(byte value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+\n+        byte oldValue = (byte) 1;\n+        byte newValue = (byte) 2;\n+        var obj = new C(oldValue);\n+\n+        f.setAccessible(false);\n+        assertThrows(IllegalAccessException.class, () -> mutator.setByte(f, obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+\n+        f.setAccessible(true);\n+        mutator.setByte(f, obj, newValue);\n+        assertTrue(obj.value == newValue);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"mutators\")\n+    void testFieldSetChar(Mutator mutator) throws Exception {\n+        class C {\n+            final char value;\n+            C(char value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+\n+        char oldValue = 'A';\n+        char newValue = 'B';\n+        var obj = new C(oldValue);\n+\n+        f.setAccessible(false);\n+        assertThrows(IllegalAccessException.class, () -> mutator.setChar(f, obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+\n+        f.setAccessible(true);\n+        mutator.setChar(f, obj, newValue);\n+        assertTrue(obj.value == newValue);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"mutators\")\n+    void testFieldSetShort(Mutator mutator) throws Exception {\n+        class C {\n+            final short value;\n+            C(short value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+\n+        short oldValue = (short) 1;\n+        short newValue = (short) 2;\n+        var obj = new C(oldValue);\n+\n+        f.setAccessible(false);\n+        assertThrows(IllegalAccessException.class, () -> mutator.setShort(f, obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+\n+        f.setAccessible(true);\n+        mutator.setShort(f, obj, newValue);\n+        assertTrue(obj.value == newValue);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"mutators\")\n+    void testFieldSetInt(Mutator mutator) throws Exception {\n+        class C {\n+            final int value;\n+            C(int value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+\n+        int oldValue = 1;\n+        int newValue = 2;\n+        var obj = new C(oldValue);\n+\n+        f.setAccessible(false);\n+        assertThrows(IllegalAccessException.class, () -> mutator.setInt(f, obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+\n+        f.setAccessible(true);\n+        mutator.setInt(f, obj, newValue);\n+        assertTrue(obj.value == newValue);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"mutators\")\n+    void testFieldSetLong(Mutator mutator) throws Exception {\n+        class C {\n+            final long value;\n+            C(long value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+\n+        long oldValue = 1L;\n+        long newValue = 2L;\n+        var obj = new C(oldValue);\n+\n+        f.setAccessible(false);\n+        assertThrows(IllegalAccessException.class, () -> mutator.setLong(f, obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+\n+        f.setAccessible(true);\n+        mutator.setLong(f, obj, newValue);\n+        assertTrue(obj.value == newValue);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"mutators\")\n+    void testFieldSetFloat(Mutator mutator) throws Exception {\n+        class C {\n+            final float value;\n+            C(float value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+\n+        float oldValue = 1.0f;\n+        float newValue = 2.0f;\n+        var obj = new C(oldValue);\n+\n+        f.setAccessible(false);\n+        assertThrows(IllegalAccessException.class, () -> mutator.setFloat(f, obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+\n+        f.setAccessible(true);\n+        mutator.setFloat(f, obj, newValue);\n+        assertTrue(obj.value == newValue);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"mutators\")\n+    void testFieldSetDouble(Mutator mutator) throws Exception {\n+        class C {\n+            final double value;\n+            C(double value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+\n+        double oldValue = 1.0d;\n+        double newValue = 2.0d;\n+        var obj = new C(oldValue);\n+\n+        f.setAccessible(false);\n+        assertThrows(IllegalAccessException.class, () -> mutator.setDouble(f, obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+\n+        f.setAccessible(true);\n+        mutator.setDouble(f, obj, newValue);\n+        assertTrue(obj.value == newValue);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"mutators\")\n+    void testUnreflectSetter(Mutator mutator) throws Throwable {\n+        class C {\n+            final int value;\n+            C(int value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+\n+        int oldValue = 1;\n+        int newValue = 2;\n+        var obj = new C(oldValue);\n+\n+        f.setAccessible(false);\n+        assertThrows(IllegalAccessException.class, () -> mutator.unreflectSetter(f));\n+\n+        f.setAccessible(true);\n+        mutator.unreflectSetter(f).invokeExact(obj, newValue);\n+        assertTrue(obj.value == newValue);\n+    }\n+\n+\n+    @ParameterizedTest\n+    @MethodSource(\"deniedMutators\")\n+    void testFieldSetThrows(Mutator mutator) throws Exception {\n+        class C {\n+            final Object value;\n+            C(Object value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+        f.setAccessible(true);\n+\n+        Object oldValue = new Object();\n+        Object newValue = new Object();\n+        var obj = new C(oldValue);\n+        assertThrows(IllegalAccessException.class, () -> mutator.set(f, obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+\n+        \/\/ open package to mutator module, should have no effect on set method\n+        mainModule.addOpens(mainPackageName, mutator.getClass().getModule());\n+        assertThrows(IllegalAccessException.class, () -> mutator.set(f, obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"deniedMutators\")\n+    void testFieldSetByteThrows(Mutator mutator) throws Exception {\n+        class C {\n+            final byte value;\n+            C(byte value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+        f.setAccessible(true);\n+\n+        byte oldValue = (byte) 1;\n+        byte newValue = (byte) 2;\n+        var obj = new C(oldValue);\n+        assertThrows(IllegalAccessException.class, () -> mutator.setByte(f, obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+\n+        \/\/ open package to mutator module, should have no effect on set method\n+        mainModule.addOpens(mainPackageName, mutator.getClass().getModule());\n+        assertThrows(IllegalAccessException.class, () -> mutator.setByte(f, obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"deniedMutators\")\n+    void testFieldSetCharThrows(Mutator mutator) throws Exception {\n+        class C {\n+            final char value;\n+            C(char value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+        f.setAccessible(true);\n+\n+        char oldValue = 'A';\n+        char newValue = 'B';\n+        var obj = new C(oldValue);\n+        assertThrows(IllegalAccessException.class, () -> mutator.setChar(f, obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+\n+        \/\/ open package to mutator module, should have no effect on set method\n+        mainModule.addOpens(mainPackageName, mutator.getClass().getModule());\n+        assertThrows(IllegalAccessException.class, () -> mutator.setChar(f, obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"deniedMutators\")\n+    void testFieldSetShortThrows(Mutator mutator) throws Exception {\n+        class C {\n+            final short value;\n+            C(short value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+        f.setAccessible(true);\n+\n+        short oldValue = (short) 1;\n+        short newValue = (short) 2;\n+        var obj = new C(oldValue);\n+        assertThrows(IllegalAccessException.class, () -> mutator.setShort(f, obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+\n+        \/\/ open package to mutator module, should have no effect on set method\n+        mainModule.addOpens(mainPackageName, mutator.getClass().getModule());\n+        assertThrows(IllegalAccessException.class, () -> mutator.setShort(f, obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"deniedMutators\")\n+    void testFieldSetIntThrows(Mutator mutator) throws Exception {\n+        class C {\n+            final int value;\n+            C(int value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+        f.setAccessible(true);\n+\n+        int oldValue = 1;\n+        int newValue = 2;\n+        var obj = new C(oldValue);\n+        assertThrows(IllegalAccessException.class, () -> mutator.setInt(f, obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+\n+        \/\/ open package to mutator module, should have no effect on set method\n+        mainModule.addOpens(mainPackageName, mutator.getClass().getModule());\n+        assertThrows(IllegalAccessException.class, () -> mutator.setInt(f, obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"deniedMutators\")\n+    void testFieldSetLongThrows(Mutator mutator) throws Exception {\n+        class C {\n+            final long value;\n+            C(long value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+        f.setAccessible(true);\n+\n+        long oldValue = 1;\n+        long newValue = 2;\n+        var obj = new C(oldValue);\n+        assertThrows(IllegalAccessException.class, () -> mutator.setLong(f, obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+\n+        \/\/ open package to mutator module, should have no effect on set method\n+        mainModule.addOpens(mainPackageName, mutator.getClass().getModule());\n+        assertThrows(IllegalAccessException.class, () -> mutator.setLong(f, obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"deniedMutators\")\n+    void testFieldSetFloatThrows(Mutator mutator) throws Exception {\n+        class C {\n+            final float value;\n+            C(float value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+        f.setAccessible(true);\n+\n+        float oldValue = 1.0f;\n+        float newValue = 2.0f;\n+        var obj = new C(oldValue);\n+        assertThrows(IllegalAccessException.class, () -> mutator.setFloat(f, obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+\n+        \/\/ open package to mutator module, should have no effect on set method\n+        mainModule.addOpens(mainPackageName, mutator.getClass().getModule());\n+        assertThrows(IllegalAccessException.class, () -> mutator.setFloat(f, obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"deniedMutators\")\n+    void testFieldSetDoubleThrows(Mutator mutator) throws Exception {\n+        class C {\n+            final double value;\n+            C(double value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+        f.setAccessible(true);\n+\n+        double oldValue = 1.0d;\n+        double newValue = 2.0d;\n+        var obj = new C(oldValue);\n+        assertThrows(IllegalAccessException.class, () -> mutator.setDouble(f, obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+\n+        \/\/ open package to mutator module, should have no effect on set method\n+        mainModule.addOpens(mainPackageName, mutator.getClass().getModule());\n+        assertThrows(IllegalAccessException.class, () -> mutator.setDouble(f, obj, newValue));\n+        assertTrue(obj.value == oldValue);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"deniedMutators\")\n+    void testUnreflectSetterThrows(Mutator mutator) throws Exception {\n+        class C {\n+            final int value;\n+            C(int value) {\n+                this.value = value;\n+            }\n+        }\n+        Field f = C.class.getDeclaredField(\"value\");\n+        f.setAccessible(true);\n+\n+        assertThrows(IllegalAccessException.class, () -> mutator.unreflectSetter(f));\n+\n+        \/\/ open package to mutator module, should have no effect on set method\n+        mainModule.addOpens(mainPackageName, mutator.getClass().getModule());\n+        assertThrows(IllegalAccessException.class, () -> mutator.unreflectSetter(f));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/modules\/m1\/p1\/TestMain.java","additions":538,"deletions":0,"binary":false,"changes":538,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+@SuppressWarnings(\"module\")\n+module m2 {\n+    requires m1;\n+    provides p1.Mutator with p2.M2Mutator;\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/modules\/m2\/module-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package p2;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Field;\n+\n+public class M2Mutator implements p1.Mutator {\n+\n+    @Override\n+    public void set(Field f, Object obj, Object value) throws IllegalAccessException {\n+        f.set(obj, value);\n+    }\n+\n+    @Override\n+    public void setBoolean(Field f, Object obj, boolean value) throws IllegalAccessException {\n+        f.setBoolean(obj, value);\n+    }\n+\n+    @Override\n+    public void setByte(Field f, Object obj, byte value) throws IllegalAccessException {\n+        f.setByte(obj, value);\n+    }\n+\n+    @Override\n+    public void setChar(Field f, Object obj, char value) throws IllegalAccessException {\n+        f.setChar(obj, value);\n+    }\n+\n+    @Override\n+    public void setShort(Field f, Object obj, short value) throws IllegalAccessException {\n+        f.setShort(obj, value);\n+    }\n+\n+    @Override\n+    public void setInt(Field f, Object obj, int value) throws IllegalAccessException {\n+        f.setInt(obj, value);\n+    }\n+\n+    @Override\n+    public void setLong(Field f, Object obj, long value) throws IllegalAccessException {\n+        f.setLong(obj, value);\n+    }\n+\n+    @Override\n+    public void setFloat(Field f, Object obj, float value) throws IllegalAccessException {\n+        f.setFloat(obj, value);\n+    }\n+\n+    @Override\n+    public void setDouble(Field f, Object obj, double value) throws IllegalAccessException {\n+        f.setDouble(obj, value);\n+    }\n+\n+    @Override\n+    public MethodHandle unreflectSetter(Field f) throws IllegalAccessException {\n+        return MethodHandles.lookup().unreflectSetter(f);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/modules\/m2\/p2\/M2Mutator.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+@SuppressWarnings(\"module\")\n+module m3 {\n+    requires m1;\n+    provides p1.Mutator with p3.M3Mutator;\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/modules\/m3\/module-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package p3;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Field;\n+\n+public class M3Mutator implements p1.Mutator {\n+\n+    @Override\n+    public void set(Field f, Object obj, Object value) throws IllegalAccessException {\n+        f.set(obj, value);\n+    }\n+\n+    @Override\n+    public void setBoolean(Field f, Object obj, boolean value) throws IllegalAccessException {\n+        f.setBoolean(obj, value);\n+    }\n+\n+    @Override\n+    public void setByte(Field f, Object obj, byte value) throws IllegalAccessException {\n+        f.setByte(obj, value);\n+    }\n+\n+    @Override\n+    public void setChar(Field f, Object obj, char value) throws IllegalAccessException {\n+        f.setChar(obj, value);\n+    }\n+\n+    @Override\n+    public void setShort(Field f, Object obj, short value) throws IllegalAccessException {\n+        f.setShort(obj, value);\n+    }\n+\n+    @Override\n+    public void setInt(Field f, Object obj, int value) throws IllegalAccessException {\n+        f.setInt(obj, value);\n+    }\n+\n+    @Override\n+    public void setLong(Field f, Object obj, long value) throws IllegalAccessException {\n+        f.setLong(obj, value);\n+    }\n+\n+    @Override\n+    public void setFloat(Field f, Object obj, float value) throws IllegalAccessException {\n+        f.setFloat(obj, value);\n+    }\n+\n+    @Override\n+    public void setDouble(Field f, Object obj, double value) throws IllegalAccessException {\n+        f.setDouble(obj, value);\n+    }\n+\n+    @Override\n+    public MethodHandle unreflectSetter(Field f) throws IllegalAccessException {\n+        return MethodHandles.lookup().unreflectSetter(f);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/modules\/m3\/p3\/M3Mutator.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * @run testng\/othervm NullAndEmptyKeysAndValues\n+ * @run testng\/othervm --enable-final-field-mutation=ALL-UNNAMED NullAndEmptyKeysAndValues\n","filename":"test\/jdk\/java\/util\/jar\/Attributes\/NullAndEmptyKeysAndValues.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run main\/othervm FileHandlerLongLimit\n+ * @run main\/othervm --enable-final-field-mutation=ALL-UNNAMED FileHandlerLongLimit\n","filename":"test\/jdk\/java\/util\/logging\/FileHandlerLongLimit.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -84,0 +84,4 @@\n+    \/\/ This event is tested in test\/jdk\/java\/lang\/reflect\/Field\/mutateFinals\/FinalFieldMutationEventTest.java\n+    private static final Set<String> coveredFinalFieldMutationEvents = Set.of(\n+        \"FinalFieldMutationEvent\");\n+\n@@ -131,0 +135,1 @@\n+        eventsNotCoveredByTest.removeAll(coveredFinalFieldMutationEvents);\n","filename":"test\/jdk\/jdk\/jfr\/event\/metadata\/TestLookForUntestedEvents.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main\/othervm CancelMultipart\n+ * @run main\/othervm --enable-final-field-mutation=ALL-UNNAMED CancelMultipart\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/CancelMultipart.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,2 @@\n- * @run main DRBGS11n mech\n- * @run main DRBGS11n capability\n+ * @run main\/othervm --enable-final-field-mutation=ALL-UNNAMED DRBGS11n mech\n+ * @run main\/othervm --enable-final-field-mutation=ALL-UNNAMED DRBGS11n capability\n","filename":"test\/jdk\/sun\/security\/provider\/SecureRandom\/DRBGS11n.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n- * @run testng\/othervm FindSection\n+ * @run testng\/othervm --enable-final-field-mutation=ALL-UNNAMED FindSection\n","filename":"test\/jdk\/sun\/security\/util\/ManifestDigester\/FindSection.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @run junit\/timeout=480 CompletionSuggestionTest\n+ * @run junit\/othervm\/timeout=480 --enable-final-field-mutation=ALL-UNNAMED CompletionSuggestionTest\n","filename":"test\/langtools\/jdk\/jshell\/CompletionSuggestionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -223,0 +223,1 @@\n+    public static final String FinalFieldMutation = PREFIX + \"FinalFieldMutation\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.reflect;\n+\n+import java.lang.reflect.Field;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 10, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 10, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(3)\n+public class FieldSet {\n+\n+    static class FieldHolder {\n+        Object obj;\n+        int intValue;\n+        long longValue;\n+        FieldHolder(Object obj, int i, long l) {\n+            this.obj = obj;\n+            this.intValue = i;\n+            this.longValue = l;\n+        }\n+    }\n+\n+    static class FinalFieldHolder {\n+        final Object obj;\n+        final int intValue;\n+        final long longValue;\n+        FinalFieldHolder(Object obj, int i, long l) {\n+            this.obj = obj;\n+            this.intValue = i;\n+            this.longValue = l;\n+        }\n+    }\n+\n+    private FieldHolder fieldHolder;\n+    private FinalFieldHolder finalFieldHolder;\n+\n+    private Field objField1, objField2, objField3;\n+    private Field intField1, intField2, intField3;\n+    private Field longField1, longField2, longField3;\n+\n+    @Setup\n+    public void setup() throws Exception {\n+        fieldHolder = new FieldHolder(new Object(), 1, 1L);\n+        finalFieldHolder = new FinalFieldHolder(new Object(), 1, 1L);\n+\n+        \/\/ non-final && !override\n+        objField1 = FieldHolder.class.getDeclaredField(\"obj\");\n+        intField1 = FieldHolder.class.getDeclaredField(\"intValue\");\n+        longField1 = FieldHolder.class.getDeclaredField(\"longValue\");\n+\n+        \/\/ non-final && override\n+        objField2 = FieldHolder.class.getDeclaredField(\"obj\");\n+        objField2.setAccessible(true);\n+        intField2 = FieldHolder.class.getDeclaredField(\"intValue\");\n+        intField2.setAccessible(true);\n+        longField2 = FieldHolder.class.getDeclaredField(\"longValue\");\n+        longField2.setAccessible(true);\n+\n+        \/\/ final && override\n+        objField3 = FinalFieldHolder.class.getDeclaredField(\"obj\");\n+        objField3.setAccessible(true);\n+        intField3 = FinalFieldHolder.class.getDeclaredField(\"intValue\");\n+        intField3.setAccessible(true);\n+        longField3 = FinalFieldHolder.class.getDeclaredField(\"longValue\");\n+        longField3.setAccessible(true);\n+    }\n+\n+    \/\/ non-final && !override\n+\n+    @Benchmark\n+    public void setNonFinalObjectField() throws Exception {\n+        objField1.set(fieldHolder, new Object());\n+    }\n+\n+    @Benchmark\n+    public void setNonFinalIntField() throws Exception {\n+        int newValue = ThreadLocalRandom.current().nextInt();\n+        intField1.setInt(fieldHolder, newValue);\n+    }\n+\n+    @Benchmark\n+    public void setNonFinalLongField() throws Exception {\n+        long newValue = ThreadLocalRandom.current().nextLong();\n+        longField1.setLong(fieldHolder, newValue);\n+    }\n+\n+    \/\/ non-final && override\n+\n+    @Benchmark\n+    public void setNonFinalObjectFieldWithOverride() throws Exception {\n+        objField2.set(fieldHolder, new Object());\n+    }\n+\n+    @Benchmark\n+    public void setNonFinalIntFieldWithOverride() throws Exception {\n+        int newValue = ThreadLocalRandom.current().nextInt();\n+        intField2.setInt(fieldHolder, newValue);\n+    }\n+\n+    @Benchmark\n+    public void setNonFinalLongFieldWithOverride() throws Exception {\n+        long newValue = ThreadLocalRandom.current().nextLong();\n+        longField2.setLong(fieldHolder, newValue);\n+    }\n+\n+    \/\/ final && override\n+\n+    @Benchmark\n+    public void setFinalObjectField()throws Exception {\n+        objField3.set(finalFieldHolder, new Object());\n+    }\n+\n+    @Benchmark\n+    public void setFinalIntField() throws Exception {\n+        int newValue = ThreadLocalRandom.current().nextInt();\n+        intField3.setInt(finalFieldHolder, newValue);\n+    }\n+\n+    @Benchmark\n+    public void setFinalLongField() throws Exception {\n+        long newValue = ThreadLocalRandom.current().nextLong();\n+        longField3.setLong(finalFieldHolder, newValue);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/reflect\/FieldSet.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"}]}