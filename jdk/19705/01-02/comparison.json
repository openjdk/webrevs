{"files":[{"patch":"@@ -361,1 +361,1 @@\n-            Type outerThisType = types.erasure(owner.type.getEnclosingType());\n+            Type outerThisType = owner.innermostAccessibleEnclosingClass().erasure(types);\n@@ -509,1 +509,17 @@\n-            type.getEnclosingType().hasTag(CLASS) && (flags() & (INTERFACE | ENUM | RECORD | NOOUTERTHIS)) == 0;\n+            type.getEnclosingType().hasTag(CLASS) && (flags() & (INTERFACE | ENUM | RECORD)) == 0 &&\n+                    ((flags() & NOOUTERTHIS) == 0 || type.getEnclosingType().tsym.hasOuterInstance());\n+    }\n+\n+    \/** If the class containing this symbol is a local or an anonymous class, then it might be\n+     *  defined inside one or more pre-construction contexts, for which the corresponding enclosing\n+     *  instance is considered inaccessible. This method return the class symbol corresponding to the\n+     *  innermost enclosing type that is accessible from this symbol's class. Note: this method should\n+     *  only be called after checking that {@link #hasOuterInstance()} returns {@code true}.\n+     *\/\n+    public ClassSymbol innermostAccessibleEnclosingClass() {\n+        Assert.check(enclClass().hasOuterInstance());\n+        Type current = enclClass().type;\n+        while ((current.tsym.flags() & NOOUTERTHIS) != 0) {\n+            current = current.getEnclosingType();\n+        }\n+        return (ClassSymbol) current.getEnclosingType().tsym;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2589,1 +2589,1 @@\n-                    } else if (methName == names._super) {\n+                    } else if (methName == names._super && site.tsym.hasOuterInstance()) {\n@@ -2592,1 +2592,1 @@\n-                        rs.resolveImplicitThis(tree.meth.pos(),\n+                        rs.resolveImplicitOuterInstance(tree.meth.pos(),\n@@ -2800,3 +2800,1 @@\n-        } else if (!clazztype.tsym.isInterface() &&\n-                   (clazztype.tsym.flags_field & NOOUTERTHIS) == 0 &&\n-                   clazztype.getEnclosingType().hasTag(CLASS)) {\n+        } else if (clazztype.tsym.hasOuterInstance()) {\n@@ -2804,1 +2802,1 @@\n-            rs.resolveImplicitThis(tree.pos(), env, clazztype);\n+            rs.resolveImplicitOuterInstance(tree.pos(), env, clazztype);\n@@ -3728,4 +3726,1 @@\n-                Type enclosingType = exprType.getEnclosingType();\n-                if (enclosingType != null &&\n-                    enclosingType.hasTag(CLASS) &&\n-                    (exprType.tsym.flags_field & NOOUTERTHIS) == 0) {\n+                if (exprType.tsym.hasOuterInstance()) {\n@@ -3733,1 +3728,1 @@\n-                    rs.resolveImplicitThis(that.pos(), env, exprType);\n+                    rs.resolveImplicitOuterInstance(that.pos(), env, exprType);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -3950,2 +3950,2 @@\n-     * Resolve an appropriate implicit this instance for t's container.\n-     * JLS 8.8.5.1 and 15.9.2\n+     * Resolve an appropriate implicit outer instance for type t.\n+     * This assumes that an outer instance exists (i.e., t.tsym.hasOuterInstance()).\n@@ -3953,2 +3953,2 @@\n-    Type resolveImplicitThis(DiagnosticPosition pos, Env<AttrContext> env, Type t) {\n-        return resolveImplicitThis(pos, env, t, false);\n+    Type resolveImplicitOuterInstance(DiagnosticPosition pos, Env<AttrContext> env, Type t) {\n+        return resolveImplicitOuterInstance(pos, env, t, false);\n@@ -3957,6 +3957,17 @@\n-    Type resolveImplicitThis(DiagnosticPosition pos, Env<AttrContext> env, Type t, boolean isSuperCall) {\n-        Type thisType = (t.tsym.owner.kind.matches(KindSelector.VAL_MTH)\n-                         ? resolveSelf(pos, env, t.getEnclosingType().tsym, names._this)\n-                         : resolveSelfContaining(pos, env, t.tsym, isSuperCall)).type;\n-        if (env.info.ctorPrologue && thisType.tsym == env.enclClass.sym) {\n-            log.error(pos, Errors.CantRefBeforeCtorCalled(names._this));\n+    Type resolveImplicitOuterInstance(DiagnosticPosition pos, Env<AttrContext> env, Type t, boolean isSuperCall) {\n+        Assert.check(t.tsym.hasOuterInstance());\n+\n+        \/\/ Resolve the target type\n+        Type targetType;\n+        if (t.tsym.owner.kind.matches(KindSelector.VAL_MTH)) {\n+            Type outerType = t.tsym.innermostAccessibleEnclosingClass().type;\n+            targetType = resolveSelf(pos, env, outerType.tsym, names._this).type;\n+        } else\n+            targetType = resolveSelfContaining(pos, env, t.tsym, isSuperCall).type;\n+\n+        \/\/ Verify we're not in an early construction context for that type\n+        for (Env<AttrContext> env1 = env; env1 != null; env1 = env1.outer) {\n+            if (env1.info.ctorPrologue && targetType.tsym == env1.enclClass.sym) {\n+                log.error(pos, Errors.CantRefBeforeCtorCalled(names._this));\n+                break;\n+            }\n@@ -3964,1 +3975,3 @@\n-        return thisType;\n+\n+        \/\/ Done\n+        return targetType;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":25,"deletions":12,"binary":false,"changes":37,"status":"modified"}]}