{"files":[{"patch":"@@ -361,1 +361,1 @@\n-            Type outerThisType = types.erasure(owner.type.getEnclosingType());\n+            Type outerThisType = owner.innermostAccessibleEnclosingClass().erasure(types);\n@@ -509,1 +509,17 @@\n-            type.getEnclosingType().hasTag(CLASS) && (flags() & (INTERFACE | ENUM | RECORD | NOOUTERTHIS)) == 0;\n+            type.getEnclosingType().hasTag(CLASS) && (flags() & (INTERFACE | ENUM | RECORD)) == 0 &&\n+                    ((flags() & NOOUTERTHIS) == 0 || type.getEnclosingType().tsym.hasOuterInstance());\n+    }\n+\n+    \/** If the class containing this symbol is a local or an anonymous class, then it might be\n+     *  defined inside one or more pre-construction contexts, for which the corresponding enclosing\n+     *  instance is considered inaccessible. This method return the class symbol corresponding to the\n+     *  innermost enclosing type that is accessible from this symbol's class. Note: this method should\n+     *  only be called after checking that {@link #hasOuterInstance()} returns {@code true}.\n+     *\/\n+    public ClassSymbol innermostAccessibleEnclosingClass() {\n+        Assert.check(enclClass().hasOuterInstance());\n+        Type current = enclClass().type;\n+        while ((current.tsym.flags() & NOOUTERTHIS) != 0) {\n+            current = current.getEnclosingType();\n+        }\n+        return (ClassSymbol) current.getEnclosingType().tsym;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2589,1 +2589,1 @@\n-                    } else if (methName == names._super) {\n+                    } else if (methName == names._super && site.tsym.hasOuterInstance()) {\n@@ -2592,1 +2592,1 @@\n-                        rs.resolveImplicitThis(tree.meth.pos(),\n+                        rs.resolveImplicitOuterInstance(tree.meth.pos(),\n@@ -2800,3 +2800,1 @@\n-        } else if (!clazztype.tsym.isInterface() &&\n-                   (clazztype.tsym.flags_field & NOOUTERTHIS) == 0 &&\n-                   clazztype.getEnclosingType().hasTag(CLASS)) {\n+        } else if (clazztype.tsym.hasOuterInstance()) {\n@@ -2804,1 +2802,1 @@\n-            rs.resolveImplicitThis(tree.pos(), env, clazztype);\n+            rs.resolveImplicitOuterInstance(tree.pos(), env, clazztype);\n@@ -3728,2 +3726,1 @@\n-                Type enclosingType = exprType.getEnclosingType();\n-                if (enclosingType != null && enclosingType.hasTag(CLASS)) {\n+                if (exprType.tsym.hasOuterInstance()) {\n@@ -3731,1 +3728,1 @@\n-                    rs.resolveImplicitThis(that.pos(), env, exprType);\n+                    rs.resolveImplicitOuterInstance(that.pos(), env, exprType);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -3950,2 +3950,2 @@\n-     * Resolve an appropriate implicit this instance for t's container.\n-     * JLS 8.8.5.1 and 15.9.2\n+     * Resolve an appropriate implicit outer instance for type t.\n+     * This assumes that an outer instance exists (i.e., t.tsym.hasOuterInstance()).\n@@ -3953,2 +3953,2 @@\n-    Type resolveImplicitThis(DiagnosticPosition pos, Env<AttrContext> env, Type t) {\n-        return resolveImplicitThis(pos, env, t, false);\n+    Type resolveImplicitOuterInstance(DiagnosticPosition pos, Env<AttrContext> env, Type t) {\n+        return resolveImplicitOuterInstance(pos, env, t, false);\n@@ -3957,6 +3957,17 @@\n-    Type resolveImplicitThis(DiagnosticPosition pos, Env<AttrContext> env, Type t, boolean isSuperCall) {\n-        Type thisType = (t.tsym.owner.kind.matches(KindSelector.VAL_MTH)\n-                         ? resolveSelf(pos, env, t.getEnclosingType().tsym, names._this)\n-                         : resolveSelfContaining(pos, env, t.tsym, isSuperCall)).type;\n-        if (env.info.ctorPrologue && thisType.tsym == env.enclClass.sym) {\n-            log.error(pos, Errors.CantRefBeforeCtorCalled(names._this));\n+    Type resolveImplicitOuterInstance(DiagnosticPosition pos, Env<AttrContext> env, Type t, boolean isSuperCall) {\n+        Assert.check(t.tsym.hasOuterInstance());\n+\n+        \/\/ Resolve the target type\n+        Type targetType;\n+        if (t.tsym.owner.kind.matches(KindSelector.VAL_MTH)) {\n+            Type outerType = t.tsym.innermostAccessibleEnclosingClass().type;\n+            targetType = resolveSelf(pos, env, outerType.tsym, names._this).type;\n+        } else\n+            targetType = resolveSelfContaining(pos, env, t.tsym, isSuperCall).type;\n+\n+        \/\/ Verify we're not in an early construction context for that type\n+        for (Env<AttrContext> env1 = env; env1 != null; env1 = env1.outer) {\n+            if (env1.info.ctorPrologue && targetType.tsym == env1.enclClass.sym) {\n+                log.error(pos, Errors.CantRefBeforeCtorCalled(names._this));\n+                break;\n+            }\n@@ -3964,1 +3975,3 @@\n-        return thisType;\n+\n+        \/\/ Done\n+        return targetType;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":25,"deletions":12,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8334248\n+ * @summary Allow early construction local class constructor method references\n+ * @enablePreview\n+ *\/\n+\n+import java.util.function.Supplier;\n+\n+public class EarlyLocalCtorRef {\n+\n+    public EarlyLocalCtorRef() {\n+        class InnerLocal { }\n+        this(InnerLocal::new);\n+    }\n+\n+    public EarlyLocalCtorRef(Supplier<Object> s) {\n+    }\n+\n+    public static void main(String[] args) {\n+        new EarlyLocalCtorRef();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalCtorRef.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"}]}