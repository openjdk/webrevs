{"files":[{"patch":"@@ -453,0 +453,10 @@\n+\/\/ Returns true if the JavaThread's Java object is a platform thread\n+static bool is_platform_thread(JavaThread* jt) {\n+  if (jt != nullptr) {\n+    oop thread_obj = jt->threadObj();\n+    return (thread_obj != nullptr) && !thread_obj->is_a(vmClasses::BoundVirtualThread_klass());\n+  } else {\n+    return false;\n+  }\n+}\n+\n@@ -465,0 +475,5 @@\n+\/\/ Returns true if the ThreadSnapshot's Java object is a platform thread\n+static bool is_platform_thread(ThreadSnapshot* ts) {\n+  oop thread_obj = ts->threadObj();\n+  return (thread_obj != nullptr) && !thread_obj->is_a(vmClasses::BoundVirtualThread_klass());\n+}\n@@ -1047,1 +1062,1 @@\n-      oop thread_obj = (jt != nullptr ? jt->threadObj() : (oop)nullptr);\n+      oop thread_obj = is_platform_thread(jt) ? jt->threadObj() : (oop)nullptr;\n@@ -1148,2 +1163,2 @@\n-    if (ts->threadObj() == nullptr) {\n-     \/\/ if the thread does not exist or now it is terminated, set threadinfo to null\n+    if (!is_platform_thread(ts)) {\n+      \/\/ if the thread does not exist, has terminated, or is a virtual thread, then set threadinfo to null\n@@ -1214,2 +1229,2 @@\n-    if (ts->threadObj() == nullptr) {\n-     \/\/ if the thread does not exist or now it is terminated, set threadinfo to null\n+    if (!is_platform_thread(ts)) {\n+      \/\/ if the thread does not exist, has terminated, or is a virtual thread, then set threadinfo to null\n@@ -1411,1 +1426,1 @@\n-    if (java_thread != nullptr) {\n+    if (is_platform_thread(java_thread)) {\n@@ -2104,2 +2119,1 @@\n-\n-  if (java_thread != nullptr) {\n+  if (is_platform_thread(java_thread)) {\n@@ -2144,1 +2158,1 @@\n-    if (java_thread != nullptr) {\n+    if (is_platform_thread(java_thread)) {\n@@ -2172,5 +2186,2 @@\n-    if (java_thread != nullptr) {\n-      oop thread_obj = java_thread->threadObj();\n-      if (thread_obj != nullptr && !thread_obj->is_a(vmClasses::BaseVirtualThread_klass())) {\n-        return os::thread_cpu_time((Thread*) java_thread, user_sys_cpu_time != 0);\n-      }\n+    if (is_platform_thread(java_thread)) {\n+      return os::thread_cpu_time((Thread*) java_thread, user_sys_cpu_time != 0);\n@@ -2218,1 +2229,1 @@\n-    if (java_thread != nullptr) {\n+    if (is_platform_thread(java_thread)) {\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":26,"deletions":15,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,0 @@\n-    private boolean      virtual;   \/\/ accessed by ThreadImpl\n@@ -227,1 +226,0 @@\n-        this.virtual = t.isVirtual();\n","filename":"src\/java.management\/share\/classes\/java\/lang\/management\/ThreadInfo.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,2 +68,2 @@\n- * A Java virtual machine implementation may support measuring\n- * the CPU time for the current thread, for any thread, or for no threads.\n+ * A Java virtual machine implementation may support measuring the CPU time\n+ * for the current platform thread, for any platform thread, or for no threads.\n@@ -74,5 +74,4 @@\n- * thread.  The {@link #isCurrentThreadCpuTimeSupported} method can\n- * be used to determine if a Java virtual machine supports measuring of\n- * the CPU time for the current  thread.\n- * A Java virtual machine implementation that supports CPU time measurement\n- * for any thread will also support that for the current thread.\n+ * platform thread.  The {@link #isCurrentThreadCpuTimeSupported()} method\n+ * can be used to determine if a Java virtual machine supports measuring of\n+ * the CPU time with the {@link #getCurrentThreadCpuTime()} and\n+ * {@link #getCurrentThreadUserTime()} methods from a platform thread.\n@@ -414,2 +413,3 @@\n-     * @return the total CPU time for the current thread if CPU time\n-     * measurement is enabled; {@code -1} otherwise.\n+     * @return the total CPU time for the current thread if the current\n+     * thread is a platform thread and if CPU time measurement is enabled;\n+     * {@code -1} otherwise.\n@@ -441,2 +441,3 @@\n-     * @return the user-level CPU time for the current thread if CPU time\n-     * measurement is enabled; {@code -1} otherwise.\n+     * @return the user-level CPU time for the current thread if the current\n+     * thread is a platform thread and if CPU time measurement is enabled;\n+     * {@code -1} otherwise.\n@@ -475,2 +476,2 @@\n-     * @return the total CPU time for a thread of the specified ID\n-     * if the thread of the specified ID exists, the thread is alive,\n+     * @return the total CPU time for a thread of the specified ID if the\n+     * thread of the specified ID is a platform thread, the thread is alive,\n@@ -510,2 +511,2 @@\n-     * @return the user-level CPU time for a thread of the specified ID\n-     * if the thread of the specified ID exists, the thread is alive,\n+     * @return the user-level CPU time for a thread of the specified ID if the\n+     * thread of the specified ID is a platform thread, the thread is alive,\n@@ -529,1 +530,1 @@\n-     * measurement for any thread.\n+     * measurement for any platform thread.\n@@ -531,2 +532,3 @@\n-     * measurement for any thread will also support CPU time\n-     * measurement for the current thread.\n+     * measurement for any platform thread will also support CPU time\n+     * measurement for the current thread, when the current thread is a\n+     * platform thread.\n@@ -537,1 +539,1 @@\n-     *     measurement for any thread;\n+     *     measurement for any platform thread;\n@@ -543,2 +545,3 @@\n-     * Tests if the Java virtual machine supports CPU time\n-     * measurement for the current thread.\n+     * Tests if the Java virtual machine supports CPU time measurement from\n+     * a platform thread with the {@link #getCurrentThreadCpuTime()} and\n+     * {@link #getCurrentThreadUserTime()} methods.\n@@ -550,2 +553,2 @@\n-     *     if the Java virtual machine supports CPU time\n-     *     measurement for current thread;\n+     *     if the Java virtual machine supports CPU time measurement\n+     *     of the current platform thread;\n","filename":"src\/java.management\/share\/classes\/java\/lang\/management\/ThreadMXBean.java","additions":26,"deletions":23,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.Arrays;\n@@ -133,1 +134,1 @@\n-        return platformThreadIds(threads);\n+        return threadIds(threads);\n@@ -144,6 +145,1 @@\n-        ThreadInfo ti = getThreadInfo(ids, maxDepth)[0];\n-        if (ti == null || Util.isVirtual(ti)) {\n-            return null;\n-        } else {\n-            return ti;\n-        }\n+        return getThreadInfo(ids, maxDepth)[0];\n@@ -193,1 +189,0 @@\n-        nullVirtualThreads(infos);\n@@ -223,4 +218,0 @@\n-        \/\/ check if Thread CPU time measurement is supported.\n-        if (Thread.currentThread().isVirtual()) {\n-            throw new UnsupportedOperationException(\"Not supported by virtual threads\");\n-        }\n@@ -236,1 +227,1 @@\n-        if (verifyCurrentThreadCpuTime()) {\n+        if (verifyCurrentThreadCpuTime() && !Thread.currentThread().isVirtual()) {\n@@ -286,5 +277,1 @@\n-                    if (thread.isVirtual()) {\n-                        times[0] = -1;\n-                    } else {\n-                        times[0] = getThreadTotalCpuTime0(0);\n-                    }\n+                    times[0] = thread.isVirtual() ? -1L : getThreadTotalCpuTime0(0);\n@@ -303,1 +290,1 @@\n-        if (verifyCurrentThreadCpuTime()) {\n+        if (verifyCurrentThreadCpuTime() && !Thread.currentThread().isVirtual()) {\n@@ -329,5 +316,1 @@\n-                    if (thread.isVirtual()) {\n-                        times[0] = -1;\n-                    } else {\n-                        times[0] = getThreadUserCpuTime0(0);\n-                    }\n+                    times[0] = thread.isVirtual() ? -1L : getThreadTotalCpuTime0(0);\n@@ -379,5 +362,1 @@\n-                if (thread.isVirtual()) {\n-                    return -1L;\n-                } else {\n-                    return getThreadAllocatedMemory0(0);\n-                }\n+                return thread.isVirtual() ? -1L : getThreadAllocatedMemory0(0);\n@@ -434,5 +413,4 @@\n-        if (threads != null) {\n-            long[] tids = platformThreadIds(threads);\n-            if (tids.length > 0) {\n-                return tids;\n-            }\n+        if (threads != null && threads.length > 0) {\n+            return threadIds(threads);\n+        } else {\n+            return null;\n@@ -440,1 +418,0 @@\n-        return null;\n@@ -446,1 +423,0 @@\n-\n@@ -499,4 +475,1 @@\n-        ThreadInfo[] infos = dumpThreads0(ids, lockedMonitors, lockedSynchronizers,\n-                                          Integer.MAX_VALUE);\n-        nullVirtualThreads(infos);\n-        return infos;\n+        return dumpThreads0(ids, lockedMonitors, lockedSynchronizers, Integer.MAX_VALUE);\n@@ -505,0 +478,1 @@\n+    @Override\n@@ -519,3 +493,1 @@\n-        ThreadInfo[] infos = dumpThreads0(ids, lockedMonitors, lockedSynchronizers, maxDepth);\n-        nullVirtualThreads(infos);\n-        return infos;\n+        return dumpThreads0(ids, lockedMonitors, lockedSynchronizers, maxDepth);\n@@ -527,3 +499,1 @@\n-        ThreadInfo[] infos = dumpAllThreads(lockedMonitors, lockedSynchronizers,\n-                                            Integer.MAX_VALUE);\n-        return platformThreads(infos);\n+        return dumpAllThreads(lockedMonitors, lockedSynchronizers, Integer.MAX_VALUE);\n@@ -532,0 +502,1 @@\n+    @Override\n@@ -541,1 +512,3 @@\n-        return platformThreads(infos);\n+        return Arrays.stream(infos)\n+                .filter(ti -> ti != null)\n+                .toArray(ThreadInfo[]::new);\n@@ -575,1 +548,1 @@\n-     * Returns the thread identifiers of the platform threads in the given array.\n+     * Returns the thread identifiers of the threads in the given array.\n@@ -577,1 +550,1 @@\n-    private static long[] platformThreadIds(Thread[] threads) {\n+    private static long[] threadIds(Thread[] threads) {\n@@ -579,1 +552,0 @@\n-                .filter(t -> !t.isVirtual())\n@@ -583,22 +555,0 @@\n-\n-    \/**\n-     * Returns the ThreadInfo objects from the given array that correspond to platform\n-     * threads.\n-     *\/\n-    private ThreadInfo[] platformThreads(ThreadInfo[] infos) {\n-        return Stream.of(infos)\n-                .filter(ti -> !Util.isVirtual(ti))\n-                .toArray(ThreadInfo[]::new);\n-    }\n-\n-    \/**\n-     * Set the elements of the given array to null if they correspond to a virtual thread.\n-     *\/\n-    private static void nullVirtualThreads(ThreadInfo[] infos) {\n-        for (int i = 0; i < infos.length; i++) {\n-            ThreadInfo ti = infos[i];\n-            if (ti != null && Util.isVirtual(ti)) {\n-                infos[i] = null;\n-            }\n-        }\n-    }\n","filename":"src\/java.management\/share\/classes\/sun\/management\/ThreadImpl.java","additions":23,"deletions":73,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.lang.reflect.Field;\n@@ -30,4 +29,0 @@\n-import java.lang.management.ThreadInfo;\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -38,1 +33,0 @@\n-\n@@ -89,27 +83,0 @@\n-\n-    \/**\n-     * Returns true if the given ThreadInfo is for a virtual thread.\n-     *\/\n-    public static boolean isVirtual(ThreadInfo threadInfo) {\n-        try {\n-            return (boolean) THREADINFO_VIRTUAL.get(threadInfo);\n-        } catch (Exception e) {\n-            throw new InternalError(e);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    private static Field threadInfoVirtual() {\n-        PrivilegedExceptionAction<Field> pa = () -> {\n-            Field f = ThreadInfo.class.getDeclaredField(\"virtual\");\n-            f.setAccessible(true);\n-            return f;\n-        };\n-        try {\n-            return AccessController.doPrivileged(pa);\n-        } catch (PrivilegedActionException e) {\n-            throw new InternalError(e);\n-        }\n-    }\n-\n-    private static final Field THREADINFO_VIRTUAL = threadInfoVirtual();\n","filename":"src\/java.management\/share\/classes\/sun\/management\/Util.java","additions":1,"deletions":34,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,3 +56,2 @@\n-     * array of IDs has used,\n-     * if the thread of a specified ID exists, the thread is alive,\n-     * and CPU time measurement is enabled;\n+     * array of IDs has used, if the thread of a specified ID is a platform\n+     * thread, the thread is alive, and CPU time measurement is enabled;\n@@ -90,3 +89,2 @@\n-     * the input array of IDs has used,\n-     * if the thread of a specified ID exists, the thread is alive,\n-     * and CPU time measurement is enabled;\n+     * the input array of IDs has used, if the thread of a specified ID is a\n+     * platform thread, the thread is alive, and CPU time measurement is enabled;\n@@ -164,4 +162,3 @@\n-     * heap memory for the thread with the specified ID\n-     * if the thread with the specified ID exists, the thread is alive,\n-     * and thread memory allocation measurement is enabled;\n-     * {@code -1} otherwise.\n+     * heap memory for the thread with the specified ID if the thread with the\n+     * specified ID is a platform thread, the thread is alive, and thread memory\n+     * allocation measurement is enabled; {@code -1} otherwise.\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/ThreadMXBean.java","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=default\n+ * @bug 8284161 8303242\n+ * @summary Test com.sun.management.ThreadMXBean with virtual threads\n+ * @enablePreview\n+ * @library \/test\/lib\n+ * @run junit\/othervm VirtualThreads\n+ *\/\n+\n+\/**\n+ * @test id=no-vmcontinuations\n+ * @requires vm.continuations\n+ * @enablePreview\n+ * @library \/test\/lib\n+ * @run junit\/othervm -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations VirtualThreads\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import java.util.concurrent.locks.LockSupport;\n+import com.sun.management.ThreadMXBean;\n+\n+import jdk.test.lib.thread.VThreadRunner;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assumptions.*;\n+\n+public class VirtualThreads {\n+\n+    \/**\n+     * Test that ThreadMXBean::getCurrentThreadAllocatedBytes() returns -1 when\n+     * invoked from a virtual thread.\n+     *\/\n+    @Test\n+    void testGetCurrentThreadAllocatedBytes() throws Exception {\n+        ThreadMXBean bean = ManagementFactory.getPlatformMXBean(ThreadMXBean.class);\n+        assumeTrue(bean.isThreadAllocatedMemorySupported(),\n+                \"Thread memory allocation measurement not supported\");\n+\n+        VThreadRunner.run(() -> {\n+            assertEquals(-1L, bean.getCurrentThreadAllocatedBytes());\n+        });\n+    }\n+\n+    \/**\n+     * Test that ThreadMXBean.getThreadAllocatedBytes(long) returns -1 when invoked\n+     * with the thread ID of a virtual thread.\n+     *\/\n+    @Test\n+    void testGetThreadAllocatedBytes1() {\n+        ThreadMXBean bean = ManagementFactory.getPlatformMXBean(ThreadMXBean.class);\n+        assumeTrue(bean.isThreadAllocatedMemorySupported(),\n+                \"Thread memory allocation measurement not supported\");\n+\n+        Thread vthread = Thread.startVirtualThread(LockSupport::park);\n+        try {\n+            long allocated = bean.getThreadAllocatedBytes(vthread.threadId());\n+            assertEquals(-1L, allocated);\n+        } finally {\n+            LockSupport.unpark(vthread);\n+        }\n+    }\n+\n+    \/**\n+     * Test that ThreadMXBean.getThreadAllocatedBytes(long) returns -1 when invoked\n+     * by a virtual thread with its own thread id.\n+     *\/\n+    @Test\n+    void testGetThreadAllocatedBytes2() throws Exception {\n+        ThreadMXBean bean = ManagementFactory.getPlatformMXBean(ThreadMXBean.class);\n+        assumeTrue(bean.isThreadAllocatedMemorySupported(),\n+                \"Thread memory allocation measurement not supported\");\n+\n+        VThreadRunner.run(() -> {\n+            long tid = Thread.currentThread().threadId();\n+            long allocated = bean.getThreadAllocatedBytes(tid);\n+            assertEquals(-1L, allocated);\n+        });\n+    }\n+\n+    \/**\n+     * Test that ThreadMXBean.getThreadAllocatedBytes(long[]) returns -1 for\n+     * elements that correspond to a virtual thread.\n+     *\/\n+    @Test\n+    void testGetThreadAllocatedBytes3() {\n+        ThreadMXBean bean = ManagementFactory.getPlatformMXBean(ThreadMXBean.class);\n+        assumeTrue(bean.isThreadAllocatedMemorySupported(),\n+                \"Thread memory allocation measurement not supported\");\n+\n+        Thread vthread = Thread.startVirtualThread(LockSupport::park);\n+        try {\n+            long tid0 = Thread.currentThread().threadId();\n+            long tid1 = vthread.threadId();\n+            long[] tids = new long[] { tid0, tid1 };\n+            long[] allocated = bean.getThreadAllocatedBytes(tids);\n+            assertTrue(allocated[0] >= 0L);\n+            assertEquals(-1L, allocated[1]);\n+        } finally {\n+            LockSupport.unpark(vthread);\n+        }\n+    }\n+\n+    \/**\n+     * Test that ThreadMXBean.getThreadCpuTime(long[]) returns -1 for\n+     * elements that correspond to a virtual thread.\n+     *\/\n+    @Test\n+    void testGetThreadCpuTime() {\n+        ThreadMXBean bean = ManagementFactory.getPlatformMXBean(ThreadMXBean.class);\n+        assumeTrue(bean.isThreadCpuTimeSupported(), \"Thread CPU time measurement not supported\");\n+\n+        Thread vthread = Thread.startVirtualThread(LockSupport::park);\n+        try {\n+            long tid0 = Thread.currentThread().threadId();\n+            long tid1 = vthread.threadId();\n+            long[] tids = new long[] { tid0, tid1 };\n+            long[] cpuTimes = bean.getThreadCpuTime(tids);\n+            assertTrue(cpuTimes[0] >= 0L);\n+            assertEquals(-1L, cpuTimes[1]);\n+        } finally {\n+            LockSupport.unpark(vthread);\n+        }\n+    }\n+\n+    \/**\n+     * Test that ThreadMXBean.getThreadUserTime(long[])returns -1 for\n+     * elements that correspond to a virtual thread.\n+     *\/\n+    @Test\n+    void testGetThreadUserTime() {\n+        ThreadMXBean bean = ManagementFactory.getPlatformMXBean(ThreadMXBean.class);\n+        assumeTrue(bean.isThreadCpuTimeSupported(), \"Thread CPU time measurement not supported\");\n+\n+        Thread vthread = Thread.startVirtualThread(LockSupport::park);\n+        try {\n+            long tid0 = Thread.currentThread().threadId();\n+            long tid1 = vthread.threadId();\n+            long[] tids = new long[] { tid0, tid1 };\n+            long[] userTimes = bean.getThreadUserTime(tids);\n+            assertTrue(userTimes[0] >= 0L);\n+            assertEquals(-1L, userTimes[1]);\n+        } finally {\n+            LockSupport.unpark(vthread);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/management\/ThreadMXBean\/VirtualThreads.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8284161 8290562\n+ * @bug 8284161 8290562 8303242\n@@ -30,0 +30,1 @@\n+ * @library \/test\/lib\n@@ -38,0 +39,1 @@\n+ * @library \/test\/lib\n@@ -48,0 +50,1 @@\n+import java.util.Set;\n@@ -53,0 +56,1 @@\n+import java.util.stream.Collectors;\n@@ -54,0 +58,1 @@\n+import jdk.test.lib.thread.VThreadRunner;\n@@ -55,0 +60,2 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -61,2 +68,25 @@\n-     * Test that ThreadMXBean::getAllThreadsIds does not include thread ids for\n-     * virtual threads.\n+     * Test that ThreadMXBean.dumpAllThreads does not include virtual threads.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(ints = {0, Integer.MAX_VALUE})\n+    void testDumpAllThreads(int maxDepth) {\n+        Thread vthread = Thread.startVirtualThread(LockSupport::park);\n+        try {\n+            ThreadMXBean bean = ManagementFactory.getThreadMXBean();\n+            ThreadInfo[] infos = bean.dumpAllThreads(false, false, maxDepth);\n+            Set<Long> tids = Arrays.stream(infos)\n+                    .map(ThreadInfo::getThreadId)\n+                    .collect(Collectors.toSet());\n+\n+            \/\/ current thread should be included\n+            assertTrue(tids.contains(Thread.currentThread().threadId()));\n+\n+            \/\/ virtual thread should not be included\n+            assertFalse(tids.contains(vthread.threadId()));\n+        } finally {\n+            LockSupport.unpark(vthread);\n+        }\n+    }\n+\n+    \/**\n+     * Test that ThreadMXBean::getAllThreadsIds does not include virtual threads.\n@@ -65,1 +95,1 @@\n-    void testGetAllThreadIds() throws Exception {\n+    void testGetAllThreadIds() {\n@@ -83,1 +113,2 @@\n-     * Test that ThreadMXBean.getThreadInfo(long) returns null for a virtual thread.\n+     * Test that ThreadMXBean.getThreadInfo(long, maxDepth) returns null for a virtual\n+     * thread.\n@@ -85,2 +116,3 @@\n-    @Test\n-    void testGetThreadInfo1() throws Exception {\n+    @ParameterizedTest\n+    @ValueSource(ints = {0, Integer.MAX_VALUE})\n+    void testGetThreadInfo1(int maxDepth) {\n@@ -90,2 +122,2 @@\n-            ThreadInfo info = ManagementFactory.getThreadMXBean().getThreadInfo(tid);\n-            assertTrue(info == null);\n+            ThreadInfo info = ManagementFactory.getThreadMXBean().getThreadInfo(tid, maxDepth);\n+            assertNull(info);\n@@ -98,2 +130,2 @@\n-     * Test that ThreadMXBean.getThreadInfo(long) returns null when invoked by a virtual\n-     * thread with its own thread id.\n+     * Test that ThreadMXBean.getThreadInfo(long, maxDepth) returns null when invoked\n+     * by a virtual thread with its own thread id.\n@@ -101,3 +133,4 @@\n-    @Test\n-    void testGetThreadInfo2() throws Exception {\n-        runInVirtualThread(() -> {\n+    @ParameterizedTest\n+    @ValueSource(ints = {0, Integer.MAX_VALUE})\n+    void testGetThreadInfo2(int maxDepth) throws Exception {\n+        VThreadRunner.run(() -> {\n@@ -105,2 +138,2 @@\n-            ThreadInfo info = ManagementFactory.getThreadMXBean().getThreadInfo(tid);\n-            assertTrue(info == null);\n+            ThreadInfo info = ManagementFactory.getThreadMXBean().getThreadInfo(tid, maxDepth);\n+            assertNull(info);\n@@ -110,0 +143,41 @@\n+    \/**\n+     * Test that ThreadMXBean.getThreadInfo(long[], maxDepth) returns a null ThreadInfo\n+     * for elements that correspond to a virtual thread.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(ints = {0, Integer.MAX_VALUE})\n+    void testGetThreadInfo3(int maxDepth) {\n+        Thread vthread = Thread.startVirtualThread(LockSupport::park);\n+        try {\n+            long tid0 = Thread.currentThread().threadId();\n+            long tid1 = vthread.threadId();\n+            long[] tids = new long[] { tid0, tid1 };\n+            ThreadInfo[] infos = ManagementFactory.getThreadMXBean().getThreadInfo(tids, maxDepth);\n+            assertEquals(tid0, infos[0].getThreadId());\n+            assertNull(infos[1]);\n+        } finally {\n+            LockSupport.unpark(vthread);\n+        }\n+    }\n+\n+    \/**\n+     * Test that ThreadMXBean.getThreadInfo(long[], boolean, boolean, maxDepth) returns\n+     * a null ThreadInfo for elements that correspond to a virtual thread.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(ints = {0, Integer.MAX_VALUE})\n+    void testGetThreadInfo4(int maxDepth) {\n+        Thread vthread = Thread.startVirtualThread(LockSupport::park);\n+        try {\n+            long tid0 = Thread.currentThread().threadId();\n+            long tid1 = vthread.threadId();\n+            long[] tids = new long[] { tid0, tid1 };\n+            ThreadMXBean bean = ManagementFactory.getThreadMXBean();\n+            ThreadInfo[] infos = bean.getThreadInfo(tids, false, false, maxDepth);\n+            assertEquals(tid0, infos[0].getThreadId());\n+            assertNull(infos[1]);\n+        } finally {\n+            LockSupport.unpark(vthread);\n+        }\n+    }\n+\n@@ -115,1 +189,1 @@\n-    void testGetThreadInfo3() throws Exception {\n+    void testGetThreadInfoCarrierThread() throws Exception {\n@@ -149,1 +223,1 @@\n-                assertTrue(info.getLockedMonitors().length == 0);\n+                assertEquals(0, info.getLockedMonitors().length);\n@@ -154,19 +228,0 @@\n-    \/**\n-     * Test that ThreadMXBean.getThreadInfo(long[]) returns a null ThreadInfo for\n-     * elements that correspond to a virtual thread.\n-     *\/\n-    @Test\n-    void testGetThreadInfo4() throws Exception {\n-        Thread vthread = Thread.startVirtualThread(LockSupport::park);\n-        try {\n-            long tid0 = Thread.currentThread().threadId();\n-            long tid1 = vthread.threadId();\n-            long[] tids = new long[] { tid0, tid1 };\n-            ThreadInfo[] infos = ManagementFactory.getThreadMXBean().getThreadInfo(tids);\n-            assertTrue(infos[0].getThreadId() == tid0);\n-            assertTrue(infos[1] == null);\n-        } finally {\n-            LockSupport.unpark(vthread);\n-        }\n-    }\n-\n@@ -178,0 +233,3 @@\n+        ThreadMXBean bean = ManagementFactory.getThreadMXBean();\n+        assumeTrue(bean.isThreadCpuTimeSupported(), \"Thread CPU time measurement not supported\");\n+\n@@ -181,2 +239,2 @@\n-            long cpuTime = ManagementFactory.getThreadMXBean().getThreadCpuTime(tid);\n-            assertTrue(cpuTime == -1L);\n+            long cpuTime = bean.getThreadCpuTime(tid);\n+            assertEquals(-1L, cpuTime);\n@@ -194,1 +252,4 @@\n-        runInVirtualThread(() -> {\n+        ThreadMXBean bean = ManagementFactory.getThreadMXBean();\n+        assumeTrue(bean.isThreadCpuTimeSupported(), \"Thread CPU time measurement not supported\");\n+\n+        VThreadRunner.run(() -> {\n@@ -196,2 +257,2 @@\n-            long cpuTime = ManagementFactory.getThreadMXBean().getThreadCpuTime(tid);\n-            assertTrue(cpuTime == -1L);\n+            long cpuTime = bean.getThreadCpuTime(tid);\n+            assertEquals(-1L, cpuTime);\n@@ -206,0 +267,3 @@\n+        ThreadMXBean bean = ManagementFactory.getThreadMXBean();\n+        assumeTrue(bean.isThreadCpuTimeSupported(), \"Thread CPU time measurement not supported\");\n+\n@@ -210,1 +274,1 @@\n-            assertTrue(userTime == -1L);\n+            assertEquals(-1L, userTime);\n@@ -222,1 +286,4 @@\n-        runInVirtualThread(() -> {\n+        ThreadMXBean bean = ManagementFactory.getThreadMXBean();\n+        assumeTrue(bean.isThreadCpuTimeSupported(), \"Thread CPU time measurement not supported\");\n+\n+        VThreadRunner.run(() -> {\n@@ -225,1 +292,1 @@\n-            assertTrue(userTime == -1L);\n+            assertEquals(-1L, userTime);\n@@ -230,2 +297,2 @@\n-     * Test that ThreadMXBean::getCurrentThreadCpuTime throws UOE when invoked\n-     * on a virtual thread.\n+     * Test that ThreadMXBean::isCurrentThreadCpuTimeSupported returns true when\n+     * CPU time measurement for the current thread is supported.\n@@ -234,4 +301,7 @@\n-    void testGetCurrentThreadCpuTime() throws Exception {\n-        runInVirtualThread(() -> {\n-            assertThrows(UnsupportedOperationException.class,\n-                    () -> ManagementFactory.getThreadMXBean().getCurrentThreadCpuTime());\n+    void testIsCurrentThreadCpuTimeSupported() throws Exception {\n+        ThreadMXBean bean = ManagementFactory.getThreadMXBean();\n+        assumeTrue(bean.isCurrentThreadCpuTimeSupported(),\n+                \"Thread CPU time measurement for the current thread not supported\");\n+\n+        VThreadRunner.run(() -> {\n+            assertTrue(bean.isCurrentThreadCpuTimeSupported());\n@@ -242,2 +312,2 @@\n-     * Test that ThreadMXBean::getCurrentThreadUserTime throws UOE when\n-     * invoked on a virtual thread.\n+     * Test that ThreadMXBean::getCurrentThreadCpuTime returns -1 when invoked\n+     * from a virtual thread.\n@@ -246,4 +316,7 @@\n-    void testGetCurrentThreadUserTime() throws Exception {\n-        runInVirtualThread(() -> {\n-            assertThrows(UnsupportedOperationException.class,\n-                    () -> ManagementFactory.getThreadMXBean().getCurrentThreadUserTime());\n+    void testGetCurrentThreadCpuTime() throws Exception {\n+        ThreadMXBean bean = ManagementFactory.getThreadMXBean();\n+        assumeTrue(bean.isCurrentThreadCpuTimeSupported(),\n+                \"Thread CPU time measurement for the current thread not supported\");\n+\n+        VThreadRunner.run(() -> {\n+            assertEquals(-1L, bean.getCurrentThreadCpuTime());\n@@ -254,2 +327,2 @@\n-     * Test that ThreadMXBean::getCurrentThreadAllocatedBytes returns -1 when\n-     * invoked on a virtual thread.\n+     * Test that ThreadMXBean::getCurrentThreadUserTime returns -1 when invoked\n+     * from a virtual thread.\n@@ -258,11 +331,4 @@\n-    void testGetCurrentThreadAllocatedBytes() throws Exception {\n-        runInVirtualThread(() -> {\n-            long allocated = ManagementFactory.getPlatformMXBean(com.sun.management.ThreadMXBean.class)\n-                    .getCurrentThreadAllocatedBytes();\n-            assertTrue(allocated == -1L);\n-        });\n-    }\n-\n-    interface ThrowingRunnable {\n-        void run() throws Exception;\n-    }\n+    void testGetCurrentThreadUserTime() throws Exception {\n+        ThreadMXBean bean = ManagementFactory.getThreadMXBean();\n+        assumeTrue(bean.isCurrentThreadCpuTimeSupported(),\n+                \"Thread CPU time measurement for the current thread not supported\");\n@@ -270,17 +336,3 @@\n-    private static void runInVirtualThread(ThrowingRunnable task) throws Exception {\n-        AtomicReference<Exception> exc = new AtomicReference<>();\n-        Runnable target =  () -> {\n-            try {\n-                task.run();\n-            } catch (Error e) {\n-                exc.set(new RuntimeException(e));\n-            } catch (Exception e) {\n-                exc.set(e);\n-            }\n-        };\n-        Thread thread = Thread.ofVirtual().start(target);\n-        thread.join();\n-        Exception e = exc.get();\n-        if (e != null) {\n-            throw e;\n-        }\n+        VThreadRunner.run(() -> {\n+            assertEquals(-1L, bean.getCurrentThreadUserTime());\n+        });\n","filename":"test\/jdk\/java\/lang\/management\/ThreadMXBean\/VirtualThreads.java","additions":139,"deletions":87,"binary":false,"changes":226,"status":"modified"}]}