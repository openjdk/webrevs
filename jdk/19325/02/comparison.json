{"files":[{"patch":"@@ -1866,1 +1866,1 @@\n-  \/\/ Vector Bit-manipulation used in Cryptography (Zvkb) Extension\n+  \/\/ Vector Bit-manipulation used in Cryptography (Zvbb) Extension\n@@ -1868,2 +1868,0 @@\n-  INSN(vclmul_vv,  0b1010111, 0b010, 0b001100);\n-  INSN(vclmulh_vv, 0b1010111, 0b010, 0b001101);\n@@ -1873,0 +1871,38 @@\n+  \/\/ Vector Bit-manipulation used in Cryptography (Zvbc) Extension\n+  INSN(vclmul_vv,  0b1010111, 0b010, 0b001100);\n+  INSN(vclmulh_vv, 0b1010111, 0b010, 0b001101);\n+\n+#undef INSN\n+\n+#define INSN(NAME, op, funct3, funct6)                                                             \\\n+  void NAME(VectorRegister Vd, VectorRegister Vs2, Register Rs1, VectorMask vm = unmasked) {       \\\n+    patch_VArith(op, Vd, funct3, Rs1->raw_encoding(), Vs2, vm, funct6);                            \\\n+  }\n+\n+  \/\/ Vector Bit-manipulation used in Cryptography (Zvbb) Extension\n+  INSN(vror_vx,    0b1010111, 0b100, 0b010100);\n+\n+#undef INSN\n+\n+#define patch_VArith_imm6(op, Reg, funct3, Reg_or_Imm5, I5, Vs2, vm, funct6)   \\\n+    unsigned insn = 0;                                                         \\\n+    patch((address)&insn, 6, 0, op);                                           \\\n+    patch((address)&insn, 14, 12, funct3);                                     \\\n+    patch((address)&insn, 19, 15, Reg_or_Imm5);                                \\\n+    patch((address)&insn, 25, vm);                                             \\\n+    patch((address)&insn, 26, I5);                                             \\\n+    patch((address)&insn, 31, 27, funct6);                                     \\\n+    patch_reg((address)&insn, 7, Reg);                                         \\\n+    patch_reg((address)&insn, 20, Vs2);                                        \\\n+    emit(insn)\n+\n+#define INSN(NAME, op, funct3, funct6)                                                             \\\n+  void NAME(VectorRegister Vd, VectorRegister Vs2, uint32_t imm, VectorMask vm = unmasked) {       \\\n+    guarantee(is_uimm6(imm), \"uimm is invalid\");                                                   \\\n+    patch_VArith_imm6(op, Vd, funct3, (uint32_t)(imm & 0x1f), (uint32_t)((imm >> 5) & 0x1), Vs2, vm, funct6);  \\\n+  }\n+\n+  \/\/ Vector Bit-manipulation used in Cryptography (Zvbb) Extension\n+  \/\/ NOTE: there is no corresponding vrol.vi supplied by the extension, but it can be emulated with vror.vi easily.\n+  INSN(vror_vi,    0b1010111, 0b011, 0b01010);\n+\n@@ -1874,0 +1910,1 @@\n+#undef patch_VArith_imm6\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":40,"deletions":3,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -141,2 +141,2 @@\n-  static constexpr bool supports_vector_variable_rotates(void) {\n-    return false;\n+  static bool supports_vector_variable_rotates(void) {\n+    return UseZvbb;\n@@ -146,2 +146,2 @@\n-  static constexpr bool supports_vector_constant_rotates(int shift) {\n-    return false;\n+  static bool supports_vector_constant_rotates(int shift) {\n+    return UseZvbb;\n","filename":"src\/hotspot\/cpu\/riscv\/matcher_riscv.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -78,1 +78,0 @@\n-      case Op_ReverseBytesV:\n@@ -81,0 +80,3 @@\n+      case Op_ReverseBytesV:\n+      case Op_RotateLeftV:\n+      case Op_RotateRightV:\n@@ -3060,0 +3062,146 @@\n+\/\/ --------------------------------- Vector Rotation ----------------------------------\n+\/\/\n+\/\/ Following rotate instruct's are shared by vectorization (in SLP, superword.cpp) and Vector API.\n+\/\/\n+\/\/ Rotate behaviour in vectorization is defined by java API, which includes:\n+\/\/  1. Integer.rorateRight, Integer.rorateLeft.\n+\/\/     `rotation by any multiple of 32 is a no-op, so all but the last five bits of the rotation distance can be ignored`.\n+\/\/  2. Long.rorateRight, Long.rorateLeft.\n+\/\/     `rotation by any multiple of 64 is a no-op, so all but the last six bits of the rotation distance can be ignored`.\n+\/\/\n+\/\/ Rotate behaviour in Vector API is defined as below, e.g.\n+\/\/  1. For Byte ROR, `a ROR b` is: (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))))\n+\/\/  2. For Short ROR, `a ROR b` is: (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))))\n+\/\/  3. For Integer ROR, `a ROR b` is: Integer.rotateRight(a, ((int)b))\n+\/\/  4. For Long ROR, `a ROR b` is: Long.rotateRight(a, ((int)b))\n+\/\/\n+\/\/ Basically, the behaviour between vectorization and Vector API is the same for Long and Integer, except that Vector API\n+\/\/ also supports Byte and Short rotation. But we can still share the intrinsics between vectorization and Vector API.\n+\/\/\n+\/\/ NOTE: for Long, its valid rotation value is 6 bits, although basic vector instruction only support 5 bit vector-immediate,\n+\/\/       in Zvbb, vror.vi support 6 bits vector-immediate, so the imm implementation of Long and other types can be unified.\n+\n+\/\/ Rotate right\n+\n+instruct vrotate_right(vReg dst, vReg src, vReg shift) %{\n+  match(Set dst (RotateRightV src shift));\n+  format %{ \"vrotate_right $dst, $src, $shift\\t\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vror_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), as_VectorRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vrotate_right_imm(vReg dst, vReg src, immI shift) %{\n+  match(Set dst (RotateRightV src shift));\n+  format %{ \"vrotate_right_imm $dst, $src, $shift\\t\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint32_t bits = type2aelembytes(bt) * 8;\n+    uint32_t con = (unsigned)$shift$$constant & (bits - 1);\n+    if (con == 0) {\n+      return;\n+    }\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vror_vi(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Rotate right - masked\n+\n+instruct vrotate_right_masked(vReg dst_src, vReg shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (RotateRightV (Binary dst_src shift) v0));\n+  effect(TEMP_DEF dst_src);\n+  format %{ \"vrotate_right_masked $dst_src, $dst_src, $shift, v0.t\\t\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vror_vv(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+                                 as_VectorRegister($shift$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vrotate_right_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (RotateRightV (Binary dst_src shift) v0));\n+  effect(TEMP_DEF dst_src);\n+  format %{ \"vrotate_right_imm_masked $dst_src, $dst_src, $shift, v0.t\\t\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint32_t bits = type2aelembytes(bt) * 8;\n+    uint32_t con = (unsigned)$shift$$constant & (bits - 1);\n+    if (con == 0) {\n+      return;\n+    }\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vror_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), con, Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Rotate left\n+\n+instruct vrotate_left(vReg dst, vReg src, vReg shift) %{\n+  match(Set dst (RotateLeftV src shift));\n+  format %{ \"vrotate_left $dst, $src, $shift\\t\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vrol_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), as_VectorRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vrotate_left_imm(vReg dst, vReg src, immI shift) %{\n+  match(Set dst (RotateLeftV src shift));\n+  format %{ \"vrotate_left_imm $dst, $src, $shift\\t\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint32_t bits = type2aelembytes(bt) * 8;\n+    uint32_t con = (unsigned)$shift$$constant & (bits - 1);\n+    if (con == 0) {\n+      return;\n+    }\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    con = bits - con;\n+    __ vror_vi(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Rotate left - masked\n+\n+instruct vrotate_left_masked(vReg dst_src, vReg shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (RotateLeftV (Binary dst_src shift) v0));\n+  effect(TEMP_DEF dst_src);\n+  format %{ \"vrotate_left_masked $dst_src, $dst_src, $shift, v0.t\\t\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vrol_vv(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+               as_VectorRegister($shift$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vrotate_left_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (RotateLeftV (Binary dst_src shift) v0));\n+  effect(TEMP_DEF dst_src);\n+  format %{ \"vrotate_left_imm_masked $dst_src, $dst_src, $shift, v0.t\\t\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint32_t bits = type2aelembytes(bt) * 8;\n+    uint32_t con = (unsigned)$shift$$constant & (bits - 1);\n+    if (con == 0) {\n+      return;\n+    }\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    con = bits - con;\n+    __ vror_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), con, Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":149,"deletions":1,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -78,0 +78,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"zvbb\", \"true\"},\n+        counts = {IRNode.ROTATE_RIGHT_V, \">0\"})\n@@ -91,0 +94,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"zvbb\", \"true\"},\n+        counts = {IRNode.ROTATE_RIGHT_V, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayShiftOpTest.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}