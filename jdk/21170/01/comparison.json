{"files":[{"patch":"@@ -42,0 +42,1 @@\n+import java.lang.classfile.ClassFile;\n@@ -43,0 +44,1 @@\n+import java.lang.constant.ClassDesc;\n@@ -2245,8 +2247,12 @@\n-        static class ClassFile {\n-            final String name;  \/\/ internal name\n-            final int accessFlags;\n-            final byte[] bytes;\n-            ClassFile(String name, int accessFlags, byte[] bytes) {\n-                this.name = name;\n-                this.accessFlags = accessFlags;\n-                this.bytes = bytes;\n+        \/**\n+         * This method checks the class file version and the structure of `this_class`.\n+         * and checks if the bytes is a class or interface (ACC_MODULE flag not set)\n+         * that is in the named package.\n+         *\n+         * @throws IllegalArgumentException if ACC_MODULE flag is set in access flags\n+         * or the class is not in the given package name.\n+         *\/\n+        static String validateAndFindInternalName(byte[] bytes, String pkgName) {\n+            int magic = readInt(bytes, 0);\n+            if (magic != ClassFile.MAGIC_NUMBER) {\n+                throw new ClassFormatError(\"Incompatible magic value: \" + magic);\n@@ -2254,0 +2260,4 @@\n+            \/\/ We have to read major and minor this way as ClassFile API throws IAE\n+            \/\/ yet we want distinct ClassFormatError and UnsupportedClassVersionError\n+            int minor = readUnsignedShort(bytes, 4);\n+            int major = readUnsignedShort(bytes, 6);\n@@ -2255,2 +2265,2 @@\n-            static ClassFile newInstanceNoCheck(String name, byte[] bytes) {\n-                return new ClassFile(name, 0, bytes);\n+            if (!VM.isSupportedClassFileVersion(major, minor)) {\n+                throw new UnsupportedClassVersionError(\"Unsupported class file version \" + major + \".\" + minor);\n@@ -2259,18 +2269,17 @@\n-            \/**\n-             * This method checks the class file version and the structure of `this_class`.\n-             * and checks if the bytes is a class or interface (ACC_MODULE flag not set)\n-             * that is in the named package.\n-             *\n-             * @throws IllegalArgumentException if ACC_MODULE flag is set in access flags\n-             * or the class is not in the given package name.\n-             *\/\n-            static ClassFile newInstance(byte[] bytes, String pkgName) {\n-                var cf = readClassFile(bytes);\n-\n-                \/\/ check if it's in the named package\n-                int index = cf.name.lastIndexOf('\/');\n-                String pn = (index == -1) ? \"\" : cf.name.substring(0, index).replace('\/', '.');\n-                if (!pn.equals(pkgName)) {\n-                    throw newIllegalArgumentException(cf.name + \" not in same package as lookup class\");\n-                }\n-                return cf;\n+            String name;\n+            ClassDesc sym;\n+            int accessFlags;\n+            try {\n+                ClassModel cm = ClassFile.of().parse(bytes);\n+                var thisClass = cm.thisClass();\n+                name = thisClass.asInternalName();\n+                sym = thisClass.asSymbol();\n+                accessFlags = cm.flags().flagsMask();\n+            } catch (IllegalArgumentException e) {\n+                ClassFormatError cfe = new ClassFormatError();\n+                cfe.initCause(e);\n+                throw cfe;\n+            }\n+            \/\/ must be a class or interface\n+            if ((accessFlags & ACC_MODULE) != 0) {\n+                throw newIllegalArgumentException(\"Not a class or interface: ACC_MODULE flag is set\");\n@@ -2279,27 +2288,3 @@\n-            private static ClassFile readClassFile(byte[] bytes) {\n-                int magic = readInt(bytes, 0);\n-                if (magic != 0xCAFEBABE) {\n-                    throw new ClassFormatError(\"Incompatible magic value: \" + magic);\n-                }\n-                int minor = readUnsignedShort(bytes, 4);\n-                int major = readUnsignedShort(bytes, 6);\n-                if (!VM.isSupportedClassFileVersion(major, minor)) {\n-                    throw new UnsupportedClassVersionError(\"Unsupported class file version \" + major + \".\" + minor);\n-                }\n-\n-                String name;\n-                int accessFlags;\n-                try {\n-                    ClassModel cm = java.lang.classfile.ClassFile.of().parse(bytes);\n-                    name = cm.thisClass().asInternalName();\n-                    accessFlags = cm.flags().flagsMask();\n-                } catch (IllegalArgumentException e) {\n-                    ClassFormatError cfe = new ClassFormatError();\n-                    cfe.initCause(e);\n-                    throw cfe;\n-                }\n-                \/\/ must be a class or interface\n-                if ((accessFlags & ACC_MODULE) != 0) {\n-                    throw newIllegalArgumentException(\"Not a class or interface: ACC_MODULE flag is set\");\n-                }\n-                return new ClassFile(name, accessFlags, bytes);\n+            String pn = sym.packageName();\n+            if (!pn.equals(pkgName)) {\n+                throw newIllegalArgumentException(name + \" not in same package as lookup class\");\n@@ -2308,8 +2293,6 @@\n-            private static int readInt(byte[] bytes, int offset) {\n-                if ((offset+4) > bytes.length) {\n-                    throw new ClassFormatError(\"Invalid ClassFile structure\");\n-                }\n-                return ((bytes[offset] & 0xFF) << 24)\n-                        | ((bytes[offset + 1] & 0xFF) << 16)\n-                        | ((bytes[offset + 2] & 0xFF) << 8)\n-                        | (bytes[offset + 3] & 0xFF);\n+            return name;\n+        }\n+\n+        private static int readInt(byte[] bytes, int offset) {\n+            if ((offset + 4) > bytes.length) {\n+                throw new ClassFormatError(\"Invalid ClassFile structure\");\n@@ -2317,0 +2300,5 @@\n+            return ((bytes[offset] & 0xFF) << 24)\n+                    | ((bytes[offset + 1] & 0xFF) << 16)\n+                    | ((bytes[offset + 2] & 0xFF) << 8)\n+                    | (bytes[offset + 3] & 0xFF);\n+        }\n@@ -2318,5 +2306,3 @@\n-            private static int readUnsignedShort(byte[] bytes, int offset) {\n-                if ((offset+2) > bytes.length) {\n-                    throw new ClassFormatError(\"Invalid ClassFile structure\");\n-                }\n-                return ((bytes[offset] & 0xFF) << 8) | (bytes[offset + 1] & 0xFF);\n+        private static int readUnsignedShort(byte[] bytes, int offset) {\n+            if ((offset+2) > bytes.length) {\n+                throw new ClassFormatError(\"Invalid ClassFile structure\");\n@@ -2324,0 +2310,1 @@\n+            return ((bytes[offset] & 0xFF) << 8) | (bytes[offset + 1] & 0xFF);\n@@ -2337,2 +2324,2 @@\n-            ClassFile cf = ClassFile.newInstance(bytes, lookupClass().getPackageName());\n-            return new ClassDefiner(this, cf, STRONG_LOADER_LINK, defaultDumper());\n+            var internalName = validateAndFindInternalName(bytes, lookupClass().getPackageName());\n+            return new ClassDefiner(this, internalName, bytes, STRONG_LOADER_LINK, defaultDumper());\n@@ -2345,1 +2332,1 @@\n-         * @param name    internal name\n+         * @param internalName internal name\n@@ -2350,1 +2337,1 @@\n-        ClassDefiner makeClassDefiner(String name, byte[] bytes, ClassFileDumper dumper) {\n+        ClassDefiner makeClassDefiner(String internalName, byte[] bytes, ClassFileDumper dumper) {\n@@ -2352,2 +2339,1 @@\n-            ClassFile cf = ClassFile.newInstanceNoCheck(name, bytes);\n-            return new ClassDefiner(this, cf, STRONG_LOADER_LINK, dumper);\n+            return new ClassDefiner(this, internalName, bytes, STRONG_LOADER_LINK, dumper);\n@@ -2371,2 +2357,2 @@\n-            ClassFile cf = ClassFile.newInstance(bytes, lookupClass().getPackageName());\n-            return makeHiddenClassDefiner(cf, false, dumper, 0);\n+            var internalName = validateAndFindInternalName(bytes, lookupClass().getPackageName());\n+            return makeHiddenClassDefiner(internalName, bytes, false, dumper, 0);\n@@ -2394,2 +2380,2 @@\n-            ClassFile cf = ClassFile.newInstance(bytes, lookupClass().getPackageName());\n-            return makeHiddenClassDefiner(cf, accessVmAnnotations, defaultDumper(), flags);\n+            var internalName = validateAndFindInternalName(bytes, lookupClass().getPackageName());\n+            return makeHiddenClassDefiner(internalName, bytes, accessVmAnnotations, defaultDumper(), flags);\n@@ -2402,1 +2388,1 @@\n-         * @param name    internal name that specifies the prefix of the hidden class\n+         * @param internalName internal name that specifies the prefix of the hidden class\n@@ -2407,1 +2393,1 @@\n-        ClassDefiner makeHiddenClassDefiner(String name, byte[] bytes, ClassFileDumper dumper) {\n+        ClassDefiner makeHiddenClassDefiner(String internalName, byte[] bytes, ClassFileDumper dumper) {\n@@ -2410,1 +2396,1 @@\n-            return makeHiddenClassDefiner(ClassFile.newInstanceNoCheck(name, bytes), false, dumper, 0);\n+            return makeHiddenClassDefiner(internalName, bytes, false, dumper, 0);\n@@ -2417,1 +2403,1 @@\n-         * @param name    internal name that specifies the prefix of the hidden class\n+         * @param internalName internal name that specifies the prefix of the hidden class\n@@ -2423,1 +2409,1 @@\n-        ClassDefiner makeHiddenClassDefiner(String name, byte[] bytes, ClassFileDumper dumper, int flags) {\n+        ClassDefiner makeHiddenClassDefiner(String internalName, byte[] bytes, ClassFileDumper dumper, int flags) {\n@@ -2426,1 +2412,1 @@\n-            return makeHiddenClassDefiner(ClassFile.newInstanceNoCheck(name, bytes), false, dumper, flags);\n+            return makeHiddenClassDefiner(internalName, bytes, false, dumper, flags);\n@@ -2433,1 +2419,2 @@\n-         * @param cf ClassFile\n+         * @param internalName internal name\n+         * @param bytes Class byte array\n@@ -2438,1 +2425,2 @@\n-        private ClassDefiner makeHiddenClassDefiner(ClassFile cf,\n+        private ClassDefiner makeHiddenClassDefiner(String internalName,\n+                                                    byte[] bytes,\n@@ -2449,1 +2437,1 @@\n-            return new ClassDefiner(this, cf, flags, dumper);\n+            return new ClassDefiner(this, internalName, bytes, flags, dumper);\n@@ -2452,18 +2440,3 @@\n-        static class ClassDefiner {\n-            private final Lookup lookup;\n-            private final String name;  \/\/ internal name\n-            private final byte[] bytes;\n-            private final int classFlags;\n-            private final ClassFileDumper dumper;\n-\n-            private ClassDefiner(Lookup lookup, ClassFile cf, int flags, ClassFileDumper dumper) {\n-                assert ((flags & HIDDEN_CLASS) != 0 || (flags & STRONG_LOADER_LINK) == STRONG_LOADER_LINK);\n-                this.lookup = lookup;\n-                this.bytes = cf.bytes;\n-                this.name = cf.name;\n-                this.classFlags = flags;\n-                this.dumper = dumper;\n-            }\n-\n-            String internalName() {\n-                return name;\n+        record ClassDefiner(Lookup lookup, String internalName, byte[] bytes, int classFlags, ClassFileDumper dumper) {\n+            ClassDefiner {\n+                assert ((classFlags & HIDDEN_CLASS) != 0 || (classFlags & STRONG_LOADER_LINK) == STRONG_LOADER_LINK);\n@@ -2498,1 +2471,1 @@\n-                            .defineClass(loader, lookupClass, name, bytes, pd, initialize, classFlags, classData);\n+                            .defineClass(loader, lookupClass, internalName, bytes, pd, initialize, classFlags, classData);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":79,"deletions":106,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.classfile.ClassFile;\n@@ -161,4 +162,0 @@\n-    private static int classFileMajorVersion;\n-    private static int classFileMinorVersion;\n-    private static final int PREVIEW_MINOR_VERSION = 65535;\n-\n@@ -178,1 +175,1 @@\n-        if (major < 45 || major > classFileMajorVersion) return false;\n+        if (major < ClassFile.JAVA_1_VERSION || major > ClassFile.latestMajorVersion()) return false;\n@@ -180,1 +177,1 @@\n-        if (major < 56) return true;\n+        if (major < ClassFile.JAVA_12_VERSION) return true;\n@@ -182,1 +179,1 @@\n-        return minor == 0 || minor == PREVIEW_MINOR_VERSION;\n+        return minor == 0 || (minor == ClassFile.PREVIEW_MINOR_VERSION && major == ClassFile.latestMajorVersion());\n@@ -192,6 +189,2 @@\n-        if (major < 53 || major > classFileMajorVersion) return false;\n-        \/\/ for major version is between 45 and 55 inclusive, the minor version may be any value\n-        if (major < 56) return true;\n-        \/\/ otherwise, the minor version must be 0 or 65535\n-        \/\/ preview features do not apply to module-info.class but JVMS allows it\n-        return minor == 0 || minor == PREVIEW_MINOR_VERSION;\n+        if (major < ClassFile.JAVA_9_VERSION) return false;\n+        return isSupportedClassFileVersion(major, minor);\n@@ -274,9 +267,0 @@\n-\n-        s = props.get(\"java.class.version\");\n-        int index = s.indexOf('.');\n-        try {\n-            classFileMajorVersion = Integer.parseInt(s.substring(0, index));\n-            classFileMinorVersion = Integer.parseInt(s.substring(index + 1));\n-        } catch (NumberFormatException e) {\n-            throw new InternalError(e);\n-        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/VM.java","additions":6,"deletions":22,"binary":false,"changes":28,"status":"modified"}]}